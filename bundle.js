/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 563:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `body {
  margin: 0;
  padding: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  /* background-color: black; */
  touch-action: none;
}
html {
  touch-action: none;
  width: 100%;
  height: 100%;
}
body{
  margin: 0px;
  width: 100%;
  height: 100%;
}

canvas {
  max-width: 100%;
  max-height: 100%;
  /* width: 100%;
  height: 100%; */
  touch-action: none;
}
`, "",{"version":3,"sources":["webpack://./public/style.css"],"names":[],"mappings":"AAAA;EACE,SAAS;EACT,UAAU;EACV,YAAY;EACZ,aAAa;EACb,gBAAgB;EAChB,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,6BAA6B;EAC7B,kBAAkB;AACpB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,WAAW;EACX,WAAW;EACX,YAAY;AACd;;AAEA;EACE,eAAe;EACf,gBAAgB;EAChB;iBACe;EACf,kBAAkB;AACpB","sourcesContent":["body {\n  margin: 0;\n  padding: 0;\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /* background-color: black; */\n  touch-action: none;\n}\nhtml {\n  touch-action: none;\n  width: 100%;\n  height: 100%;\n}\nbody{\n  margin: 0px;\n  width: 100%;\n  height: 100%;\n}\n\ncanvas {\n  max-width: 100%;\n  max-height: 100%;\n  /* width: 100%;\n  height: 100%; */\n  touch-action: none;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 352:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 864:
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ 956:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

!function(e,t){ true?t(exports):0}(this,(function(e){"use strict";function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){for(var r=0;t.length>r;r++){var i=t[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function i(e,t,i){return t&&r(e.prototype,t),i&&r(e,i),e}function s(e){return(s=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function n(e,t){return(n=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function a(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}function o(e,t,r){return(o=a()?Reflect.construct:function(e,t,r){var i=[null];i.push.apply(i,t);var s=new(Function.bind.apply(e,i));return r&&n(s,r.prototype),s}).apply(null,arguments)}function u(e){var t="function"==typeof Map?new Map:void 0;return(u=function(e){if(null===e||-1===Function.toString.call(e).indexOf("[native code]"))return e;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return o(e,arguments,s(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n(r,e)})(e)}function c(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}var p="app",l="user",f="team",m="dropboxapi.com",h="dropbox.com",d={api:"api",notify:"bolt",content:"api-content"},_={};function g(e){var t="000".concat(e.charCodeAt(0).toString(16)).slice(-4);return"\\u".concat(t)}_.accountSetProfilePhoto=function(e){return this.request("account/set_profile_photo",e,"user","api","rpc","account_info.write")},_.authTokenFromOauth1=function(e){return this.request("auth/token/from_oauth1",e,"app","api","rpc",null)},_.authTokenRevoke=function(){return this.request("auth/token/revoke",null,"user","api","rpc",null)},_.checkApp=function(e){return this.request("check/app",e,"app","api","rpc",null)},_.checkUser=function(e){return this.request("check/user",e,"user","api","rpc","account_info.read")},_.contactsDeleteManualContacts=function(){return this.request("contacts/delete_manual_contacts",null,"user","api","rpc","contacts.write")},_.contactsDeleteManualContactsBatch=function(e){return this.request("contacts/delete_manual_contacts_batch",e,"user","api","rpc","contacts.write")},_.filePropertiesPropertiesAdd=function(e){return this.request("file_properties/properties/add",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesOverwrite=function(e){return this.request("file_properties/properties/overwrite",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesRemove=function(e){return this.request("file_properties/properties/remove",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesSearch=function(e){return this.request("file_properties/properties/search",e,"user","api","rpc","files.metadata.read")},_.filePropertiesPropertiesSearchContinue=function(e){return this.request("file_properties/properties/search/continue",e,"user","api","rpc","files.metadata.read")},_.filePropertiesPropertiesUpdate=function(e){return this.request("file_properties/properties/update",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesAddForTeam=function(e){return this.request("file_properties/templates/add_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesAddForUser=function(e){return this.request("file_properties/templates/add_for_user",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesGetForTeam=function(e){return this.request("file_properties/templates/get_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesGetForUser=function(e){return this.request("file_properties/templates/get_for_user",e,"user","api","rpc","files.metadata.read")},_.filePropertiesTemplatesListForTeam=function(){return this.request("file_properties/templates/list_for_team",null,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesListForUser=function(){return this.request("file_properties/templates/list_for_user",null,"user","api","rpc","files.metadata.read")},_.filePropertiesTemplatesRemoveForTeam=function(e){return this.request("file_properties/templates/remove_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesRemoveForUser=function(e){return this.request("file_properties/templates/remove_for_user",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesUpdateForTeam=function(e){return this.request("file_properties/templates/update_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesUpdateForUser=function(e){return this.request("file_properties/templates/update_for_user",e,"user","api","rpc","files.metadata.write")},_.fileRequestsCount=function(){return this.request("file_requests/count",null,"user","api","rpc","file_requests.read")},_.fileRequestsCreate=function(e){return this.request("file_requests/create",e,"user","api","rpc","file_requests.write")},_.fileRequestsDelete=function(e){return this.request("file_requests/delete",e,"user","api","rpc","file_requests.write")},_.fileRequestsDeleteAllClosed=function(){return this.request("file_requests/delete_all_closed",null,"user","api","rpc","file_requests.write")},_.fileRequestsGet=function(e){return this.request("file_requests/get",e,"user","api","rpc","file_requests.read")},_.fileRequestsListV2=function(e){return this.request("file_requests/list_v2",e,"user","api","rpc","file_requests.read")},_.fileRequestsList=function(){return this.request("file_requests/list",null,"user","api","rpc","file_requests.read")},_.fileRequestsListContinue=function(e){return this.request("file_requests/list/continue",e,"user","api","rpc","file_requests.read")},_.fileRequestsUpdate=function(e){return this.request("file_requests/update",e,"user","api","rpc","file_requests.write")},_.filesAlphaGetMetadata=function(e){return this.request("files/alpha/get_metadata",e,"user","api","rpc","files.metadata.read")},_.filesAlphaUpload=function(e){return this.request("files/alpha/upload",e,"user","content","upload","files.content.write")},_.filesCopyV2=function(e){return this.request("files/copy_v2",e,"user","api","rpc","files.content.write")},_.filesCopy=function(e){return this.request("files/copy",e,"user","api","rpc","files.content.write")},_.filesCopyBatchV2=function(e){return this.request("files/copy_batch_v2",e,"user","api","rpc","files.content.write")},_.filesCopyBatch=function(e){return this.request("files/copy_batch",e,"user","api","rpc","files.content.write")},_.filesCopyBatchCheckV2=function(e){return this.request("files/copy_batch/check_v2",e,"user","api","rpc","files.content.write")},_.filesCopyBatchCheck=function(e){return this.request("files/copy_batch/check",e,"user","api","rpc","files.content.write")},_.filesCopyReferenceGet=function(e){return this.request("files/copy_reference/get",e,"user","api","rpc","files.content.write")},_.filesCopyReferenceSave=function(e){return this.request("files/copy_reference/save",e,"user","api","rpc","files.content.write")},_.filesCreateFolderV2=function(e){return this.request("files/create_folder_v2",e,"user","api","rpc","files.content.write")},_.filesCreateFolder=function(e){return this.request("files/create_folder",e,"user","api","rpc","files.content.write")},_.filesCreateFolderBatch=function(e){return this.request("files/create_folder_batch",e,"user","api","rpc","files.content.write")},_.filesCreateFolderBatchCheck=function(e){return this.request("files/create_folder_batch/check",e,"user","api","rpc","files.content.write")},_.filesDeleteV2=function(e){return this.request("files/delete_v2",e,"user","api","rpc","files.content.write")},_.filesDelete=function(e){return this.request("files/delete",e,"user","api","rpc","files.content.write")},_.filesDeleteBatch=function(e){return this.request("files/delete_batch",e,"user","api","rpc","files.content.write")},_.filesDeleteBatchCheck=function(e){return this.request("files/delete_batch/check",e,"user","api","rpc","files.content.write")},_.filesDownload=function(e){return this.request("files/download",e,"user","content","download","files.content.read")},_.filesDownloadZip=function(e){return this.request("files/download_zip",e,"user","content","download","files.content.read")},_.filesExport=function(e){return this.request("files/export",e,"user","content","download","files.content.read")},_.filesGetFileLockBatch=function(e){return this.request("files/get_file_lock_batch",e,"user","api","rpc","files.content.read")},_.filesGetMetadata=function(e){return this.request("files/get_metadata",e,"user","api","rpc","files.metadata.read")},_.filesGetPreview=function(e){return this.request("files/get_preview",e,"user","content","download","files.content.read")},_.filesGetTemporaryLink=function(e){return this.request("files/get_temporary_link",e,"user","api","rpc","files.content.read")},_.filesGetTemporaryUploadLink=function(e){return this.request("files/get_temporary_upload_link",e,"user","api","rpc","files.content.write")},_.filesGetThumbnail=function(e){return this.request("files/get_thumbnail",e,"user","content","download","files.content.read")},_.filesGetThumbnailV2=function(e){return this.request("files/get_thumbnail_v2",e,"app, user","content","download","files.content.read")},_.filesGetThumbnailBatch=function(e){return this.request("files/get_thumbnail_batch",e,"user","content","rpc","files.content.read")},_.filesListFolder=function(e){return this.request("files/list_folder",e,"app, user","api","rpc","files.metadata.read")},_.filesListFolderContinue=function(e){return this.request("files/list_folder/continue",e,"app, user","api","rpc","files.metadata.read")},_.filesListFolderGetLatestCursor=function(e){return this.request("files/list_folder/get_latest_cursor",e,"user","api","rpc","files.metadata.read")},_.filesListFolderLongpoll=function(e){return this.request("files/list_folder/longpoll",e,"noauth","notify","rpc","files.metadata.read")},_.filesListRevisions=function(e){return this.request("files/list_revisions",e,"user","api","rpc","files.metadata.read")},_.filesLockFileBatch=function(e){return this.request("files/lock_file_batch",e,"user","api","rpc","files.content.write")},_.filesMoveV2=function(e){return this.request("files/move_v2",e,"user","api","rpc","files.content.write")},_.filesMove=function(e){return this.request("files/move",e,"user","api","rpc","files.content.write")},_.filesMoveBatchV2=function(e){return this.request("files/move_batch_v2",e,"user","api","rpc","files.content.write")},_.filesMoveBatch=function(e){return this.request("files/move_batch",e,"user","api","rpc","files.content.write")},_.filesMoveBatchCheckV2=function(e){return this.request("files/move_batch/check_v2",e,"user","api","rpc","files.content.write")},_.filesMoveBatchCheck=function(e){return this.request("files/move_batch/check",e,"user","api","rpc","files.content.write")},_.filesPaperCreate=function(e){return this.request("files/paper/create",e,"user","api","upload","files.content.write")},_.filesPaperUpdate=function(e){return this.request("files/paper/update",e,"user","api","upload","files.content.write")},_.filesPermanentlyDelete=function(e){return this.request("files/permanently_delete",e,"user","api","rpc","files.permanent_delete")},_.filesPropertiesAdd=function(e){return this.request("files/properties/add",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesOverwrite=function(e){return this.request("files/properties/overwrite",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesRemove=function(e){return this.request("files/properties/remove",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesTemplateGet=function(e){return this.request("files/properties/template/get",e,"user","api","rpc","files.metadata.read")},_.filesPropertiesTemplateList=function(){return this.request("files/properties/template/list",null,"user","api","rpc","files.metadata.read")},_.filesPropertiesUpdate=function(e){return this.request("files/properties/update",e,"user","api","rpc","files.metadata.write")},_.filesRestore=function(e){return this.request("files/restore",e,"user","api","rpc","files.content.write")},_.filesSaveUrl=function(e){return this.request("files/save_url",e,"user","api","rpc","files.content.write")},_.filesSaveUrlCheckJobStatus=function(e){return this.request("files/save_url/check_job_status",e,"user","api","rpc","files.content.write")},_.filesSearch=function(e){return this.request("files/search",e,"user","api","rpc","files.metadata.read")},_.filesSearchV2=function(e){return this.request("files/search_v2",e,"user","api","rpc","files.metadata.read")},_.filesSearchContinueV2=function(e){return this.request("files/search/continue_v2",e,"user","api","rpc","files.metadata.read")},_.filesTagsAdd=function(e){return this.request("files/tags/add",e,"user","api","rpc","files.metadata.write")},_.filesTagsGet=function(e){return this.request("files/tags/get",e,"user","api","rpc","files.metadata.read")},_.filesTagsRemove=function(e){return this.request("files/tags/remove",e,"user","api","rpc","files.metadata.write")},_.filesUnlockFileBatch=function(e){return this.request("files/unlock_file_batch",e,"user","api","rpc","files.content.write")},_.filesUpload=function(e){return this.request("files/upload",e,"user","content","upload","files.content.write")},_.filesUploadSessionAppendV2=function(e){return this.request("files/upload_session/append_v2",e,"user","content","upload","files.content.write")},_.filesUploadSessionAppend=function(e){return this.request("files/upload_session/append",e,"user","content","upload","files.content.write")},_.filesUploadSessionFinish=function(e){return this.request("files/upload_session/finish",e,"user","content","upload","files.content.write")},_.filesUploadSessionFinishBatch=function(e){return this.request("files/upload_session/finish_batch",e,"user","api","rpc","files.content.write")},_.filesUploadSessionFinishBatchV2=function(e){return this.request("files/upload_session/finish_batch_v2",e,"user","api","rpc","files.content.write")},_.filesUploadSessionFinishBatchCheck=function(e){return this.request("files/upload_session/finish_batch/check",e,"user","api","rpc","files.content.write")},_.filesUploadSessionStart=function(e){return this.request("files/upload_session/start",e,"user","content","upload","files.content.write")},_.filesUploadSessionStartBatch=function(e){return this.request("files/upload_session/start_batch",e,"user","api","rpc","files.content.write")},_.openidUserinfo=function(e){return this.request("openid/userinfo",e,"user","api","rpc","openid")},_.paperDocsArchive=function(e){return this.request("paper/docs/archive",e,"user","api","rpc","files.content.write")},_.paperDocsCreate=function(e){return this.request("paper/docs/create",e,"user","api","upload","files.content.write")},_.paperDocsDownload=function(e){return this.request("paper/docs/download",e,"user","api","download","files.content.read")},_.paperDocsFolderUsersList=function(e){return this.request("paper/docs/folder_users/list",e,"user","api","rpc","sharing.read")},_.paperDocsFolderUsersListContinue=function(e){return this.request("paper/docs/folder_users/list/continue",e,"user","api","rpc","sharing.read")},_.paperDocsGetFolderInfo=function(e){return this.request("paper/docs/get_folder_info",e,"user","api","rpc","sharing.read")},_.paperDocsList=function(e){return this.request("paper/docs/list",e,"user","api","rpc","files.metadata.read")},_.paperDocsListContinue=function(e){return this.request("paper/docs/list/continue",e,"user","api","rpc","files.metadata.read")},_.paperDocsPermanentlyDelete=function(e){return this.request("paper/docs/permanently_delete",e,"user","api","rpc","files.permanent_delete")},_.paperDocsSharingPolicyGet=function(e){return this.request("paper/docs/sharing_policy/get",e,"user","api","rpc","sharing.read")},_.paperDocsSharingPolicySet=function(e){return this.request("paper/docs/sharing_policy/set",e,"user","api","rpc","sharing.write")},_.paperDocsUpdate=function(e){return this.request("paper/docs/update",e,"user","api","upload","files.content.write")},_.paperDocsUsersAdd=function(e){return this.request("paper/docs/users/add",e,"user","api","rpc","sharing.write")},_.paperDocsUsersList=function(e){return this.request("paper/docs/users/list",e,"user","api","rpc","sharing.read")},_.paperDocsUsersListContinue=function(e){return this.request("paper/docs/users/list/continue",e,"user","api","rpc","sharing.read")},_.paperDocsUsersRemove=function(e){return this.request("paper/docs/users/remove",e,"user","api","rpc","sharing.write")},_.paperFoldersCreate=function(e){return this.request("paper/folders/create",e,"user","api","rpc","files.content.write")},_.sharingAddFileMember=function(e){return this.request("sharing/add_file_member",e,"user","api","rpc","sharing.write")},_.sharingAddFolderMember=function(e){return this.request("sharing/add_folder_member",e,"user","api","rpc","sharing.write")},_.sharingCheckJobStatus=function(e){return this.request("sharing/check_job_status",e,"user","api","rpc","sharing.write")},_.sharingCheckRemoveMemberJobStatus=function(e){return this.request("sharing/check_remove_member_job_status",e,"user","api","rpc","sharing.write")},_.sharingCheckShareJobStatus=function(e){return this.request("sharing/check_share_job_status",e,"user","api","rpc","sharing.write")},_.sharingCreateSharedLink=function(e){return this.request("sharing/create_shared_link",e,"user","api","rpc","sharing.write")},_.sharingCreateSharedLinkWithSettings=function(e){return this.request("sharing/create_shared_link_with_settings",e,"user","api","rpc","sharing.write")},_.sharingGetFileMetadata=function(e){return this.request("sharing/get_file_metadata",e,"user","api","rpc","sharing.read")},_.sharingGetFileMetadataBatch=function(e){return this.request("sharing/get_file_metadata/batch",e,"user","api","rpc","sharing.read")},_.sharingGetFolderMetadata=function(e){return this.request("sharing/get_folder_metadata",e,"user","api","rpc","sharing.read")},_.sharingGetSharedLinkFile=function(e){return this.request("sharing/get_shared_link_file",e,"user","content","download","sharing.read")},_.sharingGetSharedLinkMetadata=function(e){return this.request("sharing/get_shared_link_metadata",e,"app, user","api","rpc","sharing.read")},_.sharingGetSharedLinks=function(e){return this.request("sharing/get_shared_links",e,"user","api","rpc","sharing.read")},_.sharingListFileMembers=function(e){return this.request("sharing/list_file_members",e,"user","api","rpc","sharing.read")},_.sharingListFileMembersBatch=function(e){return this.request("sharing/list_file_members/batch",e,"user","api","rpc","sharing.read")},_.sharingListFileMembersContinue=function(e){return this.request("sharing/list_file_members/continue",e,"user","api","rpc","sharing.read")},_.sharingListFolderMembers=function(e){return this.request("sharing/list_folder_members",e,"user","api","rpc","sharing.read")},_.sharingListFolderMembersContinue=function(e){return this.request("sharing/list_folder_members/continue",e,"user","api","rpc","sharing.read")},_.sharingListFolders=function(e){return this.request("sharing/list_folders",e,"user","api","rpc","sharing.read")},_.sharingListFoldersContinue=function(e){return this.request("sharing/list_folders/continue",e,"user","api","rpc","sharing.read")},_.sharingListMountableFolders=function(e){return this.request("sharing/list_mountable_folders",e,"user","api","rpc","sharing.read")},_.sharingListMountableFoldersContinue=function(e){return this.request("sharing/list_mountable_folders/continue",e,"user","api","rpc","sharing.read")},_.sharingListReceivedFiles=function(e){return this.request("sharing/list_received_files",e,"user","api","rpc","sharing.read")},_.sharingListReceivedFilesContinue=function(e){return this.request("sharing/list_received_files/continue",e,"user","api","rpc","sharing.read")},_.sharingListSharedLinks=function(e){return this.request("sharing/list_shared_links",e,"user","api","rpc","sharing.read")},_.sharingModifySharedLinkSettings=function(e){return this.request("sharing/modify_shared_link_settings",e,"user","api","rpc","sharing.write")},_.sharingMountFolder=function(e){return this.request("sharing/mount_folder",e,"user","api","rpc","sharing.write")},_.sharingRelinquishFileMembership=function(e){return this.request("sharing/relinquish_file_membership",e,"user","api","rpc","sharing.write")},_.sharingRelinquishFolderMembership=function(e){return this.request("sharing/relinquish_folder_membership",e,"user","api","rpc","sharing.write")},_.sharingRemoveFileMember=function(e){return this.request("sharing/remove_file_member",e,"user","api","rpc","sharing.write")},_.sharingRemoveFileMember2=function(e){return this.request("sharing/remove_file_member_2",e,"user","api","rpc","sharing.write")},_.sharingRemoveFolderMember=function(e){return this.request("sharing/remove_folder_member",e,"user","api","rpc","sharing.write")},_.sharingRevokeSharedLink=function(e){return this.request("sharing/revoke_shared_link",e,"user","api","rpc","sharing.write")},_.sharingSetAccessInheritance=function(e){return this.request("sharing/set_access_inheritance",e,"user","api","rpc","sharing.write")},_.sharingShareFolder=function(e){return this.request("sharing/share_folder",e,"user","api","rpc","sharing.write")},_.sharingTransferFolder=function(e){return this.request("sharing/transfer_folder",e,"user","api","rpc","sharing.write")},_.sharingUnmountFolder=function(e){return this.request("sharing/unmount_folder",e,"user","api","rpc","sharing.write")},_.sharingUnshareFile=function(e){return this.request("sharing/unshare_file",e,"user","api","rpc","sharing.write")},_.sharingUnshareFolder=function(e){return this.request("sharing/unshare_folder",e,"user","api","rpc","sharing.write")},_.sharingUpdateFileMember=function(e){return this.request("sharing/update_file_member",e,"user","api","rpc","sharing.write")},_.sharingUpdateFolderMember=function(e){return this.request("sharing/update_folder_member",e,"user","api","rpc","sharing.write")},_.sharingUpdateFolderPolicy=function(e){return this.request("sharing/update_folder_policy",e,"user","api","rpc","sharing.write")},_.teamDevicesListMemberDevices=function(e){return this.request("team/devices/list_member_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesListMembersDevices=function(e){return this.request("team/devices/list_members_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesListTeamDevices=function(e){return this.request("team/devices/list_team_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesRevokeDeviceSession=function(e){return this.request("team/devices/revoke_device_session",e,"team","api","rpc","sessions.modify")},_.teamDevicesRevokeDeviceSessionBatch=function(e){return this.request("team/devices/revoke_device_session_batch",e,"team","api","rpc","sessions.modify")},_.teamFeaturesGetValues=function(e){return this.request("team/features/get_values",e,"team","api","rpc","team_info.read")},_.teamGetInfo=function(){return this.request("team/get_info",null,"team","api","rpc","team_info.read")},_.teamGroupsCreate=function(e){return this.request("team/groups/create",e,"team","api","rpc","groups.write")},_.teamGroupsDelete=function(e){return this.request("team/groups/delete",e,"team","api","rpc","groups.write")},_.teamGroupsGetInfo=function(e){return this.request("team/groups/get_info",e,"team","api","rpc","groups.read")},_.teamGroupsJobStatusGet=function(e){return this.request("team/groups/job_status/get",e,"team","api","rpc","groups.write")},_.teamGroupsList=function(e){return this.request("team/groups/list",e,"team","api","rpc","groups.read")},_.teamGroupsListContinue=function(e){return this.request("team/groups/list/continue",e,"team","api","rpc","groups.read")},_.teamGroupsMembersAdd=function(e){return this.request("team/groups/members/add",e,"team","api","rpc","groups.write")},_.teamGroupsMembersList=function(e){return this.request("team/groups/members/list",e,"team","api","rpc","groups.read")},_.teamGroupsMembersListContinue=function(e){return this.request("team/groups/members/list/continue",e,"team","api","rpc","groups.read")},_.teamGroupsMembersRemove=function(e){return this.request("team/groups/members/remove",e,"team","api","rpc","groups.write")},_.teamGroupsMembersSetAccessType=function(e){return this.request("team/groups/members/set_access_type",e,"team","api","rpc","groups.write")},_.teamGroupsUpdate=function(e){return this.request("team/groups/update",e,"team","api","rpc","groups.write")},_.teamLegalHoldsCreatePolicy=function(e){return this.request("team/legal_holds/create_policy",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsGetPolicy=function(e){return this.request("team/legal_holds/get_policy",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsListHeldRevisions=function(e){return this.request("team/legal_holds/list_held_revisions",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsListHeldRevisionsContinue=function(e){return this.request("team/legal_holds/list_held_revisions_continue",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsListPolicies=function(e){return this.request("team/legal_holds/list_policies",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsReleasePolicy=function(e){return this.request("team/legal_holds/release_policy",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsUpdatePolicy=function(e){return this.request("team/legal_holds/update_policy",e,"team","api","rpc","team_data.governance.write")},_.teamLinkedAppsListMemberLinkedApps=function(e){return this.request("team/linked_apps/list_member_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsListMembersLinkedApps=function(e){return this.request("team/linked_apps/list_members_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsListTeamLinkedApps=function(e){return this.request("team/linked_apps/list_team_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsRevokeLinkedApp=function(e){return this.request("team/linked_apps/revoke_linked_app",e,"team","api","rpc","sessions.modify")},_.teamLinkedAppsRevokeLinkedAppBatch=function(e){return this.request("team/linked_apps/revoke_linked_app_batch",e,"team","api","rpc","sessions.modify")},_.teamMemberSpaceLimitsExcludedUsersAdd=function(e){return this.request("team/member_space_limits/excluded_users/add",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsExcludedUsersList=function(e){return this.request("team/member_space_limits/excluded_users/list",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsExcludedUsersListContinue=function(e){return this.request("team/member_space_limits/excluded_users/list/continue",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsExcludedUsersRemove=function(e){return this.request("team/member_space_limits/excluded_users/remove",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsGetCustomQuota=function(e){return this.request("team/member_space_limits/get_custom_quota",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsRemoveCustomQuota=function(e){return this.request("team/member_space_limits/remove_custom_quota",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsSetCustomQuota=function(e){return this.request("team/member_space_limits/set_custom_quota",e,"team","api","rpc","members.read")},_.teamMembersAddV2=function(e){return this.request("team/members/add_v2",e,"team","api","rpc","members.write")},_.teamMembersAdd=function(e){return this.request("team/members/add",e,"team","api","rpc","members.write")},_.teamMembersAddJobStatusGetV2=function(e){return this.request("team/members/add/job_status/get_v2",e,"team","api","rpc","members.write")},_.teamMembersAddJobStatusGet=function(e){return this.request("team/members/add/job_status/get",e,"team","api","rpc","members.write")},_.teamMembersDeleteProfilePhotoV2=function(e){return this.request("team/members/delete_profile_photo_v2",e,"team","api","rpc","members.write")},_.teamMembersDeleteProfilePhoto=function(e){return this.request("team/members/delete_profile_photo",e,"team","api","rpc","members.write")},_.teamMembersGetAvailableTeamMemberRoles=function(){return this.request("team/members/get_available_team_member_roles",null,"team","api","rpc","members.read")},_.teamMembersGetInfoV2=function(e){return this.request("team/members/get_info_v2",e,"team","api","rpc","members.read")},_.teamMembersGetInfo=function(e){return this.request("team/members/get_info",e,"team","api","rpc","members.read")},_.teamMembersListV2=function(e){return this.request("team/members/list_v2",e,"team","api","rpc","members.read")},_.teamMembersList=function(e){return this.request("team/members/list",e,"team","api","rpc","members.read")},_.teamMembersListContinueV2=function(e){return this.request("team/members/list/continue_v2",e,"team","api","rpc","members.read")},_.teamMembersListContinue=function(e){return this.request("team/members/list/continue",e,"team","api","rpc","members.read")},_.teamMembersMoveFormerMemberFiles=function(e){return this.request("team/members/move_former_member_files",e,"team","api","rpc","members.write")},_.teamMembersMoveFormerMemberFilesJobStatusCheck=function(e){return this.request("team/members/move_former_member_files/job_status/check",e,"team","api","rpc","members.write")},_.teamMembersRecover=function(e){return this.request("team/members/recover",e,"team","api","rpc","members.delete")},_.teamMembersRemove=function(e){return this.request("team/members/remove",e,"team","api","rpc","members.delete")},_.teamMembersRemoveJobStatusGet=function(e){return this.request("team/members/remove/job_status/get",e,"team","api","rpc","members.delete")},_.teamMembersSecondaryEmailsAdd=function(e){return this.request("team/members/secondary_emails/add",e,"team","api","rpc","members.write")},_.teamMembersSecondaryEmailsDelete=function(e){return this.request("team/members/secondary_emails/delete",e,"team","api","rpc","members.write")},_.teamMembersSecondaryEmailsResendVerificationEmails=function(e){return this.request("team/members/secondary_emails/resend_verification_emails",e,"team","api","rpc","members.write")},_.teamMembersSendWelcomeEmail=function(e){return this.request("team/members/send_welcome_email",e,"team","api","rpc","members.write")},_.teamMembersSetAdminPermissionsV2=function(e){return this.request("team/members/set_admin_permissions_v2",e,"team","api","rpc","members.write")},_.teamMembersSetAdminPermissions=function(e){return this.request("team/members/set_admin_permissions",e,"team","api","rpc","members.write")},_.teamMembersSetProfileV2=function(e){return this.request("team/members/set_profile_v2",e,"team","api","rpc","members.write")},_.teamMembersSetProfile=function(e){return this.request("team/members/set_profile",e,"team","api","rpc","members.write")},_.teamMembersSetProfilePhotoV2=function(e){return this.request("team/members/set_profile_photo_v2",e,"team","api","rpc","members.write")},_.teamMembersSetProfilePhoto=function(e){return this.request("team/members/set_profile_photo",e,"team","api","rpc","members.write")},_.teamMembersSuspend=function(e){return this.request("team/members/suspend",e,"team","api","rpc","members.write")},_.teamMembersUnsuspend=function(e){return this.request("team/members/unsuspend",e,"team","api","rpc","members.write")},_.teamNamespacesList=function(e){return this.request("team/namespaces/list",e,"team","api","rpc","team_data.member")},_.teamNamespacesListContinue=function(e){return this.request("team/namespaces/list/continue",e,"team","api","rpc","team_data.member")},_.teamPropertiesTemplateAdd=function(e){return this.request("team/properties/template/add",e,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateGet=function(e){return this.request("team/properties/template/get",e,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateList=function(){return this.request("team/properties/template/list",null,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateUpdate=function(e){return this.request("team/properties/template/update",e,"team","api","rpc","files.team_metadata.write")},_.teamReportsGetActivity=function(e){return this.request("team/reports/get_activity",e,"team","api","rpc","team_info.read")},_.teamReportsGetDevices=function(e){return this.request("team/reports/get_devices",e,"team","api","rpc","team_info.read")},_.teamReportsGetMembership=function(e){return this.request("team/reports/get_membership",e,"team","api","rpc","team_info.read")},_.teamReportsGetStorage=function(e){return this.request("team/reports/get_storage",e,"team","api","rpc","team_info.read")},_.teamSharingAllowlistAdd=function(e){return this.request("team/sharing_allowlist/add",e,"team","api","rpc","team_info.write")},_.teamSharingAllowlistList=function(e){return this.request("team/sharing_allowlist/list",e,"team","api","rpc","team_info.read")},_.teamSharingAllowlistListContinue=function(e){return this.request("team/sharing_allowlist/list/continue",e,"team","api","rpc","team_info.read")},_.teamSharingAllowlistRemove=function(e){return this.request("team/sharing_allowlist/remove",e,"team","api","rpc","team_info.write")},_.teamTeamFolderActivate=function(e){return this.request("team/team_folder/activate",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderArchive=function(e){return this.request("team/team_folder/archive",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderArchiveCheck=function(e){return this.request("team/team_folder/archive/check",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderCreate=function(e){return this.request("team/team_folder/create",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderGetInfo=function(e){return this.request("team/team_folder/get_info",e,"team","api","rpc","team_data.content.read")},_.teamTeamFolderList=function(e){return this.request("team/team_folder/list",e,"team","api","rpc","team_data.content.read")},_.teamTeamFolderListContinue=function(e){return this.request("team/team_folder/list/continue",e,"team","api","rpc","team_data.content.read")},_.teamTeamFolderPermanentlyDelete=function(e){return this.request("team/team_folder/permanently_delete",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderRename=function(e){return this.request("team/team_folder/rename",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderUpdateSyncSettings=function(e){return this.request("team/team_folder/update_sync_settings",e,"team","api","rpc","team_data.content.write")},_.teamTokenGetAuthenticatedAdmin=function(){return this.request("team/token/get_authenticated_admin",null,"team","api","rpc","team_info.read")},_.teamLogGetEvents=function(e){return this.request("team_log/get_events",e,"team","api","rpc","events.read")},_.teamLogGetEventsContinue=function(e){return this.request("team_log/get_events/continue",e,"team","api","rpc","events.read")},_.usersFeaturesGetValues=function(e){return this.request("users/features/get_values",e,"user","api","rpc","account_info.read")},_.usersGetAccount=function(e){return this.request("users/get_account",e,"user","api","rpc","sharing.read")},_.usersGetAccountBatch=function(e){return this.request("users/get_account_batch",e,"user","api","rpc","sharing.read")},_.usersGetCurrentAccount=function(){return this.request("users/get_current_account",null,"user","api","rpc","account_info.read")},_.usersGetSpaceUsage=function(){return this.request("users/get_space_usage",null,"user","api","rpc","account_info.read")};var q=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:".";return r?(t!==m&&void 0!==d[e]&&(e=d[e],r="-"),"https://".concat(e).concat(r).concat(t,"/2/")):"https://".concat(t,"/2/")},b=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:h;return e!==h&&(e="meta-".concat(e)),"https://".concat(e,"/oauth2/authorize")},v=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:".",r="api";return e!==m&&(r=d[r],t="-"),"https://".concat(r).concat(t).concat(e,"/oauth2/token")};function w(e){return JSON.stringify(e).replace(/[\u007f-\uffff]/g,g)}function k(e){return new Date(Date.now()+1e3*e)}function y(){return"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope||"undefined"=="object"||"undefined"!=typeof window}function A(){return"undefined"!=typeof window}function S(){return"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope}function C(e){return e.toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}var T,L,M,P=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&n(e,t)}(u,e);var r,i,o=(r=u,i=a(),function(){var e,t=s(r);if(i){var n=s(this).constructor;e=Reflect.construct(t,arguments,n)}else e=t.apply(this,arguments);return c(this,e)});function u(e,r,i){var s;return t(this,u),(s=o.call(this,"Response failed with a ".concat(e," code"))).name="DropboxResponseError",s.status=e,s.headers=r,s.error=i,s}return u}(u(Error)),R=function e(r,i,s){t(this,e),this.status=r,this.headers=i,this.result=s};function F(e){return e.text().then((function(t){var r;try{r=JSON.parse(t)}catch(e){r=t}throw new P(e.status,e.headers,r)}))}function D(e){return e.ok?e.text().then((function(t){var r;try{r=JSON.parse(t)}catch(e){r=t}return new R(e.status,e.headers,r)})):F(e)}var G=["legacy","offline","online"],U=["code","token"],x=["none","user","team"],E=function(){function e(r){t(this,e),r=r||{},A()?(T=window.fetch.bind(window),L=window.crypto||window.msCrypto):S()?(T=self.fetch.bind(self),L=self.crypto):(T=__webpack_require__(898),L=__webpack_require__(90)),M="undefined"==typeof TextEncoder?(__webpack_require__(974).TextEncoder):TextEncoder,this.fetch=r.fetch||T,this.accessToken=r.accessToken,this.accessTokenExpiresAt=r.accessTokenExpiresAt,this.refreshToken=r.refreshToken,this.clientId=r.clientId,this.clientSecret=r.clientSecret,this.domain=r.domain,this.domainDelimiter=r.domainDelimiter,this.customHeaders=r.customHeaders,this.dataOnBody=r.dataOnBody}return i(e,[{key:"setAccessToken",value:function(e){this.accessToken=e}},{key:"getAccessToken",value:function(){return this.accessToken}},{key:"setClientId",value:function(e){this.clientId=e}},{key:"getClientId",value:function(){return this.clientId}},{key:"setClientSecret",value:function(e){this.clientSecret=e}},{key:"getClientSecret",value:function(){return this.clientSecret}},{key:"getRefreshToken",value:function(){return this.refreshToken}},{key:"setRefreshToken",value:function(e){this.refreshToken=e}},{key:"getAccessTokenExpiresAt",value:function(){return this.accessTokenExpiresAt}},{key:"setAccessTokenExpiresAt",value:function(e){this.accessTokenExpiresAt=e}},{key:"setCodeVerifier",value:function(e){this.codeVerifier=e}},{key:"getCodeVerifier",value:function(){return this.codeVerifier}},{key:"generateCodeChallenge",value:function(){var e,t=this,r=(new M).encode(this.codeVerifier);if(A()||S())return L.subtle.digest("SHA-256",r).then((function(r){var i=btoa(String.fromCharCode.apply(null,new Uint8Array(r)));e=C(i).substr(0,128),t.codeChallenge=e}));var i=L.createHash("sha256").update(r).digest();return e=C(i),this.codeChallenge=e,Promise.resolve()}},{key:"generatePKCECodes",value:function(){var e;if(A()||S()){var t=new Uint8Array(128),r=L.getRandomValues(t);e=C(btoa(r)).substr(0,128)}else{e=C(L.randomBytes(128)).substr(0,128)}return this.codeVerifier=e,this.generateCodeChallenge()}},{key:"getAuthenticationUrl",value:function(e,t){var r,i=this,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"token",n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"none",u=arguments.length>6&&void 0!==arguments[6]&&arguments[6],c=this.getClientId(),p=b(this.domain);if(!c)throw Error("A client id is required. You can set the client id using .setClientId().");if("code"!==s&&!e)throw Error("A redirect uri is required.");if(!U.includes(s))throw Error("Authorization type must be code or token");if(n&&!G.includes(n))throw Error("Token Access Type must be legacy, offline, or online");if(a&&!(a instanceof Array))throw Error("Scope must be an array of strings");if(!x.includes(o))throw Error("includeGrantedScopes must be none, user, or team");return r="code"===s?"".concat(p,"?response_type=code&client_id=").concat(c):"".concat(p,"?response_type=token&client_id=").concat(c),e&&(r+="&redirect_uri=".concat(e)),t&&(r+="&state=".concat(t)),n&&(r+="&token_access_type=".concat(n)),a&&(r+="&scope=".concat(a.join(" "))),"none"!==o&&(r+="&include_granted_scopes=".concat(o)),u?this.generatePKCECodes().then((function(){return r+="&code_challenge_method=S256",r+="&code_challenge=".concat(i.codeChallenge)})):Promise.resolve(r)}},{key:"getAccessTokenFromCode",value:function(e,t){var r=this.getClientId(),i=this.getClientSecret();if(!r)throw Error("A client id is required. You can set the client id using .setClientId().");var s=v(this.domain,this.domainDelimiter);if(s+="?grant_type=authorization_code",s+="&code=".concat(t),s+="&client_id=".concat(r),i)s+="&client_secret=".concat(i);else{if(!this.codeVerifier)throw Error("You must use PKCE when generating the authorization URL to not include a client secret");s+="&code_verifier=".concat(this.codeVerifier)}e&&(s+="&redirect_uri=".concat(e));return this.fetch(s,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"}}).then((function(e){return D(e)}))}},{key:"checkAndRefreshAccessToken",value:function(){var e=this.getRefreshToken()&&this.getClientId(),t=!this.getAccessTokenExpiresAt()||new Date(Date.now()+3e5)>=this.getAccessTokenExpiresAt(),r=!this.getAccessToken();return(t||r)&&e?this.refreshAccessToken():Promise.resolve()}},{key:"refreshAccessToken",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=this.getClientId(),i=this.getClientSecret();if(!r)throw Error("A client id is required. You can set the client id using .setClientId().");if(t&&!(t instanceof Array))throw Error("Scope must be an array of strings");var s=v(this.domain,this.domainDelimiter),n={headers:{"Content-Type":"application/json"},method:"POST"};if(this.dataOnBody){var a={grant_type:"refresh_token",client_id:r,refresh_token:this.getRefreshToken()};i&&(a.client_secret=i),t&&(a.scope=t.join(" ")),n.body=a}else s+="?grant_type=refresh_token&refresh_token=".concat(this.getRefreshToken()),s+="&client_id=".concat(r),i&&(s+="&client_secret=".concat(i)),t&&(s+="&scope=".concat(t.join(" ")));return this.fetch(s,n).then((function(e){return D(e)})).then((function(t){e.setAccessToken(t.result.access_token),e.setAccessTokenExpiresAt(k(t.result.expires_in))}))}}]),e}(),B="undefined"==typeof btoa?function(e){return Buffer.from(e).toString("base64")}:btoa;e.Dropbox=function(){function e(r){t(this,e),this.auth=(r=r||{}).auth?r.auth:new E(r),this.fetch=r.fetch||this.auth.fetch,this.selectUser=r.selectUser,this.selectAdmin=r.selectAdmin,this.pathRoot=r.pathRoot,this.domain=r.domain||this.auth.domain,this.domainDelimiter=r.domainDelimiter||this.auth.domainDelimiter,this.customHeaders=r.customHeaders||this.auth.customHeaders,Object.assign(this,_)}return i(e,[{key:"request",value:function(e,t,r,i,s){switch(s){case"rpc":return this.rpcRequest(e,t,r,i);case"download":return this.downloadRequest(e,t,r,i);case"upload":return this.uploadRequest(e,t,r,i);default:throw Error("Invalid request style: ".concat(s))}}},{key:"rpcRequest",value:function(e,t,r,i){var s=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e={method:"POST",body:t?JSON.stringify(t):null,headers:{}};return t&&(e.headers["Content-Type"]="application/json"),s.setAuthHeaders(r,e),s.setCommonHeaders(e),e})).then((function(t){return s.fetch(q(i,s.domain,s.domainDelimiter)+e,t)})).then((function(e){return D(e)}))}},{key:"downloadRequest",value:function(e,t,r,i){var s=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e={method:"POST",headers:{"Dropbox-API-Arg":w(t)}};return s.setAuthHeaders(r,e),s.setCommonHeaders(e),e})).then((function(t){return s.fetch(q(i,s.domain,s.domainDelimiter)+e,t)})).then((function(e){return function(e){return e.ok?new Promise((function(t){y()?e.blob().then((function(e){return t(e)})):e.buffer().then((function(e){return t(e)}))})).then((function(t){var r=JSON.parse(e.headers.get("dropbox-api-result"));return y()?r.fileBlob=t:r.fileBinary=t,new R(e.status,e.headers,r)})):F(e)}(e)}))}},{key:"uploadRequest",value:function(e,t,r,i){var s=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e=t.contents;delete t.contents;var i={body:e,method:"POST",headers:{"Content-Type":"application/octet-stream","Dropbox-API-Arg":w(t)}};return s.setAuthHeaders(r,i),s.setCommonHeaders(i),i})).then((function(t){return s.fetch(q(i,s.domain,s.domainDelimiter)+e,t)})).then((function(e){return D(e)}))}},{key:"setAuthHeaders",value:function(e,t){if(e.split(",").length>1){var r=e.replace(" ","").split(",");r.includes(l)&&this.auth.getAccessToken()?e=l:r.includes(f)&&this.auth.getAccessToken()?e=f:r.includes(p)&&(e=p)}switch(e){case p:if(this.auth.clientId&&this.auth.clientSecret){var i=B("".concat(this.auth.clientId,":").concat(this.auth.clientSecret));t.headers.Authorization="Basic ".concat(i)}break;case f:case l:this.auth.getAccessToken()&&(t.headers.Authorization="Bearer ".concat(this.auth.getAccessToken()));break;case"noauth":case"cookie":break;default:throw Error("Unhandled auth type: ".concat(e))}}},{key:"setCommonHeaders",value:function(e){var t=this;(this.selectUser&&(e.headers["Dropbox-API-Select-User"]=this.selectUser),this.selectAdmin&&(e.headers["Dropbox-API-Select-Admin"]=this.selectAdmin),this.pathRoot&&(e.headers["Dropbox-API-Path-Root"]=this.pathRoot),this.customHeaders)&&Object.keys(this.customHeaders).forEach((function(r){e.headers[r]=t.customHeaders[r]}))}}]),e}(),e.DropboxAuth=E,e.DropboxResponse=R,e.DropboxResponseError=P,Object.defineProperty(e,"__esModule",{value:!0})}));


/***/ }),

/***/ 720:
/***/ ((module) => {

"use strict";


module.exports = earcut;
module.exports["default"] = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ 587:
/***/ (function(module) {

"use strict";
/*

 Copyright 2000, Silicon Graphics, Inc. All Rights Reserved.
 Copyright 2015, Google Inc. All Rights Reserved.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to
 deal in the Software without restriction, including without limitation the
 rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice including the dates of first publication and
 either this permission notice or a reference to http://oss.sgi.com/projects/FreeB/
 shall be included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 Original Code. The Original Code is: OpenGL Sample Implementation,
 Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
 Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
 Copyright in any portions created by third parties is as indicated
 elsewhere herein. All Rights Reserved.
*/
var n;function t(a,b){return a.b===b.b&&a.a===b.a}function u(a,b){return a.b<b.b||a.b===b.b&&a.a<=b.a}function v(a,b,c){var d=b.b-a.b,e=c.b-b.b;return 0<d+e?d<e?b.a-a.a+d/(d+e)*(a.a-c.a):b.a-c.a+e/(d+e)*(c.a-a.a):0}function x(a,b,c){var d=b.b-a.b,e=c.b-b.b;return 0<d+e?(b.a-c.a)*d+(b.a-a.a)*e:0}function z(a,b){return a.a<b.a||a.a===b.a&&a.b<=b.b}function aa(a,b,c){var d=b.a-a.a,e=c.a-b.a;return 0<d+e?d<e?b.b-a.b+d/(d+e)*(a.b-c.b):b.b-c.b+e/(d+e)*(c.b-a.b):0}
function ba(a,b,c){var d=b.a-a.a,e=c.a-b.a;return 0<d+e?(b.b-c.b)*d+(b.b-a.b)*e:0}function ca(a){return u(a.b.a,a.a)}function da(a){return u(a.a,a.b.a)}function A(a,b,c,d){a=0>a?0:a;c=0>c?0:c;return a<=c?0===c?(b+d)/2:b+a/(a+c)*(d-b):d+c/(a+c)*(b-d)};function ea(a){var b=B(a.b);C(b,a.c);C(b.b,a.c);D(b,a.a);return b}function E(a,b){var c=!1,d=!1;a!==b&&(b.a!==a.a&&(d=!0,F(b.a,a.a)),b.d!==a.d&&(c=!0,G(b.d,a.d)),H(b,a),d||(C(b,a.a),a.a.c=a),c||(D(b,a.d),a.d.a=a))}function I(a){var b=a.b,c=!1;a.d!==a.b.d&&(c=!0,G(a.d,a.b.d));a.c===a?F(a.a,null):(a.b.d.a=J(a),a.a.c=a.c,H(a,J(a)),c||D(a,a.d));b.c===b?(F(b.a,null),G(b.d,null)):(a.d.a=J(b),b.a.c=b.c,H(b,J(b)));fa(a)}
function K(a){var b=B(a),c=b.b;H(b,a.e);b.a=a.b.a;C(c,b.a);b.d=c.d=a.d;b=b.b;H(a.b,J(a.b));H(a.b,b);a.b.a=b.a;b.b.a.c=b.b;b.b.d=a.b.d;b.f=a.f;b.b.f=a.b.f;return b}function L(a,b){var c=!1,d=B(a),e=d.b;b.d!==a.d&&(c=!0,G(b.d,a.d));H(d,a.e);H(e,b);d.a=a.b.a;e.a=b.a;d.d=e.d=a.d;a.d.a=e;c||D(d,a.d);return d}function B(a){var b=new M,c=new M,d=a.b.h;c.h=d;d.b.h=b;b.h=a;a.b.h=c;b.b=c;b.c=b;b.e=c;c.b=b;c.c=c;return c.e=b}function H(a,b){var c=a.c,d=b.c;c.b.e=b;d.b.e=a;a.c=d;b.c=c}
function C(a,b){var c=b.f,d=new N(b,c);c.e=d;b.f=d;c=d.c=a;do c.a=d,c=c.c;while(c!==a)}function D(a,b){var c=b.d,d=new ga(b,c);c.b=d;b.d=d;d.a=a;d.c=b.c;c=a;do c.d=d,c=c.e;while(c!==a)}function fa(a){var b=a.h;a=a.b.h;b.b.h=a;a.b.h=b}function F(a,b){var c=a.c,d=c;do d.a=b,d=d.c;while(d!==c);c=a.f;d=a.e;d.f=c;c.e=d}function G(a,b){var c=a.a,d=c;do d.d=b,d=d.e;while(d!==c);c=a.d;d=a.b;d.d=c;c.b=d};function ha(a){var b=0;Math.abs(a[1])>Math.abs(a[0])&&(b=1);Math.abs(a[2])>Math.abs(a[b])&&(b=2);return b};var O=4*1E150;function P(a,b){a.f+=b.f;a.b.f+=b.b.f}function ia(a,b,c){a=a.a;b=b.a;c=c.a;if(b.b.a===a)return c.b.a===a?u(b.a,c.a)?0>=x(c.b.a,b.a,c.a):0<=x(b.b.a,c.a,b.a):0>=x(c.b.a,a,c.a);if(c.b.a===a)return 0<=x(b.b.a,a,b.a);b=v(b.b.a,a,b.a);a=v(c.b.a,a,c.a);return b>=a}function Q(a){a.a.i=null;var b=a.e;b.a.c=b.c;b.c.a=b.a;a.e=null}function ja(a,b){I(a.a);a.c=!1;a.a=b;b.i=a}function ka(a){var b=a.a.a;do a=R(a);while(a.a.a===b);a.c&&(b=L(S(a).a.b,a.a.e),ja(a,b),a=R(a));return a}
function la(a,b,c){var d=new ma;d.a=c;d.e=na(a.f,b.e,d);return c.i=d}function oa(a,b){switch(a.s){case 100130:return 0!==(b&1);case 100131:return 0!==b;case 100132:return 0<b;case 100133:return 0>b;case 100134:return 2<=b||-2>=b}return!1}function pa(a){var b=a.a,c=b.d;c.c=a.d;c.a=b;Q(a)}function T(a,b,c){a=b;for(b=b.a;a!==c;){a.c=!1;var d=S(a),e=d.a;if(e.a!==b.a){if(!d.c){pa(a);break}e=L(b.c.b,e.b);ja(d,e)}b.c!==e&&(E(J(e),e),E(b,e));pa(a);b=d.a;a=d}return b}
function U(a,b,c,d,e,f){var g=!0;do la(a,b,c.b),c=c.c;while(c!==d);for(null===e&&(e=S(b).a.b.c);;){d=S(b);c=d.a.b;if(c.a!==e.a)break;c.c!==e&&(E(J(c),c),E(J(e),c));d.f=b.f-c.f;d.d=oa(a,d.f);b.b=!0;!g&&qa(a,b)&&(P(c,e),Q(b),I(e));g=!1;b=d;e=c}b.b=!0;f&&ra(a,b)}function sa(a,b,c,d,e){var f=[b.g[0],b.g[1],b.g[2]];b.d=null;b.d=a.o?a.o(f,c,d,a.c)||null:null;null===b.d&&(e?a.n||(V(a,100156),a.n=!0):b.d=c[0])}
function ta(a,b,c){var d=[null,null,null,null];d[0]=b.a.d;d[1]=c.a.d;sa(a,b.a,d,[.5,.5,0,0],!1);E(b,c)}function ua(a,b,c,d,e){var f=Math.abs(b.b-a.b)+Math.abs(b.a-a.a),g=Math.abs(c.b-a.b)+Math.abs(c.a-a.a),h=e+1;d[e]=.5*g/(f+g);d[h]=.5*f/(f+g);a.g[0]+=d[e]*b.g[0]+d[h]*c.g[0];a.g[1]+=d[e]*b.g[1]+d[h]*c.g[1];a.g[2]+=d[e]*b.g[2]+d[h]*c.g[2]}
function qa(a,b){var c=S(b),d=b.a,e=c.a;if(u(d.a,e.a)){if(0<x(e.b.a,d.a,e.a))return!1;if(!t(d.a,e.a))K(e.b),E(d,J(e)),b.b=c.b=!0;else if(d.a!==e.a){var c=a.e,f=d.a.h;if(0<=f){var c=c.b,g=c.d,h=c.e,k=c.c,l=k[f];g[l]=g[c.a];k[g[l]]=l;l<=--c.a&&(1>=l?W(c,l):u(h[g[l>>1]],h[g[l]])?W(c,l):va(c,l));h[f]=null;k[f]=c.b;c.b=f}else for(c.c[-(f+1)]=null;0<c.a&&null===c.c[c.d[c.a-1]];)--c.a;ta(a,J(e),d)}}else{if(0>x(d.b.a,e.a,d.a))return!1;R(b).b=b.b=!0;K(d.b);E(J(e),d)}return!0}
function wa(a,b){var c=S(b),d=b.a,e=c.a,f=d.a,g=e.a,h=d.b.a,k=e.b.a,l=new N;x(h,a.a,f);x(k,a.a,g);if(f===g||Math.min(f.a,h.a)>Math.max(g.a,k.a))return!1;if(u(f,g)){if(0<x(k,f,g))return!1}else if(0>x(h,g,f))return!1;var r=h,p=f,q=k,y=g,m,w;u(r,p)||(m=r,r=p,p=m);u(q,y)||(m=q,q=y,y=m);u(r,q)||(m=r,r=q,q=m,m=p,p=y,y=m);u(q,p)?u(p,y)?(m=v(r,q,p),w=v(q,p,y),0>m+w&&(m=-m,w=-w),l.b=A(m,q.b,w,p.b)):(m=x(r,q,p),w=-x(r,y,p),0>m+w&&(m=-m,w=-w),l.b=A(m,q.b,w,y.b)):l.b=(q.b+p.b)/2;z(r,p)||(m=r,r=p,p=m);z(q,y)||
(m=q,q=y,y=m);z(r,q)||(m=r,r=q,q=m,m=p,p=y,y=m);z(q,p)?z(p,y)?(m=aa(r,q,p),w=aa(q,p,y),0>m+w&&(m=-m,w=-w),l.a=A(m,q.a,w,p.a)):(m=ba(r,q,p),w=-ba(r,y,p),0>m+w&&(m=-m,w=-w),l.a=A(m,q.a,w,y.a)):l.a=(q.a+p.a)/2;u(l,a.a)&&(l.b=a.a.b,l.a=a.a.a);r=u(f,g)?f:g;u(r,l)&&(l.b=r.b,l.a=r.a);if(t(l,f)||t(l,g))return qa(a,b),!1;if(!t(h,a.a)&&0<=x(h,a.a,l)||!t(k,a.a)&&0>=x(k,a.a,l)){if(k===a.a)return K(d.b),E(e.b,d),b=ka(b),d=S(b).a,T(a,S(b),c),U(a,b,J(d),d,d,!0),!0;if(h===a.a){K(e.b);E(d.e,J(e));f=c=b;g=f.a.b.a;
do f=R(f);while(f.a.b.a===g);b=f;f=S(b).a.b.c;c.a=J(e);e=T(a,c,null);U(a,b,e.c,d.b.c,f,!0);return!0}0<=x(h,a.a,l)&&(R(b).b=b.b=!0,K(d.b),d.a.b=a.a.b,d.a.a=a.a.a);0>=x(k,a.a,l)&&(b.b=c.b=!0,K(e.b),e.a.b=a.a.b,e.a.a=a.a.a);return!1}K(d.b);K(e.b);E(J(e),d);d.a.b=l.b;d.a.a=l.a;d.a.h=xa(a.e,d.a);d=d.a;e=[0,0,0,0];l=[f.d,h.d,g.d,k.d];d.g[0]=d.g[1]=d.g[2]=0;ua(d,f,h,e,0);ua(d,g,k,e,2);sa(a,d,l,e,!0);R(b).b=b.b=c.b=!0;return!1}
function ra(a,b){for(var c=S(b);;){for(;c.b;)b=c,c=S(c);if(!b.b&&(c=b,b=R(b),null===b||!b.b))break;b.b=!1;var d=b.a,e=c.a,f;if(f=d.b.a!==e.b.a)a:{f=b;var g=S(f),h=f.a,k=g.a,l=void 0;if(u(h.b.a,k.b.a)){if(0>x(h.b.a,k.b.a,h.a)){f=!1;break a}R(f).b=f.b=!0;l=K(h);E(k.b,l);l.d.c=f.d}else{if(0<x(k.b.a,h.b.a,k.a)){f=!1;break a}f.b=g.b=!0;l=K(k);E(h.e,k.b);l.b.d.c=f.d}f=!0}f&&(c.c?(Q(c),I(e),c=S(b),e=c.a):b.c&&(Q(b),I(d),b=R(c),d=b.a));if(d.a!==e.a)if(d.b.a===e.b.a||b.c||c.c||d.b.a!==a.a&&e.b.a!==a.a)qa(a,
b);else if(wa(a,b))break;d.a===e.a&&d.b.a===e.b.a&&(P(e,d),Q(b),I(d),b=R(c))}}
function ya(a,b){a.a=b;for(var c=b.c;null===c.i;)if(c=c.c,c===b.c){var c=a,d=b,e=new ma;e.a=d.c.b;var f=c.f,g=f.a;do g=g.a;while(null!==g.b&&!f.c(f.b,e,g.b));var f=g.b,h=S(f),e=f.a,g=h.a;if(0===x(e.b.a,d,e.a))e=f.a,t(e.a,d)||t(e.b.a,d)||(K(e.b),f.c&&(I(e.c),f.c=!1),E(d.c,e),ya(c,d));else{var k=u(g.b.a,e.b.a)?f:h,h=void 0;f.d||k.c?(k===f?h=L(d.c.b,e.e):h=L(g.b.c.b,d.c).b,k.c?ja(k,h):(e=c,f=la(c,f,h),f.f=R(f).f+f.a.f,f.d=oa(e,f.f)),ya(c,d)):U(c,f,d.c,d.c,null,!0)}return}c=ka(c.i);e=S(c);f=e.a;e=T(a,
e,null);if(e.c===f){var f=e,e=f.c,g=S(c),h=c.a,k=g.a,l=!1;h.b.a!==k.b.a&&wa(a,c);t(h.a,a.a)&&(E(J(e),h),c=ka(c),e=S(c).a,T(a,S(c),g),l=!0);t(k.a,a.a)&&(E(f,J(k)),f=T(a,g,null),l=!0);l?U(a,c,f.c,e,e,!0):(u(k.a,h.a)?d=J(k):d=h,d=L(f.c.b,d),U(a,c,d,d.c,d.c,!1),d.b.i.c=!0,ra(a,c))}else U(a,c,e.c,f,f,!0)}function za(a,b){var c=new ma,d=ea(a.b);d.a.b=O;d.a.a=b;d.b.a.b=-O;d.b.a.a=b;a.a=d.b.a;c.a=d;c.f=0;c.d=!1;c.c=!1;c.h=!0;c.b=!1;d=a.f;d=na(d,d.a,c);c.e=d};function Aa(a){this.a=new Ba;this.b=a;this.c=ia}function na(a,b,c){do b=b.c;while(null!==b.b&&!a.c(a.b,b.b,c));a=new Ba(c,b.a,b);b.a.c=a;return b.a=a};function Ba(a,b,c){this.b=a||null;this.a=b||this;this.c=c||this};function X(){this.d=Y;this.p=this.b=this.q=null;this.j=[0,0,0];this.s=100130;this.n=!1;this.o=this.a=this.e=this.f=null;this.m=!1;this.c=this.r=this.i=this.k=this.l=this.h=null}var Y=0;n=X.prototype;n.x=function(){Z(this,Y)};n.B=function(a,b){switch(a){case 100142:return;case 100140:switch(b){case 100130:case 100131:case 100132:case 100133:case 100134:this.s=b;return}break;case 100141:this.m=!!b;return;default:V(this,100900);return}V(this,100901)};
n.y=function(a){switch(a){case 100142:return 0;case 100140:return this.s;case 100141:return this.m;default:V(this,100900)}return!1};n.A=function(a,b,c){this.j[0]=a;this.j[1]=b;this.j[2]=c};
n.z=function(a,b){var c=b?b:null;switch(a){case 100100:case 100106:this.h=c;break;case 100104:case 100110:this.l=c;break;case 100101:case 100107:this.k=c;break;case 100102:case 100108:this.i=c;break;case 100103:case 100109:this.p=c;break;case 100105:case 100111:this.o=c;break;case 100112:this.r=c;break;default:V(this,100900)}};
n.C=function(a,b){var c=!1,d=[0,0,0];Z(this,2);for(var e=0;3>e;++e){var f=a[e];-1E150>f&&(f=-1E150,c=!0);1E150<f&&(f=1E150,c=!0);d[e]=f}c&&V(this,100155);c=this.q;null===c?(c=ea(this.b),E(c,c.b)):(K(c),c=c.e);c.a.d=b;c.a.g[0]=d[0];c.a.g[1]=d[1];c.a.g[2]=d[2];c.f=1;c.b.f=-1;this.q=c};n.u=function(a){Z(this,Y);this.d=1;this.b=new Ca;this.c=a};n.t=function(){Z(this,1);this.d=2;this.q=null};n.v=function(){Z(this,2);this.d=1};
n.w=function(){Z(this,1);this.d=Y;var a=this.j[0],b=this.j[1],c=this.j[2],d=!1,e=[a,b,c];if(0===a&&0===b&&0===c){for(var b=[-2*1E150,-2*1E150,-2*1E150],f=[2*1E150,2*1E150,2*1E150],c=[],g=[],d=this.b.c,a=d.e;a!==d;a=a.e)for(var h=0;3>h;++h){var k=a.g[h];k<f[h]&&(f[h]=k,g[h]=a);k>b[h]&&(b[h]=k,c[h]=a)}a=0;b[1]-f[1]>b[0]-f[0]&&(a=1);b[2]-f[2]>b[a]-f[a]&&(a=2);if(f[a]>=b[a])e[0]=0,e[1]=0,e[2]=1;else{b=0;f=g[a];c=c[a];g=[0,0,0];f=[f.g[0]-c.g[0],f.g[1]-c.g[1],f.g[2]-c.g[2]];h=[0,0,0];for(a=d.e;a!==d;a=
a.e)h[0]=a.g[0]-c.g[0],h[1]=a.g[1]-c.g[1],h[2]=a.g[2]-c.g[2],g[0]=f[1]*h[2]-f[2]*h[1],g[1]=f[2]*h[0]-f[0]*h[2],g[2]=f[0]*h[1]-f[1]*h[0],k=g[0]*g[0]+g[1]*g[1]+g[2]*g[2],k>b&&(b=k,e[0]=g[0],e[1]=g[1],e[2]=g[2]);0>=b&&(e[0]=e[1]=e[2]=0,e[ha(f)]=1)}d=!0}g=ha(e);a=this.b.c;b=(g+1)%3;c=(g+2)%3;g=0<e[g]?1:-1;for(e=a.e;e!==a;e=e.e)e.b=e.g[b],e.a=g*e.g[c];if(d){e=0;d=this.b.a;for(a=d.b;a!==d;a=a.b)if(b=a.a,!(0>=b.f)){do e+=(b.a.b-b.b.a.b)*(b.a.a+b.b.a.a),b=b.e;while(b!==a.a)}if(0>e)for(e=this.b.c,d=e.e;d!==
e;d=d.e)d.a=-d.a}this.n=!1;e=this.b.b;for(a=e.h;a!==e;a=d)if(d=a.h,b=a.e,t(a.a,a.b.a)&&a.e.e!==a&&(ta(this,b,a),I(a),a=b,b=a.e),b.e===a){if(b!==a){if(b===d||b===d.b)d=d.h;I(b)}if(a===d||a===d.b)d=d.h;I(a)}this.e=e=new Da;d=this.b.c;for(a=d.e;a!==d;a=a.e)a.h=xa(e,a);Ea(e);this.f=new Aa(this);za(this,-O);for(za(this,O);null!==(e=Fa(this.e));){for(;;){a:if(a=this.e,0===a.a)d=Ga(a.b);else if(d=a.c[a.d[a.a-1]],0!==a.b.a&&(a=Ga(a.b),u(a,d))){d=a;break a}if(null===d||!t(d,e))break;d=Fa(this.e);ta(this,e.c,
d.c)}ya(this,e)}this.a=this.f.a.a.b.a.a;for(e=0;null!==(d=this.f.a.a.b);)d.h||++e,Q(d);this.f=null;e=this.e;e.b=null;e.d=null;this.e=e.c=null;e=this.b;for(a=e.a.b;a!==e.a;a=d)d=a.b,a=a.a,a.e.e===a&&(P(a.c,a),I(a));if(!this.n){e=this.b;if(this.m)for(a=e.b.h;a!==e.b;a=d)d=a.h,a.b.d.c!==a.d.c?a.f=a.d.c?1:-1:I(a);else for(a=e.a.b;a!==e.a;a=d)if(d=a.b,a.c){for(a=a.a;u(a.b.a,a.a);a=a.c.b);for(;u(a.a,a.b.a);a=a.e);b=a.c.b;for(c=void 0;a.e!==b;)if(u(a.b.a,b.a)){for(;b.e!==a&&(ca(b.e)||0>=x(b.a,b.b.a,b.e.b.a));)c=
L(b.e,b),b=c.b;b=b.c.b}else{for(;b.e!==a&&(da(a.c.b)||0<=x(a.b.a,a.a,a.c.b.a));)c=L(a,a.c.b),a=c.b;a=a.e}for(;b.e.e!==a;)c=L(b.e,b),b=c.b}if(this.h||this.i||this.k||this.l)if(this.m)for(e=this.b,d=e.a.b;d!==e.a;d=d.b){if(d.c){this.h&&this.h(2,this.c);a=d.a;do this.k&&this.k(a.a.d,this.c),a=a.e;while(a!==d.a);this.i&&this.i(this.c)}}else{e=this.b;d=!!this.l;a=!1;b=-1;for(c=e.a.d;c!==e.a;c=c.d)if(c.c){a||(this.h&&this.h(4,this.c),a=!0);g=c.a;do d&&(f=g.b.d.c?0:1,b!==f&&(b=f,this.l&&this.l(!!b,this.c))),
this.k&&this.k(g.a.d,this.c),g=g.e;while(g!==c.a)}a&&this.i&&this.i(this.c)}if(this.r){e=this.b;for(a=e.a.b;a!==e.a;a=d)if(d=a.b,!a.c){b=a.a;c=b.e;g=void 0;do g=c,c=g.e,g.d=null,null===g.b.d&&(g.c===g?F(g.a,null):(g.a.c=g.c,H(g,J(g))),f=g.b,f.c===f?F(f.a,null):(f.a.c=f.c,H(f,J(f))),fa(g));while(g!==b);b=a.d;a=a.b;a.d=b;b.b=a}this.r(this.b);this.c=this.b=null;return}}this.b=this.c=null};
function Z(a,b){if(a.d!==b)for(;a.d!==b;)if(a.d<b)switch(a.d){case Y:V(a,100151);a.u(null);break;case 1:V(a,100152),a.t()}else switch(a.d){case 2:V(a,100154);a.v();break;case 1:V(a,100153),a.w()}}function V(a,b){a.p&&a.p(b,a.c)};function ga(a,b){this.b=a||this;this.d=b||this;this.a=null;this.c=!1};function M(){this.h=this;this.i=this.d=this.a=this.e=this.c=this.b=null;this.f=0}function J(a){return a.b.e};function Ca(){this.c=new N;this.a=new ga;this.b=new M;this.d=new M;this.b.b=this.d;this.d.b=this.b};function N(a,b){this.e=a||this;this.f=b||this;this.d=this.c=null;this.g=[0,0,0];this.h=this.a=this.b=0};function Da(){this.c=[];this.d=null;this.a=0;this.e=!1;this.b=new Ha}function Ea(a){a.d=[];for(var b=0;b<a.a;b++)a.d[b]=b;a.d.sort(function(a){return function(b,e){return u(a[b],a[e])?1:-1}}(a.c));a.e=!0;Ia(a.b)}function xa(a,b){if(a.e){var c=a.b,d=++c.a;2*d>c.f&&(c.f*=2,c.c=Ja(c.c,c.f+1));var e;0===c.b?e=d:(e=c.b,c.b=c.c[c.b]);c.e[e]=b;c.c[e]=d;c.d[d]=e;c.h&&va(c,d);return e}c=a.a++;a.c[c]=b;return-(c+1)}
function Fa(a){if(0===a.a)return Ka(a.b);var b=a.c[a.d[a.a-1]];if(0!==a.b.a&&u(Ga(a.b),b))return Ka(a.b);do--a.a;while(0<a.a&&null===a.c[a.d[a.a-1]]);return b};function Ha(){this.d=Ja([0],33);this.e=[null,null];this.c=[0,0];this.a=0;this.f=32;this.b=0;this.h=!1;this.d[1]=1}function Ja(a,b){for(var c=Array(b),d=0;d<a.length;d++)c[d]=a[d];for(;d<b;d++)c[d]=0;return c}function Ia(a){for(var b=a.a;1<=b;--b)W(a,b);a.h=!0}function Ga(a){return a.e[a.d[1]]}function Ka(a){var b=a.d,c=a.e,d=a.c,e=b[1],f=c[e];0<a.a&&(b[1]=b[a.a],d[b[1]]=1,c[e]=null,d[e]=a.b,a.b=e,0<--a.a&&W(a,1));return f}
function W(a,b){for(var c=a.d,d=a.e,e=a.c,f=b,g=c[f];;){var h=f<<1;h<a.a&&u(d[c[h+1]],d[c[h]])&&(h+=1);var k=c[h];if(h>a.a||u(d[g],d[k])){c[f]=g;e[g]=f;break}c[f]=k;e[k]=f;f=h}}function va(a,b){for(var c=a.d,d=a.e,e=a.c,f=b,g=c[f];;){var h=f>>1,k=c[h];if(0===h||u(d[k],d[g])){c[f]=g;e[g]=f;break}c[f]=k;e[k]=f;f=h}};function ma(){this.e=this.a=null;this.f=0;this.c=this.b=this.h=this.d=!1}function S(a){return a.e.c.b}function R(a){return a.e.a.b};this.libtess={GluTesselator:X,windingRule:{GLU_TESS_WINDING_ODD:100130,GLU_TESS_WINDING_NONZERO:100131,GLU_TESS_WINDING_POSITIVE:100132,GLU_TESS_WINDING_NEGATIVE:100133,GLU_TESS_WINDING_ABS_GEQ_TWO:100134},primitiveType:{GL_LINE_LOOP:2,GL_TRIANGLES:4,GL_TRIANGLE_STRIP:5,GL_TRIANGLE_FAN:6},errorType:{GLU_TESS_MISSING_BEGIN_POLYGON:100151,GLU_TESS_MISSING_END_POLYGON:100153,GLU_TESS_MISSING_BEGIN_CONTOUR:100152,GLU_TESS_MISSING_END_CONTOUR:100154,GLU_TESS_COORD_TOO_LARGE:100155,GLU_TESS_NEED_COMBINE_CALLBACK:100156},
gluEnum:{GLU_TESS_MESH:100112,GLU_TESS_TOLERANCE:100142,GLU_TESS_WINDING_RULE:100140,GLU_TESS_BOUNDARY_ONLY:100141,GLU_INVALID_ENUM:100900,GLU_INVALID_VALUE:100901,GLU_TESS_BEGIN:100100,GLU_TESS_VERTEX:100101,GLU_TESS_END:100102,GLU_TESS_ERROR:100103,GLU_TESS_EDGE_FLAG:100104,GLU_TESS_COMBINE:100105,GLU_TESS_BEGIN_DATA:100106,GLU_TESS_VERTEX_DATA:100107,GLU_TESS_END_DATA:100108,GLU_TESS_ERROR_DATA:100109,GLU_TESS_EDGE_FLAG_DATA:100110,GLU_TESS_COMBINE_DATA:100111}};X.prototype.gluDeleteTess=X.prototype.x;
X.prototype.gluTessProperty=X.prototype.B;X.prototype.gluGetTessProperty=X.prototype.y;X.prototype.gluTessNormal=X.prototype.A;X.prototype.gluTessCallback=X.prototype.z;X.prototype.gluTessVertex=X.prototype.C;X.prototype.gluTessBeginPolygon=X.prototype.u;X.prototype.gluTessBeginContour=X.prototype.t;X.prototype.gluTessEndContour=X.prototype.v;X.prototype.gluTessEndPolygon=X.prototype.w; if (true) { module.exports = this.libtess; }


/***/ }),

/***/ 898:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof __webpack_require__.g !== 'undefined') { return __webpack_require__.g; }
	throw new Error('unable to locate global object');
}

var globalObject = getGlobal();

module.exports = exports = globalObject.fetch;

// Needed for TypeScript and Webpack.
if (globalObject.fetch) {
	exports["default"] = globalObject.fetch.bind(globalObject);
}

exports.Headers = globalObject.Headers;
exports.Request = globalObject.Request;
exports.Response = globalObject.Response;


/***/ }),

/***/ 379:
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 569:
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ 216:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ 565:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 795:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ 589:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ 36:
/***/ ((module) => {

module.exports = "<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 689 456.3\"><circle cx=\"78.99\" cy=\"226.63\" r=\"78.99\"></circle><circle cx=\"296.5\" cy=\"344.5\" r=\"111.8\"></circle><circle cx=\"541.36\" cy=\"147.64\" r=\"147.64\"></circle></svg>"

/***/ }),

/***/ 212:
/***/ ((module) => {

module.exports = "<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 623.98 532.11\"><path d=\"M591.31,495.25c57.9-140.61-220.75-311-366.91-77.42L64,228.89C409,44.34,605.42,160.72,668.16,308c70.35,165.11-61.18,345-163,356.88-94.7,11.09-214.8-58.09-245.56-84.45l81.29-156S533.4,635.86,591.31,495.25Z\" transform=\"translate(-64.02 -133.94)\"></path><path d=\"M598,428\" transform=\"translate(-64.02 -133.94)\"></path></svg>"

/***/ }),

/***/ 504:
/***/ ((module) => {

module.exports = "<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 596 610\"><path d=\"M634,572,216,732,92,474,328,174l360-52\" transform=\"translate(-92 -122)\"></path><path d=\"M598,428\" transform=\"translate(-92 -122)\"></path></svg>"

/***/ }),

/***/ 445:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>capture</title><path d=\"M4 2v28h24v-28h-24zM24 22h-16v-16h16v16z\"></path></svg>"

/***/ }),

/***/ 399:
/***/ ((module) => {

module.exports = "<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 600 600\"><path d=\"M300,100V200H600V500H700V100Z\" transform=\"translate(-100 -100)\"></path><path d=\"M328,700V600H200V472H100V700Z\" transform=\"translate(-100 -100)\"></path></svg>"

/***/ }),

/***/ 28:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>download</title><path d=\"M16.001 19.314l-8.485-8.485 2.828-2.829 5.657 5.657 5.657-5.657 2.828 2.828-8.485 8.486zM8 28h16v-4h-16v4z\"></path></svg>"

/***/ }),

/***/ 461:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>forbid</title><path d=\"M18.828 16l4.243 4.243-2.828 2.828-4.243-4.243-4.243 4.243-2.828-2.828 4.243-4.243-4.243-4.243 2.828-2.828 4.243 4.243 4.243-4.243 2.828 2.828-4.243 4.243z\"></path></svg>"

/***/ }),

/***/ 485:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>launch</title><path d=\"M24 24h-6v4h-4v-4h-6l4-4v-13l4-4 4 4v13l4 4z\"></path></svg>"

/***/ }),

/***/ 713:
/***/ ((module) => {

module.exports = "<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 525.86 431.95\"><path d=\"M385,607.38,148.64,422.62l61.57-78.8L367.78,467l228-291.57L674.5,237Z\" transform=\"translate(-148.64 -175.43)\"></path></svg>"

/***/ }),

/***/ 801:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>plug</title><path d=\"M22 11v-8h-12v8h-2v14h6v4h4v-4h6v-14h-2zM18 11h-4v-4h4v4z\"></path></svg>"

/***/ }),

/***/ 56:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>redo</title><path d=\"M28 24v4h-24v-20h10.071l-3.657-3.654 2.828-2.826 8.485 8.485-8.485 8.484-2.828-2.83 3.657-3.659h-6.071v12h20z\"></path></svg>"

/***/ }),

/***/ 866:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>resize</title><path d=\"M28 12v-8h-8v2h-8v-2h-8v8h2v8h-2v8h8v-2h8v2h8v-8h-2v-8h2zM22 20h-2v2h-8v-2h-2v-8h2v-2h8v2h2v8z\"></path></svg>"

/***/ }),

/***/ 878:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>solve</title><path d=\"M28 12v4h-4v6h-6v4h-4v-4h-6v-6h-4v-4h4v-6h6v4h4v-4h6v6h4z\"></path></svg>"

/***/ }),

/***/ 179:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>time</title><path d=\"M22 18h-8v-8h4v4h4v4zM30 2v28h-28v-28h28zM26 6h-20v20h20v-20z\"></path></svg>"

/***/ }),

/***/ 897:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>undo</title><path d=\"M28 8v20h-24v-4h20v-12h-6.071l3.657 3.66-2.828 2.83-8.485-8.484 8.485-8.485 2.828 2.826-3.657 3.653h10.071z\"></path></svg>"

/***/ }),

/***/ 737:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/c9ec27466feec6639c0e7cdd798e5707.webp");

/***/ }),

/***/ 616:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/11d1819c329097bd42d612af51984ebf.webp");

/***/ }),

/***/ 130:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/f582214ff3350f1957d2e5f71ac6089c.webp");

/***/ }),

/***/ 229:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/f06932ac516f7c72ce848dfe5a1557ca.webp");

/***/ }),

/***/ 949:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/f7442041cb9d6db02b7f80e9a3aa298f.webp");

/***/ }),

/***/ 157:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/2ee5dd2f76544899d917464f1c7ed687.webp");

/***/ }),

/***/ 928:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/320fc7b7b1a658588d5b020a90c3ee26.webp");

/***/ }),

/***/ 385:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\n// uniform float time;\\n// uniform float frame;\\n// uniform float zoom;\\n// uniform vec2 panning;\\n// uniform vec2 R;\\n// uniform vec2 canvasR;\\n// uniform vec4 stroke_col;\\n// uniform vec2 stroke_pos;\\n// uniform float stroke_opacity;\\n// uniform vec3 tex_lch_dynamics;\\n// uniform vec2 tex_stretch;\\n// uniform vec2 tilt;\\n// uniform vec2 brush_sz;\\n// uniform float pressure;\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\n// uniform sampler2D brush_texture_0;\\n// uniform sampler2D brush_texture_1;\\n// uniform sampler2D brush_texture_2;\\n// uniform sampler2D brush_texture_3;\\n// uniform sampler2D brush_texture_4;\\n// uniform sampler2D brush_texture_5;\\n// uniform sampler2D brush_texture_6;\\n// uniform sampler2D brush_texture_7;\\n// uniform sampler2D brush_texture_8;\\n// uniform sampler2D brush_texture_9;\\n// uniform sampler2D brush_texture_10;\\n// uniform sampler2D brush_texture_11;\\n// uniform sampler2D brush_texture_12;\\n\\n// uniform float canvas_idx;\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nuint seed = 11425u;\\n\\nuint hash_u(uint _a) {\\n   uint a = _a;\\n   a ^= a >> 16;\\n   a *= 0x7feb352du;\\n   a ^= a >> 15;\\n   a *= 0x846ca68bu;\\n   a ^= a >> 16;\\n   return a; \\n }\\nfloat hash_f(){ uint s = hash_u(seed); seed = s;return ( float( s ) / float( 0xffffffffu ) ); }\\nvec2 hash_v2(){ return vec2(hash_f(), hash_f()); }\\nvec3 hash_v3(){ return vec3(hash_f(), hash_f(), hash_f()); }\\nvec4 hash_v4(){ return vec4(hash_f(), hash_f(), hash_f(), hash_f()); }\\n\\nfloat hash_f_s(uint s){ s = hash_u(s); return ( float( s ) / float( 0xffffffffu ) ); }\\n// vec2 hash_22_s(uvec2 s){ uint _s = hash_u(s.x) + hash_u(s.y); return vec2(hash_f_s(_s.x), hash_f_s(_s.y)); }\\nfloat hash_21_s(ivec2 _s_){ \\n  uvec2 s = uvec2(_s_);\\n  uint _s = hash_u(s.x + hash_u(s.y)) + hash_u(s.y + hash_u(s.x)); \\n  return hash_f_s(_s); \\n}\\n// vec3 hash_23_s(){ return vec3(hash_f_s(), hash_f_s(), hash_f_s()); }\\n// vec4 hash_24_s(){ return vec4(hash_f_s(), hash_f_s(), hash_f_s(), hash_f_s()); }\\n\\nfloat valueNoise( in vec2 p ){\\n    p += 100.;\\n    ivec2 i = ivec2(floor( p ));\\n    vec2 f = fract( p );\\n\\n    // cubic interpolant\\n    vec2 u = f*f*(3.0-2.0*f);\\n\\n    return mix( mix( hash_21_s( i + ivec2(0,0) ), \\n                     hash_21_s( i + ivec2(1,0) ), u.x),\\n                mix( hash_21_s( i + ivec2(0,1) ), \\n                     hash_21_s( i + ivec2(1,1) ), u.x), u.y);\\n}\\n\\nuniform int brush_texture_idx;\\nuniform vec3 tex_hsv_dynamics;\\nuniform vec2 tex_stretch;\\n\\nin vec2 uv;\\nin vec4 vCol;\\nout vec4 col;\\n// float sdBox( in vec2 p, in vec2 b ) {\\n//     vec2 d = abs(p)-b;\\n//     return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\\n// }\\n\\nvec4 sample_brush_tex(int idx, vec2 uv){\\n  if(idx == 0){\\n    return texture(brush_texture[0],uv,-1.);\\n  }\\n  if(idx == 1){\\n    return texture(brush_texture[1],uv,-1.);\\n  }\\n  if(idx == 2){\\n    return texture(brush_texture[2],uv,-1.);\\n  }\\n  if(idx == 3){\\n    return texture(brush_texture[3],uv,-1.);\\n  }\\n  if(idx == 4){\\n    return texture(brush_texture[4],uv,-1.);\\n  }\\n  if(idx == 5){\\n    return texture(brush_texture[5],uv,-1.);\\n  }\\n  if(idx == 6){\\n    return texture(brush_texture[6],uv,-1.);\\n  } \\n  // if(idx == 7){\\n  //   return texture(brush_texture[7],uv);\\n  // }\\n  // if(idx == 8){\\n  //   return texture(brush_texture_8,uv);\\n  // }\\n  // if(idx == 9){\\n  //   return texture(brush_texture_9,uv);\\n  // }\\n  // if(idx == 10){\\n  //   return texture(brush_texture_10,uv);\\n  // }\\n  // if(idx == 11){\\n  //   return texture(brush_texture_11,uv);\\n  // }\\n  // if(idx == 12){\\n  //   return texture(brush_texture_12,uv);\\n  // }\\n}\\n\\nfloat sdBox(vec2 p, vec2 sz){\\n    p = abs(p) - sz;\\n    return max(p.x,p.y);\\n}\\nvoid main() {\\n  col = vec4(1);\\n  // col.xyz = stroke_col.xyz;\\n  \\n  vec2 u = uv - 0.5;\\n  \\n  vec2 boxSz = vec2(0.49);\\n\\n  col = vCol;\\n  {\\n    col.xyz = srgb_to_oklch(col.xyz);\\n\\n    vec2 nuv = uv*2120.;\\n    nuv *= tex_stretch;\\n    float n = (valueNoise(nuv)*2. - 1.);\\n\\n    col.z += 5.5*n * tex_hsv_dynamics.z;\\n    col.x += n * tex_hsv_dynamics.x;\\n    col.y += n * tex_hsv_dynamics.y;\\n    // col.x -= valueNoise(uv*120.)*0.6;\\n\\n    col.x = clamp(col.x, 0., 1.);\\n    col.y = clamp(col.y, 0., 1.);\\n    // col.z = clamp(col.z, 0., acos(-1.)*2.);\\n    col.z = mod(col.z, acos(-1.)*2.);\\n    col.xyz = oklch_to_srgb(col.xyz);\\n  }\\n  \\n  {\\n    // col.w = smoothstep(1.,0.,(rect_sdf)/abs(fwidth(rect_sdf)));\\n    vec2 dx = dFdx(uv.xy);\\n    vec2 dy = dFdy(uv.xy);\\n    \\n    float sd = sdBox(u,boxSz);\\n    sd = sdBox(u,boxSz - fwidth(sd));\\n    // float sd = sdBox(u,boxSz);\\n\\n    float fw = fwidth((sd));\\n    \\n    #define render(pos)  (1.-step(0.,sdBox(pos,boxSz)))\\n        \\n\\n    \\n    if(fw < 0.004){\\n      col.w *= smoothstep(1.,0.,(sd)/fw);\\n    } else{\\n        float w = 0.;\\n        float _Bias = 1.;\\n        vec2 uvOffsets = vec2(0.125, 0.375);\\n        vec2 offsetUV = vec2(0.0, 0.0);\\n\\n        offsetUV.xy = u.xy + uvOffsets.x * dx + uvOffsets.y * dy;\\n        w += render(offsetUV.xy);\\n        offsetUV.xy = u.xy - uvOffsets.x * dx - uvOffsets.y * dy;\\n        w += render(offsetUV.xy);\\n        offsetUV.xy = u.xy + uvOffsets.y * dx - uvOffsets.x * dy;\\n        w += render(offsetUV.xy);\\n        offsetUV.xy = u.xy - uvOffsets.y * dx + uvOffsets.x * dy;\\n        w += render(offsetUV.xy);\\n        \\n        uvOffsets = uvOffsets * rot(0.25*acos(-1.));\\n        offsetUV.xy = u.xy + uvOffsets.x * dx + uvOffsets.y * dy;\\n        w += render(offsetUV.xy);\\n        offsetUV.xy = u.xy - uvOffsets.x * dx - uvOffsets.y * dy;\\n        w += render(offsetUV.xy);\\n        offsetUV.xy = u.xy + uvOffsets.y * dx - uvOffsets.x * dy;\\n        w += render(offsetUV.xy);\\n        offsetUV.xy = u.xy - uvOffsets.y * dx + uvOffsets.x * dy;\\n        w += render(offsetUV.xy);\\n\\n        w /= 8.;\\n        col.w *= w;\\n        //col.x = 1.;\\n    }\\n\\n    col.w *= sample_brush_tex(brush_texture_idx, uv).w;\\n    // col.w *= texture(brush_texture[1],uv,-4.).w;\\n  }\\n  // col.xyz = uv.xyx;\\n  // col.w *= sample_brush_tex(1, uv).w;\\n  // col.w *= pow(texture(brush_texture[brush_texture_idx],uv).w,1.0);\\n  // col.xyz /= pow(max(col.w,0.001),0.2);\\n  // col.w = length(uv - 0.5) < 0.25 ? 1. : 0.; \\n  // col.xyz = uv.xyx;\\n\\n  // col.xyz = texture(canvas,uv).xyz;\\n}\";";

/***/ }),

/***/ 580:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\n// uniform float time;\\n// uniform float frame;\\n// uniform float zoom;\\n// uniform vec2 panning;\\n// uniform vec2 R;\\n// uniform vec2 canvasR;\\n// uniform vec4 stroke_col;\\n// uniform vec2 stroke_pos;\\n// uniform float stroke_opacity;\\n// uniform vec3 tex_lch_dynamics;\\n// uniform vec2 tex_stretch;\\n// uniform vec2 tilt;\\n// uniform vec2 brush_sz;\\n// uniform float pressure;\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\n// uniform sampler2D brush_texture_0;\\n// uniform sampler2D brush_texture_1;\\n// uniform sampler2D brush_texture_2;\\n// uniform sampler2D brush_texture_3;\\n// uniform sampler2D brush_texture_4;\\n// uniform sampler2D brush_texture_5;\\n// uniform sampler2D brush_texture_6;\\n// uniform sampler2D brush_texture_7;\\n// uniform sampler2D brush_texture_8;\\n// uniform sampler2D brush_texture_9;\\n// uniform sampler2D brush_texture_10;\\n// uniform sampler2D brush_texture_11;\\n// uniform sampler2D brush_texture_12;\\n\\n// uniform float canvas_idx;\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\nout vec2 uv;\\n\\nlayout(location = 0) in vec4 pos;\\nlayout(location = 1) in vec4 col;\\nout vec4 vCol;\\nvoid main(){\\n  // gl_Position.xy *= brush_sz;\\n  gl_Position = vec4(pos.xy,0,1);\\n  \\n  vCol = col;\\n\\n  uv = pos.zw;\\n}  \";";

/***/ }),

/***/ 175:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\n// uniform float time;\\n// uniform float frame;\\n// uniform float zoom;\\n// uniform vec2 panning;\\n// uniform vec2 R;\\n// uniform vec2 canvasR;\\n// uniform vec4 stroke_col;\\n// uniform vec2 stroke_pos;\\n// uniform float stroke_opacity;\\n// uniform vec3 tex_lch_dynamics;\\n// uniform vec2 tex_stretch;\\n// uniform vec2 tilt;\\n// uniform vec2 brush_sz;\\n// uniform float pressure;\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\n// uniform sampler2D brush_texture_0;\\n// uniform sampler2D brush_texture_1;\\n// uniform sampler2D brush_texture_2;\\n// uniform sampler2D brush_texture_3;\\n// uniform sampler2D brush_texture_4;\\n// uniform sampler2D brush_texture_5;\\n// uniform sampler2D brush_texture_6;\\n// uniform sampler2D brush_texture_7;\\n// uniform sampler2D brush_texture_8;\\n// uniform sampler2D brush_texture_9;\\n// uniform sampler2D brush_texture_10;\\n// uniform sampler2D brush_texture_11;\\n// uniform sampler2D brush_texture_12;\\n\\n// uniform float canvas_idx;\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nin vec2 uv;\\nout vec4 col;\\nvoid main() {\\n  col = vec4(1);\\n  // col.xyz = stroke_col.xyz;\\n  \\n  vec2 u = uv;\\n  u = abs(u) \\n    // - 0.5*ndc_aspect_correct(vec2(1),R)\\n    - 0.5/css_contain(vec2(1), canvasR,R);\\n  ;\\n  float rect_sdf = max(u.x,u.y);\\n  // float fw = abs(fwidth(rect_sdf));\\n  // rect_sdf += fw;\\n  rect_sdf = -1.;\\n  if(rect_sdf >0.)\\n    col.xyz = vec3(0);\\n\\n  col.w = 1.;\\n}\";";

/***/ }),

/***/ 218:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\n// uniform float time;\\n// uniform float frame;\\n// uniform float zoom;\\n// uniform vec2 panning;\\n// uniform vec2 R;\\n// uniform vec2 canvasR;\\n// uniform vec4 stroke_col;\\n// uniform vec2 stroke_pos;\\n// uniform float stroke_opacity;\\n// uniform vec3 tex_lch_dynamics;\\n// uniform vec2 tex_stretch;\\n// uniform vec2 tilt;\\n// uniform vec2 brush_sz;\\n// uniform float pressure;\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\n// uniform sampler2D brush_texture_0;\\n// uniform sampler2D brush_texture_1;\\n// uniform sampler2D brush_texture_2;\\n// uniform sampler2D brush_texture_3;\\n// uniform sampler2D brush_texture_4;\\n// uniform sampler2D brush_texture_5;\\n// uniform sampler2D brush_texture_6;\\n// uniform sampler2D brush_texture_7;\\n// uniform sampler2D brush_texture_8;\\n// uniform sampler2D brush_texture_9;\\n// uniform sampler2D brush_texture_10;\\n// uniform sampler2D brush_texture_11;\\n// uniform sampler2D brush_texture_12;\\n\\n// uniform float canvas_idx;\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nuniform float zoom;\\nuniform vec2 brush_sz;\\nout vec2 uv;\\nvoid main(){\\n  gl_Position = vec4(positions[gl_VertexID],0,1);\\n  uv = gl_Position.xy;\\n  // gl_Position.xy *= css_contain(brush_sz*0.25*zoom, canvasR,R);\\n  // gl_Position.xy *= brush_sz*0.5*zoom;\\n  // gl_Position.xy /= css_contain(vec2(1), canvasR,R);\\n\\n  gl_Position.xy *= brush_sz*0.2125*zoom;\\n\\n  vec2 aspect_correction;\\n  if (canvasR.x > canvasR.y) {\\n    aspect_correction.x = canvasR.y / canvasR.x;\\n    aspect_correction.y = 1.;\\n  } else {\\n    aspect_correction.x = 1.;\\n    aspect_correction.y = canvasR.x / canvasR.y;\\n  }\\n  gl_Position.xy *= aspect_correction;\\n  \\n  // gl_Position.xy *= brush_sz*0.5*zoom*ndc_aspect_correct(vec2(1), canvasR);\\n  // gl_Position.xy /= css_contain(vec2(1), R,canvasR);\\n  \\n  // float asp_canvas = canvasR.x/canvasR.y;\\n  // float asp_screen = R.x/R.y;\\n  \\n  // if(asp_canvas < asp_screen){\\n  //   gl_Position.x *= asp_canvas/asp_screen;\\n  // } else {\\n  //   gl_Position.y *= asp_screen/asp_canvas;\\n  // }\\n  gl_Position.xy = css_contain(gl_Position.xy,canvasR,R);\\n\\n  // gl_Position.xy *= ndc_aspect_correct(vec2(1), canvasR);\\n}  \";";

/***/ }),

/***/ 7:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\n// uniform float time;\\n// uniform float frame;\\n// uniform float zoom;\\n// uniform vec2 panning;\\n// uniform vec2 R;\\n// uniform vec2 canvasR;\\n// uniform vec4 stroke_col;\\n// uniform vec2 stroke_pos;\\n// uniform float stroke_opacity;\\n// uniform vec3 tex_lch_dynamics;\\n// uniform vec2 tex_stretch;\\n// uniform vec2 tilt;\\n// uniform vec2 brush_sz;\\n// uniform float pressure;\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\n// uniform sampler2D brush_texture_0;\\n// uniform sampler2D brush_texture_1;\\n// uniform sampler2D brush_texture_2;\\n// uniform sampler2D brush_texture_3;\\n// uniform sampler2D brush_texture_4;\\n// uniform sampler2D brush_texture_5;\\n// uniform sampler2D brush_texture_6;\\n// uniform sampler2D brush_texture_7;\\n// uniform sampler2D brush_texture_8;\\n// uniform sampler2D brush_texture_9;\\n// uniform sampler2D brush_texture_10;\\n// uniform sampler2D brush_texture_11;\\n// uniform sampler2D brush_texture_12;\\n\\n// uniform float canvas_idx;\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\n#ifndef SPECTRAL\\n#define SPECTRAL\\n\\nconst int SPECTRAL_SIZE = 38;\\nconst float SPECTRAL_GAMMA = 2.4;\\nconst float SPECTRAL_EPSILON = 0.0001;\\n\\nfloat spectral_uncompand(float x) {\\n  return (x < 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, SPECTRAL_GAMMA);\\n}\\n\\nfloat spectral_compand(float x) {\\n  return (x < 0.0031308) ? x * 12.92 : 1.055 * pow(x, 1.0 / SPECTRAL_GAMMA) - 0.055;\\n}\\n\\nvec3 spectral_srgb_to_linear(vec3 srgb) {\\n    return vec3(spectral_uncompand(srgb[0]), spectral_uncompand(srgb[1]), spectral_uncompand(srgb[2]));\\n}\\n\\nvec3 spectral_linear_to_srgb(vec3 lrgb) {\\n    return clamp(vec3(spectral_compand(lrgb[0]), spectral_compand(lrgb[1]), spectral_compand(lrgb[2])), 0.0, 1.0);\\n}\\n\\nvoid spectral_upsampling(vec3 lrgb, out float w, out float c, out float m, out float y, out float r, out float g, out float b) {\\n    w = min(lrgb.r, min(lrgb.g, lrgb.b));\\n\\n    lrgb -= w;\\n\\n    c = min(lrgb.g, lrgb.b);\\n    m = min(lrgb.r, lrgb.b);\\n    y = min(lrgb.r, lrgb.g);\\n    r = min(max(0., lrgb.r - lrgb.b), max(0., lrgb.r - lrgb.g));\\n    g = min(max(0., lrgb.g - lrgb.b), max(0., lrgb.g - lrgb.r));\\n    b = min(max(0., lrgb.b - lrgb.g), max(0., lrgb.b - lrgb.r));\\n}\\n\\nvoid spectral_linear_to_reflectance(vec3 lrgb, inout float R[SPECTRAL_SIZE]) {\\n    float w, c, m, y, r, g, b;\\n    \\n    spectral_upsampling(lrgb, w, c, m, y, r, g, b);\\n    \\n     R[0] = max(SPECTRAL_EPSILON, w + c * 0.96853629 + m * 0.51567122 + y * 0.02055257 + r * 0.03147571 + g * 0.49108579 + b * 0.97901834);\\n     R[1] = max(SPECTRAL_EPSILON, w + c * 0.96855103 + m * 0.54015520 + y * 0.02059936 + r * 0.03146636 + g * 0.46944057 + b * 0.97901649);\\n     R[2] = max(SPECTRAL_EPSILON, w + c * 0.96859338 + m * 0.62645502 + y * 0.02062723 + r * 0.03140624 + g * 0.40165780 + b * 0.97901118);\\n     R[3] = max(SPECTRAL_EPSILON, w + c * 0.96877345 + m * 0.75595012 + y * 0.02073387 + r * 0.03119611 + g * 0.24490420 + b * 0.97892146);\\n     R[4] = max(SPECTRAL_EPSILON, w + c * 0.96942204 + m * 0.92826996 + y * 0.02114202 + r * 0.03053888 + g * 0.06826880 + b * 0.97858555);\\n     R[5] = max(SPECTRAL_EPSILON, w + c * 0.97143709 + m * 0.97223624 + y * 0.02233154 + r * 0.02856855 + g * 0.02732883 + b * 0.97743705);\\n     R[6] = max(SPECTRAL_EPSILON, w + c * 0.97541862 + m * 0.98616174 + y * 0.02556857 + r * 0.02459485 + g * 0.01360600 + b * 0.97428075);\\n     R[7] = max(SPECTRAL_EPSILON, w + c * 0.98074186 + m * 0.98955255 + y * 0.03330189 + r * 0.01929520 + g * 0.01000187 + b * 0.96663223);\\n     R[8] = max(SPECTRAL_EPSILON, w + c * 0.98580992 + m * 0.98676237 + y * 0.05185294 + r * 0.01423112 + g * 0.01284127 + b * 0.94822893);\\n     R[9] = max(SPECTRAL_EPSILON, w + c * 0.98971194 + m * 0.97312575 + y * 0.10087639 + r * 0.01033111 + g * 0.02636635 + b * 0.89937713);\\n    R[10] = max(SPECTRAL_EPSILON, w + c * 0.99238027 + m * 0.91944277 + y * 0.24000413 + r * 0.00765876 + g * 0.07058713 + b * 0.76070164);\\n    R[11] = max(SPECTRAL_EPSILON, w + c * 0.99409844 + m * 0.32564851 + y * 0.53589066 + r * 0.00593693 + g * 0.70421692 + b * 0.46420440);\\n    R[12] = max(SPECTRAL_EPSILON, w + c * 0.99517200 + m * 0.13820628 + y * 0.79874659 + r * 0.00485616 + g * 0.85473994 + b * 0.20123039);\\n    R[13] = max(SPECTRAL_EPSILON, w + c * 0.99576545 + m * 0.05015143 + y * 0.91186529 + r * 0.00426186 + g * 0.95081565 + b * 0.08808402);\\n    R[14] = max(SPECTRAL_EPSILON, w + c * 0.99593552 + m * 0.02912336 + y * 0.95399623 + r * 0.00409039 + g * 0.97170370 + b * 0.04592894);\\n    R[15] = max(SPECTRAL_EPSILON, w + c * 0.99564041 + m * 0.02421691 + y * 0.97137099 + r * 0.00438375 + g * 0.97651888 + b * 0.02860373);\\n    R[16] = max(SPECTRAL_EPSILON, w + c * 0.99464769 + m * 0.02660696 + y * 0.97939505 + r * 0.00537525 + g * 0.97429245 + b * 0.02060067);\\n    R[17] = max(SPECTRAL_EPSILON, w + c * 0.99229579 + m * 0.03407586 + y * 0.98345207 + r * 0.00772962 + g * 0.97012917 + b * 0.01656701);\\n    R[18] = max(SPECTRAL_EPSILON, w + c * 0.98638762 + m * 0.04835936 + y * 0.98553736 + r * 0.01366120 + g * 0.94258630 + b * 0.01451549);\\n    R[19] = max(SPECTRAL_EPSILON, w + c * 0.96829712 + m * 0.00011720 + y * 0.98648905 + r * 0.03181352 + g * 0.99989207 + b * 0.01357964);\\n    R[20] = max(SPECTRAL_EPSILON, w + c * 0.89228016 + m * 0.00008554 + y * 0.98674535 + r * 0.10791525 + g * 0.99989891 + b * 0.01331243);\\n    R[21] = max(SPECTRAL_EPSILON, w + c * 0.53740239 + m * 0.85267882 + y * 0.98657555 + r * 0.46249516 + g * 0.13823139 + b * 0.01347661);\\n    R[22] = max(SPECTRAL_EPSILON, w + c * 0.15360445 + m * 0.93188793 + y * 0.98611877 + r * 0.84604333 + g * 0.06968113 + b * 0.01387181);\\n    R[23] = max(SPECTRAL_EPSILON, w + c * 0.05705719 + m * 0.94810268 + y * 0.98559942 + r * 0.94275572 + g * 0.05628787 + b * 0.01435472);\\n    R[24] = max(SPECTRAL_EPSILON, w + c * 0.03126539 + m * 0.94200977 + y * 0.98507063 + r * 0.96860996 + g * 0.06111561 + b * 0.01479836);\\n    R[25] = max(SPECTRAL_EPSILON, w + c * 0.02205445 + m * 0.91478045 + y * 0.98460039 + r * 0.97783966 + g * 0.08987709 + b * 0.01515250);\\n    R[26] = max(SPECTRAL_EPSILON, w + c * 0.01802271 + m * 0.87065445 + y * 0.98425301 + r * 0.98187757 + g * 0.13656016 + b * 0.01540513);\\n    R[27] = max(SPECTRAL_EPSILON, w + c * 0.01613460 + m * 0.78827548 + y * 0.98403909 + r * 0.98377315 + g * 0.22169624 + b * 0.01557233);\\n    R[28] = max(SPECTRAL_EPSILON, w + c * 0.01520947 + m * 0.65738359 + y * 0.98388535 + r * 0.98470202 + g * 0.32176956 + b * 0.01565710);\\n    R[29] = max(SPECTRAL_EPSILON, w + c * 0.01475977 + m * 0.59909403 + y * 0.98376116 + r * 0.98515481 + g * 0.36157329 + b * 0.01571025);\\n    R[30] = max(SPECTRAL_EPSILON, w + c * 0.01454263 + m * 0.56817268 + y * 0.98368246 + r * 0.98537114 + g * 0.48361920 + b * 0.01571916);\\n    R[31] = max(SPECTRAL_EPSILON, w + c * 0.01444459 + m * 0.54031997 + y * 0.98365023 + r * 0.98546685 + g * 0.46488579 + b * 0.01572133);\\n    R[32] = max(SPECTRAL_EPSILON, w + c * 0.01439897 + m * 0.52110241 + y * 0.98361309 + r * 0.98550011 + g * 0.47440306 + b * 0.01572502);\\n    R[33] = max(SPECTRAL_EPSILON, w + c * 0.01437620 + m * 0.51041094 + y * 0.98357259 + r * 0.98551031 + g * 0.48576990 + b * 0.01571717);\\n    R[34] = max(SPECTRAL_EPSILON, w + c * 0.01436343 + m * 0.50526577 + y * 0.98353856 + r * 0.98550741 + g * 0.49267971 + b * 0.01571905);\\n    R[35] = max(SPECTRAL_EPSILON, w + c * 0.01435687 + m * 0.50255080 + y * 0.98351247 + r * 0.98551323 + g * 0.49625685 + b * 0.01571059);\\n    R[36] = max(SPECTRAL_EPSILON, w + c * 0.01435370 + m * 0.50126452 + y * 0.98350101 + r * 0.98551563 + g * 0.49807754 + b * 0.01569728);\\n    R[37] = max(SPECTRAL_EPSILON, w + c * 0.01435408 + m * 0.50083021 + y * 0.98350852 + r * 0.98551547 + g * 0.49889859 + b * 0.01570020);\\n}\\n\\nvec3 spectral_xyz_to_srgb(vec3 xyz) {\\n    mat3 XYZ_RGB;\\n\\n    XYZ_RGB[0] = vec3( 3.24306333, -1.53837619, -0.49893282);\\n    XYZ_RGB[1] = vec3(-0.96896309,  1.87542451,  0.04154303);\\n    XYZ_RGB[2] = vec3( 0.05568392, -0.20417438,  1.05799454);\\n    \\n    float r = dot(XYZ_RGB[0], xyz);\\n    float g = dot(XYZ_RGB[1], xyz);\\n    float b = dot(XYZ_RGB[2], xyz);\\n\\n    return spectral_linear_to_srgb(vec3(r, g, b));\\n}\\n\\nvec3 spectral_reflectance_to_xyz(float R[SPECTRAL_SIZE]) {\\n    vec3 xyz = vec3(0.0);\\n    \\n    xyz +=  R[0] * vec3(0.00006469, 0.00000184, 0.00030502);\\n    xyz +=  R[1] * vec3(0.00021941, 0.00000621, 0.00103681);\\n    xyz +=  R[2] * vec3(0.00112057, 0.00003101, 0.00531314);\\n    xyz +=  R[3] * vec3(0.00376661, 0.00010475, 0.01795439);\\n    xyz +=  R[4] * vec3(0.01188055, 0.00035364, 0.05707758);\\n    xyz +=  R[5] * vec3(0.02328644, 0.00095147, 0.11365162);\\n    xyz +=  R[6] * vec3(0.03455942, 0.00228226, 0.17335873);\\n    xyz +=  R[7] * vec3(0.03722379, 0.00420733, 0.19620658);\\n    xyz +=  R[8] * vec3(0.03241838, 0.00668880, 0.18608237);\\n    xyz +=  R[9] * vec3(0.02123321, 0.00988840, 0.13995048);\\n    xyz += R[10] * vec3(0.01049099, 0.01524945, 0.08917453);\\n    xyz += R[11] * vec3(0.00329584, 0.02141831, 0.04789621);\\n    xyz += R[12] * vec3(0.00050704, 0.03342293, 0.02814563);\\n    xyz += R[13] * vec3(0.00094867, 0.05131001, 0.01613766);\\n    xyz += R[14] * vec3(0.00627372, 0.07040208, 0.00775910);\\n    xyz += R[15] * vec3(0.01686462, 0.08783871, 0.00429615);\\n    xyz += R[16] * vec3(0.02868965, 0.09424905, 0.00200551);\\n    xyz += R[17] * vec3(0.04267481, 0.09795667, 0.00086147);\\n    xyz += R[18] * vec3(0.05625475, 0.09415219, 0.00036904);\\n    xyz += R[19] * vec3(0.06947040, 0.08678102, 0.00019143);\\n    xyz += R[20] * vec3(0.08305315, 0.07885653, 0.00014956);\\n    xyz += R[21] * vec3(0.08612610, 0.06352670, 0.00009231);\\n    xyz += R[22] * vec3(0.09046614, 0.05374142, 0.00006813);\\n    xyz += R[23] * vec3(0.08500387, 0.04264606, 0.00002883);\\n    xyz += R[24] * vec3(0.07090667, 0.03161735, 0.00001577);\\n    xyz += R[25] * vec3(0.05062889, 0.02088521, 0.00000394);\\n    xyz += R[26] * vec3(0.03547396, 0.01386011, 0.00000158);\\n    xyz += R[27] * vec3(0.02146821, 0.00810264, 0.00000000);\\n    xyz += R[28] * vec3(0.01251646, 0.00463010, 0.00000000);\\n    xyz += R[29] * vec3(0.00680458, 0.00249138, 0.00000000);\\n    xyz += R[30] * vec3(0.00346457, 0.00125930, 0.00000000);\\n    xyz += R[31] * vec3(0.00149761, 0.00054165, 0.00000000);\\n    xyz += R[32] * vec3(0.00076970, 0.00027795, 0.00000000);\\n    xyz += R[33] * vec3(0.00040737, 0.00014711, 0.00000000);\\n    xyz += R[34] * vec3(0.00016901, 0.00006103, 0.00000000);\\n    xyz += R[35] * vec3(0.00009522, 0.00003439, 0.00000000);\\n    xyz += R[36] * vec3(0.00004903, 0.00001771, 0.00000000);\\n    xyz += R[37] * vec3(0.00002000, 0.00000722, 0.00000000);\\n\\n    return xyz;\\n}\\n\\nfloat spectral_linear_to_concentration(float l1, float l2, float t) {\\n    float t1 = l1 * pow(1.0 - t, 2.0);\\n    float t2 = l2 * pow(t, 2.0);\\n\\n    return t2 / (t1 + t2);\\n}\\n\\nvec3 spectral_mix(vec3 color1, vec3 color2, float t) {\\n    vec3 lrgb1 = spectral_srgb_to_linear(color1);\\n    vec3 lrgb2 = spectral_srgb_to_linear(color2);\\n\\n    float R1[SPECTRAL_SIZE];\\n    float R2[SPECTRAL_SIZE];\\n\\n    spectral_linear_to_reflectance(lrgb1, R1);\\n    spectral_linear_to_reflectance(lrgb2, R2);\\n\\n    float l1 = spectral_reflectance_to_xyz(R1)[1];\\n    float l2 = spectral_reflectance_to_xyz(R2)[1];\\n\\n    t = spectral_linear_to_concentration(l1, l2, t);\\n\\n    float R[SPECTRAL_SIZE];\\n\\n    for (int i = 0; i < SPECTRAL_SIZE; i++) {\\n      float KS = (1.0 - t) * (pow(1.0 - R1[i], 2.0) / (2.0 * R1[i])) + t * (pow(1.0 - R2[i], 2.0) / (2.0 * R2[i]));\\n      float KM = 1.0 + KS - sqrt(pow(KS, 2.0) + 2.0 * KS);\\n\\n      //Saunderson correction\\n      // let S = ((1.0 - K1) * (1.0 - K2) * KM) / (1.0 - K2 * KM);\\n\\n      R[i] = KM;\\n    }\\n\\n    return spectral_xyz_to_srgb(spectral_reflectance_to_xyz(R));\\n}\\n\\nvec4 spectral_mix(vec4 color1, vec4 color2, float t) {\\n    return vec4(spectral_mix(color1.rgb, color2.rgb, t), mix(color1.a, color2.a, t));\\n}\\n\\n#endif\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nvec4 blend_brushstroke(vec4 col, vec4 stroke, int blending_colour_space){\\n  // col.xyz = mix(col.xyz, stroke.xyz, stroke.w); \\n  \\n  int mode = blending_colour_space;\\n  \\n  if(stroke.w > 0.00000001){\\n    // float interpolant = stroke.w;\\n    stroke.xyz = stroke.xyz/max(stroke.w,0.001);\\n    \\n    if(mode == 0){\\n      col.xyz = spectral_mix(col.xyz, clamp(stroke.xyz,0.00001,0.99999), stroke.w);\\n      if(stroke.w > 0.99999)\\n        col.xyz = stroke.xyz;\\n    } else if(mode == 1){\\n      col.xyz = srgb_to_oklch( col.xyz );\\n      stroke.xyz = srgb_to_oklch( stroke.xyz );\\n      col.xy = mix(col.xy, stroke.xy,stroke.w);\\n      float tau = acos(-1.) * 2.;\\n      float h_a = stroke.z;\\n      float h_b = stroke.z + tau;\\n      float dist_a = abs(col.z - h_a);\\n      float dist_b = abs(col.z - h_b);\\n      if(dist_a < dist_b){\\n        col.z = mix(col.z, h_a, stroke.w);\\n      } else {\\n        col.z = mix(col.z, h_b, stroke.w);\\n      }\\n      col.z = mod(col.z, tau);\\n      // col.z = max(col.z)\\n      // if(isnan(col.z)){\\n      //   col.z = 1.;\\n      // }\\n\\n      col.xyz = oklch_to_srgb( col.xyz );\\n      col.xyz = clamp(col.xyz,0.,1.);\\n    \\n    } else {\\n      col.xyz = mix(col.xyz, stroke.xyz, stroke.w);\\n    }\\n    col.w = max(col.w, stroke.w);\\n  }\\n\\n  return col; \\n}\\n\\n// uniform float pong_idx;\\nuniform int amogus;\\nuniform int blending_colour_space;\\nin vec2 uv;\\nout vec4 col;\\nvoid main() {\\n  // col = texture(canvas_back,uv);\\n  \\n  col = texture(canvas_a,uv);\\n  col.w = 1.;\\n\\n    // col.xyzw = vec4(1);\\n\\n  vec4 temp_tex = texture(temp_tex,uv);\\n  // col.xyz = mix(col.xyz, temp_tex.xyz, temp_tex.w);\\n \\n  if(temp_tex.w > 0.000001)\\n    col = blend_brushstroke(col,temp_tex,blending_colour_space); \\n}      \";";

/***/ }),

/***/ 275:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\n// uniform float time;\\n// uniform float frame;\\n// uniform float zoom;\\n// uniform vec2 panning;\\n// uniform vec2 R;\\n// uniform vec2 canvasR;\\n// uniform vec4 stroke_col;\\n// uniform vec2 stroke_pos;\\n// uniform float stroke_opacity;\\n// uniform vec3 tex_lch_dynamics;\\n// uniform vec2 tex_stretch;\\n// uniform vec2 tilt;\\n// uniform vec2 brush_sz;\\n// uniform float pressure;\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\n// uniform sampler2D brush_texture_0;\\n// uniform sampler2D brush_texture_1;\\n// uniform sampler2D brush_texture_2;\\n// uniform sampler2D brush_texture_3;\\n// uniform sampler2D brush_texture_4;\\n// uniform sampler2D brush_texture_5;\\n// uniform sampler2D brush_texture_6;\\n// uniform sampler2D brush_texture_7;\\n// uniform sampler2D brush_texture_8;\\n// uniform sampler2D brush_texture_9;\\n// uniform sampler2D brush_texture_10;\\n// uniform sampler2D brush_texture_11;\\n// uniform sampler2D brush_texture_12;\\n\\n// uniform float canvas_idx;\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\nout vec2 uv;\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nvoid main(){\\n  uv = positions[gl_VertexID];\\n  uv = uv*0.5 + 0.5;\\n  gl_Position = vec4(positions[gl_VertexID],0,1);\\n  // gl_Position.xy = css_contain(gl_Position.xy, canvasR, R);\\n}  \";";

/***/ }),

/***/ 493:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\n// uniform float time;\\n// uniform float frame;\\n// uniform float zoom;\\n// uniform vec2 panning;\\n// uniform vec2 R;\\n// uniform vec2 canvasR;\\n// uniform vec4 stroke_col;\\n// uniform vec2 stroke_pos;\\n// uniform float stroke_opacity;\\n// uniform vec3 tex_lch_dynamics;\\n// uniform vec2 tex_stretch;\\n// uniform vec2 tilt;\\n// uniform vec2 brush_sz;\\n// uniform float pressure;\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\n// uniform sampler2D brush_texture_0;\\n// uniform sampler2D brush_texture_1;\\n// uniform sampler2D brush_texture_2;\\n// uniform sampler2D brush_texture_3;\\n// uniform sampler2D brush_texture_4;\\n// uniform sampler2D brush_texture_5;\\n// uniform sampler2D brush_texture_6;\\n// uniform sampler2D brush_texture_7;\\n// uniform sampler2D brush_texture_8;\\n// uniform sampler2D brush_texture_9;\\n// uniform sampler2D brush_texture_10;\\n// uniform sampler2D brush_texture_11;\\n// uniform sampler2D brush_texture_12;\\n\\n// uniform float canvas_idx;\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\n#ifndef SPECTRAL\\n#define SPECTRAL\\n\\nconst int SPECTRAL_SIZE = 38;\\nconst float SPECTRAL_GAMMA = 2.4;\\nconst float SPECTRAL_EPSILON = 0.0001;\\n\\nfloat spectral_uncompand(float x) {\\n  return (x < 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, SPECTRAL_GAMMA);\\n}\\n\\nfloat spectral_compand(float x) {\\n  return (x < 0.0031308) ? x * 12.92 : 1.055 * pow(x, 1.0 / SPECTRAL_GAMMA) - 0.055;\\n}\\n\\nvec3 spectral_srgb_to_linear(vec3 srgb) {\\n    return vec3(spectral_uncompand(srgb[0]), spectral_uncompand(srgb[1]), spectral_uncompand(srgb[2]));\\n}\\n\\nvec3 spectral_linear_to_srgb(vec3 lrgb) {\\n    return clamp(vec3(spectral_compand(lrgb[0]), spectral_compand(lrgb[1]), spectral_compand(lrgb[2])), 0.0, 1.0);\\n}\\n\\nvoid spectral_upsampling(vec3 lrgb, out float w, out float c, out float m, out float y, out float r, out float g, out float b) {\\n    w = min(lrgb.r, min(lrgb.g, lrgb.b));\\n\\n    lrgb -= w;\\n\\n    c = min(lrgb.g, lrgb.b);\\n    m = min(lrgb.r, lrgb.b);\\n    y = min(lrgb.r, lrgb.g);\\n    r = min(max(0., lrgb.r - lrgb.b), max(0., lrgb.r - lrgb.g));\\n    g = min(max(0., lrgb.g - lrgb.b), max(0., lrgb.g - lrgb.r));\\n    b = min(max(0., lrgb.b - lrgb.g), max(0., lrgb.b - lrgb.r));\\n}\\n\\nvoid spectral_linear_to_reflectance(vec3 lrgb, inout float R[SPECTRAL_SIZE]) {\\n    float w, c, m, y, r, g, b;\\n    \\n    spectral_upsampling(lrgb, w, c, m, y, r, g, b);\\n    \\n     R[0] = max(SPECTRAL_EPSILON, w + c * 0.96853629 + m * 0.51567122 + y * 0.02055257 + r * 0.03147571 + g * 0.49108579 + b * 0.97901834);\\n     R[1] = max(SPECTRAL_EPSILON, w + c * 0.96855103 + m * 0.54015520 + y * 0.02059936 + r * 0.03146636 + g * 0.46944057 + b * 0.97901649);\\n     R[2] = max(SPECTRAL_EPSILON, w + c * 0.96859338 + m * 0.62645502 + y * 0.02062723 + r * 0.03140624 + g * 0.40165780 + b * 0.97901118);\\n     R[3] = max(SPECTRAL_EPSILON, w + c * 0.96877345 + m * 0.75595012 + y * 0.02073387 + r * 0.03119611 + g * 0.24490420 + b * 0.97892146);\\n     R[4] = max(SPECTRAL_EPSILON, w + c * 0.96942204 + m * 0.92826996 + y * 0.02114202 + r * 0.03053888 + g * 0.06826880 + b * 0.97858555);\\n     R[5] = max(SPECTRAL_EPSILON, w + c * 0.97143709 + m * 0.97223624 + y * 0.02233154 + r * 0.02856855 + g * 0.02732883 + b * 0.97743705);\\n     R[6] = max(SPECTRAL_EPSILON, w + c * 0.97541862 + m * 0.98616174 + y * 0.02556857 + r * 0.02459485 + g * 0.01360600 + b * 0.97428075);\\n     R[7] = max(SPECTRAL_EPSILON, w + c * 0.98074186 + m * 0.98955255 + y * 0.03330189 + r * 0.01929520 + g * 0.01000187 + b * 0.96663223);\\n     R[8] = max(SPECTRAL_EPSILON, w + c * 0.98580992 + m * 0.98676237 + y * 0.05185294 + r * 0.01423112 + g * 0.01284127 + b * 0.94822893);\\n     R[9] = max(SPECTRAL_EPSILON, w + c * 0.98971194 + m * 0.97312575 + y * 0.10087639 + r * 0.01033111 + g * 0.02636635 + b * 0.89937713);\\n    R[10] = max(SPECTRAL_EPSILON, w + c * 0.99238027 + m * 0.91944277 + y * 0.24000413 + r * 0.00765876 + g * 0.07058713 + b * 0.76070164);\\n    R[11] = max(SPECTRAL_EPSILON, w + c * 0.99409844 + m * 0.32564851 + y * 0.53589066 + r * 0.00593693 + g * 0.70421692 + b * 0.46420440);\\n    R[12] = max(SPECTRAL_EPSILON, w + c * 0.99517200 + m * 0.13820628 + y * 0.79874659 + r * 0.00485616 + g * 0.85473994 + b * 0.20123039);\\n    R[13] = max(SPECTRAL_EPSILON, w + c * 0.99576545 + m * 0.05015143 + y * 0.91186529 + r * 0.00426186 + g * 0.95081565 + b * 0.08808402);\\n    R[14] = max(SPECTRAL_EPSILON, w + c * 0.99593552 + m * 0.02912336 + y * 0.95399623 + r * 0.00409039 + g * 0.97170370 + b * 0.04592894);\\n    R[15] = max(SPECTRAL_EPSILON, w + c * 0.99564041 + m * 0.02421691 + y * 0.97137099 + r * 0.00438375 + g * 0.97651888 + b * 0.02860373);\\n    R[16] = max(SPECTRAL_EPSILON, w + c * 0.99464769 + m * 0.02660696 + y * 0.97939505 + r * 0.00537525 + g * 0.97429245 + b * 0.02060067);\\n    R[17] = max(SPECTRAL_EPSILON, w + c * 0.99229579 + m * 0.03407586 + y * 0.98345207 + r * 0.00772962 + g * 0.97012917 + b * 0.01656701);\\n    R[18] = max(SPECTRAL_EPSILON, w + c * 0.98638762 + m * 0.04835936 + y * 0.98553736 + r * 0.01366120 + g * 0.94258630 + b * 0.01451549);\\n    R[19] = max(SPECTRAL_EPSILON, w + c * 0.96829712 + m * 0.00011720 + y * 0.98648905 + r * 0.03181352 + g * 0.99989207 + b * 0.01357964);\\n    R[20] = max(SPECTRAL_EPSILON, w + c * 0.89228016 + m * 0.00008554 + y * 0.98674535 + r * 0.10791525 + g * 0.99989891 + b * 0.01331243);\\n    R[21] = max(SPECTRAL_EPSILON, w + c * 0.53740239 + m * 0.85267882 + y * 0.98657555 + r * 0.46249516 + g * 0.13823139 + b * 0.01347661);\\n    R[22] = max(SPECTRAL_EPSILON, w + c * 0.15360445 + m * 0.93188793 + y * 0.98611877 + r * 0.84604333 + g * 0.06968113 + b * 0.01387181);\\n    R[23] = max(SPECTRAL_EPSILON, w + c * 0.05705719 + m * 0.94810268 + y * 0.98559942 + r * 0.94275572 + g * 0.05628787 + b * 0.01435472);\\n    R[24] = max(SPECTRAL_EPSILON, w + c * 0.03126539 + m * 0.94200977 + y * 0.98507063 + r * 0.96860996 + g * 0.06111561 + b * 0.01479836);\\n    R[25] = max(SPECTRAL_EPSILON, w + c * 0.02205445 + m * 0.91478045 + y * 0.98460039 + r * 0.97783966 + g * 0.08987709 + b * 0.01515250);\\n    R[26] = max(SPECTRAL_EPSILON, w + c * 0.01802271 + m * 0.87065445 + y * 0.98425301 + r * 0.98187757 + g * 0.13656016 + b * 0.01540513);\\n    R[27] = max(SPECTRAL_EPSILON, w + c * 0.01613460 + m * 0.78827548 + y * 0.98403909 + r * 0.98377315 + g * 0.22169624 + b * 0.01557233);\\n    R[28] = max(SPECTRAL_EPSILON, w + c * 0.01520947 + m * 0.65738359 + y * 0.98388535 + r * 0.98470202 + g * 0.32176956 + b * 0.01565710);\\n    R[29] = max(SPECTRAL_EPSILON, w + c * 0.01475977 + m * 0.59909403 + y * 0.98376116 + r * 0.98515481 + g * 0.36157329 + b * 0.01571025);\\n    R[30] = max(SPECTRAL_EPSILON, w + c * 0.01454263 + m * 0.56817268 + y * 0.98368246 + r * 0.98537114 + g * 0.48361920 + b * 0.01571916);\\n    R[31] = max(SPECTRAL_EPSILON, w + c * 0.01444459 + m * 0.54031997 + y * 0.98365023 + r * 0.98546685 + g * 0.46488579 + b * 0.01572133);\\n    R[32] = max(SPECTRAL_EPSILON, w + c * 0.01439897 + m * 0.52110241 + y * 0.98361309 + r * 0.98550011 + g * 0.47440306 + b * 0.01572502);\\n    R[33] = max(SPECTRAL_EPSILON, w + c * 0.01437620 + m * 0.51041094 + y * 0.98357259 + r * 0.98551031 + g * 0.48576990 + b * 0.01571717);\\n    R[34] = max(SPECTRAL_EPSILON, w + c * 0.01436343 + m * 0.50526577 + y * 0.98353856 + r * 0.98550741 + g * 0.49267971 + b * 0.01571905);\\n    R[35] = max(SPECTRAL_EPSILON, w + c * 0.01435687 + m * 0.50255080 + y * 0.98351247 + r * 0.98551323 + g * 0.49625685 + b * 0.01571059);\\n    R[36] = max(SPECTRAL_EPSILON, w + c * 0.01435370 + m * 0.50126452 + y * 0.98350101 + r * 0.98551563 + g * 0.49807754 + b * 0.01569728);\\n    R[37] = max(SPECTRAL_EPSILON, w + c * 0.01435408 + m * 0.50083021 + y * 0.98350852 + r * 0.98551547 + g * 0.49889859 + b * 0.01570020);\\n}\\n\\nvec3 spectral_xyz_to_srgb(vec3 xyz) {\\n    mat3 XYZ_RGB;\\n\\n    XYZ_RGB[0] = vec3( 3.24306333, -1.53837619, -0.49893282);\\n    XYZ_RGB[1] = vec3(-0.96896309,  1.87542451,  0.04154303);\\n    XYZ_RGB[2] = vec3( 0.05568392, -0.20417438,  1.05799454);\\n    \\n    float r = dot(XYZ_RGB[0], xyz);\\n    float g = dot(XYZ_RGB[1], xyz);\\n    float b = dot(XYZ_RGB[2], xyz);\\n\\n    return spectral_linear_to_srgb(vec3(r, g, b));\\n}\\n\\nvec3 spectral_reflectance_to_xyz(float R[SPECTRAL_SIZE]) {\\n    vec3 xyz = vec3(0.0);\\n    \\n    xyz +=  R[0] * vec3(0.00006469, 0.00000184, 0.00030502);\\n    xyz +=  R[1] * vec3(0.00021941, 0.00000621, 0.00103681);\\n    xyz +=  R[2] * vec3(0.00112057, 0.00003101, 0.00531314);\\n    xyz +=  R[3] * vec3(0.00376661, 0.00010475, 0.01795439);\\n    xyz +=  R[4] * vec3(0.01188055, 0.00035364, 0.05707758);\\n    xyz +=  R[5] * vec3(0.02328644, 0.00095147, 0.11365162);\\n    xyz +=  R[6] * vec3(0.03455942, 0.00228226, 0.17335873);\\n    xyz +=  R[7] * vec3(0.03722379, 0.00420733, 0.19620658);\\n    xyz +=  R[8] * vec3(0.03241838, 0.00668880, 0.18608237);\\n    xyz +=  R[9] * vec3(0.02123321, 0.00988840, 0.13995048);\\n    xyz += R[10] * vec3(0.01049099, 0.01524945, 0.08917453);\\n    xyz += R[11] * vec3(0.00329584, 0.02141831, 0.04789621);\\n    xyz += R[12] * vec3(0.00050704, 0.03342293, 0.02814563);\\n    xyz += R[13] * vec3(0.00094867, 0.05131001, 0.01613766);\\n    xyz += R[14] * vec3(0.00627372, 0.07040208, 0.00775910);\\n    xyz += R[15] * vec3(0.01686462, 0.08783871, 0.00429615);\\n    xyz += R[16] * vec3(0.02868965, 0.09424905, 0.00200551);\\n    xyz += R[17] * vec3(0.04267481, 0.09795667, 0.00086147);\\n    xyz += R[18] * vec3(0.05625475, 0.09415219, 0.00036904);\\n    xyz += R[19] * vec3(0.06947040, 0.08678102, 0.00019143);\\n    xyz += R[20] * vec3(0.08305315, 0.07885653, 0.00014956);\\n    xyz += R[21] * vec3(0.08612610, 0.06352670, 0.00009231);\\n    xyz += R[22] * vec3(0.09046614, 0.05374142, 0.00006813);\\n    xyz += R[23] * vec3(0.08500387, 0.04264606, 0.00002883);\\n    xyz += R[24] * vec3(0.07090667, 0.03161735, 0.00001577);\\n    xyz += R[25] * vec3(0.05062889, 0.02088521, 0.00000394);\\n    xyz += R[26] * vec3(0.03547396, 0.01386011, 0.00000158);\\n    xyz += R[27] * vec3(0.02146821, 0.00810264, 0.00000000);\\n    xyz += R[28] * vec3(0.01251646, 0.00463010, 0.00000000);\\n    xyz += R[29] * vec3(0.00680458, 0.00249138, 0.00000000);\\n    xyz += R[30] * vec3(0.00346457, 0.00125930, 0.00000000);\\n    xyz += R[31] * vec3(0.00149761, 0.00054165, 0.00000000);\\n    xyz += R[32] * vec3(0.00076970, 0.00027795, 0.00000000);\\n    xyz += R[33] * vec3(0.00040737, 0.00014711, 0.00000000);\\n    xyz += R[34] * vec3(0.00016901, 0.00006103, 0.00000000);\\n    xyz += R[35] * vec3(0.00009522, 0.00003439, 0.00000000);\\n    xyz += R[36] * vec3(0.00004903, 0.00001771, 0.00000000);\\n    xyz += R[37] * vec3(0.00002000, 0.00000722, 0.00000000);\\n\\n    return xyz;\\n}\\n\\nfloat spectral_linear_to_concentration(float l1, float l2, float t) {\\n    float t1 = l1 * pow(1.0 - t, 2.0);\\n    float t2 = l2 * pow(t, 2.0);\\n\\n    return t2 / (t1 + t2);\\n}\\n\\nvec3 spectral_mix(vec3 color1, vec3 color2, float t) {\\n    vec3 lrgb1 = spectral_srgb_to_linear(color1);\\n    vec3 lrgb2 = spectral_srgb_to_linear(color2);\\n\\n    float R1[SPECTRAL_SIZE];\\n    float R2[SPECTRAL_SIZE];\\n\\n    spectral_linear_to_reflectance(lrgb1, R1);\\n    spectral_linear_to_reflectance(lrgb2, R2);\\n\\n    float l1 = spectral_reflectance_to_xyz(R1)[1];\\n    float l2 = spectral_reflectance_to_xyz(R2)[1];\\n\\n    t = spectral_linear_to_concentration(l1, l2, t);\\n\\n    float R[SPECTRAL_SIZE];\\n\\n    for (int i = 0; i < SPECTRAL_SIZE; i++) {\\n      float KS = (1.0 - t) * (pow(1.0 - R1[i], 2.0) / (2.0 * R1[i])) + t * (pow(1.0 - R2[i], 2.0) / (2.0 * R2[i]));\\n      float KM = 1.0 + KS - sqrt(pow(KS, 2.0) + 2.0 * KS);\\n\\n      //Saunderson correction\\n      // let S = ((1.0 - K1) * (1.0 - K2) * KM) / (1.0 - K2 * KM);\\n\\n      R[i] = KM;\\n    }\\n\\n    return spectral_xyz_to_srgb(spectral_reflectance_to_xyz(R));\\n}\\n\\nvec4 spectral_mix(vec4 color1, vec4 color2, float t) {\\n    return vec4(spectral_mix(color1.rgb, color2.rgb, t), mix(color1.a, color2.a, t));\\n}\\n\\n#endif\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nvec4 blend_brushstroke(vec4 col, vec4 stroke, int blending_colour_space){\\n  // col.xyz = mix(col.xyz, stroke.xyz, stroke.w); \\n  \\n  int mode = blending_colour_space;\\n  \\n  if(stroke.w > 0.00000001){\\n    // float interpolant = stroke.w;\\n    stroke.xyz = stroke.xyz/max(stroke.w,0.001);\\n    \\n    if(mode == 0){\\n      col.xyz = spectral_mix(col.xyz, clamp(stroke.xyz,0.00001,0.99999), stroke.w);\\n      if(stroke.w > 0.99999)\\n        col.xyz = stroke.xyz;\\n    } else if(mode == 1){\\n      col.xyz = srgb_to_oklch( col.xyz );\\n      stroke.xyz = srgb_to_oklch( stroke.xyz );\\n      col.xy = mix(col.xy, stroke.xy,stroke.w);\\n      float tau = acos(-1.) * 2.;\\n      float h_a = stroke.z;\\n      float h_b = stroke.z + tau;\\n      float dist_a = abs(col.z - h_a);\\n      float dist_b = abs(col.z - h_b);\\n      if(dist_a < dist_b){\\n        col.z = mix(col.z, h_a, stroke.w);\\n      } else {\\n        col.z = mix(col.z, h_b, stroke.w);\\n      }\\n      col.z = mod(col.z, tau);\\n      // col.z = max(col.z)\\n      // if(isnan(col.z)){\\n      //   col.z = 1.;\\n      // }\\n\\n      col.xyz = oklch_to_srgb( col.xyz );\\n      col.xyz = clamp(col.xyz,0.,1.);\\n    \\n    } else {\\n      col.xyz = mix(col.xyz, stroke.xyz, stroke.w);\\n    }\\n    col.w = max(col.w, stroke.w);\\n  }\\n\\n  return col; \\n}\\n\\n// uniform float pong_idx;\\nuniform int amogus;\\nuniform int blending_colour_space;\\nin vec2 uv;\\nout vec4 col;\\nvoid main() {\\n  // col = texture(canvas_back,uv);\\n  \\n  col = texture(canvas_b,uv);\\n  col.w = 1.;\\n\\n    // col.xyzw = vec4(1);\\n\\n  vec4 temp_tex = texture(temp_tex,uv);\\n  // col.xyz = mix(col.xyz, temp_tex.xyz, temp_tex.w);\\n \\n  if(temp_tex.w > 0.000001)\\n    col = blend_brushstroke(col,temp_tex,blending_colour_space); \\n}      \";";

/***/ }),

/***/ 754:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\n// uniform float time;\\n// uniform float frame;\\n// uniform float zoom;\\n// uniform vec2 panning;\\n// uniform vec2 R;\\n// uniform vec2 canvasR;\\n// uniform vec4 stroke_col;\\n// uniform vec2 stroke_pos;\\n// uniform float stroke_opacity;\\n// uniform vec3 tex_lch_dynamics;\\n// uniform vec2 tex_stretch;\\n// uniform vec2 tilt;\\n// uniform vec2 brush_sz;\\n// uniform float pressure;\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\n// uniform sampler2D brush_texture_0;\\n// uniform sampler2D brush_texture_1;\\n// uniform sampler2D brush_texture_2;\\n// uniform sampler2D brush_texture_3;\\n// uniform sampler2D brush_texture_4;\\n// uniform sampler2D brush_texture_5;\\n// uniform sampler2D brush_texture_6;\\n// uniform sampler2D brush_texture_7;\\n// uniform sampler2D brush_texture_8;\\n// uniform sampler2D brush_texture_9;\\n// uniform sampler2D brush_texture_10;\\n// uniform sampler2D brush_texture_11;\\n// uniform sampler2D brush_texture_12;\\n\\n// uniform float canvas_idx;\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nuint seed = 11425u;\\n\\nuint hash_u(uint _a) {\\n   uint a = _a;\\n   a ^= a >> 16;\\n   a *= 0x7feb352du;\\n   a ^= a >> 15;\\n   a *= 0x846ca68bu;\\n   a ^= a >> 16;\\n   return a; \\n }\\nfloat hash_f(){ uint s = hash_u(seed); seed = s;return ( float( s ) / float( 0xffffffffu ) ); }\\nvec2 hash_v2(){ return vec2(hash_f(), hash_f()); }\\nvec3 hash_v3(){ return vec3(hash_f(), hash_f(), hash_f()); }\\nvec4 hash_v4(){ return vec4(hash_f(), hash_f(), hash_f(), hash_f()); }\\n\\nfloat hash_f_s(uint s){ s = hash_u(s); return ( float( s ) / float( 0xffffffffu ) ); }\\n// vec2 hash_22_s(uvec2 s){ uint _s = hash_u(s.x) + hash_u(s.y); return vec2(hash_f_s(_s.x), hash_f_s(_s.y)); }\\nfloat hash_21_s(ivec2 _s_){ \\n  uvec2 s = uvec2(_s_);\\n  uint _s = hash_u(s.x + hash_u(s.y)) + hash_u(s.y + hash_u(s.x)); \\n  return hash_f_s(_s); \\n}\\n// vec3 hash_23_s(){ return vec3(hash_f_s(), hash_f_s(), hash_f_s()); }\\n// vec4 hash_24_s(){ return vec4(hash_f_s(), hash_f_s(), hash_f_s(), hash_f_s()); }\\n\\nfloat valueNoise( in vec2 p ){\\n    p += 100.;\\n    ivec2 i = ivec2(floor( p ));\\n    vec2 f = fract( p );\\n\\n    // cubic interpolant\\n    vec2 u = f*f*(3.0-2.0*f);\\n\\n    return mix( mix( hash_21_s( i + ivec2(0,0) ), \\n                     hash_21_s( i + ivec2(1,0) ), u.x),\\n                mix( hash_21_s( i + ivec2(0,1) ), \\n                     hash_21_s( i + ivec2(1,1) ), u.x), u.y);\\n}\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nuniform vec3 picked_col;\\n\\nin vec2 uv;\\nout vec4 col;\\nvoid main() {\\n  // col = vec4(1);\\n  col.xyz = picked_col;\\n  \\n  vec2 u = uv;\\n  u = abs(u) - 0.8;\\n  float rect_sdf = max(u.x,u.y);\\n  // float fw = abs(fwidth(rect_sdf));\\n  // rect_sdf += fw;\\n  if(rect_sdf >0.)\\n    col.xyz = vec3(1);\\n\\n  col.w = 1.;\\n  // col.xyz *= 1.;\\n  // col.xyz = vec3(1);\\n}\";";

/***/ }),

/***/ 451:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\n// uniform float time;\\n// uniform float frame;\\n// uniform float zoom;\\n// uniform vec2 panning;\\n// uniform vec2 R;\\n// uniform vec2 canvasR;\\n// uniform vec4 stroke_col;\\n// uniform vec2 stroke_pos;\\n// uniform float stroke_opacity;\\n// uniform vec3 tex_lch_dynamics;\\n// uniform vec2 tex_stretch;\\n// uniform vec2 tilt;\\n// uniform vec2 brush_sz;\\n// uniform float pressure;\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\n// uniform sampler2D brush_texture_0;\\n// uniform sampler2D brush_texture_1;\\n// uniform sampler2D brush_texture_2;\\n// uniform sampler2D brush_texture_3;\\n// uniform sampler2D brush_texture_4;\\n// uniform sampler2D brush_texture_5;\\n// uniform sampler2D brush_texture_6;\\n// uniform sampler2D brush_texture_7;\\n// uniform sampler2D brush_texture_8;\\n// uniform sampler2D brush_texture_9;\\n// uniform sampler2D brush_texture_10;\\n// uniform sampler2D brush_texture_11;\\n// uniform sampler2D brush_texture_12;\\n\\n// uniform float canvas_idx;\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nuniform vec2 picker_pos;\\nout vec2 uv;\\nvoid main(){\\n  gl_Position = vec4(positions[gl_VertexID],0,1);\\n  uv = gl_Position.xy;\\n  gl_Position.xy *= ndc_aspect_correct(vec2(0.05), R);\\n  gl_Position.xy += picker_pos;\\n}\";";

/***/ }),

/***/ 38:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\n// uniform float time;\\n// uniform float frame;\\n// uniform float zoom;\\n// uniform vec2 panning;\\n// uniform vec2 R;\\n// uniform vec2 canvasR;\\n// uniform vec4 stroke_col;\\n// uniform vec2 stroke_pos;\\n// uniform float stroke_opacity;\\n// uniform vec3 tex_lch_dynamics;\\n// uniform vec2 tex_stretch;\\n// uniform vec2 tilt;\\n// uniform vec2 brush_sz;\\n// uniform float pressure;\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\n// uniform sampler2D brush_texture_0;\\n// uniform sampler2D brush_texture_1;\\n// uniform sampler2D brush_texture_2;\\n// uniform sampler2D brush_texture_3;\\n// uniform sampler2D brush_texture_4;\\n// uniform sampler2D brush_texture_5;\\n// uniform sampler2D brush_texture_6;\\n// uniform sampler2D brush_texture_7;\\n// uniform sampler2D brush_texture_8;\\n// uniform sampler2D brush_texture_9;\\n// uniform sampler2D brush_texture_10;\\n// uniform sampler2D brush_texture_11;\\n// uniform sampler2D brush_texture_12;\\n\\n// uniform float canvas_idx;\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\n#ifndef SPECTRAL\\n#define SPECTRAL\\n\\nconst int SPECTRAL_SIZE = 38;\\nconst float SPECTRAL_GAMMA = 2.4;\\nconst float SPECTRAL_EPSILON = 0.0001;\\n\\nfloat spectral_uncompand(float x) {\\n  return (x < 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, SPECTRAL_GAMMA);\\n}\\n\\nfloat spectral_compand(float x) {\\n  return (x < 0.0031308) ? x * 12.92 : 1.055 * pow(x, 1.0 / SPECTRAL_GAMMA) - 0.055;\\n}\\n\\nvec3 spectral_srgb_to_linear(vec3 srgb) {\\n    return vec3(spectral_uncompand(srgb[0]), spectral_uncompand(srgb[1]), spectral_uncompand(srgb[2]));\\n}\\n\\nvec3 spectral_linear_to_srgb(vec3 lrgb) {\\n    return clamp(vec3(spectral_compand(lrgb[0]), spectral_compand(lrgb[1]), spectral_compand(lrgb[2])), 0.0, 1.0);\\n}\\n\\nvoid spectral_upsampling(vec3 lrgb, out float w, out float c, out float m, out float y, out float r, out float g, out float b) {\\n    w = min(lrgb.r, min(lrgb.g, lrgb.b));\\n\\n    lrgb -= w;\\n\\n    c = min(lrgb.g, lrgb.b);\\n    m = min(lrgb.r, lrgb.b);\\n    y = min(lrgb.r, lrgb.g);\\n    r = min(max(0., lrgb.r - lrgb.b), max(0., lrgb.r - lrgb.g));\\n    g = min(max(0., lrgb.g - lrgb.b), max(0., lrgb.g - lrgb.r));\\n    b = min(max(0., lrgb.b - lrgb.g), max(0., lrgb.b - lrgb.r));\\n}\\n\\nvoid spectral_linear_to_reflectance(vec3 lrgb, inout float R[SPECTRAL_SIZE]) {\\n    float w, c, m, y, r, g, b;\\n    \\n    spectral_upsampling(lrgb, w, c, m, y, r, g, b);\\n    \\n     R[0] = max(SPECTRAL_EPSILON, w + c * 0.96853629 + m * 0.51567122 + y * 0.02055257 + r * 0.03147571 + g * 0.49108579 + b * 0.97901834);\\n     R[1] = max(SPECTRAL_EPSILON, w + c * 0.96855103 + m * 0.54015520 + y * 0.02059936 + r * 0.03146636 + g * 0.46944057 + b * 0.97901649);\\n     R[2] = max(SPECTRAL_EPSILON, w + c * 0.96859338 + m * 0.62645502 + y * 0.02062723 + r * 0.03140624 + g * 0.40165780 + b * 0.97901118);\\n     R[3] = max(SPECTRAL_EPSILON, w + c * 0.96877345 + m * 0.75595012 + y * 0.02073387 + r * 0.03119611 + g * 0.24490420 + b * 0.97892146);\\n     R[4] = max(SPECTRAL_EPSILON, w + c * 0.96942204 + m * 0.92826996 + y * 0.02114202 + r * 0.03053888 + g * 0.06826880 + b * 0.97858555);\\n     R[5] = max(SPECTRAL_EPSILON, w + c * 0.97143709 + m * 0.97223624 + y * 0.02233154 + r * 0.02856855 + g * 0.02732883 + b * 0.97743705);\\n     R[6] = max(SPECTRAL_EPSILON, w + c * 0.97541862 + m * 0.98616174 + y * 0.02556857 + r * 0.02459485 + g * 0.01360600 + b * 0.97428075);\\n     R[7] = max(SPECTRAL_EPSILON, w + c * 0.98074186 + m * 0.98955255 + y * 0.03330189 + r * 0.01929520 + g * 0.01000187 + b * 0.96663223);\\n     R[8] = max(SPECTRAL_EPSILON, w + c * 0.98580992 + m * 0.98676237 + y * 0.05185294 + r * 0.01423112 + g * 0.01284127 + b * 0.94822893);\\n     R[9] = max(SPECTRAL_EPSILON, w + c * 0.98971194 + m * 0.97312575 + y * 0.10087639 + r * 0.01033111 + g * 0.02636635 + b * 0.89937713);\\n    R[10] = max(SPECTRAL_EPSILON, w + c * 0.99238027 + m * 0.91944277 + y * 0.24000413 + r * 0.00765876 + g * 0.07058713 + b * 0.76070164);\\n    R[11] = max(SPECTRAL_EPSILON, w + c * 0.99409844 + m * 0.32564851 + y * 0.53589066 + r * 0.00593693 + g * 0.70421692 + b * 0.46420440);\\n    R[12] = max(SPECTRAL_EPSILON, w + c * 0.99517200 + m * 0.13820628 + y * 0.79874659 + r * 0.00485616 + g * 0.85473994 + b * 0.20123039);\\n    R[13] = max(SPECTRAL_EPSILON, w + c * 0.99576545 + m * 0.05015143 + y * 0.91186529 + r * 0.00426186 + g * 0.95081565 + b * 0.08808402);\\n    R[14] = max(SPECTRAL_EPSILON, w + c * 0.99593552 + m * 0.02912336 + y * 0.95399623 + r * 0.00409039 + g * 0.97170370 + b * 0.04592894);\\n    R[15] = max(SPECTRAL_EPSILON, w + c * 0.99564041 + m * 0.02421691 + y * 0.97137099 + r * 0.00438375 + g * 0.97651888 + b * 0.02860373);\\n    R[16] = max(SPECTRAL_EPSILON, w + c * 0.99464769 + m * 0.02660696 + y * 0.97939505 + r * 0.00537525 + g * 0.97429245 + b * 0.02060067);\\n    R[17] = max(SPECTRAL_EPSILON, w + c * 0.99229579 + m * 0.03407586 + y * 0.98345207 + r * 0.00772962 + g * 0.97012917 + b * 0.01656701);\\n    R[18] = max(SPECTRAL_EPSILON, w + c * 0.98638762 + m * 0.04835936 + y * 0.98553736 + r * 0.01366120 + g * 0.94258630 + b * 0.01451549);\\n    R[19] = max(SPECTRAL_EPSILON, w + c * 0.96829712 + m * 0.00011720 + y * 0.98648905 + r * 0.03181352 + g * 0.99989207 + b * 0.01357964);\\n    R[20] = max(SPECTRAL_EPSILON, w + c * 0.89228016 + m * 0.00008554 + y * 0.98674535 + r * 0.10791525 + g * 0.99989891 + b * 0.01331243);\\n    R[21] = max(SPECTRAL_EPSILON, w + c * 0.53740239 + m * 0.85267882 + y * 0.98657555 + r * 0.46249516 + g * 0.13823139 + b * 0.01347661);\\n    R[22] = max(SPECTRAL_EPSILON, w + c * 0.15360445 + m * 0.93188793 + y * 0.98611877 + r * 0.84604333 + g * 0.06968113 + b * 0.01387181);\\n    R[23] = max(SPECTRAL_EPSILON, w + c * 0.05705719 + m * 0.94810268 + y * 0.98559942 + r * 0.94275572 + g * 0.05628787 + b * 0.01435472);\\n    R[24] = max(SPECTRAL_EPSILON, w + c * 0.03126539 + m * 0.94200977 + y * 0.98507063 + r * 0.96860996 + g * 0.06111561 + b * 0.01479836);\\n    R[25] = max(SPECTRAL_EPSILON, w + c * 0.02205445 + m * 0.91478045 + y * 0.98460039 + r * 0.97783966 + g * 0.08987709 + b * 0.01515250);\\n    R[26] = max(SPECTRAL_EPSILON, w + c * 0.01802271 + m * 0.87065445 + y * 0.98425301 + r * 0.98187757 + g * 0.13656016 + b * 0.01540513);\\n    R[27] = max(SPECTRAL_EPSILON, w + c * 0.01613460 + m * 0.78827548 + y * 0.98403909 + r * 0.98377315 + g * 0.22169624 + b * 0.01557233);\\n    R[28] = max(SPECTRAL_EPSILON, w + c * 0.01520947 + m * 0.65738359 + y * 0.98388535 + r * 0.98470202 + g * 0.32176956 + b * 0.01565710);\\n    R[29] = max(SPECTRAL_EPSILON, w + c * 0.01475977 + m * 0.59909403 + y * 0.98376116 + r * 0.98515481 + g * 0.36157329 + b * 0.01571025);\\n    R[30] = max(SPECTRAL_EPSILON, w + c * 0.01454263 + m * 0.56817268 + y * 0.98368246 + r * 0.98537114 + g * 0.48361920 + b * 0.01571916);\\n    R[31] = max(SPECTRAL_EPSILON, w + c * 0.01444459 + m * 0.54031997 + y * 0.98365023 + r * 0.98546685 + g * 0.46488579 + b * 0.01572133);\\n    R[32] = max(SPECTRAL_EPSILON, w + c * 0.01439897 + m * 0.52110241 + y * 0.98361309 + r * 0.98550011 + g * 0.47440306 + b * 0.01572502);\\n    R[33] = max(SPECTRAL_EPSILON, w + c * 0.01437620 + m * 0.51041094 + y * 0.98357259 + r * 0.98551031 + g * 0.48576990 + b * 0.01571717);\\n    R[34] = max(SPECTRAL_EPSILON, w + c * 0.01436343 + m * 0.50526577 + y * 0.98353856 + r * 0.98550741 + g * 0.49267971 + b * 0.01571905);\\n    R[35] = max(SPECTRAL_EPSILON, w + c * 0.01435687 + m * 0.50255080 + y * 0.98351247 + r * 0.98551323 + g * 0.49625685 + b * 0.01571059);\\n    R[36] = max(SPECTRAL_EPSILON, w + c * 0.01435370 + m * 0.50126452 + y * 0.98350101 + r * 0.98551563 + g * 0.49807754 + b * 0.01569728);\\n    R[37] = max(SPECTRAL_EPSILON, w + c * 0.01435408 + m * 0.50083021 + y * 0.98350852 + r * 0.98551547 + g * 0.49889859 + b * 0.01570020);\\n}\\n\\nvec3 spectral_xyz_to_srgb(vec3 xyz) {\\n    mat3 XYZ_RGB;\\n\\n    XYZ_RGB[0] = vec3( 3.24306333, -1.53837619, -0.49893282);\\n    XYZ_RGB[1] = vec3(-0.96896309,  1.87542451,  0.04154303);\\n    XYZ_RGB[2] = vec3( 0.05568392, -0.20417438,  1.05799454);\\n    \\n    float r = dot(XYZ_RGB[0], xyz);\\n    float g = dot(XYZ_RGB[1], xyz);\\n    float b = dot(XYZ_RGB[2], xyz);\\n\\n    return spectral_linear_to_srgb(vec3(r, g, b));\\n}\\n\\nvec3 spectral_reflectance_to_xyz(float R[SPECTRAL_SIZE]) {\\n    vec3 xyz = vec3(0.0);\\n    \\n    xyz +=  R[0] * vec3(0.00006469, 0.00000184, 0.00030502);\\n    xyz +=  R[1] * vec3(0.00021941, 0.00000621, 0.00103681);\\n    xyz +=  R[2] * vec3(0.00112057, 0.00003101, 0.00531314);\\n    xyz +=  R[3] * vec3(0.00376661, 0.00010475, 0.01795439);\\n    xyz +=  R[4] * vec3(0.01188055, 0.00035364, 0.05707758);\\n    xyz +=  R[5] * vec3(0.02328644, 0.00095147, 0.11365162);\\n    xyz +=  R[6] * vec3(0.03455942, 0.00228226, 0.17335873);\\n    xyz +=  R[7] * vec3(0.03722379, 0.00420733, 0.19620658);\\n    xyz +=  R[8] * vec3(0.03241838, 0.00668880, 0.18608237);\\n    xyz +=  R[9] * vec3(0.02123321, 0.00988840, 0.13995048);\\n    xyz += R[10] * vec3(0.01049099, 0.01524945, 0.08917453);\\n    xyz += R[11] * vec3(0.00329584, 0.02141831, 0.04789621);\\n    xyz += R[12] * vec3(0.00050704, 0.03342293, 0.02814563);\\n    xyz += R[13] * vec3(0.00094867, 0.05131001, 0.01613766);\\n    xyz += R[14] * vec3(0.00627372, 0.07040208, 0.00775910);\\n    xyz += R[15] * vec3(0.01686462, 0.08783871, 0.00429615);\\n    xyz += R[16] * vec3(0.02868965, 0.09424905, 0.00200551);\\n    xyz += R[17] * vec3(0.04267481, 0.09795667, 0.00086147);\\n    xyz += R[18] * vec3(0.05625475, 0.09415219, 0.00036904);\\n    xyz += R[19] * vec3(0.06947040, 0.08678102, 0.00019143);\\n    xyz += R[20] * vec3(0.08305315, 0.07885653, 0.00014956);\\n    xyz += R[21] * vec3(0.08612610, 0.06352670, 0.00009231);\\n    xyz += R[22] * vec3(0.09046614, 0.05374142, 0.00006813);\\n    xyz += R[23] * vec3(0.08500387, 0.04264606, 0.00002883);\\n    xyz += R[24] * vec3(0.07090667, 0.03161735, 0.00001577);\\n    xyz += R[25] * vec3(0.05062889, 0.02088521, 0.00000394);\\n    xyz += R[26] * vec3(0.03547396, 0.01386011, 0.00000158);\\n    xyz += R[27] * vec3(0.02146821, 0.00810264, 0.00000000);\\n    xyz += R[28] * vec3(0.01251646, 0.00463010, 0.00000000);\\n    xyz += R[29] * vec3(0.00680458, 0.00249138, 0.00000000);\\n    xyz += R[30] * vec3(0.00346457, 0.00125930, 0.00000000);\\n    xyz += R[31] * vec3(0.00149761, 0.00054165, 0.00000000);\\n    xyz += R[32] * vec3(0.00076970, 0.00027795, 0.00000000);\\n    xyz += R[33] * vec3(0.00040737, 0.00014711, 0.00000000);\\n    xyz += R[34] * vec3(0.00016901, 0.00006103, 0.00000000);\\n    xyz += R[35] * vec3(0.00009522, 0.00003439, 0.00000000);\\n    xyz += R[36] * vec3(0.00004903, 0.00001771, 0.00000000);\\n    xyz += R[37] * vec3(0.00002000, 0.00000722, 0.00000000);\\n\\n    return xyz;\\n}\\n\\nfloat spectral_linear_to_concentration(float l1, float l2, float t) {\\n    float t1 = l1 * pow(1.0 - t, 2.0);\\n    float t2 = l2 * pow(t, 2.0);\\n\\n    return t2 / (t1 + t2);\\n}\\n\\nvec3 spectral_mix(vec3 color1, vec3 color2, float t) {\\n    vec3 lrgb1 = spectral_srgb_to_linear(color1);\\n    vec3 lrgb2 = spectral_srgb_to_linear(color2);\\n\\n    float R1[SPECTRAL_SIZE];\\n    float R2[SPECTRAL_SIZE];\\n\\n    spectral_linear_to_reflectance(lrgb1, R1);\\n    spectral_linear_to_reflectance(lrgb2, R2);\\n\\n    float l1 = spectral_reflectance_to_xyz(R1)[1];\\n    float l2 = spectral_reflectance_to_xyz(R2)[1];\\n\\n    t = spectral_linear_to_concentration(l1, l2, t);\\n\\n    float R[SPECTRAL_SIZE];\\n\\n    for (int i = 0; i < SPECTRAL_SIZE; i++) {\\n      float KS = (1.0 - t) * (pow(1.0 - R1[i], 2.0) / (2.0 * R1[i])) + t * (pow(1.0 - R2[i], 2.0) / (2.0 * R2[i]));\\n      float KM = 1.0 + KS - sqrt(pow(KS, 2.0) + 2.0 * KS);\\n\\n      //Saunderson correction\\n      // let S = ((1.0 - K1) * (1.0 - K2) * KM) / (1.0 - K2 * KM);\\n\\n      R[i] = KM;\\n    }\\n\\n    return spectral_xyz_to_srgb(spectral_reflectance_to_xyz(R));\\n}\\n\\nvec4 spectral_mix(vec4 color1, vec4 color2, float t) {\\n    return vec4(spectral_mix(color1.rgb, color2.rgb, t), mix(color1.a, color2.a, t));\\n}\\n\\n#endif\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nvec4 blend_brushstroke(vec4 col, vec4 stroke, int blending_colour_space){\\n  // col.xyz = mix(col.xyz, stroke.xyz, stroke.w); \\n  \\n  int mode = blending_colour_space;\\n  \\n  if(stroke.w > 0.00000001){\\n    // float interpolant = stroke.w;\\n    stroke.xyz = stroke.xyz/max(stroke.w,0.001);\\n    \\n    if(mode == 0){\\n      col.xyz = spectral_mix(col.xyz, clamp(stroke.xyz,0.00001,0.99999), stroke.w);\\n      if(stroke.w > 0.99999)\\n        col.xyz = stroke.xyz;\\n    } else if(mode == 1){\\n      col.xyz = srgb_to_oklch( col.xyz );\\n      stroke.xyz = srgb_to_oklch( stroke.xyz );\\n      col.xy = mix(col.xy, stroke.xy,stroke.w);\\n      float tau = acos(-1.) * 2.;\\n      float h_a = stroke.z;\\n      float h_b = stroke.z + tau;\\n      float dist_a = abs(col.z - h_a);\\n      float dist_b = abs(col.z - h_b);\\n      if(dist_a < dist_b){\\n        col.z = mix(col.z, h_a, stroke.w);\\n      } else {\\n        col.z = mix(col.z, h_b, stroke.w);\\n      }\\n      col.z = mod(col.z, tau);\\n      // col.z = max(col.z)\\n      // if(isnan(col.z)){\\n      //   col.z = 1.;\\n      // }\\n\\n      col.xyz = oklch_to_srgb( col.xyz );\\n      col.xyz = clamp(col.xyz,0.,1.);\\n    \\n    } else {\\n      col.xyz = mix(col.xyz, stroke.xyz, stroke.w);\\n    }\\n    col.w = max(col.w, stroke.w);\\n  }\\n\\n  return col; \\n}\\n\\nuniform int blending_colour_space;\\nin vec2 uv;\\nout vec4 col;\\n\\nvec4 sample_tex_mobile(sampler2D tex, vec2 fruv, ivec2 ifuv){\\n  ivec3 st = ivec3(1,1,0);\\n  return mix(\\n    mix(\\n      texelFetch(tex,ifuv,0),\\n      texelFetch(tex,ifuv + st.xz,0),\\n      // smoothstep(0.,1.,fruv.x)\\n      fruv.x\\n    ),\\n    mix(\\n      texelFetch(tex,ifuv + st.zy,0),\\n      texelFetch(tex,ifuv + st.xy,0),\\n      // smoothstep(0.,1.,fruv.x)\\n      fruv.x\\n    ),\\n    // smoothstep(0.,1.,fruv.y)\\n    fruv.y\\n  );\\n}\\nvec4 sample_tex_desktop(sampler2D tex, vec2 uv){\\n\\n    vec2 dx = dFdx(uv.xy);\\n    vec2 dy = dFdy(uv.xy);\\n\\n    vec2 textureRes = vec2(textureSize(tex,0));\\n\\n    dx *= clamp( 0.5 * log2(dot(dx * textureRes, dx * textureRes)), 0., 1.);\\n    dy *= clamp( 0.5 * log2(dot(dy * textureRes, dy * textureRes)), 0., 1.);\\n\\n    float _Bias = -1.;\\n    vec2 uvOffsets = vec2(0.125, 0.375);\\n    vec2 offsetUV = vec2(0.0, 0.0);\\n    \\n    vec4 col = vec4(0);\\n    // supersampled using 2x2 rotated grid\\n    // half4 col = 0;\\n    offsetUV.xy = uv.xy + uvOffsets.x * dx + uvOffsets.y * dy;\\n    col += texture(tex, offsetUV, _Bias);\\n    offsetUV.xy = uv.xy - uvOffsets.x * dx - uvOffsets.y * dy;\\n    col += texture(tex, offsetUV, _Bias);\\n    offsetUV.xy = uv.xy + uvOffsets.y * dx - uvOffsets.x * dy;\\n    col += texture(tex, offsetUV, _Bias);\\n    offsetUV.xy = uv.xy - uvOffsets.y * dx + uvOffsets.x * dy;\\n    col += texture(tex, offsetUV, _Bias);\\n    col *= 0.25;\\n    return col;\\n}\\nvoid main() {\\n  col = vec4(1);\\n  \\n  vec4 _temp_tex;\\n  \\n  if(is_on_mobile > 0.5){\\n    ivec2 ifuv = ivec2(uv*canvasR);\\n    vec2 fruv = fract(uv*canvasR);\\n\\n    col.xyz = sample_tex_mobile(canvas_back, fruv, ifuv).xyz;\\n    _temp_tex = sample_tex_mobile(temp_tex, fruv, ifuv);\\n  } else {\\n    col.xyz = sample_tex_desktop(canvas_back,uv).xyz;\\n    // col.xyz = texture(canvas_back, uv).xyz;\\n    // _temp_tex = texture(temp_tex, uv);    \\n\\n    ivec2 ifuv = ivec2(uv*canvasR);\\n    vec2 fruv = fract(uv*canvasR);\\n\\n    // _temp_tex = sample_tex_desktop(temp_tex,uv);\\n    // _temp_tex = texelFetch(temp_tex,ivec2(uv*canvasR),0);\\n    _temp_tex = texture(temp_tex,uv);\\n\\n    // _temp_tex = sample_tex_mobile(temp_tex, fruv, ifuv);    \\n  }\\n\\n  // // if(temp_tex.w > 0.)\\n  if(_temp_tex.w > 0.0)\\n    col = blend_brushstroke(\\n      col,\\n      _temp_tex,\\n      blending_colour_space\\n    );\\n \\n    \\n  col = pow(col,vec4(0.454545454545)); \\n  col.w = 1.;\\n}    \\n\\n  \\n  \\n\\t\\t \";";

/***/ }),

/***/ 929:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\n// uniform float time;\\n// uniform float frame;\\n// uniform float zoom;\\n// uniform vec2 panning;\\n// uniform vec2 R;\\n// uniform vec2 canvasR;\\n// uniform vec4 stroke_col;\\n// uniform vec2 stroke_pos;\\n// uniform float stroke_opacity;\\n// uniform vec3 tex_lch_dynamics;\\n// uniform vec2 tex_stretch;\\n// uniform vec2 tilt;\\n// uniform vec2 brush_sz;\\n// uniform float pressure;\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\n// uniform sampler2D brush_texture_0;\\n// uniform sampler2D brush_texture_1;\\n// uniform sampler2D brush_texture_2;\\n// uniform sampler2D brush_texture_3;\\n// uniform sampler2D brush_texture_4;\\n// uniform sampler2D brush_texture_5;\\n// uniform sampler2D brush_texture_6;\\n// uniform sampler2D brush_texture_7;\\n// uniform sampler2D brush_texture_8;\\n// uniform sampler2D brush_texture_9;\\n// uniform sampler2D brush_texture_10;\\n// uniform sampler2D brush_texture_11;\\n// uniform sampler2D brush_texture_12;\\n\\n// uniform float canvas_idx;\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\nout vec2 uv;\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nuniform float zoom;\\nuniform vec2 panning;\\nvoid main(){\\n  uv = positions[gl_VertexID];\\n  uv = uv*0.5 + 0.5;\\n\\n  gl_Position = vec4(positions[gl_VertexID],0,1);\\n  gl_Position.xy += panning/css_contain(vec2(1), canvasR, R);\\n  gl_Position.xy = css_contain(gl_Position.xy, canvasR, R);\\n  gl_Position.xy *= zoom;\\n}  \\n\\t\\t\\t\\n\";";

/***/ }),

/***/ 90:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 974:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 302:
/***/ (function(module) {

/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */

(function (global, factory) {
     true ? module.exports = factory() :
    0;
})(this, (function () { 'use strict';

    var limit$2 = function (x, min, max) {
        if ( min === void 0 ) min=0;
        if ( max === void 0 ) max=1;

        return x < min ? min : x > max ? max : x;
    };

    var limit$1 = limit$2;

    var clip_rgb$3 = function (rgb) {
        rgb._clipped = false;
        rgb._unclipped = rgb.slice(0);
        for (var i=0; i<=3; i++) {
            if (i < 3) {
                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }
                rgb[i] = limit$1(rgb[i], 0, 255);
            } else if (i === 3) {
                rgb[i] = limit$1(rgb[i], 0, 1);
            }
        }
        return rgb;
    };

    // ported from jQuery's $.type
    var classToType = {};
    for (var i$1 = 0, list$1 = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i$1 < list$1.length; i$1 += 1) {
        var name = list$1[i$1];

        classToType[("[object " + name + "]")] = name.toLowerCase();
    }
    var type$p = function(obj) {
        return classToType[Object.prototype.toString.call(obj)] || "object";
    };

    var type$o = type$p;

    var unpack$B = function (args, keyOrder) {
        if ( keyOrder === void 0 ) keyOrder=null;

    	// if called with more than 3 arguments, we return the arguments
        if (args.length >= 3) { return Array.prototype.slice.call(args); }
        // with less than 3 args we check if first arg is object
        // and use the keyOrder string to extract and sort properties
    	if (type$o(args[0]) == 'object' && keyOrder) {
    		return keyOrder.split('')
    			.filter(function (k) { return args[0][k] !== undefined; })
    			.map(function (k) { return args[0][k]; });
    	}
    	// otherwise we just return the first argument
    	// (which we suppose is an array of args)
        return args[0];
    };

    var type$n = type$p;

    var last$4 = function (args) {
        if (args.length < 2) { return null; }
        var l = args.length-1;
        if (type$n(args[l]) == 'string') { return args[l].toLowerCase(); }
        return null;
    };

    var PI$2 = Math.PI;

    var utils = {
    	clip_rgb: clip_rgb$3,
    	limit: limit$2,
    	type: type$p,
    	unpack: unpack$B,
    	last: last$4,
    	PI: PI$2,
    	TWOPI: PI$2*2,
    	PITHIRD: PI$2/3,
    	DEG2RAD: PI$2 / 180,
    	RAD2DEG: 180 / PI$2
    };

    var input$h = {
    	format: {},
    	autodetect: []
    };

    var last$3 = utils.last;
    var clip_rgb$2 = utils.clip_rgb;
    var type$m = utils.type;
    var _input = input$h;

    var Color$D = function Color() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var me = this;
        if (type$m(args[0]) === 'object' &&
            args[0].constructor &&
            args[0].constructor === this.constructor) {
            // the argument is already a Color instance
            return args[0];
        }

        // last argument could be the mode
        var mode = last$3(args);
        var autodetect = false;

        if (!mode) {
            autodetect = true;
            if (!_input.sorted) {
                _input.autodetect = _input.autodetect.sort(function (a,b) { return b.p - a.p; });
                _input.sorted = true;
            }
            // auto-detect format
            for (var i = 0, list = _input.autodetect; i < list.length; i += 1) {
                var chk = list[i];

                mode = chk.test.apply(chk, args);
                if (mode) { break; }
            }
        }

        if (_input.format[mode]) {
            var rgb = _input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));
            me._rgb = clip_rgb$2(rgb);
        } else {
            throw new Error('unknown format: '+args);
        }

        // add alpha channel
        if (me._rgb.length === 3) { me._rgb.push(1); }
    };

    Color$D.prototype.toString = function toString () {
        if (type$m(this.hex) == 'function') { return this.hex(); }
        return ("[" + (this._rgb.join(',')) + "]");
    };

    var Color_1 = Color$D;

    var chroma$k = function () {
    	var args = [], len = arguments.length;
    	while ( len-- ) args[ len ] = arguments[ len ];

    	return new (Function.prototype.bind.apply( chroma$k.Color, [ null ].concat( args) ));
    };

    chroma$k.Color = Color_1;
    chroma$k.version = '2.4.2';

    var chroma_1 = chroma$k;

    var unpack$A = utils.unpack;
    var max$2 = Math.max;

    var rgb2cmyk$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$A(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r = r / 255;
        g = g / 255;
        b = b / 255;
        var k = 1 - max$2(r,max$2(g,b));
        var f = k < 1 ? 1 / (1-k) : 0;
        var c = (1-r-k) * f;
        var m = (1-g-k) * f;
        var y = (1-b-k) * f;
        return [c,m,y,k];
    };

    var rgb2cmyk_1 = rgb2cmyk$1;

    var unpack$z = utils.unpack;

    var cmyk2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$z(args, 'cmyk');
        var c = args[0];
        var m = args[1];
        var y = args[2];
        var k = args[3];
        var alpha = args.length > 4 ? args[4] : 1;
        if (k === 1) { return [0,0,0,alpha]; }
        return [
            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r
            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g
            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b
            alpha
        ];
    };

    var cmyk2rgb_1 = cmyk2rgb;

    var chroma$j = chroma_1;
    var Color$C = Color_1;
    var input$g = input$h;
    var unpack$y = utils.unpack;
    var type$l = utils.type;

    var rgb2cmyk = rgb2cmyk_1;

    Color$C.prototype.cmyk = function() {
        return rgb2cmyk(this._rgb);
    };

    chroma$j.cmyk = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$C, [ null ].concat( args, ['cmyk']) ));
    };

    input$g.format.cmyk = cmyk2rgb_1;

    input$g.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$y(args, 'cmyk');
            if (type$l(args) === 'array' && args.length === 4) {
                return 'cmyk';
            }
        }
    });

    var unpack$x = utils.unpack;
    var last$2 = utils.last;
    var rnd = function (a) { return Math.round(a*100)/100; };

    /*
     * supported arguments:
     * - hsl2css(h,s,l)
     * - hsl2css(h,s,l,a)
     * - hsl2css([h,s,l], mode)
     * - hsl2css([h,s,l,a], mode)
     * - hsl2css({h,s,l,a}, mode)
     */
    var hsl2css$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hsla = unpack$x(args, 'hsla');
        var mode = last$2(args) || 'lsa';
        hsla[0] = rnd(hsla[0] || 0);
        hsla[1] = rnd(hsla[1]*100) + '%';
        hsla[2] = rnd(hsla[2]*100) + '%';
        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {
            hsla[3] = hsla.length > 3 ? hsla[3] : 1;
            mode = 'hsla';
        } else {
            hsla.length = 3;
        }
        return (mode + "(" + (hsla.join(',')) + ")");
    };

    var hsl2css_1 = hsl2css$1;

    var unpack$w = utils.unpack;

    /*
     * supported arguments:
     * - rgb2hsl(r,g,b)
     * - rgb2hsl(r,g,b,a)
     * - rgb2hsl([r,g,b])
     * - rgb2hsl([r,g,b,a])
     * - rgb2hsl({r,g,b,a})
     */
    var rgb2hsl$3 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$w(args, 'rgba');
        var r = args[0];
        var g = args[1];
        var b = args[2];

        r /= 255;
        g /= 255;
        b /= 255;

        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);

        var l = (max + min) / 2;
        var s, h;

        if (max === min){
            s = 0;
            h = Number.NaN;
        } else {
            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
        }

        if (r == max) { h = (g - b) / (max - min); }
        else if (g == max) { h = 2 + (b - r) / (max - min); }
        else if (b == max) { h = 4 + (r - g) / (max - min); }

        h *= 60;
        if (h < 0) { h += 360; }
        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }
        return [h,s,l];
    };

    var rgb2hsl_1 = rgb2hsl$3;

    var unpack$v = utils.unpack;
    var last$1 = utils.last;
    var hsl2css = hsl2css_1;
    var rgb2hsl$2 = rgb2hsl_1;
    var round$6 = Math.round;

    /*
     * supported arguments:
     * - rgb2css(r,g,b)
     * - rgb2css(r,g,b,a)
     * - rgb2css([r,g,b], mode)
     * - rgb2css([r,g,b,a], mode)
     * - rgb2css({r,g,b,a}, mode)
     */
    var rgb2css$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$v(args, 'rgba');
        var mode = last$1(args) || 'rgb';
        if (mode.substr(0,3) == 'hsl') {
            return hsl2css(rgb2hsl$2(rgba), mode);
        }
        rgba[0] = round$6(rgba[0]);
        rgba[1] = round$6(rgba[1]);
        rgba[2] = round$6(rgba[2]);
        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {
            rgba[3] = rgba.length > 3 ? rgba[3] : 1;
            mode = 'rgba';
        }
        return (mode + "(" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + ")");
    };

    var rgb2css_1 = rgb2css$1;

    var unpack$u = utils.unpack;
    var round$5 = Math.round;

    var hsl2rgb$1 = function () {
        var assign;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$u(args, 'hsl');
        var h = args[0];
        var s = args[1];
        var l = args[2];
        var r,g,b;
        if (s === 0) {
            r = g = b = l*255;
        } else {
            var t3 = [0,0,0];
            var c = [0,0,0];
            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;
            var t1 = 2 * l - t2;
            var h_ = h / 360;
            t3[0] = h_ + 1/3;
            t3[1] = h_;
            t3[2] = h_ - 1/3;
            for (var i=0; i<3; i++) {
                if (t3[i] < 0) { t3[i] += 1; }
                if (t3[i] > 1) { t3[i] -= 1; }
                if (6 * t3[i] < 1)
                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }
                else if (2 * t3[i] < 1)
                    { c[i] = t2; }
                else if (3 * t3[i] < 2)
                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }
                else
                    { c[i] = t1; }
            }
            (assign = [round$5(c[0]*255),round$5(c[1]*255),round$5(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);
        }
        if (args.length > 3) {
            // keep alpha channel
            return [r,g,b,args[3]];
        }
        return [r,g,b,1];
    };

    var hsl2rgb_1 = hsl2rgb$1;

    var hsl2rgb = hsl2rgb_1;
    var input$f = input$h;

    var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
    var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;

    var round$4 = Math.round;

    var css2rgb$1 = function (css) {
        css = css.toLowerCase().trim();
        var m;

        if (input$f.format.named) {
            try {
                return input$f.format.named(css);
            } catch (e) {
                // eslint-disable-next-line
            }
        }

        // rgb(250,20,0)
        if ((m = css.match(RE_RGB))) {
            var rgb = m.slice(1,4);
            for (var i=0; i<3; i++) {
                rgb[i] = +rgb[i];
            }
            rgb[3] = 1;  // default alpha
            return rgb;
        }

        // rgba(250,20,0,0.4)
        if ((m = css.match(RE_RGBA))) {
            var rgb$1 = m.slice(1,5);
            for (var i$1=0; i$1<4; i$1++) {
                rgb$1[i$1] = +rgb$1[i$1];
            }
            return rgb$1;
        }

        // rgb(100%,0%,0%)
        if ((m = css.match(RE_RGB_PCT))) {
            var rgb$2 = m.slice(1,4);
            for (var i$2=0; i$2<3; i$2++) {
                rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
            }
            rgb$2[3] = 1;  // default alpha
            return rgb$2;
        }

        // rgba(100%,0%,0%,0.4)
        if ((m = css.match(RE_RGBA_PCT))) {
            var rgb$3 = m.slice(1,5);
            for (var i$3=0; i$3<3; i$3++) {
                rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
            }
            rgb$3[3] = +rgb$3[3];
            return rgb$3;
        }

        // hsl(0,100%,50%)
        if ((m = css.match(RE_HSL))) {
            var hsl = m.slice(1,4);
            hsl[1] *= 0.01;
            hsl[2] *= 0.01;
            var rgb$4 = hsl2rgb(hsl);
            rgb$4[3] = 1;
            return rgb$4;
        }

        // hsla(0,100%,50%,0.5)
        if ((m = css.match(RE_HSLA))) {
            var hsl$1 = m.slice(1,4);
            hsl$1[1] *= 0.01;
            hsl$1[2] *= 0.01;
            var rgb$5 = hsl2rgb(hsl$1);
            rgb$5[3] = +m[4];  // default alpha = 1
            return rgb$5;
        }
    };

    css2rgb$1.test = function (s) {
        return RE_RGB.test(s) ||
            RE_RGBA.test(s) ||
            RE_RGB_PCT.test(s) ||
            RE_RGBA_PCT.test(s) ||
            RE_HSL.test(s) ||
            RE_HSLA.test(s);
    };

    var css2rgb_1 = css2rgb$1;

    var chroma$i = chroma_1;
    var Color$B = Color_1;
    var input$e = input$h;
    var type$k = utils.type;

    var rgb2css = rgb2css_1;
    var css2rgb = css2rgb_1;

    Color$B.prototype.css = function(mode) {
        return rgb2css(this._rgb, mode);
    };

    chroma$i.css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$B, [ null ].concat( args, ['css']) ));
    };

    input$e.format.css = css2rgb;

    input$e.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$k(h) === 'string' && css2rgb.test(h)) {
                return 'css';
            }
        }
    });

    var Color$A = Color_1;
    var chroma$h = chroma_1;
    var input$d = input$h;
    var unpack$t = utils.unpack;

    input$d.format.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$t(args, 'rgba');
        rgb[0] *= 255;
        rgb[1] *= 255;
        rgb[2] *= 255;
        return rgb;
    };

    chroma$h.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$A, [ null ].concat( args, ['gl']) ));
    };

    Color$A.prototype.gl = function() {
        var rgb = this._rgb;
        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];
    };

    var unpack$s = utils.unpack;

    var rgb2hcg$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$s(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var c = delta * 100 / 255;
        var _g = min / (255 - delta) * 100;
        var h;
        if (delta === 0) {
            h = Number.NaN;
        } else {
            if (r === max) { h = (g - b) / delta; }
            if (g === max) { h = 2+(b - r) / delta; }
            if (b === max) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, c, _g];
    };

    var rgb2hcg_1 = rgb2hcg$1;

    var unpack$r = utils.unpack;
    var floor$3 = Math.floor;

    /*
     * this is basically just HSV with some minor tweaks
     *
     * hue.. [0..360]
     * chroma .. [0..1]
     * grayness .. [0..1]
     */

    var hcg2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$r(args, 'hcg');
        var h = args[0];
        var c = args[1];
        var _g = args[2];
        var r,g,b;
        _g = _g * 255;
        var _c = c * 255;
        if (c === 0) {
            r = g = b = _g;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;
            var i = floor$3(h);
            var f = h - i;
            var p = _g * (1 - c);
            var q = p + _c * (1 - f);
            var t = p + _c * f;
            var v = p + _c;
            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var hcg2rgb_1 = hcg2rgb;

    var unpack$q = utils.unpack;
    var type$j = utils.type;
    var chroma$g = chroma_1;
    var Color$z = Color_1;
    var input$c = input$h;

    var rgb2hcg = rgb2hcg_1;

    Color$z.prototype.hcg = function() {
        return rgb2hcg(this._rgb);
    };

    chroma$g.hcg = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$z, [ null ].concat( args, ['hcg']) ));
    };

    input$c.format.hcg = hcg2rgb_1;

    input$c.autodetect.push({
        p: 1,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$q(args, 'hcg');
            if (type$j(args) === 'array' && args.length === 3) {
                return 'hcg';
            }
        }
    });

    var unpack$p = utils.unpack;
    var last = utils.last;
    var round$3 = Math.round;

    var rgb2hex$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$p(args, 'rgba');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var a = ref[3];
        var mode = last(args) || 'auto';
        if (a === undefined) { a = 1; }
        if (mode === 'auto') {
            mode = a < 1 ? 'rgba' : 'rgb';
        }
        r = round$3(r);
        g = round$3(g);
        b = round$3(b);
        var u = r << 16 | g << 8 | b;
        var str = "000000" + u.toString(16); //#.toUpperCase();
        str = str.substr(str.length - 6);
        var hxa = '0' + round$3(a * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        switch (mode.toLowerCase()) {
            case 'rgba': return ("#" + str + hxa);
            case 'argb': return ("#" + hxa + str);
            default: return ("#" + str);
        }
    };

    var rgb2hex_1 = rgb2hex$2;

    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;

    var hex2rgb$1 = function (hex) {
        if (hex.match(RE_HEX)) {
            // remove optional leading #
            if (hex.length === 4 || hex.length === 7) {
                hex = hex.substr(1);
            }
            // expand short-notation to full six-digit
            if (hex.length === 3) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            }
            var u = parseInt(hex, 16);
            var r = u >> 16;
            var g = u >> 8 & 0xFF;
            var b = u & 0xFF;
            return [r,g,b,1];
        }

        // match rgba hex format, eg #FF000077
        if (hex.match(RE_HEXA)) {
            if (hex.length === 5 || hex.length === 9) {
                // remove optional leading #
                hex = hex.substr(1);
            }
            // expand short-notation to full eight-digit
            if (hex.length === 4) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];
            }
            var u$1 = parseInt(hex, 16);
            var r$1 = u$1 >> 24 & 0xFF;
            var g$1 = u$1 >> 16 & 0xFF;
            var b$1 = u$1 >> 8 & 0xFF;
            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;
            return [r$1,g$1,b$1,a];
        }

        // we used to check for css colors here
        // if _input.css? and rgb = _input.css hex
        //     return rgb

        throw new Error(("unknown hex color: " + hex));
    };

    var hex2rgb_1 = hex2rgb$1;

    var chroma$f = chroma_1;
    var Color$y = Color_1;
    var type$i = utils.type;
    var input$b = input$h;

    var rgb2hex$1 = rgb2hex_1;

    Color$y.prototype.hex = function(mode) {
        return rgb2hex$1(this._rgb, mode);
    };

    chroma$f.hex = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$y, [ null ].concat( args, ['hex']) ));
    };

    input$b.format.hex = hex2rgb_1;
    input$b.autodetect.push({
        p: 4,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$i(h) === 'string' && [3,4,5,6,7,8,9].indexOf(h.length) >= 0) {
                return 'hex';
            }
        }
    });

    var unpack$o = utils.unpack;
    var TWOPI$2 = utils.TWOPI;
    var min$2 = Math.min;
    var sqrt$4 = Math.sqrt;
    var acos = Math.acos;

    var rgb2hsi$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
        */
        var ref = unpack$o(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r /= 255;
        g /= 255;
        b /= 255;
        var h;
        var min_ = min$2(r,g,b);
        var i = (r+g+b) / 3;
        var s = i > 0 ? 1 - min_/i : 0;
        if (s === 0) {
            h = NaN;
        } else {
            h = ((r-g)+(r-b)) / 2;
            h /= sqrt$4((r-g)*(r-g) + (r-b)*(g-b));
            h = acos(h);
            if (b > g) {
                h = TWOPI$2 - h;
            }
            h /= TWOPI$2;
        }
        return [h*360,s,i];
    };

    var rgb2hsi_1 = rgb2hsi$1;

    var unpack$n = utils.unpack;
    var limit = utils.limit;
    var TWOPI$1 = utils.TWOPI;
    var PITHIRD = utils.PITHIRD;
    var cos$4 = Math.cos;

    /*
     * hue [0..360]
     * saturation [0..1]
     * intensity [0..1]
     */
    var hsi2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
        */
        args = unpack$n(args, 'hsi');
        var h = args[0];
        var s = args[1];
        var i = args[2];
        var r,g,b;

        if (isNaN(h)) { h = 0; }
        if (isNaN(s)) { s = 0; }
        // normalize hue
        if (h > 360) { h -= 360; }
        if (h < 0) { h += 360; }
        h /= 360;
        if (h < 1/3) {
            b = (1-s)/3;
            r = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            g = 1 - (b+r);
        } else if (h < 2/3) {
            h -= 1/3;
            r = (1-s)/3;
            g = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            b = 1 - (r+g);
        } else {
            h -= 2/3;
            g = (1-s)/3;
            b = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            r = 1 - (g+b);
        }
        r = limit(i*r*3);
        g = limit(i*g*3);
        b = limit(i*b*3);
        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];
    };

    var hsi2rgb_1 = hsi2rgb;

    var unpack$m = utils.unpack;
    var type$h = utils.type;
    var chroma$e = chroma_1;
    var Color$x = Color_1;
    var input$a = input$h;

    var rgb2hsi = rgb2hsi_1;

    Color$x.prototype.hsi = function() {
        return rgb2hsi(this._rgb);
    };

    chroma$e.hsi = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$x, [ null ].concat( args, ['hsi']) ));
    };

    input$a.format.hsi = hsi2rgb_1;

    input$a.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$m(args, 'hsi');
            if (type$h(args) === 'array' && args.length === 3) {
                return 'hsi';
            }
        }
    });

    var unpack$l = utils.unpack;
    var type$g = utils.type;
    var chroma$d = chroma_1;
    var Color$w = Color_1;
    var input$9 = input$h;

    var rgb2hsl$1 = rgb2hsl_1;

    Color$w.prototype.hsl = function() {
        return rgb2hsl$1(this._rgb);
    };

    chroma$d.hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$w, [ null ].concat( args, ['hsl']) ));
    };

    input$9.format.hsl = hsl2rgb_1;

    input$9.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$l(args, 'hsl');
            if (type$g(args) === 'array' && args.length === 3) {
                return 'hsl';
            }
        }
    });

    var unpack$k = utils.unpack;
    var min$1 = Math.min;
    var max$1 = Math.max;

    /*
     * supported arguments:
     * - rgb2hsv(r,g,b)
     * - rgb2hsv([r,g,b])
     * - rgb2hsv({r,g,b})
     */
    var rgb2hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$k(args, 'rgb');
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var min_ = min$1(r, g, b);
        var max_ = max$1(r, g, b);
        var delta = max_ - min_;
        var h,s,v;
        v = max_ / 255.0;
        if (max_ === 0) {
            h = Number.NaN;
            s = 0;
        } else {
            s = delta / max_;
            if (r === max_) { h = (g - b) / delta; }
            if (g === max_) { h = 2+(b - r) / delta; }
            if (b === max_) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, s, v]
    };

    var rgb2hsv$1 = rgb2hsl;

    var unpack$j = utils.unpack;
    var floor$2 = Math.floor;

    var hsv2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$j(args, 'hsv');
        var h = args[0];
        var s = args[1];
        var v = args[2];
        var r,g,b;
        v *= 255;
        if (s === 0) {
            r = g = b = v;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;

            var i = floor$2(h);
            var f = h - i;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));

            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r,g,b,args.length > 3?args[3]:1];
    };

    var hsv2rgb_1 = hsv2rgb;

    var unpack$i = utils.unpack;
    var type$f = utils.type;
    var chroma$c = chroma_1;
    var Color$v = Color_1;
    var input$8 = input$h;

    var rgb2hsv = rgb2hsv$1;

    Color$v.prototype.hsv = function() {
        return rgb2hsv(this._rgb);
    };

    chroma$c.hsv = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$v, [ null ].concat( args, ['hsv']) ));
    };

    input$8.format.hsv = hsv2rgb_1;

    input$8.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$i(args, 'hsv');
            if (type$f(args) === 'array' && args.length === 3) {
                return 'hsv';
            }
        }
    });

    var labConstants = {
        // Corresponds roughly to RGB brighter/darker
        Kn: 18,

        // D65 standard referent
        Xn: 0.950470,
        Yn: 1,
        Zn: 1.088830,

        t0: 0.137931034,  // 4 / 29
        t1: 0.206896552,  // 6 / 29
        t2: 0.12841855,   // 3 * t1 * t1
        t3: 0.008856452,  // t1 * t1 * t1
    };

    var LAB_CONSTANTS$3 = labConstants;
    var unpack$h = utils.unpack;
    var pow$a = Math.pow;

    var rgb2lab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$h(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2xyz(r,g,b);
        var x = ref$1[0];
        var y = ref$1[1];
        var z = ref$1[2];
        var l = 116 * y - 16;
        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
    };

    var rgb_xyz = function (r) {
        if ((r /= 255) <= 0.04045) { return r / 12.92; }
        return pow$a((r + 0.055) / 1.055, 2.4);
    };

    var xyz_lab = function (t) {
        if (t > LAB_CONSTANTS$3.t3) { return pow$a(t, 1 / 3); }
        return t / LAB_CONSTANTS$3.t2 + LAB_CONSTANTS$3.t0;
    };

    var rgb2xyz = function (r,g,b) {
        r = rgb_xyz(r);
        g = rgb_xyz(g);
        b = rgb_xyz(b);
        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS$3.Xn);
        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / LAB_CONSTANTS$3.Yn);
        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / LAB_CONSTANTS$3.Zn);
        return [x,y,z];
    };

    var rgb2lab_1 = rgb2lab$2;

    var LAB_CONSTANTS$2 = labConstants;
    var unpack$g = utils.unpack;
    var pow$9 = Math.pow;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var lab2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$g(args, 'lab');
        var l = args[0];
        var a = args[1];
        var b = args[2];
        var x,y,z, r,g,b_;

        y = (l + 16) / 116;
        x = isNaN(a) ? y : y + a / 500;
        z = isNaN(b) ? y : y - b / 200;

        y = LAB_CONSTANTS$2.Yn * lab_xyz(y);
        x = LAB_CONSTANTS$2.Xn * lab_xyz(x);
        z = LAB_CONSTANTS$2.Zn * lab_xyz(z);

        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB
        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);

        return [r,g,b_,args.length > 3 ? args[3] : 1];
    };

    var xyz_rgb = function (r) {
        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$9(r, 1 / 2.4) - 0.055)
    };

    var lab_xyz = function (t) {
        return t > LAB_CONSTANTS$2.t1 ? t * t * t : LAB_CONSTANTS$2.t2 * (t - LAB_CONSTANTS$2.t0)
    };

    var lab2rgb_1 = lab2rgb$1;

    var unpack$f = utils.unpack;
    var type$e = utils.type;
    var chroma$b = chroma_1;
    var Color$u = Color_1;
    var input$7 = input$h;

    var rgb2lab$1 = rgb2lab_1;

    Color$u.prototype.lab = function() {
        return rgb2lab$1(this._rgb);
    };

    chroma$b.lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$u, [ null ].concat( args, ['lab']) ));
    };

    input$7.format.lab = lab2rgb_1;

    input$7.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$f(args, 'lab');
            if (type$e(args) === 'array' && args.length === 3) {
                return 'lab';
            }
        }
    });

    var unpack$e = utils.unpack;
    var RAD2DEG = utils.RAD2DEG;
    var sqrt$3 = Math.sqrt;
    var atan2$2 = Math.atan2;
    var round$2 = Math.round;

    var lab2lch$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$e(args, 'lab');
        var l = ref[0];
        var a = ref[1];
        var b = ref[2];
        var c = sqrt$3(a * a + b * b);
        var h = (atan2$2(b, a) * RAD2DEG + 360) % 360;
        if (round$2(c*10000) === 0) { h = Number.NaN; }
        return [l, c, h];
    };

    var lab2lch_1 = lab2lch$2;

    var unpack$d = utils.unpack;
    var rgb2lab = rgb2lab_1;
    var lab2lch$1 = lab2lch_1;

    var rgb2lch$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$d(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2lab(r,g,b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch$1(l,a,b_);
    };

    var rgb2lch_1 = rgb2lch$1;

    var unpack$c = utils.unpack;
    var DEG2RAD = utils.DEG2RAD;
    var sin$3 = Math.sin;
    var cos$3 = Math.cos;

    var lch2lab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.
        These formulas were invented by David Dalrymple to obtain maximum contrast without going
        out of gamut if the parameters are in the range 0-1.

        A saturation multiplier was added by Gregor Aisch
        */
        var ref = unpack$c(args, 'lch');
        var l = ref[0];
        var c = ref[1];
        var h = ref[2];
        if (isNaN(h)) { h = 0; }
        h = h * DEG2RAD;
        return [l, cos$3(h) * c, sin$3(h) * c]
    };

    var lch2lab_1 = lch2lab$2;

    var unpack$b = utils.unpack;
    var lch2lab$1 = lch2lab_1;
    var lab2rgb = lab2rgb_1;

    var lch2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$b(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab$1 (l,c,h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = lab2rgb (L,a,b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var lch2rgb_1 = lch2rgb$1;

    var unpack$a = utils.unpack;
    var lch2rgb = lch2rgb_1;

    var hcl2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hcl = unpack$a(args, 'hcl').reverse();
        return lch2rgb.apply(void 0, hcl);
    };

    var hcl2rgb_1 = hcl2rgb;

    var unpack$9 = utils.unpack;
    var type$d = utils.type;
    var chroma$a = chroma_1;
    var Color$t = Color_1;
    var input$6 = input$h;

    var rgb2lch = rgb2lch_1;

    Color$t.prototype.lch = function() { return rgb2lch(this._rgb); };
    Color$t.prototype.hcl = function() { return rgb2lch(this._rgb).reverse(); };

    chroma$a.lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['lch']) ));
    };
    chroma$a.hcl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['hcl']) ));
    };

    input$6.format.lch = lch2rgb_1;
    input$6.format.hcl = hcl2rgb_1;

    ['lch','hcl'].forEach(function (m) { return input$6.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$9(args, m);
            if (type$d(args) === 'array' && args.length === 3) {
                return m;
            }
        }
    }); });

    /**
    	X11 color names

    	http://www.w3.org/TR/css3-color/#svg-color
    */

    var w3cx11$1 = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflower: '#6495ed',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        laserlemon: '#ffff54',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrod: '#fafad2',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        maroon2: '#7f0000',
        maroon3: '#b03060',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        purple2: '#7f007f',
        purple3: '#a020f0',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32'
    };

    var w3cx11_1 = w3cx11$1;

    var Color$s = Color_1;
    var input$5 = input$h;
    var type$c = utils.type;

    var w3cx11 = w3cx11_1;
    var hex2rgb = hex2rgb_1;
    var rgb2hex = rgb2hex_1;

    Color$s.prototype.name = function() {
        var hex = rgb2hex(this._rgb, 'rgb');
        for (var i = 0, list = Object.keys(w3cx11); i < list.length; i += 1) {
            var n = list[i];

            if (w3cx11[n] === hex) { return n.toLowerCase(); }
        }
        return hex;
    };

    input$5.format.named = function (name) {
        name = name.toLowerCase();
        if (w3cx11[name]) { return hex2rgb(w3cx11[name]); }
        throw new Error('unknown color name: '+name);
    };

    input$5.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$c(h) === 'string' && w3cx11[h.toLowerCase()]) {
                return 'named';
            }
        }
    });

    var unpack$8 = utils.unpack;

    var rgb2num$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$8(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        return (r << 16) + (g << 8) + b;
    };

    var rgb2num_1 = rgb2num$1;

    var type$b = utils.type;

    var num2rgb = function (num) {
        if (type$b(num) == "number" && num >= 0 && num <= 0xFFFFFF) {
            var r = num >> 16;
            var g = (num >> 8) & 0xFF;
            var b = num & 0xFF;
            return [r,g,b,1];
        }
        throw new Error("unknown num color: "+num);
    };

    var num2rgb_1 = num2rgb;

    var chroma$9 = chroma_1;
    var Color$r = Color_1;
    var input$4 = input$h;
    var type$a = utils.type;

    var rgb2num = rgb2num_1;

    Color$r.prototype.num = function() {
        return rgb2num(this._rgb);
    };

    chroma$9.num = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$r, [ null ].concat( args, ['num']) ));
    };

    input$4.format.num = num2rgb_1;

    input$4.autodetect.push({
        p: 5,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            if (args.length === 1 && type$a(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {
                return 'num';
            }
        }
    });

    var chroma$8 = chroma_1;
    var Color$q = Color_1;
    var input$3 = input$h;
    var unpack$7 = utils.unpack;
    var type$9 = utils.type;
    var round$1 = Math.round;

    Color$q.prototype.rgb = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        if (rnd === false) { return this._rgb.slice(0,3); }
        return this._rgb.slice(0,3).map(round$1);
    };

    Color$q.prototype.rgba = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        return this._rgb.slice(0,4).map(function (v,i) {
            return i<3 ? (rnd === false ? v : round$1(v)) : v;
        });
    };

    chroma$8.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$q, [ null ].concat( args, ['rgb']) ));
    };

    input$3.format.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$7(args, 'rgba');
        if (rgba[3] === undefined) { rgba[3] = 1; }
        return rgba;
    };

    input$3.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$7(args, 'rgba');
            if (type$9(args) === 'array' && (args.length === 3 ||
                args.length === 4 && type$9(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {
                return 'rgb';
            }
        }
    });

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     */

    var log$1 = Math.log;

    var temperature2rgb$1 = function (kelvin) {
        var temp = kelvin / 100;
        var r,g,b;
        if (temp < 66) {
            r = 255;
            g = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log$1(g);
            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log$1(b);
        } else {
            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log$1(r);
            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log$1(g);
            b = 255;
        }
        return [r,g,b,1];
    };

    var temperature2rgb_1 = temperature2rgb$1;

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     **/

    var temperature2rgb = temperature2rgb_1;
    var unpack$6 = utils.unpack;
    var round = Math.round;

    var rgb2temperature$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$6(args, 'rgb');
        var r = rgb[0], b = rgb[2];
        var minTemp = 1000;
        var maxTemp = 40000;
        var eps = 0.4;
        var temp;
        while (maxTemp - minTemp > eps) {
            temp = (maxTemp + minTemp) * 0.5;
            var rgb$1 = temperature2rgb(temp);
            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {
                maxTemp = temp;
            } else {
                minTemp = temp;
            }
        }
        return round(temp);
    };

    var rgb2temperature_1 = rgb2temperature$1;

    var chroma$7 = chroma_1;
    var Color$p = Color_1;
    var input$2 = input$h;

    var rgb2temperature = rgb2temperature_1;

    Color$p.prototype.temp =
    Color$p.prototype.kelvin =
    Color$p.prototype.temperature = function() {
        return rgb2temperature(this._rgb);
    };

    chroma$7.temp =
    chroma$7.kelvin =
    chroma$7.temperature = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$p, [ null ].concat( args, ['temp']) ));
    };

    input$2.format.temp =
    input$2.format.kelvin =
    input$2.format.temperature = temperature2rgb_1;

    var unpack$5 = utils.unpack;
    var cbrt = Math.cbrt;
    var pow$8 = Math.pow;
    var sign$1 = Math.sign;

    var rgb2oklab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        // OKLab color space implementation taken from
        // https://bottosson.github.io/posts/oklab/
        var ref = unpack$5(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = [rgb2lrgb(r / 255), rgb2lrgb(g / 255), rgb2lrgb(b / 255)];
        var lr = ref$1[0];
        var lg = ref$1[1];
        var lb = ref$1[2];
        var l = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
        var m = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
        var s = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);

        return [
            0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
            1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
            0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s
        ];
    };

    var rgb2oklab_1 = rgb2oklab$2;

    function rgb2lrgb(c) {
        var abs = Math.abs(c);
        if (abs < 0.04045) {
            return c / 12.92;
        }
        return (sign$1(c) || 1) * pow$8((abs + 0.055) / 1.055, 2.4);
    }

    var unpack$4 = utils.unpack;
    var pow$7 = Math.pow;
    var sign = Math.sign;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var oklab2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$4(args, 'lab');
        var L = args[0];
        var a = args[1];
        var b = args[2];

        var l = pow$7(L + 0.3963377774 * a + 0.2158037573 * b, 3);
        var m = pow$7(L - 0.1055613458 * a - 0.0638541728 * b, 3);
        var s = pow$7(L - 0.0894841775 * a - 1.291485548 * b, 3);

        return [
            255 * lrgb2rgb(+4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s),
            255 * lrgb2rgb(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s),
            255 * lrgb2rgb(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s),
            args.length > 3 ? args[3] : 1
        ];
    };

    var oklab2rgb_1 = oklab2rgb$1;

    function lrgb2rgb(c) {
        var abs = Math.abs(c);
        if (abs > 0.0031308) {
            return (sign(c) || 1) * (1.055 * pow$7(abs, 1 / 2.4) - 0.055);
        }
        return c * 12.92;
    }

    var unpack$3 = utils.unpack;
    var type$8 = utils.type;
    var chroma$6 = chroma_1;
    var Color$o = Color_1;
    var input$1 = input$h;

    var rgb2oklab$1 = rgb2oklab_1;

    Color$o.prototype.oklab = function () {
        return rgb2oklab$1(this._rgb);
    };

    chroma$6.oklab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$o, [ null ].concat( args, ['oklab']) ));
    };

    input$1.format.oklab = oklab2rgb_1;

    input$1.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$3(args, 'oklab');
            if (type$8(args) === 'array' && args.length === 3) {
                return 'oklab';
            }
        }
    });

    var unpack$2 = utils.unpack;
    var rgb2oklab = rgb2oklab_1;
    var lab2lch = lab2lch_1;

    var rgb2oklch$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$2(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2oklab(r, g, b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch(l, a, b_);
    };

    var rgb2oklch_1 = rgb2oklch$1;

    var unpack$1 = utils.unpack;
    var lch2lab = lch2lab_1;
    var oklab2rgb = oklab2rgb_1;

    var oklch2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$1(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab(l, c, h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = oklab2rgb(L, a, b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var oklch2rgb_1 = oklch2rgb;

    var unpack = utils.unpack;
    var type$7 = utils.type;
    var chroma$5 = chroma_1;
    var Color$n = Color_1;
    var input = input$h;

    var rgb2oklch = rgb2oklch_1;

    Color$n.prototype.oklch = function () {
        return rgb2oklch(this._rgb);
    };

    chroma$5.oklch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$n, [ null ].concat( args, ['oklch']) ));
    };

    input.format.oklch = oklch2rgb_1;

    input.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'oklch');
            if (type$7(args) === 'array' && args.length === 3) {
                return 'oklch';
            }
        }
    });

    var Color$m = Color_1;
    var type$6 = utils.type;

    Color$m.prototype.alpha = function(a, mutate) {
        if ( mutate === void 0 ) mutate=false;

        if (a !== undefined && type$6(a) === 'number') {
            if (mutate) {
                this._rgb[3] = a;
                return this;
            }
            return new Color$m([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');
        }
        return this._rgb[3];
    };

    var Color$l = Color_1;

    Color$l.prototype.clipped = function() {
        return this._rgb._clipped || false;
    };

    var Color$k = Color_1;
    var LAB_CONSTANTS$1 = labConstants;

    Color$k.prototype.darken = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lab = me.lab();
    	lab[0] -= LAB_CONSTANTS$1.Kn * amount;
    	return new Color$k(lab, 'lab').alpha(me.alpha(), true);
    };

    Color$k.prototype.brighten = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.darken(-amount);
    };

    Color$k.prototype.darker = Color$k.prototype.darken;
    Color$k.prototype.brighter = Color$k.prototype.brighten;

    var Color$j = Color_1;

    Color$j.prototype.get = function (mc) {
        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) { return src[i]; }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var Color$i = Color_1;
    var type$5 = utils.type;
    var pow$6 = Math.pow;

    var EPS = 1e-7;
    var MAX_ITER = 20;

    Color$i.prototype.luminance = function(lum) {
        if (lum !== undefined && type$5(lum) === 'number') {
            if (lum === 0) {
                // return pure black
                return new Color$i([0,0,0,this._rgb[3]], 'rgb');
            }
            if (lum === 1) {
                // return pure white
                return new Color$i([255,255,255,this._rgb[3]], 'rgb');
            }
            // compute new color using...
            var cur_lum = this.luminance();
            var mode = 'rgb';
            var max_iter = MAX_ITER;

            var test = function (low, high) {
                var mid = low.interpolate(high, 0.5, mode);
                var lm = mid.luminance();
                if (Math.abs(lum - lm) < EPS || !max_iter--) {
                    // close enough
                    return mid;
                }
                return lm > lum ? test(low, mid) : test(mid, high);
            };

            var rgb = (cur_lum > lum ? test(new Color$i([0,0,0]), this) : test(this, new Color$i([255,255,255]))).rgb();
            return new Color$i(rgb.concat( [this._rgb[3]]));
        }
        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));
    };


    var rgb2luminance = function (r,g,b) {
        // relative luminance
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        r = luminance_x(r);
        g = luminance_x(g);
        b = luminance_x(b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };

    var luminance_x = function (x) {
        x /= 255;
        return x <= 0.03928 ? x/12.92 : pow$6((x+0.055)/1.055, 2.4);
    };

    var interpolator$1 = {};

    var Color$h = Color_1;
    var type$4 = utils.type;
    var interpolator = interpolator$1;

    var mix$1 = function (col1, col2, f) {
        if ( f === void 0 ) f=0.5;
        var rest = [], len = arguments.length - 3;
        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];

        var mode = rest[0] || 'lrgb';
        if (!interpolator[mode] && !rest.length) {
            // fall back to the first supported mode
            mode = Object.keys(interpolator)[0];
        }
        if (!interpolator[mode]) {
            throw new Error(("interpolation mode " + mode + " is not defined"));
        }
        if (type$4(col1) !== 'object') { col1 = new Color$h(col1); }
        if (type$4(col2) !== 'object') { col2 = new Color$h(col2); }
        return interpolator[mode](col1, col2, f)
            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
    };

    var Color$g = Color_1;
    var mix = mix$1;

    Color$g.prototype.mix =
    Color$g.prototype.interpolate = function(col2, f) {
    	if ( f === void 0 ) f=0.5;
    	var rest = [], len = arguments.length - 2;
    	while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];

    	return mix.apply(void 0, [ this, col2, f ].concat( rest ));
    };

    var Color$f = Color_1;

    Color$f.prototype.premultiply = function(mutate) {
    	if ( mutate === void 0 ) mutate=false;

    	var rgb = this._rgb;
    	var a = rgb[3];
    	if (mutate) {
    		this._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];
    		return this;
    	} else {
    		return new Color$f([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');
    	}
    };

    var Color$e = Color_1;
    var LAB_CONSTANTS = labConstants;

    Color$e.prototype.saturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lch = me.lch();
    	lch[1] += LAB_CONSTANTS.Kn * amount;
    	if (lch[1] < 0) { lch[1] = 0; }
    	return new Color$e(lch, 'lch').alpha(me.alpha(), true);
    };

    Color$e.prototype.desaturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.saturate(-amount);
    };

    var Color$d = Color_1;
    var type$3 = utils.type;

    Color$d.prototype.set = function (mc, value, mutate) {
        if ( mutate === void 0 ) mutate = false;

        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) {
                if (type$3(value) == 'string') {
                    switch (value.charAt(0)) {
                        case '+':
                            src[i] += +value;
                            break;
                        case '-':
                            src[i] += +value;
                            break;
                        case '*':
                            src[i] *= +value.substr(1);
                            break;
                        case '/':
                            src[i] /= +value.substr(1);
                            break;
                        default:
                            src[i] = +value;
                    }
                } else if (type$3(value) === 'number') {
                    src[i] = value;
                } else {
                    throw new Error("unsupported value for Color.set");
                }
                var out = new Color$d(src, mode);
                if (mutate) {
                    this._rgb = out._rgb;
                    return this;
                }
                return out;
            }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var Color$c = Color_1;

    var rgb = function (col1, col2, f) {
        var xyz0 = col1._rgb;
        var xyz1 = col2._rgb;
        return new Color$c(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'rgb'
        )
    };

    // register interpolator
    interpolator$1.rgb = rgb;

    var Color$b = Color_1;
    var sqrt$2 = Math.sqrt;
    var pow$5 = Math.pow;

    var lrgb = function (col1, col2, f) {
        var ref = col1._rgb;
        var x1 = ref[0];
        var y1 = ref[1];
        var z1 = ref[2];
        var ref$1 = col2._rgb;
        var x2 = ref$1[0];
        var y2 = ref$1[1];
        var z2 = ref$1[2];
        return new Color$b(
            sqrt$2(pow$5(x1,2) * (1-f) + pow$5(x2,2) * f),
            sqrt$2(pow$5(y1,2) * (1-f) + pow$5(y2,2) * f),
            sqrt$2(pow$5(z1,2) * (1-f) + pow$5(z2,2) * f),
            'rgb'
        )
    };

    // register interpolator
    interpolator$1.lrgb = lrgb;

    var Color$a = Color_1;

    var lab = function (col1, col2, f) {
        var xyz0 = col1.lab();
        var xyz1 = col2.lab();
        return new Color$a(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'lab'
        )
    };

    // register interpolator
    interpolator$1.lab = lab;

    var Color$9 = Color_1;

    var _hsx = function (col1, col2, f, m) {
        var assign, assign$1;

        var xyz0, xyz1;
        if (m === 'hsl') {
            xyz0 = col1.hsl();
            xyz1 = col2.hsl();
        } else if (m === 'hsv') {
            xyz0 = col1.hsv();
            xyz1 = col2.hsv();
        } else if (m === 'hcg') {
            xyz0 = col1.hcg();
            xyz1 = col2.hcg();
        } else if (m === 'hsi') {
            xyz0 = col1.hsi();
            xyz1 = col2.hsi();
        } else if (m === 'lch' || m === 'hcl') {
            m = 'hcl';
            xyz0 = col1.hcl();
            xyz1 = col2.hcl();
        } else if (m === 'oklch') {
            xyz0 = col1.oklch().reverse();
            xyz1 = col2.oklch().reverse();
        }

        var hue0, hue1, sat0, sat1, lbv0, lbv1;
        if (m.substr(0, 1) === 'h' || m === 'oklch') {
            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);
            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);
        }

        var sat, hue, lbv, dh;

        if (!isNaN(hue0) && !isNaN(hue1)) {
            // both colors have hue
            if (hue1 > hue0 && hue1 - hue0 > 180) {
                dh = hue1 - (hue0 + 360);
            } else if (hue1 < hue0 && hue0 - hue1 > 180) {
                dh = hue1 + 360 - hue0;
            } else {
                dh = hue1 - hue0;
            }
            hue = hue0 + f * dh;
        } else if (!isNaN(hue0)) {
            hue = hue0;
            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }
        } else if (!isNaN(hue1)) {
            hue = hue1;
            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }
        } else {
            hue = Number.NaN;
        }

        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }
        lbv = lbv0 + f * (lbv1 - lbv0);
        return m === 'oklch' ? new Color$9([lbv, sat, hue], m) : new Color$9([hue, sat, lbv], m);
    };

    var interpolate_hsx$5 = _hsx;

    var lch = function (col1, col2, f) {
    	return interpolate_hsx$5(col1, col2, f, 'lch');
    };

    // register interpolator
    interpolator$1.lch = lch;
    interpolator$1.hcl = lch;

    var Color$8 = Color_1;

    var num = function (col1, col2, f) {
        var c1 = col1.num();
        var c2 = col2.num();
        return new Color$8(c1 + f * (c2-c1), 'num')
    };

    // register interpolator
    interpolator$1.num = num;

    var interpolate_hsx$4 = _hsx;

    var hcg = function (col1, col2, f) {
    	return interpolate_hsx$4(col1, col2, f, 'hcg');
    };

    // register interpolator
    interpolator$1.hcg = hcg;

    var interpolate_hsx$3 = _hsx;

    var hsi = function (col1, col2, f) {
    	return interpolate_hsx$3(col1, col2, f, 'hsi');
    };

    // register interpolator
    interpolator$1.hsi = hsi;

    var interpolate_hsx$2 = _hsx;

    var hsl = function (col1, col2, f) {
    	return interpolate_hsx$2(col1, col2, f, 'hsl');
    };

    // register interpolator
    interpolator$1.hsl = hsl;

    var interpolate_hsx$1 = _hsx;

    var hsv = function (col1, col2, f) {
    	return interpolate_hsx$1(col1, col2, f, 'hsv');
    };

    // register interpolator
    interpolator$1.hsv = hsv;

    var Color$7 = Color_1;

    var oklab = function (col1, col2, f) {
        var xyz0 = col1.oklab();
        var xyz1 = col2.oklab();
        return new Color$7(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            'oklab'
        );
    };

    // register interpolator
    interpolator$1.oklab = oklab;

    var interpolate_hsx = _hsx;

    var oklch = function (col1, col2, f) {
        return interpolate_hsx(col1, col2, f, 'oklch');
    };

    // register interpolator
    interpolator$1.oklch = oklch;

    var Color$6 = Color_1;
    var clip_rgb$1 = utils.clip_rgb;
    var pow$4 = Math.pow;
    var sqrt$1 = Math.sqrt;
    var PI$1 = Math.PI;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var atan2$1 = Math.atan2;

    var average = function (colors, mode, weights) {
        if ( mode === void 0 ) mode='lrgb';
        if ( weights === void 0 ) weights=null;

        var l = colors.length;
        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }
        // normalize weights
        var k = l / weights.reduce(function(a, b) { return a + b; });
        weights.forEach(function (w,i) { weights[i] *= k; });
        // convert colors to Color objects
        colors = colors.map(function (c) { return new Color$6(c); });
        if (mode === 'lrgb') {
            return _average_lrgb(colors, weights)
        }
        var first = colors.shift();
        var xyz = first.get(mode);
        var cnt = [];
        var dx = 0;
        var dy = 0;
        // initial color
        for (var i=0; i<xyz.length; i++) {
            xyz[i] = (xyz[i] || 0) * weights[0];
            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);
            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {
                var A = xyz[i] / 180 * PI$1;
                dx += cos$2(A) * weights[0];
                dy += sin$2(A) * weights[0];
            }
        }

        var alpha = first.alpha() * weights[0];
        colors.forEach(function (c,ci) {
            var xyz2 = c.get(mode);
            alpha += c.alpha() * weights[ci+1];
            for (var i=0; i<xyz.length; i++) {
                if (!isNaN(xyz2[i])) {
                    cnt[i] += weights[ci+1];
                    if (mode.charAt(i) === 'h') {
                        var A = xyz2[i] / 180 * PI$1;
                        dx += cos$2(A) * weights[ci+1];
                        dy += sin$2(A) * weights[ci+1];
                    } else {
                        xyz[i] += xyz2[i] * weights[ci+1];
                    }
                }
            }
        });

        for (var i$1=0; i$1<xyz.length; i$1++) {
            if (mode.charAt(i$1) === 'h') {
                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;
                while (A$1 < 0) { A$1 += 360; }
                while (A$1 >= 360) { A$1 -= 360; }
                xyz[i$1] = A$1;
            } else {
                xyz[i$1] = xyz[i$1]/cnt[i$1];
            }
        }
        alpha /= l;
        return (new Color$6(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);
    };


    var _average_lrgb = function (colors, weights) {
        var l = colors.length;
        var xyz = [0,0,0,0];
        for (var i=0; i < colors.length; i++) {
            var col = colors[i];
            var f = weights[i] / l;
            var rgb = col._rgb;
            xyz[0] += pow$4(rgb[0],2) * f;
            xyz[1] += pow$4(rgb[1],2) * f;
            xyz[2] += pow$4(rgb[2],2) * f;
            xyz[3] += rgb[3] * f;
        }
        xyz[0] = sqrt$1(xyz[0]);
        xyz[1] = sqrt$1(xyz[1]);
        xyz[2] = sqrt$1(xyz[2]);
        if (xyz[3] > 0.9999999) { xyz[3] = 1; }
        return new Color$6(clip_rgb$1(xyz));
    };

    // minimal multi-purpose interface

    // @requires utils color analyze

    var chroma$4 = chroma_1;
    var type$2 = utils.type;

    var pow$3 = Math.pow;

    var scale$2 = function(colors) {

        // constructor
        var _mode = 'rgb';
        var _nacol = chroma$4('#ccc');
        var _spread = 0;
        // const _fixed = false;
        var _domain = [0, 1];
        var _pos = [];
        var _padding = [0,0];
        var _classes = false;
        var _colors = [];
        var _out = false;
        var _min = 0;
        var _max = 1;
        var _correctLightness = false;
        var _colorCache = {};
        var _useCache = true;
        var _gamma = 1;

        // private methods

        var setColors = function(colors) {
            colors = colors || ['#fff', '#000'];
            if (colors && type$2(colors) === 'string' && chroma$4.brewer &&
                chroma$4.brewer[colors.toLowerCase()]) {
                colors = chroma$4.brewer[colors.toLowerCase()];
            }
            if (type$2(colors) === 'array') {
                // handle single color
                if (colors.length === 1) {
                    colors = [colors[0], colors[0]];
                }
                // make a copy of the colors
                colors = colors.slice(0);
                // convert to chroma classes
                for (var c=0; c<colors.length; c++) {
                    colors[c] = chroma$4(colors[c]);
                }
                // auto-fill color position
                _pos.length = 0;
                for (var c$1=0; c$1<colors.length; c$1++) {
                    _pos.push(c$1/(colors.length-1));
                }
            }
            resetCache();
            return _colors = colors;
        };

        var getClass = function(value) {
            if (_classes != null) {
                var n = _classes.length-1;
                var i = 0;
                while (i < n && value >= _classes[i]) {
                    i++;
                }
                return i-1;
            }
            return 0;
        };

        var tMapLightness = function (t) { return t; };
        var tMapDomain = function (t) { return t; };

        // const classifyValue = function(value) {
        //     let val = value;
        //     if (_classes.length > 2) {
        //         const n = _classes.length-1;
        //         const i = getClass(value);
        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class
        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class
        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));
        //     }
        //     return val;
        // };

        var getColor = function(val, bypassMap) {
            var col, t;
            if (bypassMap == null) { bypassMap = false; }
            if (isNaN(val) || (val === null)) { return _nacol; }
            if (!bypassMap) {
                if (_classes && (_classes.length > 2)) {
                    // find the class
                    var c = getClass(val);
                    t = c / (_classes.length-2);
                } else if (_max !== _min) {
                    // just interpolate between min/max
                    t = (val - _min) / (_max - _min);
                } else {
                    t = 1;
                }
            } else {
                t = val;
            }

            // domain map
            t = tMapDomain(t);

            if (!bypassMap) {
                t = tMapLightness(t);  // lightness correction
            }

            if (_gamma !== 1) { t = pow$3(t, _gamma); }

            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));

            t = Math.min(1, Math.max(0, t));

            var k = Math.floor(t * 10000);

            if (_useCache && _colorCache[k]) {
                col = _colorCache[k];
            } else {
                if (type$2(_colors) === 'array') {
                    //for i in [0.._pos.length-1]
                    for (var i=0; i<_pos.length; i++) {
                        var p = _pos[i];
                        if (t <= p) {
                            col = _colors[i];
                            break;
                        }
                        if ((t >= p) && (i === (_pos.length-1))) {
                            col = _colors[i];
                            break;
                        }
                        if (t > p && t < _pos[i+1]) {
                            t = (t-p)/(_pos[i+1]-p);
                            col = chroma$4.interpolate(_colors[i], _colors[i+1], t, _mode);
                            break;
                        }
                    }
                } else if (type$2(_colors) === 'function') {
                    col = _colors(t);
                }
                if (_useCache) { _colorCache[k] = col; }
            }
            return col;
        };

        var resetCache = function () { return _colorCache = {}; };

        setColors(colors);

        // public interface

        var f = function(v) {
            var c = chroma$4(getColor(v));
            if (_out && c[_out]) { return c[_out](); } else { return c; }
        };

        f.classes = function(classes) {
            if (classes != null) {
                if (type$2(classes) === 'array') {
                    _classes = classes;
                    _domain = [classes[0], classes[classes.length-1]];
                } else {
                    var d = chroma$4.analyze(_domain);
                    if (classes === 0) {
                        _classes = [d.min, d.max];
                    } else {
                        _classes = chroma$4.limits(d, 'e', classes);
                    }
                }
                return f;
            }
            return _classes;
        };


        f.domain = function(domain) {
            if (!arguments.length) {
                return _domain;
            }
            _min = domain[0];
            _max = domain[domain.length-1];
            _pos = [];
            var k = _colors.length;
            if ((domain.length === k) && (_min !== _max)) {
                // update positions
                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {
                    var d = list[i];

                  _pos.push((d-_min) / (_max-_min));
                }
            } else {
                for (var c=0; c<k; c++) {
                    _pos.push(c/(k-1));
                }
                if (domain.length > 2) {
                    // set domain map
                    var tOut = domain.map(function (d,i) { return i/(domain.length-1); });
                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });
                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {
                        tMapDomain = function (t) {
                            if (t <= 0 || t >= 1) { return t; }
                            var i = 0;
                            while (t >= tBreaks[i+1]) { i++; }
                            var f = (t - tBreaks[i]) / (tBreaks[i+1] - tBreaks[i]);
                            var out = tOut[i] + f * (tOut[i+1] - tOut[i]);
                            return out;
                        };
                    }

                }
            }
            _domain = [_min, _max];
            return f;
        };

        f.mode = function(_m) {
            if (!arguments.length) {
                return _mode;
            }
            _mode = _m;
            resetCache();
            return f;
        };

        f.range = function(colors, _pos) {
            setColors(colors);
            return f;
        };

        f.out = function(_o) {
            _out = _o;
            return f;
        };

        f.spread = function(val) {
            if (!arguments.length) {
                return _spread;
            }
            _spread = val;
            return f;
        };

        f.correctLightness = function(v) {
            if (v == null) { v = true; }
            _correctLightness = v;
            resetCache();
            if (_correctLightness) {
                tMapLightness = function(t) {
                    var L0 = getColor(0, true).lab()[0];
                    var L1 = getColor(1, true).lab()[0];
                    var pol = L0 > L1;
                    var L_actual = getColor(t, true).lab()[0];
                    var L_ideal = L0 + ((L1 - L0) * t);
                    var L_diff = L_actual - L_ideal;
                    var t0 = 0;
                    var t1 = 1;
                    var max_iter = 20;
                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {
                        (function() {
                            if (pol) { L_diff *= -1; }
                            if (L_diff < 0) {
                                t0 = t;
                                t += (t1 - t) * 0.5;
                            } else {
                                t1 = t;
                                t += (t0 - t) * 0.5;
                            }
                            L_actual = getColor(t, true).lab()[0];
                            return L_diff = L_actual - L_ideal;
                        })();
                    }
                    return t;
                };
            } else {
                tMapLightness = function (t) { return t; };
            }
            return f;
        };

        f.padding = function(p) {
            if (p != null) {
                if (type$2(p) === 'number') {
                    p = [p,p];
                }
                _padding = p;
                return f;
            } else {
                return _padding;
            }
        };

        f.colors = function(numColors, out) {
            // If no arguments are given, return the original colors that were provided
            if (arguments.length < 2) { out = 'hex'; }
            var result = [];

            if (arguments.length === 0) {
                result = _colors.slice(0);

            } else if (numColors === 1) {
                result = [f(0.5)];

            } else if (numColors > 1) {
                var dm = _domain[0];
                var dd = _domain[1] - dm;
                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });

            } else { // returns all colors based on the defined classes
                colors = [];
                var samples = [];
                if (_classes && (_classes.length > 2)) {
                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
                        samples.push((_classes[i-1]+_classes[i])*0.5);
                    }
                } else {
                    samples = _domain;
                }
                result = samples.map(function (v) { return f(v); });
            }

            if (chroma$4[out]) {
                result = result.map(function (c) { return c[out](); });
            }
            return result;
        };

        f.cache = function(c) {
            if (c != null) {
                _useCache = c;
                return f;
            } else {
                return _useCache;
            }
        };

        f.gamma = function(g) {
            if (g != null) {
                _gamma = g;
                return f;
            } else {
                return _gamma;
            }
        };

        f.nodata = function(d) {
            if (d != null) {
                _nacol = chroma$4(d);
                return f;
            } else {
                return _nacol;
            }
        };

        return f;
    };

    function __range__(left, right, inclusive) {
      var range = [];
      var ascending = left < right;
      var end = !inclusive ? right : ascending ? right + 1 : right - 1;
      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
        range.push(i);
      }
      return range;
    }

    //
    // interpolates between a set of colors uzing a bezier spline
    //

    // @requires utils lab
    var Color$5 = Color_1;

    var scale$1 = scale$2;

    // nth row of the pascal triangle
    var binom_row = function(n) {
        var row = [1, 1];
        for (var i = 1; i < n; i++) {
            var newrow = [1];
            for (var j = 1; j <= row.length; j++) {
                newrow[j] = (row[j] || 0) + row[j - 1];
            }
            row = newrow;
        }
        return row;
    };

    var bezier = function(colors) {
        var assign, assign$1, assign$2;

        var I, lab0, lab1, lab2;
        colors = colors.map(function (c) { return new Color$5(c); });
        if (colors.length === 2) {
            // linear interpolation
            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length === 3) {
            // quadratic bezier interpolation
            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length === 4) {
            // cubic bezier interpolation
            var lab3;
            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length >= 5) {
            // general case (degree n bezier)
            var labs, row, n;
            labs = colors.map(function (c) { return c.lab(); });
            n = colors.length - 1;
            row = binom_row(n);
            I = function (t) {
                var u = 1 - t;
                var lab = ([0, 1, 2].map(function (i) { return labs.reduce(function (sum, el, j) { return (sum + row[j] * Math.pow( u, (n - j) ) * Math.pow( t, j ) * el[i]); }, 0); }));
                return new Color$5(lab, 'lab');
            };
        } else {
            throw new RangeError("No point in running bezier with only one color.")
        }
        return I;
    };

    var bezier_1 = function (colors) {
        var f = bezier(colors);
        f.scale = function () { return scale$1(f); };
        return f;
    };

    /*
     * interpolates between a set of colors uzing a bezier spline
     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/
     */

    var chroma$3 = chroma_1;

    var blend = function (bottom, top, mode) {
        if (!blend[mode]) {
            throw new Error('unknown blend mode ' + mode);
        }
        return blend[mode](bottom, top);
    };

    var blend_f = function (f) { return function (bottom,top) {
            var c0 = chroma$3(top).rgb();
            var c1 = chroma$3(bottom).rgb();
            return chroma$3.rgb(f(c0, c1));
        }; };

    var each = function (f) { return function (c0, c1) {
            var out = [];
            out[0] = f(c0[0], c1[0]);
            out[1] = f(c0[1], c1[1]);
            out[2] = f(c0[2], c1[2]);
            return out;
        }; };

    var normal = function (a) { return a; };
    var multiply = function (a,b) { return a * b / 255; };
    var darken = function (a,b) { return a > b ? b : a; };
    var lighten = function (a,b) { return a > b ? a : b; };
    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };
    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };
    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };
    var dodge = function (a,b) {
        if (a === 255) { return 255; }
        a = 255 * (b / 255) / (1 - a / 255);
        return a > 255 ? 255 : a
    };

    // # add = (a,b) ->
    // #     if (a + b > 255) then 255 else a + b

    blend.normal = blend_f(each(normal));
    blend.multiply = blend_f(each(multiply));
    blend.screen = blend_f(each(screen));
    blend.overlay = blend_f(each(overlay));
    blend.darken = blend_f(each(darken));
    blend.lighten = blend_f(each(lighten));
    blend.dodge = blend_f(each(dodge));
    blend.burn = blend_f(each(burn));
    // blend.add = blend_f(each(add));

    var blend_1 = blend;

    // cubehelix interpolation
    // based on D.A. Green "A colour scheme for the display of astronomical intensity images"
    // http://astron-soc.in/bulletin/11June/289392011.pdf

    var type$1 = utils.type;
    var clip_rgb = utils.clip_rgb;
    var TWOPI = utils.TWOPI;
    var pow$2 = Math.pow;
    var sin$1 = Math.sin;
    var cos$1 = Math.cos;
    var chroma$2 = chroma_1;

    var cubehelix = function(start, rotations, hue, gamma, lightness) {
        if ( start === void 0 ) start=300;
        if ( rotations === void 0 ) rotations=-1.5;
        if ( hue === void 0 ) hue=1;
        if ( gamma === void 0 ) gamma=1;
        if ( lightness === void 0 ) lightness=[0,1];

        var dh = 0, dl;
        if (type$1(lightness) === 'array') {
            dl = lightness[1] - lightness[0];
        } else {
            dl = 0;
            lightness = [lightness, lightness];
        }

        var f = function(fract) {
            var a = TWOPI * (((start+120)/360) + (rotations * fract));
            var l = pow$2(lightness[0] + (dl * fract), gamma);
            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;
            var amp = (h * l * (1-l)) / 2;
            var cos_a = cos$1(a);
            var sin_a = sin$1(a);
            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));
            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));
            var b = l + (amp * (+1.97294 * cos_a));
            return chroma$2(clip_rgb([r*255,g*255,b*255,1]));
        };

        f.start = function(s) {
            if ((s == null)) { return start; }
            start = s;
            return f;
        };

        f.rotations = function(r) {
            if ((r == null)) { return rotations; }
            rotations = r;
            return f;
        };

        f.gamma = function(g) {
            if ((g == null)) { return gamma; }
            gamma = g;
            return f;
        };

        f.hue = function(h) {
            if ((h == null)) { return hue; }
            hue = h;
            if (type$1(hue) === 'array') {
                dh = hue[1] - hue[0];
                if (dh === 0) { hue = hue[1]; }
            } else {
                dh = 0;
            }
            return f;
        };

        f.lightness = function(h) {
            if ((h == null)) { return lightness; }
            if (type$1(h) === 'array') {
                lightness = h;
                dl = h[1] - h[0];
            } else {
                lightness = [h,h];
                dl = 0;
            }
            return f;
        };

        f.scale = function () { return chroma$2.scale(f); };

        f.hue(hue);

        return f;
    };

    var Color$4 = Color_1;
    var digits = '0123456789abcdef';

    var floor$1 = Math.floor;
    var random = Math.random;

    var random_1 = function () {
        var code = '#';
        for (var i=0; i<6; i++) {
            code += digits.charAt(floor$1(random() * 16));
        }
        return new Color$4(code, 'hex');
    };

    var type = type$p;
    var log = Math.log;
    var pow$1 = Math.pow;
    var floor = Math.floor;
    var abs$1 = Math.abs;


    var analyze = function (data, key) {
        if ( key === void 0 ) key=null;

        var r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE*-1,
            sum: 0,
            values: [],
            count: 0
        };
        if (type(data) === 'object') {
            data = Object.values(data);
        }
        data.forEach(function (val) {
            if (key && type(val) === 'object') { val = val[key]; }
            if (val !== undefined && val !== null && !isNaN(val)) {
                r.values.push(val);
                r.sum += val;
                if (val < r.min) { r.min = val; }
                if (val > r.max) { r.max = val; }
                r.count += 1;
            }
        });

        r.domain = [r.min, r.max];

        r.limits = function (mode, num) { return limits(r, mode, num); };

        return r;
    };


    var limits = function (data, mode, num) {
        if ( mode === void 0 ) mode='equal';
        if ( num === void 0 ) num=7;

        if (type(data) == 'array') {
            data = analyze(data);
        }
        var min = data.min;
        var max = data.max;
        var values = data.values.sort(function (a,b) { return a-b; });

        if (num === 1) { return [min,max]; }

        var limits = [];

        if (mode.substr(0,1) === 'c') { // continuous
            limits.push(min);
            limits.push(max);
        }

        if (mode.substr(0,1) === 'e') { // equal interval
            limits.push(min);
            for (var i=1; i<num; i++) {
                limits.push(min+((i/num)*(max-min)));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'l') { // log scale
            if (min <= 0) {
                throw new Error('Logarithmic scales are only possible for values > 0');
            }
            var min_log = Math.LOG10E * log(min);
            var max_log = Math.LOG10E * log(max);
            limits.push(min);
            for (var i$1=1; i$1<num; i$1++) {
                limits.push(pow$1(10, min_log + ((i$1/num) * (max_log - min_log))));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'q') { // quantile scale
            limits.push(min);
            for (var i$2=1; i$2<num; i$2++) {
                var p = ((values.length-1) * i$2)/num;
                var pb = floor(p);
                if (pb === p) {
                    limits.push(values[pb]);
                } else { // p > pb
                    var pr = p - pb;
                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));
                }
            }
            limits.push(max);

        }

        else if (mode.substr(0,1) === 'k') { // k-means clustering
            /*
            implementation based on
            http://code.google.com/p/figue/source/browse/trunk/figue.js#336
            simplified for 1-d input values
            */
            var cluster;
            var n = values.length;
            var assignments = new Array(n);
            var clusterSizes = new Array(num);
            var repeat = true;
            var nb_iters = 0;
            var centroids = null;

            // get seed values
            centroids = [];
            centroids.push(min);
            for (var i$3=1; i$3<num; i$3++) {
                centroids.push(min + ((i$3/num) * (max-min)));
            }
            centroids.push(max);

            while (repeat) {
                // assignment step
                for (var j=0; j<num; j++) {
                    clusterSizes[j] = 0;
                }
                for (var i$4=0; i$4<n; i$4++) {
                    var value = values[i$4];
                    var mindist = Number.MAX_VALUE;
                    var best = (void 0);
                    for (var j$1=0; j$1<num; j$1++) {
                        var dist = abs$1(centroids[j$1]-value);
                        if (dist < mindist) {
                            mindist = dist;
                            best = j$1;
                        }
                        clusterSizes[best]++;
                        assignments[i$4] = best;
                    }
                }

                // update centroids step
                var newCentroids = new Array(num);
                for (var j$2=0; j$2<num; j$2++) {
                    newCentroids[j$2] = null;
                }
                for (var i$5=0; i$5<n; i$5++) {
                    cluster = assignments[i$5];
                    if (newCentroids[cluster] === null) {
                        newCentroids[cluster] = values[i$5];
                    } else {
                        newCentroids[cluster] += values[i$5];
                    }
                }
                for (var j$3=0; j$3<num; j$3++) {
                    newCentroids[j$3] *= 1/clusterSizes[j$3];
                }

                // check convergence
                repeat = false;
                for (var j$4=0; j$4<num; j$4++) {
                    if (newCentroids[j$4] !== centroids[j$4]) {
                        repeat = true;
                        break;
                    }
                }

                centroids = newCentroids;
                nb_iters++;

                if (nb_iters > 200) {
                    repeat = false;
                }
            }

            // finished k-means clustering
            // the next part is borrowed from gabrielflor.it
            var kClusters = {};
            for (var j$5=0; j$5<num; j$5++) {
                kClusters[j$5] = [];
            }
            for (var i$6=0; i$6<n; i$6++) {
                cluster = assignments[i$6];
                kClusters[cluster].push(values[i$6]);
            }
            var tmpKMeansBreaks = [];
            for (var j$6=0; j$6<num; j$6++) {
                tmpKMeansBreaks.push(kClusters[j$6][0]);
                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);
            }
            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });
            limits.push(tmpKMeansBreaks[0]);
            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {
                var v = tmpKMeansBreaks[i$7];
                if (!isNaN(v) && (limits.indexOf(v) === -1)) {
                    limits.push(v);
                }
            }
        }
        return limits;
    };

    var analyze_1 = {analyze: analyze, limits: limits};

    var Color$3 = Color_1;


    var contrast = function (a, b) {
        // WCAG contrast ratio
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
        a = new Color$3(a);
        b = new Color$3(b);
        var l1 = a.luminance();
        var l2 = b.luminance();
        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
    };

    var Color$2 = Color_1;
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var min = Math.min;
    var max = Math.max;
    var atan2 = Math.atan2;
    var abs = Math.abs;
    var cos = Math.cos;
    var sin = Math.sin;
    var exp = Math.exp;
    var PI = Math.PI;

    var deltaE = function(a, b, Kl, Kc, Kh) {
        if ( Kl === void 0 ) Kl=1;
        if ( Kc === void 0 ) Kc=1;
        if ( Kh === void 0 ) Kh=1;

        // Delta E (CIE 2000)
        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html
        var rad2deg = function(rad) {
            return 360 * rad / (2 * PI);
        };
        var deg2rad = function(deg) {
            return (2 * PI * deg) / 360;
        };
        a = new Color$2(a);
        b = new Color$2(b);
        var ref = Array.from(a.lab());
        var L1 = ref[0];
        var a1 = ref[1];
        var b1 = ref[2];
        var ref$1 = Array.from(b.lab());
        var L2 = ref$1[0];
        var a2 = ref$1[1];
        var b2 = ref$1[2];
        var avgL = (L1 + L2)/2;
        var C1 = sqrt(pow(a1, 2) + pow(b1, 2));
        var C2 = sqrt(pow(a2, 2) + pow(b2, 2));
        var avgC = (C1 + C2)/2;
        var G = 0.5*(1-sqrt(pow(avgC, 7)/(pow(avgC, 7) + pow(25, 7))));
        var a1p = a1*(1+G);
        var a2p = a2*(1+G);
        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));
        var C2p = sqrt(pow(a2p, 2) + pow(b2, 2));
        var avgCp = (C1p + C2p)/2;
        var arctan1 = rad2deg(atan2(b1, a1p));
        var arctan2 = rad2deg(atan2(b2, a2p));
        var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
        var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
        var avgHp = abs(h1p - h2p) > 180 ? (h1p + h2p + 360)/2 : (h1p + h2p)/2;
        var T = 1 - 0.17*cos(deg2rad(avgHp - 30)) + 0.24*cos(deg2rad(2*avgHp)) + 0.32*cos(deg2rad(3*avgHp + 6)) - 0.2*cos(deg2rad(4*avgHp - 63));
        var deltaHp = h2p - h1p;
        deltaHp = abs(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
        deltaHp = 2*sqrt(C1p*C2p)*sin(deg2rad(deltaHp)/2);
        var deltaL = L2 - L1;
        var deltaCp = C2p - C1p;    
        var sl = 1 + (0.015*pow(avgL - 50, 2))/sqrt(20 + pow(avgL - 50, 2));
        var sc = 1 + 0.045*avgCp;
        var sh = 1 + 0.015*avgCp*T;
        var deltaTheta = 30*exp(-pow((avgHp - 275)/25, 2));
        var Rc = 2*sqrt(pow(avgCp, 7)/(pow(avgCp, 7) + pow(25, 7)));
        var Rt = -Rc*sin(2*deg2rad(deltaTheta));
        var result = sqrt(pow(deltaL/(Kl*sl), 2) + pow(deltaCp/(Kc*sc), 2) + pow(deltaHp/(Kh*sh), 2) + Rt*(deltaCp/(Kc*sc))*(deltaHp/(Kh*sh)));
        return max(0, min(100, result));
    };

    var Color$1 = Color_1;

    // simple Euclidean distance
    var distance = function(a, b, mode) {
        if ( mode === void 0 ) mode='lab';

        // Delta E (CIE 1976)
        // see http://www.brucelindbloom.com/index.html?Equations.html
        a = new Color$1(a);
        b = new Color$1(b);
        var l1 = a.get(mode);
        var l2 = b.get(mode);
        var sum_sq = 0;
        for (var i in l1) {
            var d = (l1[i] || 0) - (l2[i] || 0);
            sum_sq += d*d;
        }
        return Math.sqrt(sum_sq);
    };

    var Color = Color_1;

    var valid = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        try {
            new (Function.prototype.bind.apply( Color, [ null ].concat( args) ));
            return true;
        } catch (e) {
            return false;
        }
    };

    // some pre-defined color scales:
    var chroma$1 = chroma_1;

    var scale = scale$2;

    var scales = {
    	cool: function cool() { return scale([chroma$1.hsl(180,1,.9), chroma$1.hsl(250,.7,.4)]) },
    	hot: function hot() { return scale(['#000','#f00','#ff0','#fff']).mode('rgb') }
    };

    /**
        ColorBrewer colors for chroma.js

        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
        Pennsylvania State University.

        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing, software distributed
        under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
        CONDITIONS OF ANY KIND, either express or implied. See the License for the
        specific language governing permissions and limitations under the License.
    */

    var colorbrewer = {
        // sequential
        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],

        // diverging

        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],

        // qualitative

        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
    };

    // add lowercase aliases for case-insensitive matches
    for (var i = 0, list = Object.keys(colorbrewer); i < list.length; i += 1) {
        var key = list[i];

        colorbrewer[key.toLowerCase()] = colorbrewer[key];
    }

    var colorbrewer_1 = colorbrewer;

    var chroma = chroma_1;

    // feel free to comment out anything to rollup
    // a smaller chroma.js built

    // io --> convert colors

















    // operators --> modify existing Colors










    // interpolators












    // generators -- > create new colors
    chroma.average = average;
    chroma.bezier = bezier_1;
    chroma.blend = blend_1;
    chroma.cubehelix = cubehelix;
    chroma.mix = chroma.interpolate = mix$1;
    chroma.random = random_1;
    chroma.scale = scale$2;

    // other utility methods
    chroma.analyze = analyze_1.analyze;
    chroma.contrast = contrast;
    chroma.deltaE = deltaE;
    chroma.distance = distance;
    chroma.limits = analyze_1.limits;
    chroma.valid = valid;

    // scale
    chroma.scales = scales;

    // colors
    chroma.colors = w3cx11_1;
    chroma.brewer = colorbrewer_1;

    var chroma_js = chroma;

    return chroma_js;

}));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// UNUSED EXPORTS: default

;// CONCATENATED MODULE: ./public/JetBrainsMono-Regular.ttf
/* harmony default export */ const JetBrainsMono_Regular = (__webpack_require__.p + "73fb7b7f0e68b372adfeceffe115890a.ttf");
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(379);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(795);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(569);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(565);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(216);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(589);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./public/style.css
var style = __webpack_require__(563);
;// CONCATENATED MODULE: ./public/style.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(style/* default */.Z, options);




       /* harmony default export */ const public_style = (style/* default */.Z && style/* default */.Z.locals ? style/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/environment.js


const is_client = typeof window !== 'undefined';

/** @type {() => number} */
let environment_now = (/* unused pure expression or super */ null && (is_client ? () => window.performance.now() : () => Date.now()));

let environment_raf = (/* unused pure expression or super */ null && (is_client ? (cb) => requestAnimationFrame(cb) : noop));

// used internally for testing
/** @returns {void} */
function set_now(fn) {
	environment_now = fn;
}

/** @returns {void} */
function set_raf(fn) {
	environment_raf = fn;
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/loop.js


const tasks = new Set();

/**
 * @param {number} now
 * @returns {void}
 */
function run_tasks(now) {
	tasks.forEach((task) => {
		if (!task.c(now)) {
			tasks.delete(task);
			task.f();
		}
	});
	if (tasks.size !== 0) raf(run_tasks);
}

/**
 * For testing purposes only!
 * @returns {void}
 */
function clear_loops() {
	tasks.clear();
}

/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 * @param {import('./private.js').TaskCallback} callback
 * @returns {import('./private.js').Task}
 */
function loop_loop(callback) {
	/** @type {import('./private.js').TaskEntry} */
	let task;
	if (tasks.size === 0) raf(run_tasks);
	return {
		promise: new Promise((fulfill) => {
			tasks.add((task = { c: callback, f: fulfill }));
		}),
		abort() {
			tasks.delete(task);
		}
	};
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/globals.js
/** @type {typeof globalThis} */
const globals =
	typeof window !== 'undefined'
		? window
		: typeof globalThis !== 'undefined'
		? globalThis
		: // @ts-ignore Node typings have this
		  global;

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js


/**
 * Resize observer singleton.
 * One listener per element only!
 * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ
 */
class ResizeObserverSingleton {
	/**
	 * @private
	 * @readonly
	 * @type {WeakMap<Element, import('./private.js').Listener>}
	 */
	_listeners = "WeakMap" in globals ? new WeakMap() : undefined;

	/**
	 * @private
	 * @type {ResizeObserver}
	 */
	_observer = undefined;

	/** @type {ResizeObserverOptions} */
	options;

	/** @param {ResizeObserverOptions} options */
	constructor(options) {
		this.options = options;
	}

	/**
	 * @param {Element} element
	 * @param {import('./private.js').Listener} listener
	 * @returns {() => void}
	 */
	observe(element, listener) {
		this._listeners.set(element, listener);
		this._getObserver().observe(element, this.options);
		return () => {
			this._listeners.delete(element);
			this._observer.unobserve(element); // this line can probably be removed
		};
	}

	/**
	 * @private
	 */
	_getObserver() {
		return (
			this._observer ??
			(this._observer = new ResizeObserver((entries) => {
				for (const entry of entries) {
					ResizeObserverSingleton.entries.set(entry.target, entry);
					this._listeners.get(entry.target)?.(entry);
				}
			}))
		);
	}
}

// Needs to be written like this to pass the tree-shake-test
ResizeObserverSingleton.entries = "WeakMap" in globals ? new WeakMap() : undefined;

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/dom.js


// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
// at the end of hydration without touching the remaining nodes.
let is_hydrating = false;

/**
 * @returns {void}
 */
function start_hydrating() {
	is_hydrating = true;
}

/**
 * @returns {void}
 */
function end_hydrating() {
	is_hydrating = false;
}

/**
 * @param {number} low
 * @param {number} high
 * @param {(index: number) => number} key
 * @param {number} value
 * @returns {number}
 */
function upper_bound(low, high, key, value) {
	// Return first index of value larger than input value in the range [low, high)
	while (low < high) {
		const mid = low + ((high - low) >> 1);
		if (key(mid) <= value) {
			low = mid + 1;
		} else {
			high = mid;
		}
	}
	return low;
}

/**
 * @param {NodeEx} target
 * @returns {void}
 */
function init_hydrate(target) {
	if (target.hydrate_init) return;
	target.hydrate_init = true;
	// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>

	let children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);
	// If target is <head>, there may be children without claim_order
	if (target.nodeName === 'HEAD') {
		const myChildren = [];
		for (let i = 0; i < children.length; i++) {
			const node = children[i];
			if (node.claim_order !== undefined) {
				myChildren.push(node);
			}
		}
		children = myChildren;
	}
	/*
	 * Reorder claimed children optimally.
	 * We can reorder claimed children optimally by finding the longest subsequence of
	 * nodes that are already claimed in order and only moving the rest. The longest
	 * subsequence of nodes that are claimed in order can be found by
	 * computing the longest increasing subsequence of .claim_order values.
	 *
	 * This algorithm is optimal in generating the least amount of reorder operations
	 * possible.
	 *
	 * Proof:
	 * We know that, given a set of reordering operations, the nodes that do not move
	 * always form an increasing subsequence, since they do not move among each other
	 * meaning that they must be already ordered among each other. Thus, the maximal
	 * set of nodes that do not move form a longest increasing subsequence.
	 */
	// Compute longest increasing subsequence
	// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
	const m = new Int32Array(children.length + 1);
	// Predecessor indices + 1
	const p = new Int32Array(children.length);
	m[0] = -1;
	let longest = 0;
	for (let i = 0; i < children.length; i++) {
		const current = children[i].claim_order;
		// Find the largest subsequence length such that it ends in a value less than our current value
		// upper_bound returns first greater value, so we subtract one
		// with fast path for when we are on the current longest subsequence
		const seqLen =
			(longest > 0 && children[m[longest]].claim_order <= current
				? longest + 1
				: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;
		p[i] = m[seqLen] + 1;
		const newLen = seqLen + 1;
		// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
		m[newLen] = i;
		longest = Math.max(newLen, longest);
	}
	// The longest increasing subsequence of nodes (initially reversed)

	/**
	 * @type {NodeEx2[]}
	 */
	const lis = [];
	// The rest of the nodes, nodes that will be moved

	/**
	 * @type {NodeEx2[]}
	 */
	const toMove = [];
	let last = children.length - 1;
	for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
		lis.push(children[cur - 1]);
		for (; last >= cur; last--) {
			toMove.push(children[last]);
		}
		last--;
	}
	for (; last >= 0; last--) {
		toMove.push(children[last]);
	}
	lis.reverse();
	// We sort the nodes being moved to guarantee that their insertion order matches the claim order
	toMove.sort((a, b) => a.claim_order - b.claim_order);
	// Finally, we move the nodes
	for (let i = 0, j = 0; i < toMove.length; i++) {
		while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
			j++;
		}
		const anchor = j < lis.length ? lis[j] : null;
		target.insertBefore(toMove[i], anchor);
	}
}

/**
 * @param {Node} target
 * @param {Node} node
 * @returns {void}
 */
function append(target, node) {
	target.appendChild(node);
}

/**
 * @param {Node} target
 * @param {string} style_sheet_id
 * @param {string} styles
 * @returns {void}
 */
function append_styles(target, style_sheet_id, styles) {
	const append_styles_to = dom_get_root_for_style(target);
	if (!append_styles_to.getElementById(style_sheet_id)) {
		const style = dom_element('style');
		style.id = style_sheet_id;
		style.textContent = styles;
		append_stylesheet(append_styles_to, style);
	}
}

/**
 * @param {Node} node
 * @returns {ShadowRoot | Document}
 */
function dom_get_root_for_style(node) {
	if (!node) return document;
	const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
	if (root && /** @type {ShadowRoot} */ (root).host) {
		return /** @type {ShadowRoot} */ (root);
	}
	return node.ownerDocument;
}

/**
 * @param {Node} node
 * @returns {CSSStyleSheet}
 */
function dom_append_empty_stylesheet(node) {
	const style_element = dom_element('style');
	// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,
	// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.
	// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.
	// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.
	// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.
	style_element.textContent = '/* empty */';
	append_stylesheet(dom_get_root_for_style(node), style_element);
	return style_element.sheet;
}

/**
 * @param {ShadowRoot | Document} node
 * @param {HTMLStyleElement} style
 * @returns {CSSStyleSheet}
 */
function append_stylesheet(node, style) {
	append(/** @type {Document} */ (node).head || node, style);
	return style.sheet;
}

/**
 * @param {NodeEx} target
 * @param {NodeEx} node
 * @returns {void}
 */
function dom_append_hydration(target, node) {
	if (is_hydrating) {
		init_hydrate(target);
		if (
			target.actual_end_child === undefined ||
			(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)
		) {
			target.actual_end_child = target.firstChild;
		}
		// Skip nodes of undefined ordering
		while (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {
			target.actual_end_child = target.actual_end_child.nextSibling;
		}
		if (node !== target.actual_end_child) {
			// We only insert if the ordering of this node should be modified or the parent node is not target
			if (node.claim_order !== undefined || node.parentNode !== target) {
				target.insertBefore(node, target.actual_end_child);
			}
		} else {
			target.actual_end_child = node.nextSibling;
		}
	} else if (node.parentNode !== target || node.nextSibling !== null) {
		target.appendChild(node);
	}
}

/**
 * @param {Node} target
 * @param {Node} node
 * @param {Node} [anchor]
 * @returns {void}
 */
function insert(target, node, anchor) {
	target.insertBefore(node, anchor || null);
}

/**
 * @param {NodeEx} target
 * @param {NodeEx} node
 * @param {NodeEx} [anchor]
 * @returns {void}
 */
function dom_insert_hydration(target, node, anchor) {
	if (is_hydrating && !anchor) {
		dom_append_hydration(target, node);
	} else if (node.parentNode !== target || node.nextSibling != anchor) {
		target.insertBefore(node, anchor || null);
	}
}

/**
 * @param {Node} node
 * @returns {void}
 */
function dom_detach(node) {
	if (node.parentNode) {
		node.parentNode.removeChild(node);
	}
}

/**
 * @returns {void} */
function destroy_each(iterations, detaching) {
	for (let i = 0; i < iterations.length; i += 1) {
		if (iterations[i]) iterations[i].d(detaching);
	}
}

/**
 * @template {keyof HTMLElementTagNameMap} K
 * @param {K} name
 * @returns {HTMLElementTagNameMap[K]}
 */
function dom_element(name) {
	return document.createElement(name);
}

/**
 * @template {keyof HTMLElementTagNameMap} K
 * @param {K} name
 * @param {string} is
 * @returns {HTMLElementTagNameMap[K]}
 */
function element_is(name, is) {
	return document.createElement(name, { is });
}

/**
 * @template T
 * @template {keyof T} K
 * @param {T} obj
 * @param {K[]} exclude
 * @returns {Pick<T, Exclude<keyof T, K>>}
 */
function object_without_properties(obj, exclude) {
	const target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});
	for (const k in obj) {
		if (
			has_prop(obj, k) &&
			// @ts-ignore
			exclude.indexOf(k) === -1
		) {
			// @ts-ignore
			target[k] = obj[k];
		}
	}
	return target;
}

/**
 * @template {keyof SVGElementTagNameMap} K
 * @param {K} name
 * @returns {SVGElement}
 */
function svg_element(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

/**
 * @param {string} data
 * @returns {Text}
 */
function dom_text(data) {
	return document.createTextNode(data);
}

/**
 * @returns {Text} */
function space() {
	return dom_text(' ');
}

/**
 * @returns {Text} */
function empty() {
	return dom_text('');
}

/**
 * @param {string} content
 * @returns {Comment}
 */
function comment(content) {
	return document.createComment(content);
}

/**
 * @param {EventTarget} node
 * @param {string} event
 * @param {EventListenerOrEventListenerObject} handler
 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
 * @returns {() => void}
 */
function listen(node, event, handler, options) {
	node.addEventListener(event, handler, options);
	return () => node.removeEventListener(event, handler, options);
}

/**
 * @returns {(event: any) => any} */
function prevent_default(fn) {
	return function (event) {
		event.preventDefault();
		// @ts-ignore
		return fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => any} */
function stop_propagation(fn) {
	return function (event) {
		event.stopPropagation();
		// @ts-ignore
		return fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => any} */
function stop_immediate_propagation(fn) {
	return function (event) {
		event.stopImmediatePropagation();
		// @ts-ignore
		return fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => void} */
function dom_self(fn) {
	return function (event) {
		// @ts-ignore
		if (event.target === this) fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => void} */
function trusted(fn) {
	return function (event) {
		// @ts-ignore
		if (event.isTrusted) fn.call(this, event);
	};
}

/**
 * @param {Element} node
 * @param {string} attribute
 * @param {string} [value]
 * @returns {void}
 */
function attr(node, attribute, value) {
	if (value == null) node.removeAttribute(attribute);
	else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
/**
 * List of attributes that should always be set through the attr method,
 * because updating them through the property setter doesn't work reliably.
 * In the example of `width`/`height`, the problem is that the setter only
 * accepts numeric values, but the attribute can also be set to a string like `50%`.
 * If this list becomes too big, rethink this approach.
 */
const always_set_through_set_attribute = (/* unused pure expression or super */ null && (['width', 'height']));

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {{ [x: string]: string }} attributes
 * @returns {void}
 */
function set_attributes(node, attributes) {
	// @ts-ignore
	const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
	for (const key in attributes) {
		if (attributes[key] == null) {
			node.removeAttribute(key);
		} else if (key === 'style') {
			node.style.cssText = attributes[key];
		} else if (key === '__value') {
			/** @type {any} */ (node).value = node[key] = attributes[key];
		} else if (
			descriptors[key] &&
			descriptors[key].set &&
			always_set_through_set_attribute.indexOf(key) === -1
		) {
			node[key] = attributes[key];
		} else {
			attr(node, key, attributes[key]);
		}
	}
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {{ [x: string]: string }} attributes
 * @returns {void}
 */
function set_svg_attributes(node, attributes) {
	for (const key in attributes) {
		attr(node, key, attributes[key]);
	}
}

/**
 * @param {Record<string, unknown>} data_map
 * @returns {void}
 */
function set_custom_element_data_map(node, data_map) {
	Object.keys(data_map).forEach((key) => {
		set_custom_element_data(node, key, data_map[key]);
	});
}

/**
 * @returns {void} */
function set_custom_element_data(node, prop, value) {
	if (prop in node) {
		node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
	} else {
		attr(node, prop, value);
	}
}

/**
 * @param {string} tag
 */
function set_dynamic_element_data(tag) {
	return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
}

/**
 * @returns {void}
 */
function xlink_attr(node, attribute, value) {
	node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}

/**
 * @param {HTMLElement} node
 * @returns {string}
 */
function get_svelte_dataset(node) {
	return node.dataset.svelteH;
}

/**
 * @returns {unknown[]} */
function get_binding_group_value(group, __value, checked) {
	const value = new Set();
	for (let i = 0; i < group.length; i += 1) {
		if (group[i].checked) value.add(group[i].__value);
	}
	if (!checked) {
		value.delete(__value);
	}
	return Array.from(value);
}

/**
 * @param {HTMLInputElement[]} group
 * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}
 */
function init_binding_group(group) {
	/**
	 * @type {HTMLInputElement[]} */
	let _inputs;
	return {
		/* push */ p(...inputs) {
			_inputs = inputs;
			_inputs.forEach((input) => group.push(input));
		},
		/* remove */ r() {
			_inputs.forEach((input) => group.splice(group.indexOf(input), 1));
		}
	};
}

/**
 * @param {number[]} indexes
 * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}
 */
function init_binding_group_dynamic(group, indexes) {
	/**
	 * @type {HTMLInputElement[]} */
	let _group = get_binding_group(group);

	/**
	 * @type {HTMLInputElement[]} */
	let _inputs;

	function get_binding_group(group) {
		for (let i = 0; i < indexes.length; i++) {
			group = group[indexes[i]] = group[indexes[i]] || [];
		}
		return group;
	}

	/**
	 * @returns {void} */
	function push() {
		_inputs.forEach((input) => _group.push(input));
	}

	/**
	 * @returns {void} */
	function remove() {
		_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));
	}
	return {
		/* update */ u(new_indexes) {
			indexes = new_indexes;
			const new_group = get_binding_group(group);
			if (new_group !== _group) {
				remove();
				_group = new_group;
				push();
			}
		},
		/* push */ p(...inputs) {
			_inputs = inputs;
			push();
		},
		/* remove */ r: remove
	};
}

/**
 * @returns {number} */
function to_number(value) {
	return value === '' ? null : +value;
}

/**
 * @returns {any[]} */
function time_ranges_to_array(ranges) {
	const array = [];
	for (let i = 0; i < ranges.length; i += 1) {
		array.push({ start: ranges.start(i), end: ranges.end(i) });
	}
	return array;
}

/**
 * @param {Element} element
 * @returns {ChildNode[]}
 */
function children(element) {
	return Array.from(element.childNodes);
}

/**
 * @param {ChildNodeArray} nodes
 * @returns {void}
 */
function init_claim_info(nodes) {
	if (nodes.claim_info === undefined) {
		nodes.claim_info = { last_index: 0, total_claimed: 0 };
	}
}

/**
 * @template {ChildNodeEx} R
 * @param {ChildNodeArray} nodes
 * @param {(node: ChildNodeEx) => node is R} predicate
 * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} processNode
 * @param {() => R} createNode
 * @param {boolean} dontUpdateLastIndex
 * @returns {R}
 */
function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
	// Try to find nodes in an order such that we lengthen the longest increasing subsequence
	init_claim_info(nodes);
	const resultNode = (() => {
		// We first try to find an element after the previous one
		for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {
			const node = nodes[i];
			if (predicate(node)) {
				const replacement = processNode(node);
				if (replacement === undefined) {
					nodes.splice(i, 1);
				} else {
					nodes[i] = replacement;
				}
				if (!dontUpdateLastIndex) {
					nodes.claim_info.last_index = i;
				}
				return node;
			}
		}
		// Otherwise, we try to find one before
		// We iterate in reverse so that we don't go too far back
		for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {
			const node = nodes[i];
			if (predicate(node)) {
				const replacement = processNode(node);
				if (replacement === undefined) {
					nodes.splice(i, 1);
				} else {
					nodes[i] = replacement;
				}
				if (!dontUpdateLastIndex) {
					nodes.claim_info.last_index = i;
				} else if (replacement === undefined) {
					// Since we spliced before the last_index, we decrease it
					nodes.claim_info.last_index--;
				}
				return node;
			}
		}
		// If we can't find any matching node, we create a new one
		return createNode();
	})();
	resultNode.claim_order = nodes.claim_info.total_claimed;
	nodes.claim_info.total_claimed += 1;
	return resultNode;
}

/**
 * @param {ChildNodeArray} nodes
 * @param {string} name
 * @param {{ [key: string]: boolean }} attributes
 * @param {(name: string) => Element | SVGElement} create_element
 * @returns {Element | SVGElement}
 */
function claim_element_base(nodes, name, attributes, create_element) {
	return claim_node(
		nodes,
		/** @returns {node is Element | SVGElement} */
		(node) => node.nodeName === name,
		/** @param {Element} node */
		(node) => {
			const remove = [];
			for (let j = 0; j < node.attributes.length; j++) {
				const attribute = node.attributes[j];
				if (!attributes[attribute.name]) {
					remove.push(attribute.name);
				}
			}
			remove.forEach((v) => node.removeAttribute(v));
			return undefined;
		},
		() => create_element(name)
	);
}

/**
 * @param {ChildNodeArray} nodes
 * @param {string} name
 * @param {{ [key: string]: boolean }} attributes
 * @returns {Element | SVGElement}
 */
function claim_element(nodes, name, attributes) {
	return claim_element_base(nodes, name, attributes, dom_element);
}

/**
 * @param {ChildNodeArray} nodes
 * @param {string} name
 * @param {{ [key: string]: boolean }} attributes
 * @returns {Element | SVGElement}
 */
function claim_svg_element(nodes, name, attributes) {
	return claim_element_base(nodes, name, attributes, svg_element);
}

/**
 * @param {ChildNodeArray} nodes
 * @returns {Text}
 */
function claim_text(nodes, data) {
	return claim_node(
		nodes,
		/** @returns {node is Text} */
		(node) => node.nodeType === 3,
		/** @param {Text} node */
		(node) => {
			const dataStr = '' + data;
			if (node.data.startsWith(dataStr)) {
				if (node.data.length !== dataStr.length) {
					return node.splitText(dataStr.length);
				}
			} else {
				node.data = dataStr;
			}
		},
		() => dom_text(data),
		true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements
	);
}

/**
 * @returns {Text} */
function claim_space(nodes) {
	return claim_text(nodes, ' ');
}

/**
 * @param {ChildNodeArray} nodes
 * @returns {Comment}
 */
function claim_comment(nodes, data) {
	return claim_node(
		nodes,
		/** @returns {node is Comment} */
		(node) => node.nodeType === 8,
		/** @param {Comment} node */
		(node) => {
			node.data = '' + data;
			return undefined;
		},
		() => comment(data),
		true
	);
}

function find_comment(nodes, text, start) {
	for (let i = start; i < nodes.length; i += 1) {
		const node = nodes[i];
		if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {
			return i;
		}
	}
	return nodes.length;
}

/**
 * @param {boolean} is_svg
 * @returns {HtmlTagHydration}
 */
function claim_html_tag(nodes, is_svg) {
	// find html opening tag
	const start_index = find_comment(nodes, 'HTML_TAG_START', 0);
	const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);
	if (start_index === end_index) {
		return new HtmlTagHydration(undefined, is_svg);
	}
	init_claim_info(nodes);
	const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);
	dom_detach(html_tag_nodes[0]);
	dom_detach(html_tag_nodes[html_tag_nodes.length - 1]);
	const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
	for (const n of claimed_nodes) {
		n.claim_order = nodes.claim_info.total_claimed;
		nodes.claim_info.total_claimed += 1;
	}
	return new HtmlTagHydration(claimed_nodes, is_svg);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data(text, data) {
	data = '' + data;
	if (text.data === data) return;
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data_contenteditable(text, data) {
	data = '' + data;
	if (text.wholeText === data) return;
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @param {string} attr_value
 * @returns {void}
 */
function set_data_maybe_contenteditable(text, data, attr_value) {
	if (~contenteditable_truthy_values.indexOf(attr_value)) {
		set_data_contenteditable(text, data);
	} else {
		set_data(text, data);
	}
}

/**
 * @returns {void} */
function set_input_value(input, value) {
	input.value = value == null ? '' : value;
}

/**
 * @returns {void} */
function set_input_type(input, type) {
	try {
		input.type = type;
	} catch (e) {
		// do nothing
	}
}

/**
 * @returns {void} */
function set_style(node, key, value, important) {
	if (value == null) {
		node.style.removeProperty(key);
	} else {
		node.style.setProperty(key, value, important ? 'important' : '');
	}
}

/**
 * @returns {void} */
function select_option(select, value, mounting) {
	for (let i = 0; i < select.options.length; i += 1) {
		const option = select.options[i];
		if (option.__value === value) {
			option.selected = true;
			return;
		}
	}
	if (!mounting || value !== undefined) {
		select.selectedIndex = -1; // no option should be selected
	}
}

/**
 * @returns {void} */
function select_options(select, value) {
	for (let i = 0; i < select.options.length; i += 1) {
		const option = select.options[i];
		option.selected = ~value.indexOf(option.__value);
	}
}

function select_value(select) {
	const selected_option = select.querySelector(':checked');
	return selected_option && selected_option.__value;
}

function select_multiple_value(select) {
	return [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead

/**
 * @type {boolean} */
let crossorigin;

/**
 * @returns {boolean} */
function is_crossorigin() {
	if (crossorigin === undefined) {
		crossorigin = false;
		try {
			if (typeof window !== 'undefined' && window.parent) {
				void window.parent.document;
			}
		} catch (error) {
			crossorigin = true;
		}
	}
	return crossorigin;
}

/**
 * @param {HTMLElement} node
 * @param {() => void} fn
 * @returns {() => void}
 */
function add_iframe_resize_listener(node, fn) {
	const computed_style = getComputedStyle(node);
	if (computed_style.position === 'static') {
		node.style.position = 'relative';
	}
	const iframe = dom_element('iframe');
	iframe.setAttribute(
		'style',
		'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
			'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'
	);
	iframe.setAttribute('aria-hidden', 'true');
	iframe.tabIndex = -1;
	const crossorigin = is_crossorigin();

	/**
	 * @type {() => void}
	 */
	let unsubscribe;
	if (crossorigin) {
		iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
		unsubscribe = listen(
			window,
			'message',
			/** @param {MessageEvent} event */ (event) => {
				if (event.source === iframe.contentWindow) fn();
			}
		);
	} else {
		iframe.src = 'about:blank';
		iframe.onload = () => {
			unsubscribe = listen(iframe.contentWindow, 'resize', fn);
			// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)
			// see https://github.com/sveltejs/svelte/issues/4233
			fn();
		};
	}
	append(node, iframe);
	return () => {
		if (crossorigin) {
			unsubscribe();
		} else if (unsubscribe && iframe.contentWindow) {
			unsubscribe();
		}
		dom_detach(iframe);
	};
}
const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
	box: 'content-box'
});
const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({
	box: 'border-box'
});
const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(
	{ box: 'device-pixel-content-box' }
);


/**
 * @returns {void} */
function toggle_class(element, name, toggle) {
	// The `!!` is required because an `undefined` flag means flipping the current state.
	element.classList.toggle(name, !!toggle);
}

/**
 * @template T
 * @param {string} type
 * @param {T} [detail]
 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
 * @returns {CustomEvent<T>}
 */
function dom_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
	return new CustomEvent(type, { detail, bubbles, cancelable });
}

/**
 * @param {string} selector
 * @param {HTMLElement} parent
 * @returns {ChildNodeArray}
 */
function query_selector_all(selector, parent = document.body) {
	return Array.from(parent.querySelectorAll(selector));
}

/**
 * @param {string} nodeId
 * @param {HTMLElement} head
 * @returns {any[]}
 */
function head_selector(nodeId, head) {
	const result = [];
	let started = 0;
	for (const node of head.childNodes) {
		if (node.nodeType === 8 /* comment node */) {
			const comment = node.textContent.trim();
			if (comment === `HEAD_${nodeId}_END`) {
				started -= 1;
				result.push(node);
			} else if (comment === `HEAD_${nodeId}_START`) {
				started += 1;
				result.push(node);
			}
		} else if (started > 0) {
			result.push(node);
		}
	}
	return result;
}
/** */
class HtmlTag {
	/**
	 * @private
	 * @default false
	 */
	is_svg = false;
	// parent for creating node
	/** */
	e = undefined;
	// html tag nodes
	/** */
	n = undefined;
	// target
	/** */
	t = undefined;
	// anchor
	/** */
	a = undefined;
	constructor(is_svg = false) {
		this.is_svg = is_svg;
		this.e = this.n = null;
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	c(html) {
		this.h(html);
	}

	/**
	 * @param {string} html
	 * @param {HTMLElement | SVGElement} target
	 * @param {HTMLElement | SVGElement} anchor
	 * @returns {void}
	 */
	m(html, target, anchor = null) {
		if (!this.e) {
			if (this.is_svg)
				this.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));
			/** #7364  target for <template> may be provided as #document-fragment(11) */ else
				this.e = dom_element(
					/** @type {keyof HTMLElementTagNameMap} */ (
						target.nodeType === 11 ? 'TEMPLATE' : target.nodeName
					)
				);
			this.t =
				target.tagName !== 'TEMPLATE'
					? target
					: /** @type {HTMLTemplateElement} */ (target).content;
			this.c(html);
		}
		this.i(anchor);
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	h(html) {
		this.e.innerHTML = html;
		this.n = Array.from(
			this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes
		);
	}

	/**
	 * @returns {void} */
	i(anchor) {
		for (let i = 0; i < this.n.length; i += 1) {
			insert(this.t, this.n[i], anchor);
		}
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	p(html) {
		this.d();
		this.h(html);
		this.i(this.a);
	}

	/**
	 * @returns {void} */
	d() {
		this.n.forEach(dom_detach);
	}
}

/**
 * @extends HtmlTag */
class HtmlTagHydration extends (/* unused pure expression or super */ null && (HtmlTag)) {
	// hydration claimed nodes
	/** */
	l = undefined;
	constructor(claimed_nodes, is_svg = false) {
		super(is_svg);
		this.e = this.n = null;
		this.l = claimed_nodes;
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	c(html) {
		if (this.l) {
			this.n = this.l;
		} else {
			super.c(html);
		}
	}

	/**
	 * @returns {void} */
	i(anchor) {
		for (let i = 0; i < this.n.length; i += 1) {
			dom_insert_hydration(this.t, this.n[i], anchor);
		}
	}
}

/**
 * @param {NamedNodeMap} attributes
 * @returns {{}}
 */
function attribute_to_object(attributes) {
	const result = {};
	for (const attribute of attributes) {
		result[attribute.name] = attribute.value;
	}
	return result;
}

/**
 * @param {HTMLElement} element
 * @returns {{}}
 */
function get_custom_elements_slots(element) {
	const result = {};
	element.childNodes.forEach(
		/** @param {Element} node */ (node) => {
			result[node.slot || 'default'] = true;
		}
	);
	return result;
}

function construct_svelte_component(component, props) {
	return new component(props);
}

/**
 * @typedef {Node & {
 * 	claim_order?: number;
 * 	hydrate_init?: true;
 * 	actual_end_child?: NodeEx;
 * 	childNodes: NodeListOf<NodeEx>;
 * }} NodeEx
 */

/** @typedef {ChildNode & NodeEx} ChildNodeEx */

/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

/**
 * @typedef {ChildNodeEx[] & {
 * 	claim_info?: {
 * 		last_index: number;
 * 		total_claimed: number;
 * 	};
 * }} ChildNodeArray
 */

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/style_manager.js



// we need to store the information for multiple documents because a Svelte application could also contain iframes
// https://github.com/sveltejs/svelte/issues/3624
/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */
const managed_styles = new Map();

let active = 0;

// https://github.com/darkskyapp/string-hash/blob/master/index.js
/**
 * @param {string} str
 * @returns {number}
 */
function hash(str) {
	let hash = 5381;
	let i = str.length;
	while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
	return hash >>> 0;
}

/**
 * @param {Document | ShadowRoot} doc
 * @param {Element & ElementCSSInlineStyle} node
 * @returns {{ stylesheet: any; rules: {}; }}
 */
function create_style_information(doc, node) {
	const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
	managed_styles.set(doc, info);
	return info;
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {number} a
 * @param {number} b
 * @param {number} duration
 * @param {number} delay
 * @param {(t: number) => number} ease
 * @param {(t: number, u: number) => string} fn
 * @param {number} uid
 * @returns {string}
 */
function style_manager_create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
	const step = 16.666 / duration;
	let keyframes = '{\n';
	for (let p = 0; p <= 1; p += step) {
		const t = a + (b - a) * ease(p);
		keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
	}
	const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
	const name = `__svelte_${hash(rule)}_${uid}`;
	const doc = get_root_for_style(node);
	const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
	if (!rules[name]) {
		rules[name] = true;
		stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
	}
	const animation = node.style.animation || '';
	node.style.animation = `${
		animation ? `${animation}, ` : ''
	}${name} ${duration}ms linear ${delay}ms 1 both`;
	active += 1;
	return name;
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {string} [name]
 * @returns {void}
 */
function style_manager_delete_rule(node, name) {
	const previous = (node.style.animation || '').split(', ');
	const next = previous.filter(
		name
			? (anim) => anim.indexOf(name) < 0 // remove specific animation
			: (anim) => anim.indexOf('__svelte') === -1 // remove all Svelte animations
	);
	const deleted = previous.length - next.length;
	if (deleted) {
		node.style.animation = next.join(', ');
		active -= deleted;
		if (!active) clear_rules();
	}
}

/** @returns {void} */
function clear_rules() {
	raf(() => {
		if (active) return;
		managed_styles.forEach((info) => {
			const { ownerNode } = info.stylesheet;
			// there is no ownerNode if it runs on jsdom.
			if (ownerNode) detach(ownerNode);
		});
		managed_styles.clear();
	});
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/animations.js





/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {import('./private.js').PositionRect} from
 * @param {import('./private.js').AnimationFn} fn
 */
function create_animation(node, from, fn, params) {
	if (!from) return noop;
	const to = node.getBoundingClientRect();
	if (
		from.left === to.left &&
		from.right === to.right &&
		from.top === to.top &&
		from.bottom === to.bottom
	)
		return noop;
	const {
		delay = 0,
		duration = 300,
		easing = linear,
		// @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
		start: start_time = now() + delay,
		// @ts-ignore todo:
		end = start_time + duration,
		tick = noop,
		css
	} = fn(node, { from, to }, params);
	let running = true;
	let started = false;
	let name;
	/** @returns {void} */
	function start() {
		if (css) {
			name = create_rule(node, 0, 1, duration, delay, easing, css);
		}
		if (!delay) {
			started = true;
		}
	}
	/** @returns {void} */
	function stop() {
		if (css) delete_rule(node, name);
		running = false;
	}
	loop((now) => {
		if (!started && now >= start_time) {
			started = true;
		}
		if (started && now >= end) {
			tick(1, 0);
			stop();
		}
		if (!running) {
			return false;
		}
		if (started) {
			const p = now - start_time;
			const t = 0 + 1 * easing(p / duration);
			tick(t, 1 - t);
		}
		return true;
	});
	start();
	tick(0, 1);
	return stop;
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @returns {void}
 */
function fix_position(node) {
	const style = getComputedStyle(node);
	if (style.position !== 'absolute' && style.position !== 'fixed') {
		const { width, height } = style;
		const a = node.getBoundingClientRect();
		node.style.position = 'absolute';
		node.style.width = width;
		node.style.height = height;
		add_transform(node, a);
	}
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {import('./private.js').PositionRect} a
 * @returns {void}
 */
function add_transform(node, a) {
	const b = node.getBoundingClientRect();
	if (a.left !== b.left || a.top !== b.top) {
		const style = getComputedStyle(node);
		const transform = style.transform === 'none' ? '' : style.transform;
		node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
	}
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/utils.js
/** @returns {void} */
function utils_noop() {}

const identity = (x) => x;

/**
 * @template T
 * @template S
 * @param {T} tar
 * @param {S} src
 * @returns {T & S}
 */
function utils_assign(tar, src) {
	// @ts-ignore
	for (const k in src) tar[k] = src[k];
	return /** @type {T & S} */ (tar);
}

// Adapted from https://github.com/then/is-promise/blob/master/index.js
// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE
/**
 * @param {any} value
 * @returns {value is PromiseLike<any>}
 */
function utils_is_promise(value) {
	return (
		!!value &&
		(typeof value === 'object' || typeof value === 'function') &&
		typeof (/** @type {any} */ (value).then) === 'function'
	);
}

/** @returns {void} */
function add_location(element, file, line, column, char) {
	element.__svelte_meta = {
		loc: { file, line, column, char }
	};
}

function run(fn) {
	return fn();
}

function utils_blank_object() {
	return Object.create(null);
}

/**
 * @param {Function[]} fns
 * @returns {void}
 */
function utils_run_all(fns) {
	fns.forEach(run);
}

/**
 * @param {any} thing
 * @returns {thing is Function}
 */
function utils_is_function(thing) {
	return typeof thing === 'function';
}

/** @returns {boolean} */
function safe_not_equal(a, b) {
	return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';
}

let src_url_equal_anchor;

/** @returns {boolean} */
function src_url_equal(element_src, url) {
	if (!src_url_equal_anchor) {
		src_url_equal_anchor = document.createElement('a');
	}
	src_url_equal_anchor.href = url;
	return element_src === src_url_equal_anchor.href;
}

/** @returns {boolean} */
function not_equal(a, b) {
	return a != a ? b == b : a !== b;
}

/** @returns {boolean} */
function is_empty(obj) {
	return Object.keys(obj).length === 0;
}

/** @returns {void} */
function validate_store(store, name) {
	if (store != null && typeof store.subscribe !== 'function') {
		throw new Error(`'${name}' is not a store with a 'subscribe' method`);
	}
}

function utils_subscribe(store, ...callbacks) {
	if (store == null) {
		for (const callback of callbacks) {
			callback(undefined);
		}
		return utils_noop;
	}
	const unsub = store.subscribe(...callbacks);
	return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}

/**
 * Get the current value from a store by subscribing and immediately unsubscribing.
 *
 * https://svelte.dev/docs/svelte-store#get
 * @template T
 * @param {import('../store/public.js').Readable<T>} store
 * @returns {T}
 */
function get_store_value(store) {
	let value;
	utils_subscribe(store, (_) => (value = _))();
	return value;
}

/** @returns {void} */
function component_subscribe(component, store, callback) {
	component.$$.on_destroy.push(utils_subscribe(store, callback));
}

function create_slot(definition, ctx, $$scope, fn) {
	if (definition) {
		const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
		return definition[0](slot_ctx);
	}
}

function get_slot_context(definition, ctx, $$scope, fn) {
	return definition[1] && fn ? utils_assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}

function get_slot_changes(definition, $$scope, dirty, fn) {
	if (definition[2] && fn) {
		const lets = definition[2](fn(dirty));
		if ($$scope.dirty === undefined) {
			return lets;
		}
		if (typeof lets === 'object') {
			const merged = [];
			const len = Math.max($$scope.dirty.length, lets.length);
			for (let i = 0; i < len; i += 1) {
				merged[i] = $$scope.dirty[i] | lets[i];
			}
			return merged;
		}
		return $$scope.dirty | lets;
	}
	return $$scope.dirty;
}

/** @returns {void} */
function update_slot_base(
	slot,
	slot_definition,
	ctx,
	$$scope,
	slot_changes,
	get_slot_context_fn
) {
	if (slot_changes) {
		const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
		slot.p(slot_context, slot_changes);
	}
}

/** @returns {void} */
function update_slot(
	slot,
	slot_definition,
	ctx,
	$$scope,
	dirty,
	get_slot_changes_fn,
	get_slot_context_fn
) {
	const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
	update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
}

/** @returns {any[] | -1} */
function get_all_dirty_from_scope($$scope) {
	if ($$scope.ctx.length > 32) {
		const dirty = [];
		const length = $$scope.ctx.length / 32;
		for (let i = 0; i < length; i++) {
			dirty[i] = -1;
		}
		return dirty;
	}
	return -1;
}

/** @returns {{}} */
function exclude_internal_props(props) {
	const result = {};
	for (const k in props) if (k[0] !== '$') result[k] = props[k];
	return result;
}

/** @returns {{}} */
function compute_rest_props(props, keys) {
	const rest = {};
	keys = new Set(keys);
	for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];
	return rest;
}

/** @returns {{}} */
function compute_slots(slots) {
	const result = {};
	for (const key in slots) {
		result[key] = true;
	}
	return result;
}

/** @returns {(this: any, ...args: any[]) => void} */
function once(fn) {
	let ran = false;
	return function (...args) {
		if (ran) return;
		ran = true;
		fn.call(this, ...args);
	};
}

function null_to_empty(value) {
	return value == null ? '' : value;
}

function set_store_value(store, ret, value) {
	store.set(value);
	return ret;
}

const utils_has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

function action_destroyer(action_result) {
	return action_result && utils_is_function(action_result.destroy) ? action_result.destroy : utils_noop;
}

/** @param {number | string} value
 * @returns {[number, string]}
 */
function split_css_unit(value) {
	const split = typeof value === 'string' && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
	return split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];
}

const utils_contenteditable_truthy_values = (/* unused pure expression or super */ null && (['', true, 1, 'true', 'contenteditable']));

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/lifecycle.js


let lifecycle_current_component;

/** @returns {void} */
function lifecycle_set_current_component(component) {
	lifecycle_current_component = component;
}

function lifecycle_get_current_component() {
	if (!lifecycle_current_component) throw new Error('Function called outside component initialization');
	return lifecycle_current_component;
}

/**
 * Schedules a callback to run immediately before the component is updated after any state change.
 *
 * The first time the callback runs will be before the initial `onMount`
 *
 * https://svelte.dev/docs/svelte#beforeupdate
 * @param {() => any} fn
 * @returns {void}
 */
function beforeUpdate(fn) {
	lifecycle_get_current_component().$$.before_update.push(fn);
}

/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
 *
 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs/svelte#onmount
 * @template T
 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
 * @returns {void}
 */
function onMount(fn) {
	lifecycle_get_current_component().$$.on_mount.push(fn);
}

/**
 * Schedules a callback to run immediately after the component has been updated.
 *
 * The first time the callback runs will be after the initial `onMount`
 *
 * https://svelte.dev/docs/svelte#afterupdate
 * @param {() => any} fn
 * @returns {void}
 */
function afterUpdate(fn) {
	lifecycle_get_current_component().$$.after_update.push(fn);
}

/**
 * Schedules a callback to run immediately before the component is unmounted.
 *
 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
 * only one that runs inside a server-side component.
 *
 * https://svelte.dev/docs/svelte#ondestroy
 * @param {() => any} fn
 * @returns {void}
 */
function onDestroy(fn) {
	lifecycle_get_current_component().$$.on_destroy.push(fn);
}

/**
 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
 *
 * Component events created with `createEventDispatcher` create a
 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
 * property and can contain any type of data.
 *
 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
 * ```ts
 * const dispatch = createEventDispatcher<{
 *  loaded: never; // does not take a detail argument
 *  change: string; // takes a detail argument of type string, which is required
 *  optional: number | null; // takes an optional detail argument of type number
 * }>();
 * ```
 *
 * https://svelte.dev/docs/svelte#createeventdispatcher
 * @template {Record<string, any>} [EventMap=any]
 * @returns {import('./public.js').EventDispatcher<EventMap>}
 */
function createEventDispatcher() {
	const component = lifecycle_get_current_component();
	return (type, detail, { cancelable = false } = {}) => {
		const callbacks = component.$$.callbacks[type];
		if (callbacks) {
			// TODO are there situations where events could be dispatched
			// in a server (non-DOM) environment?
			const event = custom_event(/** @type {string} */ (type), detail, { cancelable });
			callbacks.slice().forEach((fn) => {
				fn.call(component, event);
			});
			return !event.defaultPrevented;
		}
		return true;
	};
}

/**
 * Associates an arbitrary `context` object with the current component and the specified `key`
 * and returns that object. The context is then available to children of the component
 * (including slotted content) with `getContext`.
 *
 * Like lifecycle functions, this must be called during component initialisation.
 *
 * https://svelte.dev/docs/svelte#setcontext
 * @template T
 * @param {any} key
 * @param {T} context
 * @returns {T}
 */
function setContext(key, context) {
	lifecycle_get_current_component().$$.context.set(key, context);
	return context;
}

/**
 * Retrieves the context that belongs to the closest parent component with the specified `key`.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs/svelte#getcontext
 * @template T
 * @param {any} key
 * @returns {T}
 */
function getContext(key) {
	return lifecycle_get_current_component().$$.context.get(key);
}

/**
 * Retrieves the whole context map that belongs to the closest parent component.
 * Must be called during component initialisation. Useful, for example, if you
 * programmatically create a component and want to pass the existing context to it.
 *
 * https://svelte.dev/docs/svelte#getallcontexts
 * @template {Map<any, any>} [T=Map<any, any>]
 * @returns {T}
 */
function getAllContexts() {
	return lifecycle_get_current_component().$$.context;
}

/**
 * Checks whether a given `key` has been set in the context of a parent component.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs/svelte#hascontext
 * @param {any} key
 * @returns {boolean}
 */
function hasContext(key) {
	return lifecycle_get_current_component().$$.context.has(key);
}

// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
/**
 * @param component
 * @param event
 * @returns {void}
 */
function bubble(component, event) {
	const callbacks = component.$$.callbacks[event.type];
	if (callbacks) {
		// @ts-ignore
		callbacks.slice().forEach((fn) => fn.call(this, event));
	}
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/scheduler.js



const dirty_components = [];
const intros = { enabled: false };
const binding_callbacks = [];

let render_callbacks = [];

const flush_callbacks = [];

const resolved_promise = /* @__PURE__ */ Promise.resolve();

let update_scheduled = false;

/** @returns {void} */
function schedule_update() {
	if (!update_scheduled) {
		update_scheduled = true;
		resolved_promise.then(scheduler_flush);
	}
}

/** @returns {Promise<void>} */
function tick() {
	schedule_update();
	return resolved_promise;
}

/** @returns {void} */
function scheduler_add_render_callback(fn) {
	render_callbacks.push(fn);
}

/** @returns {void} */
function add_flush_callback(fn) {
	flush_callbacks.push(fn);
}

// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();

let flushidx = 0; // Do *not* move this inside the flush() function

/** @returns {void} */
function scheduler_flush() {
	// Do not reenter flush while dirty components are updated, as this can
	// result in an infinite loop. Instead, let the inner flush handle it.
	// Reentrancy is ok afterwards for bindings etc.
	if (flushidx !== 0) {
		return;
	}
	const saved_component = lifecycle_current_component;
	do {
		// first, call beforeUpdate functions
		// and update components
		try {
			while (flushidx < dirty_components.length) {
				const component = dirty_components[flushidx];
				flushidx++;
				lifecycle_set_current_component(component);
				scheduler_update(component.$$);
			}
		} catch (e) {
			// reset dirty state to not end up in a deadlocked state and then rethrow
			dirty_components.length = 0;
			flushidx = 0;
			throw e;
		}
		lifecycle_set_current_component(null);
		dirty_components.length = 0;
		flushidx = 0;
		while (binding_callbacks.length) binding_callbacks.pop()();
		// then, once components are updated, call
		// afterUpdate functions. This may cause
		// subsequent updates...
		for (let i = 0; i < render_callbacks.length; i += 1) {
			const callback = render_callbacks[i];
			if (!seen_callbacks.has(callback)) {
				// ...so guard against infinite loops
				seen_callbacks.add(callback);
				callback();
			}
		}
		render_callbacks.length = 0;
	} while (dirty_components.length);
	while (flush_callbacks.length) {
		flush_callbacks.pop()();
	}
	update_scheduled = false;
	seen_callbacks.clear();
	lifecycle_set_current_component(saved_component);
}

/** @returns {void} */
function scheduler_update($$) {
	if ($$.fragment !== null) {
		$$.update();
		utils_run_all($$.before_update);
		const dirty = $$.dirty;
		$$.dirty = [-1];
		$$.fragment && $$.fragment.p($$.ctx, dirty);
		$$.after_update.forEach(scheduler_add_render_callback);
	}
}

/**
 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
 * @param {Function[]} fns
 * @returns {void}
 */
function flush_render_callbacks(fns) {
	const filtered = [];
	const targets = [];
	render_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));
	targets.forEach((c) => c());
	render_callbacks = filtered;
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/transitions.js







/**
 * @type {Promise<void> | null}
 */
let promise;

/**
 * @returns {Promise<void>}
 */
function wait() {
	if (!promise) {
		promise = Promise.resolve();
		promise.then(() => {
			promise = null;
		});
	}
	return promise;
}

/**
 * @param {Element} node
 * @param {INTRO | OUTRO | boolean} direction
 * @param {'start' | 'end'} kind
 * @returns {void}
 */
function dispatch(node, direction, kind) {
	node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}

const outroing = new Set();

/**
 * @type {Outro}
 */
let outros;

/**
 * @returns {void} */
function transitions_group_outros() {
	outros = {
		r: 0,
		c: [],
		p: outros // parent group
	};
}

/**
 * @returns {void} */
function transitions_check_outros() {
	if (!outros.r) {
		run_all(outros.c);
	}
	outros = outros.p;
}

/**
 * @param {import('./private.js').Fragment} block
 * @param {0 | 1} [local]
 * @returns {void}
 */
function transitions_transition_in(block, local) {
	if (block && block.i) {
		outroing.delete(block);
		block.i(local);
	}
}

/**
 * @param {import('./private.js').Fragment} block
 * @param {0 | 1} local
 * @param {0 | 1} [detach]
 * @param {() => void} [callback]
 * @returns {void}
 */
function transitions_transition_out(block, local, detach, callback) {
	if (block && block.o) {
		if (outroing.has(block)) return;
		outroing.add(block);
		outros.c.push(() => {
			outroing.delete(block);
			if (callback) {
				if (detach) block.d(1);
				callback();
			}
		});
		block.o(local);
	} else if (callback) {
		callback();
	}
}

/**
 * @type {import('../transition/public.js').TransitionConfig}
 */
const null_transition = { duration: 0 };

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {TransitionFn} fn
 * @param {any} params
 * @returns {{ start(): void; invalidate(): void; end(): void; }}
 */
function create_in_transition(node, fn, params) {
	/**
	 * @type {TransitionOptions} */
	const options = { direction: 'in' };
	let config = fn(node, params, options);
	let running = false;
	let animation_name;
	let task;
	let uid = 0;

	/**
	 * @returns {void} */
	function cleanup() {
		if (animation_name) delete_rule(node, animation_name);
	}

	/**
	 * @returns {void} */
	function go() {
		const {
			delay = 0,
			duration = 300,
			easing = linear,
			tick = noop,
			css
		} = config || null_transition;
		if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
		tick(0, 1);
		const start_time = now() + delay;
		const end_time = start_time + duration;
		if (task) task.abort();
		running = true;
		add_render_callback(() => dispatch(node, true, 'start'));
		task = loop((now) => {
			if (running) {
				if (now >= end_time) {
					tick(1, 0);
					dispatch(node, true, 'end');
					cleanup();
					return (running = false);
				}
				if (now >= start_time) {
					const t = easing((now - start_time) / duration);
					tick(t, 1 - t);
				}
			}
			return running;
		});
	}
	let started = false;
	return {
		start() {
			if (started) return;
			started = true;
			delete_rule(node);
			if (is_function(config)) {
				config = config(options);
				wait().then(go);
			} else {
				go();
			}
		},
		invalidate() {
			started = false;
		},
		end() {
			if (running) {
				cleanup();
				running = false;
			}
		}
	};
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {TransitionFn} fn
 * @param {any} params
 * @returns {{ end(reset: any): void; }}
 */
function create_out_transition(node, fn, params) {
	/** @type {TransitionOptions} */
	const options = { direction: 'out' };
	let config = fn(node, params, options);
	let running = true;
	let animation_name;
	const group = outros;
	group.r += 1;
	/** @type {boolean} */
	let original_inert_value;

	/**
	 * @returns {void} */
	function go() {
		const {
			delay = 0,
			duration = 300,
			easing = linear,
			tick = noop,
			css
		} = config || null_transition;

		if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);

		const start_time = now() + delay;
		const end_time = start_time + duration;
		add_render_callback(() => dispatch(node, false, 'start'));

		if ('inert' in node) {
			original_inert_value = /** @type {HTMLElement} */ (node).inert;
			node.inert = true;
		}

		loop((now) => {
			if (running) {
				if (now >= end_time) {
					tick(0, 1);
					dispatch(node, false, 'end');
					if (!--group.r) {
						// this will result in `end()` being called,
						// so we don't need to clean up here
						run_all(group.c);
					}
					return false;
				}
				if (now >= start_time) {
					const t = easing((now - start_time) / duration);
					tick(1 - t, t);
				}
			}
			return running;
		});
	}

	if (is_function(config)) {
		wait().then(() => {
			// @ts-ignore
			config = config(options);
			go();
		});
	} else {
		go();
	}

	return {
		end(reset) {
			if (reset && 'inert' in node) {
				node.inert = original_inert_value;
			}
			if (reset && config.tick) {
				config.tick(1, 0);
			}
			if (running) {
				if (animation_name) delete_rule(node, animation_name);
				running = false;
			}
		}
	};
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {TransitionFn} fn
 * @param {any} params
 * @param {boolean} intro
 * @returns {{ run(b: 0 | 1): void; end(): void; }}
 */
function create_bidirectional_transition(node, fn, params, intro) {
	/**
	 * @type {TransitionOptions} */
	const options = { direction: 'both' };
	let config = fn(node, params, options);
	let t = intro ? 0 : 1;

	/**
	 * @type {Program | null} */
	let running_program = null;

	/**
	 * @type {PendingProgram | null} */
	let pending_program = null;
	let animation_name = null;

	/** @type {boolean} */
	let original_inert_value;

	/**
	 * @returns {void} */
	function clear_animation() {
		if (animation_name) delete_rule(node, animation_name);
	}

	/**
	 * @param {PendingProgram} program
	 * @param {number} duration
	 * @returns {Program}
	 */
	function init(program, duration) {
		const d = /** @type {Program['d']} */ (program.b - t);
		duration *= Math.abs(d);
		return {
			a: t,
			b: program.b,
			d,
			duration,
			start: program.start,
			end: program.start + duration,
			group: program.group
		};
	}

	/**
	 * @param {INTRO | OUTRO} b
	 * @returns {void}
	 */
	function go(b) {
		const {
			delay = 0,
			duration = 300,
			easing = linear,
			tick = noop,
			css
		} = config || null_transition;

		/**
		 * @type {PendingProgram} */
		const program = {
			start: now() + delay,
			b
		};

		if (!b) {
			// @ts-ignore todo: improve typings
			program.group = outros;
			outros.r += 1;
		}

		if ('inert' in node) {
			if (b) {
				if (original_inert_value !== undefined) {
					// aborted/reversed outro — restore previous inert value
					node.inert = original_inert_value;
				}
			} else {
				original_inert_value = /** @type {HTMLElement} */ (node).inert;
				node.inert = true;
			}
		}

		if (running_program || pending_program) {
			pending_program = program;
		} else {
			// if this is an intro, and there's a delay, we need to do
			// an initial tick and/or apply CSS animation immediately
			if (css) {
				clear_animation();
				animation_name = create_rule(node, t, b, duration, delay, easing, css);
			}
			if (b) tick(0, 1);
			running_program = init(program, duration);
			add_render_callback(() => dispatch(node, b, 'start'));
			loop((now) => {
				if (pending_program && now > pending_program.start) {
					running_program = init(pending_program, duration);
					pending_program = null;
					dispatch(node, running_program.b, 'start');
					if (css) {
						clear_animation();
						animation_name = create_rule(
							node,
							t,
							running_program.b,
							running_program.duration,
							0,
							easing,
							config.css
						);
					}
				}
				if (running_program) {
					if (now >= running_program.end) {
						tick((t = running_program.b), 1 - t);
						dispatch(node, running_program.b, 'end');
						if (!pending_program) {
							// we're done
							if (running_program.b) {
								// intro — we can tidy up immediately
								clear_animation();
							} else {
								// outro — needs to be coordinated
								if (!--running_program.group.r) run_all(running_program.group.c);
							}
						}
						running_program = null;
					} else if (now >= running_program.start) {
						const p = now - running_program.start;
						t = running_program.a + running_program.d * easing(p / running_program.duration);
						tick(t, 1 - t);
					}
				}
				return !!(running_program || pending_program);
			});
		}
	}
	return {
		run(b) {
			if (is_function(config)) {
				wait().then(() => {
					const opts = { direction: b ? 'in' : 'out' };
					// @ts-ignore
					config = config(opts);
					go(b);
				});
			} else {
				go(b);
			}
		},
		end() {
			clear_animation();
			running_program = pending_program = null;
		}
	};
}

/** @typedef {1} INTRO */
/** @typedef {0} OUTRO */
/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

/**
 * @typedef {Object} Outro
 * @property {number} r
 * @property {Function[]} c
 * @property {Object} p
 */

/**
 * @typedef {Object} PendingProgram
 * @property {number} start
 * @property {INTRO|OUTRO} b
 * @property {Outro} [group]
 */

/**
 * @typedef {Object} Program
 * @property {number} a
 * @property {INTRO|OUTRO} b
 * @property {1|-1} d
 * @property {number} duration
 * @property {number} start
 * @property {number} end
 * @property {Outro} [group]
 */

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/await_block.js





/**
 * @template T
 * @param {Promise<T>} promise
 * @param {import('./private.js').PromiseInfo<T>} info
 * @returns {boolean}
 */
function handle_promise(promise, info) {
	const token = (info.token = {});
	/**
	 * @param {import('./private.js').FragmentFactory} type
	 * @param {0 | 1 | 2} index
	 * @param {number} [key]
	 * @param {any} [value]
	 * @returns {void}
	 */
	function update(type, index, key, value) {
		if (info.token !== token) return;
		info.resolved = value;
		let child_ctx = info.ctx;
		if (key !== undefined) {
			child_ctx = child_ctx.slice();
			child_ctx[key] = value;
		}
		const block = type && (info.current = type)(child_ctx);
		let needs_flush = false;
		if (info.block) {
			if (info.blocks) {
				info.blocks.forEach((block, i) => {
					if (i !== index && block) {
						group_outros();
						transition_out(block, 1, 1, () => {
							if (info.blocks[i] === block) {
								info.blocks[i] = null;
							}
						});
						check_outros();
					}
				});
			} else {
				info.block.d(1);
			}
			block.c();
			transition_in(block, 1);
			block.m(info.mount(), info.anchor);
			needs_flush = true;
		}
		info.block = block;
		if (info.blocks) info.blocks[index] = block;
		if (needs_flush) {
			flush();
		}
	}
	if (is_promise(promise)) {
		const current_component = get_current_component();
		promise.then(
			(value) => {
				set_current_component(current_component);
				update(info.then, 1, info.value, value);
				set_current_component(null);
			},
			(error) => {
				set_current_component(current_component);
				update(info.catch, 2, info.error, error);
				set_current_component(null);
				if (!info.hasCatch) {
					throw error;
				}
			}
		);
		// if we previously had a then/catch block, destroy it
		if (info.current !== info.pending) {
			update(info.pending, 0);
			return true;
		}
	} else {
		if (info.current !== info.then) {
			update(info.then, 1, info.value, promise);
			return true;
		}
		info.resolved = /** @type {T} */ (promise);
	}
}

/** @returns {void} */
function update_await_block_branch(info, ctx, dirty) {
	const child_ctx = ctx.slice();
	const { resolved } = info;
	if (info.current === info.then) {
		child_ctx[info.value] = resolved;
	}
	if (info.current === info.catch) {
		child_ctx[info.error] = resolved;
	}
	info.block.p(child_ctx, dirty);
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/each.js



// general each functions:

function each_ensure_array_like(array_like_or_iterator) {
	return array_like_or_iterator?.length !== undefined
		? array_like_or_iterator
		: Array.from(array_like_or_iterator);
}

// keyed each functions:

/** @returns {void} */
function destroy_block(block, lookup) {
	block.d(1);
	lookup.delete(block.key);
}

/** @returns {void} */
function outro_and_destroy_block(block, lookup) {
	transition_out(block, 1, 1, () => {
		lookup.delete(block.key);
	});
}

/** @returns {void} */
function fix_and_destroy_block(block, lookup) {
	block.f();
	destroy_block(block, lookup);
}

/** @returns {void} */
function fix_and_outro_and_destroy_block(block, lookup) {
	block.f();
	outro_and_destroy_block(block, lookup);
}

/** @returns {any[]} */
function update_keyed_each(
	old_blocks,
	dirty,
	get_key,
	dynamic,
	ctx,
	list,
	lookup,
	node,
	destroy,
	create_each_block,
	next,
	get_context
) {
	let o = old_blocks.length;
	let n = list.length;
	let i = o;
	const old_indexes = {};
	while (i--) old_indexes[old_blocks[i].key] = i;
	const new_blocks = [];
	const new_lookup = new Map();
	const deltas = new Map();
	const updates = [];
	i = n;
	while (i--) {
		const child_ctx = get_context(ctx, list, i);
		const key = get_key(child_ctx);
		let block = lookup.get(key);
		if (!block) {
			block = create_each_block(key, child_ctx);
			block.c();
		} else if (dynamic) {
			// defer updates until all the DOM shuffling is done
			updates.push(() => block.p(child_ctx, dirty));
		}
		new_lookup.set(key, (new_blocks[i] = block));
		if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
	}
	const will_move = new Set();
	const did_move = new Set();
	/** @returns {void} */
	function insert(block) {
		transition_in(block, 1);
		block.m(node, next);
		lookup.set(block.key, block);
		next = block.first;
		n--;
	}
	while (o && n) {
		const new_block = new_blocks[n - 1];
		const old_block = old_blocks[o - 1];
		const new_key = new_block.key;
		const old_key = old_block.key;
		if (new_block === old_block) {
			// do nothing
			next = new_block.first;
			o--;
			n--;
		} else if (!new_lookup.has(old_key)) {
			// remove old block
			destroy(old_block, lookup);
			o--;
		} else if (!lookup.has(new_key) || will_move.has(new_key)) {
			insert(new_block);
		} else if (did_move.has(old_key)) {
			o--;
		} else if (deltas.get(new_key) > deltas.get(old_key)) {
			did_move.add(new_key);
			insert(new_block);
		} else {
			will_move.add(old_key);
			o--;
		}
	}
	while (o--) {
		const old_block = old_blocks[o];
		if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
	}
	while (n) insert(new_blocks[n - 1]);
	run_all(updates);
	return new_blocks;
}

/** @returns {void} */
function validate_each_keys(ctx, list, get_context, get_key) {
	const keys = new Map();
	for (let i = 0; i < list.length; i++) {
		const key = get_key(get_context(ctx, list, i));
		if (keys.has(key)) {
			let value = '';
			try {
				value = `with value '${String(key)}' `;
			} catch (e) {
				// can't stringify
			}
			throw new Error(
				`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(
					key
				)} and ${i} ${value}are duplicates`
			);
		}
		keys.set(key, i);
	}
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/shared/boolean_attributes.js
const _boolean_attributes = /** @type {const} */ ([
	'allowfullscreen',
	'allowpaymentrequest',
	'async',
	'autofocus',
	'autoplay',
	'checked',
	'controls',
	'default',
	'defer',
	'disabled',
	'formnovalidate',
	'hidden',
	'inert',
	'ismap',
	'loop',
	'multiple',
	'muted',
	'nomodule',
	'novalidate',
	'open',
	'playsinline',
	'readonly',
	'required',
	'reversed',
	'selected'
]);

/**
 * List of HTML boolean attributes (e.g. `<input disabled>`).
 * Source: https://html.spec.whatwg.org/multipage/indices.html
 *
 * @type {Set<string>}
 */
const boolean_attributes_boolean_attributes = new Set([..._boolean_attributes]);

/** @typedef {typeof _boolean_attributes[number]} BooleanAttributes */

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/ssr.js






const invalid_attribute_name_character =
	/[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter

/** @returns {string} */
function spread(args, attrs_to_add) {
	const attributes = Object.assign({}, ...args);
	if (attrs_to_add) {
		const classes_to_add = attrs_to_add.classes;
		const styles_to_add = attrs_to_add.styles;
		if (classes_to_add) {
			if (attributes.class == null) {
				attributes.class = classes_to_add;
			} else {
				attributes.class += ' ' + classes_to_add;
			}
		}
		if (styles_to_add) {
			if (attributes.style == null) {
				attributes.style = style_object_to_string(styles_to_add);
			} else {
				attributes.style = style_object_to_string(
					merge_ssr_styles(attributes.style, styles_to_add)
				);
			}
		}
	}
	let str = '';
	Object.keys(attributes).forEach((name) => {
		if (invalid_attribute_name_character.test(name)) return;
		const value = attributes[name];
		if (value === true) str += ' ' + name;
		else if (boolean_attributes.has(name.toLowerCase())) {
			if (value) str += ' ' + name;
		} else if (value != null) {
			str += ` ${name}="${value}"`;
		}
	});
	return str;
}

/** @returns {{}} */
function merge_ssr_styles(style_attribute, style_directive) {
	const style_object = {};
	for (const individual_style of style_attribute.split(';')) {
		const colon_index = individual_style.indexOf(':');
		const name = individual_style.slice(0, colon_index).trim();
		const value = individual_style.slice(colon_index + 1).trim();
		if (!name) continue;
		style_object[name] = value;
	}
	for (const name in style_directive) {
		const value = style_directive[name];
		if (value) {
			style_object[name] = value;
		} else {
			delete style_object[name];
		}
	}
	return style_object;
}

const ATTR_REGEX = /[&"]/g;
const CONTENT_REGEX = /[&<]/g;

/**
 * Note: this method is performance sensitive and has been optimized
 * https://github.com/sveltejs/svelte/pull/5701
 * @param {unknown} value
 * @returns {string}
 */
function ssr_escape(value, is_attr = false) {
	const str = String(value);
	const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
	pattern.lastIndex = 0;
	let escaped = '';
	let last = 0;
	while (pattern.test(str)) {
		const i = pattern.lastIndex - 1;
		const ch = str[i];
		escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : ch === '"' ? '&quot;' : '&lt;');
		last = i + 1;
	}
	return escaped + str.substring(last);
}

function escape_attribute_value(value) {
	// keep booleans, null, and undefined for the sake of `spread`
	const should_escape = typeof value === 'string' || (value && typeof value === 'object');
	return should_escape ? ssr_escape(value, true) : value;
}

/** @returns {{}} */
function escape_object(obj) {
	const result = {};
	for (const key in obj) {
		result[key] = escape_attribute_value(obj[key]);
	}
	return result;
}

/** @returns {string} */
function each(items, fn) {
	items = ensure_array_like(items);
	let str = '';
	for (let i = 0; i < items.length; i += 1) {
		str += fn(items[i], i);
	}
	return str;
}

const missing_component = {
	$$render: () => ''
};

function validate_component(component, name) {
	if (!component || !component.$$render) {
		if (name === 'svelte:component') name += ' this={...}';
		throw new Error(
			`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`
		);
	}
	return component;
}

/** @returns {string} */
function debug(file, line, column, values) {
	console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
	console.log(values); // eslint-disable-line no-console
	return '';
}

let on_destroy;

/** @returns {{ render: (props?: {}, { $$slots, context }?: { $$slots?: {}; context?: Map<any, any>; }) => { html: any; css: { code: string; map: any; }; head: string; }; $$render: (result: any, props: any, bindings: any, slots: any, context: any) => any; }} */
function create_ssr_component(fn) {
	function $$render(result, props, bindings, slots, context) {
		const parent_component = current_component;
		const $$ = {
			on_destroy,
			context: new Map(context || (parent_component ? parent_component.$$.context : [])),
			// these will be immediately discarded
			on_mount: [],
			before_update: [],
			after_update: [],
			callbacks: blank_object()
		};
		set_current_component({ $$ });
		const html = fn(result, props, bindings, slots);
		set_current_component(parent_component);
		return html;
	}
	return {
		render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
			on_destroy = [];
			const result = { title: '', head: '', css: new Set() };
			const html = $$render(result, props, {}, $$slots, context);
			run_all(on_destroy);
			return {
				html,
				css: {
					code: Array.from(result.css)
						.map((css) => css.code)
						.join('\n'),
					map: null // TODO
				},
				head: result.title + result.head
			};
		},
		$$render
	};
}

/** @returns {string} */
function add_attribute(name, value, boolean) {
	if (value == null || (boolean && !value)) return '';
	const assignment = boolean && value === true ? '' : `="${ssr_escape(value, true)}"`;
	return ` ${name}${assignment}`;
}

/** @returns {string} */
function add_classes(classes) {
	return classes ? ` class="${classes}"` : '';
}

/** @returns {string} */
function style_object_to_string(style_object) {
	return Object.keys(style_object)
		.filter((key) => style_object[key])
		.map((key) => `${key}: ${escape_attribute_value(style_object[key])};`)
		.join(' ');
}

/** @returns {string} */
function add_styles(style_object) {
	const styles = style_object_to_string(style_object);
	return styles ? ` style="${styles}"` : '';
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/Component.js






/** @returns {void} */
function bind(component, name, callback) {
	const index = component.$$.props[name];
	if (index !== undefined) {
		component.$$.bound[index] = callback;
		callback(component.$$.ctx[index]);
	}
}

/** @returns {void} */
function create_component(block) {
	block && block.c();
}

/** @returns {void} */
function claim_component(block, parent_nodes) {
	block && block.l(parent_nodes);
}

/** @returns {void} */
function mount_component(component, target, anchor) {
	const { fragment, after_update } = component.$$;
	fragment && fragment.m(target, anchor);
	// onMount happens before the initial afterUpdate
	scheduler_add_render_callback(() => {
		const new_on_destroy = component.$$.on_mount.map(run).filter(utils_is_function);
		// if the component was destroyed immediately
		// it will update the `$$.on_destroy` reference to `null`.
		// the destructured on_destroy may still reference to the old array
		if (component.$$.on_destroy) {
			component.$$.on_destroy.push(...new_on_destroy);
		} else {
			// Edge case - component was destroyed immediately,
			// most likely as a result of a binding initialising
			utils_run_all(new_on_destroy);
		}
		component.$$.on_mount = [];
	});
	after_update.forEach(scheduler_add_render_callback);
}

/** @returns {void} */
function destroy_component(component, detaching) {
	const $$ = component.$$;
	if ($$.fragment !== null) {
		flush_render_callbacks($$.after_update);
		utils_run_all($$.on_destroy);
		$$.fragment && $$.fragment.d(detaching);
		// TODO null out other refs, including component.$$ (but need to
		// preserve final state?)
		$$.on_destroy = $$.fragment = null;
		$$.ctx = [];
	}
}

/** @returns {void} */
function make_dirty(component, i) {
	if (component.$$.dirty[0] === -1) {
		dirty_components.push(component);
		schedule_update();
		component.$$.dirty.fill(0);
	}
	component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
}

/** @returns {void} */
function init(
	component,
	options,
	instance,
	create_fragment,
	not_equal,
	props,
	append_styles,
	dirty = [-1]
) {
	const parent_component = lifecycle_current_component;
	lifecycle_set_current_component(component);
	/** @type {import('./private.js').T$$} */
	const $$ = (component.$$ = {
		fragment: null,
		ctx: [],
		// state
		props,
		update: utils_noop,
		not_equal,
		bound: utils_blank_object(),
		// lifecycle
		on_mount: [],
		on_destroy: [],
		on_disconnect: [],
		before_update: [],
		after_update: [],
		context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
		// everything else
		callbacks: utils_blank_object(),
		dirty,
		skip_bound: false,
		root: options.target || parent_component.$$.root
	});
	append_styles && append_styles($$.root);
	let ready = false;
	$$.ctx = instance
		? instance(component, options.props || {}, (i, ret, ...rest) => {
				const value = rest.length ? rest[0] : ret;
				if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
					if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
					if (ready) make_dirty(component, i);
				}
				return ret;
		  })
		: [];
	$$.update();
	ready = true;
	utils_run_all($$.before_update);
	// `false` as a special case of no DOM component
	$$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	if (options.target) {
		if (options.hydrate) {
			start_hydrating();
			const nodes = children(options.target);
			// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
			$$.fragment && $$.fragment.l(nodes);
			nodes.forEach(dom_detach);
		} else {
			// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
			$$.fragment && $$.fragment.c();
		}
		if (options.intro) transitions_transition_in(component.$$.fragment);
		mount_component(component, options.target, options.anchor);
		end_hydrating();
		scheduler_flush();
	}
	lifecycle_set_current_component(parent_component);
}

let SvelteElement;

if (typeof HTMLElement === 'function') {
	SvelteElement = class extends HTMLElement {
		$$componentCtor;
		$$slots;
		$$component;
		$$connected = false;
		$$data = {};
		$$reflecting = false;
		/** @type {Record<string, CustomElementPropDefinition>} */
		$$props_definition = {};
		/** @type {Record<string, Function[]>} */
		$$listeners = {};
		/** @type {Map<Function, Function>} */
		$$listener_unsubscribe_fns = new Map();

		constructor($$componentCtor, $$slots, use_shadow_dom) {
			super();
			this.$$componentCtor = $$componentCtor;
			this.$$slots = $$slots;
			if (use_shadow_dom) {
				this.attachShadow({ mode: 'open' });
			}
		}

		addEventListener(type, listener, options) {
			// We can't determine upfront if the event is a custom event or not, so we have to
			// listen to both. If someone uses a custom event with the same name as a regular
			// browser event, this fires twice - we can't avoid that.
			this.$$listeners[type] = this.$$listeners[type] || [];
			this.$$listeners[type].push(listener);
			if (this.$$component) {
				const unsub = this.$$component.$on(type, listener);
				this.$$listener_unsubscribe_fns.set(listener, unsub);
			}
			super.addEventListener(type, listener, options);
		}

		removeEventListener(type, listener, options) {
			super.removeEventListener(type, listener, options);
			if (this.$$component) {
				const unsub = this.$$listener_unsubscribe_fns.get(listener);
				if (unsub) {
					unsub();
					this.$$listener_unsubscribe_fns.delete(listener);
				}
			}
		}

		async connectedCallback() {
			this.$$connected = true;
			if (!this.$$component) {
				// We wait one tick to let possible child slot elements be created/mounted
				await Promise.resolve();
				if (!this.$$connected) {
					return;
				}
				function create_slot(name) {
					return () => {
						let node;
						const obj = {
							c: function create() {
								node = document.createElement('slot');
								if (name !== 'default') {
									node.setAttribute('name', name);
								}
							},
							/**
							 * @param {HTMLElement} target
							 * @param {HTMLElement} [anchor]
							 */
							m: function mount(target, anchor) {
								insert(target, node, anchor);
							},
							d: function destroy(detaching) {
								if (detaching) {
									dom_detach(node);
								}
							}
						};
						return obj;
					};
				}
				const $$slots = {};
				const existing_slots = get_custom_elements_slots(this);
				for (const name of this.$$slots) {
					if (name in existing_slots) {
						$$slots[name] = [create_slot(name)];
					}
				}
				for (const attribute of this.attributes) {
					// this.$$data takes precedence over this.attributes
					const name = this.$$get_prop_name(attribute.name);
					if (!(name in this.$$data)) {
						this.$$data[name] = get_custom_element_value(
							name,
							attribute.value,
							this.$$props_definition,
							'toProp'
						);
					}
				}
				this.$$component = new this.$$componentCtor({
					target: this.shadowRoot || this,
					props: {
						...this.$$data,
						$$slots,
						$$scope: {
							ctx: []
						}
					}
				});
				for (const type in this.$$listeners) {
					for (const listener of this.$$listeners[type]) {
						const unsub = this.$$component.$on(type, listener);
						this.$$listener_unsubscribe_fns.set(listener, unsub);
					}
				}
				this.$$listeners = {};
			}
		}

		// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
		// and setting attributes through setAttribute etc, this is helpful
		attributeChangedCallback(attr, _oldValue, newValue) {
			if (this.$$reflecting) return;
			attr = this.$$get_prop_name(attr);
			this.$$data[attr] = get_custom_element_value(
				attr,
				newValue,
				this.$$props_definition,
				'toProp'
			);
			this.$$component?.$set({ [attr]: this.$$data[attr] });
		}

		disconnectedCallback() {
			this.$$connected = false;
			// In a microtask, because this could be a move within the DOM
			Promise.resolve().then(() => {
				if (!this.$$connected) {
					this.$$component.$destroy();
					this.$$component = undefined;
				}
			});
		}

		$$get_prop_name(attribute_name) {
			return (
				Object.keys(this.$$props_definition).find(
					(key) =>
						this.$$props_definition[key].attribute === attribute_name ||
						(!this.$$props_definition[key].attribute && key.toLowerCase() === attribute_name)
				) || attribute_name
			);
		}
	};
}

/**
 * @param {string} prop
 * @param {any} value
 * @param {Record<string, CustomElementPropDefinition>} props_definition
 * @param {'toAttribute' | 'toProp'} [transform]
 */
function get_custom_element_value(prop, value, props_definition, transform) {
	const type = props_definition[prop]?.type;
	value = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;
	if (!transform || !props_definition[prop]) {
		return value;
	} else if (transform === 'toAttribute') {
		switch (type) {
			case 'Object':
			case 'Array':
				return value == null ? null : JSON.stringify(value);
			case 'Boolean':
				return value ? '' : null;
			case 'Number':
				return value == null ? null : value;
			default:
				return value;
		}
	} else {
		switch (type) {
			case 'Object':
			case 'Array':
				return value && JSON.parse(value);
			case 'Boolean':
				return value; // conversion already handled above
			case 'Number':
				return value != null ? +value : value;
			default:
				return value;
		}
	}
}

/**
 * @internal
 *
 * Turn a Svelte component into a custom element.
 * @param {import('./public.js').ComponentType} Component  A Svelte component constructor
 * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe
 * @param {string[]} slots  The slots to create
 * @param {string[]} accessors  Other accessors besides the ones for props the component has
 * @param {boolean} use_shadow_dom  Whether to use shadow DOM
 */
function create_custom_element(
	Component,
	props_definition,
	slots,
	accessors,
	use_shadow_dom
) {
	const Class = class extends SvelteElement {
		constructor() {
			super(Component, slots, use_shadow_dom);
			this.$$props_definition = props_definition;
		}
		static get observedAttributes() {
			return Object.keys(props_definition).map((key) =>
				(props_definition[key].attribute || key).toLowerCase()
			);
		}
	};
	Object.keys(props_definition).forEach((prop) => {
		Object.defineProperty(Class.prototype, prop, {
			get() {
				return this.$$component && prop in this.$$component
					? this.$$component[prop]
					: this.$$data[prop];
			},
			set(value) {
				value = get_custom_element_value(prop, value, props_definition);
				this.$$data[prop] = value;
				this.$$component?.$set({ [prop]: value });
				if (props_definition[prop].reflect) {
					this.$$reflecting = true;
					const attribute_value = get_custom_element_value(
						prop,
						value,
						props_definition,
						'toAttribute'
					);
					if (attribute_value == null) {
						this.removeAttribute(prop);
					} else {
						this.setAttribute(props_definition[prop].attribute || prop, attribute_value);
					}
					this.$$reflecting = false;
				}
			}
		});
	});
	accessors.forEach((accessor) => {
		Object.defineProperty(Class.prototype, accessor, {
			get() {
				return this.$$component?.[accessor];
			}
		});
	});
	Component.element = /** @type {any} */ (Class);
	return Class;
}

/**
 * Base class for Svelte components. Used when dev=false.
 *
 * @template {Record<string, any>} [Props=any]
 * @template {Record<string, any>} [Events=any]
 */
class SvelteComponent {
	/**
	 * ### PRIVATE API
	 *
	 * Do not use, may change at any time
	 *
	 * @type {any}
	 */
	$$ = undefined;
	/**
	 * ### PRIVATE API
	 *
	 * Do not use, may change at any time
	 *
	 * @type {any}
	 */
	$$set = undefined;

	/** @returns {void} */
	$destroy() {
		destroy_component(this, 1);
		this.$destroy = utils_noop;
	}

	/**
	 * @template {Extract<keyof Events, string>} K
	 * @param {K} type
	 * @param {((e: Events[K]) => void) | null | undefined} callback
	 * @returns {() => void}
	 */
	$on(type, callback) {
		if (!utils_is_function(callback)) {
			return utils_noop;
		}
		const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
		callbacks.push(callback);
		return () => {
			const index = callbacks.indexOf(callback);
			if (index !== -1) callbacks.splice(index, 1);
		};
	}

	/**
	 * @param {Partial<Props>} props
	 * @returns {void}
	 */
	$set(props) {
		if (this.$$set && !is_empty(props)) {
			this.$$.skip_bound = true;
			this.$$set(props);
			this.$$.skip_bound = false;
		}
	}
}

/**
 * @typedef {Object} CustomElementPropDefinition
 * @property {string} [attribute]
 * @property {boolean} [reflect]
 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
 */

;// CONCATENATED MODULE: ./node_modules/svelte/src/shared/version.js
// generated during release, do not modify

/**
 * The current version, as set in package.json.
 *
 * https://svelte.dev/docs/svelte-compiler#svelte-version
 * @type {string}
 */
const VERSION = '4.0.0';
const PUBLIC_VERSION = '4';

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/dev.js







/**
 * @template T
 * @param {string} type
 * @param {T} [detail]
 * @returns {void}
 */
function dispatch_dev(type, detail) {
	document.dispatchEvent(dom_custom_event(type, { version: VERSION, ...detail }, { bubbles: true }));
}

/**
 * @param {Node} target
 * @param {Node} node
 * @returns {void}
 */
function append_dev(target, node) {
	dispatch_dev('SvelteDOMInsert', { target, node });
	append(target, node);
}

/**
 * @param {Node} target
 * @param {Node} node
 * @returns {void}
 */
function append_hydration_dev(target, node) {
	dispatch_dev('SvelteDOMInsert', { target, node });
	append_hydration(target, node);
}

/**
 * @param {Node} target
 * @param {Node} node
 * @param {Node} [anchor]
 * @returns {void}
 */
function insert_dev(target, node, anchor) {
	dispatch_dev('SvelteDOMInsert', { target, node, anchor });
	insert(target, node, anchor);
}

/** @param {Node} target
 * @param {Node} node
 * @param {Node} [anchor]
 * @returns {void}
 */
function insert_hydration_dev(target, node, anchor) {
	dispatch_dev('SvelteDOMInsert', { target, node, anchor });
	insert_hydration(target, node, anchor);
}

/**
 * @param {Node} node
 * @returns {void}
 */
function detach_dev(node) {
	dispatch_dev('SvelteDOMRemove', { node });
	dom_detach(node);
}

/**
 * @param {Node} before
 * @param {Node} after
 * @returns {void}
 */
function detach_between_dev(before, after) {
	while (before.nextSibling && before.nextSibling !== after) {
		detach_dev(before.nextSibling);
	}
}

/**
 * @param {Node} after
 * @returns {void}
 */
function detach_before_dev(after) {
	while (after.previousSibling) {
		detach_dev(after.previousSibling);
	}
}

/**
 * @param {Node} before
 * @returns {void}
 */
function detach_after_dev(before) {
	while (before.nextSibling) {
		detach_dev(before.nextSibling);
	}
}

/**
 * @param {Node} node
 * @param {string} event
 * @param {EventListenerOrEventListenerObject} handler
 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
 * @param {boolean} [has_prevent_default]
 * @param {boolean} [has_stop_propagation]
 * @param {boolean} [has_stop_immediate_propagation]
 * @returns {() => void}
 */
function listen_dev(
	node,
	event,
	handler,
	options,
	has_prevent_default,
	has_stop_propagation,
	has_stop_immediate_propagation
) {
	const modifiers =
		options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
	if (has_prevent_default) modifiers.push('preventDefault');
	if (has_stop_propagation) modifiers.push('stopPropagation');
	if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');
	dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
	const dispose = listen(node, event, handler, options);
	return () => {
		dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
		dispose();
	};
}

/**
 * @param {Element} node
 * @param {string} attribute
 * @param {string} [value]
 * @returns {void}
 */
function attr_dev(node, attribute, value) {
	attr(node, attribute, value);
	if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
	else dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
}

/**
 * @param {Element} node
 * @param {string} property
 * @param {any} [value]
 * @returns {void}
 */
function prop_dev(node, property, value) {
	node[property] = value;
	dispatch_dev('SvelteDOMSetProperty', { node, property, value });
}

/**
 * @param {HTMLElement} node
 * @param {string} property
 * @param {any} [value]
 * @returns {void}
 */
function dataset_dev(node, property, value) {
	node.dataset[property] = value;
	dispatch_dev('SvelteDOMSetDataset', { node, property, value });
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data_dev(text, data) {
	data = '' + data;
	if (text.data === data) return;
	dispatch_dev('SvelteDOMSetData', { node: text, data });
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data_contenteditable_dev(text, data) {
	data = '' + data;
	if (text.wholeText === data) return;
	dispatch_dev('SvelteDOMSetData', { node: text, data });
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @param {string} attr_value
 * @returns {void}
 */
function set_data_maybe_contenteditable_dev(text, data, attr_value) {
	if (~contenteditable_truthy_values.indexOf(attr_value)) {
		set_data_contenteditable_dev(text, data);
	} else {
		set_data_dev(text, data);
	}
}

function ensure_array_like_dev(arg) {
	if (
		typeof arg !== 'string' &&
		!(arg && typeof arg === 'object' && 'length' in arg) &&
		!(typeof Symbol === 'function' && arg && Symbol.iterator in arg)
	) {
		throw new Error('{#each} only works with iterable values.');
	}
	return each_ensure_array_like(arg);
}

/**
 * @returns {void} */
function validate_slots(name, slot, keys) {
	for (const slot_key of Object.keys(slot)) {
		if (!~keys.indexOf(slot_key)) {
			console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
		}
	}
}

/**
 * @param {unknown} tag
 * @returns {void}
 */
function validate_dynamic_element(tag) {
	const is_string = typeof tag === 'string';
	if (tag && !is_string) {
		throw new Error('<svelte:element> expects "this" attribute to be a string.');
	}
}

/**
 * @param {undefined | string} tag
 * @returns {void}
 */
function validate_void_dynamic_element(tag) {
	if (tag && is_void(tag)) {
		console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
	}
}

function construct_svelte_component_dev(component, props) {
	const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
	try {
		const instance = new component(props);
		if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
			throw new Error(error_message);
		}
		return instance;
	} catch (err) {
		const { message } = err;
		if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
			throw new Error(error_message);
		} else {
			throw err;
		}
	}
}

/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 *
 * Can be used to create strongly typed Svelte components.
 *
 * #### Example:
 *
 * You have component library on npm called `component-library`, from which
 * you export a component called `MyComponent`. For Svelte+TypeScript users,
 * you want to provide typings. Therefore you create a `index.d.ts`:
 * ```ts
 * import { SvelteComponent } from "svelte";
 * export class MyComponent extends SvelteComponent<{foo: string}> {}
 * ```
 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
 * to provide intellisense and to use the component like this in a Svelte file
 * with TypeScript:
 * ```svelte
 * <script lang="ts">
 * 	import { MyComponent } from "component-library";
 * </script>
 * <MyComponent foo={'bar'} />
 * ```
 * @template {Record<string, any>} [Props=any]
 * @template {Record<string, any>} [Events=any]
 * @template {Record<string, any>} [Slots=any]
 * @extends {SvelteComponent<Props, Events>}
 */
class SvelteComponentDev extends SvelteComponent {
	/**
	 * For type checking capabilities only.
	 * Does not exist at runtime.
	 * ### DO NOT USE!
	 *
	 * @type {Props}
	 */
	$$prop_def;
	/**
	 * For type checking capabilities only.
	 * Does not exist at runtime.
	 * ### DO NOT USE!
	 *
	 * @type {Events}
	 */
	$$events_def;
	/**
	 * For type checking capabilities only.
	 * Does not exist at runtime.
	 * ### DO NOT USE!
	 *
	 * @type {Slots}
	 */
	$$slot_def;

	/** @param {import('./public.js').ComponentConstructorOptions<Props>} options */
	constructor(options) {
		if (!options || (!options.target && !options.$$inline)) {
			throw new Error("'target' is a required option");
		}
		super();
	}

	/** @returns {void} */
	$destroy() {
		super.$destroy();
		this.$destroy = () => {
			console.warn('Component was already destroyed'); // eslint-disable-line no-console
		};
	}

	/** @returns {void} */
	$capture_state() {}

	/** @returns {void} */
	$inject_state() {}
}
/**
 * @template {Record<string, any>} [Props=any]
 * @template {Record<string, any>} [Events=any]
 * @template {Record<string, any>} [Slots=any]
 * @deprecated Use `SvelteComponent` instead. See PR for more information: https://github.com/sveltejs/svelte/pull/8512
 * @extends {SvelteComponentDev<Props, Events, Slots>}
 */
class SvelteComponentTyped extends (/* unused pure expression or super */ null && (SvelteComponentDev)) {}

/** @returns {() => void} */
function loop_guard(timeout) {
	const start = Date.now();
	return () => {
		if (Date.now() - start > timeout) {
			throw new Error('Infinite loop detected');
		}
	};
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/index.js
















;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/disclose-version/index.js


if (typeof window !== 'undefined')
	// @ts-ignore
	(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/index.js


;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/store/index.js


const subscriber_queue = [];

/**
 * Creates a `Readable` store that allows reading by subscription.
 *
 * https://svelte.dev/docs/svelte-store#readable
 * @template T
 * @param {T} [value] initial value
 * @param {import('./public.js').StartStopNotifier<T>} [start]
 * @returns {import('./public.js').Readable<T>}
 */
function readable(value, start) {
	return {
		subscribe: writable(value, start).subscribe
	};
}

/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 *
 * https://svelte.dev/docs/svelte-store#writable
 * @template T
 * @param {T} [value] initial value
 * @param {import('./public.js').StartStopNotifier<T>} [start]
 * @returns {import('./public.js').Writable<T>}
 */
function writable(value, start = utils_noop) {
	/** @type {import('./public.js').Unsubscriber} */
	let stop;
	/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
	const subscribers = new Set();
	/** @param {T} new_value
	 * @returns {void}
	 */
	function set(new_value) {
		if (safe_not_equal(value, new_value)) {
			value = new_value;
			if (stop) {
				// store is ready
				const run_queue = !subscriber_queue.length;
				for (const subscriber of subscribers) {
					subscriber[1]();
					subscriber_queue.push(subscriber, value);
				}
				if (run_queue) {
					for (let i = 0; i < subscriber_queue.length; i += 2) {
						subscriber_queue[i][0](subscriber_queue[i + 1]);
					}
					subscriber_queue.length = 0;
				}
			}
		}
	}

	/**
	 * @param {import('./public.js').Updater<T>} fn
	 * @returns {void}
	 */
	function update(fn) {
		set(fn(value));
	}

	/**
	 * @param {import('./public.js').Subscriber<T>} run
	 * @param {import('./private.js').Invalidator<T>} [invalidate]
	 * @returns {import('./public.js').Unsubscriber}
	 */
	function subscribe(run, invalidate = utils_noop) {
		/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
		const subscriber = [run, invalidate];
		subscribers.add(subscriber);
		if (subscribers.size === 1) {
			stop = start(set, update) || utils_noop;
		}
		run(value);
		return () => {
			subscribers.delete(subscriber);
			if (subscribers.size === 0 && stop) {
				stop();
				stop = null;
			}
		};
	}
	return { set, update, subscribe };
}

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 *
 * https://svelte.dev/docs/svelte-store#derived
 * @template {import('./private.js').Stores} S
 * @template T
 * @overload
 * @param {S} stores - input stores
 * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values
 * @param {T} [initial_value] - initial value
 * @returns {import('./public.js').Readable<T>}
 */

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 *
 * https://svelte.dev/docs/svelte-store#derived
 * @template {import('./private.js').Stores} S
 * @template T
 * @overload
 * @param {S} stores - input stores
 * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values
 * @param {T} [initial_value] - initial value
 * @returns {import('./public.js').Readable<T>}
 */

/**
 * @template {import('./private.js').Stores} S
 * @template T
 * @param {S} stores
 * @param {Function} fn
 * @param {T} [initial_value]
 * @returns {import('./public.js').Readable<T>}
 */
function derived(stores, fn, initial_value) {
	const single = !Array.isArray(stores);
	/** @type {Array<import('./public.js').Readable<any>>} */
	const stores_array = single ? [stores] : stores;
	if (!stores_array.every(Boolean)) {
		throw new Error('derived() expects stores as input, got a falsy value');
	}
	const auto = fn.length < 2;
	return readable(initial_value, (set, update) => {
		let started = false;
		const values = [];
		let pending = 0;
		let cleanup = noop;
		const sync = () => {
			if (pending) {
				return;
			}
			cleanup();
			const result = fn(single ? values[0] : values, set, update);
			if (auto) {
				set(result);
			} else {
				cleanup = is_function(result) ? result : noop;
			}
		};
		const unsubscribers = stores_array.map((store, i) =>
			subscribe(
				store,
				(value) => {
					values[i] = value;
					pending &= ~(1 << i);
					if (started) {
						sync();
					}
				},
				() => {
					pending |= 1 << i;
				}
			)
		);
		started = true;
		sync();
		return function stop() {
			run_all(unsubscribers);
			cleanup();
			// We need to set this to false because callbacks can still happen despite having unsubscribed:
			// Callbacks might already be placed in the queue which doesn't know it should no longer
			// invoke this derived store.
			started = false;
		};
	});
}

/**
 * Takes a store and returns a new one derived from the old one that is readable.
 *
 * https://svelte.dev/docs/svelte-store#readonly
 * @template T
 * @param {import('./public.js').Readable<T>} store  - store to make readonly
 * @returns {import('./public.js').Readable<T>}
 */
function readonly(store) {
	return {
		subscribe: store.subscribe.bind(store)
	};
}



;// CONCATENATED MODULE: ./src/store.ts

let gallery_open = writable(true);
let floating_modal_message = writable(undefined);

;// CONCATENATED MODULE: ./node_modules/@0b5vr/experimental/dist/0b5vr-experimental.esm.js
/*!
* @0b5vr/experimental v0.9.5
* Experimental edition of 0b5vr
*
* Copyright (c) 2019-2023 0b5vr
* @0b5vr/experimental is distributed under MIT License
* https://github.com/0b5vr/experimental-npm/blob/release/LICENSE
*/
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/algorithm/binarySearch.ts
function binarySearch(array, elementOrCompare) {
  if (typeof elementOrCompare !== "function") {
    return binarySearch(array, (element) => element < elementOrCompare);
  }
  const compare = elementOrCompare;
  let start = 0;
  let end = array.length;
  while (start < end) {
    const center = start + end >> 1;
    const centerElement = array[center];
    const compareResult = compare(centerElement);
    if (compareResult) {
      start = center + 1;
    } else {
      end = center;
    }
  }
  return start;
}

// src/algorithm/traverse.ts
function traverse(root, traverser) {
  const nodesNeedProcess = [root];
  const nodesSeen = new Set(nodesNeedProcess);
  while (nodesNeedProcess.length > 0) {
    const currentNode = nodesNeedProcess.shift();
    const children = traverser(currentNode);
    if (!children) {
      break;
    }
    const nodesFound = children.filter((node) => !nodesSeen.has(node));
    nodesNeedProcess.unshift(...nodesFound);
    nodesFound.map((node) => nodesSeen.add(node));
  }
}

// src/array/arrayRange.ts
function arrayRange(start, end, step) {
  let current = start;
  const ret = [];
  if (start < end) {
    step = step != null ? step : 1;
    while (current < end) {
      ret.push(current);
      current += step;
    }
  } else {
    step = step != null ? step : -1;
    while (current > end) {
      ret.push(current);
      current += step;
    }
  }
  return ret;
}

// src/array/arraySerial.ts
var arraySerial = (count) => [...Array(count)].map((_, i) => i);

// src/array/arraySet.ts
function arraySetDelete(array, value) {
  const index = array.indexOf(value);
  if (index === -1) {
    return false;
  }
  array.splice(index, 1);
  return true;
}
function arraySetHas(array, value) {
  return array.indexOf(value) !== -1;
}
function arraySetAdd(array, value) {
  const index = array.indexOf(value);
  if (index !== -1) {
    return false;
  }
  array.push(value);
  return true;
}
function arraySetUnion(a, b) {
  const out = [...a];
  b.forEach((v) => {
    if (!arraySetHas(out, v)) {
      out.push(v);
    }
  });
  return out;
}
function arraySetDiff(from, diff) {
  const out = [...from];
  diff.forEach((v) => {
    arraySetDelete(out, v);
  });
  return out;
}

// src/array/constants.ts
var TRIANGLE_STRIP_QUAD = (/* unused pure expression or super */ null && ([-1, -1, 1, -1, -1, 1, 1, 1]));
var TRIANGLE_STRIP_QUAD_3D = (/* unused pure expression or super */ null && ([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]));
var TRIANGLE_STRIP_QUAD_NORMAL = (/* unused pure expression or super */ null && ([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]));
var TRIANGLE_STRIP_QUAD_UV = (/* unused pure expression or super */ null && ([0, 0, 1, 0, 0, 1, 1, 1]));

// src/array/utils.ts
function shuffleArray(array, dice) {
  const f = dice ? dice : () => Math.random();
  for (let i = 0; i < array.length - 1; i++) {
    const ir = i + Math.floor(f() * (array.length - i));
    const temp = array[ir];
    array[ir] = array[i];
    array[i] = temp;
  }
  return array;
}
function triIndexToLineIndex(array) {
  const ret = [];
  for (let i = 0; i < array.length / 3; i++) {
    const head = i * 3;
    ret.push(array[head], array[head + 1], array[head + 1], array[head + 2], array[head + 2], array[head]);
  }
  return ret;
}
function matrix2d(w, h) {
  const arr = [];
  for (let iy = 0; iy < h; iy++) {
    for (let ix = 0; ix < w; ix++) {
      arr.push(ix, iy);
    }
  }
  return arr;
}
function matrix3d(w, h, d) {
  const arr = [];
  for (let iz = 0; iz < d; iz++) {
    for (let iy = 0; iy < h; iy++) {
      for (let ix = 0; ix < w; ix++) {
        arr.push(ix, iy, iz);
      }
    }
  }
  return arr;
}

// src/CDS/CDS.ts
var CDS = class {
  constructor() {
    this.factor = 100;
    this.ratio = 1;
    this.velocity = 0;
    this.value = 0;
    this.target = 0;
  }
  update(deltaTime) {
    this.velocity += (-this.factor * (this.value - this.target) - 2 * this.velocity * Math.sqrt(this.factor) * this.ratio) * deltaTime;
    this.value += this.velocity * deltaTime;
    return this.value;
  }
};

// src/Clock/Clock.ts
var Clock = class {
  constructor() {
    this.__time = 0;
    this.__deltaTime = 0;
    this.__isPlaying = false;
  }
  get time() {
    return this.__time;
  }
  get deltaTime() {
    return this.__deltaTime;
  }
  get isPlaying() {
    return this.__isPlaying;
  }
  update(time) {
    const prevTime = this.__time;
    this.__time = time || 0;
    this.__deltaTime = this.__time - prevTime;
  }
  play() {
    this.__isPlaying = true;
  }
  pause() {
    this.__isPlaying = false;
  }
  setTime(time) {
    this.__time = time;
  }
};

// src/Clock/ClockFrame.ts
var ClockFrame = class extends (/* unused pure expression or super */ null && (Clock)) {
  constructor(fps = 60) {
    super();
    this.__frame = 0;
    this.__fps = fps;
  }
  get frame() {
    return this.__frame;
  }
  get fps() {
    return this.__fps;
  }
  update() {
    if (this.__isPlaying) {
      this.__time = this.__frame / this.__fps;
      this.__deltaTime = 1 / this.__fps;
      this.__frame++;
    } else {
      this.__deltaTime = 0;
    }
  }
  setTime(time) {
    this.__frame = Math.floor(this.__fps * time);
    this.__time = this.__frame / this.__fps;
  }
};

// src/Clock/ClockRealtime.ts
var ClockRealtime = class extends (/* unused pure expression or super */ null && (Clock)) {
  constructor() {
    super(...arguments);
    this.__rtTime = 0;
    this.__rtDate = performance.now();
  }
  get isRealtime() {
    return true;
  }
  update() {
    const now = performance.now();
    if (this.__isPlaying) {
      const prevTime = this.__time;
      const deltaDate = now - this.__rtDate;
      this.__time = this.__rtTime + deltaDate / 1e3;
      this.__deltaTime = this.time - prevTime;
    } else {
      this.__rtTime = this.time;
      this.__rtDate = now;
      this.__deltaTime = 0;
    }
  }
  setTime(time) {
    this.__time = time;
    this.__rtTime = this.time;
    this.__rtDate = performance.now();
  }
};

// src/color/colorFromAtariST.ts
function colorFromAtariST(stColor) {
  return [
    (stColor >> 8 & 7) / 7,
    (stColor >> 4 & 7) / 7,
    (stColor & 7) / 7
  ];
}

// src/math/utils.ts
function lerp(a, b, x) {
  return a + (b - a) * x;
}
function clamp(x, l, h) {
  return Math.min(Math.max(x, l), h);
}
function saturate(x) {
  return clamp(x, 0, 1);
}
function range(x, x0, x1, y0, y1) {
  return (x - x0) * (y1 - y0) / (x1 - x0) + y0;
}
function linearstep(a, b, x) {
  return saturate((x - a) / (b - a));
}
function smoothstep(a, b, x) {
  const t = linearstep(a, b, x);
  return t * t * (3 - 2 * t);
}
function smootherstep(a, b, x) {
  const t = linearstep(a, b, x);
  return t * t * t * (t * (t * 6 - 15) + 10);
}
function smootheststep(a, b, x) {
  const t = linearstep(a, b, x);
  return t * t * t * t * (t * (t * (-20 * t + 70) - 84) + 35);
}

// src/color/colorHSV2RGB.ts
function colorHSV2RGB([h, s, v]) {
  const ht = h % 1 * 6;
  return [0, 4, 2].map((p) => {
    const colH = Math.min(Math.max(Math.abs((ht + p) % 6 - 3) - 1, 0), 1);
    const colS = lerp(1, colH, s);
    return v * colS;
  });
}

// src/color/colorToHex.ts
function colorToHex(color) {
  return "#" + color.map((v) => ("0" + Math.round(saturate(v) * 255).toString(16)).slice(-2)).join("");
}

// src/math/vec/vecDot.ts
function vecDot(vecA, vecB) {
  return vecA.reduce((sum, v, i) => sum + v * vecB[i], 0);
}

// src/color/colorTurbo.ts
function colorTurbo(x) {
  const kr = [
    0.13572138,
    4.6153926,
    -42.66032258,
    132.13108234,
    -152.94239396,
    59.28637943
  ];
  const kg = [
    0.09140261,
    2.19418839,
    4.84296658,
    -14.18503333,
    4.27729857,
    2.82956604
  ];
  const kb = [
    0.1066733,
    12.64194608,
    -60.58204836,
    110.36276771,
    -89.90310912,
    27.34824973
  ];
  const xt = saturate(x);
  const xv = [
    1,
    xt,
    xt * xt,
    xt * xt * xt,
    xt * xt * xt * xt,
    xt * xt * xt * xt * xt
  ];
  const col = [
    saturate(vecDot(kr, xv)),
    saturate(vecDot(kg, xv)),
    saturate(vecDot(kb, xv))
  ];
  return col;
}

// src/color/eotfRec709.ts
function eotfRec709(value) {
  return value.map((v) => v < 0.081 ? v / 4.5 : Math.pow((v + 0.099) / 1.099, 1 / 0.45));
}

// src/color/oetfRec709.ts
function oetfRec709(luminance) {
  return luminance.map((l) => l < 0.018 ? 4.5 * l : 1.099 * Math.pow(l, 0.45) - 0.099);
}

// src/dag/dagEdgesParents.ts
function dagEdgesParents(edges, destination) {
  return edges.filter((edge) => edge[1] === destination).map((edge) => edge[0]);
}

// src/dag/dagEdgesAncestors.ts
function dagEdgesAncestors(edges, destination) {
  const ancestors = /* @__PURE__ */ new Set();
  traverse(destination, (node) => {
    const parents = dagEdgesParents(edges, node);
    parents.map((parent) => ancestors.add(parent));
    return parents;
  });
  return Array.from(ancestors);
}

// src/dag/dagEdgesChildren.ts
function dagEdgesChildren(edges, source) {
  return edges.filter((edge) => edge[0] === source).map((edge) => edge[1]);
}

// src/dag/dagEdgesDescendants.ts
function dagEdgesDescendants(edges, source) {
  const descendants = /* @__PURE__ */ new Set();
  traverse(source, (node) => {
    const children = dagEdgesChildren(edges, node);
    children.map((child) => descendants.add(child));
    return children;
  });
  return Array.from(descendants);
}

// src/dag/dagEdgesParent.ts
function dagEdgesParent(edges, destination) {
  var _a, _b;
  return (_b = (_a = edges.find((edge) => edge[1] === destination)) == null ? void 0 : _a[0]) != null ? _b : null;
}

// src/dag/dagEdgesResolve.ts
function dagEdgesResolve(edges, nodes) {
  const order = [];
  const nodeSet = new Set(nodes);
  let tempEdges = edges.concat();
  while (tempEdges.length > 0) {
    nodeSet.forEach((node) => {
      const hasParents = dagEdgesParent(tempEdges, node) != null;
      if (!hasParents) {
        nodeSet.delete(node);
        order.push(node);
        tempEdges = tempEdges.filter(([src]) => src !== node);
      }
    });
  }
  return order.concat(Array.from(nodeSet));
}

// src/edt/edt.ts
function edt1d(data, offset, stride, length) {
  let k = 0;
  const v = new Float32Array(length);
  v[0] = 0;
  const z = new Float32Array(length + 1);
  z[0] = -Infinity;
  z[1] = Infinity;
  const f = new Float32Array(length);
  for (let q = 0; q < length; q++) {
    f[q] = data[offset + q * stride];
  }
  for (let q = 1; q < length; q++) {
    let s = 0;
    while (0 <= k) {
      s = (f[q] + q * q - f[v[k]] - v[k] * v[k]) / (2 * q - 2 * v[k]);
      if (s <= z[k]) {
        k--;
      } else {
        break;
      }
    }
    k++;
    v[k] = q;
    z[k] = s;
    z[k + 1] = Infinity;
  }
  k = 0;
  for (let q = 0; q < length; q++) {
    while (z[k + 1] < q) {
      k++;
    }
    const qSubVK = q - v[k];
    data[offset + q * stride] = f[v[k]] + qSubVK * qSubVK;
  }
}
function edt2d(data, width, height) {
  for (let x = 0; x < width; x++) {
    edt1d(data, x, width, height);
  }
  for (let y = 0; y < height; y++) {
    edt1d(data, y * width, 1, width);
  }
}

// src/ExpSmooth/ExpSmooth.ts
var ExpSmooth = class {
  constructor() {
    this.factor = 10;
    this.target = 0;
    this.value = 0;
  }
  update(deltaTime) {
    this.value = lerp(this.target, this.value, Math.exp(-this.factor * deltaTime));
    return this.value;
  }
};

// src/Pool/Pool.ts
var Pool = class {
  constructor(array) {
    this.index = 0;
    this.array = array;
  }
  get current() {
    return this.array[this.index];
  }
  next() {
    this.index = (this.index + 1) % this.array.length;
    return this.current;
  }
};

// src/GPUTimer/GPUTimer.ts
var GPUTimer = class {
  static isSupported(gl) {
    return new Set(gl.getSupportedExtensions()).has("EXT_disjoint_timer_query_webgl2");
  }
  constructor(gl) {
    this.gl = gl;
    const queries = new Array(1024).fill(1).map(() => gl.createQuery());
    this.queries = new Pool(queries);
    this.stack = [];
    this.ext = gl.getExtension("EXT_disjoint_timer_query_webgl2");
    this.__loopTasks = /* @__PURE__ */ new Set();
    const update = () => {
      this.update();
      requestAnimationFrame(update);
    };
    update();
  }
  update() {
    Array.from(this.__loopTasks).forEach((task) => task());
  }
  measure(func) {
    return __async(this, null, function* () {
      const { gl } = this;
      if (this.stack.length !== 0) {
        gl.endQuery(this.ext.TIME_ELAPSED_EXT);
        const promiseFinishingPrev = this.check(this.queries.current);
        this.stack = this.stack.map((promiseAccum2) => __async(this, null, function* () {
          return (yield promiseAccum2) + (yield promiseFinishingPrev);
        }));
      }
      this.stack.push(Promise.resolve(0));
      gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.queries.next());
      func();
      gl.endQuery(this.ext.TIME_ELAPSED_EXT);
      const promiseAccum = this.stack.pop();
      const promiseThis = this.check(this.queries.current);
      if (this.stack.length !== 0) {
        this.stack = this.stack.map((promiseAccum2) => __async(this, null, function* () {
          return (yield promiseAccum2) + (yield promiseThis);
        }));
        gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.queries.next());
      }
      return (yield promiseAccum) + (yield promiseThis);
    });
  }
  check(query) {
    const { gl } = this;
    return new Promise((resolve) => {
      const task = () => {
        const isAvailable = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);
        if (isAvailable) {
          this.__loopTasks.delete(task);
          resolve(gl.getQueryParameter(query, gl.QUERY_RESULT) * 1e-3 * 1e-3);
        }
      };
      this.__loopTasks.add(task);
    });
  }
};

// src/HistoryMeanCalculator/HistoryMeanCalculator.ts
var HistoryMeanCalculator = class {
  constructor(length) {
    this.__recalcForEach = 0;
    this.__countUntilRecalc = 0;
    this.__history = [];
    this.__index = 0;
    this.__count = 0;
    this.__cache = 0;
    this.__length = length;
    this.__recalcForEach = length;
    for (let i = 0; i < length; i++) {
      this.__history[i] = 0;
    }
  }
  get mean() {
    const count = Math.min(this.__count, this.__length);
    return count === 0 ? 0 : this.__cache / count;
  }
  get recalcForEach() {
    return this.__recalcForEach;
  }
  set recalcForEach(value) {
    const delta = value - this.__recalcForEach;
    this.__recalcForEach = value;
    this.__countUntilRecalc = Math.max(0, this.__countUntilRecalc + delta);
  }
  reset() {
    this.__index = 0;
    this.__count = 0;
    this.__cache = 0;
    this.__countUntilRecalc = 0;
    for (let i = 0; i < this.__length; i++) {
      this.__history[i] = 0;
    }
  }
  push(value) {
    const prev = this.__history[this.__index];
    this.__history[this.__index] = value;
    this.__count++;
    this.__index = (this.__index + 1) % this.__length;
    if (this.__countUntilRecalc === 0) {
      this.recalc();
    } else {
      this.__countUntilRecalc--;
      this.__cache -= prev;
      this.__cache += value;
    }
  }
  recalc() {
    this.__countUntilRecalc = this.__recalcForEach;
    const sum = this.__history.slice(0, Math.min(this.__count, this.__length)).reduce((sum2, v) => sum2 + v, 0);
    this.__cache = sum;
  }
};

// src/HistoryMeanCalculator/HistoryPercentileCalculator.ts
var HistoryPercentileCalculator = class {
  constructor(length) {
    this.__history = [];
    this.__sorted = [];
    this.__index = 0;
    this.__length = length;
  }
  get median() {
    return this.percentile(50);
  }
  percentile(percentile) {
    if (this.__history.length === 0) {
      return 0;
    }
    return this.__sorted[Math.round(percentile * 0.01 * (this.__history.length - 1))];
  }
  reset() {
    this.__index = 0;
    this.__history = [];
    this.__sorted = [];
  }
  push(value) {
    const prev = this.__history[this.__index];
    this.__history[this.__index] = value;
    this.__index = (this.__index + 1) % this.__length;
    if (this.__sorted.length === this.__length) {
      const prevIndex = binarySearch(this.__sorted, prev);
      this.__sorted.splice(prevIndex, 1);
    }
    const index = binarySearch(this.__sorted, value);
    this.__sorted.splice(index, 0, value);
  }
};

// src/HistoryMeanCalculator/HistoryMedianCalculator.ts
var HistoryMedianCalculator = class extends (/* unused pure expression or super */ null && (HistoryPercentileCalculator)) {
  constructor(length) {
    super(length);
    console.warn("HistoryMedianCalculator: Deprecated. Use HistoryPercentileCalculator instead");
  }
};

// src/MapOfSet/MapOfSet.ts
var MapOfSet = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    var _a;
    return (_a = this.map.get(key)) != null ? _a : /* @__PURE__ */ new Set();
  }
  add(key, value) {
    let set = this.map.get(key);
    if (set == null) {
      set = /* @__PURE__ */ new Set();
      this.map.set(key, set);
    }
    set.add(value);
  }
};

// src/math/vec/vecAbs.ts
function vecAbs(vec) {
  return vec.map((v) => Math.abs(v));
}

// src/math/vec/vecAdd.ts
function vecAdd(...vecs) {
  if (vecs.length < 2) {
    return vecs[0];
  }
  const a = vecs.shift();
  const b = vecAdd(...vecs);
  return a.map((v, i) => v + b[i]);
}

// src/math/vec/vecDivide.ts
function vecDivide(vecA, vecB) {
  return vecA.map((v, i) => v / vecB[i]);
}

// src/math/vec/vecLength.ts
function vecLength(vec) {
  return Math.sqrt(vec.reduce((sum, v) => sum + v * v, 0));
}

// src/math/vec/vecLengthSq.ts
function vecLengthSq(vec) {
  return vec.reduce((sum, v) => sum + v * v, 0);
}

// src/math/vec/vecManhattanLength.ts
function vecManhattanLength(vec) {
  return vec.reduce((sum, v) => sum + Math.abs(v), 0);
}

// src/math/vec/vecMultiply.ts
function vecMultiply(...vecs) {
  if (vecs.length < 2) {
    return vecs[0];
  }
  const a = vecs.shift();
  const b = vecMultiply(...vecs);
  return a.map((v, i) => v * b[i]);
}

// src/math/vec/vecNeg.ts
function vecNeg(vec) {
  return vec.map((v) => -v);
}

// src/math/vec/vecScale.ts
function vecScale(vec, scalar) {
  return vec.map((v) => v * scalar);
}

// src/math/vec/vecNormalize.ts
function vecNormalize(vec) {
  const len = vecLength(vec);
  const invLen = len === 0 ? 0 : 1 / len;
  return vecScale(vec, invLen);
}

// src/math/vec/vecSub.ts
function vecSub(vecA, vecB) {
  return vecA.map((v, i) => v - vecB[i]);
}

// src/math/vec/Vector.ts
var Vector = class {
  get length() {
    return vecLength(this.elements);
  }
  get lengthSq() {
    return vecLengthSq(this.elements);
  }
  get manhattanLength() {
    return vecManhattanLength(this.elements);
  }
  get normalized() {
    return this.__new(vecNormalize(this.elements));
  }
  get negated() {
    return this.__new(vecNeg(this.elements));
  }
  get abs() {
    return this.__new(vecAbs(this.elements));
  }
  clone() {
    return this.__new(this.elements.concat());
  }
  add(...vectors) {
    return this.__new(vecAdd(this.elements, ...vectors.map((v) => v.elements)));
  }
  sub(vector) {
    return this.__new(vecSub(this.elements, vector.elements));
  }
  multiply(...vectors) {
    return this.__new(vecMultiply(this.elements, ...vectors.map((v) => v.elements)));
  }
  divide(vector) {
    return this.__new(vecDivide(this.elements, vector.elements));
  }
  scale(scalar) {
    return this.__new(vecScale(this.elements, scalar));
  }
  dot(vector) {
    return vecDot(this.elements, vector.elements);
  }
};

// src/math/vec4/vec4ApplyMatrix4.ts
function vec4ApplyMatrix4(v, m) {
  return [
    m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3],
    m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3],
    m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3],
    m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3]
  ];
}

// src/math/vec3/vec3ApplyMatrix4.ts
function vec3ApplyMatrix4(v, m) {
  const vec4 = vec4ApplyMatrix4([...v, 1], m);
  const xyz = [vec4[0], vec4[1], vec4[2]];
  const w = vec4[3];
  return vecScale(xyz, 1 / w);
}

// src/math/quat/quatInverse.ts
function quatInverse(quat) {
  return [-quat[0], -quat[1], -quat[2], quat[3]];
}

// src/math/quat/quatMultiply.ts
function quatMultiply(...quats) {
  if (quats.length < 2) {
    return quats[0];
  }
  const a = quats.shift();
  const b = quatMultiply(...quats);
  return [
    a[3] * b[0] + a[0] * b[3] + a[1] * b[2] - a[2] * b[1],
    a[3] * b[1] - a[0] * b[2] + a[1] * b[3] + a[2] * b[0],
    a[3] * b[2] + a[0] * b[1] - a[1] * b[0] + a[2] * b[3],
    a[3] * b[3] - a[0] * b[0] - a[1] * b[1] - a[2] * b[2]
  ];
}

// src/math/vec3/vec3ApplyQuaternion.ts
function vec3ApplyQuaternion(vec, quat) {
  const p = [...vec, 0];
  const r = quatInverse(quat);
  const res = quatMultiply(quat, p, r);
  res.pop();
  return res;
}

// src/math/vec3/vec3Cross.ts
function vec3Cross(vecA, vecB) {
  return [
    vecA[1] * vecB[2] - vecA[2] * vecB[1],
    vecA[2] * vecB[0] - vecA[0] * vecB[2],
    vecA[0] * vecB[1] - vecA[1] * vecB[0]
  ];
}

// src/math/vec3/vec3OrthoNormalize.ts
function vec3OrthoNormalize(normal, tangent = [0, 1, 0], binormal) {
  const n = vecNormalize(normal);
  let t = vecNormalize(tangent);
  let dotNT = vecDot(n, t);
  if (dotNT === 1) {
    if (Math.abs(n[1]) > Math.abs(n[2])) {
      t = [0, 0, 1];
    } else {
      t = [0, 1, 0];
    }
    dotNT = vecDot(n, t);
  }
  t = vecNormalize(vecSub(t, vecScale(n, dotNT)));
  let b = vec3Cross(t, n);
  if (binormal && vecDot(b, binormal) < 0) {
    b = vecNeg(b);
  }
  return {
    normal: n,
    tangent: t,
    binormal: b
  };
}

// src/math/vec3/Vector3.ts
var Vector3 = class extends (/* unused pure expression or super */ null && (Vector)) {
  constructor(v = [0, 0, 0]) {
    super();
    this.elements = v;
  }
  get x() {
    return this.elements[0];
  }
  set x(x) {
    this.elements[0] = x;
  }
  get y() {
    return this.elements[1];
  }
  set y(y) {
    this.elements[1] = y;
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
  }
  toString() {
    return `Vector3( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)} )`;
  }
  cross(vector) {
    return new Vector3(vec3Cross(this.elements, vector.elements));
  }
  applyQuaternion(quaternion) {
    return new Vector3(vec3ApplyQuaternion(this.elements, quaternion.elements));
  }
  applyMatrix4(matrix) {
    return new Vector3(vec3ApplyMatrix4(this.elements, matrix.elements));
  }
  __new(v) {
    return new Vector3(v);
  }
  static get zero() {
    return new Vector3([0, 0, 0]);
  }
  static get px() {
    return new Vector3([1, 0, 0]);
  }
  static get nx() {
    return new Vector3([-1, 0, 0]);
  }
  static get py() {
    return new Vector3([0, 1, 0]);
  }
  static get ny() {
    return new Vector3([0, -1, 0]);
  }
  static get pz() {
    return new Vector3([0, 0, 1]);
  }
  static get nz() {
    return new Vector3([0, 0, -1]);
  }
  static get one() {
    return new Vector3([1, 1, 1]);
  }
  static orthoNormalize(normal, tangent, binormal) {
    const result = vec3OrthoNormalize(normal.elements, tangent.elements, binormal.elements);
    return {
      normal: new Vector3(result.normal),
      tangent: new Vector3(result.tangent),
      binormal: new Vector3(result.binormal)
    };
  }
};

// src/math/box3/box3ContainsPoint.ts
function box3ContainsPoint(box, point) {
  return box[0][0] <= point[0] && box[1][0] >= point[0] && box[0][1] <= point[1] && box[1][1] >= point[1] && box[0][2] <= point[2] && box[1][2] >= point[2];
}

// src/math/box3/Box3.ts
var Box3 = class {
  constructor(min = Vector3.zero, max = Vector3.zero) {
    this.min = min;
    this.max = max;
  }
  get raw() {
    return [this.min.elements, this.max.elements];
  }
  containsPoint(point) {
    return box3ContainsPoint(this.raw, point.elements);
  }
  static fromRaw(box) {
    return new Box3(new Vector3(box[0]), new Vector3(box[1]));
  }
};

// src/math/mat3/mat3FromMat4Transpose.ts
function mat3FromMat4Transpose(source) {
  return [
    source[0],
    source[4],
    source[8],
    source[1],
    source[5],
    source[9],
    source[2],
    source[6],
    source[10]
  ];
}

// src/math/mat3/mat3Inverse.ts
function mat3Inverse(m) {
  const n11 = m[0], n21 = m[1], n31 = m[2], n12 = m[3], n22 = m[4], n32 = m[5], n13 = m[6], n23 = m[7], n33 = m[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
  if (det === 0) {
    return vecScale(m, 0);
  }
  return vecScale([
    t11,
    n31 * n23 - n33 * n21,
    n32 * n21 - n31 * n22,
    t12,
    n33 * n11 - n31 * n13,
    n31 * n12 - n32 * n11,
    t13,
    n21 * n13 - n23 * n11,
    n22 * n11 - n21 * n12
  ], 1 / det);
}

// src/math/mat3/mat3CreateNormalMatrix.ts
function mat3CreateNormalMatrix(m) {
  return mat3Inverse(mat3FromMat4Transpose(m));
}

// src/math/mat3/mat3Determinant.ts
function mat3Determinant(m) {
  const n11 = m[0], n21 = m[1], n31 = m[2], n12 = m[3], n22 = m[4], n32 = m[5], n13 = m[6], n23 = m[7], n33 = m[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13;
  return n11 * t11 + n21 * t12 + n31 * t13;
}

// src/math/mat3/mat3FromMat4.ts
function mat3FromMat4(source) {
  return [
    source[0],
    source[1],
    source[2],
    source[4],
    source[5],
    source[6],
    source[8],
    source[9],
    source[10]
  ];
}

// src/math/mat3/mat3FromQuaternion.ts
function mat3FromQuaternion(quat) {
  const x = quat[0];
  const y = quat[1];
  const z = quat[2];
  const w = quat[3];
  return [
    1 - 2 * y * y - 2 * z * z,
    2 * x * y + 2 * z * w,
    2 * x * z - 2 * y * w,
    2 * x * y - 2 * z * w,
    1 - 2 * x * x - 2 * z * z,
    2 * y * z + 2 * x * w,
    2 * x * z + 2 * y * w,
    2 * y * z - 2 * x * w,
    1 - 2 * x * x - 2 * y * y
  ];
}

// src/math/mat3/mat3Multiply.ts
function mat3Multiply(...mats) {
  if (mats.length < 2) {
    return mats[0];
  }
  const a = mats.shift();
  const b = mat3Multiply(...mats);
  const a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];
  return [
    a00 * b00 + a10 * b01 + a20 * b02,
    a01 * b00 + a11 * b01 + a21 * b02,
    a02 * b00 + a12 * b01 + a22 * b02,
    a00 * b10 + a10 * b11 + a20 * b12,
    a01 * b10 + a11 * b11 + a21 * b12,
    a02 * b10 + a12 * b11 + a22 * b12,
    a00 * b20 + a10 * b21 + a20 * b22,
    a01 * b20 + a11 * b21 + a21 * b22,
    a02 * b20 + a12 * b21 + a22 * b22
  ];
}

// src/math/mat3/mat3Transpose.ts
function mat3Transpose(source) {
  return [
    source[0],
    source[3],
    source[6],
    source[1],
    source[4],
    source[7],
    source[2],
    source[5],
    source[8]
  ];
}

// src/math/mat3/Matrix3.ts
var rawIdentityMatrix3 = (/* unused pure expression or super */ null && ([
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1
]));
var Matrix3 = class {
  constructor(v = rawIdentityMatrix3) {
    this.elements = v;
  }
  get transpose() {
    return new Matrix3(mat3Transpose(this.elements));
  }
  get determinant() {
    return mat3Determinant(this.elements);
  }
  get inverse() {
    return new Matrix3(mat3Inverse(this.elements));
  }
  get matrix4() {
    return Matrix4.fromMatrix3(this);
  }
  toString() {
    const m = this.elements.map((v) => v.toFixed(3));
    return `Matrix3( ${m[0]}, ${m[3]}, ${m[6]}; ${m[1]}, ${m[4]}, ${m[7]}; ${m[2]}, ${m[5]}, ${m[8]} )`;
  }
  clone() {
    return new Matrix3(this.elements.concat());
  }
  multiply(...matrices) {
    return Matrix3.multiply(this, ...matrices);
  }
  scaleScalar(scalar) {
    return new Matrix3(vecScale(this.elements, scalar));
  }
  static get identity() {
    return new Matrix3(rawIdentityMatrix3);
  }
  static multiply(...matrices) {
    if (matrices.length === 0) {
      return Matrix3.identity;
    } else {
      return new Matrix3(mat3Multiply(...matrices.map((m) => m.elements)));
    }
  }
  static createNormalMatrix(matrix4) {
    return new Matrix3(mat3CreateNormalMatrix(matrix4.elements));
  }
  static fromMatrix4(matrix4) {
    return new Matrix3(mat3FromMat4(matrix4.elements));
  }
  static fromQuaternion(quaternion) {
    return new Matrix3(mat3FromQuaternion(quaternion.elements));
  }
};

// src/math/mat4/mat4FromQuaternion.ts
function mat4FromQuaternion(quat) {
  const x = quat[0];
  const y = quat[1];
  const z = quat[2];
  const w = quat[3];
  return [
    1 - 2 * y * y - 2 * z * z,
    2 * x * y + 2 * z * w,
    2 * x * z - 2 * y * w,
    0,
    2 * x * y - 2 * z * w,
    1 - 2 * x * x - 2 * z * z,
    2 * y * z + 2 * x * w,
    0,
    2 * x * z + 2 * y * w,
    2 * y * z - 2 * x * w,
    1 - 2 * x * x - 2 * y * y,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Compose.ts
function mat4Compose(position, rotation, scale) {
  const matRot = mat4FromQuaternion(rotation);
  const sx = scale[0], sy = scale[1], sz = scale[2];
  return [
    matRot[0] * sx,
    matRot[1] * sx,
    matRot[2] * sx,
    0,
    matRot[4] * sy,
    matRot[5] * sy,
    matRot[6] * sy,
    0,
    matRot[8] * sz,
    matRot[9] * sz,
    matRot[10] * sz,
    0,
    position[0],
    position[1],
    position[2],
    1
  ];
}

// src/math/mat4/mat4Determinant.ts
function mat4Determinant(m) {
  const a00 = m[0], a01 = m[1], a02 = m[2], a03 = m[3], a10 = m[4], a11 = m[5], a12 = m[6], a13 = m[7], a20 = m[8], a21 = m[9], a22 = m[10], a23 = m[11], a30 = m[12], a31 = m[13], a32 = m[14], a33 = m[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

// src/math/quat/quatFromMatrix3.ts
function quatFromMatrix3(m) {
  const m11 = m[0], m12 = m[3], m13 = m[6], m21 = m[1], m22 = m[4], m23 = m[7], m31 = m[2], m32 = m[5], m33 = m[8], trace = m11 + m22 + m33;
  if (trace > 0) {
    const s = 0.5 / Math.sqrt(trace + 1);
    return [
      (m32 - m23) * s,
      (m13 - m31) * s,
      (m21 - m12) * s,
      0.25 / s
    ];
  } else if (m11 > m22 && m11 > m33) {
    const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
    return [
      0.25 * s,
      (m12 + m21) / s,
      (m13 + m31) / s,
      (m32 - m23) / s
    ];
  } else if (m22 > m33) {
    const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
    return [
      (m12 + m21) / s,
      0.25 * s,
      (m23 + m32) / s,
      (m13 - m31) / s
    ];
  } else {
    const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
    return [
      (m13 + m31) / s,
      (m23 + m32) / s,
      0.25 * s,
      (m21 - m12) / s
    ];
  }
}

// src/math/quat/quatFromMatrix4.ts
function quatFromMatrix4(m) {
  return quatFromMatrix3(mat3FromMat4(m));
}

// src/math/mat4/mat4Decompose.ts
function mat4Decompose(m) {
  let sx = vecLength([m[0], m[1], m[2]]);
  const sy = vecLength([m[4], m[5], m[6]]);
  const sz = vecLength([m[8], m[9], m[10]]);
  const det = mat4Determinant(m);
  if (det < 0) {
    sx = -sx;
  }
  const invSx = 1 / sx;
  const invSy = 1 / sy;
  const invSz = 1 / sz;
  const rotationMatrix = m.concat();
  rotationMatrix[0] *= invSx;
  rotationMatrix[1] *= invSx;
  rotationMatrix[2] *= invSx;
  rotationMatrix[4] *= invSy;
  rotationMatrix[5] *= invSy;
  rotationMatrix[6] *= invSy;
  rotationMatrix[8] *= invSz;
  rotationMatrix[9] *= invSz;
  rotationMatrix[10] *= invSz;
  return {
    position: [m[12], m[13], m[14]],
    scale: [sx, sy, sz],
    rotation: quatFromMatrix4(rotationMatrix)
  };
}

// src/math/mat4/mat4FromMat3.ts
function mat4FromMat3(source) {
  return [
    source[0],
    source[1],
    source[2],
    0,
    source[3],
    source[4],
    source[5],
    0,
    source[6],
    source[7],
    source[8],
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Inverse.ts
function mat4Inverse(m) {
  const a00 = m[0], a01 = m[1], a02 = m[2], a03 = m[3], a10 = m[4], a11 = m[5], a12 = m[6], a13 = m[7], a20 = m[8], a21 = m[9], a22 = m[10], a23 = m[11], a30 = m[12], a31 = m[13], a32 = m[14], a33 = m[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
  const det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (det === 0) {
    return vecScale(m, 0);
  }
  return vecScale([
    a11 * b11 - a12 * b10 + a13 * b09,
    a02 * b10 - a01 * b11 - a03 * b09,
    a31 * b05 - a32 * b04 + a33 * b03,
    a22 * b04 - a21 * b05 - a23 * b03,
    a12 * b08 - a10 * b11 - a13 * b07,
    a00 * b11 - a02 * b08 + a03 * b07,
    a32 * b02 - a30 * b05 - a33 * b01,
    a20 * b05 - a22 * b02 + a23 * b01,
    a10 * b10 - a11 * b08 + a13 * b06,
    a01 * b08 - a00 * b10 - a03 * b06,
    a30 * b04 - a31 * b02 + a33 * b00,
    a21 * b02 - a20 * b04 - a23 * b00,
    a11 * b07 - a10 * b09 - a12 * b06,
    a00 * b09 - a01 * b07 + a02 * b06,
    a31 * b01 - a30 * b03 - a32 * b00,
    a20 * b03 - a21 * b01 + a22 * b00
  ], 1 / det);
}

// src/math/mat4/mat4LookAt.ts
function mat4LookAt(position, target = [0, 0, 0], up = [0, 1, 0], roll = 0) {
  const dir = vecNormalize(vecSub(position, target));
  let sid = vecNormalize(vec3Cross(up, dir));
  if (roll !== 0) {
    sid = vecAdd(vecScale(sid, Math.cos(roll)), vecScale(vec3Cross(dir, sid), Math.sin(roll)));
  }
  const top = vec3Cross(dir, sid);
  return [
    sid[0],
    sid[1],
    sid[2],
    0,
    top[0],
    top[1],
    top[2],
    0,
    dir[0],
    dir[1],
    dir[2],
    0,
    position[0],
    position[1],
    position[2],
    1
  ];
}

// src/math/mat4/mat4LookAtInverse.ts
function mat4LookAtInverse(position, target = [0, 0, 0], up = [0, 1, 0], roll = 0) {
  const dir = vecNormalize(vecSub(position, target));
  let sid = vecNormalize(vec3Cross(up, dir));
  if (roll !== 0) {
    sid = vecAdd(vecScale(sid, Math.cos(roll)), vecScale(vec3Cross(dir, sid), Math.sin(roll)));
  }
  const top = vec3Cross(dir, sid);
  return [
    sid[0],
    top[0],
    dir[0],
    0,
    sid[1],
    top[1],
    dir[1],
    0,
    sid[2],
    top[2],
    dir[2],
    0,
    -vecDot(sid, position),
    -vecDot(top, position),
    -vecDot(dir, position),
    1
  ];
}

// src/math/mat4/mat4Multiply.ts
function mat4Multiply(...mats) {
  if (mats.length < 2) {
    return mats[0];
  }
  const a = mats.shift();
  const b = mat4Multiply(...mats);
  const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3], b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7], b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11], b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];
  return [
    a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03,
    a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03,
    a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03,
    a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03,
    a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13,
    a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13,
    a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13,
    a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13,
    a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23,
    a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23,
    a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23,
    a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23,
    a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33,
    a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33,
    a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33,
    a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33
  ];
}

// src/math/mat4/mat4Perspective.ts
function mat4Perspective(fov = 45, near = 0.01, far = 100, aspect = 1) {
  const p = 1 / Math.tan(fov * Math.PI / 360);
  const d = far - near;
  return [
    p / aspect,
    0,
    0,
    0,
    0,
    p,
    0,
    0,
    0,
    0,
    -(far + near) / d,
    -1,
    0,
    0,
    -2 * far * near / d,
    0
  ];
}

// src/math/mat4/mat4RotationX.ts
function mat4RotationX(theta) {
  const c = Math.cos(theta);
  const s = Math.sin(theta);
  return [
    1,
    0,
    0,
    0,
    0,
    c,
    -s,
    0,
    0,
    s,
    c,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4RotationY.ts
function mat4RotationY(theta) {
  const c = Math.cos(theta);
  const s = Math.sin(theta);
  return [
    c,
    0,
    s,
    0,
    0,
    1,
    0,
    0,
    -s,
    0,
    c,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4RotationZ.ts
function mat4RotationZ(theta) {
  const c = Math.cos(theta);
  const s = Math.sin(theta);
  return [
    c,
    -s,
    0,
    0,
    s,
    c,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Scale.ts
function mat4Scale(vec) {
  return [
    vec[0],
    0,
    0,
    0,
    0,
    vec[1],
    0,
    0,
    0,
    0,
    vec[2],
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4ScaleScalar.ts
function mat4ScaleScalar(scalar) {
  return [
    scalar,
    0,
    0,
    0,
    0,
    scalar,
    0,
    0,
    0,
    0,
    scalar,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Translate.ts
function mat4Translate(vec) {
  return [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    vec[0],
    vec[1],
    vec[2],
    1
  ];
}

// src/math/mat4/mat4Transpose.ts
function mat4Transpose(m) {
  return [
    m[0],
    m[4],
    m[8],
    m[12],
    m[1],
    m[5],
    m[9],
    m[13],
    m[2],
    m[6],
    m[10],
    m[14],
    m[3],
    m[7],
    m[11],
    m[15]
  ];
}

// src/math/mat4/Matrix4.ts
var rawIdentityMatrix4 = (/* unused pure expression or super */ null && ([
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
]));
var Matrix4 = class {
  constructor(v = rawIdentityMatrix4) {
    this.elements = v;
  }
  get transpose() {
    return new Matrix4(mat4Transpose(this.elements));
  }
  get determinant() {
    return mat4Determinant(this.elements);
  }
  get inverse() {
    return new Matrix4(mat4Inverse(this.elements));
  }
  get matrix3() {
    return Matrix3.fromMatrix4(this);
  }
  get normalMatrix() {
    return Matrix3.createNormalMatrix(this);
  }
  toString() {
    const m = this.elements.map((v) => v.toFixed(3));
    return `Matrix4( ${m[0]}, ${m[4]}, ${m[8]}, ${m[12]}; ${m[1]}, ${m[5]}, ${m[9]}, ${m[13]}; ${m[2]}, ${m[6]}, ${m[10]}, ${m[14]}; ${m[3]}, ${m[7]}, ${m[11]}, ${m[15]} )`;
  }
  clone() {
    return new Matrix4(this.elements.concat());
  }
  multiply(...matrices) {
    return Matrix4.multiply(this, ...matrices);
  }
  scaleScalar(scalar) {
    return new Matrix4(vecScale(this.elements, scalar));
  }
  decompose() {
    const { position, scale, rotation } = mat4Decompose(this.elements);
    return {
      position: new Vector3(position),
      scale: new Vector3(scale),
      rotation: new Quaternion(rotation)
    };
  }
  static get identity() {
    return new Matrix4(rawIdentityMatrix4);
  }
  static multiply(...matrices) {
    if (matrices.length === 0) {
      return Matrix4.identity;
    } else {
      return new Matrix4(mat4Multiply(...matrices.map((m) => m.elements)));
    }
  }
  static fromQuaternion(quaternion) {
    return new Matrix4(mat4FromQuaternion(quaternion.elements));
  }
  static fromMatrix3(matrix3) {
    return new Matrix4(mat4FromMat3(matrix3.elements));
  }
  static translate(vector) {
    return new Matrix4(mat4Translate(vector.elements));
  }
  static scale(vector) {
    return new Matrix4(mat4Scale(vector.elements));
  }
  static scaleScalar(scalar) {
    return new Matrix4(mat4ScaleScalar(scalar));
  }
  static rotationX(theta) {
    return new Matrix4(mat4RotationX(theta));
  }
  static rotationY(theta) {
    return new Matrix4(mat4RotationY(theta));
  }
  static rotationZ(theta) {
    return new Matrix4(mat4RotationZ(theta));
  }
  static lookAt(position, target = new Vector3([0, 0, 0]), up = new Vector3([0, 1, 0]), roll = 0) {
    return new Matrix4(mat4LookAt(position.elements, target.elements, up.elements, roll));
  }
  static lookAtInverse(position, target = new Vector3([0, 0, 0]), up = new Vector3([0, 1, 0]), roll = 0) {
    return new Matrix4(mat4LookAtInverse(position.elements, target.elements, up.elements, roll));
  }
  static perspective(fov = 45, near = 0.01, far = 100) {
    return new Matrix4(mat4Perspective(fov, near, far));
  }
  static compose(position, rotation, scale) {
    return new Matrix4(mat4Compose(position.elements, rotation.elements, scale.elements));
  }
};

// src/math/quat/quatFromAxisAngle.ts
function quatFromAxisAngle(axis, angle) {
  const halfAngle = angle / 2;
  const sinHalfAngle = Math.sin(halfAngle);
  return [
    axis[0] * sinHalfAngle,
    axis[1] * sinHalfAngle,
    axis[2] * sinHalfAngle,
    Math.cos(halfAngle)
  ];
}

// src/math/quat/quatLookRotation.ts
function quatLookRotation(look, up) {
  const { normal, tangent, binormal } = vec3OrthoNormalize(look, up != null ? up : [0, 1, 0]);
  const w = Math.sqrt(1 + binormal[0] + tangent[1] + normal[2]) * 0.5;
  const invW4 = 0.25 / w;
  return [
    (tangent[2] - normal[1]) * invW4,
    (normal[0] - binormal[2]) * invW4,
    (binormal[1] - tangent[0]) * invW4,
    w
  ];
}

// src/math/quat/quatNormalize.ts
function quatNormalize(vec) {
  const len = vecLength(vec);
  if (len === 0) {
    return [0, 0, 0, 1];
  }
  return vecScale(vec, 1 / len);
}

// src/math/quat/quatRotationX.ts
function quatRotationX(theta) {
  return [Math.sin(theta / 2), 0, 0, Math.cos(theta / 2)];
}

// src/math/quat/quatRotationY.ts
function quatRotationY(theta) {
  return [0, Math.sin(theta / 2), 0, Math.cos(theta / 2)];
}

// src/math/quat/quatRotationZ.ts
function quatRotationZ(theta) {
  return [0, 0, Math.sin(theta / 2), Math.cos(theta / 2)];
}

// src/math/quat/quatSlerp.ts
function quatSlerp(a, b, t) {
  if (t === 0) {
    return a.concat();
  }
  if (t === 1) {
    return b.concat();
  }
  let cosHalfTheta = vecDot(a, b);
  if (cosHalfTheta < 0) {
    b = vecNeg(b);
    cosHalfTheta = -cosHalfTheta;
  }
  if (cosHalfTheta >= 1) {
    return a.concat();
  }
  const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
  if (sqrSinHalfTheta <= Number.EPSILON) {
    const s = 1 - t;
    return vecNormalize([
      s * a[0] + t * b[0],
      s * a[1] + t * b[1],
      s * a[2] + t * b[2],
      s * a[3] + t * b[3]
    ]);
  }
  const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
  const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
  const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
  const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
  return [
    a[0] * ratioA + b[0] * ratioB,
    a[1] * ratioA + b[1] * ratioB,
    a[2] * ratioA + b[2] * ratioB,
    a[3] * ratioA + b[3] * ratioB
  ];
}

// src/math/quat/Quaternion.ts
var rawIdentityQuaternion = (/* unused pure expression or super */ null && ([0, 0, 0, 1]));
var Quaternion = class {
  constructor(elements = rawIdentityQuaternion) {
    this.elements = elements;
  }
  get x() {
    return this.elements[0];
  }
  get y() {
    return this.elements[1];
  }
  get z() {
    return this.elements[2];
  }
  get w() {
    return this.elements[3];
  }
  toString() {
    return `Quaternion( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)}, ${this.w.toFixed(3)} )`;
  }
  clone() {
    return new Quaternion(this.elements.concat());
  }
  get matrix4() {
    return new Matrix4(mat4FromQuaternion(this.elements));
  }
  get inversed() {
    return new Quaternion(quatInverse(this.elements));
  }
  get length() {
    return vecLength(this.elements);
  }
  get lengthSq() {
    return vecLengthSq(this.elements);
  }
  get normalized() {
    return new Quaternion(quatNormalize(this.elements));
  }
  multiply(...quaternions) {
    return Quaternion.multiply(this, ...quaternions);
  }
  slerp(b, t) {
    return Quaternion.slerp(this, b, t);
  }
  static get identity() {
    return new Quaternion(rawIdentityQuaternion);
  }
  static multiply(...quaternions) {
    if (quaternions.length === 0) {
      return Quaternion.identity;
    } else {
      return new Quaternion(quatMultiply(...quaternions.map((q) => q.elements)));
    }
  }
  static slerp(a, b, t) {
    return new Quaternion(quatSlerp(a.elements, b.elements, t));
  }
  static rotationX(theta) {
    return new Quaternion(quatRotationX(theta));
  }
  static rotationY(theta) {
    return new Quaternion(quatRotationY(theta));
  }
  static rotationZ(theta) {
    return new Quaternion(quatRotationZ(theta));
  }
  static lookRotation(look, up) {
    return new Quaternion(quatLookRotation(look.elements, up.elements));
  }
  static fromAxisAngle(axis, angle) {
    return new Quaternion(quatFromAxisAngle(axis.elements, angle));
  }
  static fromMatrix4(matrix) {
    return new Quaternion(quatFromMatrix4(matrix.elements));
  }
};

// src/math/mod.ts
function _0b5vr_experimental_esm_mod(value, divisor) {
  return value - Math.floor(value / divisor) * divisor;
}

// src/math/sanitizeAngle.ts
function sanitizeAngle(angle) {
  return _0b5vr_experimental_esm_mod(angle + Math.PI, 2 * Math.PI) - Math.PI;
}

// src/math/euler/eulerFromMat3.ts
function eulerFromMat3(m, order) {
  const [i, j, k, sign] = !order || order === "XYZ" ? [0, 1, 2, 1] : order === "XZY" ? [0, 2, 1, -1] : order === "YXZ" ? [1, 0, 2, -1] : order === "YZX" ? [1, 2, 0, 1] : order === "ZXY" ? [2, 0, 1, 1] : [2, 1, 0, -1];
  const result = [0, 0, 0];
  const c = m[k + i * 3];
  result[j] = -sign * Math.asin(clamp(c, -1, 1));
  if (Math.abs(c) < 0.999999) {
    result[i] = sign * Math.atan2(m[k + j * 3], m[k * 4]);
    result[k] = sign * Math.atan2(m[j + i * 3], m[i * 4]);
  } else {
    result[i] = sign * Math.atan2(-m[j + k * 3], m[j * 4]);
  }
  if (vecManhattanLength(result) > 1.5 * Math.PI) {
    result[i] = sanitizeAngle(result[i] + Math.PI);
    result[j] = sanitizeAngle(Math.PI - result[j]);
    result[k] = sanitizeAngle(result[k] + Math.PI);
  }
  return result;
}

// src/math/euler/eulerFromMat4.ts
function eulerFromMat4(m, order) {
  return eulerFromMat3(mat3FromMat4(m), order);
}

// src/math/euler/eulerFromQuaternion.ts
function eulerFromQuaternion(m, order) {
  return eulerFromMat3(mat3FromQuaternion(m), order);
}

// src/math/quat/quatFromEuler.ts
function quatFromEuler(euler, order) {
  const [i, j, k, sign] = !order || order === "XYZ" ? [0, 1, 2, 1] : order === "XZY" ? [0, 2, 1, -1] : order === "YXZ" ? [1, 0, 2, -1] : order === "YZX" ? [1, 2, 0, 1] : order === "ZXY" ? [2, 0, 1, 1] : [2, 1, 0, -1];
  const ti = 0.5 * euler[i];
  const tj = 0.5 * sign * euler[j];
  const tk = 0.5 * euler[k];
  const ci = Math.cos(ti);
  const cj = Math.cos(tj);
  const ck = Math.cos(tk);
  const si = Math.sin(ti);
  const sj = Math.sin(tj);
  const sk = Math.sin(tk);
  const result = [
    0,
    0,
    0,
    ck * cj * ci + sk * sj * si
  ];
  result[i] = ck * cj * si - sk * sj * ci;
  result[j] = sign * (ck * sj * ci + sk * cj * si);
  result[k] = sk * cj * ci - ck * sj * si;
  return result;
}

// src/math/euler/Euler.ts
var Euler = class {
  constructor(elements = [0, 0, 0], order = "XYZ") {
    this.elements = elements;
    this.order = order;
  }
  get x() {
    return this.elements[0];
  }
  get y() {
    return this.elements[1];
  }
  get z() {
    return this.elements[2];
  }
  toString() {
    return `Euler( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)} (${this.order}) )`;
  }
  clone() {
    return new Euler(this.elements.concat(), this.order);
  }
  get quaternion() {
    return new Quaternion(quatFromEuler(this.elements, this.order));
  }
  get matrix4() {
    return this.quaternion.matrix4;
  }
  static fromMatrix3(matrix, order) {
    return new Euler(eulerFromMat3(matrix.elements, order), order);
  }
  static fromMatrix4(matrix, order) {
    return new Euler(eulerFromMat4(matrix.elements, order), order);
  }
  static fromQuaternion(quaternion, order) {
    return new Euler(eulerFromQuaternion(quaternion.elements, order), order);
  }
};

// src/math/ray3/ray3DistanceToSphere.ts
function ray3DistanceToSphere([ro, rd], sphere) {
  const v = vecSub(ro, sphere[0]);
  const b = vecDot(v, rd);
  const c = vecDot(v, v) - sphere[1];
  const d = b * b - c;
  if (d < 0) {
    return null;
  }
  const sqrtD = Math.sqrt(d);
  return [-b - sqrtD, -b + sqrtD];
}

// src/math/line3/line3Delta.ts
function line3Delta(line) {
  return vecSub(line[1], line[0]);
}

// src/math/ray3/ray3FromLine3.ts
function ray3FromLine3(line) {
  return [
    line[0],
    vecNormalize(line3Delta(line))
  ];
}

// src/math/ray3/Ray3.ts
var Ray3 = class {
  constructor(start = Vector3.zero, end = Vector3.pz) {
    this.origin = start;
    this.direction = end;
  }
  get raw() {
    return [this.origin.elements, this.direction.elements];
  }
  distanceToSphere(sphere) {
    return ray3DistanceToSphere(this.raw, sphere.raw);
  }
  static fromRaw(ray) {
    return new Ray3(new Vector3(ray[0]), new Vector3(ray[1]));
  }
  static fromLine3(line) {
    return Ray3.fromRaw(ray3FromLine3(line.raw));
  }
};

// src/math/line3/line3ApplyMatrix4.ts
function line3ApplyMatrix4([start, end], matrix) {
  return [
    vec3ApplyMatrix4(start, matrix),
    vec3ApplyMatrix4(end, matrix)
  ];
}

// src/math/line3/line3At.ts
function line3At(line, t) {
  return vecAdd(vecScale(line[0], 1 - t), vecScale(line[1], t));
}

// src/math/line3/line3ClosestPointToPoint.ts
function line3ClosestPointToPoint(line, point, segment) {
  const ap = vecSub(point, line[0]);
  const ab = vecSub(line[1], line[0]);
  let t = vecDot(ap, ab) / vecDot(ab, ab);
  segment && (t = saturate(t));
  return line3At(line, t);
}

// src/math/line3/line3DistanceToPoint.ts
function line3DistanceToPoint(line, point, segment) {
  return vecLength(vecSub(line3ClosestPointToPoint(line, point, segment), point));
}

// src/math/line3/Line3.ts
var Line3 = class {
  constructor(start = Vector3.zero, end = Vector3.zero) {
    this.start = start;
    this.end = end;
  }
  get raw() {
    return [this.start.elements, this.end.elements];
  }
  get ray() {
    return Ray3.fromLine3(this);
  }
  delta() {
    return new Vector3(line3Delta(this.raw));
  }
  length() {
    return this.delta.length;
  }
  at(t) {
    return new Vector3(line3At(this.raw, t));
  }
  applyMatrix4(matrix) {
    return Line3.fromRaw(line3ApplyMatrix4(this.raw, matrix.elements));
  }
  closestPointToPoint(point, segment) {
    return new Vector3(line3ClosestPointToPoint(this.raw, point.elements, segment));
  }
  distanceToPoint(point, segment) {
    return line3DistanceToPoint(this.raw, point.elements, segment);
  }
  static fromRaw(line) {
    return new Line3(new Vector3(line[0]), new Vector3(line[1]));
  }
};

// src/math/mat2/mat2Determinant.ts
function mat2Determinant(m) {
  return m[0] * m[3] - m[2] * m[1];
}

// src/math/mat2/mat2Inverse.ts
function mat2Inverse(m) {
  const n11 = m[0], n21 = m[1], n12 = m[2], n22 = m[3], det = n11 * n22 - n12 * n21;
  if (det === 0) {
    return vecScale(m, 0);
  }
  return vecScale([
    n22,
    -n21,
    -n12,
    n11
  ], 1 / det);
}

// src/math/mat2/mat2Multiply.ts
function mat2Multiply(...mats) {
  if (mats.length < 2) {
    return mats[0];
  }
  const a = mats.shift();
  const b = mat2Multiply(...mats);
  const a00 = a[0], a01 = a[1], a10 = a[2], a11 = a[3], b00 = b[0], b01 = b[1], b10 = b[2], b11 = b[3];
  return [
    a00 * b00 + a10 * b01,
    a01 * b00 + a11 * b01,
    a00 * b10 + a10 * b11,
    a01 * b10 + a11 * b11
  ];
}

// src/math/mat2/mat2Transpose.ts
function mat2Transpose(source) {
  return [
    source[0],
    source[2],
    source[1],
    source[3]
  ];
}

// src/math/mat2/Matrix2.ts
var rawIdentityMatrix2 = (/* unused pure expression or super */ null && ([
  1,
  0,
  0,
  1
]));
var Matrix2 = class {
  constructor(v = rawIdentityMatrix2) {
    this.elements = v;
  }
  get transpose() {
    return new Matrix2(mat2Transpose(this.elements));
  }
  get determinant() {
    return mat2Determinant(this.elements);
  }
  get inverse() {
    return new Matrix2(mat2Inverse(this.elements));
  }
  toString() {
    const m = this.elements.map((v) => v.toFixed(3));
    return `Matrix2( ${m[0]}, ${m[2]}; ${m[1]}, ${m[3]} )`;
  }
  clone() {
    return new Matrix2(this.elements.concat());
  }
  multiply(...matrices) {
    return Matrix2.multiply(this, ...matrices);
  }
  scaleScalar(scalar) {
    return new Matrix2(vecScale(this.elements, scalar));
  }
  static get identity() {
    return new Matrix2(rawIdentityMatrix2);
  }
  static multiply(...matrices) {
    if (matrices.length === 0) {
      return Matrix2.identity;
    } else {
      return new Matrix2(mat2Multiply(...matrices.map((m) => m.elements)));
    }
  }
};

// src/math/vec3/vec3ApplyMatrix3.ts
function vec3ApplyMatrix3(v, m) {
  return [
    m[0] * v[0] + m[3] * v[1] + m[6] * v[2],
    m[1] * v[0] + m[4] * v[1] + m[7] * v[2],
    m[2] * v[0] + m[5] * v[1] + m[8] * v[2]
  ];
}

// src/math/plane3/plane3ApplyMatrix4.ts
function plane3ApplyMatrix4([normal, distance], matrix, normalMatrix) {
  const newNormal = vecNormalize(vec3ApplyMatrix3(normal, normalMatrix));
  const coplanar = vecScale(normal, -distance);
  const refPoint = vec3ApplyMatrix4(coplanar, matrix);
  const newDistance = -vecDot(refPoint, normal);
  return [newNormal, newDistance];
}

// src/math/plane3/plane3DistanceToPoint.ts
function plane3DistanceToPoint([normal, distance], point) {
  return vecDot(normal, point) + distance;
}

// src/math/plane3/plane3Normalize.ts
function plane3Normalize([normal, distance]) {
  const invL = 1 / vecLength(normal);
  return [vecScale(normal, invL), distance * invL];
}

// src/math/plane3/Plane3.ts
var Plane3 = class {
  get raw() {
    return [this.normal.elements, this.distance];
  }
  get normalized() {
    return Plane3.fromRaw(plane3Normalize(this.raw));
  }
  constructor(normal = Vector3.pz, distance = 0) {
    this.normal = normal;
    this.distance = distance;
  }
  applyMatrix4(matrix, normalMatrix) {
    var _a;
    return Plane3.fromRaw(plane3ApplyMatrix4(this.raw, matrix.elements, (_a = normalMatrix == null ? void 0 : normalMatrix.elements) != null ? _a : matrix.normalMatrix.elements));
  }
  distanceToPoint(point) {
    return plane3DistanceToPoint(this.raw, point.elements);
  }
  static fromRaw(plane) {
    return new Plane3(new Vector3(plane[0]), plane[1]);
  }
};

// src/math/plane3/planes3ContainPoint.ts
function planes3ContainPoint(planes, point) {
  return planes.every((plane) => plane3DistanceToPoint(plane, point) >= 0);
}

// src/math/plane3/planes3FromBox3.ts
function planes3FromBox3(box) {
  return [
    [[1, 0, 0], -box[0][0]],
    [[-1, 0, 0], box[1][0]],
    [[0, 1, 0], -box[0][1]],
    [[0, -1, 0], box[1][1]],
    [[0, 0, 1], -box[0][2]],
    [[0, 0, -1], box[1][2]]
  ];
}

// src/math/plane3/planes3FromProjectionMatrix.ts
function planes3FromProjectionMatrix(m) {
  const m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
  return [
    plane3Normalize([[m41 - m11, m42 - m12, m43 - m13], m44 - m14]),
    plane3Normalize([[m41 + m11, m42 + m12, m43 + m13], m44 + m14]),
    plane3Normalize([[m41 - m21, m42 - m22, m43 - m23], m44 - m24]),
    plane3Normalize([[m41 + m21, m42 + m22, m43 + m23], m44 + m24]),
    plane3Normalize([[m41 - m31, m42 - m32, m43 - m33], m44 - m34]),
    plane3Normalize([[m41 + m31, m42 + m32, m43 + m33], m44 + m34])
  ];
}

// src/math/plane3/planes3IntersectBox3.ts
function planes3IntersectBox3(planes, box) {
  return planes.every((plane) => {
    const v = plane[0].map((nc, i) => box[nc > 0 ? 1 : 0][i]);
    return plane3DistanceToPoint(plane, v) >= 0;
  });
}

// src/math/plane3/planes3IntersectSphere3.ts
function planes3IntersectSphere3(planes, sphere) {
  return planes.every((plane) => plane3DistanceToPoint(plane, sphere[0]) >= -sphere[1]);
}

// src/math/plane3/Planes3.ts
var Planes3 = class {
  get raw() {
    return this.planes.map((plane) => plane.raw);
  }
  constructor(planes) {
    this.planes = planes;
  }
  containPoint(point) {
    return planes3ContainPoint(this.raw, point.elements);
  }
  intersectBox3(box) {
    return planes3IntersectBox3(this.raw, box.raw);
  }
  intersectSphere3(sphere) {
    return planes3IntersectSphere3(this.raw, sphere.raw);
  }
  static fromRaw(planes) {
    return new Planes3(planes.map((plane) => Plane3.fromRaw(plane)));
  }
  static fromBox3(box) {
    return Planes3.fromRaw(planes3FromBox3(box.raw));
  }
  static fromProjectionMatrix(matrix) {
    return Planes3.fromRaw(planes3FromProjectionMatrix(matrix.elements));
  }
};

// src/math/sphere3/sphere3ContainsPoint.ts
function sphere3ContainsPoint(sphere, point) {
  return vecLengthSq(vecSub(sphere[0], point)) <= sphere[1] * sphere[1];
}

// src/math/sphere3/Sphere3.ts
var Sphere3 = class {
  constructor(origin = Vector3.zero, radius = 0) {
    this.origin = origin;
    this.radius = radius;
  }
  get raw() {
    return [this.origin.elements, this.radius];
  }
  containsPoint(point) {
    return sphere3ContainsPoint(this.raw, point.elements);
  }
  static fromRaw(sphere) {
    return new Sphere3(new Vector3(sphere[0]), sphere[1]);
  }
};

// src/math/vec4/vec4ApplyMatrix3.ts
function vec4ApplyMatrix3(v, m) {
  const v3 = [v[0], v[1], v[2]];
  const xyz = vec3ApplyMatrix3(v3, m);
  const w = v[3];
  return [xyz[0], xyz[1], xyz[2], w];
}

// src/math/vec4/Vector4.ts
var Vector4 = class extends (/* unused pure expression or super */ null && (Vector)) {
  constructor(v = [0, 0, 0, 0]) {
    super();
    this.elements = v;
  }
  get x() {
    return this.elements[0];
  }
  set x(x) {
    this.elements[0] = x;
  }
  get y() {
    return this.elements[1];
  }
  set y(y) {
    this.elements[1] = y;
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
  }
  get w() {
    return this.elements[3];
  }
  set w(z) {
    this.elements[3] = z;
  }
  toString() {
    return `Vector4( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)}, ${this.w.toFixed(3)} )`;
  }
  applyMatrix3(matrix) {
    return new Vector4(vec4ApplyMatrix3(this.elements, matrix.elements));
  }
  applyMatrix4(matrix) {
    return new Vector4(vec4ApplyMatrix4(this.elements, matrix.elements));
  }
  __new(v) {
    return new Vector4(v);
  }
  static get zero() {
    return new Vector4([0, 0, 0, 0]);
  }
  static get one() {
    return new Vector4([1, 1, 1, 1]);
  }
};

// src/midi/midiParse.ts
function readU8(array, headBox) {
  return array[headBox[0]++];
}
function readU16(array, headBox) {
  return readU8(array, headBox) * 256 + readU8(array, headBox);
}
function readU32(array, headBox) {
  return readU16(array, headBox) * 65536 + readU16(array, headBox);
}
function readUVar(array, headBox) {
  let v = 0;
  for (; ; ) {
    const vv = readU8(array, headBox);
    v = v * 128 + (vv & 127);
    if (vv < 128) {
      return v;
    }
  }
}
function parseHeader(array, headBox) {
  headBox[0] += 8;
  return [
    readU16(array, headBox),
    readU16(array, headBox),
    readU16(array, headBox)
  ];
}
function parseTrack(array, headBox) {
  headBox[0] += 4;
  const endOfTrack = headBox[0] + readU32(array, headBox) + 4;
  const track = [];
  let type = 0;
  while (headBox[0] < endOfTrack) {
    const delta = readUVar(array, headBox);
    const status = readU8(array, headBox);
    type = status < 128 ? type : status;
    const data0 = status < 128 ? status : readU8(array, headBox);
    if (type < 192) {
      track.push([
        delta,
        type,
        data0,
        readU8(array, headBox)
      ]);
    } else if (type === 255) {
      const eventLength = readU8(array, headBox);
      track.push([
        delta,
        type,
        data0,
        arraySerial(eventLength).map(() => readU8(array, headBox))
      ]);
      if (data0 === 47) {
        break;
      }
    } else {
      throw new Error(`${type}`);
    }
  }
  return track;
}
function midiParse(buffer) {
  const array = new Uint8Array(buffer);
  const headBox = [0];
  const header = parseHeader(array, headBox);
  const tracks = [];
  while (headBox[0] < array.length) {
    tracks.push(parseTrack(array, headBox));
  }
  return [header, tracks];
}

// src/poker/pokerRanksByStrength.ts
var pokerRanksByStrength = (/* unused pure expression or super */ null && ([
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "T",
  "J",
  "Q",
  "K",
  "A"
]));

// src/poker/pokerSuitsByIndex.ts
var pokerSuitsByIndex = (/* unused pure expression or super */ null && ([
  "c",
  "d",
  "h",
  "s"
]));

// src/poker/createPokerDeck.ts
function createPokerDeck() {
  const array = [];
  pokerSuitsByIndex.map((suit) => pokerRanksByStrength.map((rank) => array.push(rank + suit)));
  return array;
}

// src/poker/pokerHandStrengthMap.ts
var pokerHandStrengthMap = {
  "HighCard": 0,
  "OnePair": 1,
  "TwoPair": 2,
  "ThreeOfAKind": 3,
  "Straight": 4,
  "Flush": 5,
  "FullHouse": 6,
  "FourOfAKind": 7,
  "StraightFlush": 8
};

// src/poker/pokerRankStrengthMap.ts
var pokerRankStrengthMap = {
  "2": 0,
  "3": 1,
  "4": 2,
  "5": 3,
  "6": 4,
  "7": 5,
  "8": 6,
  "9": 7,
  "T": 8,
  "J": 9,
  "Q": 10,
  "K": 11,
  "A": 12
};

// src/poker/pokerSuitIndexMap.ts
var pokerSuitIndexMap = {
  "c": 0,
  "d": 1,
  "h": 2,
  "s": 3
};

// src/poker/sortPokerCardsByRank.ts
function sortPokerCardsByRank(cards) {
  return cards.sort((a, b) => pokerSuitIndexMap[a[1]] - pokerSuitIndexMap[b[1]]).sort((a, b) => pokerRankStrengthMap[a[0]] - pokerRankStrengthMap[b[0]]);
}

// src/poker/evaluatePokerHand.ts
function evaluatePokerHand(cards) {
  const cards_ = cards.concat();
  const cardsByRank = new MapOfSet();
  const cardsBySuit = new MapOfSet();
  cards_.map((card) => {
    const rank = card[0];
    const suit = card[1];
    cardsByRank.add(rank, card);
    cardsBySuit.add(suit, card);
  });
  const fours = [];
  const threes = [];
  const twos = [];
  pokerRanksByStrength.map((rank) => {
    const cards2 = cardsByRank.get(rank);
    if (cards2.size > 3) {
      fours.push(rank);
    } else if (cards2.size > 2) {
      threes.push(rank);
    } else if (cards2.size > 1) {
      twos.push(rank);
    }
  });
  let straightCards;
  {
    let current = [];
    const a = Array.from(cardsByRank.get("A"))[0];
    if (a) {
      current.push(a);
    }
    pokerRanksByStrength.map((rank) => {
      const card = Array.from(cardsByRank.get(rank))[0];
      if (card) {
        current.push(card);
        if (current.length > 4) {
          straightCards = current;
        }
      } else {
        current = [];
      }
    });
  }
  if (straightCards) {
    for (const [suit, cardsSet] of cardsBySuit.map) {
      if (cardsSet.size > 0) {
        let straightFlushCards;
        let current = [];
        const target = "A" + suit;
        const a = cardsSet.has(target);
        if (a) {
          current.push(target);
        }
        pokerRanksByStrength.map((rank) => {
          const target2 = rank + suit;
          if (cardsSet.has(target2)) {
            current.push(target2);
            if (current.length > 4) {
              straightFlushCards = current;
            }
          } else {
            current = [];
          }
        });
        if (straightFlushCards) {
          straightFlushCards.splice(0, straightFlushCards.length - 5);
          const hand = "StraightFlush";
          const strength = [
            pokerHandStrengthMap[hand],
            pokerRankStrengthMap[straightFlushCards[4][0]]
          ];
          return {
            hand,
            cards: straightFlushCards,
            strength
          };
        }
      }
    }
  }
  if (fours.length > 0) {
    fours.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    fours.splice(0, fours.length - 1);
    const sameCards = Array.from(cardsByRank.get(fours[0]));
    sameCards.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 1);
    const hand = "FourOfAKind";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[fours[0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...sameCards);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  if (threes.length > 0 && threes.length + twos.length > 1) {
    threes.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    twos.push(...threes.splice(0, threes.length - 1));
    twos.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    twos.splice(0, twos.length - 1);
    const sameCards = Array.from(cardsByRank.get(threes[0]));
    sameCards.push(...Array.from(cardsByRank.get(twos[0])));
    sortPokerCardsByRank(sameCards).splice(0, sameCards.length - 5);
    const hand = "FullHouse";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[threes[0]],
      pokerRankStrengthMap[twos[0]]
    ];
    return {
      hand,
      cards: sameCards,
      strength
    };
  }
  for (const [_suit, cardsSet] of cardsBySuit.map) {
    if (cardsSet.size > 4) {
      const cards2 = sortPokerCardsByRank(Array.from(cardsSet));
      cards2.splice(0, cards2.length - 5);
      const hand = "Flush";
      const strength = [
        pokerHandStrengthMap[hand],
        ...cards2.concat().reverse().map((card) => pokerRankStrengthMap[card[0]])
      ];
      return {
        hand,
        cards: cards2,
        strength
      };
    }
  }
  if (straightCards) {
    straightCards.splice(0, straightCards.length - 5);
    const hand = "Straight";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[straightCards[4][0]]
    ];
    return {
      hand,
      cards: straightCards,
      strength
    };
  }
  if (threes.length > 0) {
    threes.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    threes.splice(0, threes.length - 1);
    const sameCards = Array.from(cardsByRank.get(threes[0]));
    sameCards.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 2);
    const hand = "ThreeOfAKind";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[threes[0]],
      pokerRankStrengthMap[cards_[1][0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...sameCards);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  if (twos.length > 1) {
    twos.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    twos.splice(0, twos.length - 2);
    const pairs = Array.from(cardsByRank.get(twos[0]));
    pairs.push(...Array.from(cardsByRank.get(twos[1])));
    pairs.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 1);
    const hand = "TwoPair";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[twos[1]],
      pokerRankStrengthMap[twos[0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...pairs);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  if (twos.length > 0) {
    const pair = Array.from(cardsByRank.get(twos[0]));
    pair.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 3);
    const hand = "OnePair";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[twos[0]],
      pokerRankStrengthMap[cards_[2][0]],
      pokerRankStrengthMap[cards_[1][0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...pair);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  {
    const hand = "HighCard";
    sortPokerCardsByRank(cards_);
    cards_.splice(0, cards_.length - 5);
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[cards_[4][0]],
      pokerRankStrengthMap[cards_[3][0]],
      pokerRankStrengthMap[cards_[2][0]],
      pokerRankStrengthMap[cards_[1][0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    return {
      hand,
      cards: cards_,
      strength
    };
  }
}

// src/poker/pokerHandsByStrength.ts
var pokerHandsByStrength = (/* unused pure expression or super */ null && ([
  "HighCard",
  "OnePair",
  "TwoPair",
  "ThreeOfAKind",
  "Straight",
  "Flush",
  "FullHouse",
  "FourOfAKind",
  "StraightFlush"
]));

// src/retry/asyncRetry.ts
function asyncRetry(func, n) {
  return __async(this, null, function* () {
    return yield func().catch((error) => {
      if (n <= 1) {
        throw error;
      }
      return asyncRetry(func, n - 1);
    });
  });
}

// src/retry/retry.ts
function retry(func, n) {
  try {
    return func();
  } catch (error) {
    if (n <= 1) {
      throw error;
    }
    return retry(func, n - 1);
  }
}

// src/stniccc/parseSTNICCC.ts
function parseSTNICCC(buffer) {
  const frames = [];
  const array = new Uint8Array(buffer);
  const palette = new Uint16Array(16);
  let head = 0;
  let shouldSkip = false;
  let shouldEnd = false;
  for (; ; ) {
    const flags = array[head++];
    const needsClear = (flags & 1) === 1;
    const hasPalette = (flags >> 1 & 1) === 1;
    const indexedMode = (flags >> 2 & 1) === 1;
    if (hasPalette) {
      const bitmask = array[head++] << 8 | array[head++];
      for (let i = 0; i < 16; i++) {
        if (bitmask >> 15 - i & 1) {
          palette[i] = array[head++] << 8 | array[head++];
        }
      }
    }
    if (indexedMode) {
      const nVertices = array[head++];
      const vertices = array.subarray(head, head + 2 * nVertices);
      head += 2 * nVertices;
      const polygons = [];
      for (; ; ) {
        const descriptor = array[head++];
        if (descriptor === 255) {
          break;
        } else if (descriptor === 254) {
          shouldSkip = true;
          break;
        } else if (descriptor === 253) {
          shouldEnd = true;
          break;
        }
        const colorIndex = descriptor >> 4 & 15;
        const nIndices = descriptor & 15;
        const indices = array.subarray(head, head + nIndices);
        head += nIndices;
        polygons.push({
          colorIndex,
          indices: Array.from(indices)
        });
      }
      frames.push({
        needsClear,
        indexedMode,
        palette: Array.from(palette),
        vertices: Array.from(vertices),
        polygons
      });
    } else {
      const polygons = [];
      for (; ; ) {
        const descriptor = array[head++];
        if (descriptor === 255) {
          break;
        } else if (descriptor === 254) {
          shouldSkip = true;
          break;
        } else if (descriptor === 253) {
          shouldEnd = true;
          break;
        }
        const colorIndex = descriptor >> 4 & 15;
        const nVertices = descriptor & 15;
        const vertices = array.subarray(head, head + 2 * nVertices);
        head += 2 * nVertices;
        polygons.push({
          colorIndex,
          vertices: Array.from(vertices)
        });
      }
      frames.push({
        needsClear,
        indexedMode,
        palette: Array.from(palette),
        polygons
      });
    }
    if (shouldSkip) {
      head = (Math.floor(head / 65536) + 1) * 65536;
      shouldSkip = false;
    }
    if (shouldEnd) {
      break;
    }
  }
  return frames;
}

// src/stniccc/stnicccToSVG.ts
function stnicccToSVG(frames, options = {}) {
  var _a;
  const delta = 1 / ((_a = options == null ? void 0 : options.fps) != null ? _a : 30);
  let svg = '<svg width="256" height="200" viewBox="0 0 256 200" xmlns="http://www.w3.org/2000/svg">';
  let style = `g{visibility:hidden;animation-duration:${(delta * frames.length).toFixed(3)}s;animation-iteration-count:infinite;animation-name:frame}@keyframes frame{0%{visibility:visible}${200 / frames.length}%{visibility:hidden}}`;
  frames.map((frame, iFrame) => {
    const { indexedMode, palette, polygons } = frame;
    style += `#f${iFrame}{animation-delay:${(delta * iFrame).toFixed(3)}s}`;
    const paletteInHex = palette.map((stColor) => {
      const color = colorFromAtariST(stColor);
      return colorToHex(color);
    });
    let childrenStr = '<rect width="256" height="200" fill="#000" />';
    let currentColorIndex = -1;
    let d = "";
    if (indexedMode) {
      const { vertices } = frame;
      polygons.map(({ colorIndex, indices }) => {
        if (currentColorIndex !== colorIndex) {
          if (currentColorIndex !== -1) {
            const colorHex2 = paletteInHex[currentColorIndex];
            childrenStr += `<path d="${d}" fill="${colorHex2}" />`;
          }
          currentColorIndex = colorIndex;
          d = "";
        }
        for (let i = 0; i < indices.length; i++) {
          const index = indices[i];
          const x = vertices[2 * index];
          const y = vertices[2 * index + 1];
          d += i === 0 ? `M${x},${y}` : `L${x},${y}`;
        }
      });
    } else {
      polygons.map(({ colorIndex, vertices }) => {
        if (currentColorIndex !== colorIndex) {
          if (currentColorIndex !== -1) {
            const colorHex2 = paletteInHex[currentColorIndex];
            childrenStr += `<path d="${d}" fill="${colorHex2}" />`;
          }
          currentColorIndex = colorIndex;
          d = "";
        }
        for (let i = 0; i < vertices.length; i += 2) {
          const x = vertices[i];
          const y = vertices[i + 1];
          d += i === 0 ? `M${x},${y}` : `L${x},${y}`;
        }
      });
    }
    const colorHex = paletteInHex[currentColorIndex];
    childrenStr += `<path d="${d}" fill="${colorHex}" />`;
    svg += `<g id="f${iFrame}">${childrenStr}</g>`;
  });
  svg += `<style>${style}</style></svg>`;
  return svg;
}

// src/SmoothDamp/SmoothDamp.ts
var SmoothDamp = class {
  constructor() {
    this.smoothTime = 1;
    this.velocity = 0;
    this.value = 0;
    this.target = 0;
  }
  update(deltaTime) {
    const omega = 2 / this.smoothTime;
    const x = omega * deltaTime;
    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
    const delta = this.value - this.target;
    const temp = (this.velocity + omega * delta) * deltaTime;
    this.velocity = (this.velocity - omega * temp) * exp;
    this.value = this.target + (delta + temp) * exp;
    return this.value;
  }
};

// src/Swap/Swap.ts
var Swap = class {
  constructor(a, b) {
    this.i = a;
    this.o = b;
  }
  swap() {
    const i = this.i;
    this.i = this.o;
    this.o = i;
  }
};

// src/TapTempo/TapTempo.ts
var TapTempo = class {
  constructor() {
    this.__bpm = 0;
    this.__lastTap = 0;
    this.__lastBeat = 0;
    this.__lastTime = 0;
    this.__calc = new HistoryMeanCalculator(16);
  }
  get beatDuration() {
    return 60 / this.__bpm;
  }
  get bpm() {
    return this.__bpm;
  }
  set bpm(bpm) {
    this.__lastBeat = this.beat;
    this.__lastTime = performance.now();
    this.__bpm = bpm;
  }
  get beat() {
    return this.__lastBeat + (performance.now() - this.__lastTime) * 1e-3 / this.beatDuration;
  }
  reset() {
    this.__calc.reset();
  }
  nudge(amount) {
    this.__lastBeat = this.beat + amount;
    this.__lastTime = performance.now();
  }
  tap() {
    const now = performance.now();
    const delta = (now - this.__lastTap) * 1e-3;
    if (2 < delta) {
      this.reset();
    } else {
      this.__calc.push(delta);
      this.__bpm = 60 / this.__calc.mean;
    }
    this.__lastTap = now;
    this.__lastTime = now;
    this.__lastBeat = 0;
  }
};

// src/tinyseq/createTinyseqPolyReader.ts
function createTinyseqPolyReader(buffer, options = {}) {
  var _a, _b, _c, _d;
  const poly = (_a = options.poly) != null ? _a : 8;
  const blockSize = (_b = options.blockSize) != null ? _b : 128;
  const sampleRate = (_c = options.sampleRate) != null ? _c : 48e3;
  const stepsPerSecond = (_d = options.stepsPerSecond) != null ? _d : 1;
  let samples = 0;
  let pos = 0;
  let note;
  const notes = arraySerial(poly).fill(-1);
  const notesTime = arraySerial(poly).fill(-Infinity);
  const notesOffTime = arraySerial(poly).fill(-Infinity);
  let nextStep = 0;
  return () => {
    const ret = arraySerial(poly).map(() => new Float32Array(4 * blockSize));
    arraySerial(blockSize).map((iSample) => {
      const t = samples / sampleRate;
      const s = t * stepsPerSecond;
      if (s >= nextStep) {
        const eventNote = buffer[pos];
        const eventDeltaStep = buffer[pos + 1];
        note = (pos === 0 ? 60 : note) + eventNote & 127;
        let iPoly = notes.indexOf(note);
        let tEarliest = Infinity;
        if (iPoly === -1) {
          notesTime.map((tOn, jPoly) => {
            const tOff = notesOffTime[jPoly];
            if (tOn <= tOff) {
              if (tOff < tEarliest) {
                iPoly = jPoly;
                tEarliest = tOff;
              }
            }
          });
        }
        if (iPoly === -1) {
          notesTime.map((tOn, jPoly) => {
            if (tOn < tEarliest) {
              iPoly = jPoly;
              tEarliest = tOn;
            }
          });
        }
        notes[iPoly] = note;
        if (eventNote & 128) {
          if (notesOffTime[iPoly] < notesTime[iPoly]) {
            notesOffTime[iPoly] = t;
          }
        } else {
          if (notesOffTime[iPoly] >= notesTime[iPoly]) {
            notesTime[iPoly] = t;
          }
        }
        nextStep += eventDeltaStep;
        pos = (pos + 2) % buffer.length;
      }
      samples++;
      arraySerial(poly).map((iPoly) => {
        const noteTime = notesTime[iPoly];
        const noteOffTime = notesOffTime[iPoly];
        ret[iPoly][4 * iSample + 0] = t - noteTime;
        ret[iPoly][4 * iSample + 1] = noteOffTime < noteTime ? 0 : t - noteOffTime;
        ret[iPoly][4 * iSample + 2] = notes[iPoly];
        ret[iPoly][4 * iSample + 3] = 0;
      });
    });
    return ret;
  };
}

// src/tinyseq/createTinyseqReader.ts
function createTinyseqReader(buffer, options = {}) {
  var _a, _b, _c;
  const blockSize = (_a = options.blockSize) != null ? _a : 128;
  const sampleRate = (_b = options.sampleRate) != null ? _b : 48e3;
  const stepsPerSecond = (_c = options.stepsPerSecond) != null ? _c : 960;
  let samples = 0;
  let pos = 0;
  let note;
  let noteTime = -Infinity;
  let noteOffTime = -Infinity;
  let nextStep = 0;
  return () => {
    return new Float32Array(arraySerial(blockSize).map(() => {
      const t = samples / sampleRate;
      const s = t * stepsPerSecond;
      if (s >= nextStep) {
        const eventNote = buffer[pos];
        const eventDeltaStep = buffer[pos + 1];
        note = (pos === 0 ? 60 : note) + eventNote & 127;
        if (eventNote & 128) {
          if (noteOffTime < noteTime) {
            noteOffTime = t;
          }
        } else {
          if (noteOffTime >= noteTime) {
            noteTime = t;
          }
        }
        nextStep += eventDeltaStep;
        pos = (pos + 2) % buffer.length;
      }
      samples++;
      return [
        t - noteTime,
        noteOffTime < noteTime ? 0 : t - noteOffTime,
        note,
        0
      ];
    }).flat());
  };
}

// src/tinyseq/tinyseqFromMidiParseResult.ts
function tinyseqFromMidiParseResult(midi, { track, tickMultiplier } = {}) {
  const data = [];
  let lastNote = 60;
  let delta = 0;
  const trackEvents = midi[1][track != null ? track : 0];
  arraySerial(trackEvents.length + 1).map((i) => {
    var _a, _b, _c, _d, _e, _f;
    delta += ((_b = (_a = trackEvents[i]) == null ? void 0 : _a[0]) != null ? _b : 0) * (tickMultiplier != null ? tickMultiplier : 1);
    if (delta === 0 && i === 0) {
      return;
    }
    const evMsg = (_d = (_c = trackEvents[i - 1]) == null ? void 0 : _c[1]) != null ? _d : 128;
    const evNote = (_f = (_e = trackEvents[i - 1]) == null ? void 0 : _e[2]) != null ? _f : 60;
    if (evMsg >= 160) {
      return;
    }
    const noteDelta = evNote - lastNote + 128 & 127;
    lastNote = evNote;
    const onoff = evMsg < 144 ? 128 : 0;
    let deltaConsume = Math.floor(Math.min(delta, 240));
    data.push(noteDelta + onoff, deltaConsume);
    delta -= deltaConsume;
    while (delta >= 1) {
      deltaConsume = Math.floor(Math.min(delta, 240));
      data.push(onoff, deltaConsume);
      delta -= deltaConsume;
    }
  });
  return new Uint8Array(data);
}

// src/Xorshift/Xorshift.ts
var Xorshift = class {
  constructor(seed) {
    this.seed = seed || 1;
  }
  gen(seed) {
    if (seed) {
      this.seed = seed;
    }
    this.seed = this.seed ^ this.seed << 13;
    this.seed = this.seed ^ this.seed >>> 17;
    this.seed = this.seed ^ this.seed << 5;
    return this.seed / Math.pow(2, 32) + 0.5;
  }
  set(seed) {
    this.seed = seed || this.seed || 1;
  }
};

// src/yugop/getYugopText.ts
function getYugopText(text, phase, randomRatio = 0.5) {
  if (phase >= 1) {
    return text;
  }
  if (phase < 0) {
    return "";
  }
  const displayTween = linearstep(0, 1 - randomRatio, phase);
  const fixTween = linearstep(randomRatio, 1, phase);
  const displayLength = 1 + Math.floor(displayTween * (text.length - 1));
  const fixLength = phase < randomRatio ? 0 : 1 + Math.floor(fixTween * (text.length - 1));
  const randomLength = displayLength - fixLength;
  const randomStr = [...Array(randomLength)].map(() => String.fromCharCode(33 + Math.floor(93 * Math.random()))).join("");
  return text.substring(0, fixLength) + randomStr;
}

// src/BinaryHeap.ts
var BinaryHeap = class {
  static defaultComparator(a, b) {
    const aStr = `${a}`;
    const bStr = `${b}`;
    if (aStr > bStr) {
      return 1;
    } else if (aStr < bStr) {
      return -1;
    } else {
      return 0;
    }
  }
  get length() {
    return this.array.length;
  }
  get isEmpty() {
    return this.array.length === 0;
  }
  get root() {
    return this.array[0];
  }
  constructor(init, comparator) {
    this.array = [];
    this.elementIndexMap = /* @__PURE__ */ new Map();
    this.comparator = comparator != null ? comparator : BinaryHeap.defaultComparator;
    if (init != null) {
      for (const el of init) {
        this.push(el);
      }
    }
  }
  push(...elements) {
    elements.map((el) => {
      const i = this.length;
      this.array.push(el);
      this.elementIndexMap.set(el, i);
      this.__up(i, el);
    });
  }
  pop() {
    if (this.isEmpty) {
      return null;
    }
    const el = this.array[0];
    this.elementIndexMap.delete(el);
    if (this.length === 1) {
      this.array.splice(0);
    } else {
      const rep = this.array.pop();
      this.__down(0, rep);
    }
    return el;
  }
  delete(i) {
    this.elementIndexMap.delete(this.array[i]);
    const rep = this.array.pop();
    if (rep != null) {
      i = this.__up(i, rep);
      i = this.__down(i, rep);
    }
    return true;
  }
  replace(i, rep) {
    if (i != null) {
      this.elementIndexMap.delete(this.array[i]);
      i = this.__up(i, rep);
      i = this.__down(i, rep);
    }
    return i != null ? i : null;
  }
  __up(i, el) {
    let ic = i;
    while (ic !== 0) {
      const ip = ic - 1 >> 1;
      const p = this.array[ip];
      if (this.comparator(el, p) < 0) {
        this.array[ic] = p;
        this.elementIndexMap.set(p, ic);
        ic = ip;
      } else {
        break;
      }
    }
    this.array[ic] = el;
    this.elementIndexMap.set(el, ic);
    return ic;
  }
  __down(i, el) {
    let ip = i;
    while ((ip << 1) + 1 < this.length) {
      const ic1 = (ip << 1) + 1;
      const ic2 = (ip << 1) + 2;
      if (ic2 < this.length) {
        const c1 = this.array[ic1];
        const c2 = this.array[ic2];
        const pickLeft = this.comparator(c1, c2) < 0;
        const c = pickLeft ? c1 : c2;
        const ic = pickLeft ? ic1 : ic2;
        if (this.comparator(c, el) < 0) {
          this.array[ip] = c;
          this.elementIndexMap.set(c, ip);
          ip = ic;
        } else {
          break;
        }
      } else if (this.comparator(this.array[ic1], el) < 0) {
        this.array[ip] = this.array[ic1];
        this.elementIndexMap.set(this.array[ip], ip);
        ip = ic1;
      } else {
        break;
      }
    }
    this.array[ip] = el;
    this.elementIndexMap.set(el, ip);
    return ip;
  }
};

// src/notifyObservers.ts
function notifyObservers(observers, param) {
  for (const observer of observers) {
    observer(param);
  }
}

/*!
 * Turbo colormap
 *
 * Copyright 2019 Google LLC. (Apache-2.0)
 *
 * https://gist.github.com/mikhailov-work/0d177465a8151eb6ede1768d51d476c7
 */

;// CONCATENATED MODULE: ./src/wmath.ts

function fract(a) {
    return _0b5vr_experimental_esm_mod(a, 1);
}
const tau = Math.PI * 2.0;
const pi = Math.PI;
const halfPi = Math.PI / 2;
function max(a, b) {
    return Math.max(a, b);
}
function min(a, b) {
    return Math.min(a, b);
}
function mix(a, b, f) {
    return a * (1.0 - f) + b * f;
}
function log(a) {
    return Math.log(a);
}
function log2(a) {
    return Math.log2(a);
}
class Hash {
    seed = 0;
    constructor(seed = 1251254) {
        Hash.seed = seed;
    }
    static h11(p) {
        p = fract(p * 0.1031);
        p *= p + 33.33;
        p *= p + p;
        return fract(p);
    }
    h11(p) {
        return this.seeded(125124 + p * 1250);
    }
    seeded(a) {
        var t = (a += 0x6d2b79f5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
    valueNoise(a) {
        const fla = floor(a);
        const ceila = fla + 1;
        const rcurr = Hash.h11(fla);
        const rnext = Hash.h11(ceila);
        let fr = fract(a);
        fr = wmath_smoothstep(0, 1, fr);
        return wmath_lerp(rcurr, rnext, fr);
    }
    valueNoiseSmooth(a, smoothness) {
        const fla = floor(a);
        const ceila = fla + 1;
        const rcurr = this.h11(fla);
        const rnext = this.h11(ceila);
        let fr = fract(a);
        for (let i = 0; i < smoothness; i++) {
            if (floor(i) === floor(smoothness)) {
                fr = wmath_lerp(fr, wmath_smoothstep(0, 1, fr), smoothness - i);
                break;
            }
            else {
                fr = wmath_smoothstep(0, 1, fr);
            }
        }
        return wmath_lerp(rcurr, rnext, fr);
    }
}
const r2pi = 0.63661977236;
const nkingSin = (x) => {
    const xtau = x * tau;
    if (xtau - Math.floor(xtau) > pi) {
        const mod = (x - pi) * r2pi - 1;
        return mod * mod - 1;
    }
    else {
        const mod = x * r2pi - 1;
        return 1 - mod * mod;
    }
};
const smoothsin = (x) => {
    const b = x * x * (3.0 - 2.0 * x);
    const a = x * (3 - 1.0 * x);
    return a + (b - a) * b;
};
const oneOverHalfPi = 1 / (pi / 2);
const fastSin = (x) => {
    x *= oneOverHalfPi;
    const id = Math.floor(x);
    x = x % 1;
    let side = 1;
    if ((id - 2) % 4 < 2) {
        side = -1;
    }
    if (id % 2 === 1) {
        x = 1 - x;
    }
    let approx = smoothsin(x);
    approx *= side;
    return approx;
};
function quantize(a, b) {
    return Math.floor(a / b) * b;
}
function dmod(a, b, c = 2) {
    return max(mod(a, b) - b + 2, 0);
}
function abs(a) {
    return Math.abs(a);
}
function sign(a) {
    return a < 0 ? -1 : 1;
}
function tri(a) {
    const fr = a - Math.floor(a);
    return abs(fr - 0.5) * 2 - 1;
}
function sin(a) {
    return Math.sin(a);
}
function cos(a) {
    return Math.cos(a);
}
function floor(a) {
    return Math.floor(a);
}
function pow(a, b) {
    return Math.pow(a, b);
}
function sqrt(a) {
    return Math.sqrt(a);
}
function wmath_wrap(a, from, to) {
    const range = to - from;
    a -= from;
    a = mod(a, range);
    return from + a;
}
const wmath_lerp = (a, b, x) => a + (b - a) * x;
const wmath_clamp = (x, l, h) => Math.min(Math.max(x, l), h);
const wmath_saturate = (x) => Math.min(Math.max(x, 0.0), 1.0);
const wmath_linearstep = (a, b, x) => wmath_saturate((x - a) / (b - a));
const wmath_smoothstep = (a, b, x) => {
    const t = wmath_linearstep(a, b, x);
    return t * t * (3.0 - 2.0 * t);
};
function rand() {
    return Math.random();
}
class Ease {
    static linear(t) {
        ;
        (t) => t;
    }
    static easeInQuad(t) {
        return t * t;
    }
    static easeOutQuad(t) {
        return t * (2 - t);
    }
    static easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    static easeInCubic(t) {
        return t * t * t;
    }
    static easeOutCubic(t) {
        return --t * t * t + 1;
    }
    static easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    }
    static easeInQuart(t) {
        return t * t * t * t;
    }
    static easeOutQuart(t) {
        return 1 - --t * t * t * t;
    }
    static easeInOutQuart(t) {
        return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    }
    static easeInQuint(t) {
        return t * t * t * t * t;
    }
    static easeOutQuint(t) {
        return 1 + --t * t * t * t * t;
    }
    static easeInOutQuint(t) {
        return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    }
    static easeInElastic(t) {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
    }
    static easeOutElastic(t) {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }
}
class WMath {
    static macos(x) {
        return Math.acos(x);
    }
    static masin(x) {
        return Math.asin(x);
    }
    static matan(y, x) {
        return Math.atan2(y, x);
    }
    static mcos(x) {
        return Math.cos(x);
    }
    static msin(x) {
        return Math.sin(x);
    }
    static cos2(x) {
        return [Math.cos(x[0]), Math.cos(x[1])];
    }
    static cos3(x) {
        return [Math.cos(x[0]), Math.cos(x[1]), Math.cos(x[2])];
    }
    static sin2(x) {
        return [Math.sin(x[0]), Math.sin(x[1])];
    }
    static sin3(x) {
        return [Math.sin(x[0]), Math.sin(x[1]), Math.sin(x[2])];
    }
    static sin4(x) {
        return [Math.sin(x[0]), Math.sin(x[1]), Math.sin(x[2]), Math.sin(x[3])];
    }
    static SC(x) {
        return [Math.sin(x), Math.cos(x)];
    }
    static add2(a, b) {
        return [a[0] + b[0], a[1] + b[1]];
    }
    static add3(a, b) {
        return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
    }
    static add31(a, b) {
        return [a[0] + b, a[1] + b, a[2] + b];
    }
    static add4(a, b) {
        return [a[0] + b[0], a[1] + b[1], a[2] + b[2], a[3] + b[3]];
    }
    static sub3(a, b) {
        return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
    }
    static sub2(a, b) {
        return [a[0] - b[0], a[1] - b[1]];
    }
    static dot3(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    static abs3(a) {
        return [a[0] > 0 ? a[0] : -a[0], a[1] > 0 ? a[1] : -a[1], a[2] > 0 ? a[2] : -a[2]];
    }
    static scale2(a, b) {
        return [a[0] * b, a[1] * b];
    }
    static scale3(a, b) {
        return [a[0] * b, a[1] * b, a[2] * b];
    }
    static scale4(a, b) {
        return [a[0] * b, a[1] * b, a[2] * b, a[3] * b];
    }
    static mul3(a, b) {
        return [a[0] * b[0], a[1] * b[1], a[2] * b[2]];
    }
    static mul4(a, b) {
        return [a[0] * b[0], a[1] * b[1], a[2] * b[2], a[3] * b[3]];
    }
    static mymix(a, b, f) {
        return a * (1.0 - f) + b * f;
    }
    static mymix22(a, b, f) {
        return [a[0] * (1.0 - f[0]) + b[0] * f[0], a[1] * (1.0 - f[1]) + b[1] * f[1]];
    }
    static mix1(a, b, f) {
        return a * (1.0 - f) + b * f;
    }
    static mix3(a, b, f) {
        return add3(scale3(a, 1.0 - f), scale3(b, f));
    }
    static length2(a) {
        return Math.sqrt(a[0] * a[0] + a[1] * a[1]);
    }
    static length3(a) {
        return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
    }
    static length4(a) {
        return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3]);
    }
    static normalize3(a) {
        return scale3(a, 1.0 / length3(a));
    }
    static normalize4(a) {
        return scale4(a, 1.0 / length4(a));
    }
    static cross(a, b) {
        return [a[1] * b[2] - b[1] * a[2], a[2] * b[0] - b[2] * a[0], a[0] * b[1] - b[0] * a[1]];
    }
    G = 0.5 + Math.sqrt(5 / 4);
    static fract1(a) {
        return a - Math.floor(a);
    }
    static floor2(a) {
        return [Math.floor(a[0]), Math.floor(a[1])];
    }
    static fract2(a) {
        return [fract1(a[0]), fract1(a[1])];
    }
    static fract3(a) {
        return [fract1(a[0]), fract1(a[1]), fract1(a[2])];
    }
    static fract4(a) {
        return [fract1(a[0]), fract1(a[1]), fract1(a[2]), fract1(a[3])];
    }
    static clamp1(a, a1, a2) {
        return a < a1 ? a1 : a > a2 ? a2 : a;
    }
    static clamp31(a, a1, a2) {
        return [clamp1(a[0], a1, a2), clamp1(a[1], a1, a2), clamp1(a[2], a1, a2)];
    }
    static rotX(ph, v) {
        return [v[0], v[1] * mcos(ph) + v[2] * msin(ph), v[2] * mcos(ph) - v[1] * msin(ph)];
    }
    static rotY(ph, v) {
        return [v[0] * mcos(ph) + v[2] * msin(ph), v[1], v[2] * mcos(ph) - v[0] * msin(ph)];
    }
    static rotZ(ph, v) {
        return [v[0] * mcos(ph) + v[1] * msin(ph), v[1] * mcos(ph) - v[0] * msin(ph), v[2]];
    }
    static hsv2rgb(c) {
        var K = [1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0];
        var p = abs3(sub3(scale3(fract3(add3([c[0], c[0], c[0]], K)), 6.0), [3, 3, 3]));
        return scale3(mix3([1, 1, 1], clamp31(sub3(p, [1, 1, 1]), 0.0, 1.0), c[1]), c[2]);
    }
}

;// CONCATENATED MODULE: ./src/gl/Texture.ts



class Texture {
    tex;
    internal_format;
    format;
    type;
    res;
    is_float;
    mipmapped;
    mip_levels;
    constructor(res, internal_format = gl.RGBA, mipmapped = false, mip_levels = 0) {
        const eq_any = (a, b) => {
            let eq = false;
            b.forEach((b) => {
                if (b === a) {
                    eq = true;
                }
            });
            return eq;
        };
        this.res = [...res];
        this.internal_format = internal_format;
        this.mipmapped = mipmapped;
        this.mip_levels = mip_levels;
        this.is_float = eq_any(internal_format, [gl.RGBA32F, gl.RGBA16F, gl.RGB16F, gl.RGB32F]);
        let comp_cnt = 4;
        if (eq_any(internal_format, [gl.RGBA32F, gl.RGBA16F, gl.RGBA, gl.RGBA16I, gl.RGBA16UI, gl.RGBA32I, gl.RGBA8I, gl.RGBA8UI])) {
            comp_cnt = 4;
        }
        if (eq_any(internal_format, [gl.RGB32F, gl.RGB16F, gl.RGB, gl.RGB16I, gl.RGB16UI, gl.RGB32I, gl.RGB8I, gl.RGB8UI])) {
            comp_cnt = 3;
        }
        this.format = comp_cnt === 4 ? gl.RGBA : gl.RGB;
        this.type = this.is_float ? gl.FLOAT : gl.UNSIGNED_BYTE;
        if (eq_any(internal_format, [gl.RGBA8UI, gl.RGBA16UI, gl.RGBA32UI, gl.RGB8UI, gl.RGB16UI, gl.RGB32UI])) {
            this.type = gl.UNSIGNED_INT;
        }
        if (eq_any(internal_format, [gl.RGBA8I, gl.RGBA16I, gl.RGBA32I, gl.RGB8I, gl.RGB16I, gl.RGB32I])) {
            this.type = gl.INT;
        }
        this.recreate();
    }
    recreate() {
        this.tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.tex);
        if (this.is_float) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        }
        else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (this.mipmapped) {
            if (this.mip_levels === 0) {
                if (this.res[0] > 4 && this.res[1] > 4) {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texStorage2D(gl.TEXTURE_2D, log2(min(this.res[0], this.res[1])), this.internal_format, this.res[0], this.res[1]);
                }
                else {
                    gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, null);
                }
            }
            pause_on_gl_error();
        }
        else {
            gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, null);
        }
        if (!gl.isTexture(this.tex)) {
            console.error('TEXTURE INCOMPLETE');
        }
    }
    resize(new_res) {
        this.res = [...new_res];
        if (this.mipmapped) {
            gl.deleteTexture(this.tex);
            this.recreate();
        }
        else {
            gl.activeTexture(gl.TEXTURE15);
            gl.bindTexture(gl.TEXTURE_2D, this.tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, null);
        }
    }
    static async from_image_path(img_path) {
        function loadImage(url) {
            return new Promise((resolve) => {
                const image = new Image();
                image.addEventListener('load', () => {
                    resolve(image);
                });
                image.src = url;
            });
        }
        const img = await loadImage(img_path);
        const tex = new Texture([img.naturalWidth, img.naturalHeight], gl.RGBA8, true, 0);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, tex.res[0], tex.res[1], tex.format, tex.type, img);
        gl.generateMipmap(gl.TEXTURE_2D);
        pause_on_gl_error();
        gl.finish();
        img.remove();
        return tex;
    }
    upload_from_cpu(image) {
        if (image instanceof HTMLImageElement) {
            gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, image);
        }
        else {
            debugger;
        }
    }
    clone() {
        return new Texture(this.res, this.internal_format, this.mipmapped, this.mip_levels);
    }
    bind_to_unit(unit) {
        gl.activeTexture(gl.TEXTURE0 + unit);
        gl.bindTexture(gl.TEXTURE_2D, this.tex);
    }
    read_back_array(offs = [0, 0], read_back_res = [...this.res]) {
        let temp_fb = gl.createFramebuffer();
        let prev_bound_fb = Framebuffer.currently_bound;
        gl.bindFramebuffer(gl.FRAMEBUFFER, temp_fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.tex, 0);
        const data = this.is_float
            ? new Float32Array(read_back_res[0] * read_back_res[1] * 4)
            : new Uint8Array(read_back_res[0] * read_back_res[1] * 4);
        gl.readPixels(offs[0], offs[1], read_back_res[0], read_back_res[1], this.format, this.type, data);
        gl.deleteFramebuffer(temp_fb);
        gl.bindFramebuffer(gl.FRAMEBUFFER, prev_bound_fb.fb);
        return data;
    }
    read_back_pixel(offs) {
        let data = this.read_back_array(offs, [1, 1]);
        if (this.is_float) {
            data.forEach((e, i, a) => {
                a[i] *= 255;
            });
        }
        data[3] = 255;
        return Array.from(data);
    }
    async read_back_image(gamma_correct = false, offs = [0, 0], read_back_res = [...this.res]) {
        let data = this.read_back_array(offs, read_back_res);
        let i = 0;
        let idx = 0;
        for (let pixel of data) {
            if (i === 3) {
                if (this.is_float) {
                    data[idx] = 255;
                }
                else {
                    data[idx] = 255;
                }
                i = -1;
            }
            else {
                if (gamma_correct) {
                    if (this.is_float) {
                        data[idx] = 255 * pow(data[idx], 0.4545454545);
                    }
                    else {
                        data[idx] = 255 * pow(data[idx] / 255, 0.4545454545);
                    }
                }
            }
            idx++;
            i++;
        }
        const canvas = document.createElement('canvas');
        canvas.width = this.res[0];
        canvas.height = this.res[1];
        const context = canvas.getContext('2d');
        let blob;
        const getCanvasBlob = (canvas) => {
            return new Promise(function (resolve, reject) {
                canvas.toBlob(function (blob) {
                    resolve(blob);
                }, 'image/png');
            });
        };
        blob = await getCanvasBlob(canvas);
        console.log('BLORGUBS');
        console.log(blob);
        const imageData = context.createImageData(canvas.width, canvas.height);
        imageData.data.set(data);
        context.putImageData(imageData, 0, 0);
        const img = new Image();
        img.src = canvas.toDataURL();
        canvas.remove();
        return [img, blob];
    }
}

;// CONCATENATED MODULE: ./src/gl/Framebuffer.ts

class Framebuffer {
    static currently_bound;
    static framebuffers = [];
    _textures;
    _back_textures;
    _fb;
    _fb_back = undefined;
    default = false;
    pongable = false;
    needs_pong = false;
    pong_idx = 0;
    get textures() {
        if (this.pong_idx === 0)
            return this._textures;
        else
            return this._back_textures;
    }
    get back_textures() {
        if (this.pong_idx === 0)
            return this._back_textures;
        else
            return this._textures;
    }
    get fb() {
        if (this.pong_idx === 0)
            return this._fb;
        else
            return this._fb_back;
    }
    get fb_back() {
        if (this.pong_idx === 0)
            return this._fb_back;
        else
            return this._fb;
    }
    pong() {
        this.pong_idx = 1 - this.pong_idx;
        this.needs_pong = false;
    }
    recreate() {
        if (this.pongable) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fb_back);
            let i = 0;
            for (let tex of this._back_textures) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, tex.tex, 0);
            }
            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                console.error('FRAMEBUFFER INCOMPLETE');
            }
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fb);
        let i = 0;
        for (let tex of this._textures) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, tex.tex, 0);
            i++;
        }
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
            console.error('FRAMEBUFFER INCOMPLETE');
        }
    }
    constructor(textures, pongable = false) {
        this._fb = gl.createFramebuffer();
        this._textures = [...textures];
        this.pongable = pongable;
        this._back_textures = [];
        if (this.pongable) {
            this._fb_back = gl.createFramebuffer();
            for (let tex of this.textures) {
                this._back_textures.push(tex.clone());
            }
        }
        this.recreate();
        gl.bindFramebuffer(gl.FRAMEBUFFER, Framebuffer.currently_bound._fb);
        Framebuffer.framebuffers.push(this);
    }
    bind() {
        if (this.pongable)
            this.needs_pong = true;
        let draw_buffs = [];
        if (this.default) {
            draw_buffs = [gl.BACK];
        }
        else {
            let i = 0;
            for (let tex of this.textures) {
                draw_buffs.push(gl.COLOR_ATTACHMENT0 + i);
                i++;
            }
        }
        gl.viewport(0, 0, this.textures[0].res[0], this.textures[0].res[1]);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);
        Framebuffer.currently_bound = this;
    }
    clear(colour = [0, 0, 0, 0]) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);
        gl.clearColor(colour[0], colour[1], colour[2], colour[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, Framebuffer.currently_bound.fb);
    }
}

;// CONCATENATED MODULE: ./src/gl_utils.ts


function init_gl_error_handling() {
    if (!gl.debugEnabled)
        return;
    gl.glEnums = {};
    gl.enumStringToValue = {};
    for (let propertyName in gl) {
        if (typeof gl[propertyName] === 'number') {
            gl.glEnums[gl[propertyName]] = propertyName;
            gl.enumStringToValue[propertyName] = gl[propertyName];
        }
    }
}
function gl_enum_to_string(value) {
    const name = window.gl.glEnums[value];
    return name !== undefined ? 'gl.' + name : '/*UNKNOWN WebGL ENUM*/ 0x' + value.toString(16) + '';
}
function print_on_gl_error() {
    if (!gl.debugEnabled)
        return;
    let err = window.gl.getError();
    if (err !== 0) {
        console.error(err);
        console.error(gl_enum_to_string(err));
    }
}
function pause_on_gl_error() {
    if (!gl.debugEnabled)
        return;
    let err = window.gl.getError();
    if (err !== 0) {
        console.error(err);
        console.error(gl_enum_to_string(err));
        debugger;
    }
}
function copy_fb_to_texture(in_framebuffer, out_texture) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, in_framebuffer);
    gl.bindTexture(gl.TEXTURE_2D, out_texture.tex);
    gl.copyTexImage2D(gl.TEXTURE_2D, 0, out_texture.internal_format, 0, 0, out_texture.res[0], out_texture.res[1], 0);
}
function copy_fb_to_fb(in_framebuffer, out_framebuffer, res) {
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, in_framebuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, out_framebuffer);
    gl.blitFramebuffer(0, 0, res[0], res[1], 0, 0, res[0], res[1], gl.COLOR_BUFFER_BIT, gl.NEAREST);
}
function resizeIfNeeded(canvas, default_framebuffer, client_res, set_redraw_needed, set_shared_uniforms) {
    const displayWidth = canvas.clientWidth;
    const displayHeight = canvas.clientHeight;
    const needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;
    if (needResize) {
        client_res[0] = canvas.width = displayWidth;
        client_res[1] = canvas.height = displayHeight;
        set_redraw_needed(true);
        default_framebuffer._textures[0].res = [...client_res];
        set_shared_uniforms();
    }
    return needResize;
}

;// CONCATENATED MODULE: ./src/components/SemiModal.svelte
/* src/components/SemiModal.svelte generated by Svelte v4.0.0 */




const file = "src/components/SemiModal.svelte";

function add_css(target) {
	append_styles(target, "svelte-khmjsp", "#bar.svelte-khmjsp.svelte-khmjsp{background:black;width:100%;height:100px;display:flex;padding:0rem 1rem;align-items:center;justify-content:flex-end}#bar.svelte-khmjsp>.svelte-khmjsp:last-of-type{margin-left:auto;margin-right:0px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VtaU1vZGFsLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFla0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2VtaU1vZGFsLnN2ZWx0ZSJdfQ== */");
}

function create_fragment(ctx) {
	let div;
	let div_style_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	const block = {
		c: function create() {
			div = dom_element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "id", "bar");
			attr_dev(div, "style", div_style_value = /*hidden*/ ctx[0] ? "display: none;" : "");
			attr_dev(div, "class", "svelte-khmjsp");
			add_location(div, file, 11, 0, 137);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*hidden*/ 1 && div_style_value !== (div_style_value = /*hidden*/ ctx[0] ? "display: none;" : "")) {
				attr_dev(div, "style", div_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('SemiModal', slots, ['default']);
	let { hidden = true } = $$props;
	let { knob } = $$props;

	$$self.$$.on_mount.push(function () {
		if (knob === undefined && !('knob' in $$props || $$self.$$.bound[$$self.$$.props['knob']])) {
			console.warn("<SemiModal> was created without expected prop 'knob'");
		}
	});

	const writable_props = ['hidden', 'knob'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SemiModal> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('hidden' in $$props) $$invalidate(0, hidden = $$props.hidden);
		if ('knob' in $$props) $$invalidate(1, knob = $$props.knob);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ Knob: Knob_svelte, hidden, knob });

	$$self.$inject_state = $$props => {
		if ('hidden' in $$props) $$invalidate(0, hidden = $$props.hidden);
		if ('knob' in $$props) $$invalidate(1, knob = $$props.knob);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [hidden, knob, $$scope, slots];
}

class SemiModal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { hidden: 0, knob: 1 }, add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SemiModal",
			options,
			id: create_fragment.name
		});
	}

	get hidden() {
		return this.$$.ctx[0];
	}

	set hidden(hidden) {
		this.$$set({ hidden });
		scheduler_flush();
	}

	get knob() {
		return this.$$.ctx[1];
	}

	set knob(knob) {
		this.$$set({ knob });
		scheduler_flush();
	}
}

/* harmony default export */ const SemiModal_svelte = (SemiModal);
;// CONCATENATED MODULE: ./src/components/Knob.svelte
/* src/components/Knob.svelte generated by Svelte v4.0.0 */






const Knob_svelte_file = "src/components/Knob.svelte";

function Knob_svelte_add_css(target) {
	append_styles(target, "svelte-dko0zj", ".svelte-dko0zj.svelte-dko0zj{user-select:none;-webkit-tap-highlight-color:transparent}.knob-container-container.svelte-dko0zj.svelte-dko0zj{aspect-ratio:1/1;max-height:50%;margin-top:0.5rem;margin-right:0.5rem;display:flex;flex-direction:column;justify-content:center;align-items:center;pointer-events:all;user-select:none}.knob-container.svelte-dko0zj.svelte-dko0zj{box-sizing:border-box;-webkit-box-sizing:border-box;&:hover{\n      cursor: pointer;\n    };aspect-ratio:1/1;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;background-image:conic-gradient(from 45deg,\n      var(--secondary-color) 0deg 15deg,\n      var(--tertiary-color) 60deg 60deg,\n      var(--darken-color) 120deg 240deg,\n      var(--tertiary-color) 300deg 300deg,\n      var(--secondary-color) 345deg 360deg\n    );box-shadow:-.15em .15em .05em .02em rgba(0, 0, 0, 0.3);border-radius:50%;border:0.2rem solid white}.knob-container-container.svelte-dko0zj>.title.menu-toggle.svelte-dko0zj{background:white;color:black}.knob-container-container.svelte-dko0zj>.title.svelte-dko0zj{cursor:pointer;font-size:0.8rem !important;margin-top:0.5rem;color:white;width:100%;text-align:center;font-weight:bolder;top:5.5rem;user-select:none}.knob.svelte-dko0zj.svelte-dko0zj{display:block;aspect-ratio:1/1;height:100%;padding:0;border-radius:50%;color:var(--text-color);background-color:var(--tertiary-color);box-shadow:0 0 .3em rgba(255, 255, 255, 0.3) inset;transform-origin:50% 50%}.knob.svelte-dko0zj svg.svelte-dko0zj{width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}

function Knob_svelte_create_fragment(ctx) {
	let div3;
	let div1;
	let div0;
	let svg;
	let g;
	let path;
	let t0;
	let div2;
	let t1;
	let div2_class_value;
	let div2_style_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div3 = dom_element("div");
			div1 = dom_element("div");
			div0 = dom_element("div");
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			t0 = space();
			div2 = dom_element("div");
			t1 = dom_text(/*title*/ ctx[3]);
			attr_dev(path, "stroke-width", "10");
			attr_dev(path, "d", "M50 40 l0 -50");
			attr_dev(path, "class", "svelte-dko0zj");
			add_location(path, Knob_svelte_file, 80, 10, 2045);
			attr_dev(g, "fill", "none");
			attr_dev(g, "stroke", "currentColor");
			attr_dev(g, "class", "svelte-dko0zj");
			add_location(g, Knob_svelte_file, 79, 8, 1997);
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "0 0 100 100");
			attr_dev(svg, "class", "svelte-dko0zj");
			add_location(svg, Knob_svelte_file, 78, 6, 1934);
			attr_dev(div0, "class", "knob svelte-dko0zj");
			set_style(div0, "transform", "rotate(calc(" + /*rotation*/ ctx[5] + " * 1rad))");
			add_location(div0, Knob_svelte_file, 77, 4, 1829);
			attr_dev(div1, "class", "knob-container svelte-dko0zj");
			add_location(div1, Knob_svelte_file, 76, 2, 1796);
			attr_dev(div2, "class", div2_class_value = "title " + (/*triggerModal*/ ctx[1] ? "menu-toggle" : "") + " svelte-dko0zj");
			attr_dev(div2, "style", div2_style_value = "" + ((!/*modalHidden*/ ctx[0] && "outline: 1px solid white; outline-offset: 0.1rem;") + " " + (/*modal*/ ctx[2] && "cursor: pointer;")));
			add_location(div2, Knob_svelte_file, 85, 2, 2138);
			attr_dev(div3, "draggable", "false");
			attr_dev(div3, "class", "knob-container-container svelte-dko0zj");
			add_location(div3, Knob_svelte_file, 75, 0, 1737);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div1);
			append_dev(div1, div0);
			append_dev(div0, svg);
			append_dev(svg, g);
			append_dev(g, path);
			append_dev(div3, t0);
			append_dev(div3, div2);
			append_dev(div2, t1);
			/*div2_binding*/ ctx[8](div2);

			if (!mounted) {
				dispose = listen_dev(div0, "pointerdown", /*pointerDown*/ ctx[6], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*rotation*/ 32) {
				set_style(div0, "transform", "rotate(calc(" + /*rotation*/ ctx[5] + " * 1rad))");
			}

			if (dirty & /*title*/ 8) set_data_dev(t1, /*title*/ ctx[3]);

			if (dirty & /*triggerModal*/ 2 && div2_class_value !== (div2_class_value = "title " + (/*triggerModal*/ ctx[1] ? "menu-toggle" : "") + " svelte-dko0zj")) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (dirty & /*modalHidden, modal*/ 5 && div2_style_value !== (div2_style_value = "" + ((!/*modalHidden*/ ctx[0] && "outline: 1px solid white; outline-offset: 0.1rem;") + " " + (/*modal*/ ctx[2] && "cursor: pointer;")))) {
				attr_dev(div2, "style", div2_style_value);
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div3);
			}

			/*div2_binding*/ ctx[8](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Knob_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function Knob_svelte_clamp(num, min, max) {
	return Math.max(min, Math.min(num, max));
}

function Knob_svelte_instance($$self, $$props, $$invalidate) {
	let rotation;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Knob', slots, []);
	let { value } = $$props;
	let { triggerModal = undefined } = $$props;
	let { modal = undefined } = $$props;
	let knobElement;
	let { modalHidden = true } = $$props;
	let { title = "" } = $$props;
	const rotRange = 2 * Math.PI * 0.83;
	let startY = 0;
	let startX = 0;
	let startValue = 0;

	function pointerMove({ clientX, clientY }) {
		let scale = 3. / min(document.documentElement.clientWidth, document.documentElement.clientHeight);
		let valueDiff = (startY - clientY) * scale;
		valueDiff -= (startX - clientX) * scale;
		$$invalidate(7, value = Knob_svelte_clamp(startValue + valueDiff, 0, 1));
	}

	function pointerDown(e) {
		let { clientX, clientY } = e;
		startY = clientY;
		startX = clientX;
		startValue = value;
		window.addEventListener('pointermove', pointerMove);
		window.addEventListener('pointerup', pointerUp);
		e.stopPropagation();
	}

	function pointerUp() {
		window.removeEventListener('pointermove', pointerMove);
		window.removeEventListener('pointerup', pointerUp);
	}

	let titleElement;

	onMount(() => {
		let pointerDown;

		let pointerUp = () => {
			if (modal) {
				triggerModal?.(modal);
				$$invalidate(0, modalHidden = modal.hidden);
			}

			titleElement.removeEventListener("pointerdown", pointerDown);
		};

		pointerDown = () => {
			titleElement.removeEventListener("pointerup", pointerUp);
			titleElement.addEventListener("pointerup", pointerUp);
		};

		titleElement.addEventListener("pointerdown", pointerDown);
	});

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<Knob> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value', 'triggerModal', 'modal', 'modalHidden', 'title'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Knob> was created with unknown prop '${key}'`);
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			titleElement = $$value;
			$$invalidate(4, titleElement);
		});
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(7, value = $$props.value);
		if ('triggerModal' in $$props) $$invalidate(1, triggerModal = $$props.triggerModal);
		if ('modal' in $$props) $$invalidate(2, modal = $$props.modal);
		if ('modalHidden' in $$props) $$invalidate(0, modalHidden = $$props.modalHidden);
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
	};

	$$self.$capture_state = () => ({
		min: min,
		SemiModal: SemiModal_svelte,
		onMount: onMount,
		value,
		triggerModal,
		modal,
		knobElement,
		modalHidden,
		title,
		rotRange,
		startY,
		startX,
		startValue,
		clamp: Knob_svelte_clamp,
		pointerMove,
		pointerDown,
		pointerUp,
		titleElement,
		rotation
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(7, value = $$props.value);
		if ('triggerModal' in $$props) $$invalidate(1, triggerModal = $$props.triggerModal);
		if ('modal' in $$props) $$invalidate(2, modal = $$props.modal);
		if ('knobElement' in $$props) knobElement = $$props.knobElement;
		if ('modalHidden' in $$props) $$invalidate(0, modalHidden = $$props.modalHidden);
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
		if ('startY' in $$props) startY = $$props.startY;
		if ('startX' in $$props) startX = $$props.startX;
		if ('startValue' in $$props) startValue = $$props.startValue;
		if ('titleElement' in $$props) $$invalidate(4, titleElement = $$props.titleElement);
		if ('rotation' in $$props) $$invalidate(5, rotation = $$props.rotation);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 128) {
			$: $$invalidate(5, rotation = -Math.PI * 0.83 + value * rotRange);
		}
	};

	return [
		modalHidden,
		triggerModal,
		modal,
		title,
		titleElement,
		rotation,
		pointerDown,
		value,
		div2_binding
	];
}

class Knob extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			Knob_svelte_instance,
			Knob_svelte_create_fragment,
			safe_not_equal,
			{
				value: 7,
				triggerModal: 1,
				modal: 2,
				modalHidden: 0,
				title: 3
			},
			Knob_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Knob",
			options,
			id: Knob_svelte_create_fragment.name
		});
	}

	get value() {
		return this.$$.ctx[7];
	}

	set value(value) {
		this.$$set({ value });
		scheduler_flush();
	}

	get triggerModal() {
		return this.$$.ctx[1];
	}

	set triggerModal(triggerModal) {
		this.$$set({ triggerModal });
		scheduler_flush();
	}

	get modal() {
		return this.$$.ctx[2];
	}

	set modal(modal) {
		this.$$set({ modal });
		scheduler_flush();
	}

	get modalHidden() {
		return this.$$.ctx[0];
	}

	set modalHidden(modalHidden) {
		this.$$set({ modalHidden });
		scheduler_flush();
	}

	get title() {
		return this.$$.ctx[3];
	}

	set title(title) {
		this.$$set({ title });
		scheduler_flush();
	}
}

/* harmony default export */ const Knob_svelte = (Knob);
// EXTERNAL MODULE: ./public/copy.svg
var copy = __webpack_require__(399);
var copy_default = /*#__PURE__*/__webpack_require__.n(copy);
;// CONCATENATED MODULE: ./src/components/BrushSizeWidget.svelte
/* src/components/BrushSizeWidget.svelte generated by Svelte v4.0.0 */


const { console: console_1 } = globals;


const BrushSizeWidget_svelte_file = "src/components/BrushSizeWidget.svelte";

function BrushSizeWidget_svelte_add_css(target) {
	append_styles(target, "svelte-1opwpu0", ".svelte-1opwpu0{user-select:none;-webkit-tap-highlight-color:transparent}.knob-container.svelte-1opwpu0{cursor:pointer;box-sizing:border-box;-webkit-box-sizing:border-box;aspect-ratio:1/1;max-height:50%;height:100%;display:flex;justify-content:center;align-items:center;border-radius:50%;margin-right:1rem;margin-bottom:auto;margin-top:auto;pointer-events:all;user-select:none}.knob-container.svelte-1opwpu0:hover{cursor:pointer}.knob.svelte-1opwpu0{display:block;aspect-ratio:1/1;height:100%;padding:0;color:var(--text-color);fill:white;transform-origin:50% 50%}.knob.svelte-1opwpu0:active{filter:invert(1);background:black}.knob.svelte-1opwpu0 svg{fill:white;width:100%;height:100%}.knob-container-container.svelte-1opwpu0{max-height:unset !important;display:flex;align-items:center;height:100%}.knob-container-container.svelte-1opwpu0:hover{cursor:pointer}.knob-container.svelte-1opwpu0{padding:0.3rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnJ1c2hTaXplV2lkZ2V0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE2RWtCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJydXNoU2l6ZVdpZGdldC5zdmVsdGUiXX0= */");
}

function BrushSizeWidget_svelte_create_fragment(ctx) {
	let div2;
	let div1;
	let div0;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div2 = dom_element("div");
			div1 = dom_element("div");
			div0 = dom_element("div");
			attr_dev(div0, "class", "knob svelte-1opwpu0");
			add_location(div0, BrushSizeWidget_svelte_file, 4, 2, 161);
			attr_dev(div1, "class", "knob-container svelte-1opwpu0");
			add_location(div1, BrushSizeWidget_svelte_file, 3, 1, 130);
			attr_dev(div2, "class", "knob-container-container svelte-1opwpu0");
			toggle_class(div2, "knob-selected", /*dragging*/ ctx[0]);
			add_location(div2, BrushSizeWidget_svelte_file, 2, 0, 30);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, div0);
			div0.innerHTML = (copy_default());

			if (!mounted) {
				dispose = listen_dev(div2, "pointerdown", /*pointerDown*/ ctx[1], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*dragging*/ 1) {
				toggle_class(div2, "knob-selected", /*dragging*/ ctx[0]);
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div2);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BrushSizeWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function BrushSizeWidget_svelte_clamp(num, min, max) {
	return Math.max(min, Math.min(num, max));
}

function BrushSizeWidget_svelte_instance($$self, $$props, $$invalidate) {
	let valueRange;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BrushSizeWidget', slots, []);
	let { brush_sz = [0.2, 0.2] } = $$props;
	let { pixelRange = 200 } = $$props;
	let value = [0, 0];
	let min = 0;
	let max = 4;
	let { dragging = false } = $$props;
	let { stopped_dragging = false } = $$props;
	let startY = 0, startValue = [0, 0], startX = 0;

	function pointerMove({ clientX, clientY }) {
		let valueDiffY = valueRange * (startY - clientY) / pixelRange;
		let valueDiffX = valueRange * (startX - clientX) / pixelRange;
		$$invalidate(2, brush_sz[0] = BrushSizeWidget_svelte_clamp(startValue[0] - valueDiffX, min, max), brush_sz);
		$$invalidate(2, brush_sz[1] = BrushSizeWidget_svelte_clamp(startValue[1] + valueDiffY, min, max), brush_sz);
	}

	function pointerDown(e) {
		$$invalidate(0, dragging = true);
		let { clientX, clientY } = e;
		console.log('down');
		startY = clientY;
		startX = clientX;
		startValue = [...brush_sz];
		window.addEventListener('pointermove', pointerMove);
		window.addEventListener('pointerup', pointerUp);
		e.stopPropagation();
	}

	function pointerUp() {
		$$invalidate(0, dragging = false);
		$$invalidate(3, stopped_dragging = true);
		console.log('up');
		window.removeEventListener('pointermove', pointerMove);
		window.removeEventListener('pointerup', pointerUp);
	}

	const writable_props = ['brush_sz', 'pixelRange', 'dragging', 'stopped_dragging'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<BrushSizeWidget> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('brush_sz' in $$props) $$invalidate(2, brush_sz = $$props.brush_sz);
		if ('pixelRange' in $$props) $$invalidate(4, pixelRange = $$props.pixelRange);
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
		if ('stopped_dragging' in $$props) $$invalidate(3, stopped_dragging = $$props.stopped_dragging);
	};

	$$self.$capture_state = () => ({
		brushSizeIcon: (copy_default()),
		brush_sz,
		pixelRange,
		value,
		min,
		max,
		dragging,
		stopped_dragging,
		startY,
		startValue,
		startX,
		clamp: BrushSizeWidget_svelte_clamp,
		pointerMove,
		pointerDown,
		pointerUp,
		valueRange
	});

	$$self.$inject_state = $$props => {
		if ('brush_sz' in $$props) $$invalidate(2, brush_sz = $$props.brush_sz);
		if ('pixelRange' in $$props) $$invalidate(4, pixelRange = $$props.pixelRange);
		if ('value' in $$props) value = $$props.value;
		if ('min' in $$props) $$invalidate(10, min = $$props.min);
		if ('max' in $$props) $$invalidate(11, max = $$props.max);
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
		if ('stopped_dragging' in $$props) $$invalidate(3, stopped_dragging = $$props.stopped_dragging);
		if ('startY' in $$props) startY = $$props.startY;
		if ('startValue' in $$props) startValue = $$props.startValue;
		if ('startX' in $$props) startX = $$props.startX;
		if ('valueRange' in $$props) valueRange = $$props.valueRange;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$: valueRange = max - min;
	return [dragging, pointerDown, brush_sz, stopped_dragging, pixelRange];
}

class BrushSizeWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			BrushSizeWidget_svelte_instance,
			BrushSizeWidget_svelte_create_fragment,
			safe_not_equal,
			{
				brush_sz: 2,
				pixelRange: 4,
				dragging: 0,
				stopped_dragging: 3
			},
			BrushSizeWidget_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BrushSizeWidget",
			options,
			id: BrushSizeWidget_svelte_create_fragment.name
		});
	}

	get brush_sz() {
		return this.$$.ctx[2];
	}

	set brush_sz(brush_sz) {
		this.$$set({ brush_sz });
		scheduler_flush();
	}

	get pixelRange() {
		return this.$$.ctx[4];
	}

	set pixelRange(pixelRange) {
		this.$$set({ pixelRange });
		scheduler_flush();
	}

	get dragging() {
		return this.$$.ctx[0];
	}

	set dragging(dragging) {
		this.$$set({ dragging });
		scheduler_flush();
	}

	get stopped_dragging() {
		return this.$$.ctx[3];
	}

	set stopped_dragging(stopped_dragging) {
		this.$$set({ stopped_dragging });
		scheduler_flush();
	}
}

/* harmony default export */ const BrushSizeWidget_svelte = (BrushSizeWidget);
;// CONCATENATED MODULE: ./src/stuff.ts



function assert(v) {
    if (!v)
        debugger;
}
class BrushTexture {
    gpu_tex = undefined;
    path = undefined;
    idx;
    static async create(path, idx) {
        let gpu_tex = await Texture.from_image_path(path);
        return {
            gpu_tex,
            path,
            idx,
        };
    }
}
class Project {
    id = Date.now();
    saved = false;
    brush_strokes = [];
    canvasRes = [1024, 2048];
    constructor() { }
    push_stroke(stroke) {
        this.brush_strokes.push(stroke);
    }
}
class Utils {
    static isOnMobile = () => {
        let check = false;
        (function (a) {
            if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) ||
                /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
                check = true;
        })(navigator.userAgent || navigator.vendor || window.opera);
        return check;
    };
    static gamma_correct(u, inverse = false, modify = false) {
        const exponent = inverse ? 1 / 0.45454545454545 : 0.45454545454545;
        if (!modify)
            u = [...u];
        u.forEach((v, i, a) => {
            a[i] = pow(v, exponent);
        });
        return u;
    }
    static css_contain(u, input_res, tex_res) {
        let user_res = input_res;
        let canvas_res = tex_res;
        let input_ratio = user_res[0] / user_res[1];
        let tex_ratio = canvas_res[0] / canvas_res[1];
        let ratio = input_ratio / tex_ratio;
        if (ratio > 1) {
            return [u[0] * ratio, u[1]];
        }
        else {
            return [u[0], u[1] / ratio];
        }
    }
    static screen_NDC_to_canvas_NDC(u, user_tex, canvas_tex, zoom, pan) {
        let user_res = user_tex.res;
        let canvas_res = canvas_tex.res;
        u = [...u];
        let input_ratio = user_res[0] / user_res[1];
        let tex_ratio = canvas_res[0] / canvas_res[1];
        let ratio = input_ratio / tex_ratio;
        if (ratio > 1) {
            u[0] *= ratio / zoom;
            u[1] /= zoom;
            let cont = Utils.css_contain([1, 1], user_res, canvas_res);
            u[0] -= pan[0] * cont[0];
            u[1] -= pan[1] * cont[1];
        }
        else {
            u[0] /= zoom;
            u[1] /= ratio * zoom;
            let cont = Utils.css_contain([1, 1], user_res, canvas_res);
            u[0] -= pan[0] * cont[0];
            u[1] -= pan[1] * cont[1];
        }
        return u;
    }
    static texture_NDC_to_texture_pixel_coords(u, tex) {
        return [(u[0] * 0.5 + 0.5) * tex.res[0], (u[1] * 0.5 + 0.5) * tex.res[1]];
    }
}

;// CONCATENATED MODULE: ./src/brush_stroke.ts

var BlendingColourSpace;
(function (BlendingColourSpace) {
    BlendingColourSpace[BlendingColourSpace["RGB"] = 0] = "RGB";
    BlendingColourSpace[BlendingColourSpace["OkLCH"] = 1] = "OkLCH";
    BlendingColourSpace[BlendingColourSpace["Pigments"] = 2] = "Pigments";
})(BlendingColourSpace || (BlendingColourSpace = {}));
class DrawParams {
    tex_dynamics = 0.3;
    tex_lch_dynamics = [0, 0, 0.2];
    tex_stretch = [1, 0.2];
    blending_colour_space = BlendingColourSpace.Pigments;
    constructor(tex_dynamics, tex_lch_dynamics, tex_stretch, blending_colour_space) {
        this.tex_dynamics = tex_dynamics;
        this.tex_lch_dynamics = [...tex_lch_dynamics];
        this.tex_stretch = [...tex_stretch];
        this.blending_colour_space = blending_colour_space;
    }
}
class BrushPreset {
    selected_brush_type = BrushType.Blobs;
    chaos_lch = [0, 0, 1];
    chaos_speed = 0.3;
    chaos = 0.7;
    dynamics = 0.3;
    stroke_opacity_dynamics = [0, 1];
    stroke_size_dynamics = [0.7, 1];
    rot_jitter = 0;
    pos_jitter = 0;
    selected_brush_texture = undefined;
    tex_dynamics = 0.3;
    tex_lch_dynamics = [0, 0, 0.02];
    tex_stretch = [1, 0.2];
    constructor() { }
}
var BrushType;
(function (BrushType) {
    BrushType[BrushType["Blobs"] = 0] = "Blobs";
    BrushType[BrushType["Long"] = 1] = "Long";
    BrushType[BrushType["Tri"] = 2] = "Tri";
})(BrushType || (BrushType = {}));
class BrushStroke {
    brush_type;
    brush_texture;
    draw_params;
    positions = [];
    rotations = [];
    sizes = [];
    opacities = [];
    colours = [];
    idx = 0;
    constructor(brush_type, draw_params, brush_texture) {
        this.draw_params = draw_params;
        this.brush_type = brush_type;
        this.brush_texture = brush_texture;
    }
    push_stroke(position, rotation, size, opacity, colour) {
        const curr_idx = this.idx;
        this.positions.length += 2;
        this.rotations.length += 2;
        this.sizes.length += 2;
        this.opacities.length += 1;
        this.colours.length += 3;
        this.positions[curr_idx * 2] = position[0];
        this.positions[curr_idx * 2 + 1] = position[1];
        this.sizes[curr_idx * 2] = size[0];
        this.sizes[curr_idx * 2 + 1] = size[1];
        this.rotations[curr_idx * 2] = rotation[0];
        this.rotations[curr_idx * 2 + 1] = rotation[1];
        this.opacities[curr_idx] = opacity;
        this.colours[curr_idx * 3] = colour[0];
        this.colours[curr_idx * 3 + 1] = colour[1];
        this.colours[curr_idx * 3 + 2] = colour[2];
        this.idx++;
    }
}

// EXTERNAL MODULE: ./public/brush-blobs.svg
var brush_blobs = __webpack_require__(36);
var brush_blobs_default = /*#__PURE__*/__webpack_require__.n(brush_blobs);
// EXTERNAL MODULE: ./public/brush-long.svg
var brush_long = __webpack_require__(212);
var brush_long_default = /*#__PURE__*/__webpack_require__.n(brush_long);
// EXTERNAL MODULE: ./public/brush-triangles.svg
var brush_triangles = __webpack_require__(504);
var brush_triangles_default = /*#__PURE__*/__webpack_require__.n(brush_triangles);
;// CONCATENATED MODULE: ./src/components/BrushTypeWidget.svelte
/* src/components/BrushTypeWidget.svelte generated by Svelte v4.0.0 */


const { Object: Object_1 } = globals;






const BrushTypeWidget_svelte_file = "src/components/BrushTypeWidget.svelte";

function BrushTypeWidget_svelte_add_css(target) {
	append_styles(target, "svelte-1qy0pvu", ".svelte-1qy0pvu.svelte-1qy0pvu{user-select:none;-webkit-tap-highlight-color:transparent}.knob-container-container.svelte-1qy0pvu.svelte-1qy0pvu{aspect-ratio:1/1;max-height:50%;margin-top:0.5rem;margin-bottom:auto;margin-right:1.5rem;display:flex;flex-direction:column;justify-content:center;align-items:center;pointer-events:all;user-select:none;cursor:pointer;min-width:7rem;height:100%;display:flex;margin:0;margin-right:0.5rem;min-height:unset;min-width:unset;max-height:1.6rem !important}.knob-container-container.svelte-1qy0pvu>.title.menu-toggle.svelte-1qy0pvu{}.knob-container-container.svelte-1qy0pvu>.title.menu-toggle.svelte-1qy0pvu svg{fill:white}.knob-container-container.svelte-1qy0pvu>.title.menu-toggle.svelte-1qy0pvu svg:active{filter:invert(1);background:black}.knob-container-container.svelte-1qy0pvu>.title.svelte-1qy0pvu{font-size:0.8rem !important;margin-top:0.5rem;color:white;width:100%;text-align:center;font-weight:bolder;top:5.5rem;user-select:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnJ1c2hUeXBlV2lkZ2V0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFxRmtCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJydXNoVHlwZVdpZGdldC5zdmVsdGUiXX0= */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	child_ctx[8] = list;
	child_ctx[9] = i;
	return child_ctx;
}

// (46:2) {#each brush_types as brush_type, i}
function create_each_block(ctx) {
	let div;
	let html_tag;

	let raw_value = (/*i*/ ctx[9] === 0
	? (brush_blobs_default())
	: /*i*/ ctx[9] === 1
		? (brush_long_default())
		: (brush_triangles_default())) + "";

	let t;
	let i = /*i*/ ctx[9];
	let mounted;
	let dispose;
	const assign_div = () => /*div_binding*/ ctx[3](div, i);
	const unassign_div = () => /*div_binding*/ ctx[3](null, i);

	function click_handler() {
		return /*click_handler*/ ctx[4](/*brush_type*/ ctx[7], /*i*/ ctx[9]);
	}

	const block = {
		c: function create() {
			div = dom_element("div");
			html_tag = new HtmlTag(false);
			t = space();
			html_tag.a = t;
			attr_dev(div, "class", "title menu-toggle svelte-1qy0pvu");
			attr_dev(div, "role", "button");
			attr_dev(div, "tabindex", "0");
			set_style(div, "cursor", "pointer");
			add_location(div, BrushTypeWidget_svelte_file, 59, 4, 1295);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			html_tag.m(raw_value, div);
			append_dev(div, t);
			assign_div();

			if (!mounted) {
				dispose = listen_dev(div, "click", click_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (i !== /*i*/ ctx[9]) {
				unassign_div();
				i = /*i*/ ctx[9];
				assign_div();
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			unassign_div();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(46:2) {#each brush_types as brush_type, i}",
		ctx
	});

	return block;
}

function BrushTypeWidget_svelte_create_fragment(ctx) {
	let div;
	let each_value = ensure_array_like_dev(/*brush_types*/ ctx[2]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "knob-container-container svelte-1qy0pvu");
			add_location(div, BrushTypeWidget_svelte_file, 57, 0, 1213);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*elements, curr_brush, BrushType, brush_types, brush_blobs_icon, brush_long_icon, brush_triangles_icon*/ 7) {
				each_value = ensure_array_like_dev(/*brush_types*/ ctx[2]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BrushTypeWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function BrushTypeWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BrushTypeWidget', slots, []);
	let { curr_brush } = $$props;
	let selected_brush_type;
	let elements = [];
	let brush_types = [];

	for (let type of Object.keys(BrushType).filter(v => isNaN(Number(v)))) {
		brush_types.push(type);
		elements.length++;
	}

	const update_styles = () => {
		let k = 0;

		try {
			for (let element of elements) {
				let brush_type = brush_types[k];
				let brush_type_int = BrushType[brush_types[k]];

				if (brush_type_int === selected_brush_type) {
					element.style.outline = '1px solid white';
					element.style.outlineOffset = '0.1rem';
				} else {
					element.style.outline = '0px solid white';
				}

				k++;
			}
		} catch(_) {
			
		}
	};

	onMount(() => {
		update_styles();
	});

	$$self.$$.on_mount.push(function () {
		if (curr_brush === undefined && !('curr_brush' in $$props || $$self.$$.bound[$$self.$$.props['curr_brush']])) {
			console.warn("<BrushTypeWidget> was created without expected prop 'curr_brush'");
		}
	});

	const writable_props = ['curr_brush'];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BrushTypeWidget> was created with unknown prop '${key}'`);
	});

	function div_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elements[i] = $$value;
			$$invalidate(1, elements);
		});
	}

	const click_handler = (brush_type, i) => {
		$$invalidate(0, curr_brush.selected_brush_type = BrushType[brush_type], curr_brush);
		let k = 0;

		for (let element of elements) {
			if (k === i) {
				element.style.outline = '1px solid white';
				element.style.outlineOffset = '0.1rem';
			} else {
				element.style.outline = '0px solid white';
			}

			k++;
		}
	};

	$$self.$$set = $$props => {
		if ('curr_brush' in $$props) $$invalidate(0, curr_brush = $$props.curr_brush);
	};

	$$self.$capture_state = () => ({
		BrushPreset: BrushPreset,
		BrushType: BrushType,
		onMount: onMount,
		brush_blobs_icon: (brush_blobs_default()),
		brush_long_icon: (brush_long_default()),
		brush_triangles_icon: (brush_triangles_default()),
		curr_brush,
		selected_brush_type,
		elements,
		brush_types,
		update_styles
	});

	$$self.$inject_state = $$props => {
		if ('curr_brush' in $$props) $$invalidate(0, curr_brush = $$props.curr_brush);
		if ('selected_brush_type' in $$props) selected_brush_type = $$props.selected_brush_type;
		if ('elements' in $$props) $$invalidate(1, elements = $$props.elements);
		if ('brush_types' in $$props) $$invalidate(2, brush_types = $$props.brush_types);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*curr_brush*/ 1) {
			$: {
				selected_brush_type = curr_brush.selected_brush_type;
				update_styles();
			}
		}
	};

	return [curr_brush, elements, brush_types, div_binding, click_handler];
}

class BrushTypeWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, BrushTypeWidget_svelte_instance, BrushTypeWidget_svelte_create_fragment, safe_not_equal, { curr_brush: 0 }, BrushTypeWidget_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BrushTypeWidget",
			options,
			id: BrushTypeWidget_svelte_create_fragment.name
		});
	}

	get curr_brush() {
		return this.$$.ctx[0];
	}

	set curr_brush(curr_brush) {
		this.$$set({ curr_brush });
		scheduler_flush();
	}
}

/* harmony default export */ const BrushTypeWidget_svelte = (BrushTypeWidget);
;// CONCATENATED MODULE: ./src/components/BrushPresetWidget.svelte
/* src/components/BrushPresetWidget.svelte generated by Svelte v4.0.0 */





const BrushPresetWidget_svelte_file = "src/components/BrushPresetWidget.svelte";

function BrushPresetWidget_svelte_add_css(target) {
	append_styles(target, "svelte-1qoypaf", ".svelte-1qoypaf.svelte-1qoypaf{user-select:none;-webkit-tap-highlight-color:transparent}.knob-container-container.svelte-1qoypaf.svelte-1qoypaf{aspect-ratio:1/1;max-height:75%;margin-top:0.7rem;margin-bottom:auto;margin-right:2rem;display:grid;grid-template-columns:fit-content(8ch) fit-content(8ch) 1fr;pointer-events:all;user-select:none;cursor:pointer;width:fit-content}.knob-container-container.svelte-1qoypaf>.title.menu-toggle.svelte-1qoypaf{background:white;color:black;width:49%;height:70%}.knob-container-container.svelte-1qoypaf>.title.svelte-1qoypaf{padding:0.2rem;font-size:0.8rem !important;margin:0.3rem;color:white;text-align:center;font-weight:bolder;user-select:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnJ1c2hQcmVzZXRXaWRnZXQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXNEa0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQnJ1c2hQcmVzZXRXaWRnZXQuc3ZlbHRlIl19 */");
}

function BrushPresetWidget_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[6] = list;
	child_ctx[7] = i;
	return child_ctx;
}

// (28:2) {#each brush_presets as preset, i}
function BrushPresetWidget_svelte_create_each_block(ctx) {
	let div;
	let i = /*i*/ ctx[7];
	let mounted;
	let dispose;
	const assign_div = () => /*div_binding*/ ctx[3](div, i);
	const unassign_div = () => /*div_binding*/ ctx[3](null, i);

	function click_handler() {
		return /*click_handler*/ ctx[4](/*preset*/ ctx[5], /*i*/ ctx[7]);
	}

	const block = {
		c: function create() {
			div = dom_element("div");
			div.textContent = `${/*i*/ ctx[7].toString()}`;
			attr_dev(div, "class", "title menu-toggle svelte-1qoypaf");
			attr_dev(div, "role", "button");
			attr_dev(div, "tabindex", "0");
			set_style(div, "cursor", "pointer");
			add_location(div, BrushPresetWidget_svelte_file, 32, 4, 714);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			assign_div();

			if (!mounted) {
				dispose = listen_dev(div, "click", click_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (i !== /*i*/ ctx[7]) {
				unassign_div();
				i = /*i*/ ctx[7];
				assign_div();
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			unassign_div();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BrushPresetWidget_svelte_create_each_block.name,
		type: "each",
		source: "(28:2) {#each brush_presets as preset, i}",
		ctx
	});

	return block;
}

function BrushPresetWidget_svelte_create_fragment(ctx) {
	let div;
	let each_value = ensure_array_like_dev(/*brush_presets*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = BrushPresetWidget_svelte_create_each_block(BrushPresetWidget_svelte_get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "knob-container-container svelte-1qoypaf");
			add_location(div, BrushPresetWidget_svelte_file, 30, 0, 634);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*elements, selected_brush_preset, brush_presets*/ 7) {
				each_value = ensure_array_like_dev(/*brush_presets*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = BrushPresetWidget_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = BrushPresetWidget_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BrushPresetWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function BrushPresetWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BrushPresetWidget', slots, []);
	let { brush_presets } = $$props;
	let { selected_brush_preset } = $$props;
	let elements = [];

	for (let preset of brush_presets) {
		elements.length++;
	}

	onMount(() => {
		let k = 0;

		for (let element of elements) {
			if (selected_brush_preset === brush_presets[k]) {
				element.style.outline = '1px solid white';
				element.style.outlineOffset = '0.1rem';
			} else {
				element.style.outline = '0px solid white';
			}

			k++;
		}
	});

	$$self.$$.on_mount.push(function () {
		if (brush_presets === undefined && !('brush_presets' in $$props || $$self.$$.bound[$$self.$$.props['brush_presets']])) {
			console.warn("<BrushPresetWidget> was created without expected prop 'brush_presets'");
		}

		if (selected_brush_preset === undefined && !('selected_brush_preset' in $$props || $$self.$$.bound[$$self.$$.props['selected_brush_preset']])) {
			console.warn("<BrushPresetWidget> was created without expected prop 'selected_brush_preset'");
		}
	});

	const writable_props = ['brush_presets', 'selected_brush_preset'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BrushPresetWidget> was created with unknown prop '${key}'`);
	});

	function div_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elements[i] = $$value;
			$$invalidate(2, elements);
		});
	}

	const click_handler = (preset, i) => {
		$$invalidate(0, selected_brush_preset = preset);
		let k = 0;

		for (let element of elements) {
			if (k === i) {
				element.style.outline = '1px solid white';
				element.style.outlineOffset = '0.1rem';
			} else {
				element.style.outline = '0px solid white';
			}

			k++;
		}
	};

	$$self.$$set = $$props => {
		if ('brush_presets' in $$props) $$invalidate(1, brush_presets = $$props.brush_presets);
		if ('selected_brush_preset' in $$props) $$invalidate(0, selected_brush_preset = $$props.selected_brush_preset);
	};

	$$self.$capture_state = () => ({
		BrushPreset: BrushPreset,
		BrushType: BrushType,
		onMount: onMount,
		brush_presets,
		selected_brush_preset,
		elements
	});

	$$self.$inject_state = $$props => {
		if ('brush_presets' in $$props) $$invalidate(1, brush_presets = $$props.brush_presets);
		if ('selected_brush_preset' in $$props) $$invalidate(0, selected_brush_preset = $$props.selected_brush_preset);
		if ('elements' in $$props) $$invalidate(2, elements = $$props.elements);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [selected_brush_preset, brush_presets, elements, div_binding, click_handler];
}

class BrushPresetWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			BrushPresetWidget_svelte_instance,
			BrushPresetWidget_svelte_create_fragment,
			safe_not_equal,
			{
				brush_presets: 1,
				selected_brush_preset: 0
			},
			BrushPresetWidget_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BrushPresetWidget",
			options,
			id: BrushPresetWidget_svelte_create_fragment.name
		});
	}

	get brush_presets() {
		return this.$$.ctx[1];
	}

	set brush_presets(brush_presets) {
		this.$$set({ brush_presets });
		scheduler_flush();
	}

	get selected_brush_preset() {
		return this.$$.ctx[0];
	}

	set selected_brush_preset(selected_brush_preset) {
		this.$$set({ selected_brush_preset });
		scheduler_flush();
	}
}

/* harmony default export */ const BrushPresetWidget_svelte = (BrushPresetWidget);
// EXTERNAL MODULE: ./public/undo.svg
var public_undo = __webpack_require__(897);
var undo_default = /*#__PURE__*/__webpack_require__.n(public_undo);
// EXTERNAL MODULE: ./public/redo.svg
var public_redo = __webpack_require__(56);
var redo_default = /*#__PURE__*/__webpack_require__.n(public_redo);
;// CONCATENATED MODULE: ./src/components/UndoRedoWidget.svelte
/* src/components/UndoRedoWidget.svelte generated by Svelte v4.0.0 */





const UndoRedoWidget_svelte_file = "src/components/UndoRedoWidget.svelte";

function UndoRedoWidget_svelte_add_css(target) {
	append_styles(target, "svelte-i2wb88", ".svelte-i2wb88{user-select:none;-webkit-tap-highlight-color:transparent}.knob-container.svelte-i2wb88{cursor:pointer;box-sizing:border-box;-webkit-box-sizing:border-box;aspect-ratio:1/1;max-height:50%;height:100%;display:flex;justify-content:center;align-items:center;border-radius:50%;margin-right:1rem;margin-bottom:auto;margin-top:auto;pointer-events:all;user-select:none}.knob-container.svelte-i2wb88:hover{cursor:pointer}.knob.svelte-i2wb88{display:block;aspect-ratio:1/1;height:100%;padding:0;color:var(--text-color);fill:white;transform-origin:50% 50%}.knob.svelte-i2wb88:active{filter:invert(1);background:black}.knob.svelte-i2wb88 svg{fill:white;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVW5kb1JlZG9XaWRnZXQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXlCa0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVW5kb1JlZG9XaWRnZXQuc3ZlbHRlIl19 */");
}

function UndoRedoWidget_svelte_create_fragment(ctx) {
	let div2;
	let div0;
	let t;
	let div1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div2 = dom_element("div");
			div0 = dom_element("div");
			t = space();
			div1 = dom_element("div");
			attr_dev(div0, "class", "knob svelte-i2wb88");
			add_location(div0, UndoRedoWidget_svelte_file, 15, 2, 212);
			attr_dev(div1, "class", "knob svelte-i2wb88");
			add_location(div1, UndoRedoWidget_svelte_file, 18, 2, 285);
			attr_dev(div2, "class", "knob-container svelte-i2wb88");
			add_location(div2, UndoRedoWidget_svelte_file, 14, 0, 181);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			div0.innerHTML = (undo_default());
			append_dev(div2, t);
			append_dev(div2, div1);
			div1.innerHTML = (redo_default());

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*click_handler*/ ctx[2], false, false, false, false),
					listen_dev(div1, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: utils_noop,
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div2);
			}

			mounted = false;
			utils_run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: UndoRedoWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function UndoRedoWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('UndoRedoWidget', slots, []);
	let { redo } = $$props;
	let { undo } = $$props;

	$$self.$$.on_mount.push(function () {
		if (redo === undefined && !('redo' in $$props || $$self.$$.bound[$$self.$$.props['redo']])) {
			console.warn("<UndoRedoWidget> was created without expected prop 'redo'");
		}

		if (undo === undefined && !('undo' in $$props || $$self.$$.bound[$$self.$$.props['undo']])) {
			console.warn("<UndoRedoWidget> was created without expected prop 'undo'");
		}
	});

	const writable_props = ['redo', 'undo'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UndoRedoWidget> was created with unknown prop '${key}'`);
	});

	const click_handler = () => undo();
	const click_handler_1 = () => redo();

	$$self.$$set = $$props => {
		if ('redo' in $$props) $$invalidate(0, redo = $$props.redo);
		if ('undo' in $$props) $$invalidate(1, undo = $$props.undo);
	};

	$$self.$capture_state = () => ({ undoIcon: (undo_default()), redoIcon: (redo_default()), redo, undo });

	$$self.$inject_state = $$props => {
		if ('redo' in $$props) $$invalidate(0, redo = $$props.redo);
		if ('undo' in $$props) $$invalidate(1, undo = $$props.undo);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [redo, undo, click_handler, click_handler_1];
}

class UndoRedoWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, UndoRedoWidget_svelte_instance, UndoRedoWidget_svelte_create_fragment, safe_not_equal, { redo: 0, undo: 1 }, UndoRedoWidget_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UndoRedoWidget",
			options,
			id: UndoRedoWidget_svelte_create_fragment.name
		});
	}

	get redo() {
		return this.$$.ctx[0];
	}

	set redo(redo) {
		this.$$set({ redo });
		scheduler_flush();
	}

	get undo() {
		return this.$$.ctx[1];
	}

	set undo(undo) {
		this.$$set({ undo });
		scheduler_flush();
	}
}

/* harmony default export */ const UndoRedoWidget_svelte = (UndoRedoWidget);
// EXTERNAL MODULE: ./public/solve.svg
var solve = __webpack_require__(878);
var solve_default = /*#__PURE__*/__webpack_require__.n(solve);
// EXTERNAL MODULE: ./public/launch.svg
var launch = __webpack_require__(485);
var launch_default = /*#__PURE__*/__webpack_require__.n(launch);
// EXTERNAL MODULE: ./public/resize.svg
var resize = __webpack_require__(866);
var resize_default = /*#__PURE__*/__webpack_require__.n(resize);
// EXTERNAL MODULE: ./public/forbid.svg
var forbid = __webpack_require__(461);
var forbid_default = /*#__PURE__*/__webpack_require__.n(forbid);
// EXTERNAL MODULE: ./public/ok.svg
var ok = __webpack_require__(713);
var ok_default = /*#__PURE__*/__webpack_require__.n(ok);
// EXTERNAL MODULE: ./public/capture.svg
var capture = __webpack_require__(445);
var capture_default = /*#__PURE__*/__webpack_require__.n(capture);
// EXTERNAL MODULE: ./public/download.svg
var download = __webpack_require__(28);
var download_default = /*#__PURE__*/__webpack_require__.n(download);
// EXTERNAL MODULE: ./public/time.svg
var time = __webpack_require__(179);
var time_default = /*#__PURE__*/__webpack_require__.n(time);
// EXTERNAL MODULE: ./node_modules/dropbox/dist/Dropbox-sdk.min.js
var Dropbox_sdk_min = __webpack_require__(956);
;// CONCATENATED MODULE: ./node_modules/@firebase/util/dist/index.esm2017.js
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.
 */
const CONSTANTS = {
    /**
     * @define {boolean} Whether this is the client Node.js SDK.
     */
    NODE_CLIENT: false,
    /**
     * @define {boolean} Whether this is the Admin Node.js SDK.
     */
    NODE_ADMIN: false,
    /**
     * Firebase SDK Version
     */
    SDK_VERSION: '${JSCORE_VERSION}'
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Throws an error if the provided assertion is falsy
 */
const index_esm2017_assert = function (assertion, message) {
    if (!assertion) {
        throw assertionError(message);
    }
};
/**
 * Returns an Error object suitable for throwing.
 */
const assertionError = function (message) {
    return new Error('Firebase Database (' +
        CONSTANTS.SDK_VERSION +
        ') INTERNAL ASSERT FAILED: ' +
        message);
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const stringToByteArray$1 = function (str) {
    // TODO(user): Use native implementations if/when available
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if ((c & 0xfc00) === 0xd800 &&
            i + 1 < str.length &&
            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
            // Surrogate Pair
            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return out;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param bytes Array of numbers representing characters.
 * @return Stringification of the array.
 */
const byteArrayToString = function (bytes) {
    // TODO(user): Use native implementations if/when available
    const out = [];
    let pos = 0, c = 0;
    while (pos < bytes.length) {
        const c1 = bytes[pos++];
        if (c1 < 128) {
            out[c++] = String.fromCharCode(c1);
        }
        else if (c1 > 191 && c1 < 224) {
            const c2 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
        }
        else if (c1 > 239 && c1 < 365) {
            // Surrogate Pair
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            const c4 = bytes[pos++];
            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -
                0x10000;
            out[c++] = String.fromCharCode(0xd800 + (u >> 10));
            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));
        }
        else {
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
        }
    }
    return out.join('');
};
// We define it as an object literal instead of a class because a class compiled down to es5 can't
// be treeshaked. https://github.com/rollup/rollup/issues/1691
// Static lookup maps, lazily populated by init_()
const base64 = {
    /**
     * Maps bytes to characters.
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     */
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + '+/=';
    },
    /**
     * Our websafe alphabet.
     */
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + '-_.';
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     */
    HAS_NATIVE_SUPPORT: typeof atob === 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeByteArray(input, webSafe) {
        if (!Array.isArray(input)) {
            throw Error('encodeByteArray takes an array as a parameter');
        }
        this.init_();
        const byteToCharMap = webSafe
            ? this.byteToCharMapWebSafe_
            : this.byteToCharMap_;
        const output = [];
        for (let i = 0; i < input.length; i += 3) {
            const byte1 = input[i];
            const haveByte2 = i + 1 < input.length;
            const byte2 = haveByte2 ? input[i + 1] : 0;
            const haveByte3 = i + 2 < input.length;
            const byte3 = haveByte3 ? input[i + 2] : 0;
            const outByte1 = byte1 >> 2;
            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);
            let outByte4 = byte3 & 0x3f;
            if (!haveByte3) {
                outByte4 = 64;
                if (!haveByte2) {
                    outByte3 = 64;
                }
            }
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join('');
    },
    /**
     * Base64-encode a string.
     *
     * @param input A string to encode.
     * @param webSafe If true, we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeString(input, webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
            return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray$1(input), webSafe);
    },
    /**
     * Base64-decode a string.
     *
     * @param input to decode.
     * @param webSafe True if we should use the
     *     alternative alphabet.
     * @return string representing the decoded value.
     */
    decodeString(input, webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
            return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param input Input to decode.
     * @param webSafe True if we should use the web-safe alphabet.
     * @return bytes representing the decoded value.
     */
    decodeStringToByteArray(input, webSafe) {
        this.init_();
        const charToByteMap = webSafe
            ? this.charToByteMapWebSafe_
            : this.charToByteMap_;
        const output = [];
        for (let i = 0; i < input.length;) {
            const byte1 = charToByteMap[input.charAt(i++)];
            const haveByte2 = i < input.length;
            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            const haveByte3 = i < input.length;
            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            const haveByte4 = i < input.length;
            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
                throw new DecodeBase64StringError();
            }
            const outByte1 = (byte1 << 2) | (byte2 >> 4);
            output.push(outByte1);
            if (byte3 !== 64) {
                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);
                output.push(outByte2);
                if (byte4 !== 64) {
                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;
                    output.push(outByte3);
                }
            }
        }
        return output;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_() {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {};
            this.charToByteMap_ = {};
            this.byteToCharMapWebSafe_ = {};
            this.charToByteMapWebSafe_ = {};
            // We want quick mappings back and forth, so we precompute two maps.
            for (let i = 0; i < this.ENCODED_VALS.length; i++) {
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) {
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
                }
            }
        }
    }
};
/**
 * An error encountered while decoding base64 string.
 */
class DecodeBase64StringError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'DecodeBase64StringError';
    }
}
/**
 * URL-safe base64 encoding
 */
const base64Encode = function (str) {
    const utf8Bytes = stringToByteArray$1(str);
    return base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 encoding (without "." padding in the end).
 * e.g. Used in JSON Web Token (JWT) parts.
 */
const base64urlEncodeWithoutPadding = function (str) {
    // Use base64url encoding and remove padding in the end (dot characters).
    return base64Encode(str).replace(/\./g, '');
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param str To be decoded
 * @return Decoded result, if possible
 */
const base64Decode = function (str) {
    try {
        return base64.decodeString(str, true);
    }
    catch (e) {
        console.error('base64Decode failed: ', e);
    }
    return null;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Do a deep-copy of basic JavaScript Objects or Arrays.
 */
function deepCopy(value) {
    return deepExtend(undefined, value);
}
/**
 * Copy properties from source to target (recursively allows extension
 * of Objects and Arrays).  Scalar values in the target are over-written.
 * If target is undefined, an object of the appropriate type will be created
 * (and returned).
 *
 * We recursively copy all child properties of plain Objects in the source- so
 * that namespace- like dictionaries are merged.
 *
 * Note that the target can be a function, in which case the properties in
 * the source Object are copied onto it as static properties of the Function.
 *
 * Note: we don't merge __proto__ to prevent prototype pollution
 */
function deepExtend(target, source) {
    if (!(source instanceof Object)) {
        return source;
    }
    switch (source.constructor) {
        case Date:
            // Treat Dates like scalars; if the target date object had any child
            // properties - they will be lost!
            const dateValue = source;
            return new Date(dateValue.getTime());
        case Object:
            if (target === undefined) {
                target = {};
            }
            break;
        case Array:
            // Always copy the array source and overwrite the target.
            target = [];
            break;
        default:
            // Not a plain Object - treat it as a scalar.
            return source;
    }
    for (const prop in source) {
        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202
        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
            continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
    }
    return target;
}
function isValidKey(key) {
    return key !== '__proto__';
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Polyfill for `globalThis` object.
 * @returns the `globalThis` object for the given environment.
 * @public
 */
function getGlobal() {
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof __webpack_require__.g !== 'undefined') {
        return __webpack_require__.g;
    }
    throw new Error('Unable to locate global object.');
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;
/**
 * Attempt to read defaults from a JSON string provided to
 * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in
 * process(.)env(.)__FIREBASE_DEFAULTS_PATH__
 * The dots are in parens because certain compilers (Vite?) cannot
 * handle seeing that variable in comments.
 * See https://github.com/firebase/firebase-js-sdk/issues/6838
 */
const getDefaultsFromEnvVariable = () => {
    if (typeof process === 'undefined' || typeof process.env === 'undefined') {
        return;
    }
    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;
    if (defaultsJsonString) {
        return JSON.parse(defaultsJsonString);
    }
};
const getDefaultsFromCookie = () => {
    if (typeof document === 'undefined') {
        return;
    }
    let match;
    try {
        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
    }
    catch (e) {
        // Some environments such as Angular Universal SSR have a
        // `document` object but error on accessing `document.cookie`.
        return;
    }
    const decoded = match && base64Decode(match[1]);
    return decoded && JSON.parse(decoded);
};
/**
 * Get the __FIREBASE_DEFAULTS__ object. It checks in order:
 * (1) if such an object exists as a property of `globalThis`
 * (2) if such an object was provided on a shell environment variable
 * (3) if such an object exists in a cookie
 * @public
 */
const getDefaults = () => {
    try {
        return (getDefaultsFromGlobal() ||
            getDefaultsFromEnvVariable() ||
            getDefaultsFromCookie());
    }
    catch (e) {
        /**
         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due
         * to any environment case we have not accounted for. Log to
         * info instead of swallowing so we can find these unknown cases
         * and add paths for them if needed.
         */
        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
        return;
    }
};
/**
 * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object
 * for the given product.
 * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available
 * @public
 */
const getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };
/**
 * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object
 * for the given product.
 * @returns a pair of hostname and port like `["::1", 4000]` if available
 * @public
 */
const getDefaultEmulatorHostnameAndPort = (productName) => {
    const host = getDefaultEmulatorHost(productName);
    if (!host) {
        return undefined;
    }
    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.
    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {
        throw new Error(`Invalid host ${host} with no separate hostname and port!`);
    }
    // eslint-disable-next-line no-restricted-globals
    const port = parseInt(host.substring(separatorIndex + 1), 10);
    if (host[0] === '[') {
        // Bracket-quoted `[ipv6addr]:port` => return "ipv6addr" (without brackets).
        return [host.substring(1, separatorIndex - 1), port];
    }
    else {
        return [host.substring(0, separatorIndex), port];
    }
};
/**
 * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.
 * @public
 */
const getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };
/**
 * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties
 * prefixed by "_")
 * @public
 */
const getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Deferred {
    constructor() {
        this.reject = () => { };
        this.resolve = () => { };
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    /**
     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
     * and returns a node-style callback which will resolve or reject the Deferred's promise.
     */
    wrapCallback(callback) {
        return (error, value) => {
            if (error) {
                this.reject(error);
            }
            else {
                this.resolve(value);
            }
            if (typeof callback === 'function') {
                // Attaching noop handler just in case developer wasn't expecting
                // promises
                this.promise.catch(() => { });
                // Some of our callbacks don't expect a value and our own tests
                // assert that the parameter length is 1
                if (callback.length === 1) {
                    callback(error);
                }
                else {
                    callback(error, value);
                }
            }
        };
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createMockUserToken(token, projectId) {
    if (token.uid) {
        throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
    }
    // Unsecured JWTs use "none" as the algorithm.
    const header = {
        alg: 'none',
        type: 'JWT'
    };
    const project = projectId || 'demo-project';
    const iat = token.iat || 0;
    const sub = token.sub || token.user_id;
    if (!sub) {
        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
    }
    const payload = Object.assign({ 
        // Set all required fields to decent defaults
        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {
            sign_in_provider: 'custom',
            identities: {}
        } }, token);
    // Unsecured JWTs use the empty string as a signature.
    const signature = '';
    return [
        base64urlEncodeWithoutPadding(JSON.stringify(header)),
        base64urlEncodeWithoutPadding(JSON.stringify(payload)),
        signature
    ].join('.');
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns navigator.userAgent string or '' if it's not defined.
 * @return user agent string
 */
function index_esm2017_getUA() {
    if (typeof navigator !== 'undefined' &&
        typeof navigator['userAgent'] === 'string') {
        return navigator['userAgent'];
    }
    else {
        return '';
    }
}
/**
 * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
 *
 * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap
 * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally
 * wait for a callback.
 */
function isMobileCordova() {
    return (typeof window !== 'undefined' &&
        // @ts-ignore Setting up an broadly applicable index signature for Window
        // just to deal with this case would probably be a bad idea.
        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&
        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(index_esm2017_getUA()));
}
/**
 * Detect Node.js.
 *
 * @return true if Node.js environment is detected or specified.
 */
// Node detection logic from: https://github.com/iliakan/detect-node/
function isNode() {
    var _a;
    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;
    if (forceEnvironment === 'node') {
        return true;
    }
    else if (forceEnvironment === 'browser') {
        return false;
    }
    try {
        return (Object.prototype.toString.call(__webpack_require__.g.process) === '[object process]');
    }
    catch (e) {
        return false;
    }
}
/**
 * Detect Browser Environment
 */
function isBrowser() {
    return typeof self === 'object' && self.self === self;
}
function isBrowserExtension() {
    const runtime = typeof chrome === 'object'
        ? chrome.runtime
        : typeof browser === 'object'
            ? browser.runtime
            : undefined;
    return typeof runtime === 'object' && runtime.id !== undefined;
}
/**
 * Detect React Native.
 *
 * @return true if ReactNative environment is detected.
 */
function isReactNative() {
    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');
}
/** Detects Electron apps. */
function isElectron() {
    return index_esm2017_getUA().indexOf('Electron/') >= 0;
}
/** Detects Internet Explorer. */
function isIE() {
    const ua = index_esm2017_getUA();
    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
}
/** Detects Universal Windows Platform apps. */
function isUWP() {
    return index_esm2017_getUA().indexOf('MSAppHost/') >= 0;
}
/**
 * Detect whether the current SDK build is the Node version.
 *
 * @return true if it's the Node SDK build.
 */
function isNodeSdk() {
    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
}
/** Returns true if we are running in Safari. */
function isSafari() {
    return (!isNode() &&
        navigator.userAgent.includes('Safari') &&
        !navigator.userAgent.includes('Chrome'));
}
/**
 * This method checks if indexedDB is supported by current browser/service worker context
 * @return true if indexedDB is supported by current browser/service worker context
 */
function isIndexedDBAvailable() {
    try {
        return typeof indexedDB === 'object';
    }
    catch (e) {
        return false;
    }
}
/**
 * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject
 * if errors occur during the database open operation.
 *
 * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox
 * private browsing)
 */
function validateIndexedDBOpenable() {
    return new Promise((resolve, reject) => {
        try {
            let preExist = true;
            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';
            const request = self.indexedDB.open(DB_CHECK_NAME);
            request.onsuccess = () => {
                request.result.close();
                // delete database only when it doesn't pre-exist
                if (!preExist) {
                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);
                }
                resolve(true);
            };
            request.onupgradeneeded = () => {
                preExist = false;
            };
            request.onerror = () => {
                var _a;
                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');
            };
        }
        catch (error) {
            reject(error);
        }
    });
}
/**
 *
 * This method checks whether cookie is enabled within current browser
 * @return true if cookie is enabled within current browser
 */
function areCookiesEnabled() {
    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {
        return false;
    }
    return true;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Standardized Firebase Error.
 *
 * Usage:
 *
 *   // Typescript string literals for type-safe codes
 *   type Err =
 *     'unknown' |
 *     'object-not-found'
 *     ;
 *
 *   // Closure enum for type-safe error codes
 *   // at-enum {string}
 *   var Err = {
 *     UNKNOWN: 'unknown',
 *     OBJECT_NOT_FOUND: 'object-not-found',
 *   }
 *
 *   let errors: Map<Err, string> = {
 *     'generic-error': "Unknown error",
 *     'file-not-found': "Could not find file: {$file}",
 *   };
 *
 *   // Type-safe function - must pass a valid error code as param.
 *   let error = new ErrorFactory<Err>('service', 'Service', errors);
 *
 *   ...
 *   throw error.create(Err.GENERIC);
 *   ...
 *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});
 *   ...
 *   // Service: Could not file file: foo.txt (service/file-not-found).
 *
 *   catch (e) {
 *     assert(e.message === "Could not find file: foo.txt.");
 *     if ((e as FirebaseError)?.code === 'service/file-not-found') {
 *       console.log("Could not read file: " + e['file']);
 *     }
 *   }
 */
const ERROR_NAME = 'FirebaseError';
// Based on code from:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
class FirebaseError extends Error {
    constructor(
    /** The error code for this error. */
    code, message, 
    /** Custom data for this error. */
    customData) {
        super(message);
        this.code = code;
        this.customData = customData;
        /** The custom name for all FirebaseErrors. */
        this.name = ERROR_NAME;
        // Fix For ES5
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, FirebaseError.prototype);
        // Maintains proper stack trace for where our error was thrown.
        // Only available on V8.
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ErrorFactory.prototype.create);
        }
    }
}
class ErrorFactory {
    constructor(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
    }
    create(code, ...data) {
        const customData = data[0] || {};
        const fullCode = `${this.service}/${code}`;
        const template = this.errors[code];
        const message = template ? replaceTemplate(template, customData) : 'Error';
        // Service Name: Error message (service/code).
        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
        const error = new FirebaseError(fullCode, fullMessage, customData);
        return error;
    }
}
function replaceTemplate(template, data) {
    return template.replace(PATTERN, (_, key) => {
        const value = data[key];
        return value != null ? String(value) : `<${key}?>`;
    });
}
const PATTERN = /\{\$([^}]+)}/g;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Evaluates a JSON string into a javascript object.
 *
 * @param {string} str A string containing JSON.
 * @return {*} The javascript object representing the specified JSON.
 */
function jsonEval(str) {
    return JSON.parse(str);
}
/**
 * Returns JSON representing a javascript object.
 * @param {*} data Javascript object to be stringified.
 * @return {string} The JSON contents of the object.
 */
function stringify(data) {
    return JSON.stringify(data);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Decodes a Firebase auth. token into constituent parts.
 *
 * Notes:
 * - May return with invalid / incomplete claims if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const decode = function (token) {
    let header = {}, claims = {}, data = {}, signature = '';
    try {
        const parts = token.split('.');
        header = jsonEval(base64Decode(parts[0]) || '');
        claims = jsonEval(base64Decode(parts[1]) || '');
        signature = parts[2];
        data = claims['d'] || {};
        delete claims['d'];
    }
    catch (e) { }
    return {
        header,
        claims,
        data,
        signature
    };
};
/**
 * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the
 * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const isValidTimestamp = function (token) {
    const claims = decode(token).claims;
    const now = Math.floor(new Date().getTime() / 1000);
    let validSince = 0, validUntil = 0;
    if (typeof claims === 'object') {
        if (claims.hasOwnProperty('nbf')) {
            validSince = claims['nbf'];
        }
        else if (claims.hasOwnProperty('iat')) {
            validSince = claims['iat'];
        }
        if (claims.hasOwnProperty('exp')) {
            validUntil = claims['exp'];
        }
        else {
            // token will expire after 24h by default
            validUntil = validSince + 86400;
        }
    }
    return (!!now &&
        !!validSince &&
        !!validUntil &&
        now >= validSince &&
        now <= validUntil);
};
/**
 * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.
 *
 * Notes:
 * - May return null if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const issuedAtTime = function (token) {
    const claims = decode(token).claims;
    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {
        return claims['iat'];
    }
    return null;
};
/**
 * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const isValidFormat = function (token) {
    const decoded = decode(token), claims = decoded.claims;
    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');
};
/**
 * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const isAdmin = function (token) {
    const claims = decode(token).claims;
    return typeof claims === 'object' && claims['admin'] === true;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function contains(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
function safeGet(obj, key) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return obj[key];
    }
    else {
        return undefined;
    }
}
function isEmpty(obj) {
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            return false;
        }
    }
    return true;
}
function map(obj, fn, contextObj) {
    const res = {};
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            res[key] = fn.call(contextObj, obj[key], key, obj);
        }
    }
    return res;
}
/**
 * Deep equal two objects. Support Arrays and Objects.
 */
function deepEqual(a, b) {
    if (a === b) {
        return true;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    for (const k of aKeys) {
        if (!bKeys.includes(k)) {
            return false;
        }
        const aProp = a[k];
        const bProp = b[k];
        if (isObject(aProp) && isObject(bProp)) {
            if (!deepEqual(aProp, bProp)) {
                return false;
            }
        }
        else if (aProp !== bProp) {
            return false;
        }
    }
    for (const k of bKeys) {
        if (!aKeys.includes(k)) {
            return false;
        }
    }
    return true;
}
function isObject(thing) {
    return thing !== null && typeof thing === 'object';
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Rejects if the given promise doesn't resolve in timeInMS milliseconds.
 * @internal
 */
function promiseWithTimeout(promise, timeInMS = 2000) {
    const deferredPromise = new Deferred();
    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);
    promise.then(deferredPromise.resolve, deferredPromise.reject);
    return deferredPromise.promise;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a
 * params object (e.g. {arg: 'val', arg2: 'val2'})
 * Note: You must prepend it with ? when adding it to a URL.
 */
function index_esm2017_querystring(querystringParams) {
    const params = [];
    for (const [key, value] of Object.entries(querystringParams)) {
        if (Array.isArray(value)) {
            value.forEach(arrayVal => {
                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));
            });
        }
        else {
            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        }
    }
    return params.length ? '&' + params.join('&') : '';
}
/**
 * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object
 * (e.g. {arg: 'val', arg2: 'val2'})
 */
function querystringDecode(querystring) {
    const obj = {};
    const tokens = querystring.replace(/^\?/, '').split('&');
    tokens.forEach(token => {
        if (token) {
            const [key, value] = token.split('=');
            obj[decodeURIComponent(key)] = decodeURIComponent(value);
        }
    });
    return obj;
}
/**
 * Extract the query string part of a URL, including the leading question mark (if present).
 */
function extractQuerystring(url) {
    const queryStart = url.indexOf('?');
    if (!queryStart) {
        return '';
    }
    const fragmentStart = url.indexOf('#', queryStart);
    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */
/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @final
 * @struct
 */
class Sha1 {
    constructor() {
        /**
         * Holds the previous values of accumulated variables a-e in the compress_
         * function.
         * @private
         */
        this.chain_ = [];
        /**
         * A buffer holding the partially computed hash result.
         * @private
         */
        this.buf_ = [];
        /**
         * An array of 80 bytes, each a part of the message to be hashed.  Referred to
         * as the message schedule in the docs.
         * @private
         */
        this.W_ = [];
        /**
         * Contains data needed to pad messages less than 64 bytes.
         * @private
         */
        this.pad_ = [];
        /**
         * @private {number}
         */
        this.inbuf_ = 0;
        /**
         * @private {number}
         */
        this.total_ = 0;
        this.blockSize = 512 / 8;
        this.pad_[0] = 128;
        for (let i = 1; i < this.blockSize; ++i) {
            this.pad_[i] = 0;
        }
        this.reset();
    }
    reset() {
        this.chain_[0] = 0x67452301;
        this.chain_[1] = 0xefcdab89;
        this.chain_[2] = 0x98badcfe;
        this.chain_[3] = 0x10325476;
        this.chain_[4] = 0xc3d2e1f0;
        this.inbuf_ = 0;
        this.total_ = 0;
    }
    /**
     * Internal compress helper function.
     * @param buf Block to compress.
     * @param offset Offset of the block in the buffer.
     * @private
     */
    compress_(buf, offset) {
        if (!offset) {
            offset = 0;
        }
        const W = this.W_;
        // get 16 big endian words
        if (typeof buf === 'string') {
            for (let i = 0; i < 16; i++) {
                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS
                // have a bug that turns the post-increment ++ operator into pre-increment
                // during JIT compilation.  We have code that depends heavily on SHA-1 for
                // correctness and which is affected by this bug, so I've removed all uses
                // of post-increment ++ in which the result value is used.  We can revert
                // this change once the Safari bug
                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
                // most clients have been updated.
                W[i] =
                    (buf.charCodeAt(offset) << 24) |
                        (buf.charCodeAt(offset + 1) << 16) |
                        (buf.charCodeAt(offset + 2) << 8) |
                        buf.charCodeAt(offset + 3);
                offset += 4;
            }
        }
        else {
            for (let i = 0; i < 16; i++) {
                W[i] =
                    (buf[offset] << 24) |
                        (buf[offset + 1] << 16) |
                        (buf[offset + 2] << 8) |
                        buf[offset + 3];
                offset += 4;
            }
        }
        // expand to 80 words
        for (let i = 16; i < 80; i++) {
            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;
        }
        let a = this.chain_[0];
        let b = this.chain_[1];
        let c = this.chain_[2];
        let d = this.chain_[3];
        let e = this.chain_[4];
        let f, k;
        // TODO(user): Try to unroll this loop to speed up the computation.
        for (let i = 0; i < 80; i++) {
            if (i < 40) {
                if (i < 20) {
                    f = d ^ (b & (c ^ d));
                    k = 0x5a827999;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0x6ed9eba1;
                }
            }
            else {
                if (i < 60) {
                    f = (b & c) | (d & (b | c));
                    k = 0x8f1bbcdc;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0xca62c1d6;
                }
            }
            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;
            e = d;
            d = c;
            c = ((b << 30) | (b >>> 2)) & 0xffffffff;
            b = a;
            a = t;
        }
        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;
        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;
        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;
        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;
        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;
    }
    update(bytes, length) {
        // TODO(johnlenz): tighten the function signature and remove this check
        if (bytes == null) {
            return;
        }
        if (length === undefined) {
            length = bytes.length;
        }
        const lengthMinusBlock = length - this.blockSize;
        let n = 0;
        // Using local instead of member variables gives ~5% speedup on Firefox 16.
        const buf = this.buf_;
        let inbuf = this.inbuf_;
        // The outer while loop should execute at most twice.
        while (n < length) {
            // When we have no data in the block to top up, we can directly process the
            // input buffer (assuming it contains sufficient data). This gives ~25%
            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
            // the data is provided in large chunks (or in multiples of 64 bytes).
            if (inbuf === 0) {
                while (n <= lengthMinusBlock) {
                    this.compress_(bytes, n);
                    n += this.blockSize;
                }
            }
            if (typeof bytes === 'string') {
                while (n < length) {
                    buf[inbuf] = bytes.charCodeAt(n);
                    ++inbuf;
                    ++n;
                    if (inbuf === this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
            else {
                while (n < length) {
                    buf[inbuf] = bytes[n];
                    ++inbuf;
                    ++n;
                    if (inbuf === this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
        }
        this.inbuf_ = inbuf;
        this.total_ += length;
    }
    /** @override */
    digest() {
        const digest = [];
        let totalBits = this.total_ * 8;
        // Add pad 0x80 0x00*.
        if (this.inbuf_ < 56) {
            this.update(this.pad_, 56 - this.inbuf_);
        }
        else {
            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        // Add # bits.
        for (let i = this.blockSize - 1; i >= 56; i--) {
            this.buf_[i] = totalBits & 255;
            totalBits /= 256; // Don't use bit-shifting here!
        }
        this.compress_(this.buf_);
        let n = 0;
        for (let i = 0; i < 5; i++) {
            for (let j = 24; j >= 0; j -= 8) {
                digest[n] = (this.chain_[i] >> j) & 255;
                ++n;
            }
        }
        return digest;
    }
}

/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */
function createSubscribe(executor, onNoObservers) {
    const proxy = new ObserverProxy(executor, onNoObservers);
    return proxy.subscribe.bind(proxy);
}
/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */
class ObserverProxy {
    /**
     * @param executor Function which can make calls to a single Observer
     *     as a proxy.
     * @param onNoObservers Callback when count of Observers goes to zero.
     */
    constructor(executor, onNoObservers) {
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        // Micro-task scheduling by calling task.then().
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        // Call the executor asynchronously so subscribers that are called
        // synchronously after the creation of the subscribe function
        // can still receive the very first value generated in the executor.
        this.task
            .then(() => {
            executor(this);
        })
            .catch(e => {
            this.error(e);
        });
    }
    next(value) {
        this.forEachObserver((observer) => {
            observer.next(value);
        });
    }
    error(error) {
        this.forEachObserver((observer) => {
            observer.error(error);
        });
        this.close(error);
    }
    complete() {
        this.forEachObserver((observer) => {
            observer.complete();
        });
        this.close();
    }
    /**
     * Subscribe function that can be used to add an Observer to the fan-out list.
     *
     * - We require that no event is sent to a subscriber sychronously to their
     *   call to subscribe().
     */
    subscribe(nextOrObserver, error, complete) {
        let observer;
        if (nextOrObserver === undefined &&
            error === undefined &&
            complete === undefined) {
            throw new Error('Missing Observer.');
        }
        // Assemble an Observer object when passed as callback functions.
        if (implementsAnyMethods(nextOrObserver, [
            'next',
            'error',
            'complete'
        ])) {
            observer = nextOrObserver;
        }
        else {
            observer = {
                next: nextOrObserver,
                error,
                complete
            };
        }
        if (observer.next === undefined) {
            observer.next = index_esm2017_noop;
        }
        if (observer.error === undefined) {
            observer.error = index_esm2017_noop;
        }
        if (observer.complete === undefined) {
            observer.complete = index_esm2017_noop;
        }
        const unsub = this.unsubscribeOne.bind(this, this.observers.length);
        // Attempt to subscribe to a terminated Observable - we
        // just respond to the Observer with the final error or complete
        // event.
        if (this.finalized) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.task.then(() => {
                try {
                    if (this.finalError) {
                        observer.error(this.finalError);
                    }
                    else {
                        observer.complete();
                    }
                }
                catch (e) {
                    // nothing
                }
                return;
            });
        }
        this.observers.push(observer);
        return unsub;
    }
    // Unsubscribe is synchronous - we guarantee that no events are sent to
    // any unsubscribed Observer.
    unsubscribeOne(i) {
        if (this.observers === undefined || this.observers[i] === undefined) {
            return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== undefined) {
            this.onNoObservers(this);
        }
    }
    forEachObserver(fn) {
        if (this.finalized) {
            // Already closed by previous event....just eat the additional values.
            return;
        }
        // Since sendOne calls asynchronously - there is no chance that
        // this.observers will become undefined.
        for (let i = 0; i < this.observers.length; i++) {
            this.sendOne(i, fn);
        }
    }
    // Call the Observer via one of it's callback function. We are careful to
    // confirm that the observe has not been unsubscribed since this asynchronous
    // function had been queued.
    sendOne(i, fn) {
        // Execute the callback asynchronously
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.task.then(() => {
            if (this.observers !== undefined && this.observers[i] !== undefined) {
                try {
                    fn(this.observers[i]);
                }
                catch (e) {
                    // Ignore exceptions raised in Observers or missing methods of an
                    // Observer.
                    // Log error to console. b/31404806
                    if (typeof console !== 'undefined' && console.error) {
                        console.error(e);
                    }
                }
            }
        });
    }
    close(err) {
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        if (err !== undefined) {
            this.finalError = err;
        }
        // Proxy is no longer needed - garbage collect references
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.task.then(() => {
            this.observers = undefined;
            this.onNoObservers = undefined;
        });
    }
}
/** Turn synchronous function into one called asynchronously. */
// eslint-disable-next-line @typescript-eslint/ban-types
function index_esm2017_async(fn, onError) {
    return (...args) => {
        Promise.resolve(true)
            .then(() => {
            fn(...args);
        })
            .catch((error) => {
            if (onError) {
                onError(error);
            }
        });
    };
}
/**
 * Return true if the object passed in implements any of the named methods.
 */
function implementsAnyMethods(obj, methods) {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    for (const method of methods) {
        if (method in obj && typeof obj[method] === 'function') {
            return true;
        }
    }
    return false;
}
function index_esm2017_noop() {
    // do nothing
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Check to make sure the appropriate number of arguments are provided for a public function.
 * Throws an error if it fails.
 *
 * @param fnName The function name
 * @param minCount The minimum number of arguments to allow for the function call
 * @param maxCount The maximum number of argument to allow for the function call
 * @param argCount The actual number of arguments provided.
 */
const validateArgCount = function (fnName, minCount, maxCount, argCount) {
    let argError;
    if (argCount < minCount) {
        argError = 'at least ' + minCount;
    }
    else if (argCount > maxCount) {
        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;
    }
    if (argError) {
        const error = fnName +
            ' failed: Was called with ' +
            argCount +
            (argCount === 1 ? ' argument.' : ' arguments.') +
            ' Expects ' +
            argError +
            '.';
        throw new Error(error);
    }
};
/**
 * Generates a string to prefix an error message about failed argument validation
 *
 * @param fnName The function name
 * @param argName The name of the argument
 * @return The prefix to add to the error thrown for validation.
 */
function errorPrefix(fnName, argName) {
    return `${fnName} failed: ${argName} argument `;
}
/**
 * @param fnName
 * @param argumentNumber
 * @param namespace
 * @param optional
 */
function validateNamespace(fnName, namespace, optional) {
    if (optional && !namespace) {
        return;
    }
    if (typeof namespace !== 'string') {
        //TODO: I should do more validation here. We only allow certain chars in namespaces.
        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');
    }
}
function validateCallback(fnName, argumentName, 
// eslint-disable-next-line @typescript-eslint/ban-types
callback, optional) {
    if (optional && !callback) {
        return;
    }
    if (typeof callback !== 'function') {
        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');
    }
}
function validateContextObject(fnName, argumentName, context, optional) {
    if (optional && !context) {
        return;
    }
    if (typeof context !== 'object' || context === null) {
        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they
// automatically replaced '\r\n' with '\n', and they didn't handle surrogate pairs,
// so it's been modified.
// Note that not all Unicode characters appear as single characters in JavaScript strings.
// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters
// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first
// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate
// pair).
// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3
/**
 * @param {string} str
 * @return {Array}
 */
const stringToByteArray = function (str) {
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        // Is this the lead surrogate in a surrogate pair?
        if (c >= 0xd800 && c <= 0xdbff) {
            const high = c - 0xd800; // the high 10 bits.
            i++;
            index_esm2017_assert(i < str.length, 'Surrogate pair missing trail surrogate.');
            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.
            c = 0x10000 + (high << 10) + low;
        }
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if (c < 65536) {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return out;
};
/**
 * Calculate length without actually converting; useful for doing cheaper validation.
 * @param {string} str
 * @return {number}
 */
const stringLength = function (str) {
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 128) {
            p++;
        }
        else if (c < 2048) {
            p += 2;
        }
        else if (c >= 0xd800 && c <= 0xdbff) {
            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.
            p += 4;
            i++; // skip trail surrogate.
        }
        else {
            p += 3;
        }
    }
    return p;
};

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Copied from https://stackoverflow.com/a/2117523
 * Generates a new uuid.
 * @public
 */
const uuidv4 = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
};

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The amount of milliseconds to exponentially increase.
 */
const DEFAULT_INTERVAL_MILLIS = 1000;
/**
 * The factor to backoff by.
 * Should be a number greater than 1.
 */
const DEFAULT_BACKOFF_FACTOR = 2;
/**
 * The maximum milliseconds to increase to.
 *
 * <p>Visible for testing
 */
const MAX_VALUE_MILLIS = (/* unused pure expression or super */ null && (4 * 60 * 60 * 1000)); // Four hours, like iOS and Android.
/**
 * The percentage of backoff time to randomize by.
 * See
 * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic
 * for context.
 *
 * <p>Visible for testing
 */
const RANDOM_FACTOR = 0.5;
/**
 * Based on the backoff method from
 * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.
 * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.
 */
function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {
    // Calculates an exponentially increasing value.
    // Deviation: calculates value from count and a constant interval, so we only need to save value
    // and count to restore state.
    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
    // A random "fuzz" to avoid waves of retries.
    // Deviation: randomFactor is required.
    const randomWait = Math.round(
    // A fraction of the backoff value to add/subtract.
    // Deviation: changes multiplication order to improve readability.
    RANDOM_FACTOR *
        currBaseValue *
        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines
        // if we add or subtract.
        (Math.random() - 0.5) *
        2);
    // Limits backoff to max to avoid effectively permanent backoff.
    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provide English ordinal letters after a number
 */
function ordinal(i) {
    if (!Number.isFinite(i)) {
        return `${i}`;
    }
    return i + indicator(i);
}
function indicator(i) {
    i = Math.abs(i);
    const cent = i % 100;
    if (cent >= 10 && cent <= 20) {
        return 'th';
    }
    const dec = i % 10;
    if (dec === 1) {
        return 'st';
    }
    if (dec === 2) {
        return 'nd';
    }
    if (dec === 3) {
        return 'rd';
    }
    return 'th';
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function index_esm2017_getModularInstance(service) {
    if (service && service._delegate) {
        return service._delegate;
    }
    else {
        return service;
    }
}



;// CONCATENATED MODULE: ./node_modules/@firebase/component/dist/esm/index.esm2017.js


/**
 * Component for service name T, e.g. `auth`, `auth-internal`
 */
class Component {
    /**
     *
     * @param name The public service name, e.g. app, auth, firestore, database
     * @param instanceFactory Service factory responsible for creating the public interface
     * @param type whether the service provided by the component is public or private
     */
    constructor(name, instanceFactory, type) {
        this.name = name;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        /**
         * Properties to be added to the service namespace
         */
        this.serviceProps = {};
        this.instantiationMode = "LAZY" /* InstantiationMode.LAZY */;
        this.onInstanceCreated = null;
    }
    setInstantiationMode(mode) {
        this.instantiationMode = mode;
        return this;
    }
    setMultipleInstances(multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
    }
    setServiceProps(props) {
        this.serviceProps = props;
        return this;
    }
    setInstanceCreatedCallback(callback) {
        this.onInstanceCreated = callback;
        return this;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME = '[DEFAULT]';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for instance for service name T, e.g. 'auth', 'auth-internal'
 * NameServiceMapping[T] is an alias for the type of the instance
 */
class Provider {
    constructor(name, container) {
        this.name = name;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.instancesOptions = new Map();
        this.onInitCallbacks = new Map();
    }
    /**
     * @param identifier A provider can provide mulitple instances of a service
     * if this.component.multipleInstances is true.
     */
    get(identifier) {
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) {
            const deferred = new Deferred();
            this.instancesDeferred.set(normalizedIdentifier, deferred);
            if (this.isInitialized(normalizedIdentifier) ||
                this.shouldAutoInitialize()) {
                // initialize the service if it can be auto-initialized
                try {
                    const instance = this.getOrInitializeService({
                        instanceIdentifier: normalizedIdentifier
                    });
                    if (instance) {
                        deferred.resolve(instance);
                    }
                }
                catch (e) {
                    // when the instance factory throws an exception during get(), it should not cause
                    // a fatal error. We just return the unresolved promise in this case.
                }
            }
        }
        return this.instancesDeferred.get(normalizedIdentifier).promise;
    }
    getImmediate(options) {
        var _a;
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) ||
            this.shouldAutoInitialize()) {
            try {
                return this.getOrInitializeService({
                    instanceIdentifier: normalizedIdentifier
                });
            }
            catch (e) {
                if (optional) {
                    return null;
                }
                else {
                    throw e;
                }
            }
        }
        else {
            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw
            if (optional) {
                return null;
            }
            else {
                throw Error(`Service ${this.name} is not available`);
            }
        }
    }
    getComponent() {
        return this.component;
    }
    setComponent(component) {
        if (component.name !== this.name) {
            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
        }
        if (this.component) {
            throw Error(`Component for ${this.name} has already been provided`);
        }
        this.component = component;
        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)
        if (!this.shouldAutoInitialize()) {
            return;
        }
        // if the service is eager, initialize the default instance
        if (isComponentEager(component)) {
            try {
                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });
            }
            catch (e) {
                // when the instance factory for an eager Component throws an exception during the eager
                // initialization, it should not cause a fatal error.
                // TODO: Investigate if we need to make it configurable, because some component may want to cause
                // a fatal error in this case?
            }
        }
        // Create service instances for the pending promises and resolve them
        // NOTE: if this.multipleInstances is false, only the default instance will be created
        // and all promises with resolve with it regardless of the identifier.
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            try {
                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.
                const instance = this.getOrInitializeService({
                    instanceIdentifier: normalizedIdentifier
                });
                instanceDeferred.resolve(instance);
            }
            catch (e) {
                // when the instance factory throws an exception, it should not cause
                // a fatal error. We just leave the promise unresolved.
            }
        }
    }
    clearInstance(identifier = DEFAULT_ENTRY_NAME) {
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
    }
    // app.delete() will call this method on every provider to delete the services
    // TODO: should we mark the provider as deleted?
    async delete() {
        const services = Array.from(this.instances.values());
        await Promise.all([
            ...services
                .filter(service => 'INTERNAL' in service) // legacy services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service.INTERNAL.delete()),
            ...services
                .filter(service => '_delete' in service) // modularized services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service._delete())
        ]);
    }
    isComponentSet() {
        return this.component != null;
    }
    isInitialized(identifier = DEFAULT_ENTRY_NAME) {
        return this.instances.has(identifier);
    }
    getOptions(identifier = DEFAULT_ENTRY_NAME) {
        return this.instancesOptions.get(identifier) || {};
    }
    initialize(opts = {}) {
        const { options = {} } = opts;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) {
            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
        }
        if (!this.isComponentSet()) {
            throw Error(`Component ${this.name} has not been registered yet`);
        }
        const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier,
            options
        });
        // resolve any pending promise waiting for the service instance
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            if (normalizedIdentifier === normalizedDeferredIdentifier) {
                instanceDeferred.resolve(instance);
            }
        }
        return instance;
    }
    /**
     *
     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
     *
     * @param identifier An optional instance identifier
     * @returns a function to unregister the callback
     */
    onInit(callback, identifier) {
        var _a;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        const existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) {
            callback(existingInstance, normalizedIdentifier);
        }
        return () => {
            existingCallbacks.delete(callback);
        };
    }
    /**
     * Invoke onInit callbacks synchronously
     * @param instance the service instance`
     */
    invokeOnInitCallbacks(instance, identifier) {
        const callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) {
            return;
        }
        for (const callback of callbacks) {
            try {
                callback(instance, identifier);
            }
            catch (_a) {
                // ignore errors in the onInit callback
            }
        }
    }
    getOrInitializeService({ instanceIdentifier, options = {} }) {
        let instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) {
            instance = this.component.instanceFactory(this.container, {
                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
                options
            });
            this.instances.set(instanceIdentifier, instance);
            this.instancesOptions.set(instanceIdentifier, options);
            /**
             * Invoke onInit listeners.
             * Note this.component.onInstanceCreated is different, which is used by the component creator,
             * while onInit listeners are registered by consumers of the provider.
             */
            this.invokeOnInitCallbacks(instance, instanceIdentifier);
            /**
             * Order is important
             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which
             * makes `isInitialized()` return true.
             */
            if (this.component.onInstanceCreated) {
                try {
                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
                }
                catch (_a) {
                    // ignore errors in the onInstanceCreatedCallback
                }
            }
        }
        return instance || null;
    }
    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {
        if (this.component) {
            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
        }
        else {
            return identifier; // assume multiple instances are supported before the component is provided.
        }
    }
    shouldAutoInitialize() {
        return (!!this.component &&
            this.component.instantiationMode !== "EXPLICIT" /* InstantiationMode.EXPLICIT */);
    }
}
// undefined should be passed to the service factory for the default instance
function normalizeIdentifierForFactory(identifier) {
    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;
}
function isComponentEager(component) {
    return component.instantiationMode === "EAGER" /* InstantiationMode.EAGER */;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`
 */
class ComponentContainer {
    constructor(name) {
        this.name = name;
        this.providers = new Map();
    }
    /**
     *
     * @param component Component being added
     * @param overwrite When a component with the same name has already been registered,
     * if overwrite is true: overwrite the existing component with the new component and create a new
     * provider with the new component. It can be useful in tests where you want to use different mocks
     * for different tests.
     * if overwrite is false: throw an exception
     */
    addComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
        }
        provider.setComponent(component);
    }
    addOrOverwriteComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
            // delete the existing provider from the container, so we can register the new component
            this.providers.delete(component.name);
        }
        this.addComponent(component);
    }
    /**
     * getProvider provides a type safe interface where it can only be called with a field name
     * present in NameServiceMapping interface.
     *
     * Firebase SDKs providing services should extend NameServiceMapping interface to register
     * themselves.
     */
    getProvider(name) {
        if (this.providers.has(name)) {
            return this.providers.get(name);
        }
        // create a Provider for a service that hasn't registered with Firebase
        const provider = new Provider(name, this);
        this.providers.set(name, provider);
        return provider;
    }
    getProviders() {
        return Array.from(this.providers.values());
    }
}



;// CONCATENATED MODULE: ./node_modules/@firebase/logger/dist/esm/index.esm2017.js
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A container for all of the Logger instances
 */
const instances = [];
/**
 * The JS SDK supports 5 log levels and also allows a user the ability to
 * silence the logs altogether.
 *
 * The order is a follows:
 * DEBUG < VERBOSE < INFO < WARN < ERROR
 *
 * All of the log types above the current log level will be captured (i.e. if
 * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and
 * `VERBOSE` logs will not)
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
const levelStringToEnum = {
    'debug': LogLevel.DEBUG,
    'verbose': LogLevel.VERBOSE,
    'info': LogLevel.INFO,
    'warn': LogLevel.WARN,
    'error': LogLevel.ERROR,
    'silent': LogLevel.SILENT
};
/**
 * The default log level
 */
const defaultLogLevel = LogLevel.INFO;
/**
 * By default, `console.debug` is not displayed in the developer console (in
 * chrome). To avoid forcing users to have to opt-in to these logs twice
 * (i.e. once for firebase, and once in the console), we are sending `DEBUG`
 * logs to the `console.log` function.
 */
const ConsoleMethod = {
    [LogLevel.DEBUG]: 'log',
    [LogLevel.VERBOSE]: 'log',
    [LogLevel.INFO]: 'info',
    [LogLevel.WARN]: 'warn',
    [LogLevel.ERROR]: 'error'
};
/**
 * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR
 * messages on to their corresponding console counterparts (if the log method
 * is supported by the current log level)
 */
const defaultLogHandler = (instance, logType, ...args) => {
    if (logType < instance.logLevel) {
        return;
    }
    const now = new Date().toISOString();
    const method = ConsoleMethod[logType];
    if (method) {
        console[method](`[${now}]  ${instance.name}:`, ...args);
    }
    else {
        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
    }
};
class Logger {
    /**
     * Gives you an instance of a Logger to capture messages according to
     * Firebase's logging scheme.
     *
     * @param name The name that the logs will be associated with
     */
    constructor(name) {
        this.name = name;
        /**
         * The log level of the given Logger instance.
         */
        this._logLevel = defaultLogLevel;
        /**
         * The main (internal) log handler for the Logger instance.
         * Can be set to a new function in internal package code but not by user.
         */
        this._logHandler = defaultLogHandler;
        /**
         * The optional, additional, user-defined log handler for the Logger instance.
         */
        this._userLogHandler = null;
        /**
         * Capture the current instance for later use
         */
        instances.push(this);
    }
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(val) {
        if (!(val in LogLevel)) {
            throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
        }
        this._logLevel = val;
    }
    // Workaround for setter/getter having to be the same type.
    setLogLevel(val) {
        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;
    }
    get logHandler() {
        return this._logHandler;
    }
    set logHandler(val) {
        if (typeof val !== 'function') {
            throw new TypeError('Value assigned to `logHandler` must be a function');
        }
        this._logHandler = val;
    }
    get userLogHandler() {
        return this._userLogHandler;
    }
    set userLogHandler(val) {
        this._userLogHandler = val;
    }
    /**
     * The functions below are all based on the `console` interface
     */
    debug(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
        this._logHandler(this, LogLevel.DEBUG, ...args);
    }
    log(...args) {
        this._userLogHandler &&
            this._userLogHandler(this, LogLevel.VERBOSE, ...args);
        this._logHandler(this, LogLevel.VERBOSE, ...args);
    }
    info(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
        this._logHandler(this, LogLevel.INFO, ...args);
    }
    warn(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
        this._logHandler(this, LogLevel.WARN, ...args);
    }
    error(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
        this._logHandler(this, LogLevel.ERROR, ...args);
    }
}
function setLogLevel(level) {
    instances.forEach(inst => {
        inst.setLogLevel(level);
    });
}
function index_esm2017_setUserLogHandler(logCallback, options) {
    for (const instance of instances) {
        let customLogLevel = null;
        if (options && options.level) {
            customLogLevel = levelStringToEnum[options.level];
        }
        if (logCallback === null) {
            instance.userLogHandler = null;
        }
        else {
            instance.userLogHandler = (instance, level, ...args) => {
                const message = args
                    .map(arg => {
                    if (arg == null) {
                        return null;
                    }
                    else if (typeof arg === 'string') {
                        return arg;
                    }
                    else if (typeof arg === 'number' || typeof arg === 'boolean') {
                        return arg.toString();
                    }
                    else if (arg instanceof Error) {
                        return arg.message;
                    }
                    else {
                        try {
                            return JSON.stringify(arg);
                        }
                        catch (ignored) {
                            return null;
                        }
                    }
                })
                    .filter(arg => arg)
                    .join(' ');
                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {
                    logCallback({
                        level: LogLevel[level].toLowerCase(),
                        message,
                        args,
                        type: instance.name
                    });
                }
            };
        }
    }
}



;// CONCATENATED MODULE: ./node_modules/idb/build/wrap-idb-value.js
const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);

let idbProxyableTypes;
let cursorAdvanceMethods;
// This is a function to prevent it throwing up in node environments.
function getIdbProxyableTypes() {
    return (idbProxyableTypes ||
        (idbProxyableTypes = [
            IDBDatabase,
            IDBObjectStore,
            IDBIndex,
            IDBCursor,
            IDBTransaction,
        ]));
}
// This is a function to prevent it throwing up in node environments.
function getCursorAdvanceMethods() {
    return (cursorAdvanceMethods ||
        (cursorAdvanceMethods = [
            IDBCursor.prototype.advance,
            IDBCursor.prototype.continue,
            IDBCursor.prototype.continuePrimaryKey,
        ]));
}
const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
        const unlisten = () => {
            request.removeEventListener('success', success);
            request.removeEventListener('error', error);
        };
        const success = () => {
            resolve(wrap_idb_value_wrap(request.result));
            unlisten();
        };
        const error = () => {
            reject(request.error);
            unlisten();
        };
        request.addEventListener('success', success);
        request.addEventListener('error', error);
    });
    promise
        .then((value) => {
        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
        // (see wrapFunction).
        if (value instanceof IDBCursor) {
            cursorRequestMap.set(value, request);
        }
        // Catching to avoid "Uncaught Promise exceptions"
    })
        .catch(() => { });
    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
    // is because we create many promises from a single IDBRequest.
    reverseTransformCache.set(promise, request);
    return promise;
}
function cacheDonePromiseForTransaction(tx) {
    // Early bail if we've already created a done promise for this transaction.
    if (transactionDoneMap.has(tx))
        return;
    const done = new Promise((resolve, reject) => {
        const unlisten = () => {
            tx.removeEventListener('complete', complete);
            tx.removeEventListener('error', error);
            tx.removeEventListener('abort', error);
        };
        const complete = () => {
            resolve();
            unlisten();
        };
        const error = () => {
            reject(tx.error || new DOMException('AbortError', 'AbortError'));
            unlisten();
        };
        tx.addEventListener('complete', complete);
        tx.addEventListener('error', error);
        tx.addEventListener('abort', error);
    });
    // Cache it for later retrieval.
    transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
    get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
            // Special handling for transaction.done.
            if (prop === 'done')
                return transactionDoneMap.get(target);
            // Polyfill for objectStoreNames because of Edge.
            if (prop === 'objectStoreNames') {
                return target.objectStoreNames || transactionStoreNamesMap.get(target);
            }
            // Make tx.store return the only store in the transaction, or undefined if there are many.
            if (prop === 'store') {
                return receiver.objectStoreNames[1]
                    ? undefined
                    : receiver.objectStore(receiver.objectStoreNames[0]);
            }
        }
        // Else transform whatever we get back.
        return wrap_idb_value_wrap(target[prop]);
    },
    set(target, prop, value) {
        target[prop] = value;
        return true;
    },
    has(target, prop) {
        if (target instanceof IDBTransaction &&
            (prop === 'done' || prop === 'store')) {
            return true;
        }
        return prop in target;
    },
};
function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
    // Due to expected object equality (which is enforced by the caching in `wrap`), we
    // only create one new func per func.
    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
    if (func === IDBDatabase.prototype.transaction &&
        !('objectStoreNames' in IDBTransaction.prototype)) {
        return function (storeNames, ...args) {
            const tx = func.call(unwrap(this), storeNames, ...args);
            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
            return wrap_idb_value_wrap(tx);
        };
    }
    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
    // with real promises, so each advance methods returns a new promise for the cursor object, or
    // undefined if the end of the cursor has been reached.
    if (getCursorAdvanceMethods().includes(func)) {
        return function (...args) {
            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
            // the original object.
            func.apply(unwrap(this), args);
            return wrap_idb_value_wrap(cursorRequestMap.get(this));
        };
    }
    return function (...args) {
        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
        // the original object.
        return wrap_idb_value_wrap(func.apply(unwrap(this), args));
    };
}
function transformCachableValue(value) {
    if (typeof value === 'function')
        return wrapFunction(value);
    // This doesn't return, it just creates a 'done' promise for the transaction,
    // which is later returned for transaction.done (see idbObjectHandler).
    if (value instanceof IDBTransaction)
        cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
        return new Proxy(value, idbProxyTraps);
    // Return the same value back if we're not going to transform it.
    return value;
}
function wrap_idb_value_wrap(value) {
    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
    if (value instanceof IDBRequest)
        return promisifyRequest(value);
    // If we've already transformed this value before, reuse the transformed value.
    // This is faster, but it also provides object equality.
    if (transformCache.has(value))
        return transformCache.get(value);
    const newValue = transformCachableValue(value);
    // Not all types are transformed.
    // These may be primitive types, so they can't be WeakMap keys.
    if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
    }
    return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);



;// CONCATENATED MODULE: ./node_modules/idb/build/index.js



/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap_idb_value_wrap(request);
    if (upgrade) {
        request.addEventListener('upgradeneeded', (event) => {
            upgrade(wrap_idb_value_wrap(request.result), event.oldVersion, event.newVersion, wrap_idb_value_wrap(request.transaction), event);
        });
    }
    if (blocked) {
        request.addEventListener('blocked', (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion, event.newVersion, event));
    }
    openPromise
        .then((db) => {
        if (terminated)
            db.addEventListener('close', () => terminated());
        if (blocking) {
            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));
        }
    })
        .catch(() => { });
    return openPromise;
}
/**
 * Delete a database.
 *
 * @param name Name of the database.
 */
function deleteDB(name, { blocked } = {}) {
    const request = indexedDB.deleteDatabase(name);
    if (blocked) {
        request.addEventListener('blocked', (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion, event));
    }
    return wrap(request).then(() => undefined);
}

const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
const writeMethods = ['put', 'add', 'delete', 'clear'];
const cachedMethods = new Map();
function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase &&
        !(prop in target) &&
        typeof prop === 'string')) {
        return;
    }
    if (cachedMethods.get(prop))
        return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, '');
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
        !(isWrite || readMethods.includes(targetFuncName))) {
        return;
    }
    const method = async function (storeName, ...args) {
        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
        let target = tx.store;
        if (useIndex)
            target = target.index(args.shift());
        // Must reject if op rejects.
        // If it's a write operation, must reject if tx.done rejects.
        // Must reject with op rejection first.
        // Must resolve with op value.
        // Must handle both promises (no unhandled rejections)
        return (await Promise.all([
            target[targetFuncName](...args),
            isWrite && tx.done,
        ]))[0];
    };
    cachedMethods.set(prop, method);
    return method;
}
replaceTraps((oldTraps) => ({
    ...oldTraps,
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
}));



;// CONCATENATED MODULE: ./node_modules/@firebase/app/dist/esm/index.esm2017.js






/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlatformLoggerServiceImpl {
    constructor(container) {
        this.container = container;
    }
    // In initial implementation, this will be called by installations on
    // auth token refresh, and installations will send this string.
    getPlatformInfoString() {
        const providers = this.container.getProviders();
        // Loop through providers and get library/version pairs from any that are
        // version components.
        return providers
            .map(provider => {
            if (isVersionServiceProvider(provider)) {
                const service = provider.getImmediate();
                return `${service.library}/${service.version}`;
            }
            else {
                return null;
            }
        })
            .filter(logString => logString)
            .join(' ');
    }
}
/**
 *
 * @param provider check if this provider provides a VersionService
 *
 * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider
 * provides VersionService. The provider is not necessarily a 'app-version'
 * provider.
 */
function isVersionServiceProvider(provider) {
    const component = provider.getComponent();
    return (component === null || component === void 0 ? void 0 : component.type) === "VERSION" /* ComponentType.VERSION */;
}

const name$o = "@firebase/app";
const version$1 = "0.9.13";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger = new Logger('@firebase/app');

const name$n = "@firebase/app-compat";

const name$m = "@firebase/analytics-compat";

const name$l = "@firebase/analytics";

const name$k = "@firebase/app-check-compat";

const name$j = "@firebase/app-check";

const name$i = "@firebase/auth";

const name$h = "@firebase/auth-compat";

const name$g = "@firebase/database";

const name$f = "@firebase/database-compat";

const name$e = "@firebase/functions";

const name$d = "@firebase/functions-compat";

const name$c = "@firebase/installations";

const name$b = "@firebase/installations-compat";

const name$a = "@firebase/messaging";

const name$9 = "@firebase/messaging-compat";

const name$8 = "@firebase/performance";

const name$7 = "@firebase/performance-compat";

const name$6 = "@firebase/remote-config";

const name$5 = "@firebase/remote-config-compat";

const name$4 = "@firebase/storage";

const name$3 = "@firebase/storage-compat";

const name$2 = "@firebase/firestore";

const name$1 = "@firebase/firestore-compat";

const index_esm2017_name = "firebase";
const version = "9.23.0";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The default app name
 *
 * @internal
 */
const index_esm2017_DEFAULT_ENTRY_NAME = '[DEFAULT]';
const PLATFORM_LOG_STRING = {
    [name$o]: 'fire-core',
    [name$n]: 'fire-core-compat',
    [name$l]: 'fire-analytics',
    [name$m]: 'fire-analytics-compat',
    [name$j]: 'fire-app-check',
    [name$k]: 'fire-app-check-compat',
    [name$i]: 'fire-auth',
    [name$h]: 'fire-auth-compat',
    [name$g]: 'fire-rtdb',
    [name$f]: 'fire-rtdb-compat',
    [name$e]: 'fire-fn',
    [name$d]: 'fire-fn-compat',
    [name$c]: 'fire-iid',
    [name$b]: 'fire-iid-compat',
    [name$a]: 'fire-fcm',
    [name$9]: 'fire-fcm-compat',
    [name$8]: 'fire-perf',
    [name$7]: 'fire-perf-compat',
    [name$6]: 'fire-rc',
    [name$5]: 'fire-rc-compat',
    [name$4]: 'fire-gcs',
    [name$3]: 'fire-gcs-compat',
    [name$2]: 'fire-fst',
    [name$1]: 'fire-fst-compat',
    'fire-js': 'fire-js',
    [index_esm2017_name]: 'fire-js-all'
};

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
const _apps = new Map();
/**
 * Registered components.
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const _components = new Map();
/**
 * @param component - the component being added to this app's container
 *
 * @internal
 */
function _addComponent(app, component) {
    try {
        app.container.addComponent(component);
    }
    catch (e) {
        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);
    }
}
/**
 *
 * @internal
 */
function _addOrOverwriteComponent(app, component) {
    app.container.addOrOverwriteComponent(component);
}
/**
 *
 * @param component - the component to register
 * @returns whether or not the component is registered successfully
 *
 * @internal
 */
function _registerComponent(component) {
    const componentName = component.name;
    if (_components.has(componentName)) {
        logger.debug(`There were multiple attempts to register component ${componentName}.`);
        return false;
    }
    _components.set(componentName, component);
    // add the component to existing app instances
    for (const app of _apps.values()) {
        _addComponent(app, component);
    }
    return true;
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 *
 * @returns the provider for the service with the matching name
 *
 * @internal
 */
function _getProvider(app, name) {
    const heartbeatController = app.container
        .getProvider('heartbeat')
        .getImmediate({ optional: true });
    if (heartbeatController) {
        void heartbeatController.triggerHeartbeat();
    }
    return app.container.getProvider(name);
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 * @param instanceIdentifier - service instance identifier in case the service supports multiple instances
 *
 * @internal
 */
function _removeServiceInstance(app, name, instanceIdentifier = index_esm2017_DEFAULT_ENTRY_NAME) {
    _getProvider(app, name).clearInstance(instanceIdentifier);
}
/**
 * Test only
 *
 * @internal
 */
function _clearComponents() {
    _components.clear();
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = {
    ["no-app" /* AppError.NO_APP */]: "No Firebase App '{$appName}' has been created - " +
        'call initializeApp() first',
    ["bad-app-name" /* AppError.BAD_APP_NAME */]: "Illegal App name: '{$appName}",
    ["duplicate-app" /* AppError.DUPLICATE_APP */]: "Firebase App named '{$appName}' already exists with different options or config",
    ["app-deleted" /* AppError.APP_DELETED */]: "Firebase App named '{$appName}' already deleted",
    ["no-options" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',
    ["invalid-app-argument" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +
        'Firebase App instance.',
    ["invalid-log-argument" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',
    ["idb-open" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',
    ["idb-get" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',
    ["idb-set" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',
    ["idb-delete" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.'
};
const ERROR_FACTORY = new ErrorFactory('app', 'Firebase', ERRORS);

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl {
    constructor(options, config, container) {
        this._isDeleted = false;
        this._options = Object.assign({}, options);
        this._config = Object.assign({}, config);
        this._name = config.name;
        this._automaticDataCollectionEnabled =
            config.automaticDataCollectionEnabled;
        this._container = container;
        this.container.addComponent(new Component('app', () => this, "PUBLIC" /* ComponentType.PUBLIC */));
    }
    get automaticDataCollectionEnabled() {
        this.checkDestroyed();
        return this._automaticDataCollectionEnabled;
    }
    set automaticDataCollectionEnabled(val) {
        this.checkDestroyed();
        this._automaticDataCollectionEnabled = val;
    }
    get name() {
        this.checkDestroyed();
        return this._name;
    }
    get options() {
        this.checkDestroyed();
        return this._options;
    }
    get config() {
        this.checkDestroyed();
        return this._config;
    }
    get container() {
        return this._container;
    }
    get isDeleted() {
        return this._isDeleted;
    }
    set isDeleted(val) {
        this._isDeleted = val;
    }
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    checkDestroyed() {
        if (this.isDeleted) {
            throw ERROR_FACTORY.create("app-deleted" /* AppError.APP_DELETED */, { appName: this._name });
        }
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The current SDK version.
 *
 * @public
 */
const SDK_VERSION = version;
function initializeApp(_options, rawConfig = {}) {
    let options = _options;
    if (typeof rawConfig !== 'object') {
        const name = rawConfig;
        rawConfig = { name };
    }
    const config = Object.assign({ name: index_esm2017_DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);
    const name = config.name;
    if (typeof name !== 'string' || !name) {
        throw ERROR_FACTORY.create("bad-app-name" /* AppError.BAD_APP_NAME */, {
            appName: String(name)
        });
    }
    options || (options = getDefaultAppConfig());
    if (!options) {
        throw ERROR_FACTORY.create("no-options" /* AppError.NO_OPTIONS */);
    }
    const existingApp = _apps.get(name);
    if (existingApp) {
        // return the existing app if options and config deep equal the ones in the existing app.
        if (deepEqual(options, existingApp.options) &&
            deepEqual(config, existingApp.config)) {
            return existingApp;
        }
        else {
            throw ERROR_FACTORY.create("duplicate-app" /* AppError.DUPLICATE_APP */, { appName: name });
        }
    }
    const container = new ComponentContainer(name);
    for (const component of _components.values()) {
        container.addComponent(component);
    }
    const newApp = new FirebaseAppImpl(options, config, container);
    _apps.set(name, newApp);
    return newApp;
}
/**
 * Retrieves a {@link @firebase/app#FirebaseApp} instance.
 *
 * When called with no arguments, the default app is returned. When an app name
 * is provided, the app corresponding to that name is returned.
 *
 * An exception is thrown if the app being retrieved has not yet been
 * initialized.
 *
 * @example
 * ```javascript
 * // Return the default app
 * const app = getApp();
 * ```
 *
 * @example
 * ```javascript
 * // Return a named app
 * const otherApp = getApp("otherApp");
 * ```
 *
 * @param name - Optional name of the app to return. If no name is
 *   provided, the default is `"[DEFAULT]"`.
 *
 * @returns The app corresponding to the provided app name.
 *   If no app name is provided, the default app is returned.
 *
 * @public
 */
function getApp(name = index_esm2017_DEFAULT_ENTRY_NAME) {
    const app = _apps.get(name);
    if (!app && name === index_esm2017_DEFAULT_ENTRY_NAME && getDefaultAppConfig()) {
        return initializeApp();
    }
    if (!app) {
        throw ERROR_FACTORY.create("no-app" /* AppError.NO_APP */, { appName: name });
    }
    return app;
}
/**
 * A (read-only) array of all initialized apps.
 * @public
 */
function getApps() {
    return Array.from(_apps.values());
}
/**
 * Renders this app unusable and frees the resources of all associated
 * services.
 *
 * @example
 * ```javascript
 * deleteApp(app)
 *   .then(function() {
 *     console.log("App deleted successfully");
 *   })
 *   .catch(function(error) {
 *     console.log("Error deleting app:", error);
 *   });
 * ```
 *
 * @public
 */
async function deleteApp(app) {
    const name = app.name;
    if (_apps.has(name)) {
        _apps.delete(name);
        await Promise.all(app.container
            .getProviders()
            .map(provider => provider.delete()));
        app.isDeleted = true;
    }
}
/**
 * Registers a library's name and version for platform logging purposes.
 * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)
 * @param version - Current version of that library.
 * @param variant - Bundle variant, e.g., node, rn, etc.
 *
 * @public
 */
function registerVersion(libraryKeyOrName, version, variant) {
    var _a;
    // TODO: We can use this check to whitelist strings when/if we set up
    // a good whitelist system.
    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
    if (variant) {
        library += `-${variant}`;
    }
    const libraryMismatch = library.match(/\s|\//);
    const versionMismatch = version.match(/\s|\//);
    if (libraryMismatch || versionMismatch) {
        const warning = [
            `Unable to register library "${library}" with version "${version}":`
        ];
        if (libraryMismatch) {
            warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
        }
        if (libraryMismatch && versionMismatch) {
            warning.push('and');
        }
        if (versionMismatch) {
            warning.push(`version name "${version}" contains illegal characters (whitespace or "/")`);
        }
        logger.warn(warning.join(' '));
        return;
    }
    _registerComponent(new Component(`${library}-version`, () => ({ library, version }), "VERSION" /* ComponentType.VERSION */));
}
/**
 * Sets log handler for all Firebase SDKs.
 * @param logCallback - An optional custom log handler that executes user code whenever
 * the Firebase SDK makes a logging call.
 *
 * @public
 */
function onLog(logCallback, options) {
    if (logCallback !== null && typeof logCallback !== 'function') {
        throw ERROR_FACTORY.create("invalid-log-argument" /* AppError.INVALID_LOG_ARGUMENT */);
    }
    setUserLogHandler(logCallback, options);
}
/**
 * Sets log level for all Firebase SDKs.
 *
 * All of the log types above the current log level are captured (i.e. if
 * you set the log level to `info`, errors are logged, but `debug` and
 * `verbose` logs are not).
 *
 * @public
 */
function index_esm2017_setLogLevel(logLevel) {
    setLogLevel$1(logLevel);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME = 'firebase-heartbeat-database';
const DB_VERSION = 1;
const STORE_NAME = 'firebase-heartbeat-store';
let dbPromise = null;
function getDbPromise() {
    if (!dbPromise) {
        dbPromise = openDB(DB_NAME, DB_VERSION, {
            upgrade: (db, oldVersion) => {
                // We don't use 'break' in this switch statement, the fall-through
                // behavior is what we want, because if there are multiple versions between
                // the old version and the current version, we want ALL the migrations
                // that correspond to those versions to run, not only the last one.
                // eslint-disable-next-line default-case
                switch (oldVersion) {
                    case 0:
                        db.createObjectStore(STORE_NAME);
                }
            }
        }).catch(e => {
            throw ERROR_FACTORY.create("idb-open" /* AppError.IDB_OPEN */, {
                originalErrorMessage: e.message
            });
        });
    }
    return dbPromise;
}
async function readHeartbeatsFromIndexedDB(app) {
    try {
        const db = await getDbPromise();
        const result = await db
            .transaction(STORE_NAME)
            .objectStore(STORE_NAME)
            .get(computeKey(app));
        return result;
    }
    catch (e) {
        if (e instanceof FirebaseError) {
            logger.warn(e.message);
        }
        else {
            const idbGetError = ERROR_FACTORY.create("idb-get" /* AppError.IDB_GET */, {
                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
            });
            logger.warn(idbGetError.message);
        }
    }
}
async function writeHeartbeatsToIndexedDB(app, heartbeatObject) {
    try {
        const db = await getDbPromise();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const objectStore = tx.objectStore(STORE_NAME);
        await objectStore.put(heartbeatObject, computeKey(app));
        await tx.done;
    }
    catch (e) {
        if (e instanceof FirebaseError) {
            logger.warn(e.message);
        }
        else {
            const idbGetError = ERROR_FACTORY.create("idb-set" /* AppError.IDB_WRITE */, {
                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
            });
            logger.warn(idbGetError.message);
        }
    }
}
function computeKey(app) {
    return `${app.name}!${app.options.appId}`;
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_HEADER_BYTES = 1024;
// 30 days
const STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;
class HeartbeatServiceImpl {
    constructor(container) {
        this.container = container;
        /**
         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate
         * the header string.
         * Stores one record per date. This will be consolidated into the standard
         * format of one record per user agent string before being sent as a header.
         * Populated from indexedDB when the controller is instantiated and should
         * be kept in sync with indexedDB.
         * Leave public for easier testing.
         */
        this._heartbeatsCache = null;
        const app = this.container.getProvider('app').getImmediate();
        this._storage = new HeartbeatStorageImpl(app);
        this._heartbeatsCachePromise = this._storage.read().then(result => {
            this._heartbeatsCache = result;
            return result;
        });
    }
    /**
     * Called to report a heartbeat. The function will generate
     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
     * to IndexedDB.
     * Note that we only store one heartbeat per day. So if a heartbeat for today is
     * already logged, subsequent calls to this function in the same day will be ignored.
     */
    async triggerHeartbeat() {
        const platformLogger = this.container
            .getProvider('platform-logger')
            .getImmediate();
        // This is the "Firebase user agent" string from the platform logger
        // service, not the browser user agent.
        const agent = platformLogger.getPlatformInfoString();
        const date = getUTCDateString();
        if (this._heartbeatsCache === null) {
            this._heartbeatsCache = await this._heartbeatsCachePromise;
        }
        // Do not store a heartbeat if one is already stored for this day
        // or if a header has already been sent today.
        if (this._heartbeatsCache.lastSentHeartbeatDate === date ||
            this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {
            return;
        }
        else {
            // There is no entry for this date. Create one.
            this._heartbeatsCache.heartbeats.push({ date, agent });
        }
        // Remove entries older than 30 days.
        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {
            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
            const now = Date.now();
            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
        });
        return this._storage.overwrite(this._heartbeatsCache);
    }
    /**
     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
     * It also clears all heartbeats from memory as well as in IndexedDB.
     *
     * NOTE: Consuming product SDKs should not send the header if this method
     * returns an empty string.
     */
    async getHeartbeatsHeader() {
        if (this._heartbeatsCache === null) {
            await this._heartbeatsCachePromise;
        }
        // If it's still null or the array is empty, there is no data to send.
        if (this._heartbeatsCache === null ||
            this._heartbeatsCache.heartbeats.length === 0) {
            return '';
        }
        const date = getUTCDateString();
        // Extract as many heartbeats from the cache as will fit under the size limit.
        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
        const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
        // Store last sent date to prevent another being logged/sent for the same day.
        this._heartbeatsCache.lastSentHeartbeatDate = date;
        if (unsentEntries.length > 0) {
            // Store any unsent entries if they exist.
            this._heartbeatsCache.heartbeats = unsentEntries;
            // This seems more likely than emptying the array (below) to lead to some odd state
            // since the cache isn't empty and this will be called again on the next request,
            // and is probably safest if we await it.
            await this._storage.overwrite(this._heartbeatsCache);
        }
        else {
            this._heartbeatsCache.heartbeats = [];
            // Do not wait for this, to reduce latency.
            void this._storage.overwrite(this._heartbeatsCache);
        }
        return headerString;
    }
}
function getUTCDateString() {
    const today = new Date();
    // Returns date format 'YYYY-MM-DD'
    return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
    // Heartbeats grouped by user agent in the standard format to be sent in
    // the header.
    const heartbeatsToSend = [];
    // Single date format heartbeats that are not sent.
    let unsentEntries = heartbeatsCache.slice();
    for (const singleDateHeartbeat of heartbeatsCache) {
        // Look for an existing entry with the same user agent.
        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);
        if (!heartbeatEntry) {
            // If no entry for this user agent exists, create one.
            heartbeatsToSend.push({
                agent: singleDateHeartbeat.agent,
                dates: [singleDateHeartbeat.date]
            });
            if (countBytes(heartbeatsToSend) > maxSize) {
                // If the header would exceed max size, remove the added heartbeat
                // entry and stop adding to the header.
                heartbeatsToSend.pop();
                break;
            }
        }
        else {
            heartbeatEntry.dates.push(singleDateHeartbeat.date);
            // If the header would exceed max size, remove the added date
            // and stop adding to the header.
            if (countBytes(heartbeatsToSend) > maxSize) {
                heartbeatEntry.dates.pop();
                break;
            }
        }
        // Pop unsent entry from queue. (Skipped if adding the entry exceeded
        // quota and the loop breaks early.)
        unsentEntries = unsentEntries.slice(1);
    }
    return {
        heartbeatsToSend,
        unsentEntries
    };
}
class HeartbeatStorageImpl {
    constructor(app) {
        this.app = app;
        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
    }
    async runIndexedDBEnvironmentCheck() {
        if (!isIndexedDBAvailable()) {
            return false;
        }
        else {
            return validateIndexedDBOpenable()
                .then(() => true)
                .catch(() => false);
        }
    }
    /**
     * Read all heartbeats.
     */
    async read() {
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return { heartbeats: [] };
        }
        else {
            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
            return idbHeartbeatObject || { heartbeats: [] };
        }
    }
    // overwrite the storage with the provided heartbeats
    async overwrite(heartbeatsObject) {
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return;
        }
        else {
            const existingHeartbeatsObject = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
                heartbeats: heartbeatsObject.heartbeats
            });
        }
    }
    // add heartbeats
    async add(heartbeatsObject) {
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return;
        }
        else {
            const existingHeartbeatsObject = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
                heartbeats: [
                    ...existingHeartbeatsObject.heartbeats,
                    ...heartbeatsObject.heartbeats
                ]
            });
        }
    }
}
/**
 * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped
 * in a platform logging header JSON object, stringified, and converted
 * to base 64.
 */
function countBytes(heartbeatsCache) {
    // base64 has a restricted set of characters, all of which should be 1 byte.
    return base64urlEncodeWithoutPadding(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents(variant) {
    _registerComponent(new Component('platform-logger', container => new PlatformLoggerServiceImpl(container), "PRIVATE" /* ComponentType.PRIVATE */));
    _registerComponent(new Component('heartbeat', container => new HeartbeatServiceImpl(container), "PRIVATE" /* ComponentType.PRIVATE */));
    // Register `app` package.
    registerVersion(name$o, version$1, variant);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(name$o, version$1, 'esm2017');
    // Register platform SDK identifier (no version).
    registerVersion('fire-js', '');
}

/**
 * Firebase App
 *
 * @remarks This package coordinates the communication between the different Firebase components
 * @packageDocumentation
 */
registerCoreComponents('');



;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.mjs
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

/* harmony default export */ const tslib_es6 = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
});

;// CONCATENATED MODULE: ./node_modules/@firebase/auth/dist/esm2017/index-e3d5d3f4.js






/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An enum of factors that may be used for multifactor authentication.
 *
 * @public
 */
const FactorId = {
    /** Phone as second factor */
    PHONE: 'phone',
    TOTP: 'totp'
};
/**
 * Enumeration of supported providers.
 *
 * @public
 */
const ProviderId = {
    /** Facebook provider ID */
    FACEBOOK: 'facebook.com',
    /** GitHub provider ID */
    GITHUB: 'github.com',
    /** Google provider ID */
    GOOGLE: 'google.com',
    /** Password provider */
    PASSWORD: 'password',
    /** Phone provider */
    PHONE: 'phone',
    /** Twitter provider ID */
    TWITTER: 'twitter.com'
};
/**
 * Enumeration of supported sign-in methods.
 *
 * @public
 */
const SignInMethod = {
    /** Email link sign in method */
    EMAIL_LINK: 'emailLink',
    /** Email/password sign in method */
    EMAIL_PASSWORD: 'password',
    /** Facebook sign in method */
    FACEBOOK: 'facebook.com',
    /** GitHub sign in method */
    GITHUB: 'github.com',
    /** Google sign in method */
    GOOGLE: 'google.com',
    /** Phone sign in method */
    PHONE: 'phone',
    /** Twitter sign in method */
    TWITTER: 'twitter.com'
};
/**
 * Enumeration of supported operation types.
 *
 * @public
 */
const OperationType = {
    /** Operation involving linking an additional provider to an already signed-in user. */
    LINK: 'link',
    /** Operation involving using a provider to reauthenticate an already signed-in user. */
    REAUTHENTICATE: 'reauthenticate',
    /** Operation involving signing in a user. */
    SIGN_IN: 'signIn'
};
/**
 * An enumeration of the possible email action types.
 *
 * @public
 */
const ActionCodeOperation = {
    /** The email link sign-in action. */
    EMAIL_SIGNIN: 'EMAIL_SIGNIN',
    /** The password reset action. */
    PASSWORD_RESET: 'PASSWORD_RESET',
    /** The email revocation action. */
    RECOVER_EMAIL: 'RECOVER_EMAIL',
    /** The revert second factor addition email action. */
    REVERT_SECOND_FACTOR_ADDITION: 'REVERT_SECOND_FACTOR_ADDITION',
    /** The revert second factor addition email action. */
    VERIFY_AND_CHANGE_EMAIL: 'VERIFY_AND_CHANGE_EMAIL',
    /** The email verification action. */
    VERIFY_EMAIL: 'VERIFY_EMAIL'
};

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _debugErrorMap() {
    return {
        ["admin-restricted-operation" /* AuthErrorCode.ADMIN_ONLY_OPERATION */]: 'This operation is restricted to administrators only.',
        ["argument-error" /* AuthErrorCode.ARGUMENT_ERROR */]: '',
        ["app-not-authorized" /* AuthErrorCode.APP_NOT_AUTHORIZED */]: "This app, identified by the domain where it's hosted, is not " +
            'authorized to use Firebase Authentication with the provided API key. ' +
            'Review your key configuration in the Google API console.',
        ["app-not-installed" /* AuthErrorCode.APP_NOT_INSTALLED */]: 'The requested mobile application corresponding to the identifier (' +
            'Android package name or iOS bundle ID) provided is not installed on ' +
            'this device.',
        ["captcha-check-failed" /* AuthErrorCode.CAPTCHA_CHECK_FAILED */]: 'The reCAPTCHA response token provided is either invalid, expired, ' +
            'already used or the domain associated with it does not match the list ' +
            'of whitelisted domains.',
        ["code-expired" /* AuthErrorCode.CODE_EXPIRED */]: 'The SMS code has expired. Please re-send the verification code to try ' +
            'again.',
        ["cordova-not-ready" /* AuthErrorCode.CORDOVA_NOT_READY */]: 'Cordova framework is not ready.',
        ["cors-unsupported" /* AuthErrorCode.CORS_UNSUPPORTED */]: 'This browser is not supported.',
        ["credential-already-in-use" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */]: 'This credential is already associated with a different user account.',
        ["custom-token-mismatch" /* AuthErrorCode.CREDENTIAL_MISMATCH */]: 'The custom token corresponds to a different audience.',
        ["requires-recent-login" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: 'This operation is sensitive and requires recent authentication. Log in ' +
            'again before retrying this request.',
        ["dependent-sdk-initialized-before-auth" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +
            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +
            'starting any other Firebase SDK.',
        ["dynamic-link-not-activated" /* AuthErrorCode.DYNAMIC_LINK_NOT_ACTIVATED */]: 'Please activate Dynamic Links in the Firebase Console and agree to the terms and ' +
            'conditions.',
        ["email-change-needs-verification" /* AuthErrorCode.EMAIL_CHANGE_NEEDS_VERIFICATION */]: 'Multi-factor users must always have a verified email.',
        ["email-already-in-use" /* AuthErrorCode.EMAIL_EXISTS */]: 'The email address is already in use by another account.',
        ["emulator-config-failed" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */]: 'Auth instance has already been used to make a network call. Auth can ' +
            'no longer be configured to use the emulator. Try calling ' +
            '"connectAuthEmulator()" sooner.',
        ["expired-action-code" /* AuthErrorCode.EXPIRED_OOB_CODE */]: 'The action code has expired.',
        ["cancelled-popup-request" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */]: 'This operation has been cancelled due to another conflicting popup being opened.',
        ["internal-error" /* AuthErrorCode.INTERNAL_ERROR */]: 'An internal AuthError has occurred.',
        ["invalid-app-credential" /* AuthErrorCode.INVALID_APP_CREDENTIAL */]: 'The phone verification request contains an invalid application verifier.' +
            ' The reCAPTCHA token response is either invalid or expired.',
        ["invalid-app-id" /* AuthErrorCode.INVALID_APP_ID */]: 'The mobile app identifier is not registed for the current project.',
        ["invalid-user-token" /* AuthErrorCode.INVALID_AUTH */]: "This user's credential isn't valid for this project. This can happen " +
            "if the user's token has been tampered with, or if the user isn't for " +
            'the project associated with this API key.',
        ["invalid-auth-event" /* AuthErrorCode.INVALID_AUTH_EVENT */]: 'An internal AuthError has occurred.',
        ["invalid-verification-code" /* AuthErrorCode.INVALID_CODE */]: 'The SMS verification code used to create the phone auth credential is ' +
            'invalid. Please resend the verification code sms and be sure to use the ' +
            'verification code provided by the user.',
        ["invalid-continue-uri" /* AuthErrorCode.INVALID_CONTINUE_URI */]: 'The continue URL provided in the request is invalid.',
        ["invalid-cordova-configuration" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */]: 'The following Cordova plugins must be installed to enable OAuth sign-in: ' +
            'cordova-plugin-buildinfo, cordova-universal-links-plugin, ' +
            'cordova-plugin-browsertab, cordova-plugin-inappbrowser and ' +
            'cordova-plugin-customurlscheme.',
        ["invalid-custom-token" /* AuthErrorCode.INVALID_CUSTOM_TOKEN */]: 'The custom token format is incorrect. Please check the documentation.',
        ["invalid-dynamic-link-domain" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */]: 'The provided dynamic link domain is not configured or authorized for the current project.',
        ["invalid-email" /* AuthErrorCode.INVALID_EMAIL */]: 'The email address is badly formatted.',
        ["invalid-emulator-scheme" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */]: 'Emulator URL must start with a valid scheme (http:// or https://).',
        ["invalid-api-key" /* AuthErrorCode.INVALID_API_KEY */]: 'Your API key is invalid, please check you have copied it correctly.',
        ["invalid-cert-hash" /* AuthErrorCode.INVALID_CERT_HASH */]: 'The SHA-1 certificate hash provided is invalid.',
        ["invalid-credential" /* AuthErrorCode.INVALID_IDP_RESPONSE */]: 'The supplied auth credential is malformed or has expired.',
        ["invalid-message-payload" /* AuthErrorCode.INVALID_MESSAGE_PAYLOAD */]: 'The email template corresponding to this action contains invalid characters in its message. ' +
            'Please fix by going to the Auth email templates section in the Firebase Console.',
        ["invalid-multi-factor-session" /* AuthErrorCode.INVALID_MFA_SESSION */]: 'The request does not contain a valid proof of first factor successful sign-in.',
        ["invalid-oauth-provider" /* AuthErrorCode.INVALID_OAUTH_PROVIDER */]: 'EmailAuthProvider is not supported for this operation. This operation ' +
            'only supports OAuth providers.',
        ["invalid-oauth-client-id" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */]: 'The OAuth client ID provided is either invalid or does not match the ' +
            'specified API key.',
        ["unauthorized-domain" /* AuthErrorCode.INVALID_ORIGIN */]: 'This domain is not authorized for OAuth operations for your Firebase ' +
            'project. Edit the list of authorized domains from the Firebase console.',
        ["invalid-action-code" /* AuthErrorCode.INVALID_OOB_CODE */]: 'The action code is invalid. This can happen if the code is malformed, ' +
            'expired, or has already been used.',
        ["wrong-password" /* AuthErrorCode.INVALID_PASSWORD */]: 'The password is invalid or the user does not have a password.',
        ["invalid-persistence-type" /* AuthErrorCode.INVALID_PERSISTENCE */]: 'The specified persistence type is invalid. It can only be local, session or none.',
        ["invalid-phone-number" /* AuthErrorCode.INVALID_PHONE_NUMBER */]: 'The format of the phone number provided is incorrect. Please enter the ' +
            'phone number in a format that can be parsed into E.164 format. E.164 ' +
            'phone numbers are written in the format [+][country code][subscriber ' +
            'number including area code].',
        ["invalid-provider-id" /* AuthErrorCode.INVALID_PROVIDER_ID */]: 'The specified provider ID is invalid.',
        ["invalid-recipient-email" /* AuthErrorCode.INVALID_RECIPIENT_EMAIL */]: 'The email corresponding to this action failed to send as the provided ' +
            'recipient email address is invalid.',
        ["invalid-sender" /* AuthErrorCode.INVALID_SENDER */]: 'The email template corresponding to this action contains an invalid sender email or name. ' +
            'Please fix by going to the Auth email templates section in the Firebase Console.',
        ["invalid-verification-id" /* AuthErrorCode.INVALID_SESSION_INFO */]: 'The verification ID used to create the phone auth credential is invalid.',
        ["invalid-tenant-id" /* AuthErrorCode.INVALID_TENANT_ID */]: "The Auth instance's tenant ID is invalid.",
        ["login-blocked" /* AuthErrorCode.LOGIN_BLOCKED */]: 'Login blocked by user-provided method: {$originalMessage}',
        ["missing-android-pkg-name" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */]: 'An Android Package Name must be provided if the Android App is required to be installed.',
        ["auth-domain-config-required" /* AuthErrorCode.MISSING_AUTH_DOMAIN */]: 'Be sure to include authDomain when calling firebase.initializeApp(), ' +
            'by following the instructions in the Firebase console.',
        ["missing-app-credential" /* AuthErrorCode.MISSING_APP_CREDENTIAL */]: 'The phone verification request is missing an application verifier ' +
            'assertion. A reCAPTCHA response token needs to be provided.',
        ["missing-verification-code" /* AuthErrorCode.MISSING_CODE */]: 'The phone auth credential was created with an empty SMS verification code.',
        ["missing-continue-uri" /* AuthErrorCode.MISSING_CONTINUE_URI */]: 'A continue URL must be provided in the request.',
        ["missing-iframe-start" /* AuthErrorCode.MISSING_IFRAME_START */]: 'An internal AuthError has occurred.',
        ["missing-ios-bundle-id" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */]: 'An iOS Bundle ID must be provided if an App Store ID is provided.',
        ["missing-or-invalid-nonce" /* AuthErrorCode.MISSING_OR_INVALID_NONCE */]: 'The request does not contain a valid nonce. This can occur if the ' +
            'SHA-256 hash of the provided raw nonce does not match the hashed nonce ' +
            'in the ID token payload.',
        ["missing-password" /* AuthErrorCode.MISSING_PASSWORD */]: 'A non-empty password must be provided',
        ["missing-multi-factor-info" /* AuthErrorCode.MISSING_MFA_INFO */]: 'No second factor identifier is provided.',
        ["missing-multi-factor-session" /* AuthErrorCode.MISSING_MFA_SESSION */]: 'The request is missing proof of first factor successful sign-in.',
        ["missing-phone-number" /* AuthErrorCode.MISSING_PHONE_NUMBER */]: 'To send verification codes, provide a phone number for the recipient.',
        ["missing-verification-id" /* AuthErrorCode.MISSING_SESSION_INFO */]: 'The phone auth credential was created with an empty verification ID.',
        ["app-deleted" /* AuthErrorCode.MODULE_DESTROYED */]: 'This instance of FirebaseApp has been deleted.',
        ["multi-factor-info-not-found" /* AuthErrorCode.MFA_INFO_NOT_FOUND */]: 'The user does not have a second factor matching the identifier provided.',
        ["multi-factor-auth-required" /* AuthErrorCode.MFA_REQUIRED */]: 'Proof of ownership of a second factor is required to complete sign-in.',
        ["account-exists-with-different-credential" /* AuthErrorCode.NEED_CONFIRMATION */]: 'An account already exists with the same email address but different ' +
            'sign-in credentials. Sign in using a provider associated with this ' +
            'email address.',
        ["network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */]: 'A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.',
        ["no-auth-event" /* AuthErrorCode.NO_AUTH_EVENT */]: 'An internal AuthError has occurred.',
        ["no-such-provider" /* AuthErrorCode.NO_SUCH_PROVIDER */]: 'User was not linked to an account with the given provider.',
        ["null-user" /* AuthErrorCode.NULL_USER */]: 'A null user object was provided as the argument for an operation which ' +
            'requires a non-null user object.',
        ["operation-not-allowed" /* AuthErrorCode.OPERATION_NOT_ALLOWED */]: 'The given sign-in provider is disabled for this Firebase project. ' +
            'Enable it in the Firebase console, under the sign-in method tab of the ' +
            'Auth section.',
        ["operation-not-supported-in-this-environment" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */]: 'This operation is not supported in the environment this application is ' +
            'running on. "location.protocol" must be http, https or chrome-extension' +
            ' and web storage must be enabled.',
        ["popup-blocked" /* AuthErrorCode.POPUP_BLOCKED */]: 'Unable to establish a connection with the popup. It may have been blocked by the browser.',
        ["popup-closed-by-user" /* AuthErrorCode.POPUP_CLOSED_BY_USER */]: 'The popup has been closed by the user before finalizing the operation.',
        ["provider-already-linked" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */]: 'User can only be linked to one identity for the given provider.',
        ["quota-exceeded" /* AuthErrorCode.QUOTA_EXCEEDED */]: "The project's quota for this operation has been exceeded.",
        ["redirect-cancelled-by-user" /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */]: 'The redirect operation has been cancelled by the user before finalizing.',
        ["redirect-operation-pending" /* AuthErrorCode.REDIRECT_OPERATION_PENDING */]: 'A redirect sign-in operation is already pending.',
        ["rejected-credential" /* AuthErrorCode.REJECTED_CREDENTIAL */]: 'The request contains malformed or mismatching credentials.',
        ["second-factor-already-in-use" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */]: 'The second factor is already enrolled on this account.',
        ["maximum-second-factor-count-exceeded" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */]: 'The maximum allowed number of second factors on a user has been exceeded.',
        ["tenant-id-mismatch" /* AuthErrorCode.TENANT_ID_MISMATCH */]: "The provided tenant ID does not match the Auth instance's tenant ID",
        ["timeout" /* AuthErrorCode.TIMEOUT */]: 'The operation has timed out.',
        ["user-token-expired" /* AuthErrorCode.TOKEN_EXPIRED */]: "The user's credential is no longer valid. The user must sign in again.",
        ["too-many-requests" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */]: 'We have blocked all requests from this device due to unusual activity. ' +
            'Try again later.',
        ["unauthorized-continue-uri" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */]: 'The domain of the continue URL is not whitelisted.  Please whitelist ' +
            'the domain in the Firebase console.',
        ["unsupported-first-factor" /* AuthErrorCode.UNSUPPORTED_FIRST_FACTOR */]: 'Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.',
        ["unsupported-persistence-type" /* AuthErrorCode.UNSUPPORTED_PERSISTENCE */]: 'The current environment does not support the specified persistence type.',
        ["unsupported-tenant-operation" /* AuthErrorCode.UNSUPPORTED_TENANT_OPERATION */]: 'This operation is not supported in a multi-tenant context.',
        ["unverified-email" /* AuthErrorCode.UNVERIFIED_EMAIL */]: 'The operation requires a verified email.',
        ["user-cancelled" /* AuthErrorCode.USER_CANCELLED */]: 'The user did not grant your application the permissions it requested.',
        ["user-not-found" /* AuthErrorCode.USER_DELETED */]: 'There is no user record corresponding to this identifier. The user may ' +
            'have been deleted.',
        ["user-disabled" /* AuthErrorCode.USER_DISABLED */]: 'The user account has been disabled by an administrator.',
        ["user-mismatch" /* AuthErrorCode.USER_MISMATCH */]: 'The supplied credentials do not correspond to the previously signed in user.',
        ["user-signed-out" /* AuthErrorCode.USER_SIGNED_OUT */]: '',
        ["weak-password" /* AuthErrorCode.WEAK_PASSWORD */]: 'The password must be 6 characters long or more.',
        ["web-storage-unsupported" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */]: 'This browser is not supported or 3rd party cookies and data may be disabled.',
        ["already-initialized" /* AuthErrorCode.ALREADY_INITIALIZED */]: 'initializeAuth() has already been called with ' +
            'different options. To avoid this error, call initializeAuth() with the ' +
            'same options as when it was originally called, or call getAuth() to return the' +
            ' already initialized instance.',
        ["missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is missing when sending request to the backend.',
        ["invalid-recaptcha-token" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is invalid when sending request to the backend.',
        ["invalid-recaptcha-action" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */]: 'The reCAPTCHA action is invalid when sending request to the backend.',
        ["recaptcha-not-enabled" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */]: 'reCAPTCHA Enterprise integration is not enabled for this project.',
        ["missing-client-type" /* AuthErrorCode.MISSING_CLIENT_TYPE */]: 'The reCAPTCHA client type is missing when sending request to the backend.',
        ["missing-recaptcha-version" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is missing when sending request to the backend.',
        ["invalid-req-type" /* AuthErrorCode.INVALID_REQ_TYPE */]: 'Invalid request parameters.',
        ["invalid-recaptcha-version" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is invalid when sending request to the backend.'
    };
}
function _prodErrorMap() {
    // We will include this one message in the prod error map since by the very
    // nature of this error, developers will never be able to see the message
    // using the debugErrorMap (which is installed during auth initialization).
    return {
        ["dependent-sdk-initialized-before-auth" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +
            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +
            'starting any other Firebase SDK.'
    };
}
/**
 * A verbose error map with detailed descriptions for most error codes.
 *
 * See discussion at {@link AuthErrorMap}
 *
 * @public
 */
const debugErrorMap = (/* unused pure expression or super */ null && (_debugErrorMap));
/**
 * A minimal error map with all verbose error messages stripped.
 *
 * See discussion at {@link AuthErrorMap}
 *
 * @public
 */
const prodErrorMap = _prodErrorMap;
const _DEFAULT_AUTH_ERROR_FACTORY = new ErrorFactory('auth', 'Firebase', _prodErrorMap());
/**
 * A map of potential `Auth` error codes, for easier comparison with errors
 * thrown by the SDK.
 *
 * @remarks
 * Note that you can't tree-shake individual keys
 * in the map, so by using the map you might substantially increase your
 * bundle size.
 *
 * @public
 */
const AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {
    ADMIN_ONLY_OPERATION: 'auth/admin-restricted-operation',
    ARGUMENT_ERROR: 'auth/argument-error',
    APP_NOT_AUTHORIZED: 'auth/app-not-authorized',
    APP_NOT_INSTALLED: 'auth/app-not-installed',
    CAPTCHA_CHECK_FAILED: 'auth/captcha-check-failed',
    CODE_EXPIRED: 'auth/code-expired',
    CORDOVA_NOT_READY: 'auth/cordova-not-ready',
    CORS_UNSUPPORTED: 'auth/cors-unsupported',
    CREDENTIAL_ALREADY_IN_USE: 'auth/credential-already-in-use',
    CREDENTIAL_MISMATCH: 'auth/custom-token-mismatch',
    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'auth/requires-recent-login',
    DEPENDENT_SDK_INIT_BEFORE_AUTH: 'auth/dependent-sdk-initialized-before-auth',
    DYNAMIC_LINK_NOT_ACTIVATED: 'auth/dynamic-link-not-activated',
    EMAIL_CHANGE_NEEDS_VERIFICATION: 'auth/email-change-needs-verification',
    EMAIL_EXISTS: 'auth/email-already-in-use',
    EMULATOR_CONFIG_FAILED: 'auth/emulator-config-failed',
    EXPIRED_OOB_CODE: 'auth/expired-action-code',
    EXPIRED_POPUP_REQUEST: 'auth/cancelled-popup-request',
    INTERNAL_ERROR: 'auth/internal-error',
    INVALID_API_KEY: 'auth/invalid-api-key',
    INVALID_APP_CREDENTIAL: 'auth/invalid-app-credential',
    INVALID_APP_ID: 'auth/invalid-app-id',
    INVALID_AUTH: 'auth/invalid-user-token',
    INVALID_AUTH_EVENT: 'auth/invalid-auth-event',
    INVALID_CERT_HASH: 'auth/invalid-cert-hash',
    INVALID_CODE: 'auth/invalid-verification-code',
    INVALID_CONTINUE_URI: 'auth/invalid-continue-uri',
    INVALID_CORDOVA_CONFIGURATION: 'auth/invalid-cordova-configuration',
    INVALID_CUSTOM_TOKEN: 'auth/invalid-custom-token',
    INVALID_DYNAMIC_LINK_DOMAIN: 'auth/invalid-dynamic-link-domain',
    INVALID_EMAIL: 'auth/invalid-email',
    INVALID_EMULATOR_SCHEME: 'auth/invalid-emulator-scheme',
    INVALID_IDP_RESPONSE: 'auth/invalid-credential',
    INVALID_MESSAGE_PAYLOAD: 'auth/invalid-message-payload',
    INVALID_MFA_SESSION: 'auth/invalid-multi-factor-session',
    INVALID_OAUTH_CLIENT_ID: 'auth/invalid-oauth-client-id',
    INVALID_OAUTH_PROVIDER: 'auth/invalid-oauth-provider',
    INVALID_OOB_CODE: 'auth/invalid-action-code',
    INVALID_ORIGIN: 'auth/unauthorized-domain',
    INVALID_PASSWORD: 'auth/wrong-password',
    INVALID_PERSISTENCE: 'auth/invalid-persistence-type',
    INVALID_PHONE_NUMBER: 'auth/invalid-phone-number',
    INVALID_PROVIDER_ID: 'auth/invalid-provider-id',
    INVALID_RECIPIENT_EMAIL: 'auth/invalid-recipient-email',
    INVALID_SENDER: 'auth/invalid-sender',
    INVALID_SESSION_INFO: 'auth/invalid-verification-id',
    INVALID_TENANT_ID: 'auth/invalid-tenant-id',
    MFA_INFO_NOT_FOUND: 'auth/multi-factor-info-not-found',
    MFA_REQUIRED: 'auth/multi-factor-auth-required',
    MISSING_ANDROID_PACKAGE_NAME: 'auth/missing-android-pkg-name',
    MISSING_APP_CREDENTIAL: 'auth/missing-app-credential',
    MISSING_AUTH_DOMAIN: 'auth/auth-domain-config-required',
    MISSING_CODE: 'auth/missing-verification-code',
    MISSING_CONTINUE_URI: 'auth/missing-continue-uri',
    MISSING_IFRAME_START: 'auth/missing-iframe-start',
    MISSING_IOS_BUNDLE_ID: 'auth/missing-ios-bundle-id',
    MISSING_OR_INVALID_NONCE: 'auth/missing-or-invalid-nonce',
    MISSING_MFA_INFO: 'auth/missing-multi-factor-info',
    MISSING_MFA_SESSION: 'auth/missing-multi-factor-session',
    MISSING_PHONE_NUMBER: 'auth/missing-phone-number',
    MISSING_SESSION_INFO: 'auth/missing-verification-id',
    MODULE_DESTROYED: 'auth/app-deleted',
    NEED_CONFIRMATION: 'auth/account-exists-with-different-credential',
    NETWORK_REQUEST_FAILED: 'auth/network-request-failed',
    NULL_USER: 'auth/null-user',
    NO_AUTH_EVENT: 'auth/no-auth-event',
    NO_SUCH_PROVIDER: 'auth/no-such-provider',
    OPERATION_NOT_ALLOWED: 'auth/operation-not-allowed',
    OPERATION_NOT_SUPPORTED: 'auth/operation-not-supported-in-this-environment',
    POPUP_BLOCKED: 'auth/popup-blocked',
    POPUP_CLOSED_BY_USER: 'auth/popup-closed-by-user',
    PROVIDER_ALREADY_LINKED: 'auth/provider-already-linked',
    QUOTA_EXCEEDED: 'auth/quota-exceeded',
    REDIRECT_CANCELLED_BY_USER: 'auth/redirect-cancelled-by-user',
    REDIRECT_OPERATION_PENDING: 'auth/redirect-operation-pending',
    REJECTED_CREDENTIAL: 'auth/rejected-credential',
    SECOND_FACTOR_ALREADY_ENROLLED: 'auth/second-factor-already-in-use',
    SECOND_FACTOR_LIMIT_EXCEEDED: 'auth/maximum-second-factor-count-exceeded',
    TENANT_ID_MISMATCH: 'auth/tenant-id-mismatch',
    TIMEOUT: 'auth/timeout',
    TOKEN_EXPIRED: 'auth/user-token-expired',
    TOO_MANY_ATTEMPTS_TRY_LATER: 'auth/too-many-requests',
    UNAUTHORIZED_DOMAIN: 'auth/unauthorized-continue-uri',
    UNSUPPORTED_FIRST_FACTOR: 'auth/unsupported-first-factor',
    UNSUPPORTED_PERSISTENCE: 'auth/unsupported-persistence-type',
    UNSUPPORTED_TENANT_OPERATION: 'auth/unsupported-tenant-operation',
    UNVERIFIED_EMAIL: 'auth/unverified-email',
    USER_CANCELLED: 'auth/user-cancelled',
    USER_DELETED: 'auth/user-not-found',
    USER_DISABLED: 'auth/user-disabled',
    USER_MISMATCH: 'auth/user-mismatch',
    USER_SIGNED_OUT: 'auth/user-signed-out',
    WEAK_PASSWORD: 'auth/weak-password',
    WEB_STORAGE_UNSUPPORTED: 'auth/web-storage-unsupported',
    ALREADY_INITIALIZED: 'auth/already-initialized',
    RECAPTCHA_NOT_ENABLED: 'auth/recaptcha-not-enabled',
    MISSING_RECAPTCHA_TOKEN: 'auth/missing-recaptcha-token',
    INVALID_RECAPTCHA_TOKEN: 'auth/invalid-recaptcha-token',
    INVALID_RECAPTCHA_ACTION: 'auth/invalid-recaptcha-action',
    MISSING_CLIENT_TYPE: 'auth/missing-client-type',
    MISSING_RECAPTCHA_VERSION: 'auth/missing-recaptcha-version',
    INVALID_RECAPTCHA_VERSION: 'auth/invalid-recaptcha-version',
    INVALID_REQ_TYPE: 'auth/invalid-req-type'
};

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logClient = new Logger('@firebase/auth');
function _logWarn(msg, ...args) {
    if (logClient.logLevel <= LogLevel.WARN) {
        logClient.warn(`Auth (${SDK_VERSION}): ${msg}`, ...args);
    }
}
function _logError(msg, ...args) {
    if (logClient.logLevel <= LogLevel.ERROR) {
        logClient.error(`Auth (${SDK_VERSION}): ${msg}`, ...args);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _fail(authOrCode, ...rest) {
    throw createErrorInternal(authOrCode, ...rest);
}
function _createError(authOrCode, ...rest) {
    return createErrorInternal(authOrCode, ...rest);
}
function _errorWithCustomMessage(auth, code, message) {
    const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message });
    const factory = new ErrorFactory('auth', 'Firebase', errorMap);
    return factory.create(code, {
        appName: auth.name
    });
}
function _assertInstanceOf(auth, object, instance) {
    const constructorInstance = instance;
    if (!(object instanceof constructorInstance)) {
        if (constructorInstance.name !== object.constructor.name) {
            _fail(auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        }
        throw _errorWithCustomMessage(auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */, `Type of ${object.constructor.name} does not match expected instance.` +
            `Did you pass a reference from a different Auth SDK?`);
    }
}
function createErrorInternal(authOrCode, ...rest) {
    if (typeof authOrCode !== 'string') {
        const code = rest[0];
        const fullParams = [...rest.slice(1)];
        if (fullParams[0]) {
            fullParams[0].appName = authOrCode.name;
        }
        return authOrCode._errorFactory.create(code, ...fullParams);
    }
    return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);
}
function _assert(assertion, authOrCode, ...rest) {
    if (!assertion) {
        throw createErrorInternal(authOrCode, ...rest);
    }
}
/**
 * Unconditionally fails, throwing an internal error with the given message.
 *
 * @param failure type of failure encountered
 * @throws Error
 */
function debugFail(failure) {
    // Log the failure in addition to throw an exception, just in case the
    // exception is swallowed.
    const message = `INTERNAL ASSERTION FAILED: ` + failure;
    _logError(message);
    // NOTE: We don't use FirebaseError here because these are internal failures
    // that cannot be handled by the user. (Also it would create a circular
    // dependency between the error and assert modules which doesn't work.)
    throw new Error(message);
}
/**
 * Fails if the given assertion condition is false, throwing an Error with the
 * given message if it did.
 *
 * @param assertion
 * @param message
 */
function debugAssert(assertion, message) {
    if (!assertion) {
        debugFail(message);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getCurrentUrl() {
    var _a;
    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href)) || '';
}
function _isHttpOrHttps() {
    return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';
}
function _getCurrentScheme() {
    var _a;
    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol)) || null;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Determine whether the browser is working online
 */
function _isOnline() {
    if (typeof navigator !== 'undefined' &&
        navigator &&
        'onLine' in navigator &&
        typeof navigator.onLine === 'boolean' &&
        // Apply only for traditional web apps and Chrome extensions.
        // This is especially true for Cordova apps which have unreliable
        // navigator.onLine behavior unless cordova-plugin-network-information is
        // installed which overwrites the native navigator.onLine value and
        // defines navigator.connection.
        (_isHttpOrHttps() || isBrowserExtension() || 'connection' in navigator)) {
        return navigator.onLine;
    }
    // If we can't determine the state, assume it is online.
    return true;
}
function _getUserLanguage() {
    if (typeof navigator === 'undefined') {
        return null;
    }
    const navigatorLanguage = navigator;
    return (
    // Most reliable, but only supported in Chrome/Firefox.
    (navigatorLanguage.languages && navigatorLanguage.languages[0]) ||
        // Supported in most browsers, but returns the language of the browser
        // UI, not the language set in browser settings.
        navigatorLanguage.language ||
        // Couldn't determine language.
        null);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A structure to help pick between a range of long and short delay durations
 * depending on the current environment. In general, the long delay is used for
 * mobile environments whereas short delays are used for desktop environments.
 */
class Delay {
    constructor(shortDelay, longDelay) {
        this.shortDelay = shortDelay;
        this.longDelay = longDelay;
        // Internal error when improperly initialized.
        debugAssert(longDelay > shortDelay, 'Short delay should be less than long delay!');
        this.isMobile = isMobileCordova() || isReactNative();
    }
    get() {
        if (!_isOnline()) {
            // Pick the shorter timeout.
            return Math.min(5000 /* DelayMin.OFFLINE */, this.shortDelay);
        }
        // If running in a mobile environment, return the long delay, otherwise
        // return the short delay.
        // This could be improved in the future to dynamically change based on other
        // variables instead of just reading the current environment.
        return this.isMobile ? this.longDelay : this.shortDelay;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _emulatorUrl(config, path) {
    debugAssert(config.emulator, 'Emulator should always be set here');
    const { url } = config.emulator;
    if (!path) {
        return url;
    }
    return `${url}${path.startsWith('/') ? path.slice(1) : path}`;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FetchProvider {
    static initialize(fetchImpl, headersImpl, responseImpl) {
        this.fetchImpl = fetchImpl;
        if (headersImpl) {
            this.headersImpl = headersImpl;
        }
        if (responseImpl) {
            this.responseImpl = responseImpl;
        }
    }
    static fetch() {
        if (this.fetchImpl) {
            return this.fetchImpl;
        }
        if (typeof self !== 'undefined' && 'fetch' in self) {
            return self.fetch;
        }
        debugFail('Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');
    }
    static headers() {
        if (this.headersImpl) {
            return this.headersImpl;
        }
        if (typeof self !== 'undefined' && 'Headers' in self) {
            return self.Headers;
        }
        debugFail('Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');
    }
    static response() {
        if (this.responseImpl) {
            return this.responseImpl;
        }
        if (typeof self !== 'undefined' && 'Response' in self) {
            return self.Response;
        }
        debugFail('Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Map from errors returned by the server to errors to developer visible errors
 */
const SERVER_ERROR_MAP = {
    // Custom token errors.
    ["CREDENTIAL_MISMATCH" /* ServerError.CREDENTIAL_MISMATCH */]: "custom-token-mismatch" /* AuthErrorCode.CREDENTIAL_MISMATCH */,
    // This can only happen if the SDK sends a bad request.
    ["MISSING_CUSTOM_TOKEN" /* ServerError.MISSING_CUSTOM_TOKEN */]: "internal-error" /* AuthErrorCode.INTERNAL_ERROR */,
    // Create Auth URI errors.
    ["INVALID_IDENTIFIER" /* ServerError.INVALID_IDENTIFIER */]: "invalid-email" /* AuthErrorCode.INVALID_EMAIL */,
    // This can only happen if the SDK sends a bad request.
    ["MISSING_CONTINUE_URI" /* ServerError.MISSING_CONTINUE_URI */]: "internal-error" /* AuthErrorCode.INTERNAL_ERROR */,
    // Sign in with email and password errors (some apply to sign up too).
    ["INVALID_PASSWORD" /* ServerError.INVALID_PASSWORD */]: "wrong-password" /* AuthErrorCode.INVALID_PASSWORD */,
    // This can only happen if the SDK sends a bad request.
    ["MISSING_PASSWORD" /* ServerError.MISSING_PASSWORD */]: "missing-password" /* AuthErrorCode.MISSING_PASSWORD */,
    // Sign up with email and password errors.
    ["EMAIL_EXISTS" /* ServerError.EMAIL_EXISTS */]: "email-already-in-use" /* AuthErrorCode.EMAIL_EXISTS */,
    ["PASSWORD_LOGIN_DISABLED" /* ServerError.PASSWORD_LOGIN_DISABLED */]: "operation-not-allowed" /* AuthErrorCode.OPERATION_NOT_ALLOWED */,
    // Verify assertion for sign in with credential errors:
    ["INVALID_IDP_RESPONSE" /* ServerError.INVALID_IDP_RESPONSE */]: "invalid-credential" /* AuthErrorCode.INVALID_IDP_RESPONSE */,
    ["INVALID_PENDING_TOKEN" /* ServerError.INVALID_PENDING_TOKEN */]: "invalid-credential" /* AuthErrorCode.INVALID_IDP_RESPONSE */,
    ["FEDERATED_USER_ID_ALREADY_LINKED" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */]: "credential-already-in-use" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */,
    // This can only happen if the SDK sends a bad request.
    ["MISSING_REQ_TYPE" /* ServerError.MISSING_REQ_TYPE */]: "internal-error" /* AuthErrorCode.INTERNAL_ERROR */,
    // Send Password reset email errors:
    ["EMAIL_NOT_FOUND" /* ServerError.EMAIL_NOT_FOUND */]: "user-not-found" /* AuthErrorCode.USER_DELETED */,
    ["RESET_PASSWORD_EXCEED_LIMIT" /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */]: "too-many-requests" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,
    ["EXPIRED_OOB_CODE" /* ServerError.EXPIRED_OOB_CODE */]: "expired-action-code" /* AuthErrorCode.EXPIRED_OOB_CODE */,
    ["INVALID_OOB_CODE" /* ServerError.INVALID_OOB_CODE */]: "invalid-action-code" /* AuthErrorCode.INVALID_OOB_CODE */,
    // This can only happen if the SDK sends a bad request.
    ["MISSING_OOB_CODE" /* ServerError.MISSING_OOB_CODE */]: "internal-error" /* AuthErrorCode.INTERNAL_ERROR */,
    // Operations that require ID token in request:
    ["CREDENTIAL_TOO_OLD_LOGIN_AGAIN" /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: "requires-recent-login" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */,
    ["INVALID_ID_TOKEN" /* ServerError.INVALID_ID_TOKEN */]: "invalid-user-token" /* AuthErrorCode.INVALID_AUTH */,
    ["TOKEN_EXPIRED" /* ServerError.TOKEN_EXPIRED */]: "user-token-expired" /* AuthErrorCode.TOKEN_EXPIRED */,
    ["USER_NOT_FOUND" /* ServerError.USER_NOT_FOUND */]: "user-token-expired" /* AuthErrorCode.TOKEN_EXPIRED */,
    // Other errors.
    ["TOO_MANY_ATTEMPTS_TRY_LATER" /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */]: "too-many-requests" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,
    // Phone Auth related errors.
    ["INVALID_CODE" /* ServerError.INVALID_CODE */]: "invalid-verification-code" /* AuthErrorCode.INVALID_CODE */,
    ["INVALID_SESSION_INFO" /* ServerError.INVALID_SESSION_INFO */]: "invalid-verification-id" /* AuthErrorCode.INVALID_SESSION_INFO */,
    ["INVALID_TEMPORARY_PROOF" /* ServerError.INVALID_TEMPORARY_PROOF */]: "invalid-credential" /* AuthErrorCode.INVALID_IDP_RESPONSE */,
    ["MISSING_SESSION_INFO" /* ServerError.MISSING_SESSION_INFO */]: "missing-verification-id" /* AuthErrorCode.MISSING_SESSION_INFO */,
    ["SESSION_EXPIRED" /* ServerError.SESSION_EXPIRED */]: "code-expired" /* AuthErrorCode.CODE_EXPIRED */,
    // Other action code errors when additional settings passed.
    // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.
    // This is OK as this error will be caught by client side validation.
    ["MISSING_ANDROID_PACKAGE_NAME" /* ServerError.MISSING_ANDROID_PACKAGE_NAME */]: "missing-android-pkg-name" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */,
    ["UNAUTHORIZED_DOMAIN" /* ServerError.UNAUTHORIZED_DOMAIN */]: "unauthorized-continue-uri" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */,
    // getProjectConfig errors when clientId is passed.
    ["INVALID_OAUTH_CLIENT_ID" /* ServerError.INVALID_OAUTH_CLIENT_ID */]: "invalid-oauth-client-id" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */,
    // User actions (sign-up or deletion) disabled errors.
    ["ADMIN_ONLY_OPERATION" /* ServerError.ADMIN_ONLY_OPERATION */]: "admin-restricted-operation" /* AuthErrorCode.ADMIN_ONLY_OPERATION */,
    // Multi factor related errors.
    ["INVALID_MFA_PENDING_CREDENTIAL" /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */]: "invalid-multi-factor-session" /* AuthErrorCode.INVALID_MFA_SESSION */,
    ["MFA_ENROLLMENT_NOT_FOUND" /* ServerError.MFA_ENROLLMENT_NOT_FOUND */]: "multi-factor-info-not-found" /* AuthErrorCode.MFA_INFO_NOT_FOUND */,
    ["MISSING_MFA_ENROLLMENT_ID" /* ServerError.MISSING_MFA_ENROLLMENT_ID */]: "missing-multi-factor-info" /* AuthErrorCode.MISSING_MFA_INFO */,
    ["MISSING_MFA_PENDING_CREDENTIAL" /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */]: "missing-multi-factor-session" /* AuthErrorCode.MISSING_MFA_SESSION */,
    ["SECOND_FACTOR_EXISTS" /* ServerError.SECOND_FACTOR_EXISTS */]: "second-factor-already-in-use" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */,
    ["SECOND_FACTOR_LIMIT_EXCEEDED" /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */]: "maximum-second-factor-count-exceeded" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */,
    // Blocking functions related errors.
    ["BLOCKING_FUNCTION_ERROR_RESPONSE" /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */]: "internal-error" /* AuthErrorCode.INTERNAL_ERROR */,
    // Recaptcha related errors.
    ["RECAPTCHA_NOT_ENABLED" /* ServerError.RECAPTCHA_NOT_ENABLED */]: "recaptcha-not-enabled" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */,
    ["MISSING_RECAPTCHA_TOKEN" /* ServerError.MISSING_RECAPTCHA_TOKEN */]: "missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */,
    ["INVALID_RECAPTCHA_TOKEN" /* ServerError.INVALID_RECAPTCHA_TOKEN */]: "invalid-recaptcha-token" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */,
    ["INVALID_RECAPTCHA_ACTION" /* ServerError.INVALID_RECAPTCHA_ACTION */]: "invalid-recaptcha-action" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */,
    ["MISSING_CLIENT_TYPE" /* ServerError.MISSING_CLIENT_TYPE */]: "missing-client-type" /* AuthErrorCode.MISSING_CLIENT_TYPE */,
    ["MISSING_RECAPTCHA_VERSION" /* ServerError.MISSING_RECAPTCHA_VERSION */]: "missing-recaptcha-version" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */,
    ["INVALID_RECAPTCHA_VERSION" /* ServerError.INVALID_RECAPTCHA_VERSION */]: "invalid-recaptcha-version" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */,
    ["INVALID_REQ_TYPE" /* ServerError.INVALID_REQ_TYPE */]: "invalid-req-type" /* AuthErrorCode.INVALID_REQ_TYPE */
};

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_API_TIMEOUT_MS = new Delay(30000, 60000);
function _addTidIfNecessary(auth, request) {
    if (auth.tenantId && !request.tenantId) {
        return Object.assign(Object.assign({}, request), { tenantId: auth.tenantId });
    }
    return request;
}
async function _performApiRequest(auth, method, path, request, customErrorMap = {}) {
    return _performFetchWithErrorHandling(auth, customErrorMap, async () => {
        let body = {};
        let params = {};
        if (request) {
            if (method === "GET" /* HttpMethod.GET */) {
                params = request;
            }
            else {
                body = {
                    body: JSON.stringify(request)
                };
            }
        }
        const query = index_esm2017_querystring(Object.assign({ key: auth.config.apiKey }, params)).slice(1);
        const headers = await auth._getAdditionalHeaders();
        headers["Content-Type" /* HttpHeader.CONTENT_TYPE */] = 'application/json';
        if (auth.languageCode) {
            headers["X-Firebase-Locale" /* HttpHeader.X_FIREBASE_LOCALE */] = auth.languageCode;
        }
        return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), Object.assign({ method,
            headers, referrerPolicy: 'no-referrer' }, body));
    });
}
async function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {
    auth._canInitEmulator = false;
    const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);
    try {
        const networkTimeout = new NetworkTimeout(auth);
        const response = await Promise.race([
            fetchFn(),
            networkTimeout.promise
        ]);
        // If we've reached this point, the fetch succeeded and the networkTimeout
        // didn't throw; clear the network timeout delay so that Node won't hang
        networkTimeout.clearNetworkTimeout();
        const json = await response.json();
        if ('needConfirmation' in json) {
            throw _makeTaggedError(auth, "account-exists-with-different-credential" /* AuthErrorCode.NEED_CONFIRMATION */, json);
        }
        if (response.ok && !('errorMessage' in json)) {
            return json;
        }
        else {
            const errorMessage = response.ok ? json.errorMessage : json.error.message;
            const [serverErrorCode, serverErrorMessage] = errorMessage.split(' : ');
            if (serverErrorCode === "FEDERATED_USER_ID_ALREADY_LINKED" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */) {
                throw _makeTaggedError(auth, "credential-already-in-use" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */, json);
            }
            else if (serverErrorCode === "EMAIL_EXISTS" /* ServerError.EMAIL_EXISTS */) {
                throw _makeTaggedError(auth, "email-already-in-use" /* AuthErrorCode.EMAIL_EXISTS */, json);
            }
            else if (serverErrorCode === "USER_DISABLED" /* ServerError.USER_DISABLED */) {
                throw _makeTaggedError(auth, "user-disabled" /* AuthErrorCode.USER_DISABLED */, json);
            }
            const authError = errorMap[serverErrorCode] ||
                serverErrorCode
                    .toLowerCase()
                    .replace(/[_\s]+/g, '-');
            if (serverErrorMessage) {
                throw _errorWithCustomMessage(auth, authError, serverErrorMessage);
            }
            else {
                _fail(auth, authError);
            }
        }
    }
    catch (e) {
        if (e instanceof FirebaseError) {
            throw e;
        }
        // Changing this to a different error code will log user out when there is a network error
        // because we treat any error other than NETWORK_REQUEST_FAILED as token is invalid.
        // https://github.com/firebase/firebase-js-sdk/blob/4fbc73610d70be4e0852e7de63a39cb7897e8546/packages/auth/src/core/auth/auth_impl.ts#L309-L316
        _fail(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */, { 'message': String(e) });
    }
}
async function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {
    const serverResponse = (await _performApiRequest(auth, method, path, request, customErrorMap));
    if ('mfaPendingCredential' in serverResponse) {
        _fail(auth, "multi-factor-auth-required" /* AuthErrorCode.MFA_REQUIRED */, {
            _serverResponse: serverResponse
        });
    }
    return serverResponse;
}
function _getFinalTarget(auth, host, path, query) {
    const base = `${host}${path}?${query}`;
    if (!auth.config.emulator) {
        return `${auth.config.apiScheme}://${base}`;
    }
    return _emulatorUrl(auth.config, base);
}
class NetworkTimeout {
    constructor(auth) {
        this.auth = auth;
        // Node timers and browser timers are fundamentally incompatible, but we
        // don't care about the value here
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.timer = null;
        this.promise = new Promise((_, reject) => {
            this.timer = setTimeout(() => {
                return reject(_createError(this.auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));
            }, DEFAULT_API_TIMEOUT_MS.get());
        });
    }
    clearNetworkTimeout() {
        clearTimeout(this.timer);
    }
}
function _makeTaggedError(auth, code, response) {
    const errorParams = {
        appName: auth.name
    };
    if (response.email) {
        errorParams.email = response.email;
    }
    if (response.phoneNumber) {
        errorParams.phoneNumber = response.phoneNumber;
    }
    const error = _createError(auth, code, errorParams);
    // We know customData is defined on error because errorParams is defined
    error.customData._tokenResponse = response;
    return error;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function deleteAccount(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:delete" /* Endpoint.DELETE_ACCOUNT */, request);
}
async function deleteLinkedAccounts(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:update" /* Endpoint.SET_ACCOUNT_INFO */, request);
}
async function getAccountInfo(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:lookup" /* Endpoint.GET_ACCOUNT_INFO */, request);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function utcTimestampToDateString(utcTimestamp) {
    if (!utcTimestamp) {
        return undefined;
    }
    try {
        // Convert to date object.
        const date = new Date(Number(utcTimestamp));
        // Test date is valid.
        if (!isNaN(date.getTime())) {
            // Convert to UTC date string.
            return date.toUTCString();
        }
    }
    catch (e) {
        // Do nothing. undefined will be returned.
    }
    return undefined;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service.
 *
 * @remarks
 * Returns the current token if it has not expired or if it will not expire in the next five
 * minutes. Otherwise, this will refresh the token and return a new one.
 *
 * @param user - The user.
 * @param forceRefresh - Force refresh regardless of token expiration.
 *
 * @public
 */
function getIdToken(user, forceRefresh = false) {
    return getModularInstance(user).getIdToken(forceRefresh);
}
/**
 * Returns a deserialized JSON Web Token (JWT) used to identify the user to a Firebase service.
 *
 * @remarks
 * Returns the current token if it has not expired or if it will not expire in the next five
 * minutes. Otherwise, this will refresh the token and return a new one.
 *
 * @param user - The user.
 * @param forceRefresh - Force refresh regardless of token expiration.
 *
 * @public
 */
async function getIdTokenResult(user, forceRefresh = false) {
    const userInternal = index_esm2017_getModularInstance(user);
    const token = await userInternal.getIdToken(forceRefresh);
    const claims = _parseToken(token);
    _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    const firebase = typeof claims.firebase === 'object' ? claims.firebase : undefined;
    const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_provider'];
    return {
        claims,
        token,
        authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),
        issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),
        expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),
        signInProvider: signInProvider || null,
        signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_second_factor']) || null
    };
}
function secondsStringToMilliseconds(seconds) {
    return Number(seconds) * 1000;
}
function _parseToken(token) {
    const [algorithm, payload, signature] = token.split('.');
    if (algorithm === undefined ||
        payload === undefined ||
        signature === undefined) {
        _logError('JWT malformed, contained fewer than 3 sections');
        return null;
    }
    try {
        const decoded = base64Decode(payload);
        if (!decoded) {
            _logError('Failed to decode base64 JWT payload');
            return null;
        }
        return JSON.parse(decoded);
    }
    catch (e) {
        _logError('Caught error parsing JWT payload as JSON', e === null || e === void 0 ? void 0 : e.toString());
        return null;
    }
}
/**
 * Extract expiresIn TTL from a token by subtracting the expiration from the issuance.
 */
function _tokenExpiresIn(token) {
    const parsedToken = _parseToken(token);
    _assert(parsedToken, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    _assert(typeof parsedToken.exp !== 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    _assert(typeof parsedToken.iat !== 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    return Number(parsedToken.exp) - Number(parsedToken.iat);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _logoutIfInvalidated(user, promise, bypassAuthState = false) {
    if (bypassAuthState) {
        return promise;
    }
    try {
        return await promise;
    }
    catch (e) {
        if (e instanceof FirebaseError && isUserInvalidated(e)) {
            if (user.auth.currentUser === user) {
                await user.auth.signOut();
            }
        }
        throw e;
    }
}
function isUserInvalidated({ code }) {
    return (code === `auth/${"user-disabled" /* AuthErrorCode.USER_DISABLED */}` ||
        code === `auth/${"user-token-expired" /* AuthErrorCode.TOKEN_EXPIRED */}`);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProactiveRefresh {
    constructor(user) {
        this.user = user;
        this.isRunning = false;
        // Node timers and browser timers return fundamentally different types.
        // We don't actually care what the value is but TS won't accept unknown and
        // we can't cast properly in both environments.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.timerId = null;
        this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;
    }
    _start() {
        if (this.isRunning) {
            return;
        }
        this.isRunning = true;
        this.schedule();
    }
    _stop() {
        if (!this.isRunning) {
            return;
        }
        this.isRunning = false;
        if (this.timerId !== null) {
            clearTimeout(this.timerId);
        }
    }
    getInterval(wasError) {
        var _a;
        if (wasError) {
            const interval = this.errorBackoff;
            this.errorBackoff = Math.min(this.errorBackoff * 2, 960000 /* Duration.RETRY_BACKOFF_MAX */);
            return interval;
        }
        else {
            // Reset the error backoff
            this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;
            const expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;
            const interval = expTime - Date.now() - 300000 /* Duration.OFFSET */;
            return Math.max(0, interval);
        }
    }
    schedule(wasError = false) {
        if (!this.isRunning) {
            // Just in case...
            return;
        }
        const interval = this.getInterval(wasError);
        this.timerId = setTimeout(async () => {
            await this.iteration();
        }, interval);
    }
    async iteration() {
        try {
            await this.user.getIdToken(true);
        }
        catch (e) {
            // Only retry on network errors
            if ((e === null || e === void 0 ? void 0 : e.code) ===
                `auth/${"network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {
                this.schedule(/* wasError */ true);
            }
            return;
        }
        this.schedule();
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserMetadata {
    constructor(createdAt, lastLoginAt) {
        this.createdAt = createdAt;
        this.lastLoginAt = lastLoginAt;
        this._initializeTime();
    }
    _initializeTime() {
        this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);
        this.creationTime = utcTimestampToDateString(this.createdAt);
    }
    _copy(metadata) {
        this.createdAt = metadata.createdAt;
        this.lastLoginAt = metadata.lastLoginAt;
        this._initializeTime();
    }
    toJSON() {
        return {
            createdAt: this.createdAt,
            lastLoginAt: this.lastLoginAt
        };
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _reloadWithoutSaving(user) {
    var _a;
    const auth = user.auth;
    const idToken = await user.getIdToken();
    const response = await _logoutIfInvalidated(user, getAccountInfo(auth, { idToken }));
    _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    const coreAccount = response.users[0];
    user._notifyReloadListener(coreAccount);
    const newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length)
        ? extractProviderData(coreAccount.providerUserInfo)
        : [];
    const providerData = mergeProviderData(user.providerData, newProviderData);
    // Preserves the non-nonymous status of the stored user, even if no more
    // credentials (federated or email/password) are linked to the user. If
    // the user was previously anonymous, then use provider data to update.
    // On the other hand, if it was not anonymous before, it should never be
    // considered anonymous now.
    const oldIsAnonymous = user.isAnonymous;
    const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
    const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;
    const updates = {
        uid: coreAccount.localId,
        displayName: coreAccount.displayName || null,
        photoURL: coreAccount.photoUrl || null,
        email: coreAccount.email || null,
        emailVerified: coreAccount.emailVerified || false,
        phoneNumber: coreAccount.phoneNumber || null,
        tenantId: coreAccount.tenantId || null,
        providerData,
        metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
        isAnonymous
    };
    Object.assign(user, updates);
}
/**
 * Reloads user account data, if signed in.
 *
 * @param user - The user.
 *
 * @public
 */
async function reload(user) {
    const userInternal = index_esm2017_getModularInstance(user);
    await _reloadWithoutSaving(userInternal);
    // Even though the current user hasn't changed, update
    // current user will trigger a persistence update w/ the
    // new info.
    await userInternal.auth._persistUserIfCurrent(userInternal);
    userInternal.auth._notifyListenersIfCurrent(userInternal);
}
function mergeProviderData(original, newData) {
    const deduped = original.filter(o => !newData.some(n => n.providerId === o.providerId));
    return [...deduped, ...newData];
}
function extractProviderData(providers) {
    return providers.map((_a) => {
        var { providerId } = _a, provider = __rest(_a, ["providerId"]);
        return {
            providerId,
            uid: provider.rawId || '',
            displayName: provider.displayName || null,
            email: provider.email || null,
            phoneNumber: provider.phoneNumber || null,
            photoURL: provider.photoUrl || null
        };
    });
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function requestStsToken(auth, refreshToken) {
    const response = await _performFetchWithErrorHandling(auth, {}, async () => {
        const body = index_esm2017_querystring({
            'grant_type': 'refresh_token',
            'refresh_token': refreshToken
        }).slice(1);
        const { tokenApiHost, apiKey } = auth.config;
        const url = _getFinalTarget(auth, tokenApiHost, "/v1/token" /* Endpoint.TOKEN */, `key=${apiKey}`);
        const headers = await auth._getAdditionalHeaders();
        headers["Content-Type" /* HttpHeader.CONTENT_TYPE */] = 'application/x-www-form-urlencoded';
        return FetchProvider.fetch()(url, {
            method: "POST" /* HttpMethod.POST */,
            headers,
            body
        });
    });
    // The response comes back in snake_case. Convert to camel:
    return {
        accessToken: response.access_token,
        expiresIn: response.expires_in,
        refreshToken: response.refresh_token
    };
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * We need to mark this class as internal explicitly to exclude it in the public typings, because
 * it references AuthInternal which has a circular dependency with UserInternal.
 *
 * @internal
 */
class StsTokenManager {
    constructor() {
        this.refreshToken = null;
        this.accessToken = null;
        this.expirationTime = null;
    }
    get isExpired() {
        return (!this.expirationTime ||
            Date.now() > this.expirationTime - 30000 /* Buffer.TOKEN_REFRESH */);
    }
    updateFromServerResponse(response) {
        _assert(response.idToken, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        _assert(typeof response.idToken !== 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        _assert(typeof response.refreshToken !== 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const expiresIn = 'expiresIn' in response && typeof response.expiresIn !== 'undefined'
            ? Number(response.expiresIn)
            : _tokenExpiresIn(response.idToken);
        this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);
    }
    async getToken(auth, forceRefresh = false) {
        _assert(!this.accessToken || this.refreshToken, auth, "user-token-expired" /* AuthErrorCode.TOKEN_EXPIRED */);
        if (!forceRefresh && this.accessToken && !this.isExpired) {
            return this.accessToken;
        }
        if (this.refreshToken) {
            await this.refresh(auth, this.refreshToken);
            return this.accessToken;
        }
        return null;
    }
    clearRefreshToken() {
        this.refreshToken = null;
    }
    async refresh(auth, oldToken) {
        const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);
        this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));
    }
    updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {
        this.refreshToken = refreshToken || null;
        this.accessToken = accessToken || null;
        this.expirationTime = Date.now() + expiresInSec * 1000;
    }
    static fromJSON(appName, object) {
        const { refreshToken, accessToken, expirationTime } = object;
        const manager = new StsTokenManager();
        if (refreshToken) {
            _assert(typeof refreshToken === 'string', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */, {
                appName
            });
            manager.refreshToken = refreshToken;
        }
        if (accessToken) {
            _assert(typeof accessToken === 'string', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */, {
                appName
            });
            manager.accessToken = accessToken;
        }
        if (expirationTime) {
            _assert(typeof expirationTime === 'number', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */, {
                appName
            });
            manager.expirationTime = expirationTime;
        }
        return manager;
    }
    toJSON() {
        return {
            refreshToken: this.refreshToken,
            accessToken: this.accessToken,
            expirationTime: this.expirationTime
        };
    }
    _assign(stsTokenManager) {
        this.accessToken = stsTokenManager.accessToken;
        this.refreshToken = stsTokenManager.refreshToken;
        this.expirationTime = stsTokenManager.expirationTime;
    }
    _clone() {
        return Object.assign(new StsTokenManager(), this.toJSON());
    }
    _performRefresh() {
        return debugFail('not implemented');
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function assertStringOrUndefined(assertion, appName) {
    _assert(typeof assertion === 'string' || typeof assertion === 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */, { appName });
}
class UserImpl {
    constructor(_a) {
        var { uid, auth, stsTokenManager } = _a, opt = __rest(_a, ["uid", "auth", "stsTokenManager"]);
        // For the user object, provider is always Firebase.
        this.providerId = "firebase" /* ProviderId.FIREBASE */;
        this.proactiveRefresh = new ProactiveRefresh(this);
        this.reloadUserInfo = null;
        this.reloadListener = null;
        this.uid = uid;
        this.auth = auth;
        this.stsTokenManager = stsTokenManager;
        this.accessToken = stsTokenManager.accessToken;
        this.displayName = opt.displayName || null;
        this.email = opt.email || null;
        this.emailVerified = opt.emailVerified || false;
        this.phoneNumber = opt.phoneNumber || null;
        this.photoURL = opt.photoURL || null;
        this.isAnonymous = opt.isAnonymous || false;
        this.tenantId = opt.tenantId || null;
        this.providerData = opt.providerData ? [...opt.providerData] : [];
        this.metadata = new UserMetadata(opt.createdAt || undefined, opt.lastLoginAt || undefined);
    }
    async getIdToken(forceRefresh) {
        const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));
        _assert(accessToken, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        if (this.accessToken !== accessToken) {
            this.accessToken = accessToken;
            await this.auth._persistUserIfCurrent(this);
            this.auth._notifyListenersIfCurrent(this);
        }
        return accessToken;
    }
    getIdTokenResult(forceRefresh) {
        return getIdTokenResult(this, forceRefresh);
    }
    reload() {
        return reload(this);
    }
    _assign(user) {
        if (this === user) {
            return;
        }
        _assert(this.uid === user.uid, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        this.displayName = user.displayName;
        this.photoURL = user.photoURL;
        this.email = user.email;
        this.emailVerified = user.emailVerified;
        this.phoneNumber = user.phoneNumber;
        this.isAnonymous = user.isAnonymous;
        this.tenantId = user.tenantId;
        this.providerData = user.providerData.map(userInfo => (Object.assign({}, userInfo)));
        this.metadata._copy(user.metadata);
        this.stsTokenManager._assign(user.stsTokenManager);
    }
    _clone(auth) {
        const newUser = new UserImpl(Object.assign(Object.assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));
        newUser.metadata._copy(this.metadata);
        return newUser;
    }
    _onReload(callback) {
        // There should only ever be one listener, and that is a single instance of MultiFactorUser
        _assert(!this.reloadListener, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        this.reloadListener = callback;
        if (this.reloadUserInfo) {
            this._notifyReloadListener(this.reloadUserInfo);
            this.reloadUserInfo = null;
        }
    }
    _notifyReloadListener(userInfo) {
        if (this.reloadListener) {
            this.reloadListener(userInfo);
        }
        else {
            // If no listener is subscribed yet, save the result so it's available when they do subscribe
            this.reloadUserInfo = userInfo;
        }
    }
    _startProactiveRefresh() {
        this.proactiveRefresh._start();
    }
    _stopProactiveRefresh() {
        this.proactiveRefresh._stop();
    }
    async _updateTokensIfNecessary(response, reload = false) {
        let tokensRefreshed = false;
        if (response.idToken &&
            response.idToken !== this.stsTokenManager.accessToken) {
            this.stsTokenManager.updateFromServerResponse(response);
            tokensRefreshed = true;
        }
        if (reload) {
            await _reloadWithoutSaving(this);
        }
        await this.auth._persistUserIfCurrent(this);
        if (tokensRefreshed) {
            this.auth._notifyListenersIfCurrent(this);
        }
    }
    async delete() {
        const idToken = await this.getIdToken();
        await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));
        this.stsTokenManager.clearRefreshToken();
        // TODO: Determine if cancellable-promises are necessary to use in this class so that delete()
        //       cancels pending actions...
        return this.auth.signOut();
    }
    toJSON() {
        return Object.assign(Object.assign({ uid: this.uid, email: this.email || undefined, emailVerified: this.emailVerified, displayName: this.displayName || undefined, isAnonymous: this.isAnonymous, photoURL: this.photoURL || undefined, phoneNumber: this.phoneNumber || undefined, tenantId: this.tenantId || undefined, providerData: this.providerData.map(userInfo => (Object.assign({}, userInfo))), stsTokenManager: this.stsTokenManager.toJSON(), 
            // Redirect event ID must be maintained in case there is a pending
            // redirect event.
            _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { 
            // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):
            apiKey: this.auth.config.apiKey, appName: this.auth.name });
    }
    get refreshToken() {
        return this.stsTokenManager.refreshToken || '';
    }
    static _fromJSON(auth, object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : undefined;
        const email = (_b = object.email) !== null && _b !== void 0 ? _b : undefined;
        const phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : undefined;
        const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : undefined;
        const tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : undefined;
        const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : undefined;
        const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : undefined;
        const lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : undefined;
        const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;
        _assert(uid && plainObjectTokenManager, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);
        _assert(typeof uid === 'string', auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        assertStringOrUndefined(displayName, auth.name);
        assertStringOrUndefined(email, auth.name);
        _assert(typeof emailVerified === 'boolean', auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        _assert(typeof isAnonymous === 'boolean', auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        assertStringOrUndefined(phoneNumber, auth.name);
        assertStringOrUndefined(photoURL, auth.name);
        assertStringOrUndefined(tenantId, auth.name);
        assertStringOrUndefined(_redirectEventId, auth.name);
        assertStringOrUndefined(createdAt, auth.name);
        assertStringOrUndefined(lastLoginAt, auth.name);
        const user = new UserImpl({
            uid,
            auth,
            email,
            emailVerified,
            displayName,
            isAnonymous,
            photoURL,
            phoneNumber,
            tenantId,
            stsTokenManager,
            createdAt,
            lastLoginAt
        });
        if (providerData && Array.isArray(providerData)) {
            user.providerData = providerData.map(userInfo => (Object.assign({}, userInfo)));
        }
        if (_redirectEventId) {
            user._redirectEventId = _redirectEventId;
        }
        return user;
    }
    /**
     * Initialize a User from an idToken server response
     * @param auth
     * @param idTokenResponse
     */
    static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {
        const stsTokenManager = new StsTokenManager();
        stsTokenManager.updateFromServerResponse(idTokenResponse);
        // Initialize the Firebase Auth user.
        const user = new UserImpl({
            uid: idTokenResponse.localId,
            auth,
            stsTokenManager,
            isAnonymous
        });
        // Updates the user info and data and resolves with a user instance.
        await _reloadWithoutSaving(user);
        return user;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const instanceCache = new Map();
function _getInstance(cls) {
    debugAssert(cls instanceof Function, 'Expected a class definition');
    let instance = instanceCache.get(cls);
    if (instance) {
        debugAssert(instance instanceof cls, 'Instance stored in cache mismatched with class');
        return instance;
    }
    instance = new cls();
    instanceCache.set(cls, instance);
    return instance;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InMemoryPersistence {
    constructor() {
        this.type = "NONE" /* PersistenceType.NONE */;
        this.storage = {};
    }
    async _isAvailable() {
        return true;
    }
    async _set(key, value) {
        this.storage[key] = value;
    }
    async _get(key) {
        const value = this.storage[key];
        return value === undefined ? null : value;
    }
    async _remove(key) {
        delete this.storage[key];
    }
    _addListener(_key, _listener) {
        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers
        return;
    }
    _removeListener(_key, _listener) {
        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers
        return;
    }
}
InMemoryPersistence.type = 'NONE';
/**
 * An implementation of {@link Persistence} of type 'NONE'.
 *
 * @public
 */
const inMemoryPersistence = InMemoryPersistence;

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _persistenceKeyName(key, apiKey, appName) {
    return `${"firebase" /* Namespace.PERSISTENCE */}:${key}:${apiKey}:${appName}`;
}
class PersistenceUserManager {
    constructor(persistence, auth, userKey) {
        this.persistence = persistence;
        this.auth = auth;
        this.userKey = userKey;
        const { config, name } = this.auth;
        this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name);
        this.fullPersistenceKey = _persistenceKeyName("persistence" /* KeyName.PERSISTENCE_USER */, config.apiKey, name);
        this.boundEventHandler = auth._onStorageEvent.bind(auth);
        this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
    }
    setCurrentUser(user) {
        return this.persistence._set(this.fullUserKey, user.toJSON());
    }
    async getCurrentUser() {
        const blob = await this.persistence._get(this.fullUserKey);
        return blob ? UserImpl._fromJSON(this.auth, blob) : null;
    }
    removeCurrentUser() {
        return this.persistence._remove(this.fullUserKey);
    }
    savePersistenceForRedirect() {
        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
    }
    async setPersistence(newPersistence) {
        if (this.persistence === newPersistence) {
            return;
        }
        const currentUser = await this.getCurrentUser();
        await this.removeCurrentUser();
        this.persistence = newPersistence;
        if (currentUser) {
            return this.setCurrentUser(currentUser);
        }
    }
    delete() {
        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
    }
    static async create(auth, persistenceHierarchy, userKey = "authUser" /* KeyName.AUTH_USER */) {
        if (!persistenceHierarchy.length) {
            return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);
        }
        // Eliminate any persistences that are not available
        const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {
            if (await persistence._isAvailable()) {
                return persistence;
            }
            return undefined;
        }))).filter(persistence => persistence);
        // Fall back to the first persistence listed, or in memory if none available
        let selectedPersistence = availablePersistences[0] ||
            _getInstance(inMemoryPersistence);
        const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);
        // Pull out the existing user, setting the chosen persistence to that
        // persistence if the user exists.
        let userToMigrate = null;
        // Note, here we check for a user in _all_ persistences, not just the
        // ones deemed available. If we can migrate a user out of a broken
        // persistence, we will (but only if that persistence supports migration).
        for (const persistence of persistenceHierarchy) {
            try {
                const blob = await persistence._get(key);
                if (blob) {
                    const user = UserImpl._fromJSON(auth, blob); // throws for unparsable blob (wrong format)
                    if (persistence !== selectedPersistence) {
                        userToMigrate = user;
                    }
                    selectedPersistence = persistence;
                    break;
                }
            }
            catch (_a) { }
        }
        // If we find the user in a persistence that does support migration, use
        // that migration path (of only persistences that support migration)
        const migrationHierarchy = availablePersistences.filter(p => p._shouldAllowMigration);
        // If the persistence does _not_ allow migration, just finish off here
        if (!selectedPersistence._shouldAllowMigration ||
            !migrationHierarchy.length) {
            return new PersistenceUserManager(selectedPersistence, auth, userKey);
        }
        selectedPersistence = migrationHierarchy[0];
        if (userToMigrate) {
            // This normally shouldn't throw since chosenPersistence.isAvailable() is true, but if it does
            // we'll just let it bubble to surface the error.
            await selectedPersistence._set(key, userToMigrate.toJSON());
        }
        // Attempt to clear the key in other persistences but ignore errors. This helps prevent issues
        // such as users getting stuck with a previous account after signing out and refreshing the tab.
        await Promise.all(persistenceHierarchy.map(async (persistence) => {
            if (persistence !== selectedPersistence) {
                try {
                    await persistence._remove(key);
                }
                catch (_a) { }
            }
        }));
        return new PersistenceUserManager(selectedPersistence, auth, userKey);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Determine the browser for the purposes of reporting usage to the API
 */
function _getBrowserName(userAgent) {
    const ua = userAgent.toLowerCase();
    if (ua.includes('opera/') || ua.includes('opr/') || ua.includes('opios/')) {
        return "Opera" /* BrowserName.OPERA */;
    }
    else if (_isIEMobile(ua)) {
        // Windows phone IEMobile browser.
        return "IEMobile" /* BrowserName.IEMOBILE */;
    }
    else if (ua.includes('msie') || ua.includes('trident/')) {
        return "IE" /* BrowserName.IE */;
    }
    else if (ua.includes('edge/')) {
        return "Edge" /* BrowserName.EDGE */;
    }
    else if (_isFirefox(ua)) {
        return "Firefox" /* BrowserName.FIREFOX */;
    }
    else if (ua.includes('silk/')) {
        return "Silk" /* BrowserName.SILK */;
    }
    else if (_isBlackBerry(ua)) {
        // Blackberry browser.
        return "Blackberry" /* BrowserName.BLACKBERRY */;
    }
    else if (_isWebOS(ua)) {
        // WebOS default browser.
        return "Webos" /* BrowserName.WEBOS */;
    }
    else if (_isSafari(ua)) {
        return "Safari" /* BrowserName.SAFARI */;
    }
    else if ((ua.includes('chrome/') || _isChromeIOS(ua)) &&
        !ua.includes('edge/')) {
        return "Chrome" /* BrowserName.CHROME */;
    }
    else if (_isAndroid(ua)) {
        // Android stock browser.
        return "Android" /* BrowserName.ANDROID */;
    }
    else {
        // Most modern browsers have name/version at end of user agent string.
        const re = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/;
        const matches = userAgent.match(re);
        if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {
            return matches[1];
        }
    }
    return "Other" /* BrowserName.OTHER */;
}
function _isFirefox(ua = index_esm2017_getUA()) {
    return /firefox\//i.test(ua);
}
function _isSafari(userAgent = index_esm2017_getUA()) {
    const ua = userAgent.toLowerCase();
    return (ua.includes('safari/') &&
        !ua.includes('chrome/') &&
        !ua.includes('crios/') &&
        !ua.includes('android'));
}
function _isChromeIOS(ua = index_esm2017_getUA()) {
    return /crios\//i.test(ua);
}
function _isIEMobile(ua = index_esm2017_getUA()) {
    return /iemobile/i.test(ua);
}
function _isAndroid(ua = index_esm2017_getUA()) {
    return /android/i.test(ua);
}
function _isBlackBerry(ua = index_esm2017_getUA()) {
    return /blackberry/i.test(ua);
}
function _isWebOS(ua = index_esm2017_getUA()) {
    return /webos/i.test(ua);
}
function _isIOS(ua = index_esm2017_getUA()) {
    return (/iphone|ipad|ipod/i.test(ua) ||
        (/macintosh/i.test(ua) && /mobile/i.test(ua)));
}
function _isIOS7Or8(ua = getUA()) {
    return (/(iPad|iPhone|iPod).*OS 7_\d/i.test(ua) ||
        /(iPad|iPhone|iPod).*OS 8_\d/i.test(ua));
}
function _isIOSStandalone(ua = index_esm2017_getUA()) {
    var _a;
    return _isIOS(ua) && !!((_a = window.navigator) === null || _a === void 0 ? void 0 : _a.standalone);
}
function _isIE10() {
    return isIE() && document.documentMode === 10;
}
function _isMobileBrowser(ua = index_esm2017_getUA()) {
    // TODO: implement getBrowserName equivalent for OS.
    return (_isIOS(ua) ||
        _isAndroid(ua) ||
        _isWebOS(ua) ||
        _isBlackBerry(ua) ||
        /windows phone/i.test(ua) ||
        _isIEMobile(ua));
}
function _isIframe() {
    try {
        // Check that the current window is not the top window.
        // If so, return true.
        return !!(window && window !== window.top);
    }
    catch (e) {
        return false;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Determine the SDK version string
 */
function _getClientVersion(clientPlatform, frameworks = []) {
    let reportedPlatform;
    switch (clientPlatform) {
        case "Browser" /* ClientPlatform.BROWSER */:
            // In a browser environment, report the browser name.
            reportedPlatform = _getBrowserName(index_esm2017_getUA());
            break;
        case "Worker" /* ClientPlatform.WORKER */:
            // Technically a worker runs from a browser but we need to differentiate a
            // worker from a browser.
            // For example: Chrome-Worker/JsCore/4.9.1/FirebaseCore-web.
            reportedPlatform = `${_getBrowserName(index_esm2017_getUA())}-${clientPlatform}`;
            break;
        default:
            reportedPlatform = clientPlatform;
    }
    const reportedFrameworks = frameworks.length
        ? frameworks.join(',')
        : 'FirebaseCore-web'; /* default value if no other framework is used */
    return `${reportedPlatform}/${"JsCore" /* ClientImplementation.CORE */}/${SDK_VERSION}/${reportedFrameworks}`;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getRecaptchaParams(auth) {
    return ((await _performApiRequest(auth, "GET" /* HttpMethod.GET */, "/v1/recaptchaParams" /* Endpoint.GET_RECAPTCHA_PARAM */)).recaptchaSiteKey || '');
}
async function getRecaptchaConfig(auth, request) {
    return _performApiRequest(auth, "GET" /* HttpMethod.GET */, "/v2/recaptchaConfig" /* Endpoint.GET_RECAPTCHA_CONFIG */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isV2(grecaptcha) {
    return (grecaptcha !== undefined &&
        grecaptcha.getResponse !== undefined);
}
function isEnterprise(grecaptcha) {
    return (grecaptcha !== undefined &&
        grecaptcha.enterprise !== undefined);
}
class RecaptchaConfig {
    constructor(response) {
        /**
         * The reCAPTCHA site key.
         */
        this.siteKey = '';
        /**
         * The reCAPTCHA enablement status of the {@link EmailAuthProvider} for the current tenant.
         */
        this.emailPasswordEnabled = false;
        if (response.recaptchaKey === undefined) {
            throw new Error('recaptchaKey undefined');
        }
        // Example response.recaptchaKey: "projects/proj123/keys/sitekey123"
        this.siteKey = response.recaptchaKey.split('/')[3];
        this.emailPasswordEnabled = response.recaptchaEnforcementState.some(enforcementState => enforcementState.provider === 'EMAIL_PASSWORD_PROVIDER' &&
            enforcementState.enforcementState !== 'OFF');
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getScriptParentElement() {
    var _a, _b;
    return (_b = (_a = document.getElementsByTagName('head')) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : document;
}
function _loadJS(url) {
    // TODO: consider adding timeout support & cancellation
    return new Promise((resolve, reject) => {
        const el = document.createElement('script');
        el.setAttribute('src', url);
        el.onload = resolve;
        el.onerror = e => {
            const error = _createError("internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
            error.customData = e;
            reject(error);
        };
        el.type = 'text/javascript';
        el.charset = 'UTF-8';
        getScriptParentElement().appendChild(el);
    });
}
function _generateCallbackName(prefix) {
    return `__${prefix}${Math.floor(Math.random() * 1000000)}`;
}

/* eslint-disable @typescript-eslint/no-require-imports */
const RECAPTCHA_ENTERPRISE_URL = 'https://www.google.com/recaptcha/enterprise.js?render=';
const RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = 'recaptcha-enterprise';
const FAKE_TOKEN = 'NO_RECAPTCHA';
class RecaptchaEnterpriseVerifier {
    /**
     *
     * @param authExtern - The corresponding Firebase {@link Auth} instance.
     *
     */
    constructor(authExtern) {
        /**
         * Identifies the type of application verifier (e.g. "recaptcha-enterprise").
         */
        this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;
        this.auth = _castAuth(authExtern);
    }
    /**
     * Executes the verification process.
     *
     * @returns A Promise for a token that can be used to assert the validity of a request.
     */
    async verify(action = 'verify', forceRefresh = false) {
        async function retrieveSiteKey(auth) {
            if (!forceRefresh) {
                if (auth.tenantId == null && auth._agentRecaptchaConfig != null) {
                    return auth._agentRecaptchaConfig.siteKey;
                }
                if (auth.tenantId != null &&
                    auth._tenantRecaptchaConfigs[auth.tenantId] !== undefined) {
                    return auth._tenantRecaptchaConfigs[auth.tenantId].siteKey;
                }
            }
            return new Promise(async (resolve, reject) => {
                getRecaptchaConfig(auth, {
                    clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */,
                    version: "RECAPTCHA_ENTERPRISE" /* RecaptchaVersion.ENTERPRISE */
                })
                    .then(response => {
                    if (response.recaptchaKey === undefined) {
                        reject(new Error('recaptcha Enterprise site key undefined'));
                    }
                    else {
                        const config = new RecaptchaConfig(response);
                        if (auth.tenantId == null) {
                            auth._agentRecaptchaConfig = config;
                        }
                        else {
                            auth._tenantRecaptchaConfigs[auth.tenantId] = config;
                        }
                        return resolve(config.siteKey);
                    }
                })
                    .catch(error => {
                    reject(error);
                });
            });
        }
        function retrieveRecaptchaToken(siteKey, resolve, reject) {
            const grecaptcha = window.grecaptcha;
            if (isEnterprise(grecaptcha)) {
                grecaptcha.enterprise.ready(() => {
                    grecaptcha.enterprise
                        .execute(siteKey, { action })
                        .then(token => {
                        resolve(token);
                    })
                        .catch(() => {
                        resolve(FAKE_TOKEN);
                    });
                });
            }
            else {
                reject(Error('No reCAPTCHA enterprise script loaded.'));
            }
        }
        return new Promise((resolve, reject) => {
            retrieveSiteKey(this.auth)
                .then(siteKey => {
                if (!forceRefresh && isEnterprise(window.grecaptcha)) {
                    retrieveRecaptchaToken(siteKey, resolve, reject);
                }
                else {
                    if (typeof window === 'undefined') {
                        reject(new Error('RecaptchaVerifier is only supported in browser'));
                        return;
                    }
                    _loadJS(RECAPTCHA_ENTERPRISE_URL + siteKey)
                        .then(() => {
                        retrieveRecaptchaToken(siteKey, resolve, reject);
                    })
                        .catch(error => {
                        reject(error);
                    });
                }
            })
                .catch(error => {
                reject(error);
            });
        });
    }
}
async function injectRecaptchaFields(auth, request, action, captchaResp = false) {
    const verifier = new RecaptchaEnterpriseVerifier(auth);
    let captchaResponse;
    try {
        captchaResponse = await verifier.verify(action);
    }
    catch (error) {
        captchaResponse = await verifier.verify(action, true);
    }
    const newRequest = Object.assign({}, request);
    if (!captchaResp) {
        Object.assign(newRequest, { captchaResponse });
    }
    else {
        Object.assign(newRequest, { 'captchaResp': captchaResponse });
    }
    Object.assign(newRequest, { 'clientType': "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */ });
    Object.assign(newRequest, {
        'recaptchaVersion': "RECAPTCHA_ENTERPRISE" /* RecaptchaVersion.ENTERPRISE */
    });
    return newRequest;
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthMiddlewareQueue {
    constructor(auth) {
        this.auth = auth;
        this.queue = [];
    }
    pushCallback(callback, onAbort) {
        // The callback could be sync or async. Wrap it into a
        // function that is always async.
        const wrappedCallback = (user) => new Promise((resolve, reject) => {
            try {
                const result = callback(user);
                // Either resolve with existing promise or wrap a non-promise
                // return value into a promise.
                resolve(result);
            }
            catch (e) {
                // Sync callback throws.
                reject(e);
            }
        });
        // Attach the onAbort if present
        wrappedCallback.onAbort = onAbort;
        this.queue.push(wrappedCallback);
        const index = this.queue.length - 1;
        return () => {
            // Unsubscribe. Replace with no-op. Do not remove from array, or it will disturb
            // indexing of other elements.
            this.queue[index] = () => Promise.resolve();
        };
    }
    async runMiddleware(nextUser) {
        if (this.auth.currentUser === nextUser) {
            return;
        }
        // While running the middleware, build a temporary stack of onAbort
        // callbacks to call if one middleware callback rejects.
        const onAbortStack = [];
        try {
            for (const beforeStateCallback of this.queue) {
                await beforeStateCallback(nextUser);
                // Only push the onAbort if the callback succeeds
                if (beforeStateCallback.onAbort) {
                    onAbortStack.push(beforeStateCallback.onAbort);
                }
            }
        }
        catch (e) {
            // Run all onAbort, with separate try/catch to ignore any errors and
            // continue
            onAbortStack.reverse();
            for (const onAbort of onAbortStack) {
                try {
                    onAbort();
                }
                catch (_) {
                    /* swallow error */
                }
            }
            throw this.auth._errorFactory.create("login-blocked" /* AuthErrorCode.LOGIN_BLOCKED */, {
                originalMessage: e === null || e === void 0 ? void 0 : e.message
            });
        }
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthImpl {
    constructor(app, heartbeatServiceProvider, appCheckServiceProvider, config) {
        this.app = app;
        this.heartbeatServiceProvider = heartbeatServiceProvider;
        this.appCheckServiceProvider = appCheckServiceProvider;
        this.config = config;
        this.currentUser = null;
        this.emulatorConfig = null;
        this.operations = Promise.resolve();
        this.authStateSubscription = new Subscription(this);
        this.idTokenSubscription = new Subscription(this);
        this.beforeStateQueue = new AuthMiddlewareQueue(this);
        this.redirectUser = null;
        this.isProactiveRefreshEnabled = false;
        // Any network calls will set this to true and prevent subsequent emulator
        // initialization
        this._canInitEmulator = true;
        this._isInitialized = false;
        this._deleted = false;
        this._initializationPromise = null;
        this._popupRedirectResolver = null;
        this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;
        this._agentRecaptchaConfig = null;
        this._tenantRecaptchaConfigs = {};
        // Tracks the last notified UID for state change listeners to prevent
        // repeated calls to the callbacks. Undefined means it's never been
        // called, whereas null means it's been called with a signed out user
        this.lastNotifiedUid = undefined;
        this.languageCode = null;
        this.tenantId = null;
        this.settings = { appVerificationDisabledForTesting: false };
        this.frameworks = [];
        this.name = app.name;
        this.clientVersion = config.sdkClientVersion;
    }
    _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {
        if (popupRedirectResolver) {
            this._popupRedirectResolver = _getInstance(popupRedirectResolver);
        }
        // Have to check for app deletion throughout initialization (after each
        // promise resolution)
        this._initializationPromise = this.queue(async () => {
            var _a, _b;
            if (this._deleted) {
                return;
            }
            this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);
            if (this._deleted) {
                return;
            }
            // Initialize the resolver early if necessary (only applicable to web:
            // this will cause the iframe to load immediately in certain cases)
            if ((_a = this._popupRedirectResolver) === null || _a === void 0 ? void 0 : _a._shouldInitProactively) {
                // If this fails, don't halt auth loading
                try {
                    await this._popupRedirectResolver._initialize(this);
                }
                catch (e) {
                    /* Ignore the error */
                }
            }
            await this.initializeCurrentUser(popupRedirectResolver);
            this.lastNotifiedUid = ((_b = this.currentUser) === null || _b === void 0 ? void 0 : _b.uid) || null;
            if (this._deleted) {
                return;
            }
            this._isInitialized = true;
        });
        return this._initializationPromise;
    }
    /**
     * If the persistence is changed in another window, the user manager will let us know
     */
    async _onStorageEvent() {
        if (this._deleted) {
            return;
        }
        const user = await this.assertedPersistence.getCurrentUser();
        if (!this.currentUser && !user) {
            // No change, do nothing (was signed out and remained signed out).
            return;
        }
        // If the same user is to be synchronized.
        if (this.currentUser && user && this.currentUser.uid === user.uid) {
            // Data update, simply copy data changes.
            this._currentUser._assign(user);
            // If tokens changed from previous user tokens, this will trigger
            // notifyAuthListeners_.
            await this.currentUser.getIdToken();
            return;
        }
        // Update current Auth state. Either a new login or logout.
        // Skip blocking callbacks, they should not apply to a change in another tab.
        await this._updateCurrentUser(user, /* skipBeforeStateCallbacks */ true);
    }
    async initializeCurrentUser(popupRedirectResolver) {
        var _a;
        // First check to see if we have a pending redirect event.
        const previouslyStoredUser = (await this.assertedPersistence.getCurrentUser());
        let futureCurrentUser = previouslyStoredUser;
        let needsTocheckMiddleware = false;
        if (popupRedirectResolver && this.config.authDomain) {
            await this.getOrInitRedirectPersistenceManager();
            const redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;
            const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;
            const result = await this.tryRedirectSignIn(popupRedirectResolver);
            // If the stored user (i.e. the old "currentUser") has a redirectId that
            // matches the redirect user, then we want to initially sign in with the
            // new user object from result.
            // TODO(samgho): More thoroughly test all of this
            if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) &&
                (result === null || result === void 0 ? void 0 : result.user)) {
                futureCurrentUser = result.user;
                needsTocheckMiddleware = true;
            }
        }
        // If no user in persistence, there is no current user. Set to null.
        if (!futureCurrentUser) {
            return this.directlySetCurrentUser(null);
        }
        if (!futureCurrentUser._redirectEventId) {
            // This isn't a redirect link operation, we can reload and bail.
            // First though, ensure that we check the middleware is happy.
            if (needsTocheckMiddleware) {
                try {
                    await this.beforeStateQueue.runMiddleware(futureCurrentUser);
                }
                catch (e) {
                    futureCurrentUser = previouslyStoredUser;
                    // We know this is available since the bit is only set when the
                    // resolver is available
                    this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(e));
                }
            }
            if (futureCurrentUser) {
                return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);
            }
            else {
                return this.directlySetCurrentUser(null);
            }
        }
        _assert(this._popupRedirectResolver, this, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        await this.getOrInitRedirectPersistenceManager();
        // If the redirect user's event ID matches the current user's event ID,
        // DO NOT reload the current user, otherwise they'll be cleared from storage.
        // This is important for the reauthenticateWithRedirect() flow.
        if (this.redirectUser &&
            this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {
            return this.directlySetCurrentUser(futureCurrentUser);
        }
        return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);
    }
    async tryRedirectSignIn(redirectResolver) {
        // The redirect user needs to be checked (and signed in if available)
        // during auth initialization. All of the normal sign in and link/reauth
        // flows call back into auth and push things onto the promise queue. We
        // need to await the result of the redirect sign in *inside the promise
        // queue*. This presents a problem: we run into deadlock. See:
        //    ┌> [Initialization] ─────┐
        //    ┌> [<other queue tasks>] │
        //    └─ [getRedirectResult] <─┘
        //    where [] are tasks on the queue and arrows denote awaits
        // Initialization will never complete because it's waiting on something
        // that's waiting for initialization to complete!
        //
        // Instead, this method calls getRedirectResult() (stored in
        // _completeRedirectFn) with an optional parameter that instructs all of
        // the underlying auth operations to skip anything that mutates auth state.
        let result = null;
        try {
            // We know this._popupRedirectResolver is set since redirectResolver
            // is passed in. The _completeRedirectFn expects the unwrapped extern.
            result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);
        }
        catch (e) {
            // Swallow any errors here; the code can retrieve them in
            // getRedirectResult().
            await this._setRedirectUser(null);
        }
        return result;
    }
    async reloadAndSetCurrentUserOrClear(user) {
        try {
            await _reloadWithoutSaving(user);
        }
        catch (e) {
            if ((e === null || e === void 0 ? void 0 : e.code) !==
                `auth/${"network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {
                // Something's wrong with the user's token. Log them out and remove
                // them from storage
                return this.directlySetCurrentUser(null);
            }
        }
        return this.directlySetCurrentUser(user);
    }
    useDeviceLanguage() {
        this.languageCode = _getUserLanguage();
    }
    async _delete() {
        this._deleted = true;
    }
    async updateCurrentUser(userExtern) {
        // The public updateCurrentUser method needs to make a copy of the user,
        // and also check that the project matches
        const user = userExtern
            ? index_esm2017_getModularInstance(userExtern)
            : null;
        if (user) {
            _assert(user.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token" /* AuthErrorCode.INVALID_AUTH */);
        }
        return this._updateCurrentUser(user && user._clone(this));
    }
    async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {
        if (this._deleted) {
            return;
        }
        if (user) {
            _assert(this.tenantId === user.tenantId, this, "tenant-id-mismatch" /* AuthErrorCode.TENANT_ID_MISMATCH */);
        }
        if (!skipBeforeStateCallbacks) {
            await this.beforeStateQueue.runMiddleware(user);
        }
        return this.queue(async () => {
            await this.directlySetCurrentUser(user);
            this.notifyAuthListeners();
        });
    }
    async signOut() {
        // Run first, to block _setRedirectUser() if any callbacks fail.
        await this.beforeStateQueue.runMiddleware(null);
        // Clear the redirect user when signOut is called
        if (this.redirectPersistenceManager || this._popupRedirectResolver) {
            await this._setRedirectUser(null);
        }
        // Prevent callbacks from being called again in _updateCurrentUser, as
        // they were already called in the first line.
        return this._updateCurrentUser(null, /* skipBeforeStateCallbacks */ true);
    }
    setPersistence(persistence) {
        return this.queue(async () => {
            await this.assertedPersistence.setPersistence(_getInstance(persistence));
        });
    }
    async initializeRecaptchaConfig() {
        const response = await getRecaptchaConfig(this, {
            clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */,
            version: "RECAPTCHA_ENTERPRISE" /* RecaptchaVersion.ENTERPRISE */
        });
        const config = new RecaptchaConfig(response);
        if (this.tenantId == null) {
            this._agentRecaptchaConfig = config;
        }
        else {
            this._tenantRecaptchaConfigs[this.tenantId] = config;
        }
        if (config.emailPasswordEnabled) {
            const verifier = new RecaptchaEnterpriseVerifier(this);
            void verifier.verify();
        }
    }
    _getRecaptchaConfig() {
        if (this.tenantId == null) {
            return this._agentRecaptchaConfig;
        }
        else {
            return this._tenantRecaptchaConfigs[this.tenantId];
        }
    }
    _getPersistence() {
        return this.assertedPersistence.persistence.type;
    }
    _updateErrorMap(errorMap) {
        this._errorFactory = new ErrorFactory('auth', 'Firebase', errorMap());
    }
    onAuthStateChanged(nextOrObserver, error, completed) {
        return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);
    }
    beforeAuthStateChanged(callback, onAbort) {
        return this.beforeStateQueue.pushCallback(callback, onAbort);
    }
    onIdTokenChanged(nextOrObserver, error, completed) {
        return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);
    }
    toJSON() {
        var _a;
        return {
            apiKey: this.config.apiKey,
            authDomain: this.config.authDomain,
            appName: this.name,
            currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()
        };
    }
    async _setRedirectUser(user, popupRedirectResolver) {
        const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);
        return user === null
            ? redirectManager.removeCurrentUser()
            : redirectManager.setCurrentUser(user);
    }
    async getOrInitRedirectPersistenceManager(popupRedirectResolver) {
        if (!this.redirectPersistenceManager) {
            const resolver = (popupRedirectResolver && _getInstance(popupRedirectResolver)) ||
                this._popupRedirectResolver;
            _assert(resolver, this, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
            this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], "redirectUser" /* KeyName.REDIRECT_USER */);
            this.redirectUser =
                await this.redirectPersistenceManager.getCurrentUser();
        }
        return this.redirectPersistenceManager;
    }
    async _redirectUserForId(id) {
        var _a, _b;
        // Make sure we've cleared any pending persistence actions if we're not in
        // the initializer
        if (this._isInitialized) {
            await this.queue(async () => { });
        }
        if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id) {
            return this._currentUser;
        }
        if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {
            return this.redirectUser;
        }
        return null;
    }
    async _persistUserIfCurrent(user) {
        if (user === this.currentUser) {
            return this.queue(async () => this.directlySetCurrentUser(user));
        }
    }
    /** Notifies listeners only if the user is current */
    _notifyListenersIfCurrent(user) {
        if (user === this.currentUser) {
            this.notifyAuthListeners();
        }
    }
    _key() {
        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
    }
    _startProactiveRefresh() {
        this.isProactiveRefreshEnabled = true;
        if (this.currentUser) {
            this._currentUser._startProactiveRefresh();
        }
    }
    _stopProactiveRefresh() {
        this.isProactiveRefreshEnabled = false;
        if (this.currentUser) {
            this._currentUser._stopProactiveRefresh();
        }
    }
    /** Returns the current user cast as the internal type */
    get _currentUser() {
        return this.currentUser;
    }
    notifyAuthListeners() {
        var _a, _b;
        if (!this._isInitialized) {
            return;
        }
        this.idTokenSubscription.next(this.currentUser);
        const currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;
        if (this.lastNotifiedUid !== currentUid) {
            this.lastNotifiedUid = currentUid;
            this.authStateSubscription.next(this.currentUser);
        }
    }
    registerStateListener(subscription, nextOrObserver, error, completed) {
        if (this._deleted) {
            return () => { };
        }
        const cb = typeof nextOrObserver === 'function'
            ? nextOrObserver
            : nextOrObserver.next.bind(nextOrObserver);
        const promise = this._isInitialized
            ? Promise.resolve()
            : this._initializationPromise;
        _assert(promise, this, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        // The callback needs to be called asynchronously per the spec.
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        promise.then(() => cb(this.currentUser));
        if (typeof nextOrObserver === 'function') {
            return subscription.addObserver(nextOrObserver, error, completed);
        }
        else {
            return subscription.addObserver(nextOrObserver);
        }
    }
    /**
     * Unprotected (from race conditions) method to set the current user. This
     * should only be called from within a queued callback. This is necessary
     * because the queue shouldn't rely on another queued callback.
     */
    async directlySetCurrentUser(user) {
        if (this.currentUser && this.currentUser !== user) {
            this._currentUser._stopProactiveRefresh();
        }
        if (user && this.isProactiveRefreshEnabled) {
            user._startProactiveRefresh();
        }
        this.currentUser = user;
        if (user) {
            await this.assertedPersistence.setCurrentUser(user);
        }
        else {
            await this.assertedPersistence.removeCurrentUser();
        }
    }
    queue(action) {
        // In case something errors, the callback still should be called in order
        // to keep the promise chain alive
        this.operations = this.operations.then(action, action);
        return this.operations;
    }
    get assertedPersistence() {
        _assert(this.persistenceManager, this, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        return this.persistenceManager;
    }
    _logFramework(framework) {
        if (!framework || this.frameworks.includes(framework)) {
            return;
        }
        this.frameworks.push(framework);
        // Sort alphabetically so that "FirebaseCore-web,FirebaseUI-web" and
        // "FirebaseUI-web,FirebaseCore-web" aren't viewed as different.
        this.frameworks.sort();
        this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());
    }
    _getFrameworks() {
        return this.frameworks;
    }
    async _getAdditionalHeaders() {
        var _a;
        // Additional headers on every request
        const headers = {
            ["X-Client-Version" /* HttpHeader.X_CLIENT_VERSION */]: this.clientVersion
        };
        if (this.app.options.appId) {
            headers["X-Firebase-gmpid" /* HttpHeader.X_FIREBASE_GMPID */] = this.app.options.appId;
        }
        // If the heartbeat service exists, add the heartbeat string
        const heartbeatsHeader = await ((_a = this.heartbeatServiceProvider
            .getImmediate({
            optional: true
        })) === null || _a === void 0 ? void 0 : _a.getHeartbeatsHeader());
        if (heartbeatsHeader) {
            headers["X-Firebase-Client" /* HttpHeader.X_FIREBASE_CLIENT */] = heartbeatsHeader;
        }
        // If the App Check service exists, add the App Check token in the headers
        const appCheckToken = await this._getAppCheckToken();
        if (appCheckToken) {
            headers["X-Firebase-AppCheck" /* HttpHeader.X_FIREBASE_APP_CHECK */] = appCheckToken;
        }
        return headers;
    }
    async _getAppCheckToken() {
        var _a;
        const appCheckTokenResult = await ((_a = this.appCheckServiceProvider
            .getImmediate({ optional: true })) === null || _a === void 0 ? void 0 : _a.getToken());
        if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {
            // Context: appCheck.getToken() will never throw even if an error happened.
            // In the error case, a dummy token will be returned along with an error field describing
            // the error. In general, we shouldn't care about the error condition and just use
            // the token (actual or dummy) to send requests.
            _logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`);
        }
        return appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token;
    }
}
/**
 * Method to be used to cast down to our private implmentation of Auth.
 * It will also handle unwrapping from the compat type if necessary
 *
 * @param auth Auth object passed in from developer
 */
function _castAuth(auth) {
    return index_esm2017_getModularInstance(auth);
}
/** Helper class to wrap subscriber logic */
class Subscription {
    constructor(auth) {
        this.auth = auth;
        this.observer = null;
        this.addObserver = createSubscribe(observer => (this.observer = observer));
    }
    get next() {
        _assert(this.observer, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        return this.observer.next.bind(this.observer);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Initializes an {@link Auth} instance with fine-grained control over
 * {@link Dependencies}.
 *
 * @remarks
 *
 * This function allows more control over the {@link Auth} instance than
 * {@link getAuth}. `getAuth` uses platform-specific defaults to supply
 * the {@link Dependencies}. In general, `getAuth` is the easiest way to
 * initialize Auth and works for most use cases. Use `initializeAuth` if you
 * need control over which persistence layer is used, or to minimize bundle
 * size if you're not using either `signInWithPopup` or `signInWithRedirect`.
 *
 * For example, if your app only uses anonymous accounts and you only want
 * accounts saved for the current session, initialize `Auth` with:
 *
 * ```js
 * const auth = initializeAuth(app, {
 *   persistence: browserSessionPersistence,
 *   popupRedirectResolver: undefined,
 * });
 * ```
 *
 * @public
 */
function initializeAuth(app, deps) {
    const provider = _getProvider(app, 'auth');
    if (provider.isInitialized()) {
        const auth = provider.getImmediate();
        const initialOptions = provider.getOptions();
        if (deepEqual(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {
            return auth;
        }
        else {
            _fail(auth, "already-initialized" /* AuthErrorCode.ALREADY_INITIALIZED */);
        }
    }
    const auth = provider.initialize({ options: deps });
    return auth;
}
function _initializeAuthInstance(auth, deps) {
    const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];
    const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);
    if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {
        auth._updateErrorMap(deps.errorMap);
    }
    // This promise is intended to float; auth initialization happens in the
    // background, meanwhile the auth object may be used by the app.
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);
}

/**
 * Changes the {@link Auth} instance to communicate with the Firebase Auth Emulator, instead of production
 * Firebase Auth services.
 *
 * @remarks
 * This must be called synchronously immediately following the first call to
 * {@link initializeAuth}.  Do not use with production credentials as emulator
 * traffic is not encrypted.
 *
 *
 * @example
 * ```javascript
 * connectAuthEmulator(auth, 'http://127.0.0.1:9099', { disableWarnings: true });
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param url - The URL at which the emulator is running (eg, 'http://localhost:9099').
 * @param options - Optional. `options.disableWarnings` defaults to `false`. Set it to
 * `true` to disable the warning banner attached to the DOM.
 *
 * @public
 */
function connectAuthEmulator(auth, url, options) {
    const authInternal = _castAuth(auth);
    _assert(authInternal._canInitEmulator, authInternal, "emulator-config-failed" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */);
    _assert(/^https?:\/\//.test(url), authInternal, "invalid-emulator-scheme" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */);
    const disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);
    const protocol = extractProtocol(url);
    const { host, port } = extractHostAndPort(url);
    const portStr = port === null ? '' : `:${port}`;
    // Always replace path with "/" (even if input url had no path at all, or had a different one).
    authInternal.config.emulator = { url: `${protocol}//${host}${portStr}/` };
    authInternal.settings.appVerificationDisabledForTesting = true;
    authInternal.emulatorConfig = Object.freeze({
        host,
        port,
        protocol: protocol.replace(':', ''),
        options: Object.freeze({ disableWarnings })
    });
    if (!disableWarnings) {
        emitEmulatorWarning();
    }
}
function extractProtocol(url) {
    const protocolEnd = url.indexOf(':');
    return protocolEnd < 0 ? '' : url.substr(0, protocolEnd + 1);
}
function extractHostAndPort(url) {
    const protocol = extractProtocol(url);
    const authority = /(\/\/)?([^?#/]+)/.exec(url.substr(protocol.length)); // Between // and /, ? or #.
    if (!authority) {
        return { host: '', port: null };
    }
    const hostAndPort = authority[2].split('@').pop() || ''; // Strip out "username:password@".
    const bracketedIPv6 = /^(\[[^\]]+\])(:|$)/.exec(hostAndPort);
    if (bracketedIPv6) {
        const host = bracketedIPv6[1];
        return { host, port: parsePort(hostAndPort.substr(host.length + 1)) };
    }
    else {
        const [host, port] = hostAndPort.split(':');
        return { host, port: parsePort(port) };
    }
}
function parsePort(portStr) {
    if (!portStr) {
        return null;
    }
    const port = Number(portStr);
    if (isNaN(port)) {
        return null;
    }
    return port;
}
function emitEmulatorWarning() {
    function attachBanner() {
        const el = document.createElement('p');
        const sty = el.style;
        el.innerText =
            'Running in emulator mode. Do not use with production credentials.';
        sty.position = 'fixed';
        sty.width = '100%';
        sty.backgroundColor = '#ffffff';
        sty.border = '.1em solid #000000';
        sty.color = '#b50000';
        sty.bottom = '0px';
        sty.left = '0px';
        sty.margin = '0px';
        sty.zIndex = '10000';
        sty.textAlign = 'center';
        el.classList.add('firebase-emulator-warning');
        document.body.appendChild(el);
    }
    if (typeof console !== 'undefined' && typeof console.info === 'function') {
        console.info('WARNING: You are using the Auth Emulator,' +
            ' which is intended for local testing only.  Do not use with' +
            ' production credentials.');
    }
    if (typeof window !== 'undefined' && typeof document !== 'undefined') {
        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', attachBanner);
        }
        else {
            attachBanner();
        }
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface that represents the credentials returned by an {@link AuthProvider}.
 *
 * @remarks
 * Implementations specify the details about each auth provider's credential requirements.
 *
 * @public
 */
class AuthCredential {
    /** @internal */
    constructor(
    /**
     * The authentication provider ID for the credential.
     *
     * @remarks
     * For example, 'facebook.com', or 'google.com'.
     */
    providerId, 
    /**
     * The authentication sign in method for the credential.
     *
     * @remarks
     * For example, {@link SignInMethod}.EMAIL_PASSWORD, or
     * {@link SignInMethod}.EMAIL_LINK. This corresponds to the sign-in method
     * identifier as returned in {@link fetchSignInMethodsForEmail}.
     */
    signInMethod) {
        this.providerId = providerId;
        this.signInMethod = signInMethod;
    }
    /**
     * Returns a JSON-serializable representation of this object.
     *
     * @returns a JSON-serializable representation of this object.
     */
    toJSON() {
        return debugFail('not implemented');
    }
    /** @internal */
    _getIdTokenResponse(_auth) {
        return debugFail('not implemented');
    }
    /** @internal */
    _linkToIdToken(_auth, _idToken) {
        return debugFail('not implemented');
    }
    /** @internal */
    _getReauthenticationResolver(_auth) {
        return debugFail('not implemented');
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function resetPassword(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:resetPassword" /* Endpoint.RESET_PASSWORD */, _addTidIfNecessary(auth, request));
}
async function updateEmailPassword(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:update" /* Endpoint.SET_ACCOUNT_INFO */, request);
}
async function applyActionCode$1(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:update" /* Endpoint.SET_ACCOUNT_INFO */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithPassword(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithPassword" /* Endpoint.SIGN_IN_WITH_PASSWORD */, _addTidIfNecessary(auth, request));
}
async function sendOobCode(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:sendOobCode" /* Endpoint.SEND_OOB_CODE */, _addTidIfNecessary(auth, request));
}
async function sendEmailVerification$1(auth, request) {
    return sendOobCode(auth, request);
}
async function sendPasswordResetEmail$1(auth, request) {
    return sendOobCode(auth, request);
}
async function sendSignInLinkToEmail$1(auth, request) {
    return sendOobCode(auth, request);
}
async function verifyAndChangeEmail(auth, request) {
    return sendOobCode(auth, request);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithEmailLink$1(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithEmailLink" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));
}
async function signInWithEmailLinkForLinking(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithEmailLink" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface that represents the credentials returned by {@link EmailAuthProvider} for
 * {@link ProviderId}.PASSWORD
 *
 * @remarks
 * Covers both {@link SignInMethod}.EMAIL_PASSWORD and
 * {@link SignInMethod}.EMAIL_LINK.
 *
 * @public
 */
class EmailAuthCredential extends AuthCredential {
    /** @internal */
    constructor(
    /** @internal */
    _email, 
    /** @internal */
    _password, signInMethod, 
    /** @internal */
    _tenantId = null) {
        super("password" /* ProviderId.PASSWORD */, signInMethod);
        this._email = _email;
        this._password = _password;
        this._tenantId = _tenantId;
    }
    /** @internal */
    static _fromEmailAndPassword(email, password) {
        return new EmailAuthCredential(email, password, "password" /* SignInMethod.EMAIL_PASSWORD */);
    }
    /** @internal */
    static _fromEmailAndCode(email, oobCode, tenantId = null) {
        return new EmailAuthCredential(email, oobCode, "emailLink" /* SignInMethod.EMAIL_LINK */, tenantId);
    }
    /** {@inheritdoc AuthCredential.toJSON} */
    toJSON() {
        return {
            email: this._email,
            password: this._password,
            signInMethod: this.signInMethod,
            tenantId: this._tenantId
        };
    }
    /**
     * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.
     *
     * @param json - Either `object` or the stringified representation of the object. When string is
     * provided, `JSON.parse` would be called first.
     *
     * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.
     */
    static fromJSON(json) {
        const obj = typeof json === 'string' ? JSON.parse(json) : json;
        if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {
            if (obj.signInMethod === "password" /* SignInMethod.EMAIL_PASSWORD */) {
                return this._fromEmailAndPassword(obj.email, obj.password);
            }
            else if (obj.signInMethod === "emailLink" /* SignInMethod.EMAIL_LINK */) {
                return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);
            }
        }
        return null;
    }
    /** @internal */
    async _getIdTokenResponse(auth) {
        var _a;
        switch (this.signInMethod) {
            case "password" /* SignInMethod.EMAIL_PASSWORD */:
                const request = {
                    returnSecureToken: true,
                    email: this._email,
                    password: this._password,
                    clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */
                };
                if ((_a = auth._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.emailPasswordEnabled) {
                    const requestWithRecaptcha = await injectRecaptchaFields(auth, request, "signInWithPassword" /* RecaptchaActionName.SIGN_IN_WITH_PASSWORD */);
                    return signInWithPassword(auth, requestWithRecaptcha);
                }
                else {
                    return signInWithPassword(auth, request).catch(async (error) => {
                        if (error.code === `auth/${"missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {
                            console.log('Sign-in with email address and password is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-in flow.');
                            const requestWithRecaptcha = await injectRecaptchaFields(auth, request, "signInWithPassword" /* RecaptchaActionName.SIGN_IN_WITH_PASSWORD */);
                            return signInWithPassword(auth, requestWithRecaptcha);
                        }
                        else {
                            return Promise.reject(error);
                        }
                    });
                }
            case "emailLink" /* SignInMethod.EMAIL_LINK */:
                return signInWithEmailLink$1(auth, {
                    email: this._email,
                    oobCode: this._password
                });
            default:
                _fail(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        }
    }
    /** @internal */
    async _linkToIdToken(auth, idToken) {
        switch (this.signInMethod) {
            case "password" /* SignInMethod.EMAIL_PASSWORD */:
                return updateEmailPassword(auth, {
                    idToken,
                    returnSecureToken: true,
                    email: this._email,
                    password: this._password
                });
            case "emailLink" /* SignInMethod.EMAIL_LINK */:
                return signInWithEmailLinkForLinking(auth, {
                    idToken,
                    email: this._email,
                    oobCode: this._password
                });
            default:
                _fail(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        }
    }
    /** @internal */
    _getReauthenticationResolver(auth) {
        return this._getIdTokenResponse(auth);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithIdp(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithIdp" /* Endpoint.SIGN_IN_WITH_IDP */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IDP_REQUEST_URI$1 = 'http://localhost';
/**
 * Represents the OAuth credentials returned by an {@link OAuthProvider}.
 *
 * @remarks
 * Implementations specify the details about each auth provider's credential requirements.
 *
 * @public
 */
class OAuthCredential extends AuthCredential {
    constructor() {
        super(...arguments);
        this.pendingToken = null;
    }
    /** @internal */
    static _fromParams(params) {
        const cred = new OAuthCredential(params.providerId, params.signInMethod);
        if (params.idToken || params.accessToken) {
            // OAuth 2 and either ID token or access token.
            if (params.idToken) {
                cred.idToken = params.idToken;
            }
            if (params.accessToken) {
                cred.accessToken = params.accessToken;
            }
            // Add nonce if available and no pendingToken is present.
            if (params.nonce && !params.pendingToken) {
                cred.nonce = params.nonce;
            }
            if (params.pendingToken) {
                cred.pendingToken = params.pendingToken;
            }
        }
        else if (params.oauthToken && params.oauthTokenSecret) {
            // OAuth 1 and OAuth token with token secret
            cred.accessToken = params.oauthToken;
            cred.secret = params.oauthTokenSecret;
        }
        else {
            _fail("argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        }
        return cred;
    }
    /** {@inheritdoc AuthCredential.toJSON}  */
    toJSON() {
        return {
            idToken: this.idToken,
            accessToken: this.accessToken,
            secret: this.secret,
            nonce: this.nonce,
            pendingToken: this.pendingToken,
            providerId: this.providerId,
            signInMethod: this.signInMethod
        };
    }
    /**
     * Static method to deserialize a JSON representation of an object into an
     * {@link  AuthCredential}.
     *
     * @param json - Input can be either Object or the stringified representation of the object.
     * When string is provided, JSON.parse would be called first.
     *
     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
     */
    static fromJSON(json) {
        const obj = typeof json === 'string' ? JSON.parse(json) : json;
        const { providerId, signInMethod } = obj, rest = __rest(obj, ["providerId", "signInMethod"]);
        if (!providerId || !signInMethod) {
            return null;
        }
        const cred = new OAuthCredential(providerId, signInMethod);
        cred.idToken = rest.idToken || undefined;
        cred.accessToken = rest.accessToken || undefined;
        cred.secret = rest.secret;
        cred.nonce = rest.nonce;
        cred.pendingToken = rest.pendingToken || null;
        return cred;
    }
    /** @internal */
    _getIdTokenResponse(auth) {
        const request = this.buildRequest();
        return signInWithIdp(auth, request);
    }
    /** @internal */
    _linkToIdToken(auth, idToken) {
        const request = this.buildRequest();
        request.idToken = idToken;
        return signInWithIdp(auth, request);
    }
    /** @internal */
    _getReauthenticationResolver(auth) {
        const request = this.buildRequest();
        request.autoCreate = false;
        return signInWithIdp(auth, request);
    }
    buildRequest() {
        const request = {
            requestUri: IDP_REQUEST_URI$1,
            returnSecureToken: true
        };
        if (this.pendingToken) {
            request.pendingToken = this.pendingToken;
        }
        else {
            const postBody = {};
            if (this.idToken) {
                postBody['id_token'] = this.idToken;
            }
            if (this.accessToken) {
                postBody['access_token'] = this.accessToken;
            }
            if (this.secret) {
                postBody['oauth_token_secret'] = this.secret;
            }
            postBody['providerId'] = this.providerId;
            if (this.nonce && !this.pendingToken) {
                postBody['nonce'] = this.nonce;
            }
            request.postBody = index_esm2017_querystring(postBody);
        }
        return request;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function sendPhoneVerificationCode(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:sendVerificationCode" /* Endpoint.SEND_VERIFICATION_CODE */, _addTidIfNecessary(auth, request));
}
async function signInWithPhoneNumber$1(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithPhoneNumber" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));
}
async function linkWithPhoneNumber$1(auth, request) {
    const response = await _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithPhoneNumber" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));
    if (response.temporaryProof) {
        throw _makeTaggedError(auth, "account-exists-with-different-credential" /* AuthErrorCode.NEED_CONFIRMATION */, response);
    }
    return response;
}
const VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = {
    ["USER_NOT_FOUND" /* ServerError.USER_NOT_FOUND */]: "user-not-found" /* AuthErrorCode.USER_DELETED */
};
async function verifyPhoneNumberForExisting(auth, request) {
    const apiRequest = Object.assign(Object.assign({}, request), { operation: 'REAUTH' });
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithPhoneNumber" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Represents the credentials returned by {@link PhoneAuthProvider}.
 *
 * @public
 */
class PhoneAuthCredential extends AuthCredential {
    constructor(params) {
        super("phone" /* ProviderId.PHONE */, "phone" /* SignInMethod.PHONE */);
        this.params = params;
    }
    /** @internal */
    static _fromVerification(verificationId, verificationCode) {
        return new PhoneAuthCredential({ verificationId, verificationCode });
    }
    /** @internal */
    static _fromTokenResponse(phoneNumber, temporaryProof) {
        return new PhoneAuthCredential({ phoneNumber, temporaryProof });
    }
    /** @internal */
    _getIdTokenResponse(auth) {
        return signInWithPhoneNumber$1(auth, this._makeVerificationRequest());
    }
    /** @internal */
    _linkToIdToken(auth, idToken) {
        return linkWithPhoneNumber$1(auth, Object.assign({ idToken }, this._makeVerificationRequest()));
    }
    /** @internal */
    _getReauthenticationResolver(auth) {
        return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());
    }
    /** @internal */
    _makeVerificationRequest() {
        const { temporaryProof, phoneNumber, verificationId, verificationCode } = this.params;
        if (temporaryProof && phoneNumber) {
            return { temporaryProof, phoneNumber };
        }
        return {
            sessionInfo: verificationId,
            code: verificationCode
        };
    }
    /** {@inheritdoc AuthCredential.toJSON} */
    toJSON() {
        const obj = {
            providerId: this.providerId
        };
        if (this.params.phoneNumber) {
            obj.phoneNumber = this.params.phoneNumber;
        }
        if (this.params.temporaryProof) {
            obj.temporaryProof = this.params.temporaryProof;
        }
        if (this.params.verificationCode) {
            obj.verificationCode = this.params.verificationCode;
        }
        if (this.params.verificationId) {
            obj.verificationId = this.params.verificationId;
        }
        return obj;
    }
    /** Generates a phone credential based on a plain object or a JSON string. */
    static fromJSON(json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        const { verificationId, verificationCode, phoneNumber, temporaryProof } = json;
        if (!verificationCode &&
            !verificationId &&
            !phoneNumber &&
            !temporaryProof) {
            return null;
        }
        return new PhoneAuthCredential({
            verificationId,
            verificationCode,
            phoneNumber,
            temporaryProof
        });
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Maps the mode string in action code URL to Action Code Info operation.
 *
 * @param mode
 */
function parseMode(mode) {
    switch (mode) {
        case 'recoverEmail':
            return "RECOVER_EMAIL" /* ActionCodeOperation.RECOVER_EMAIL */;
        case 'resetPassword':
            return "PASSWORD_RESET" /* ActionCodeOperation.PASSWORD_RESET */;
        case 'signIn':
            return "EMAIL_SIGNIN" /* ActionCodeOperation.EMAIL_SIGNIN */;
        case 'verifyEmail':
            return "VERIFY_EMAIL" /* ActionCodeOperation.VERIFY_EMAIL */;
        case 'verifyAndChangeEmail':
            return "VERIFY_AND_CHANGE_EMAIL" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */;
        case 'revertSecondFactorAddition':
            return "REVERT_SECOND_FACTOR_ADDITION" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */;
        default:
            return null;
    }
}
/**
 * Helper to parse FDL links
 *
 * @param url
 */
function parseDeepLink(url) {
    const link = querystringDecode(extractQuerystring(url))['link'];
    // Double link case (automatic redirect).
    const doubleDeepLink = link
        ? querystringDecode(extractQuerystring(link))['deep_link_id']
        : null;
    // iOS custom scheme links.
    const iOSDeepLink = querystringDecode(extractQuerystring(url))['deep_link_id'];
    const iOSDoubleDeepLink = iOSDeepLink
        ? querystringDecode(extractQuerystring(iOSDeepLink))['link']
        : null;
    return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
/**
 * A utility class to parse email action URLs such as password reset, email verification,
 * email link sign in, etc.
 *
 * @public
 */
class ActionCodeURL {
    /**
     * @param actionLink - The link from which to extract the URL.
     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
     *
     * @internal
     */
    constructor(actionLink) {
        var _a, _b, _c, _d, _e, _f;
        const searchParams = querystringDecode(extractQuerystring(actionLink));
        const apiKey = (_a = searchParams["apiKey" /* QueryField.API_KEY */]) !== null && _a !== void 0 ? _a : null;
        const code = (_b = searchParams["oobCode" /* QueryField.CODE */]) !== null && _b !== void 0 ? _b : null;
        const operation = parseMode((_c = searchParams["mode" /* QueryField.MODE */]) !== null && _c !== void 0 ? _c : null);
        // Validate API key, code and mode.
        _assert(apiKey && code && operation, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        this.apiKey = apiKey;
        this.operation = operation;
        this.code = code;
        this.continueUrl = (_d = searchParams["continueUrl" /* QueryField.CONTINUE_URL */]) !== null && _d !== void 0 ? _d : null;
        this.languageCode = (_e = searchParams["languageCode" /* QueryField.LANGUAGE_CODE */]) !== null && _e !== void 0 ? _e : null;
        this.tenantId = (_f = searchParams["tenantId" /* QueryField.TENANT_ID */]) !== null && _f !== void 0 ? _f : null;
    }
    /**
     * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,
     * otherwise returns null.
     *
     * @param link  - The email action link string.
     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
     *
     * @public
     */
    static parseLink(link) {
        const actionLink = parseDeepLink(link);
        try {
            return new ActionCodeURL(actionLink);
        }
        catch (_a) {
            return null;
        }
    }
}
/**
 * Parses the email action link string and returns an {@link ActionCodeURL} if
 * the link is valid, otherwise returns null.
 *
 * @public
 */
function parseActionCodeURL(link) {
    return ActionCodeURL.parseLink(link);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating {@link EmailAuthCredential}.
 *
 * @public
 */
class EmailAuthProvider {
    constructor() {
        /**
         * Always set to {@link ProviderId}.PASSWORD, even for email link.
         */
        this.providerId = EmailAuthProvider.PROVIDER_ID;
    }
    /**
     * Initialize an {@link AuthCredential} using an email and password.
     *
     * @example
     * ```javascript
     * const authCredential = EmailAuthProvider.credential(email, password);
     * const userCredential = await signInWithCredential(auth, authCredential);
     * ```
     *
     * @example
     * ```javascript
     * const userCredential = await signInWithEmailAndPassword(auth, email, password);
     * ```
     *
     * @param email - Email address.
     * @param password - User account password.
     * @returns The auth provider credential.
     */
    static credential(email, password) {
        return EmailAuthCredential._fromEmailAndPassword(email, password);
    }
    /**
     * Initialize an {@link AuthCredential} using an email and an email link after a sign in with
     * email link operation.
     *
     * @example
     * ```javascript
     * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);
     * const userCredential = await signInWithCredential(auth, authCredential);
     * ```
     *
     * @example
     * ```javascript
     * await sendSignInLinkToEmail(auth, email);
     * // Obtain emailLink from user.
     * const userCredential = await signInWithEmailLink(auth, email, emailLink);
     * ```
     *
     * @param auth - The {@link Auth} instance used to verify the link.
     * @param email - Email address.
     * @param emailLink - Sign-in email link.
     * @returns - The auth provider credential.
     */
    static credentialWithLink(email, emailLink) {
        const actionCodeUrl = ActionCodeURL.parseLink(emailLink);
        _assert(actionCodeUrl, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);
    }
}
/**
 * Always set to {@link ProviderId}.PASSWORD, even for email link.
 */
EmailAuthProvider.PROVIDER_ID = "password" /* ProviderId.PASSWORD */;
/**
 * Always set to {@link SignInMethod}.EMAIL_PASSWORD.
 */
EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = "password" /* SignInMethod.EMAIL_PASSWORD */;
/**
 * Always set to {@link SignInMethod}.EMAIL_LINK.
 */
EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = "emailLink" /* SignInMethod.EMAIL_LINK */;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The base class for all Federated providers (OAuth (including OIDC), SAML).
 *
 * This class is not meant to be instantiated directly.
 *
 * @public
 */
class FederatedAuthProvider {
    /**
     * Constructor for generic OAuth providers.
     *
     * @param providerId - Provider for which credentials should be generated.
     */
    constructor(providerId) {
        this.providerId = providerId;
        /** @internal */
        this.defaultLanguageCode = null;
        /** @internal */
        this.customParameters = {};
    }
    /**
     * Set the language gode.
     *
     * @param languageCode - language code
     */
    setDefaultLanguage(languageCode) {
        this.defaultLanguageCode = languageCode;
    }
    /**
     * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in
     * operations.
     *
     * @remarks
     * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,
     * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.
     *
     * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.
     */
    setCustomParameters(customOAuthParameters) {
        this.customParameters = customOAuthParameters;
        return this;
    }
    /**
     * Retrieve the current list of {@link CustomParameters}.
     */
    getCustomParameters() {
        return this.customParameters;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Common code to all OAuth providers. This is separate from the
 * {@link OAuthProvider} so that child providers (like
 * {@link GoogleAuthProvider}) don't inherit the `credential` instance method.
 * Instead, they rely on a static `credential` method.
 */
class BaseOAuthProvider extends FederatedAuthProvider {
    constructor() {
        super(...arguments);
        /** @internal */
        this.scopes = [];
    }
    /**
     * Add an OAuth scope to the credential.
     *
     * @param scope - Provider OAuth scope to add.
     */
    addScope(scope) {
        // If not already added, add scope to list.
        if (!this.scopes.includes(scope)) {
            this.scopes.push(scope);
        }
        return this;
    }
    /**
     * Retrieve the current list of OAuth scopes.
     */
    getScopes() {
        return [...this.scopes];
    }
}
/**
 * Provider for generating generic {@link OAuthCredential}.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new OAuthProvider('google.com');
 * // Start a sign in process for an unauthenticated user.
 * provider.addScope('profile');
 * provider.addScope('email');
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a OAuth Access Token for the provider.
 *   const credential = provider.credentialFromResult(auth, result);
 *   const token = credential.accessToken;
 * }
 * ```
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new OAuthProvider('google.com');
 * provider.addScope('profile');
 * provider.addScope('email');
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a OAuth Access Token for the provider.
 * const credential = provider.credentialFromResult(auth, result);
 * const token = credential.accessToken;
 * ```
 * @public
 */
class OAuthProvider extends (/* unused pure expression or super */ null && (BaseOAuthProvider)) {
    /**
     * Creates an {@link OAuthCredential} from a JSON string or a plain object.
     * @param json - A plain object or a JSON string
     */
    static credentialFromJSON(json) {
        const obj = typeof json === 'string' ? JSON.parse(json) : json;
        _assert('providerId' in obj && 'signInMethod' in obj, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        return OAuthCredential._fromParams(obj);
    }
    /**
     * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.
     *
     * @remarks
     * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of
     * the raw nonce must match the nonce field in the ID token.
     *
     * @example
     * ```javascript
     * // `googleUser` from the onsuccess Google Sign In callback.
     * // Initialize a generate OAuth provider with a `google.com` providerId.
     * const provider = new OAuthProvider('google.com');
     * const credential = provider.credential({
     *   idToken: googleUser.getAuthResponse().id_token,
     * });
     * const result = await signInWithCredential(credential);
     * ```
     *
     * @param params - Either the options object containing the ID token, access token and raw nonce
     * or the ID token string.
     */
    credential(params) {
        return this._credential(Object.assign(Object.assign({}, params), { nonce: params.rawNonce }));
    }
    /** An internal credential method that accepts more permissive options */
    _credential(params) {
        _assert(params.idToken || params.accessToken, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        // For OAuthCredential, sign in method is same as providerId.
        return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), { providerId: this.providerId, signInMethod: this.providerId }));
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return OAuthProvider.oauthCredentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return OAuthProvider.oauthCredentialFromTaggedObject((error.customData || {}));
    }
    static oauthCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse) {
            return null;
        }
        const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce, providerId } = tokenResponse;
        if (!oauthAccessToken &&
            !oauthTokenSecret &&
            !oauthIdToken &&
            !pendingToken) {
            return null;
        }
        if (!providerId) {
            return null;
        }
        try {
            return new OAuthProvider(providerId)._credential({
                idToken: oauthIdToken,
                accessToken: oauthAccessToken,
                nonce,
                pendingToken
            });
        }
        catch (e) {
            return null;
        }
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.FACEBOOK.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new FacebookAuthProvider();
 * // Start a sign in process for an unauthenticated user.
 * provider.addScope('user_birthday');
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Facebook Access Token.
 *   const credential = FacebookAuthProvider.credentialFromResult(result);
 *   const token = credential.accessToken;
 * }
 * ```
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new FacebookAuthProvider();
 * provider.addScope('user_birthday');
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a Facebook Access Token.
 * const credential = FacebookAuthProvider.credentialFromResult(result);
 * const token = credential.accessToken;
 * ```
 *
 * @public
 */
class FacebookAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("facebook.com" /* ProviderId.FACEBOOK */);
    }
    /**
     * Creates a credential for Facebook.
     *
     * @example
     * ```javascript
     * // `event` from the Facebook auth.authResponseChange callback.
     * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);
     * const result = await signInWithCredential(credential);
     * ```
     *
     * @param accessToken - Facebook access token.
     */
    static credential(accessToken) {
        return OAuthCredential._fromParams({
            providerId: FacebookAuthProvider.PROVIDER_ID,
            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
            accessToken
        });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return FacebookAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return FacebookAuthProvider.credentialFromTaggedObject((error.customData || {}));
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {
            return null;
        }
        if (!tokenResponse.oauthAccessToken) {
            return null;
        }
        try {
            return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);
        }
        catch (_a) {
            return null;
        }
    }
}
/** Always set to {@link SignInMethod}.FACEBOOK. */
FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = "facebook.com" /* SignInMethod.FACEBOOK */;
/** Always set to {@link ProviderId}.FACEBOOK. */
FacebookAuthProvider.PROVIDER_ID = "facebook.com" /* ProviderId.FACEBOOK */;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating an an {@link OAuthCredential} for {@link ProviderId}.GOOGLE.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new GoogleAuthProvider();
 * // Start a sign in process for an unauthenticated user.
 * provider.addScope('profile');
 * provider.addScope('email');
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Google Access Token.
 *   const credential = GoogleAuthProvider.credentialFromResult(result);
 *   const token = credential.accessToken;
 * }
 * ```
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new GoogleAuthProvider();
 * provider.addScope('profile');
 * provider.addScope('email');
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a Google Access Token.
 * const credential = GoogleAuthProvider.credentialFromResult(result);
 * const token = credential.accessToken;
 * ```
 *
 * @public
 */
class GoogleAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("google.com" /* ProviderId.GOOGLE */);
        this.addScope('profile');
    }
    /**
     * Creates a credential for Google. At least one of ID token and access token is required.
     *
     * @example
     * ```javascript
     * // \`googleUser\` from the onsuccess Google Sign In callback.
     * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);
     * const result = await signInWithCredential(credential);
     * ```
     *
     * @param idToken - Google ID token.
     * @param accessToken - Google access token.
     */
    static credential(idToken, accessToken) {
        return OAuthCredential._fromParams({
            providerId: GoogleAuthProvider.PROVIDER_ID,
            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,
            idToken,
            accessToken
        });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return GoogleAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return GoogleAuthProvider.credentialFromTaggedObject((error.customData || {}));
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse) {
            return null;
        }
        const { oauthIdToken, oauthAccessToken } = tokenResponse;
        if (!oauthIdToken && !oauthAccessToken) {
            // This could be an oauth 1 credential or a phone credential
            return null;
        }
        try {
            return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);
        }
        catch (_a) {
            return null;
        }
    }
}
/** Always set to {@link SignInMethod}.GOOGLE. */
GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = "google.com" /* SignInMethod.GOOGLE */;
/** Always set to {@link ProviderId}.GOOGLE. */
GoogleAuthProvider.PROVIDER_ID = "google.com" /* ProviderId.GOOGLE */;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GITHUB.
 *
 * @remarks
 * GitHub requires an OAuth 2.0 redirect, so you can either handle the redirect directly, or use
 * the {@link signInWithPopup} handler:
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new GithubAuthProvider();
 * // Start a sign in process for an unauthenticated user.
 * provider.addScope('repo');
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Github Access Token.
 *   const credential = GithubAuthProvider.credentialFromResult(result);
 *   const token = credential.accessToken;
 * }
 * ```
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new GithubAuthProvider();
 * provider.addScope('repo');
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a Github Access Token.
 * const credential = GithubAuthProvider.credentialFromResult(result);
 * const token = credential.accessToken;
 * ```
 * @public
 */
class GithubAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("github.com" /* ProviderId.GITHUB */);
    }
    /**
     * Creates a credential for Github.
     *
     * @param accessToken - Github access token.
     */
    static credential(accessToken) {
        return OAuthCredential._fromParams({
            providerId: GithubAuthProvider.PROVIDER_ID,
            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,
            accessToken
        });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return GithubAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return GithubAuthProvider.credentialFromTaggedObject((error.customData || {}));
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {
            return null;
        }
        if (!tokenResponse.oauthAccessToken) {
            return null;
        }
        try {
            return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);
        }
        catch (_a) {
            return null;
        }
    }
}
/** Always set to {@link SignInMethod}.GITHUB. */
GithubAuthProvider.GITHUB_SIGN_IN_METHOD = "github.com" /* SignInMethod.GITHUB */;
/** Always set to {@link ProviderId}.GITHUB. */
GithubAuthProvider.PROVIDER_ID = "github.com" /* ProviderId.GITHUB */;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IDP_REQUEST_URI = 'http://localhost';
/**
 * @public
 */
class SAMLAuthCredential extends (/* unused pure expression or super */ null && (AuthCredential)) {
    /** @internal */
    constructor(providerId, pendingToken) {
        super(providerId, providerId);
        this.pendingToken = pendingToken;
    }
    /** @internal */
    _getIdTokenResponse(auth) {
        const request = this.buildRequest();
        return signInWithIdp(auth, request);
    }
    /** @internal */
    _linkToIdToken(auth, idToken) {
        const request = this.buildRequest();
        request.idToken = idToken;
        return signInWithIdp(auth, request);
    }
    /** @internal */
    _getReauthenticationResolver(auth) {
        const request = this.buildRequest();
        request.autoCreate = false;
        return signInWithIdp(auth, request);
    }
    /** {@inheritdoc AuthCredential.toJSON}  */
    toJSON() {
        return {
            signInMethod: this.signInMethod,
            providerId: this.providerId,
            pendingToken: this.pendingToken
        };
    }
    /**
     * Static method to deserialize a JSON representation of an object into an
     * {@link  AuthCredential}.
     *
     * @param json - Input can be either Object or the stringified representation of the object.
     * When string is provided, JSON.parse would be called first.
     *
     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
     */
    static fromJSON(json) {
        const obj = typeof json === 'string' ? JSON.parse(json) : json;
        const { providerId, signInMethod, pendingToken } = obj;
        if (!providerId ||
            !signInMethod ||
            !pendingToken ||
            providerId !== signInMethod) {
            return null;
        }
        return new SAMLAuthCredential(providerId, pendingToken);
    }
    /**
     * Helper static method to avoid exposing the constructor to end users.
     *
     * @internal
     */
    static _create(providerId, pendingToken) {
        return new SAMLAuthCredential(providerId, pendingToken);
    }
    buildRequest() {
        return {
            requestUri: IDP_REQUEST_URI,
            returnSecureToken: true,
            pendingToken: this.pendingToken
        };
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SAML_PROVIDER_PREFIX = 'saml.';
/**
 * An {@link AuthProvider} for SAML.
 *
 * @public
 */
class SAMLAuthProvider extends (/* unused pure expression or super */ null && (FederatedAuthProvider)) {
    /**
     * Constructor. The providerId must start with "saml."
     * @param providerId - SAML provider ID.
     */
    constructor(providerId) {
        _assert(providerId.startsWith(SAML_PROVIDER_PREFIX), "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        super(providerId);
    }
    /**
     * Generates an {@link AuthCredential} from a {@link UserCredential} after a
     * successful SAML flow completes.
     *
     * @remarks
     *
     * For example, to get an {@link AuthCredential}, you could write the
     * following code:
     *
     * ```js
     * const userCredential = await signInWithPopup(auth, samlProvider);
     * const credential = SAMLAuthProvider.credentialFromResult(userCredential);
     * ```
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return SAMLAuthProvider.samlCredentialFromTaggedObject((error.customData || {}));
    }
    /**
     * Creates an {@link AuthCredential} from a JSON string or a plain object.
     * @param json - A plain object or a JSON string
     */
    static credentialFromJSON(json) {
        const credential = SAMLAuthCredential.fromJSON(json);
        _assert(credential, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        return credential;
    }
    static samlCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse) {
            return null;
        }
        const { pendingToken, providerId } = tokenResponse;
        if (!pendingToken || !providerId) {
            return null;
        }
        try {
            return SAMLAuthCredential._create(providerId, pendingToken);
        }
        catch (e) {
            return null;
        }
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.TWITTER.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new TwitterAuthProvider();
 * // Start a sign in process for an unauthenticated user.
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Twitter Access Token and Secret.
 *   const credential = TwitterAuthProvider.credentialFromResult(result);
 *   const token = credential.accessToken;
 *   const secret = credential.secret;
 * }
 * ```
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new TwitterAuthProvider();
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a Twitter Access Token and Secret.
 * const credential = TwitterAuthProvider.credentialFromResult(result);
 * const token = credential.accessToken;
 * const secret = credential.secret;
 * ```
 *
 * @public
 */
class TwitterAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("twitter.com" /* ProviderId.TWITTER */);
    }
    /**
     * Creates a credential for Twitter.
     *
     * @param token - Twitter access token.
     * @param secret - Twitter secret.
     */
    static credential(token, secret) {
        return OAuthCredential._fromParams({
            providerId: TwitterAuthProvider.PROVIDER_ID,
            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,
            oauthToken: token,
            oauthTokenSecret: secret
        });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return TwitterAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return TwitterAuthProvider.credentialFromTaggedObject((error.customData || {}));
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse) {
            return null;
        }
        const { oauthAccessToken, oauthTokenSecret } = tokenResponse;
        if (!oauthAccessToken || !oauthTokenSecret) {
            return null;
        }
        try {
            return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);
        }
        catch (_a) {
            return null;
        }
    }
}
/** Always set to {@link SignInMethod}.TWITTER. */
TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = "twitter.com" /* SignInMethod.TWITTER */;
/** Always set to {@link ProviderId}.TWITTER. */
TwitterAuthProvider.PROVIDER_ID = "twitter.com" /* ProviderId.TWITTER */;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signUp(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signUp" /* Endpoint.SIGN_UP */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserCredentialImpl {
    constructor(params) {
        this.user = params.user;
        this.providerId = params.providerId;
        this._tokenResponse = params._tokenResponse;
        this.operationType = params.operationType;
    }
    static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {
        const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);
        const providerId = providerIdForResponse(idTokenResponse);
        const userCred = new UserCredentialImpl({
            user,
            providerId,
            _tokenResponse: idTokenResponse,
            operationType
        });
        return userCred;
    }
    static async _forOperation(user, operationType, response) {
        await user._updateTokensIfNecessary(response, /* reload */ true);
        const providerId = providerIdForResponse(response);
        return new UserCredentialImpl({
            user,
            providerId,
            _tokenResponse: response,
            operationType
        });
    }
}
function providerIdForResponse(response) {
    if (response.providerId) {
        return response.providerId;
    }
    if ('phoneNumber' in response) {
        return "phone" /* ProviderId.PHONE */;
    }
    return null;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Asynchronously signs in as an anonymous user.
 *
 * @remarks
 * If there is already an anonymous user signed in, that user will be returned; otherwise, a
 * new anonymous user identity will be created and returned.
 *
 * @param auth - The {@link Auth} instance.
 *
 * @public
 */
async function signInAnonymously(auth) {
    var _a;
    const authInternal = _castAuth(auth);
    await authInternal._initializationPromise;
    if ((_a = authInternal.currentUser) === null || _a === void 0 ? void 0 : _a.isAnonymous) {
        // If an anonymous user is already signed in, no need to sign them in again.
        return new UserCredentialImpl({
            user: authInternal.currentUser,
            providerId: null,
            operationType: "signIn" /* OperationType.SIGN_IN */
        });
    }
    const response = await signUp(authInternal, {
        returnSecureToken: true
    });
    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn" /* OperationType.SIGN_IN */, response, true);
    await authInternal._updateCurrentUser(userCredential.user);
    return userCredential;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiFactorError extends FirebaseError {
    constructor(auth, error, operationType, user) {
        var _a;
        super(error.code, error.message);
        this.operationType = operationType;
        this.user = user;
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, MultiFactorError.prototype);
        this.customData = {
            appName: auth.name,
            tenantId: (_a = auth.tenantId) !== null && _a !== void 0 ? _a : undefined,
            _serverResponse: error.customData._serverResponse,
            operationType
        };
    }
    static _fromErrorAndOperation(auth, error, operationType, user) {
        return new MultiFactorError(auth, error, operationType, user);
    }
}
function _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {
    const idTokenProvider = operationType === "reauthenticate" /* OperationType.REAUTHENTICATE */
        ? credential._getReauthenticationResolver(auth)
        : credential._getIdTokenResponse(auth);
    return idTokenProvider.catch(error => {
        if (error.code === `auth/${"multi-factor-auth-required" /* AuthErrorCode.MFA_REQUIRED */}`) {
            throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);
        }
        throw error;
    });
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Takes a set of UserInfo provider data and converts it to a set of names
 */
function providerDataAsNames(providerData) {
    return new Set(providerData
        .map(({ providerId }) => providerId)
        .filter(pid => !!pid));
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Unlinks a provider from a user account.
 *
 * @param user - The user.
 * @param providerId - The provider to unlink.
 *
 * @public
 */
async function unlink(user, providerId) {
    const userInternal = getModularInstance(user);
    await _assertLinkedStatus(true, userInternal, providerId);
    const { providerUserInfo } = await deleteLinkedAccounts(userInternal.auth, {
        idToken: await userInternal.getIdToken(),
        deleteProvider: [providerId]
    });
    const providersLeft = providerDataAsNames(providerUserInfo || []);
    userInternal.providerData = userInternal.providerData.filter(pd => providersLeft.has(pd.providerId));
    if (!providersLeft.has("phone" /* ProviderId.PHONE */)) {
        userInternal.phoneNumber = null;
    }
    await userInternal.auth._persistUserIfCurrent(userInternal);
    return userInternal;
}
async function _link$1(user, credential, bypassAuthState = false) {
    const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);
    return UserCredentialImpl._forOperation(user, "link" /* OperationType.LINK */, response);
}
async function _assertLinkedStatus(expected, user, provider) {
    await _reloadWithoutSaving(user);
    const providerIds = providerDataAsNames(user.providerData);
    const code = expected === false
        ? "provider-already-linked" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */
        : "no-such-provider" /* AuthErrorCode.NO_SUCH_PROVIDER */;
    _assert(providerIds.has(provider) === expected, user.auth, code);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _reauthenticate(user, credential, bypassAuthState = false) {
    const { auth } = user;
    const operationType = "reauthenticate" /* OperationType.REAUTHENTICATE */;
    try {
        const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);
        _assert(response.idToken, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const parsed = _parseToken(response.idToken);
        _assert(parsed, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const { sub: localId } = parsed;
        _assert(user.uid === localId, auth, "user-mismatch" /* AuthErrorCode.USER_MISMATCH */);
        return UserCredentialImpl._forOperation(user, operationType, response);
    }
    catch (e) {
        // Convert user deleted error into user mismatch
        if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${"user-not-found" /* AuthErrorCode.USER_DELETED */}`) {
            _fail(auth, "user-mismatch" /* AuthErrorCode.USER_MISMATCH */);
        }
        throw e;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _signInWithCredential(auth, credential, bypassAuthState = false) {
    const operationType = "signIn" /* OperationType.SIGN_IN */;
    const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);
    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);
    if (!bypassAuthState) {
        await auth._updateCurrentUser(userCredential.user);
    }
    return userCredential;
}
/**
 * Asynchronously signs in with the given credentials.
 *
 * @remarks
 * An {@link AuthProvider} can be used to generate the credential.
 *
 * @param auth - The {@link Auth} instance.
 * @param credential - The auth credential.
 *
 * @public
 */
async function signInWithCredential(auth, credential) {
    return _signInWithCredential(_castAuth(auth), credential);
}
/**
 * Links the user account with the given credentials.
 *
 * @remarks
 * An {@link AuthProvider} can be used to generate the credential.
 *
 * @param user - The user.
 * @param credential - The auth credential.
 *
 * @public
 */
async function linkWithCredential(user, credential) {
    const userInternal = getModularInstance(user);
    await _assertLinkedStatus(false, userInternal, credential.providerId);
    return _link$1(userInternal, credential);
}
/**
 * Re-authenticates a user using a fresh credential.
 *
 * @remarks
 * Use before operations such as {@link updatePassword} that require tokens from recent sign-in
 * attempts. This method can be used to recover from a `CREDENTIAL_TOO_OLD_LOGIN_AGAIN` error
 * or a `TOKEN_EXPIRED` error.
 *
 * @param user - The user.
 * @param credential - The auth credential.
 *
 * @public
 */
async function reauthenticateWithCredential(user, credential) {
    return _reauthenticate(getModularInstance(user), credential);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithCustomToken$1(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithCustomToken" /* Endpoint.SIGN_IN_WITH_CUSTOM_TOKEN */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Asynchronously signs in using a custom token.
 *
 * @remarks
 * Custom tokens are used to integrate Firebase Auth with existing auth systems, and must
 * be generated by an auth backend using the
 * {@link https://firebase.google.com/docs/reference/admin/node/admin.auth.Auth#createcustomtoken | createCustomToken}
 * method in the {@link https://firebase.google.com/docs/auth/admin | Admin SDK} .
 *
 * Fails with an error if the token is invalid, expired, or not accepted by the Firebase Auth service.
 *
 * @param auth - The {@link Auth} instance.
 * @param customToken - The custom token to sign in with.
 *
 * @public
 */
async function signInWithCustomToken(auth, customToken) {
    const authInternal = _castAuth(auth);
    const response = await signInWithCustomToken$1(authInternal, {
        token: customToken,
        returnSecureToken: true
    });
    const cred = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn" /* OperationType.SIGN_IN */, response);
    await authInternal._updateCurrentUser(cred.user);
    return cred;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiFactorInfoImpl {
    constructor(factorId, response) {
        this.factorId = factorId;
        this.uid = response.mfaEnrollmentId;
        this.enrollmentTime = new Date(response.enrolledAt).toUTCString();
        this.displayName = response.displayName;
    }
    static _fromServerResponse(auth, enrollment) {
        if ('phoneInfo' in enrollment) {
            return PhoneMultiFactorInfoImpl._fromServerResponse(auth, enrollment);
        }
        else if ('totpInfo' in enrollment) {
            return TotpMultiFactorInfoImpl._fromServerResponse(auth, enrollment);
        }
        return _fail(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    }
}
class PhoneMultiFactorInfoImpl extends (/* unused pure expression or super */ null && (MultiFactorInfoImpl)) {
    constructor(response) {
        super("phone" /* FactorId.PHONE */, response);
        this.phoneNumber = response.phoneInfo;
    }
    static _fromServerResponse(_auth, enrollment) {
        return new PhoneMultiFactorInfoImpl(enrollment);
    }
}
class TotpMultiFactorInfoImpl extends (/* unused pure expression or super */ null && (MultiFactorInfoImpl)) {
    constructor(response) {
        super("totp" /* FactorId.TOTP */, response);
    }
    static _fromServerResponse(_auth, enrollment) {
        return new TotpMultiFactorInfoImpl(enrollment);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {
    var _a;
    _assert(((_a = actionCodeSettings.url) === null || _a === void 0 ? void 0 : _a.length) > 0, auth, "invalid-continue-uri" /* AuthErrorCode.INVALID_CONTINUE_URI */);
    _assert(typeof actionCodeSettings.dynamicLinkDomain === 'undefined' ||
        actionCodeSettings.dynamicLinkDomain.length > 0, auth, "invalid-dynamic-link-domain" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */);
    request.continueUrl = actionCodeSettings.url;
    request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
    request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;
    if (actionCodeSettings.iOS) {
        _assert(actionCodeSettings.iOS.bundleId.length > 0, auth, "missing-ios-bundle-id" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */);
        request.iOSBundleId = actionCodeSettings.iOS.bundleId;
    }
    if (actionCodeSettings.android) {
        _assert(actionCodeSettings.android.packageName.length > 0, auth, "missing-android-pkg-name" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */);
        request.androidInstallApp = actionCodeSettings.android.installApp;
        request.androidMinimumVersionCode =
            actionCodeSettings.android.minimumVersion;
        request.androidPackageName = actionCodeSettings.android.packageName;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Sends a password reset email to the given email address.
 *
 * @remarks
 * To complete the password reset, call {@link confirmPasswordReset} with the code supplied in
 * the email sent to the user, along with the new password specified by the user.
 *
 * @example
 * ```javascript
 * const actionCodeSettings = {
 *   url: 'https://www.example.com/?email=user@example.com',
 *   iOS: {
 *      bundleId: 'com.example.ios'
 *   },
 *   android: {
 *     packageName: 'com.example.android',
 *     installApp: true,
 *     minimumVersion: '12'
 *   },
 *   handleCodeInApp: true
 * };
 * await sendPasswordResetEmail(auth, 'user@example.com', actionCodeSettings);
 * // Obtain code from user.
 * await confirmPasswordReset('user@example.com', code);
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param email - The user's email address.
 * @param actionCodeSettings - The {@link ActionCodeSettings}.
 *
 * @public
 */
async function sendPasswordResetEmail(auth, email, actionCodeSettings) {
    var _a;
    const authInternal = _castAuth(auth);
    const request = {
        requestType: "PASSWORD_RESET" /* ActionCodeOperation.PASSWORD_RESET */,
        email,
        clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */
    };
    if ((_a = authInternal._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.emailPasswordEnabled) {
        const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "getOobCode" /* RecaptchaActionName.GET_OOB_CODE */, true);
        if (actionCodeSettings) {
            _setActionCodeSettingsOnRequest(authInternal, requestWithRecaptcha, actionCodeSettings);
        }
        await sendPasswordResetEmail$1(authInternal, requestWithRecaptcha);
    }
    else {
        if (actionCodeSettings) {
            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);
        }
        await sendPasswordResetEmail$1(authInternal, request)
            .catch(async (error) => {
            if (error.code === `auth/${"missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {
                console.log('Password resets are protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the password reset flow.');
                const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "getOobCode" /* RecaptchaActionName.GET_OOB_CODE */, true);
                if (actionCodeSettings) {
                    _setActionCodeSettingsOnRequest(authInternal, requestWithRecaptcha, actionCodeSettings);
                }
                await sendPasswordResetEmail$1(authInternal, requestWithRecaptcha);
            }
            else {
                return Promise.reject(error);
            }
        });
    }
}
/**
 * Completes the password reset process, given a confirmation code and new password.
 *
 * @param auth - The {@link Auth} instance.
 * @param oobCode - A confirmation code sent to the user.
 * @param newPassword - The new password.
 *
 * @public
 */
async function confirmPasswordReset(auth, oobCode, newPassword) {
    await resetPassword(getModularInstance(auth), {
        oobCode,
        newPassword
    });
    // Do not return the email.
}
/**
 * Applies a verification code sent to the user by email or other out-of-band mechanism.
 *
 * @param auth - The {@link Auth} instance.
 * @param oobCode - A verification code sent to the user.
 *
 * @public
 */
async function applyActionCode(auth, oobCode) {
    await applyActionCode$1(getModularInstance(auth), { oobCode });
}
/**
 * Checks a verification code sent to the user by email or other out-of-band mechanism.
 *
 * @returns metadata about the code.
 *
 * @param auth - The {@link Auth} instance.
 * @param oobCode - A verification code sent to the user.
 *
 * @public
 */
async function checkActionCode(auth, oobCode) {
    const authModular = getModularInstance(auth);
    const response = await resetPassword(authModular, { oobCode });
    // Email could be empty only if the request type is EMAIL_SIGNIN or
    // VERIFY_AND_CHANGE_EMAIL.
    // New email should not be empty if the request type is
    // VERIFY_AND_CHANGE_EMAIL.
    // Multi-factor info could not be empty if the request type is
    // REVERT_SECOND_FACTOR_ADDITION.
    const operation = response.requestType;
    _assert(operation, authModular, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    switch (operation) {
        case "EMAIL_SIGNIN" /* ActionCodeOperation.EMAIL_SIGNIN */:
            break;
        case "VERIFY_AND_CHANGE_EMAIL" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */:
            _assert(response.newEmail, authModular, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
            break;
        case "REVERT_SECOND_FACTOR_ADDITION" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */:
            _assert(response.mfaInfo, authModular, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        // fall through
        default:
            _assert(response.email, authModular, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    }
    // The multi-factor info for revert second factor addition
    let multiFactorInfo = null;
    if (response.mfaInfo) {
        multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);
    }
    return {
        data: {
            email: (response.requestType === "VERIFY_AND_CHANGE_EMAIL" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */
                ? response.newEmail
                : response.email) || null,
            previousEmail: (response.requestType === "VERIFY_AND_CHANGE_EMAIL" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */
                ? response.email
                : response.newEmail) || null,
            multiFactorInfo
        },
        operation
    };
}
/**
 * Checks a password reset code sent to the user by email or other out-of-band mechanism.
 *
 * @returns the user's email address if valid.
 *
 * @param auth - The {@link Auth} instance.
 * @param code - A verification code sent to the user.
 *
 * @public
 */
async function verifyPasswordResetCode(auth, code) {
    const { data } = await checkActionCode(getModularInstance(auth), code);
    // Email should always be present since a code was sent to it
    return data.email;
}
/**
 * Creates a new user account associated with the specified email address and password.
 *
 * @remarks
 * On successful creation of the user account, this user will also be signed in to your application.
 *
 * User account creation can fail if the account already exists or the password is invalid.
 *
 * Note: The email address acts as a unique identifier for the user and enables an email-based
 * password reset. This function will create a new user account and set the initial user password.
 *
 * @param auth - The {@link Auth} instance.
 * @param email - The user's email address.
 * @param password - The user's chosen password.
 *
 * @public
 */
async function createUserWithEmailAndPassword(auth, email, password) {
    var _a;
    const authInternal = _castAuth(auth);
    const request = {
        returnSecureToken: true,
        email,
        password,
        clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */
    };
    let signUpResponse;
    if ((_a = authInternal._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.emailPasswordEnabled) {
        const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "signUpPassword" /* RecaptchaActionName.SIGN_UP_PASSWORD */);
        signUpResponse = signUp(authInternal, requestWithRecaptcha);
    }
    else {
        signUpResponse = signUp(authInternal, request).catch(async (error) => {
            if (error.code === `auth/${"missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {
                console.log('Sign-up is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-up flow.');
                const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "signUpPassword" /* RecaptchaActionName.SIGN_UP_PASSWORD */);
                return signUp(authInternal, requestWithRecaptcha);
            }
            else {
                return Promise.reject(error);
            }
        });
    }
    const response = await signUpResponse.catch(error => {
        return Promise.reject(error);
    });
    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn" /* OperationType.SIGN_IN */, response);
    await authInternal._updateCurrentUser(userCredential.user);
    return userCredential;
}
/**
 * Asynchronously signs in using an email and password.
 *
 * @remarks
 * Fails with an error if the email address and password do not match.
 *
 * Note: The user's password is NOT the password used to access the user's email account. The
 * email address serves as a unique identifier for the user, and the password is used to access
 * the user's account in your Firebase project. See also: {@link createUserWithEmailAndPassword}.
 *
 * @param auth - The {@link Auth} instance.
 * @param email - The users email address.
 * @param password - The users password.
 *
 * @public
 */
function signInWithEmailAndPassword(auth, email, password) {
    return signInWithCredential(getModularInstance(auth), EmailAuthProvider.credential(email, password));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Sends a sign-in email link to the user with the specified email.
 *
 * @remarks
 * The sign-in operation has to always be completed in the app unlike other out of band email
 * actions (password reset and email verifications). This is because, at the end of the flow,
 * the user is expected to be signed in and their Auth state persisted within the app.
 *
 * To complete sign in with the email link, call {@link signInWithEmailLink} with the email
 * address and the email link supplied in the email sent to the user.
 *
 * @example
 * ```javascript
 * const actionCodeSettings = {
 *   url: 'https://www.example.com/?email=user@example.com',
 *   iOS: {
 *      bundleId: 'com.example.ios'
 *   },
 *   android: {
 *     packageName: 'com.example.android',
 *     installApp: true,
 *     minimumVersion: '12'
 *   },
 *   handleCodeInApp: true
 * };
 * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);
 * // Obtain emailLink from the user.
 * if(isSignInWithEmailLink(auth, emailLink)) {
 *   await signInWithEmailLink(auth, 'user@example.com', emailLink);
 * }
 * ```
 *
 * @param authInternal - The {@link Auth} instance.
 * @param email - The user's email address.
 * @param actionCodeSettings - The {@link ActionCodeSettings}.
 *
 * @public
 */
async function sendSignInLinkToEmail(auth, email, actionCodeSettings) {
    var _a;
    const authInternal = _castAuth(auth);
    const request = {
        requestType: "EMAIL_SIGNIN" /* ActionCodeOperation.EMAIL_SIGNIN */,
        email,
        clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */
    };
    function setActionCodeSettings(request, actionCodeSettings) {
        _assert(actionCodeSettings.handleCodeInApp, authInternal, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        if (actionCodeSettings) {
            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);
        }
    }
    if ((_a = authInternal._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.emailPasswordEnabled) {
        const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "getOobCode" /* RecaptchaActionName.GET_OOB_CODE */, true);
        setActionCodeSettings(requestWithRecaptcha, actionCodeSettings);
        await sendSignInLinkToEmail$1(authInternal, requestWithRecaptcha);
    }
    else {
        setActionCodeSettings(request, actionCodeSettings);
        await sendSignInLinkToEmail$1(authInternal, request)
            .catch(async (error) => {
            if (error.code === `auth/${"missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {
                console.log('Email link sign-in is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-in flow.');
                const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "getOobCode" /* RecaptchaActionName.GET_OOB_CODE */, true);
                setActionCodeSettings(requestWithRecaptcha, actionCodeSettings);
                await sendSignInLinkToEmail$1(authInternal, requestWithRecaptcha);
            }
            else {
                return Promise.reject(error);
            }
        });
    }
}
/**
 * Checks if an incoming link is a sign-in with email link suitable for {@link signInWithEmailLink}.
 *
 * @param auth - The {@link Auth} instance.
 * @param emailLink - The link sent to the user's email address.
 *
 * @public
 */
function isSignInWithEmailLink(auth, emailLink) {
    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);
    return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === "EMAIL_SIGNIN" /* ActionCodeOperation.EMAIL_SIGNIN */;
}
/**
 * Asynchronously signs in using an email and sign-in email link.
 *
 * @remarks
 * If no link is passed, the link is inferred from the current URL.
 *
 * Fails with an error if the email address is invalid or OTP in email link expires.
 *
 * Note: Confirm the link is a sign-in email link before calling this method firebase.auth.Auth.isSignInWithEmailLink.
 *
 * @example
 * ```javascript
 * const actionCodeSettings = {
 *   url: 'https://www.example.com/?email=user@example.com',
 *   iOS: {
 *      bundleId: 'com.example.ios'
 *   },
 *   android: {
 *     packageName: 'com.example.android',
 *     installApp: true,
 *     minimumVersion: '12'
 *   },
 *   handleCodeInApp: true
 * };
 * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);
 * // Obtain emailLink from the user.
 * if(isSignInWithEmailLink(auth, emailLink)) {
 *   await signInWithEmailLink(auth, 'user@example.com', emailLink);
 * }
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param email - The user's email address.
 * @param emailLink - The link sent to the user's email address.
 *
 * @public
 */
async function signInWithEmailLink(auth, email, emailLink) {
    const authModular = getModularInstance(auth);
    const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());
    // Check if the tenant ID in the email link matches the tenant ID on Auth
    // instance.
    _assert(credential._tenantId === (authModular.tenantId || null), authModular, "tenant-id-mismatch" /* AuthErrorCode.TENANT_ID_MISMATCH */);
    return signInWithCredential(authModular, credential);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function createAuthUri(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:createAuthUri" /* Endpoint.CREATE_AUTH_URI */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Gets the list of possible sign in methods for the given email address.
 *
 * @remarks
 * This is useful to differentiate methods of sign-in for the same provider, eg.
 * {@link EmailAuthProvider} which has 2 methods of sign-in,
 * {@link SignInMethod}.EMAIL_PASSWORD and
 * {@link SignInMethod}.EMAIL_LINK.
 *
 * @param auth - The {@link Auth} instance.
 * @param email - The user's email address.
 *
 * @public
 */
async function fetchSignInMethodsForEmail(auth, email) {
    // createAuthUri returns an error if continue URI is not http or https.
    // For environments like Cordova, Chrome extensions, native frameworks, file
    // systems, etc, use http://localhost as continue URL.
    const continueUri = _isHttpOrHttps() ? _getCurrentUrl() : 'http://localhost';
    const request = {
        identifier: email,
        continueUri
    };
    const { signinMethods } = await createAuthUri(getModularInstance(auth), request);
    return signinMethods || [];
}
/**
 * Sends a verification email to a user.
 *
 * @remarks
 * The verification process is completed by calling {@link applyActionCode}.
 *
 * @example
 * ```javascript
 * const actionCodeSettings = {
 *   url: 'https://www.example.com/?email=user@example.com',
 *   iOS: {
 *      bundleId: 'com.example.ios'
 *   },
 *   android: {
 *     packageName: 'com.example.android',
 *     installApp: true,
 *     minimumVersion: '12'
 *   },
 *   handleCodeInApp: true
 * };
 * await sendEmailVerification(user, actionCodeSettings);
 * // Obtain code from the user.
 * await applyActionCode(auth, code);
 * ```
 *
 * @param user - The user.
 * @param actionCodeSettings - The {@link ActionCodeSettings}.
 *
 * @public
 */
async function sendEmailVerification(user, actionCodeSettings) {
    const userInternal = getModularInstance(user);
    const idToken = await user.getIdToken();
    const request = {
        requestType: "VERIFY_EMAIL" /* ActionCodeOperation.VERIFY_EMAIL */,
        idToken
    };
    if (actionCodeSettings) {
        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
    }
    const { email } = await sendEmailVerification$1(userInternal.auth, request);
    if (email !== user.email) {
        await user.reload();
    }
}
/**
 * Sends a verification email to a new email address.
 *
 * @remarks
 * The user's email will be updated to the new one after being verified.
 *
 * If you have a custom email action handler, you can complete the verification process by calling
 * {@link applyActionCode}.
 *
 * @example
 * ```javascript
 * const actionCodeSettings = {
 *   url: 'https://www.example.com/?email=user@example.com',
 *   iOS: {
 *      bundleId: 'com.example.ios'
 *   },
 *   android: {
 *     packageName: 'com.example.android',
 *     installApp: true,
 *     minimumVersion: '12'
 *   },
 *   handleCodeInApp: true
 * };
 * await verifyBeforeUpdateEmail(user, 'newemail@example.com', actionCodeSettings);
 * // Obtain code from the user.
 * await applyActionCode(auth, code);
 * ```
 *
 * @param user - The user.
 * @param newEmail - The new email address to be verified before update.
 * @param actionCodeSettings - The {@link ActionCodeSettings}.
 *
 * @public
 */
async function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {
    const userInternal = getModularInstance(user);
    const idToken = await user.getIdToken();
    const request = {
        requestType: "VERIFY_AND_CHANGE_EMAIL" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */,
        idToken,
        newEmail
    };
    if (actionCodeSettings) {
        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
    }
    const { email } = await verifyAndChangeEmail(userInternal.auth, request);
    if (email !== user.email) {
        // If the local copy of the email on user is outdated, reload the
        // user.
        await user.reload();
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function updateProfile$1(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:update" /* Endpoint.SET_ACCOUNT_INFO */, request);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Updates a user's profile data.
 *
 * @param user - The user.
 * @param profile - The profile's `displayName` and `photoURL` to update.
 *
 * @public
 */
async function updateProfile(user, { displayName, photoURL: photoUrl }) {
    if (displayName === undefined && photoUrl === undefined) {
        return;
    }
    const userInternal = getModularInstance(user);
    const idToken = await userInternal.getIdToken();
    const profileRequest = {
        idToken,
        displayName,
        photoUrl,
        returnSecureToken: true
    };
    const response = await _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest));
    userInternal.displayName = response.displayName || null;
    userInternal.photoURL = response.photoUrl || null;
    // Update the password provider as well
    const passwordProvider = userInternal.providerData.find(({ providerId }) => providerId === "password" /* ProviderId.PASSWORD */);
    if (passwordProvider) {
        passwordProvider.displayName = userInternal.displayName;
        passwordProvider.photoURL = userInternal.photoURL;
    }
    await userInternal._updateTokensIfNecessary(response);
}
/**
 * Updates the user's email address.
 *
 * @remarks
 * An email will be sent to the original email address (if it was set) that allows to revoke the
 * email address change, in order to protect them from account hijacking.
 *
 * Important: this is a security sensitive operation that requires the user to have recently signed
 * in. If this requirement isn't met, ask the user to authenticate again and then call
 * {@link reauthenticateWithCredential}.
 *
 * @param user - The user.
 * @param newEmail - The new email address.
 *
 * @public
 */
function updateEmail(user, newEmail) {
    return updateEmailOrPassword(getModularInstance(user), newEmail, null);
}
/**
 * Updates the user's password.
 *
 * @remarks
 * Important: this is a security sensitive operation that requires the user to have recently signed
 * in. If this requirement isn't met, ask the user to authenticate again and then call
 * {@link reauthenticateWithCredential}.
 *
 * @param user - The user.
 * @param newPassword - The new password.
 *
 * @public
 */
function updatePassword(user, newPassword) {
    return updateEmailOrPassword(getModularInstance(user), null, newPassword);
}
async function updateEmailOrPassword(user, email, password) {
    const { auth } = user;
    const idToken = await user.getIdToken();
    const request = {
        idToken,
        returnSecureToken: true
    };
    if (email) {
        request.email = email;
    }
    if (password) {
        request.password = password;
    }
    const response = await _logoutIfInvalidated(user, updateEmailPassword(auth, request));
    await user._updateTokensIfNecessary(response, /* reload */ true);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Parse the `AdditionalUserInfo` from the ID token response.
 *
 */
function _fromIdTokenResponse(idTokenResponse) {
    var _a, _b;
    if (!idTokenResponse) {
        return null;
    }
    const { providerId } = idTokenResponse;
    const profile = idTokenResponse.rawUserInfo
        ? JSON.parse(idTokenResponse.rawUserInfo)
        : {};
    const isNewUser = idTokenResponse.isNewUser ||
        idTokenResponse.kind === "identitytoolkit#SignupNewUserResponse" /* IdTokenResponseKind.SignupNewUser */;
    if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {
        const signInProvider = (_b = (_a = _parseToken(idTokenResponse.idToken)) === null || _a === void 0 ? void 0 : _a.firebase) === null || _b === void 0 ? void 0 : _b['sign_in_provider'];
        if (signInProvider) {
            const filteredProviderId = signInProvider !== "anonymous" /* ProviderId.ANONYMOUS */ &&
                signInProvider !== "custom" /* ProviderId.CUSTOM */
                ? signInProvider
                : null;
            // Uses generic class in accordance with the legacy SDK.
            return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);
        }
    }
    if (!providerId) {
        return null;
    }
    switch (providerId) {
        case "facebook.com" /* ProviderId.FACEBOOK */:
            return new FacebookAdditionalUserInfo(isNewUser, profile);
        case "github.com" /* ProviderId.GITHUB */:
            return new GithubAdditionalUserInfo(isNewUser, profile);
        case "google.com" /* ProviderId.GOOGLE */:
            return new GoogleAdditionalUserInfo(isNewUser, profile);
        case "twitter.com" /* ProviderId.TWITTER */:
            return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);
        case "custom" /* ProviderId.CUSTOM */:
        case "anonymous" /* ProviderId.ANONYMOUS */:
            return new GenericAdditionalUserInfo(isNewUser, null);
        default:
            return new GenericAdditionalUserInfo(isNewUser, providerId, profile);
    }
}
class GenericAdditionalUserInfo {
    constructor(isNewUser, providerId, profile = {}) {
        this.isNewUser = isNewUser;
        this.providerId = providerId;
        this.profile = profile;
    }
}
class FederatedAdditionalUserInfoWithUsername extends (/* unused pure expression or super */ null && (GenericAdditionalUserInfo)) {
    constructor(isNewUser, providerId, profile, username) {
        super(isNewUser, providerId, profile);
        this.username = username;
    }
}
class FacebookAdditionalUserInfo extends (/* unused pure expression or super */ null && (GenericAdditionalUserInfo)) {
    constructor(isNewUser, profile) {
        super(isNewUser, "facebook.com" /* ProviderId.FACEBOOK */, profile);
    }
}
class GithubAdditionalUserInfo extends (/* unused pure expression or super */ null && (FederatedAdditionalUserInfoWithUsername)) {
    constructor(isNewUser, profile) {
        super(isNewUser, "github.com" /* ProviderId.GITHUB */, profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === 'string' ? profile === null || profile === void 0 ? void 0 : profile.login : null);
    }
}
class GoogleAdditionalUserInfo extends (/* unused pure expression or super */ null && (GenericAdditionalUserInfo)) {
    constructor(isNewUser, profile) {
        super(isNewUser, "google.com" /* ProviderId.GOOGLE */, profile);
    }
}
class TwitterAdditionalUserInfo extends (/* unused pure expression or super */ null && (FederatedAdditionalUserInfoWithUsername)) {
    constructor(isNewUser, profile, screenName) {
        super(isNewUser, "twitter.com" /* ProviderId.TWITTER */, profile, screenName);
    }
}
/**
 * Extracts provider specific {@link AdditionalUserInfo} for the given credential.
 *
 * @param userCredential - The user credential.
 *
 * @public
 */
function getAdditionalUserInfo(userCredential) {
    const { user, _tokenResponse } = userCredential;
    if (user.isAnonymous && !_tokenResponse) {
        // Handle the special case where signInAnonymously() gets called twice.
        // No network call is made so there's nothing to actually fill this in
        return {
            providerId: null,
            isNewUser: false,
            profile: null
        };
    }
    return _fromIdTokenResponse(_tokenResponse);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Non-optional auth methods.
/**
 * Changes the type of persistence on the {@link Auth} instance for the currently saved
 * `Auth` session and applies this type of persistence for future sign-in requests, including
 * sign-in with redirect requests.
 *
 * @remarks
 * This makes it easy for a user signing in to specify whether their session should be
 * remembered or not. It also makes it easier to never persist the `Auth` state for applications
 * that are shared by other users or have sensitive data.
 *
 * @example
 * ```javascript
 * setPersistence(auth, browserSessionPersistence);
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param persistence - The {@link Persistence} to use.
 * @returns A `Promise` that resolves once the persistence change has completed
 *
 * @public
 */
function setPersistence(auth, persistence) {
    return getModularInstance(auth).setPersistence(persistence);
}
/**
 * Loads the reCAPTCHA configuration into the `Auth` instance.
 *
 * @remarks
 * This will load the reCAPTCHA config, which indicates whether the reCAPTCHA
 * verification flow should be triggered for each auth provider, into the
 * current Auth session.
 *
 * If initializeRecaptchaConfig() is not invoked, the auth flow will always start
 * without reCAPTCHA verification. If the provider is configured to require reCAPTCHA
 * verification, the SDK will transparently load the reCAPTCHA config and restart the
 * auth flows.
 *
 * Thus, by calling this optional method, you will reduce the latency of future auth flows.
 * Loading the reCAPTCHA config early will also enhance the signal collected by reCAPTCHA.
 *
 * @example
 * ```javascript
 * initializeRecaptchaConfig(auth);
 * ```
 *
 * @param auth - The {@link Auth} instance.
 *
 * @public
 */
function initializeRecaptchaConfig(auth) {
    const authInternal = _castAuth(auth);
    return authInternal.initializeRecaptchaConfig();
}
/**
 * Adds an observer for changes to the signed-in user's ID token.
 *
 * @remarks
 * This includes sign-in, sign-out, and token refresh events.
 * This will not be triggered automatically upon ID token expiration. Use {@link User.getIdToken} to refresh the ID token.
 *
 * @param auth - The {@link Auth} instance.
 * @param nextOrObserver - callback triggered on change.
 * @param error - Deprecated. This callback is never triggered. Errors
 * on signing in/out can be caught in promises returned from
 * sign-in/sign-out functions.
 * @param completed - Deprecated. This callback is never triggered.
 *
 * @public
 */
function onIdTokenChanged(auth, nextOrObserver, error, completed) {
    return index_esm2017_getModularInstance(auth).onIdTokenChanged(nextOrObserver, error, completed);
}
/**
 * Adds a blocking callback that runs before an auth state change
 * sets a new user.
 *
 * @param auth - The {@link Auth} instance.
 * @param callback - callback triggered before new user value is set.
 *   If this throws, it blocks the user from being set.
 * @param onAbort - callback triggered if a later `beforeAuthStateChanged()`
 *   callback throws, allowing you to undo any side effects.
 */
function beforeAuthStateChanged(auth, callback, onAbort) {
    return index_esm2017_getModularInstance(auth).beforeAuthStateChanged(callback, onAbort);
}
/**
 * Adds an observer for changes to the user's sign-in state.
 *
 * @remarks
 * To keep the old behavior, see {@link onIdTokenChanged}.
 *
 * @param auth - The {@link Auth} instance.
 * @param nextOrObserver - callback triggered on change.
 * @param error - Deprecated. This callback is never triggered. Errors
 * on signing in/out can be caught in promises returned from
 * sign-in/sign-out functions.
 * @param completed - Deprecated. This callback is never triggered.
 *
 * @public
 */
function onAuthStateChanged(auth, nextOrObserver, error, completed) {
    return getModularInstance(auth).onAuthStateChanged(nextOrObserver, error, completed);
}
/**
 * Sets the current language to the default device/browser preference.
 *
 * @param auth - The {@link Auth} instance.
 *
 * @public
 */
function useDeviceLanguage(auth) {
    getModularInstance(auth).useDeviceLanguage();
}
/**
 * Asynchronously sets the provided user as {@link Auth.currentUser} on the
 * {@link Auth} instance.
 *
 * @remarks
 * A new instance copy of the user provided will be made and set as currentUser.
 *
 * This will trigger {@link onAuthStateChanged} and {@link onIdTokenChanged} listeners
 * like other sign in methods.
 *
 * The operation fails with an error if the user to be updated belongs to a different Firebase
 * project.
 *
 * @param auth - The {@link Auth} instance.
 * @param user - The new {@link User}.
 *
 * @public
 */
function updateCurrentUser(auth, user) {
    return getModularInstance(auth).updateCurrentUser(user);
}
/**
 * Signs out the current user.
 *
 * @param auth - The {@link Auth} instance.
 *
 * @public
 */
function signOut(auth) {
    return getModularInstance(auth).signOut();
}
/**
 * Deletes and signs out the user.
 *
 * @remarks
 * Important: this is a security-sensitive operation that requires the user to have recently
 * signed in. If this requirement isn't met, ask the user to authenticate again and then call
 * {@link reauthenticateWithCredential}.
 *
 * @param user - The user.
 *
 * @public
 */
async function deleteUser(user) {
    return getModularInstance(user).delete();
}

class MultiFactorSessionImpl {
    constructor(type, credential, auth) {
        this.type = type;
        this.credential = credential;
        this.auth = auth;
    }
    static _fromIdtoken(idToken, auth) {
        return new MultiFactorSessionImpl("enroll" /* MultiFactorSessionType.ENROLL */, idToken, auth);
    }
    static _fromMfaPendingCredential(mfaPendingCredential) {
        return new MultiFactorSessionImpl("signin" /* MultiFactorSessionType.SIGN_IN */, mfaPendingCredential);
    }
    toJSON() {
        const key = this.type === "enroll" /* MultiFactorSessionType.ENROLL */
            ? 'idToken'
            : 'pendingCredential';
        return {
            multiFactorSession: {
                [key]: this.credential
            }
        };
    }
    static fromJSON(obj) {
        var _a, _b;
        if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {
            if ((_a = obj.multiFactorSession) === null || _a === void 0 ? void 0 : _a.pendingCredential) {
                return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);
            }
            else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {
                return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);
            }
        }
        return null;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiFactorResolverImpl {
    constructor(session, hints, signInResolver) {
        this.session = session;
        this.hints = hints;
        this.signInResolver = signInResolver;
    }
    /** @internal */
    static _fromError(authExtern, error) {
        const auth = _castAuth(authExtern);
        const serverResponse = error.customData._serverResponse;
        const hints = (serverResponse.mfaInfo || []).map(enrollment => MultiFactorInfoImpl._fromServerResponse(auth, enrollment));
        _assert(serverResponse.mfaPendingCredential, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);
        return new MultiFactorResolverImpl(session, hints, async (assertion) => {
            const mfaResponse = await assertion._process(auth, session);
            // Clear out the unneeded fields from the old login response
            delete serverResponse.mfaInfo;
            delete serverResponse.mfaPendingCredential;
            // Use in the new token & refresh token in the old response
            const idTokenResponse = Object.assign(Object.assign({}, serverResponse), { idToken: mfaResponse.idToken, refreshToken: mfaResponse.refreshToken });
            // TODO: we should collapse this switch statement into UserCredentialImpl._forOperation and have it support the SIGN_IN case
            switch (error.operationType) {
                case "signIn" /* OperationType.SIGN_IN */:
                    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse);
                    await auth._updateCurrentUser(userCredential.user);
                    return userCredential;
                case "reauthenticate" /* OperationType.REAUTHENTICATE */:
                    _assert(error.user, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                    return UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse);
                default:
                    _fail(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
            }
        });
    }
    async resolveSignIn(assertionExtern) {
        const assertion = assertionExtern;
        return this.signInResolver(assertion);
    }
}
/**
 * Provides a {@link MultiFactorResolver} suitable for completion of a
 * multi-factor flow.
 *
 * @param auth - The {@link Auth} instance.
 * @param error - The {@link MultiFactorError} raised during a sign-in, or
 * reauthentication operation.
 *
 * @public
 */
function getMultiFactorResolver(auth, error) {
    var _a;
    const authModular = getModularInstance(auth);
    const errorInternal = error;
    _assert(error.customData.operationType, authModular, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
    _assert((_a = errorInternal.customData._serverResponse) === null || _a === void 0 ? void 0 : _a.mfaPendingCredential, authModular, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
    return MultiFactorResolverImpl._fromError(authModular, errorInternal);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function startEnrollPhoneMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaEnrollment:start" /* Endpoint.START_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));
}
function finalizeEnrollPhoneMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaEnrollment:finalize" /* Endpoint.FINALIZE_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));
}
function startEnrollTotpMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaEnrollment:start" /* Endpoint.START_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));
}
function finalizeEnrollTotpMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaEnrollment:finalize" /* Endpoint.FINALIZE_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));
}
function withdrawMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaEnrollment:withdraw" /* Endpoint.WITHDRAW_MFA */, _addTidIfNecessary(auth, request));
}

class MultiFactorUserImpl {
    constructor(user) {
        this.user = user;
        this.enrolledFactors = [];
        user._onReload(userInfo => {
            if (userInfo.mfaInfo) {
                this.enrolledFactors = userInfo.mfaInfo.map(enrollment => MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment));
            }
        });
    }
    static _fromUser(user) {
        return new MultiFactorUserImpl(user);
    }
    async getSession() {
        return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken(), this.user.auth);
    }
    async enroll(assertionExtern, displayName) {
        const assertion = assertionExtern;
        const session = (await this.getSession());
        const finalizeMfaResponse = await _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName));
        // New tokens will be issued after enrollment of the new second factors.
        // They need to be updated on the user.
        await this.user._updateTokensIfNecessary(finalizeMfaResponse);
        // The user needs to be reloaded to get the new multi-factor information
        // from server. USER_RELOADED event will be triggered and `enrolledFactors`
        // will be updated.
        return this.user.reload();
    }
    async unenroll(infoOrUid) {
        const mfaEnrollmentId = typeof infoOrUid === 'string' ? infoOrUid : infoOrUid.uid;
        const idToken = await this.user.getIdToken();
        try {
            const idTokenResponse = await _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {
                idToken,
                mfaEnrollmentId
            }));
            // Remove the second factor from the user's list.
            this.enrolledFactors = this.enrolledFactors.filter(({ uid }) => uid !== mfaEnrollmentId);
            // Depending on whether the backend decided to revoke the user's session,
            // the tokenResponse may be empty. If the tokens were not updated (and they
            // are now invalid), reloading the user will discover this and invalidate
            // the user's state accordingly.
            await this.user._updateTokensIfNecessary(idTokenResponse);
            await this.user.reload();
        }
        catch (e) {
            throw e;
        }
    }
}
const multiFactorUserCache = new WeakMap();
/**
 * The {@link MultiFactorUser} corresponding to the user.
 *
 * @remarks
 * This is used to access all multi-factor properties and operations related to the user.
 *
 * @param user - The user.
 *
 * @public
 */
function multiFactor(user) {
    const userModular = getModularInstance(user);
    if (!multiFactorUserCache.has(userModular)) {
        multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));
    }
    return multiFactorUserCache.get(userModular);
}

const STORAGE_AVAILABLE_KEY = '__sak';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// There are two different browser persistence types: local and session.
// Both have the same implementation but use a different underlying storage
// object.
class BrowserPersistenceClass {
    constructor(storageRetriever, type) {
        this.storageRetriever = storageRetriever;
        this.type = type;
    }
    _isAvailable() {
        try {
            if (!this.storage) {
                return Promise.resolve(false);
            }
            this.storage.setItem(STORAGE_AVAILABLE_KEY, '1');
            this.storage.removeItem(STORAGE_AVAILABLE_KEY);
            return Promise.resolve(true);
        }
        catch (_a) {
            return Promise.resolve(false);
        }
    }
    _set(key, value) {
        this.storage.setItem(key, JSON.stringify(value));
        return Promise.resolve();
    }
    _get(key) {
        const json = this.storage.getItem(key);
        return Promise.resolve(json ? JSON.parse(json) : null);
    }
    _remove(key) {
        this.storage.removeItem(key);
        return Promise.resolve();
    }
    get storage() {
        return this.storageRetriever();
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _iframeCannotSyncWebStorage() {
    const ua = index_esm2017_getUA();
    return _isSafari(ua) || _isIOS(ua);
}
// The polling period in case events are not supported
const _POLLING_INTERVAL_MS$1 = 1000;
// The IE 10 localStorage cross tab synchronization delay in milliseconds
const IE10_LOCAL_STORAGE_SYNC_DELAY = 10;
class BrowserLocalPersistence extends BrowserPersistenceClass {
    constructor() {
        super(() => window.localStorage, "LOCAL" /* PersistenceType.LOCAL */);
        this.boundEventHandler = (event, poll) => this.onStorageEvent(event, poll);
        this.listeners = {};
        this.localCache = {};
        // setTimeout return value is platform specific
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.pollTimer = null;
        // Safari or iOS browser and embedded in an iframe.
        this.safariLocalStorageNotSynced = _iframeCannotSyncWebStorage() && _isIframe();
        // Whether to use polling instead of depending on window events
        this.fallbackToPolling = _isMobileBrowser();
        this._shouldAllowMigration = true;
    }
    forAllChangedKeys(cb) {
        // Check all keys with listeners on them.
        for (const key of Object.keys(this.listeners)) {
            // Get value from localStorage.
            const newValue = this.storage.getItem(key);
            const oldValue = this.localCache[key];
            // If local map value does not match, trigger listener with storage event.
            // Differentiate this simulated event from the real storage event.
            if (newValue !== oldValue) {
                cb(key, oldValue, newValue);
            }
        }
    }
    onStorageEvent(event, poll = false) {
        // Key would be null in some situations, like when localStorage is cleared
        if (!event.key) {
            this.forAllChangedKeys((key, _oldValue, newValue) => {
                this.notifyListeners(key, newValue);
            });
            return;
        }
        const key = event.key;
        // Check the mechanism how this event was detected.
        // The first event will dictate the mechanism to be used.
        if (poll) {
            // Environment detects storage changes via polling.
            // Remove storage event listener to prevent possible event duplication.
            this.detachListener();
        }
        else {
            // Environment detects storage changes via storage event listener.
            // Remove polling listener to prevent possible event duplication.
            this.stopPolling();
        }
        // Safari embedded iframe. Storage event will trigger with the delta
        // changes but no changes will be applied to the iframe localStorage.
        if (this.safariLocalStorageNotSynced) {
            // Get current iframe page value.
            const storedValue = this.storage.getItem(key);
            // Value not synchronized, synchronize manually.
            if (event.newValue !== storedValue) {
                if (event.newValue !== null) {
                    // Value changed from current value.
                    this.storage.setItem(key, event.newValue);
                }
                else {
                    // Current value deleted.
                    this.storage.removeItem(key);
                }
            }
            else if (this.localCache[key] === event.newValue && !poll) {
                // Already detected and processed, do not trigger listeners again.
                return;
            }
        }
        const triggerListeners = () => {
            // Keep local map up to date in case storage event is triggered before
            // poll.
            const storedValue = this.storage.getItem(key);
            if (!poll && this.localCache[key] === storedValue) {
                // Real storage event which has already been detected, do nothing.
                // This seems to trigger in some IE browsers for some reason.
                return;
            }
            this.notifyListeners(key, storedValue);
        };
        const storedValue = this.storage.getItem(key);
        if (_isIE10() &&
            storedValue !== event.newValue &&
            event.newValue !== event.oldValue) {
            // IE 10 has this weird bug where a storage event would trigger with the
            // correct key, oldValue and newValue but localStorage.getItem(key) does
            // not yield the updated value until a few milliseconds. This ensures
            // this recovers from that situation.
            setTimeout(triggerListeners, IE10_LOCAL_STORAGE_SYNC_DELAY);
        }
        else {
            triggerListeners();
        }
    }
    notifyListeners(key, value) {
        this.localCache[key] = value;
        const listeners = this.listeners[key];
        if (listeners) {
            for (const listener of Array.from(listeners)) {
                listener(value ? JSON.parse(value) : value);
            }
        }
    }
    startPolling() {
        this.stopPolling();
        this.pollTimer = setInterval(() => {
            this.forAllChangedKeys((key, oldValue, newValue) => {
                this.onStorageEvent(new StorageEvent('storage', {
                    key,
                    oldValue,
                    newValue
                }), 
                /* poll */ true);
            });
        }, _POLLING_INTERVAL_MS$1);
    }
    stopPolling() {
        if (this.pollTimer) {
            clearInterval(this.pollTimer);
            this.pollTimer = null;
        }
    }
    attachListener() {
        window.addEventListener('storage', this.boundEventHandler);
    }
    detachListener() {
        window.removeEventListener('storage', this.boundEventHandler);
    }
    _addListener(key, listener) {
        if (Object.keys(this.listeners).length === 0) {
            // Whether browser can detect storage event when it had already been pushed to the background.
            // This may happen in some mobile browsers. A localStorage change in the foreground window
            // will not be detected in the background window via the storage event.
            // This was detected in iOS 7.x mobile browsers
            if (this.fallbackToPolling) {
                this.startPolling();
            }
            else {
                this.attachListener();
            }
        }
        if (!this.listeners[key]) {
            this.listeners[key] = new Set();
            // Populate the cache to avoid spuriously triggering on first poll.
            this.localCache[key] = this.storage.getItem(key);
        }
        this.listeners[key].add(listener);
    }
    _removeListener(key, listener) {
        if (this.listeners[key]) {
            this.listeners[key].delete(listener);
            if (this.listeners[key].size === 0) {
                delete this.listeners[key];
            }
        }
        if (Object.keys(this.listeners).length === 0) {
            this.detachListener();
            this.stopPolling();
        }
    }
    // Update local cache on base operations:
    async _set(key, value) {
        await super._set(key, value);
        this.localCache[key] = JSON.stringify(value);
    }
    async _get(key) {
        const value = await super._get(key);
        this.localCache[key] = JSON.stringify(value);
        return value;
    }
    async _remove(key) {
        await super._remove(key);
        delete this.localCache[key];
    }
}
BrowserLocalPersistence.type = 'LOCAL';
/**
 * An implementation of {@link Persistence} of type `LOCAL` using `localStorage`
 * for the underlying storage.
 *
 * @public
 */
const browserLocalPersistence = BrowserLocalPersistence;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserSessionPersistence extends BrowserPersistenceClass {
    constructor() {
        super(() => window.sessionStorage, "SESSION" /* PersistenceType.SESSION */);
    }
    _addListener(_key, _listener) {
        // Listeners are not supported for session storage since it cannot be shared across windows
        return;
    }
    _removeListener(_key, _listener) {
        // Listeners are not supported for session storage since it cannot be shared across windows
        return;
    }
}
BrowserSessionPersistence.type = 'SESSION';
/**
 * An implementation of {@link Persistence} of `SESSION` using `sessionStorage`
 * for the underlying storage.
 *
 * @public
 */
const browserSessionPersistence = BrowserSessionPersistence;

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Shim for Promise.allSettled, note the slightly different format of `fulfilled` vs `status`.
 *
 * @param promises - Array of promises to wait on.
 */
function _allSettled(promises) {
    return Promise.all(promises.map(async (promise) => {
        try {
            const value = await promise;
            return {
                fulfilled: true,
                value
            };
        }
        catch (reason) {
            return {
                fulfilled: false,
                reason
            };
        }
    }));
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface class for receiving messages.
 *
 */
class Receiver {
    constructor(eventTarget) {
        this.eventTarget = eventTarget;
        this.handlersMap = {};
        this.boundEventHandler = this.handleEvent.bind(this);
    }
    /**
     * Obtain an instance of a Receiver for a given event target, if none exists it will be created.
     *
     * @param eventTarget - An event target (such as window or self) through which the underlying
     * messages will be received.
     */
    static _getInstance(eventTarget) {
        // The results are stored in an array since objects can't be keys for other
        // objects. In addition, setting a unique property on an event target as a
        // hash map key may not be allowed due to CORS restrictions.
        const existingInstance = this.receivers.find(receiver => receiver.isListeningto(eventTarget));
        if (existingInstance) {
            return existingInstance;
        }
        const newInstance = new Receiver(eventTarget);
        this.receivers.push(newInstance);
        return newInstance;
    }
    isListeningto(eventTarget) {
        return this.eventTarget === eventTarget;
    }
    /**
     * Fans out a MessageEvent to the appropriate listeners.
     *
     * @remarks
     * Sends an {@link Status.ACK} upon receipt and a {@link Status.DONE} once all handlers have
     * finished processing.
     *
     * @param event - The MessageEvent.
     *
     */
    async handleEvent(event) {
        const messageEvent = event;
        const { eventId, eventType, data } = messageEvent.data;
        const handlers = this.handlersMap[eventType];
        if (!(handlers === null || handlers === void 0 ? void 0 : handlers.size)) {
            return;
        }
        messageEvent.ports[0].postMessage({
            status: "ack" /* _Status.ACK */,
            eventId,
            eventType
        });
        const promises = Array.from(handlers).map(async (handler) => handler(messageEvent.origin, data));
        const response = await _allSettled(promises);
        messageEvent.ports[0].postMessage({
            status: "done" /* _Status.DONE */,
            eventId,
            eventType,
            response
        });
    }
    /**
     * Subscribe an event handler for a particular event.
     *
     * @param eventType - Event name to subscribe to.
     * @param eventHandler - The event handler which should receive the events.
     *
     */
    _subscribe(eventType, eventHandler) {
        if (Object.keys(this.handlersMap).length === 0) {
            this.eventTarget.addEventListener('message', this.boundEventHandler);
        }
        if (!this.handlersMap[eventType]) {
            this.handlersMap[eventType] = new Set();
        }
        this.handlersMap[eventType].add(eventHandler);
    }
    /**
     * Unsubscribe an event handler from a particular event.
     *
     * @param eventType - Event name to unsubscribe from.
     * @param eventHandler - Optinoal event handler, if none provided, unsubscribe all handlers on this event.
     *
     */
    _unsubscribe(eventType, eventHandler) {
        if (this.handlersMap[eventType] && eventHandler) {
            this.handlersMap[eventType].delete(eventHandler);
        }
        if (!eventHandler || this.handlersMap[eventType].size === 0) {
            delete this.handlersMap[eventType];
        }
        if (Object.keys(this.handlersMap).length === 0) {
            this.eventTarget.removeEventListener('message', this.boundEventHandler);
        }
    }
}
Receiver.receivers = [];

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _generateEventId(prefix = '', digits = 10) {
    let random = '';
    for (let i = 0; i < digits; i++) {
        random += Math.floor(Math.random() * 10);
    }
    return prefix + random;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface for sending messages and waiting for a completion response.
 *
 */
class Sender {
    constructor(target) {
        this.target = target;
        this.handlers = new Set();
    }
    /**
     * Unsubscribe the handler and remove it from our tracking Set.
     *
     * @param handler - The handler to unsubscribe.
     */
    removeMessageHandler(handler) {
        if (handler.messageChannel) {
            handler.messageChannel.port1.removeEventListener('message', handler.onMessage);
            handler.messageChannel.port1.close();
        }
        this.handlers.delete(handler);
    }
    /**
     * Send a message to the Receiver located at {@link target}.
     *
     * @remarks
     * We'll first wait a bit for an ACK , if we get one we will wait significantly longer until the
     * receiver has had a chance to fully process the event.
     *
     * @param eventType - Type of event to send.
     * @param data - The payload of the event.
     * @param timeout - Timeout for waiting on an ACK from the receiver.
     *
     * @returns An array of settled promises from all the handlers that were listening on the receiver.
     */
    async _send(eventType, data, timeout = 50 /* _TimeoutDuration.ACK */) {
        const messageChannel = typeof MessageChannel !== 'undefined' ? new MessageChannel() : null;
        if (!messageChannel) {
            throw new Error("connection_unavailable" /* _MessageError.CONNECTION_UNAVAILABLE */);
        }
        // Node timers and browser timers return fundamentally different types.
        // We don't actually care what the value is but TS won't accept unknown and
        // we can't cast properly in both environments.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let completionTimer;
        let handler;
        return new Promise((resolve, reject) => {
            const eventId = _generateEventId('', 20);
            messageChannel.port1.start();
            const ackTimer = setTimeout(() => {
                reject(new Error("unsupported_event" /* _MessageError.UNSUPPORTED_EVENT */));
            }, timeout);
            handler = {
                messageChannel,
                onMessage(event) {
                    const messageEvent = event;
                    if (messageEvent.data.eventId !== eventId) {
                        return;
                    }
                    switch (messageEvent.data.status) {
                        case "ack" /* _Status.ACK */:
                            // The receiver should ACK first.
                            clearTimeout(ackTimer);
                            completionTimer = setTimeout(() => {
                                reject(new Error("timeout" /* _MessageError.TIMEOUT */));
                            }, 3000 /* _TimeoutDuration.COMPLETION */);
                            break;
                        case "done" /* _Status.DONE */:
                            // Once the receiver's handlers are finished we will get the results.
                            clearTimeout(completionTimer);
                            resolve(messageEvent.data.response);
                            break;
                        default:
                            clearTimeout(ackTimer);
                            clearTimeout(completionTimer);
                            reject(new Error("invalid_response" /* _MessageError.INVALID_RESPONSE */));
                            break;
                    }
                }
            };
            this.handlers.add(handler);
            messageChannel.port1.addEventListener('message', handler.onMessage);
            this.target.postMessage({
                eventType,
                eventId,
                data
            }, [messageChannel.port2]);
        }).finally(() => {
            if (handler) {
                this.removeMessageHandler(handler);
            }
        });
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Lazy accessor for window, since the compat layer won't tree shake this out,
 * we need to make sure not to mess with window unless we have to
 */
function _window() {
    return window;
}
function _setWindowLocation(url) {
    _window().location.href = url;
}

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _isWorker() {
    return (typeof _window()['WorkerGlobalScope'] !== 'undefined' &&
        typeof _window()['importScripts'] === 'function');
}
async function _getActiveServiceWorker() {
    if (!(navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker)) {
        return null;
    }
    try {
        const registration = await navigator.serviceWorker.ready;
        return registration.active;
    }
    catch (_a) {
        return null;
    }
}
function _getServiceWorkerController() {
    var _a;
    return ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker) === null || _a === void 0 ? void 0 : _a.controller) || null;
}
function _getWorkerGlobalScope() {
    return _isWorker() ? self : null;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const index_e3d5d3f4_DB_NAME = 'firebaseLocalStorageDb';
const index_e3d5d3f4_DB_VERSION = 1;
const DB_OBJECTSTORE_NAME = 'firebaseLocalStorage';
const DB_DATA_KEYPATH = 'fbase_key';
/**
 * Promise wrapper for IDBRequest
 *
 * Unfortunately we can't cleanly extend Promise<T> since promises are not callable in ES6
 *
 */
class DBPromise {
    constructor(request) {
        this.request = request;
    }
    toPromise() {
        return new Promise((resolve, reject) => {
            this.request.addEventListener('success', () => {
                resolve(this.request.result);
            });
            this.request.addEventListener('error', () => {
                reject(this.request.error);
            });
        });
    }
}
function getObjectStore(db, isReadWrite) {
    return db
        .transaction([DB_OBJECTSTORE_NAME], isReadWrite ? 'readwrite' : 'readonly')
        .objectStore(DB_OBJECTSTORE_NAME);
}
function _deleteDatabase() {
    const request = indexedDB.deleteDatabase(index_e3d5d3f4_DB_NAME);
    return new DBPromise(request).toPromise();
}
function _openDatabase() {
    const request = indexedDB.open(index_e3d5d3f4_DB_NAME, index_e3d5d3f4_DB_VERSION);
    return new Promise((resolve, reject) => {
        request.addEventListener('error', () => {
            reject(request.error);
        });
        request.addEventListener('upgradeneeded', () => {
            const db = request.result;
            try {
                db.createObjectStore(DB_OBJECTSTORE_NAME, { keyPath: DB_DATA_KEYPATH });
            }
            catch (e) {
                reject(e);
            }
        });
        request.addEventListener('success', async () => {
            const db = request.result;
            // Strange bug that occurs in Firefox when multiple tabs are opened at the
            // same time. The only way to recover seems to be deleting the database
            // and re-initializing it.
            // https://github.com/firebase/firebase-js-sdk/issues/634
            if (!db.objectStoreNames.contains(DB_OBJECTSTORE_NAME)) {
                // Need to close the database or else you get a `blocked` event
                db.close();
                await _deleteDatabase();
                resolve(await _openDatabase());
            }
            else {
                resolve(db);
            }
        });
    });
}
async function _putObject(db, key, value) {
    const request = getObjectStore(db, true).put({
        [DB_DATA_KEYPATH]: key,
        value
    });
    return new DBPromise(request).toPromise();
}
async function getObject(db, key) {
    const request = getObjectStore(db, false).get(key);
    const data = await new DBPromise(request).toPromise();
    return data === undefined ? null : data.value;
}
function _deleteObject(db, key) {
    const request = getObjectStore(db, true).delete(key);
    return new DBPromise(request).toPromise();
}
const _POLLING_INTERVAL_MS = 800;
const _TRANSACTION_RETRY_COUNT = 3;
class IndexedDBLocalPersistence {
    constructor() {
        this.type = "LOCAL" /* PersistenceType.LOCAL */;
        this._shouldAllowMigration = true;
        this.listeners = {};
        this.localCache = {};
        // setTimeout return value is platform specific
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.pollTimer = null;
        this.pendingWrites = 0;
        this.receiver = null;
        this.sender = null;
        this.serviceWorkerReceiverAvailable = false;
        this.activeServiceWorker = null;
        // Fire & forget the service worker registration as it may never resolve
        this._workerInitializationPromise =
            this.initializeServiceWorkerMessaging().then(() => { }, () => { });
    }
    async _openDb() {
        if (this.db) {
            return this.db;
        }
        this.db = await _openDatabase();
        return this.db;
    }
    async _withRetries(op) {
        let numAttempts = 0;
        while (true) {
            try {
                const db = await this._openDb();
                return await op(db);
            }
            catch (e) {
                if (numAttempts++ > _TRANSACTION_RETRY_COUNT) {
                    throw e;
                }
                if (this.db) {
                    this.db.close();
                    this.db = undefined;
                }
                // TODO: consider adding exponential backoff
            }
        }
    }
    /**
     * IndexedDB events do not propagate from the main window to the worker context.  We rely on a
     * postMessage interface to send these events to the worker ourselves.
     */
    async initializeServiceWorkerMessaging() {
        return _isWorker() ? this.initializeReceiver() : this.initializeSender();
    }
    /**
     * As the worker we should listen to events from the main window.
     */
    async initializeReceiver() {
        this.receiver = Receiver._getInstance(_getWorkerGlobalScope());
        // Refresh from persistence if we receive a KeyChanged message.
        this.receiver._subscribe("keyChanged" /* _EventType.KEY_CHANGED */, async (_origin, data) => {
            const keys = await this._poll();
            return {
                keyProcessed: keys.includes(data.key)
            };
        });
        // Let the sender know that we are listening so they give us more timeout.
        this.receiver._subscribe("ping" /* _EventType.PING */, async (_origin, _data) => {
            return ["keyChanged" /* _EventType.KEY_CHANGED */];
        });
    }
    /**
     * As the main window, we should let the worker know when keys change (set and remove).
     *
     * @remarks
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/ready | ServiceWorkerContainer.ready}
     * may not resolve.
     */
    async initializeSender() {
        var _a, _b;
        // Check to see if there's an active service worker.
        this.activeServiceWorker = await _getActiveServiceWorker();
        if (!this.activeServiceWorker) {
            return;
        }
        this.sender = new Sender(this.activeServiceWorker);
        // Ping the service worker to check what events they can handle.
        const results = await this.sender._send("ping" /* _EventType.PING */, {}, 800 /* _TimeoutDuration.LONG_ACK */);
        if (!results) {
            return;
        }
        if (((_a = results[0]) === null || _a === void 0 ? void 0 : _a.fulfilled) &&
            ((_b = results[0]) === null || _b === void 0 ? void 0 : _b.value.includes("keyChanged" /* _EventType.KEY_CHANGED */))) {
            this.serviceWorkerReceiverAvailable = true;
        }
    }
    /**
     * Let the worker know about a changed key, the exact key doesn't technically matter since the
     * worker will just trigger a full sync anyway.
     *
     * @remarks
     * For now, we only support one service worker per page.
     *
     * @param key - Storage key which changed.
     */
    async notifyServiceWorker(key) {
        if (!this.sender ||
            !this.activeServiceWorker ||
            _getServiceWorkerController() !== this.activeServiceWorker) {
            return;
        }
        try {
            await this.sender._send("keyChanged" /* _EventType.KEY_CHANGED */, { key }, 
            // Use long timeout if receiver has previously responded to a ping from us.
            this.serviceWorkerReceiverAvailable
                ? 800 /* _TimeoutDuration.LONG_ACK */
                : 50 /* _TimeoutDuration.ACK */);
        }
        catch (_a) {
            // This is a best effort approach. Ignore errors.
        }
    }
    async _isAvailable() {
        try {
            if (!indexedDB) {
                return false;
            }
            const db = await _openDatabase();
            await _putObject(db, STORAGE_AVAILABLE_KEY, '1');
            await _deleteObject(db, STORAGE_AVAILABLE_KEY);
            return true;
        }
        catch (_a) { }
        return false;
    }
    async _withPendingWrite(write) {
        this.pendingWrites++;
        try {
            await write();
        }
        finally {
            this.pendingWrites--;
        }
    }
    async _set(key, value) {
        return this._withPendingWrite(async () => {
            await this._withRetries((db) => _putObject(db, key, value));
            this.localCache[key] = value;
            return this.notifyServiceWorker(key);
        });
    }
    async _get(key) {
        const obj = (await this._withRetries((db) => getObject(db, key)));
        this.localCache[key] = obj;
        return obj;
    }
    async _remove(key) {
        return this._withPendingWrite(async () => {
            await this._withRetries((db) => _deleteObject(db, key));
            delete this.localCache[key];
            return this.notifyServiceWorker(key);
        });
    }
    async _poll() {
        // TODO: check if we need to fallback if getAll is not supported
        const result = await this._withRetries((db) => {
            const getAllRequest = getObjectStore(db, false).getAll();
            return new DBPromise(getAllRequest).toPromise();
        });
        if (!result) {
            return [];
        }
        // If we have pending writes in progress abort, we'll get picked up on the next poll
        if (this.pendingWrites !== 0) {
            return [];
        }
        const keys = [];
        const keysInResult = new Set();
        for (const { fbase_key: key, value } of result) {
            keysInResult.add(key);
            if (JSON.stringify(this.localCache[key]) !== JSON.stringify(value)) {
                this.notifyListeners(key, value);
                keys.push(key);
            }
        }
        for (const localKey of Object.keys(this.localCache)) {
            if (this.localCache[localKey] && !keysInResult.has(localKey)) {
                // Deleted
                this.notifyListeners(localKey, null);
                keys.push(localKey);
            }
        }
        return keys;
    }
    notifyListeners(key, newValue) {
        this.localCache[key] = newValue;
        const listeners = this.listeners[key];
        if (listeners) {
            for (const listener of Array.from(listeners)) {
                listener(newValue);
            }
        }
    }
    startPolling() {
        this.stopPolling();
        this.pollTimer = setInterval(async () => this._poll(), _POLLING_INTERVAL_MS);
    }
    stopPolling() {
        if (this.pollTimer) {
            clearInterval(this.pollTimer);
            this.pollTimer = null;
        }
    }
    _addListener(key, listener) {
        if (Object.keys(this.listeners).length === 0) {
            this.startPolling();
        }
        if (!this.listeners[key]) {
            this.listeners[key] = new Set();
            // Populate the cache to avoid spuriously triggering on first poll.
            void this._get(key); // This can happen in the background async and we can return immediately.
        }
        this.listeners[key].add(listener);
    }
    _removeListener(key, listener) {
        if (this.listeners[key]) {
            this.listeners[key].delete(listener);
            if (this.listeners[key].size === 0) {
                delete this.listeners[key];
            }
        }
        if (Object.keys(this.listeners).length === 0) {
            this.stopPolling();
        }
    }
}
IndexedDBLocalPersistence.type = 'LOCAL';
/**
 * An implementation of {@link Persistence} of type `LOCAL` using `indexedDB`
 * for the underlying storage.
 *
 * @public
 */
const indexedDBLocalPersistence = IndexedDBLocalPersistence;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function startSignInPhoneMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaSignIn:start" /* Endpoint.START_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));
}
function finalizeSignInPhoneMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaSignIn:finalize" /* Endpoint.FINALIZE_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));
}
function finalizeSignInTotpMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaSignIn:finalize" /* Endpoint.FINALIZE_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _SOLVE_TIME_MS = 500;
const _EXPIRATION_TIME_MS = 60000;
const _WIDGET_ID_START = 1000000000000;
class MockReCaptcha {
    constructor(auth) {
        this.auth = auth;
        this.counter = _WIDGET_ID_START;
        this._widgets = new Map();
    }
    render(container, parameters) {
        const id = this.counter;
        this._widgets.set(id, new MockWidget(container, this.auth.name, parameters || {}));
        this.counter++;
        return id;
    }
    reset(optWidgetId) {
        var _a;
        const id = optWidgetId || _WIDGET_ID_START;
        void ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a.delete());
        this._widgets.delete(id);
    }
    getResponse(optWidgetId) {
        var _a;
        const id = optWidgetId || _WIDGET_ID_START;
        return ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a.getResponse()) || '';
    }
    async execute(optWidgetId) {
        var _a;
        const id = optWidgetId || _WIDGET_ID_START;
        void ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a.execute());
        return '';
    }
}
class MockWidget {
    constructor(containerOrId, appName, params) {
        this.params = params;
        this.timerId = null;
        this.deleted = false;
        this.responseToken = null;
        this.clickHandler = () => {
            this.execute();
        };
        const container = typeof containerOrId === 'string'
            ? document.getElementById(containerOrId)
            : containerOrId;
        _assert(container, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */, { appName });
        this.container = container;
        this.isVisible = this.params.size !== 'invisible';
        if (this.isVisible) {
            this.execute();
        }
        else {
            this.container.addEventListener('click', this.clickHandler);
        }
    }
    getResponse() {
        this.checkIfDeleted();
        return this.responseToken;
    }
    delete() {
        this.checkIfDeleted();
        this.deleted = true;
        if (this.timerId) {
            clearTimeout(this.timerId);
            this.timerId = null;
        }
        this.container.removeEventListener('click', this.clickHandler);
    }
    execute() {
        this.checkIfDeleted();
        if (this.timerId) {
            return;
        }
        this.timerId = window.setTimeout(() => {
            this.responseToken = generateRandomAlphaNumericString(50);
            const { callback, 'expired-callback': expiredCallback } = this.params;
            if (callback) {
                try {
                    callback(this.responseToken);
                }
                catch (e) { }
            }
            this.timerId = window.setTimeout(() => {
                this.timerId = null;
                this.responseToken = null;
                if (expiredCallback) {
                    try {
                        expiredCallback();
                    }
                    catch (e) { }
                }
                if (this.isVisible) {
                    this.execute();
                }
            }, _EXPIRATION_TIME_MS);
        }, _SOLVE_TIME_MS);
    }
    checkIfDeleted() {
        if (this.deleted) {
            throw new Error('reCAPTCHA mock was already deleted!');
        }
    }
}
function generateRandomAlphaNumericString(len) {
    const chars = [];
    const allowedChars = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    for (let i = 0; i < len; i++) {
        chars.push(allowedChars.charAt(Math.floor(Math.random() * allowedChars.length)));
    }
    return chars.join('');
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ReCaptcha will load using the same callback, so the callback function needs
// to be kept around
const _JSLOAD_CALLBACK = _generateCallbackName('rcb');
const NETWORK_TIMEOUT_DELAY = new Delay(30000, 60000);
const RECAPTCHA_BASE = 'https://www.google.com/recaptcha/api.js?';
/**
 * Loader for the GReCaptcha library. There should only ever be one of this.
 */
class ReCaptchaLoaderImpl {
    constructor() {
        var _a;
        this.hostLanguage = '';
        this.counter = 0;
        /**
         * Check for `render()` method. `window.grecaptcha` will exist if the Enterprise
         * version of the ReCAPTCHA script was loaded by someone else (e.g. App Check) but
         * `window.grecaptcha.render()` will not. Another load will add it.
         */
        this.librarySeparatelyLoaded = !!((_a = _window().grecaptcha) === null || _a === void 0 ? void 0 : _a.render);
    }
    load(auth, hl = '') {
        _assert(isHostLanguageValid(hl), auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        if (this.shouldResolveImmediately(hl) && isV2(_window().grecaptcha)) {
            return Promise.resolve(_window().grecaptcha);
        }
        return new Promise((resolve, reject) => {
            const networkTimeout = _window().setTimeout(() => {
                reject(_createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));
            }, NETWORK_TIMEOUT_DELAY.get());
            _window()[_JSLOAD_CALLBACK] = () => {
                _window().clearTimeout(networkTimeout);
                delete _window()[_JSLOAD_CALLBACK];
                const recaptcha = _window().grecaptcha;
                if (!recaptcha || !isV2(recaptcha)) {
                    reject(_createError(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */));
                    return;
                }
                // Wrap the greptcha render function so that we know if the developer has
                // called it separately
                const render = recaptcha.render;
                recaptcha.render = (container, params) => {
                    const widgetId = render(container, params);
                    this.counter++;
                    return widgetId;
                };
                this.hostLanguage = hl;
                resolve(recaptcha);
            };
            const url = `${RECAPTCHA_BASE}?${querystring({
                onload: _JSLOAD_CALLBACK,
                render: 'explicit',
                hl
            })}`;
            _loadJS(url).catch(() => {
                clearTimeout(networkTimeout);
                reject(_createError(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */));
            });
        });
    }
    clearedOneInstance() {
        this.counter--;
    }
    shouldResolveImmediately(hl) {
        var _a;
        // We can resolve immediately if:
        //   • grecaptcha is already defined AND (
        //     1. the requested language codes are the same OR
        //     2. there exists already a ReCaptcha on the page
        //     3. the library was already loaded by the app
        // In cases (2) and (3), we _can't_ reload as it would break the recaptchas
        // that are already in the page
        return (!!((_a = _window().grecaptcha) === null || _a === void 0 ? void 0 : _a.render) &&
            (hl === this.hostLanguage ||
                this.counter > 0 ||
                this.librarySeparatelyLoaded));
    }
}
function isHostLanguageValid(hl) {
    return hl.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(hl);
}
class MockReCaptchaLoaderImpl {
    async load(auth) {
        return new MockReCaptcha(auth);
    }
    clearedOneInstance() { }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RECAPTCHA_VERIFIER_TYPE = 'recaptcha';
const DEFAULT_PARAMS = {
    theme: 'light',
    type: 'image'
};
/**
 * An {@link https://www.google.com/recaptcha/ | reCAPTCHA}-based application verifier.
 *
 * @public
 */
class RecaptchaVerifier {
    /**
     *
     * @param containerOrId - The reCAPTCHA container parameter.
     *
     * @remarks
     * This has different meaning depending on whether the reCAPTCHA is hidden or visible. For a
     * visible reCAPTCHA the container must be empty. If a string is used, it has to correspond to
     * an element ID. The corresponding element must also must be in the DOM at the time of
     * initialization.
     *
     * @param parameters - The optional reCAPTCHA parameters.
     *
     * @remarks
     * Check the reCAPTCHA docs for a comprehensive list. All parameters are accepted except for
     * the sitekey. Firebase Auth backend provisions a reCAPTCHA for each project and will
     * configure this upon rendering. For an invisible reCAPTCHA, a size key must have the value
     * 'invisible'.
     *
     * @param authExtern - The corresponding Firebase {@link Auth} instance.
     */
    constructor(containerOrId, parameters = Object.assign({}, DEFAULT_PARAMS), authExtern) {
        this.parameters = parameters;
        /**
         * The application verifier type.
         *
         * @remarks
         * For a reCAPTCHA verifier, this is 'recaptcha'.
         */
        this.type = RECAPTCHA_VERIFIER_TYPE;
        this.destroyed = false;
        this.widgetId = null;
        this.tokenChangeListeners = new Set();
        this.renderPromise = null;
        this.recaptcha = null;
        this.auth = _castAuth(authExtern);
        this.isInvisible = this.parameters.size === 'invisible';
        _assert(typeof document !== 'undefined', this.auth, "operation-not-supported-in-this-environment" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);
        const container = typeof containerOrId === 'string'
            ? document.getElementById(containerOrId)
            : containerOrId;
        _assert(container, this.auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        this.container = container;
        this.parameters.callback = this.makeTokenCallback(this.parameters.callback);
        this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting
            ? new MockReCaptchaLoaderImpl()
            : new ReCaptchaLoaderImpl();
        this.validateStartingState();
        // TODO: Figure out if sdk version is needed
    }
    /**
     * Waits for the user to solve the reCAPTCHA and resolves with the reCAPTCHA token.
     *
     * @returns A Promise for the reCAPTCHA token.
     */
    async verify() {
        this.assertNotDestroyed();
        const id = await this.render();
        const recaptcha = this.getAssertedRecaptcha();
        const response = recaptcha.getResponse(id);
        if (response) {
            return response;
        }
        return new Promise(resolve => {
            const tokenChange = (token) => {
                if (!token) {
                    return; // Ignore token expirations.
                }
                this.tokenChangeListeners.delete(tokenChange);
                resolve(token);
            };
            this.tokenChangeListeners.add(tokenChange);
            if (this.isInvisible) {
                recaptcha.execute(id);
            }
        });
    }
    /**
     * Renders the reCAPTCHA widget on the page.
     *
     * @returns A Promise that resolves with the reCAPTCHA widget ID.
     */
    render() {
        try {
            this.assertNotDestroyed();
        }
        catch (e) {
            // This method returns a promise. Since it's not async (we want to return the
            // _same_ promise if rendering is still occurring), the API surface should
            // reject with the error rather than just throw
            return Promise.reject(e);
        }
        if (this.renderPromise) {
            return this.renderPromise;
        }
        this.renderPromise = this.makeRenderPromise().catch(e => {
            this.renderPromise = null;
            throw e;
        });
        return this.renderPromise;
    }
    /** @internal */
    _reset() {
        this.assertNotDestroyed();
        if (this.widgetId !== null) {
            this.getAssertedRecaptcha().reset(this.widgetId);
        }
    }
    /**
     * Clears the reCAPTCHA widget from the page and destroys the instance.
     */
    clear() {
        this.assertNotDestroyed();
        this.destroyed = true;
        this._recaptchaLoader.clearedOneInstance();
        if (!this.isInvisible) {
            this.container.childNodes.forEach(node => {
                this.container.removeChild(node);
            });
        }
    }
    validateStartingState() {
        _assert(!this.parameters.sitekey, this.auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        _assert(this.isInvisible || !this.container.hasChildNodes(), this.auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        _assert(typeof document !== 'undefined', this.auth, "operation-not-supported-in-this-environment" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);
    }
    makeTokenCallback(existing) {
        return token => {
            this.tokenChangeListeners.forEach(listener => listener(token));
            if (typeof existing === 'function') {
                existing(token);
            }
            else if (typeof existing === 'string') {
                const globalFunc = _window()[existing];
                if (typeof globalFunc === 'function') {
                    globalFunc(token);
                }
            }
        };
    }
    assertNotDestroyed() {
        _assert(!this.destroyed, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    }
    async makeRenderPromise() {
        await this.init();
        if (!this.widgetId) {
            let container = this.container;
            if (!this.isInvisible) {
                const guaranteedEmpty = document.createElement('div');
                container.appendChild(guaranteedEmpty);
                container = guaranteedEmpty;
            }
            this.widgetId = this.getAssertedRecaptcha().render(container, this.parameters);
        }
        return this.widgetId;
    }
    async init() {
        _assert(_isHttpOrHttps() && !_isWorker(), this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        await domReady();
        this.recaptcha = await this._recaptchaLoader.load(this.auth, this.auth.languageCode || undefined);
        const siteKey = await getRecaptchaParams(this.auth);
        _assert(siteKey, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        this.parameters.sitekey = siteKey;
    }
    getAssertedRecaptcha() {
        _assert(this.recaptcha, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        return this.recaptcha;
    }
}
function domReady() {
    let resolver = null;
    return new Promise(resolve => {
        if (document.readyState === 'complete') {
            resolve();
            return;
        }
        // Document not ready, wait for load before resolving.
        // Save resolver, so we can remove listener in case it was externally
        // cancelled.
        resolver = () => resolve();
        window.addEventListener('load', resolver);
    }).catch(e => {
        if (resolver) {
            window.removeEventListener('load', resolver);
        }
        throw e;
    });
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ConfirmationResultImpl {
    constructor(verificationId, onConfirmation) {
        this.verificationId = verificationId;
        this.onConfirmation = onConfirmation;
    }
    confirm(verificationCode) {
        const authCredential = PhoneAuthCredential._fromVerification(this.verificationId, verificationCode);
        return this.onConfirmation(authCredential);
    }
}
/**
 * Asynchronously signs in using a phone number.
 *
 * @remarks
 * This method sends a code via SMS to the given
 * phone number, and returns a {@link ConfirmationResult}. After the user
 * provides the code sent to their phone, call {@link ConfirmationResult.confirm}
 * with the code to sign the user in.
 *
 * For abuse prevention, this method also requires a {@link ApplicationVerifier}.
 * This SDK includes a reCAPTCHA-based implementation, {@link RecaptchaVerifier}.
 * This function can work on other platforms that do not support the
 * {@link RecaptchaVerifier} (like React Native), but you need to use a
 * third-party {@link ApplicationVerifier} implementation.
 *
 * @example
 * ```javascript
 * // 'recaptcha-container' is the ID of an element in the DOM.
 * const applicationVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container');
 * const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
 * // Obtain a verificationCode from the user.
 * const credential = await confirmationResult.confirm(verificationCode);
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
 * @param appVerifier - The {@link ApplicationVerifier}.
 *
 * @public
 */
async function signInWithPhoneNumber(auth, phoneNumber, appVerifier) {
    const authInternal = _castAuth(auth);
    const verificationId = await _verifyPhoneNumber(authInternal, phoneNumber, getModularInstance(appVerifier));
    return new ConfirmationResultImpl(verificationId, cred => signInWithCredential(authInternal, cred));
}
/**
 * Links the user account with the given phone number.
 *
 * @param user - The user.
 * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
 * @param appVerifier - The {@link ApplicationVerifier}.
 *
 * @public
 */
async function linkWithPhoneNumber(user, phoneNumber, appVerifier) {
    const userInternal = getModularInstance(user);
    await _assertLinkedStatus(false, userInternal, "phone" /* ProviderId.PHONE */);
    const verificationId = await _verifyPhoneNumber(userInternal.auth, phoneNumber, getModularInstance(appVerifier));
    return new ConfirmationResultImpl(verificationId, cred => linkWithCredential(userInternal, cred));
}
/**
 * Re-authenticates a user using a fresh phone credential.
 *
 * @remarks Use before operations such as {@link updatePassword} that require tokens from recent sign-in attempts.
 *
 * @param user - The user.
 * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
 * @param appVerifier - The {@link ApplicationVerifier}.
 *
 * @public
 */
async function reauthenticateWithPhoneNumber(user, phoneNumber, appVerifier) {
    const userInternal = getModularInstance(user);
    const verificationId = await _verifyPhoneNumber(userInternal.auth, phoneNumber, getModularInstance(appVerifier));
    return new ConfirmationResultImpl(verificationId, cred => reauthenticateWithCredential(userInternal, cred));
}
/**
 * Returns a verification ID to be used in conjunction with the SMS code that is sent.
 *
 */
async function _verifyPhoneNumber(auth, options, verifier) {
    var _a;
    const recaptchaToken = await verifier.verify();
    try {
        _assert(typeof recaptchaToken === 'string', auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        _assert(verifier.type === RECAPTCHA_VERIFIER_TYPE, auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        let phoneInfoOptions;
        if (typeof options === 'string') {
            phoneInfoOptions = {
                phoneNumber: options
            };
        }
        else {
            phoneInfoOptions = options;
        }
        if ('session' in phoneInfoOptions) {
            const session = phoneInfoOptions.session;
            if ('phoneNumber' in phoneInfoOptions) {
                _assert(session.type === "enroll" /* MultiFactorSessionType.ENROLL */, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                const response = await startEnrollPhoneMfa(auth, {
                    idToken: session.credential,
                    phoneEnrollmentInfo: {
                        phoneNumber: phoneInfoOptions.phoneNumber,
                        recaptchaToken
                    }
                });
                return response.phoneSessionInfo.sessionInfo;
            }
            else {
                _assert(session.type === "signin" /* MultiFactorSessionType.SIGN_IN */, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                const mfaEnrollmentId = ((_a = phoneInfoOptions.multiFactorHint) === null || _a === void 0 ? void 0 : _a.uid) ||
                    phoneInfoOptions.multiFactorUid;
                _assert(mfaEnrollmentId, auth, "missing-multi-factor-info" /* AuthErrorCode.MISSING_MFA_INFO */);
                const response = await startSignInPhoneMfa(auth, {
                    mfaPendingCredential: session.credential,
                    mfaEnrollmentId,
                    phoneSignInInfo: {
                        recaptchaToken
                    }
                });
                return response.phoneResponseInfo.sessionInfo;
            }
        }
        else {
            const { sessionInfo } = await sendPhoneVerificationCode(auth, {
                phoneNumber: phoneInfoOptions.phoneNumber,
                recaptchaToken
            });
            return sessionInfo;
        }
    }
    finally {
        verifier._reset();
    }
}
/**
 * Updates the user's phone number.
 *
 * @example
 * ```
 * // 'recaptcha-container' is the ID of an element in the DOM.
 * const applicationVerifier = new RecaptchaVerifier('recaptcha-container');
 * const provider = new PhoneAuthProvider(auth);
 * const verificationId = await provider.verifyPhoneNumber('+16505550101', applicationVerifier);
 * // Obtain the verificationCode from the user.
 * const phoneCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
 * await updatePhoneNumber(user, phoneCredential);
 * ```
 *
 * @param user - The user.
 * @param credential - A credential authenticating the new phone number.
 *
 * @public
 */
async function updatePhoneNumber(user, credential) {
    await _link$1(getModularInstance(user), credential);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating an {@link PhoneAuthCredential}.
 *
 * @example
 * ```javascript
 * // 'recaptcha-container' is the ID of an element in the DOM.
 * const applicationVerifier = new RecaptchaVerifier('recaptcha-container');
 * const provider = new PhoneAuthProvider(auth);
 * const verificationId = await provider.verifyPhoneNumber('+16505550101', applicationVerifier);
 * // Obtain the verificationCode from the user.
 * const phoneCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
 * const userCredential = await signInWithCredential(auth, phoneCredential);
 * ```
 *
 * @public
 */
class PhoneAuthProvider {
    /**
     * @param auth - The Firebase {@link Auth} instance in which sign-ins should occur.
     *
     */
    constructor(auth) {
        /** Always set to {@link ProviderId}.PHONE. */
        this.providerId = PhoneAuthProvider.PROVIDER_ID;
        this.auth = _castAuth(auth);
    }
    /**
     *
     * Starts a phone number authentication flow by sending a verification code to the given phone
     * number.
     *
     * @example
     * ```javascript
     * const provider = new PhoneAuthProvider(auth);
     * const verificationId = await provider.verifyPhoneNumber(phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const authCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
     * const userCredential = await signInWithCredential(auth, authCredential);
     * ```
     *
     * @example
     * An alternative flow is provided using the `signInWithPhoneNumber` method.
     * ```javascript
     * const confirmationResult = signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const userCredential = confirmationResult.confirm(verificationCode);
     * ```
     *
     * @param phoneInfoOptions - The user's {@link PhoneInfoOptions}. The phone number should be in
     * E.164 format (e.g. +16505550101).
     * @param applicationVerifier - For abuse prevention, this method also requires a
     * {@link ApplicationVerifier}. This SDK includes a reCAPTCHA-based implementation,
     * {@link RecaptchaVerifier}.
     *
     * @returns A Promise for a verification ID that can be passed to
     * {@link PhoneAuthProvider.credential} to identify this flow..
     */
    verifyPhoneNumber(phoneOptions, applicationVerifier) {
        return _verifyPhoneNumber(this.auth, phoneOptions, index_esm2017_getModularInstance(applicationVerifier));
    }
    /**
     * Creates a phone auth credential, given the verification ID from
     * {@link PhoneAuthProvider.verifyPhoneNumber} and the code that was sent to the user's
     * mobile device.
     *
     * @example
     * ```javascript
     * const provider = new PhoneAuthProvider(auth);
     * const verificationId = provider.verifyPhoneNumber(phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const authCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
     * const userCredential = signInWithCredential(auth, authCredential);
     * ```
     *
     * @example
     * An alternative flow is provided using the `signInWithPhoneNumber` method.
     * ```javascript
     * const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const userCredential = await confirmationResult.confirm(verificationCode);
     * ```
     *
     * @param verificationId - The verification ID returned from {@link PhoneAuthProvider.verifyPhoneNumber}.
     * @param verificationCode - The verification code sent to the user's mobile device.
     *
     * @returns The auth provider credential.
     */
    static credential(verificationId, verificationCode) {
        return PhoneAuthCredential._fromVerification(verificationId, verificationCode);
    }
    /**
     * Generates an {@link AuthCredential} from a {@link UserCredential}.
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        const credential = userCredential;
        return PhoneAuthProvider.credentialFromTaggedObject(credential);
    }
    /**
     * Returns an {@link AuthCredential} when passed an error.
     *
     * @remarks
     *
     * This method works for errors like
     * `auth/account-exists-with-different-credentials`. This is useful for
     * recovering when attempting to set a user's phone number but the number
     * in question is already tied to another account. For example, the following
     * code tries to update the current user's phone number, and if that
     * fails, links the user with the account associated with that number:
     *
     * ```js
     * const provider = new PhoneAuthProvider(auth);
     * const verificationId = await provider.verifyPhoneNumber(number, verifier);
     * try {
     *   const code = ''; // Prompt the user for the verification code
     *   await updatePhoneNumber(
     *       auth.currentUser,
     *       PhoneAuthProvider.credential(verificationId, code));
     * } catch (e) {
     *   if ((e as FirebaseError)?.code === 'auth/account-exists-with-different-credential') {
     *     const cred = PhoneAuthProvider.credentialFromError(e);
     *     await linkWithCredential(auth.currentUser, cred);
     *   }
     * }
     *
     * // At this point, auth.currentUser.phoneNumber === number.
     * ```
     *
     * @param error - The error to generate a credential from.
     */
    static credentialFromError(error) {
        return PhoneAuthProvider.credentialFromTaggedObject((error.customData || {}));
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse) {
            return null;
        }
        const { phoneNumber, temporaryProof } = tokenResponse;
        if (phoneNumber && temporaryProof) {
            return PhoneAuthCredential._fromTokenResponse(phoneNumber, temporaryProof);
        }
        return null;
    }
}
/** Always set to {@link ProviderId}.PHONE. */
PhoneAuthProvider.PROVIDER_ID = "phone" /* ProviderId.PHONE */;
/** Always set to {@link SignInMethod}.PHONE. */
PhoneAuthProvider.PHONE_SIGN_IN_METHOD = "phone" /* SignInMethod.PHONE */;

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Chooses a popup/redirect resolver to use. This prefers the override (which
 * is directly passed in), and falls back to the property set on the auth
 * object. If neither are available, this function errors w/ an argument error.
 */
function _withDefaultResolver(auth, resolverOverride) {
    if (resolverOverride) {
        return _getInstance(resolverOverride);
    }
    _assert(auth._popupRedirectResolver, auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
    return auth._popupRedirectResolver;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IdpCredential extends AuthCredential {
    constructor(params) {
        super("custom" /* ProviderId.CUSTOM */, "custom" /* ProviderId.CUSTOM */);
        this.params = params;
    }
    _getIdTokenResponse(auth) {
        return signInWithIdp(auth, this._buildIdpRequest());
    }
    _linkToIdToken(auth, idToken) {
        return signInWithIdp(auth, this._buildIdpRequest(idToken));
    }
    _getReauthenticationResolver(auth) {
        return signInWithIdp(auth, this._buildIdpRequest());
    }
    _buildIdpRequest(idToken) {
        const request = {
            requestUri: this.params.requestUri,
            sessionId: this.params.sessionId,
            postBody: this.params.postBody,
            tenantId: this.params.tenantId,
            pendingToken: this.params.pendingToken,
            returnSecureToken: true,
            returnIdpCredential: true
        };
        if (idToken) {
            request.idToken = idToken;
        }
        return request;
    }
}
function _signIn(params) {
    return _signInWithCredential(params.auth, new IdpCredential(params), params.bypassAuthState);
}
function _reauth(params) {
    const { auth, user } = params;
    _assert(user, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    return _reauthenticate(user, new IdpCredential(params), params.bypassAuthState);
}
async function _link(params) {
    const { auth, user } = params;
    _assert(user, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    return _link$1(user, new IdpCredential(params), params.bypassAuthState);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Popup event manager. Handles the popup's entire lifecycle; listens to auth
 * events
 */
class AbstractPopupRedirectOperation {
    constructor(auth, filter, resolver, user, bypassAuthState = false) {
        this.auth = auth;
        this.resolver = resolver;
        this.user = user;
        this.bypassAuthState = bypassAuthState;
        this.pendingPromise = null;
        this.eventManager = null;
        this.filter = Array.isArray(filter) ? filter : [filter];
    }
    execute() {
        return new Promise(async (resolve, reject) => {
            this.pendingPromise = { resolve, reject };
            try {
                this.eventManager = await this.resolver._initialize(this.auth);
                await this.onExecution();
                this.eventManager.registerConsumer(this);
            }
            catch (e) {
                this.reject(e);
            }
        });
    }
    async onAuthEvent(event) {
        const { urlResponse, sessionId, postBody, tenantId, error, type } = event;
        if (error) {
            this.reject(error);
            return;
        }
        const params = {
            auth: this.auth,
            requestUri: urlResponse,
            sessionId: sessionId,
            tenantId: tenantId || undefined,
            postBody: postBody || undefined,
            user: this.user,
            bypassAuthState: this.bypassAuthState
        };
        try {
            this.resolve(await this.getIdpTask(type)(params));
        }
        catch (e) {
            this.reject(e);
        }
    }
    onError(error) {
        this.reject(error);
    }
    getIdpTask(type) {
        switch (type) {
            case "signInViaPopup" /* AuthEventType.SIGN_IN_VIA_POPUP */:
            case "signInViaRedirect" /* AuthEventType.SIGN_IN_VIA_REDIRECT */:
                return _signIn;
            case "linkViaPopup" /* AuthEventType.LINK_VIA_POPUP */:
            case "linkViaRedirect" /* AuthEventType.LINK_VIA_REDIRECT */:
                return _link;
            case "reauthViaPopup" /* AuthEventType.REAUTH_VIA_POPUP */:
            case "reauthViaRedirect" /* AuthEventType.REAUTH_VIA_REDIRECT */:
                return _reauth;
            default:
                _fail(this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        }
    }
    resolve(cred) {
        debugAssert(this.pendingPromise, 'Pending promise was never set');
        this.pendingPromise.resolve(cred);
        this.unregisterAndCleanUp();
    }
    reject(error) {
        debugAssert(this.pendingPromise, 'Pending promise was never set');
        this.pendingPromise.reject(error);
        this.unregisterAndCleanUp();
    }
    unregisterAndCleanUp() {
        if (this.eventManager) {
            this.eventManager.unregisterConsumer(this);
        }
        this.pendingPromise = null;
        this.cleanUp();
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _POLL_WINDOW_CLOSE_TIMEOUT = new Delay(2000, 10000);
/**
 * Authenticates a Firebase client using a popup-based OAuth authentication flow.
 *
 * @remarks
 * If succeeds, returns the signed in user along with the provider's credential. If sign in was
 * unsuccessful, returns an error object containing additional information about the error.
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new FacebookAuthProvider();
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a Facebook Access Token.
 * const credential = provider.credentialFromResult(auth, result);
 * const token = credential.accessToken;
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 *
 * @public
 */
async function signInWithPopup(auth, provider, resolver) {
    const authInternal = _castAuth(auth);
    _assertInstanceOf(auth, provider, FederatedAuthProvider);
    const resolverInternal = _withDefaultResolver(authInternal, resolver);
    const action = new PopupOperation(authInternal, "signInViaPopup" /* AuthEventType.SIGN_IN_VIA_POPUP */, provider, resolverInternal);
    return action.executeNotNull();
}
/**
 * Reauthenticates the current user with the specified {@link OAuthProvider} using a pop-up based
 * OAuth flow.
 *
 * @remarks
 * If the reauthentication is successful, the returned result will contain the user and the
 * provider's credential.
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new FacebookAuthProvider();
 * const result = await signInWithPopup(auth, provider);
 * // Reauthenticate using a popup.
 * await reauthenticateWithPopup(result.user, provider);
 * ```
 *
 * @param user - The user.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 * @public
 */
async function reauthenticateWithPopup(user, provider, resolver) {
    const userInternal = getModularInstance(user);
    _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
    const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
    const action = new PopupOperation(userInternal.auth, "reauthViaPopup" /* AuthEventType.REAUTH_VIA_POPUP */, provider, resolverInternal, userInternal);
    return action.executeNotNull();
}
/**
 * Links the authenticated provider to the user account using a pop-up based OAuth flow.
 *
 * @remarks
 * If the linking is successful, the returned result will contain the user and the provider's credential.
 *
 *
 * @example
 * ```javascript
 * // Sign in using some other provider.
 * const result = await signInWithEmailAndPassword(auth, email, password);
 * // Link using a popup.
 * const provider = new FacebookAuthProvider();
 * await linkWithPopup(result.user, provider);
 * ```
 *
 * @param user - The user.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 * @public
 */
async function linkWithPopup(user, provider, resolver) {
    const userInternal = getModularInstance(user);
    _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
    const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
    const action = new PopupOperation(userInternal.auth, "linkViaPopup" /* AuthEventType.LINK_VIA_POPUP */, provider, resolverInternal, userInternal);
    return action.executeNotNull();
}
/**
 * Popup event manager. Handles the popup's entire lifecycle; listens to auth
 * events
 *
 */
class PopupOperation extends AbstractPopupRedirectOperation {
    constructor(auth, filter, provider, resolver, user) {
        super(auth, filter, resolver, user);
        this.provider = provider;
        this.authWindow = null;
        this.pollId = null;
        if (PopupOperation.currentPopupAction) {
            PopupOperation.currentPopupAction.cancel();
        }
        PopupOperation.currentPopupAction = this;
    }
    async executeNotNull() {
        const result = await this.execute();
        _assert(result, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        return result;
    }
    async onExecution() {
        debugAssert(this.filter.length === 1, 'Popup operations only handle one event');
        const eventId = _generateEventId();
        this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], // There's always one, see constructor
        eventId);
        this.authWindow.associatedEvent = eventId;
        // Check for web storage support and origin validation _after_ the popup is
        // loaded. These operations are slow (~1 second or so) Rather than
        // waiting on them before opening the window, optimistically open the popup
        // and check for storage support at the same time. If storage support is
        // not available, this will cause the whole thing to reject properly. It
        // will also close the popup, but since the promise has already rejected,
        // the popup closed by user poll will reject into the void.
        this.resolver._originValidation(this.auth).catch(e => {
            this.reject(e);
        });
        this.resolver._isIframeWebStorageSupported(this.auth, isSupported => {
            if (!isSupported) {
                this.reject(_createError(this.auth, "web-storage-unsupported" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */));
            }
        });
        // Handle user closure. Notice this does *not* use await
        this.pollUserCancellation();
    }
    get eventId() {
        var _a;
        return ((_a = this.authWindow) === null || _a === void 0 ? void 0 : _a.associatedEvent) || null;
    }
    cancel() {
        this.reject(_createError(this.auth, "cancelled-popup-request" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */));
    }
    cleanUp() {
        if (this.authWindow) {
            this.authWindow.close();
        }
        if (this.pollId) {
            window.clearTimeout(this.pollId);
        }
        this.authWindow = null;
        this.pollId = null;
        PopupOperation.currentPopupAction = null;
    }
    pollUserCancellation() {
        const poll = () => {
            var _a, _b;
            if ((_b = (_a = this.authWindow) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.closed) {
                // Make sure that there is sufficient time for whatever action to
                // complete. The window could have closed but the sign in network
                // call could still be in flight. This is specifically true for
                // Firefox or if the opener is in an iframe, in which case the oauth
                // helper closes the popup.
                this.pollId = window.setTimeout(() => {
                    this.pollId = null;
                    this.reject(_createError(this.auth, "popup-closed-by-user" /* AuthErrorCode.POPUP_CLOSED_BY_USER */));
                }, 8000 /* _Timeout.AUTH_EVENT */);
                return;
            }
            this.pollId = window.setTimeout(poll, _POLL_WINDOW_CLOSE_TIMEOUT.get());
        };
        poll();
    }
}
// Only one popup is ever shown at once. The lifecycle of the current popup
// can be managed / cancelled by the constructor.
PopupOperation.currentPopupAction = null;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PENDING_REDIRECT_KEY = 'pendingRedirect';
// We only get one redirect outcome for any one auth, so just store it
// in here.
const redirectOutcomeMap = new Map();
class RedirectAction extends AbstractPopupRedirectOperation {
    constructor(auth, resolver, bypassAuthState = false) {
        super(auth, [
            "signInViaRedirect" /* AuthEventType.SIGN_IN_VIA_REDIRECT */,
            "linkViaRedirect" /* AuthEventType.LINK_VIA_REDIRECT */,
            "reauthViaRedirect" /* AuthEventType.REAUTH_VIA_REDIRECT */,
            "unknown" /* AuthEventType.UNKNOWN */
        ], resolver, undefined, bypassAuthState);
        this.eventId = null;
    }
    /**
     * Override the execute function; if we already have a redirect result, then
     * just return it.
     */
    async execute() {
        let readyOutcome = redirectOutcomeMap.get(this.auth._key());
        if (!readyOutcome) {
            try {
                const hasPendingRedirect = await _getAndClearPendingRedirectStatus(this.resolver, this.auth);
                const result = hasPendingRedirect ? await super.execute() : null;
                readyOutcome = () => Promise.resolve(result);
            }
            catch (e) {
                readyOutcome = () => Promise.reject(e);
            }
            redirectOutcomeMap.set(this.auth._key(), readyOutcome);
        }
        // If we're not bypassing auth state, the ready outcome should be set to
        // null.
        if (!this.bypassAuthState) {
            redirectOutcomeMap.set(this.auth._key(), () => Promise.resolve(null));
        }
        return readyOutcome();
    }
    async onAuthEvent(event) {
        if (event.type === "signInViaRedirect" /* AuthEventType.SIGN_IN_VIA_REDIRECT */) {
            return super.onAuthEvent(event);
        }
        else if (event.type === "unknown" /* AuthEventType.UNKNOWN */) {
            // This is a sentinel value indicating there's no pending redirect
            this.resolve(null);
            return;
        }
        if (event.eventId) {
            const user = await this.auth._redirectUserForId(event.eventId);
            if (user) {
                this.user = user;
                return super.onAuthEvent(event);
            }
            else {
                this.resolve(null);
            }
        }
    }
    async onExecution() { }
    cleanUp() { }
}
async function _getAndClearPendingRedirectStatus(resolver, auth) {
    const key = pendingRedirectKey(auth);
    const persistence = resolverPersistence(resolver);
    if (!(await persistence._isAvailable())) {
        return false;
    }
    const hasPendingRedirect = (await persistence._get(key)) === 'true';
    await persistence._remove(key);
    return hasPendingRedirect;
}
async function _setPendingRedirectStatus(resolver, auth) {
    return resolverPersistence(resolver)._set(pendingRedirectKey(auth), 'true');
}
function _clearRedirectOutcomes() {
    redirectOutcomeMap.clear();
}
function _overrideRedirectResult(auth, result) {
    redirectOutcomeMap.set(auth._key(), result);
}
function resolverPersistence(resolver) {
    return _getInstance(resolver._redirectPersistence);
}
function pendingRedirectKey(auth) {
    return _persistenceKeyName(PENDING_REDIRECT_KEY, auth.config.apiKey, auth.name);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Authenticates a Firebase client using a full-page redirect flow.
 *
 * @remarks
 * To handle the results and errors for this operation, refer to {@link getRedirectResult}.
 * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices
 * | best practices} when using {@link signInWithRedirect}.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new FacebookAuthProvider();
 * // You can add additional scopes to the provider:
 * provider.addScope('user_birthday');
 * // Start a sign in process for an unauthenticated user.
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Facebook Access Token.
 *   const credential = provider.credentialFromResult(auth, result);
 *   const token = credential.accessToken;
 * }
 * // As this API can be used for sign-in, linking and reauthentication,
 * // check the operationType to determine what triggered this redirect
 * // operation.
 * const operationType = result.operationType;
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 * @public
 */
function signInWithRedirect(auth, provider, resolver) {
    return _signInWithRedirect(auth, provider, resolver);
}
async function _signInWithRedirect(auth, provider, resolver) {
    const authInternal = _castAuth(auth);
    _assertInstanceOf(auth, provider, FederatedAuthProvider);
    // Wait for auth initialization to complete, this will process pending redirects and clear the
    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new
    // redirect and creating a PENDING_REDIRECT_KEY entry.
    await authInternal._initializationPromise;
    const resolverInternal = _withDefaultResolver(authInternal, resolver);
    await _setPendingRedirectStatus(resolverInternal, authInternal);
    return resolverInternal._openRedirect(authInternal, provider, "signInViaRedirect" /* AuthEventType.SIGN_IN_VIA_REDIRECT */);
}
/**
 * Reauthenticates the current user with the specified {@link OAuthProvider} using a full-page redirect flow.
 * @remarks
 * To handle the results and errors for this operation, refer to {@link getRedirectResult}.
 * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices
 * | best practices} when using {@link reauthenticateWithRedirect}.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new FacebookAuthProvider();
 * const result = await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * // Reauthenticate using a redirect.
 * await reauthenticateWithRedirect(result.user, provider);
 * // This will again trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * ```
 *
 * @param user - The user.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 * @public
 */
function reauthenticateWithRedirect(user, provider, resolver) {
    return _reauthenticateWithRedirect(user, provider, resolver);
}
async function _reauthenticateWithRedirect(user, provider, resolver) {
    const userInternal = getModularInstance(user);
    _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
    // Wait for auth initialization to complete, this will process pending redirects and clear the
    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new
    // redirect and creating a PENDING_REDIRECT_KEY entry.
    await userInternal.auth._initializationPromise;
    // Allow the resolver to error before persisting the redirect user
    const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
    await _setPendingRedirectStatus(resolverInternal, userInternal.auth);
    const eventId = await prepareUserForRedirect(userInternal);
    return resolverInternal._openRedirect(userInternal.auth, provider, "reauthViaRedirect" /* AuthEventType.REAUTH_VIA_REDIRECT */, eventId);
}
/**
 * Links the {@link OAuthProvider} to the user account using a full-page redirect flow.
 * @remarks
 * To handle the results and errors for this operation, refer to {@link getRedirectResult}.
 * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices
 * | best practices} when using {@link linkWithRedirect}.
 *
 * @example
 * ```javascript
 * // Sign in using some other provider.
 * const result = await signInWithEmailAndPassword(auth, email, password);
 * // Link using a redirect.
 * const provider = new FacebookAuthProvider();
 * await linkWithRedirect(result.user, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * ```
 *
 * @param user - The user.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 *
 * @public
 */
function linkWithRedirect(user, provider, resolver) {
    return _linkWithRedirect(user, provider, resolver);
}
async function _linkWithRedirect(user, provider, resolver) {
    const userInternal = getModularInstance(user);
    _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
    // Wait for auth initialization to complete, this will process pending redirects and clear the
    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new
    // redirect and creating a PENDING_REDIRECT_KEY entry.
    await userInternal.auth._initializationPromise;
    // Allow the resolver to error before persisting the redirect user
    const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
    await _assertLinkedStatus(false, userInternal, provider.providerId);
    await _setPendingRedirectStatus(resolverInternal, userInternal.auth);
    const eventId = await prepareUserForRedirect(userInternal);
    return resolverInternal._openRedirect(userInternal.auth, provider, "linkViaRedirect" /* AuthEventType.LINK_VIA_REDIRECT */, eventId);
}
/**
 * Returns a {@link UserCredential} from the redirect-based sign-in flow.
 *
 * @remarks
 * If sign-in succeeded, returns the signed in user. If sign-in was unsuccessful, fails with an
 * error. If no redirect operation was called, returns `null`.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new FacebookAuthProvider();
 * // You can add additional scopes to the provider:
 * provider.addScope('user_birthday');
 * // Start a sign in process for an unauthenticated user.
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Facebook Access Token.
 *   const credential = provider.credentialFromResult(auth, result);
 *   const token = credential.accessToken;
 * }
 * // As this API can be used for sign-in, linking and reauthentication,
 * // check the operationType to determine what triggered this redirect
 * // operation.
 * const operationType = result.operationType;
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 * @public
 */
async function getRedirectResult(auth, resolver) {
    await _castAuth(auth)._initializationPromise;
    return _getRedirectResult(auth, resolver, false);
}
async function _getRedirectResult(auth, resolverExtern, bypassAuthState = false) {
    const authInternal = _castAuth(auth);
    const resolver = _withDefaultResolver(authInternal, resolverExtern);
    const action = new RedirectAction(authInternal, resolver, bypassAuthState);
    const result = await action.execute();
    if (result && !bypassAuthState) {
        delete result.user._redirectEventId;
        await authInternal._persistUserIfCurrent(result.user);
        await authInternal._setRedirectUser(null, resolverExtern);
    }
    return result;
}
async function prepareUserForRedirect(user) {
    const eventId = _generateEventId(`${user.uid}:::`);
    user._redirectEventId = eventId;
    await user.auth._setRedirectUser(user);
    await user.auth._persistUserIfCurrent(user);
    return eventId;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// The amount of time to store the UIDs of seen events; this is
// set to 10 min by default
const EVENT_DUPLICATION_CACHE_DURATION_MS = 10 * 60 * 1000;
class AuthEventManager {
    constructor(auth) {
        this.auth = auth;
        this.cachedEventUids = new Set();
        this.consumers = new Set();
        this.queuedRedirectEvent = null;
        this.hasHandledPotentialRedirect = false;
        this.lastProcessedEventTime = Date.now();
    }
    registerConsumer(authEventConsumer) {
        this.consumers.add(authEventConsumer);
        if (this.queuedRedirectEvent &&
            this.isEventForConsumer(this.queuedRedirectEvent, authEventConsumer)) {
            this.sendToConsumer(this.queuedRedirectEvent, authEventConsumer);
            this.saveEventToCache(this.queuedRedirectEvent);
            this.queuedRedirectEvent = null;
        }
    }
    unregisterConsumer(authEventConsumer) {
        this.consumers.delete(authEventConsumer);
    }
    onEvent(event) {
        // Check if the event has already been handled
        if (this.hasEventBeenHandled(event)) {
            return false;
        }
        let handled = false;
        this.consumers.forEach(consumer => {
            if (this.isEventForConsumer(event, consumer)) {
                handled = true;
                this.sendToConsumer(event, consumer);
                this.saveEventToCache(event);
            }
        });
        if (this.hasHandledPotentialRedirect || !isRedirectEvent(event)) {
            // If we've already seen a redirect before, or this is a popup event,
            // bail now
            return handled;
        }
        this.hasHandledPotentialRedirect = true;
        // If the redirect wasn't handled, hang on to it
        if (!handled) {
            this.queuedRedirectEvent = event;
            handled = true;
        }
        return handled;
    }
    sendToConsumer(event, consumer) {
        var _a;
        if (event.error && !isNullRedirectEvent(event)) {
            const code = ((_a = event.error.code) === null || _a === void 0 ? void 0 : _a.split('auth/')[1]) ||
                "internal-error" /* AuthErrorCode.INTERNAL_ERROR */;
            consumer.onError(_createError(this.auth, code));
        }
        else {
            consumer.onAuthEvent(event);
        }
    }
    isEventForConsumer(event, consumer) {
        const eventIdMatches = consumer.eventId === null ||
            (!!event.eventId && event.eventId === consumer.eventId);
        return consumer.filter.includes(event.type) && eventIdMatches;
    }
    hasEventBeenHandled(event) {
        if (Date.now() - this.lastProcessedEventTime >=
            EVENT_DUPLICATION_CACHE_DURATION_MS) {
            this.cachedEventUids.clear();
        }
        return this.cachedEventUids.has(eventUid(event));
    }
    saveEventToCache(event) {
        this.cachedEventUids.add(eventUid(event));
        this.lastProcessedEventTime = Date.now();
    }
}
function eventUid(e) {
    return [e.type, e.eventId, e.sessionId, e.tenantId].filter(v => v).join('-');
}
function isNullRedirectEvent({ type, error }) {
    return (type === "unknown" /* AuthEventType.UNKNOWN */ &&
        (error === null || error === void 0 ? void 0 : error.code) === `auth/${"no-auth-event" /* AuthErrorCode.NO_AUTH_EVENT */}`);
}
function isRedirectEvent(event) {
    switch (event.type) {
        case "signInViaRedirect" /* AuthEventType.SIGN_IN_VIA_REDIRECT */:
        case "linkViaRedirect" /* AuthEventType.LINK_VIA_REDIRECT */:
        case "reauthViaRedirect" /* AuthEventType.REAUTH_VIA_REDIRECT */:
            return true;
        case "unknown" /* AuthEventType.UNKNOWN */:
            return isNullRedirectEvent(event);
        default:
            return false;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _getProjectConfig(auth, request = {}) {
    return _performApiRequest(auth, "GET" /* HttpMethod.GET */, "/v1/projects" /* Endpoint.GET_PROJECT_CONFIG */, request);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IP_ADDRESS_REGEX = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
const HTTP_REGEX = /^https?/;
async function _validateOrigin(auth) {
    // Skip origin validation if we are in an emulated environment
    if (auth.config.emulator) {
        return;
    }
    const { authorizedDomains } = await _getProjectConfig(auth);
    for (const domain of authorizedDomains) {
        try {
            if (matchDomain(domain)) {
                return;
            }
        }
        catch (_a) {
            // Do nothing if there's a URL error; just continue searching
        }
    }
    // In the old SDK, this error also provides helpful messages.
    _fail(auth, "unauthorized-domain" /* AuthErrorCode.INVALID_ORIGIN */);
}
function matchDomain(expected) {
    const currentUrl = _getCurrentUrl();
    const { protocol, hostname } = new URL(currentUrl);
    if (expected.startsWith('chrome-extension://')) {
        const ceUrl = new URL(expected);
        if (ceUrl.hostname === '' && hostname === '') {
            // For some reason we're not parsing chrome URLs properly
            return (protocol === 'chrome-extension:' &&
                expected.replace('chrome-extension://', '') ===
                    currentUrl.replace('chrome-extension://', ''));
        }
        return protocol === 'chrome-extension:' && ceUrl.hostname === hostname;
    }
    if (!HTTP_REGEX.test(protocol)) {
        return false;
    }
    if (IP_ADDRESS_REGEX.test(expected)) {
        // The domain has to be exactly equal to the pattern, as an IP domain will
        // only contain the IP, no extra character.
        return hostname === expected;
    }
    // Dots in pattern should be escaped.
    const escapedDomainPattern = expected.replace(/\./g, '\\.');
    // Non ip address domains.
    // domain.com = *.domain.com OR domain.com
    const re = new RegExp('^(.+\\.' + escapedDomainPattern + '|' + escapedDomainPattern + ')$', 'i');
    return re.test(hostname);
}

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NETWORK_TIMEOUT = new Delay(30000, 60000);
/**
 * Reset unlaoded GApi modules. If gapi.load fails due to a network error,
 * it will stop working after a retrial. This is a hack to fix this issue.
 */
function resetUnloadedGapiModules() {
    // Clear last failed gapi.load state to force next gapi.load to first
    // load the failed gapi.iframes module.
    // Get gapix.beacon context.
    const beacon = _window().___jsl;
    // Get current hint.
    if (beacon === null || beacon === void 0 ? void 0 : beacon.H) {
        // Get gapi hint.
        for (const hint of Object.keys(beacon.H)) {
            // Requested modules.
            beacon.H[hint].r = beacon.H[hint].r || [];
            // Loaded modules.
            beacon.H[hint].L = beacon.H[hint].L || [];
            // Set requested modules to a copy of the loaded modules.
            beacon.H[hint].r = [...beacon.H[hint].L];
            // Clear pending callbacks.
            if (beacon.CP) {
                for (let i = 0; i < beacon.CP.length; i++) {
                    // Remove all failed pending callbacks.
                    beacon.CP[i] = null;
                }
            }
        }
    }
}
function loadGapi(auth) {
    return new Promise((resolve, reject) => {
        var _a, _b, _c;
        // Function to run when gapi.load is ready.
        function loadGapiIframe() {
            // The developer may have tried to previously run gapi.load and failed.
            // Run this to fix that.
            resetUnloadedGapiModules();
            gapi.load('gapi.iframes', {
                callback: () => {
                    resolve(gapi.iframes.getContext());
                },
                ontimeout: () => {
                    // The above reset may be sufficient, but having this reset after
                    // failure ensures that if the developer calls gapi.load after the
                    // connection is re-established and before another attempt to embed
                    // the iframe, it would work and would not be broken because of our
                    // failed attempt.
                    // Timeout when gapi.iframes.Iframe not loaded.
                    resetUnloadedGapiModules();
                    reject(_createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));
                },
                timeout: NETWORK_TIMEOUT.get()
            });
        }
        if ((_b = (_a = _window().gapi) === null || _a === void 0 ? void 0 : _a.iframes) === null || _b === void 0 ? void 0 : _b.Iframe) {
            // If gapi.iframes.Iframe available, resolve.
            resolve(gapi.iframes.getContext());
        }
        else if (!!((_c = _window().gapi) === null || _c === void 0 ? void 0 : _c.load)) {
            // Gapi loader ready, load gapi.iframes.
            loadGapiIframe();
        }
        else {
            // Create a new iframe callback when this is called so as not to overwrite
            // any previous defined callback. This happens if this method is called
            // multiple times in parallel and could result in the later callback
            // overwriting the previous one. This would end up with a iframe
            // timeout.
            const cbName = _generateCallbackName('iframefcb');
            // GApi loader not available, dynamically load platform.js.
            _window()[cbName] = () => {
                // GApi loader should be ready.
                if (!!gapi.load) {
                    loadGapiIframe();
                }
                else {
                    // Gapi loader failed, throw error.
                    reject(_createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));
                }
            };
            // Load GApi loader.
            return _loadJS(`https://apis.google.com/js/api.js?onload=${cbName}`)
                .catch(e => reject(e));
        }
    }).catch(error => {
        // Reset cached promise to allow for retrial.
        cachedGApiLoader = null;
        throw error;
    });
}
let cachedGApiLoader = null;
function _loadGapi(auth) {
    cachedGApiLoader = cachedGApiLoader || loadGapi(auth);
    return cachedGApiLoader;
}

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PING_TIMEOUT = new Delay(5000, 15000);
const IFRAME_PATH = '__/auth/iframe';
const EMULATED_IFRAME_PATH = 'emulator/auth/iframe';
const IFRAME_ATTRIBUTES = {
    style: {
        position: 'absolute',
        top: '-100px',
        width: '1px',
        height: '1px'
    },
    'aria-hidden': 'true',
    tabindex: '-1'
};
// Map from apiHost to endpoint ID for passing into iframe. In current SDK, apiHost can be set to
// anything (not from a list of endpoints with IDs as in legacy), so this is the closest we can get.
const EID_FROM_APIHOST = new Map([
    ["identitytoolkit.googleapis.com" /* DefaultConfig.API_HOST */, 'p'],
    ['staging-identitytoolkit.sandbox.googleapis.com', 's'],
    ['test-identitytoolkit.sandbox.googleapis.com', 't'] // test
]);
function getIframeUrl(auth) {
    const config = auth.config;
    _assert(config.authDomain, auth, "auth-domain-config-required" /* AuthErrorCode.MISSING_AUTH_DOMAIN */);
    const url = config.emulator
        ? _emulatorUrl(config, EMULATED_IFRAME_PATH)
        : `https://${auth.config.authDomain}/${IFRAME_PATH}`;
    const params = {
        apiKey: config.apiKey,
        appName: auth.name,
        v: SDK_VERSION
    };
    const eid = EID_FROM_APIHOST.get(auth.config.apiHost);
    if (eid) {
        params.eid = eid;
    }
    const frameworks = auth._getFrameworks();
    if (frameworks.length) {
        params.fw = frameworks.join(',');
    }
    return `${url}?${index_esm2017_querystring(params).slice(1)}`;
}
async function _openIframe(auth) {
    const context = await _loadGapi(auth);
    const gapi = _window().gapi;
    _assert(gapi, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    return context.open({
        where: document.body,
        url: getIframeUrl(auth),
        messageHandlersFilter: gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
        attributes: IFRAME_ATTRIBUTES,
        dontclear: true
    }, (iframe) => new Promise(async (resolve, reject) => {
        await iframe.restyle({
            // Prevent iframe from closing on mouse out.
            setHideOnLeave: false
        });
        const networkError = _createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */);
        // Confirm iframe is correctly loaded.
        // To fallback on failure, set a timeout.
        const networkErrorTimer = _window().setTimeout(() => {
            reject(networkError);
        }, PING_TIMEOUT.get());
        // Clear timer and resolve pending iframe ready promise.
        function clearTimerAndResolve() {
            _window().clearTimeout(networkErrorTimer);
            resolve(iframe);
        }
        // This returns an IThenable. However the reject part does not call
        // when the iframe is not loaded.
        iframe.ping(clearTimerAndResolve).then(clearTimerAndResolve, () => {
            reject(networkError);
        });
    }));
}

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BASE_POPUP_OPTIONS = {
    location: 'yes',
    resizable: 'yes',
    statusbar: 'yes',
    toolbar: 'no'
};
const DEFAULT_WIDTH = 500;
const DEFAULT_HEIGHT = 600;
const TARGET_BLANK = '_blank';
const FIREFOX_EMPTY_URL = 'http://localhost';
class AuthPopup {
    constructor(window) {
        this.window = window;
        this.associatedEvent = null;
    }
    close() {
        if (this.window) {
            try {
                this.window.close();
            }
            catch (e) { }
        }
    }
}
function _open(auth, url, name, width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT) {
    const top = Math.max((window.screen.availHeight - height) / 2, 0).toString();
    const left = Math.max((window.screen.availWidth - width) / 2, 0).toString();
    let target = '';
    const options = Object.assign(Object.assign({}, BASE_POPUP_OPTIONS), { width: width.toString(), height: height.toString(), top,
        left });
    // Chrome iOS 7 and 8 is returning an undefined popup win when target is
    // specified, even though the popup is not necessarily blocked.
    const ua = index_esm2017_getUA().toLowerCase();
    if (name) {
        target = _isChromeIOS(ua) ? TARGET_BLANK : name;
    }
    if (_isFirefox(ua)) {
        // Firefox complains when invalid URLs are popped out. Hacky way to bypass.
        url = url || FIREFOX_EMPTY_URL;
        // Firefox disables by default scrolling on popup windows, which can create
        // issues when the user has many Google accounts, for instance.
        options.scrollbars = 'yes';
    }
    const optionsString = Object.entries(options).reduce((accum, [key, value]) => `${accum}${key}=${value},`, '');
    if (_isIOSStandalone(ua) && target !== '_self') {
        openAsNewWindowIOS(url || '', target);
        return new AuthPopup(null);
    }
    // about:blank getting sanitized causing browsers like IE/Edge to display
    // brief error message before redirecting to handler.
    const newWin = window.open(url || '', target, optionsString);
    _assert(newWin, auth, "popup-blocked" /* AuthErrorCode.POPUP_BLOCKED */);
    // Flaky on IE edge, encapsulate with a try and catch.
    try {
        newWin.focus();
    }
    catch (e) { }
    return new AuthPopup(newWin);
}
function openAsNewWindowIOS(url, target) {
    const el = document.createElement('a');
    el.href = url;
    el.target = target;
    const click = document.createEvent('MouseEvent');
    click.initMouseEvent('click', true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 1, null);
    el.dispatchEvent(click);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * URL for Authentication widget which will initiate the OAuth handshake
 *
 * @internal
 */
const WIDGET_PATH = '__/auth/handler';
/**
 * URL for emulated environment
 *
 * @internal
 */
const EMULATOR_WIDGET_PATH = 'emulator/auth/handler';
/**
 * Fragment name for the App Check token that gets passed to the widget
 *
 * @internal
 */
const FIREBASE_APP_CHECK_FRAGMENT_ID = encodeURIComponent('fac');
async function _getRedirectUrl(auth, provider, authType, redirectUrl, eventId, additionalParams) {
    _assert(auth.config.authDomain, auth, "auth-domain-config-required" /* AuthErrorCode.MISSING_AUTH_DOMAIN */);
    _assert(auth.config.apiKey, auth, "invalid-api-key" /* AuthErrorCode.INVALID_API_KEY */);
    const params = {
        apiKey: auth.config.apiKey,
        appName: auth.name,
        authType,
        redirectUrl,
        v: SDK_VERSION,
        eventId
    };
    if (provider instanceof FederatedAuthProvider) {
        provider.setDefaultLanguage(auth.languageCode);
        params.providerId = provider.providerId || '';
        if (!isEmpty(provider.getCustomParameters())) {
            params.customParameters = JSON.stringify(provider.getCustomParameters());
        }
        // TODO set additionalParams from the provider as well?
        for (const [key, value] of Object.entries(additionalParams || {})) {
            params[key] = value;
        }
    }
    if (provider instanceof BaseOAuthProvider) {
        const scopes = provider.getScopes().filter(scope => scope !== '');
        if (scopes.length > 0) {
            params.scopes = scopes.join(',');
        }
    }
    if (auth.tenantId) {
        params.tid = auth.tenantId;
    }
    // TODO: maybe set eid as endipointId
    // TODO: maybe set fw as Frameworks.join(",")
    const paramsDict = params;
    for (const key of Object.keys(paramsDict)) {
        if (paramsDict[key] === undefined) {
            delete paramsDict[key];
        }
    }
    // Sets the App Check token to pass to the widget
    const appCheckToken = await auth._getAppCheckToken();
    const appCheckTokenFragment = appCheckToken
        ? `#${FIREBASE_APP_CHECK_FRAGMENT_ID}=${encodeURIComponent(appCheckToken)}`
        : '';
    // Start at index 1 to skip the leading '&' in the query string
    return `${getHandlerBase(auth)}?${index_esm2017_querystring(paramsDict).slice(1)}${appCheckTokenFragment}`;
}
function getHandlerBase({ config }) {
    if (!config.emulator) {
        return `https://${config.authDomain}/${WIDGET_PATH}`;
    }
    return _emulatorUrl(config, EMULATOR_WIDGET_PATH);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The special web storage event
 *
 */
const WEB_STORAGE_SUPPORT_KEY = 'webStorageSupport';
class BrowserPopupRedirectResolver {
    constructor() {
        this.eventManagers = {};
        this.iframes = {};
        this.originValidationPromises = {};
        this._redirectPersistence = browserSessionPersistence;
        this._completeRedirectFn = _getRedirectResult;
        this._overrideRedirectResult = _overrideRedirectResult;
    }
    // Wrapping in async even though we don't await anywhere in order
    // to make sure errors are raised as promise rejections
    async _openPopup(auth, provider, authType, eventId) {
        var _a;
        debugAssert((_a = this.eventManagers[auth._key()]) === null || _a === void 0 ? void 0 : _a.manager, '_initialize() not called before _openPopup()');
        const url = await _getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId);
        return _open(auth, url, _generateEventId());
    }
    async _openRedirect(auth, provider, authType, eventId) {
        await this._originValidation(auth);
        const url = await _getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId);
        _setWindowLocation(url);
        return new Promise(() => { });
    }
    _initialize(auth) {
        const key = auth._key();
        if (this.eventManagers[key]) {
            const { manager, promise } = this.eventManagers[key];
            if (manager) {
                return Promise.resolve(manager);
            }
            else {
                debugAssert(promise, 'If manager is not set, promise should be');
                return promise;
            }
        }
        const promise = this.initAndGetManager(auth);
        this.eventManagers[key] = { promise };
        // If the promise is rejected, the key should be removed so that the
        // operation can be retried later.
        promise.catch(() => {
            delete this.eventManagers[key];
        });
        return promise;
    }
    async initAndGetManager(auth) {
        const iframe = await _openIframe(auth);
        const manager = new AuthEventManager(auth);
        iframe.register('authEvent', (iframeEvent) => {
            _assert(iframeEvent === null || iframeEvent === void 0 ? void 0 : iframeEvent.authEvent, auth, "invalid-auth-event" /* AuthErrorCode.INVALID_AUTH_EVENT */);
            // TODO: Consider splitting redirect and popup events earlier on
            const handled = manager.onEvent(iframeEvent.authEvent);
            return { status: handled ? "ACK" /* GapiOutcome.ACK */ : "ERROR" /* GapiOutcome.ERROR */ };
        }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
        this.eventManagers[auth._key()] = { manager };
        this.iframes[auth._key()] = iframe;
        return manager;
    }
    _isIframeWebStorageSupported(auth, cb) {
        const iframe = this.iframes[auth._key()];
        iframe.send(WEB_STORAGE_SUPPORT_KEY, { type: WEB_STORAGE_SUPPORT_KEY }, result => {
            var _a;
            const isSupported = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a[WEB_STORAGE_SUPPORT_KEY];
            if (isSupported !== undefined) {
                cb(!!isSupported);
            }
            _fail(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
    }
    _originValidation(auth) {
        const key = auth._key();
        if (!this.originValidationPromises[key]) {
            this.originValidationPromises[key] = _validateOrigin(auth);
        }
        return this.originValidationPromises[key];
    }
    get _shouldInitProactively() {
        // Mobile browsers and Safari need to optimistically initialize
        return _isMobileBrowser() || _isSafari() || _isIOS();
    }
}
/**
 * An implementation of {@link PopupRedirectResolver} suitable for browser
 * based applications.
 *
 * @public
 */
const browserPopupRedirectResolver = BrowserPopupRedirectResolver;

class MultiFactorAssertionImpl {
    constructor(factorId) {
        this.factorId = factorId;
    }
    _process(auth, session, displayName) {
        switch (session.type) {
            case "enroll" /* MultiFactorSessionType.ENROLL */:
                return this._finalizeEnroll(auth, session.credential, displayName);
            case "signin" /* MultiFactorSessionType.SIGN_IN */:
                return this._finalizeSignIn(auth, session.credential);
            default:
                return debugFail('unexpected MultiFactorSessionType');
        }
    }
}

/**
 * {@inheritdoc PhoneMultiFactorAssertion}
 *
 * @public
 */
class PhoneMultiFactorAssertionImpl extends MultiFactorAssertionImpl {
    constructor(credential) {
        super("phone" /* FactorId.PHONE */);
        this.credential = credential;
    }
    /** @internal */
    static _fromCredential(credential) {
        return new PhoneMultiFactorAssertionImpl(credential);
    }
    /** @internal */
    _finalizeEnroll(auth, idToken, displayName) {
        return finalizeEnrollPhoneMfa(auth, {
            idToken,
            displayName,
            phoneVerificationInfo: this.credential._makeVerificationRequest()
        });
    }
    /** @internal */
    _finalizeSignIn(auth, mfaPendingCredential) {
        return finalizeSignInPhoneMfa(auth, {
            mfaPendingCredential,
            phoneVerificationInfo: this.credential._makeVerificationRequest()
        });
    }
}
/**
 * Provider for generating a {@link PhoneMultiFactorAssertion}.
 *
 * @public
 */
class PhoneMultiFactorGenerator {
    constructor() { }
    /**
     * Provides a {@link PhoneMultiFactorAssertion} to confirm ownership of the phone second factor.
     *
     * @param phoneAuthCredential - A credential provided by {@link PhoneAuthProvider.credential}.
     * @returns A {@link PhoneMultiFactorAssertion} which can be used with
     * {@link MultiFactorResolver.resolveSignIn}
     */
    static assertion(credential) {
        return PhoneMultiFactorAssertionImpl._fromCredential(credential);
    }
}
/**
 * The identifier of the phone second factor: `phone`.
 */
PhoneMultiFactorGenerator.FACTOR_ID = 'phone';

/**
 * Provider for generating a {@link TotpMultiFactorAssertion}.
 *
 * @public
 */
class TotpMultiFactorGenerator {
    /**
     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of
     * the TOTP (time-based one-time password) second factor.
     * This assertion is used to complete enrollment in TOTP second factor.
     *
     * @param secret A {@link TotpSecret} containing the shared secret key and other TOTP parameters.
     * @param oneTimePassword One-time password from TOTP App.
     * @returns A {@link TotpMultiFactorAssertion} which can be used with
     * {@link MultiFactorUser.enroll}.
     */
    static assertionForEnrollment(secret, oneTimePassword) {
        return TotpMultiFactorAssertionImpl._fromSecret(secret, oneTimePassword);
    }
    /**
     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of the TOTP second factor.
     * This assertion is used to complete signIn with TOTP as the second factor.
     *
     * @param enrollmentId identifies the enrolled TOTP second factor.
     * @param oneTimePassword One-time password from TOTP App.
     * @returns A {@link TotpMultiFactorAssertion} which can be used with
     * {@link MultiFactorResolver.resolveSignIn}.
     */
    static assertionForSignIn(enrollmentId, oneTimePassword) {
        return TotpMultiFactorAssertionImpl._fromEnrollmentId(enrollmentId, oneTimePassword);
    }
    /**
     * Returns a promise to {@link TotpSecret} which contains the TOTP shared secret key and other parameters.
     * Creates a TOTP secret as part of enrolling a TOTP second factor.
     * Used for generating a QR code URL or inputting into a TOTP app.
     * This method uses the auth instance corresponding to the user in the multiFactorSession.
     *
     * @param session The {@link MultiFactorSession} that the user is part of.
     * @returns A promise to {@link TotpSecret}.
     */
    static async generateSecret(session) {
        const mfaSession = session;
        _assert(typeof mfaSession.auth !== 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const response = await startEnrollTotpMfa(mfaSession.auth, {
            idToken: mfaSession.credential,
            totpEnrollmentInfo: {}
        });
        return TotpSecret._fromStartTotpMfaEnrollmentResponse(response, mfaSession.auth);
    }
}
/**
 * The identifier of the TOTP second factor: `totp`.
 */
TotpMultiFactorGenerator.FACTOR_ID = "totp" /* FactorId.TOTP */;
class TotpMultiFactorAssertionImpl extends MultiFactorAssertionImpl {
    constructor(otp, enrollmentId, secret) {
        super("totp" /* FactorId.TOTP */);
        this.otp = otp;
        this.enrollmentId = enrollmentId;
        this.secret = secret;
    }
    /** @internal */
    static _fromSecret(secret, otp) {
        return new TotpMultiFactorAssertionImpl(otp, undefined, secret);
    }
    /** @internal */
    static _fromEnrollmentId(enrollmentId, otp) {
        return new TotpMultiFactorAssertionImpl(otp, enrollmentId);
    }
    /** @internal */
    async _finalizeEnroll(auth, idToken, displayName) {
        _assert(typeof this.secret !== 'undefined', auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        return finalizeEnrollTotpMfa(auth, {
            idToken,
            displayName,
            totpVerificationInfo: this.secret._makeTotpVerificationInfo(this.otp)
        });
    }
    /** @internal */
    async _finalizeSignIn(auth, mfaPendingCredential) {
        _assert(this.enrollmentId !== undefined && this.otp !== undefined, auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        const totpVerificationInfo = { verificationCode: this.otp };
        return finalizeSignInTotpMfa(auth, {
            mfaPendingCredential,
            mfaEnrollmentId: this.enrollmentId,
            totpVerificationInfo
        });
    }
}
/**
 * Provider for generating a {@link TotpMultiFactorAssertion}.
 *
 * Stores the shared secret key and other parameters to generate time-based OTPs.
 * Implements methods to retrieve the shared secret key and generate a QR code URL.
 * @public
 */
class TotpSecret {
    // The public members are declared outside the constructor so the docs can be generated.
    constructor(secretKey, hashingAlgorithm, codeLength, codeIntervalSeconds, enrollmentCompletionDeadline, sessionInfo, auth) {
        this.sessionInfo = sessionInfo;
        this.auth = auth;
        this.secretKey = secretKey;
        this.hashingAlgorithm = hashingAlgorithm;
        this.codeLength = codeLength;
        this.codeIntervalSeconds = codeIntervalSeconds;
        this.enrollmentCompletionDeadline = enrollmentCompletionDeadline;
    }
    /** @internal */
    static _fromStartTotpMfaEnrollmentResponse(response, auth) {
        return new TotpSecret(response.totpSessionInfo.sharedSecretKey, response.totpSessionInfo.hashingAlgorithm, response.totpSessionInfo.verificationCodeLength, response.totpSessionInfo.periodSec, new Date(response.totpSessionInfo.finalizeEnrollmentTime).toUTCString(), response.totpSessionInfo.sessionInfo, auth);
    }
    /** @internal */
    _makeTotpVerificationInfo(otp) {
        return { sessionInfo: this.sessionInfo, verificationCode: otp };
    }
    /**
     * Returns a QR code URL as described in
     * https://github.com/google/google-authenticator/wiki/Key-Uri-Format
     * This can be displayed to the user as a QR code to be scanned into a TOTP app like Google Authenticator.
     * If the optional parameters are unspecified, an accountName of <userEmail> and issuer of <firebaseAppName> are used.
     *
     * @param accountName the name of the account/app along with a user identifier.
     * @param issuer issuer of the TOTP (likely the app name).
     * @returns A QR code URL string.
     */
    generateQrCodeUrl(accountName, issuer) {
        var _a;
        let useDefaults = false;
        if (_isEmptyString(accountName) || _isEmptyString(issuer)) {
            useDefaults = true;
        }
        if (useDefaults) {
            if (_isEmptyString(accountName)) {
                accountName = ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.email) || 'unknownuser';
            }
            if (_isEmptyString(issuer)) {
                issuer = this.auth.name;
            }
        }
        return `otpauth://totp/${issuer}:${accountName}?secret=${this.secretKey}&issuer=${issuer}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`;
    }
}
/** @internal */
function _isEmptyString(input) {
    return typeof input === 'undefined' || (input === null || input === void 0 ? void 0 : input.length) === 0;
}

var index_e3d5d3f4_name = "@firebase/auth";
var index_e3d5d3f4_version = "0.23.2";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthInterop {
    constructor(auth) {
        this.auth = auth;
        this.internalListeners = new Map();
    }
    getUid() {
        var _a;
        this.assertAuthConfigured();
        return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;
    }
    async getToken(forceRefresh) {
        this.assertAuthConfigured();
        await this.auth._initializationPromise;
        if (!this.auth.currentUser) {
            return null;
        }
        const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);
        return { accessToken };
    }
    addAuthTokenListener(listener) {
        this.assertAuthConfigured();
        if (this.internalListeners.has(listener)) {
            return;
        }
        const unsubscribe = this.auth.onIdTokenChanged(user => {
            listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);
        });
        this.internalListeners.set(listener, unsubscribe);
        this.updateProactiveRefresh();
    }
    removeAuthTokenListener(listener) {
        this.assertAuthConfigured();
        const unsubscribe = this.internalListeners.get(listener);
        if (!unsubscribe) {
            return;
        }
        this.internalListeners.delete(listener);
        unsubscribe();
        this.updateProactiveRefresh();
    }
    assertAuthConfigured() {
        _assert(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */);
    }
    updateProactiveRefresh() {
        if (this.internalListeners.size > 0) {
            this.auth._startProactiveRefresh();
        }
        else {
            this.auth._stopProactiveRefresh();
        }
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getVersionForPlatform(clientPlatform) {
    switch (clientPlatform) {
        case "Node" /* ClientPlatform.NODE */:
            return 'node';
        case "ReactNative" /* ClientPlatform.REACT_NATIVE */:
            return 'rn';
        case "Worker" /* ClientPlatform.WORKER */:
            return 'webworker';
        case "Cordova" /* ClientPlatform.CORDOVA */:
            return 'cordova';
        default:
            return undefined;
    }
}
/** @internal */
function registerAuth(clientPlatform) {
    _registerComponent(new Component("auth" /* _ComponentName.AUTH */, (container, { options: deps }) => {
        const app = container.getProvider('app').getImmediate();
        const heartbeatServiceProvider = container.getProvider('heartbeat');
        const appCheckServiceProvider = container.getProvider('app-check-internal');
        const { apiKey, authDomain } = app.options;
        _assert(apiKey && !apiKey.includes(':'), "invalid-api-key" /* AuthErrorCode.INVALID_API_KEY */, { appName: app.name });
        const config = {
            apiKey,
            authDomain,
            clientPlatform,
            apiHost: "identitytoolkit.googleapis.com" /* DefaultConfig.API_HOST */,
            tokenApiHost: "securetoken.googleapis.com" /* DefaultConfig.TOKEN_API_HOST */,
            apiScheme: "https" /* DefaultConfig.API_SCHEME */,
            sdkClientVersion: _getClientVersion(clientPlatform)
        };
        const authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);
        _initializeAuthInstance(authInstance, deps);
        return authInstance;
    }, "PUBLIC" /* ComponentType.PUBLIC */)
        /**
         * Auth can only be initialized by explicitly calling getAuth() or initializeAuth()
         * For why we do this, See go/firebase-next-auth-init
         */
        .setInstantiationMode("EXPLICIT" /* InstantiationMode.EXPLICIT */)
        /**
         * Because all firebase products that depend on auth depend on auth-internal directly,
         * we need to initialize auth-internal after auth is initialized to make it available to other firebase products.
         */
        .setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {
        const authInternalProvider = container.getProvider("auth-internal" /* _ComponentName.AUTH_INTERNAL */);
        authInternalProvider.initialize();
    }));
    _registerComponent(new Component("auth-internal" /* _ComponentName.AUTH_INTERNAL */, container => {
        const auth = _castAuth(container.getProvider("auth" /* _ComponentName.AUTH */).getImmediate());
        return (auth => new AuthInterop(auth))(auth);
    }, "PRIVATE" /* ComponentType.PRIVATE */).setInstantiationMode("EXPLICIT" /* InstantiationMode.EXPLICIT */));
    registerVersion(index_e3d5d3f4_name, index_e3d5d3f4_version, getVersionForPlatform(clientPlatform));
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(index_e3d5d3f4_name, index_e3d5d3f4_version, 'esm2017');
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ID_TOKEN_MAX_AGE = 5 * 60;
const authIdTokenMaxAge = getExperimentalSetting('authIdTokenMaxAge') || DEFAULT_ID_TOKEN_MAX_AGE;
let lastPostedIdToken = null;
const mintCookieFactory = (url) => async (user) => {
    const idTokenResult = user && (await user.getIdTokenResult());
    const idTokenAge = idTokenResult &&
        (new Date().getTime() - Date.parse(idTokenResult.issuedAtTime)) / 1000;
    if (idTokenAge && idTokenAge > authIdTokenMaxAge) {
        return;
    }
    // Specifically trip null => undefined when logged out, to delete any existing cookie
    const idToken = idTokenResult === null || idTokenResult === void 0 ? void 0 : idTokenResult.token;
    if (lastPostedIdToken === idToken) {
        return;
    }
    lastPostedIdToken = idToken;
    await fetch(url, {
        method: idToken ? 'POST' : 'DELETE',
        headers: idToken
            ? {
                'Authorization': `Bearer ${idToken}`
            }
            : {}
    });
};
/**
 * Returns the Auth instance associated with the provided {@link @firebase/app#FirebaseApp}.
 * If no instance exists, initializes an Auth instance with platform-specific default dependencies.
 *
 * @param app - The Firebase App.
 *
 * @public
 */
function getAuth(app = getApp()) {
    const provider = _getProvider(app, 'auth');
    if (provider.isInitialized()) {
        return provider.getImmediate();
    }
    const auth = initializeAuth(app, {
        popupRedirectResolver: browserPopupRedirectResolver,
        persistence: [
            indexedDBLocalPersistence,
            browserLocalPersistence,
            browserSessionPersistence
        ]
    });
    const authTokenSyncUrl = getExperimentalSetting('authTokenSyncURL');
    if (authTokenSyncUrl) {
        const mintCookie = mintCookieFactory(authTokenSyncUrl);
        beforeAuthStateChanged(auth, mintCookie, () => mintCookie(auth.currentUser));
        onIdTokenChanged(auth, user => mintCookie(user));
    }
    const authEmulatorHost = getDefaultEmulatorHost('auth');
    if (authEmulatorHost) {
        connectAuthEmulator(auth, `http://${authEmulatorHost}`);
    }
    return auth;
}
registerAuth("Browser" /* ClientPlatform.BROWSER */);



;// CONCATENATED MODULE: ./node_modules/@firebase/auth/dist/esm2017/index.js







;// CONCATENATED MODULE: ./node_modules/firebase/auth/dist/esm/index.esm.js


;// CONCATENATED MODULE: ./node_modules/firebase/app/dist/esm/index.esm.js



var index_esm_name = "firebase";
var index_esm_version = "9.23.0";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerVersion(index_esm_name, index_esm_version, 'app');

;// CONCATENATED MODULE: ./src/dropbox_auth.ts




const firebaseConfig = {
    apiKey: 'AIzaSyDwtcPjQMj3JAy9d7wwjib19eywvGfdV3A',
    authDomain: 'splunge-390110.firebaseapp.com',
    projectId: 'splunge-390110',
    storageBucket: 'splunge-390110.appspot.com',
    messagingSenderId: '1041542736895',
    appId: '1:1041542736895:web:663b9c5ab38f8295eb95ca',
};
let firebase_app;
let firebase_auth;
function getCurrentUser(auth) {
    return new Promise((resolve, reject) => {
        const unsubscribe = auth.onAuthStateChanged((user) => {
            unsubscribe();
            resolve(user);
        }, reject);
    });
}
class DropboxAuther {
    CLIENT_ID = 'jxpyhv2cqozub0c';
    REDIRECT_URI = 'http://localhost:8080/';
    dbx;
    dbxAuth;
    authed = false;
    firebase_user;
    async init() {
        if (true) {
            this.REDIRECT_URI = 'https://wrightwriter.github.io/splunge/';
        }
        firebase_app = initializeApp(firebaseConfig);
        firebase_auth = getAuth(firebase_app);
        this.firebase_user = await getCurrentUser(firebase_auth);
        this.dbxAuth = new Dropbox_sdk_min.DropboxAuth({
            clientId: this.CLIENT_ID,
        });
        if (this.firebase_user) {
            const id_token = await firebase_auth.currentUser?.getIdToken(true);
            let res = await (await fetch('https://us-central1-splunge-390110.cloudfunctions.net/getDropboxCode' + `?id_token=${id_token}`)).json();
            const access_token = res.token;
            this.dbxAuth.setAccessToken(access_token);
            this.dbx = new Dropbox_sdk_min.Dropbox({
                auth: this.dbxAuth,
            });
            let files = await this.dbx.filesListFolder({
                path: '',
            });
            this.authed = true;
        }
    }
    constructor() { }
    parseQueryString(str) {
        const ret = Object.create(null);
        if (typeof str !== 'string') {
            return ret;
        }
        str = str.trim().replace(/^(\?|#|&)/, '');
        if (!str) {
            return ret;
        }
        str.split('&').forEach((param) => {
            const parts = param.replace(/\+/g, ' ').split('=');
            let key = parts.shift();
            let val = parts.length > 0 ? parts.join('=') : undefined;
            key = decodeURIComponent(key);
            val = val === undefined ? null : decodeURIComponent(val);
            if (ret[key] === undefined) {
                ret[key] = val;
            }
            else if (Array.isArray(ret[key])) {
                ret[key].push(val);
            }
            else {
                ret[key] = [ret[key], val];
            }
        });
        return ret;
    }
    async doAuth() {
        try {
            const url_response = await fetch('https://us-central1-splunge-390110.cloudfunctions.net/getAuthenticationUrl' + `?url=${window.location.href}`);
            let url = await url_response.json();
            url = url['auth_url'];
            window.location.href = url;
        }
        catch (error) {
            console.error(error);
        }
    }
    async try_init_dropbox() {
        let code = undefined;
        const getCodeFromUrl = () => {
            code = this.parseQueryString(window.location.search).code;
            return code;
        };
        const hasRedirectedFromAuth = () => {
            return !!getCodeFromUrl();
        };
        let redirectedFromAuth = hasRedirectedFromAuth();
        if (redirectedFromAuth) {
            const url = new URL(window.location.href);
            const body = {};
            for (let key of url.searchParams.keys()) {
                if (url.searchParams.getAll(key).length > 1) {
                    body[key] = url.searchParams.getAll(key);
                }
                else {
                    body[key] = url.searchParams.get(key);
                }
            }
            window.history.replaceState &&
                window.history.replaceState(null, '', window.location.pathname +
                    window.location.search.replace(/[?&]code=[^&]+/, '').replace(/^&/, '?') +
                    window.location.hash);
            body['redirect_url'] = window.location.href;
            const res = await fetch('https://us-central1-splunge-390110.cloudfunctions.net/exchangeDropboxCode' +
                `?redirect_url=${window.location.href}` +
                `&code=${body['code']}`);
            const data = await res.json();
            signInWithCustomToken(firebase_auth, data.token);
        }
        return;
    }
}

;// CONCATENATED MODULE: ./src/components/GalleryWidget.svelte
/* src/components/GalleryWidget.svelte generated by Svelte v4.0.0 */


const { Error: Error_1, console: GalleryWidget_svelte_console_1 } = globals;














const GalleryWidget_svelte_file = "src/components/GalleryWidget.svelte";

function GalleryWidget_svelte_add_css(target) {
	append_styles(target, "svelte-1lktj31", ".svelte-1lktj31.svelte-1lktj31{user-select:none;-webkit-tap-highlight-color:transparent}#canvas-preview-img.svelte-1lktj31.svelte-1lktj31{height:12rem}.hide.svelte-1lktj31.svelte-1lktj31{display:none}#gallery-container::-webkit-scrollbar{background:black}#gallery-container::-webkit-scrollbar-track{background:grey}#gallery-container::-webkit-scrollbar-thumb{background:white}#db-login-button.svelte-1lktj31.svelte-1lktj31{font-size:3rem;border-radius:0px;margin-bottom:2rem;cursor:pointer}#db-login-button.svelte-1lktj31.svelte-1lktj31:active{filter:invert(1)}#size-modal.svelte-1lktj31.svelte-1lktj31{position:fixed;display:flex;flex-direction:column;align-items:center;width:100vw;height:100vh;left:0;top:0;z-index:101;background:black;justify-content:center}#gallery-container-outer.svelte-1lktj31.svelte-1lktj31{position:fixed;display:flex;flex-direction:column;align-items:center;width:100vw;height:100vh;left:0;top:0;z-index:100;background:black}#gallery-container-outer.svelte-1lktj31 #gallery-container.svelte-1lktj31{overflow-y:overlay;scrollbar-gutter:stable both-edges;margin-top:1rem;height:100%;max-width:40rem;width:100%;display:flex;flex-direction:column;align-items:center}#gallery-container-outer.svelte-1lktj31 #gallery-container #top-bar.svelte-1lktj31{margin-bottom:1rem;width:100%;font-size:2rem;display:flex;justify-content:space-between}#gallery-container-outer.svelte-1lktj31 #gallery-container #top-bar #project-title.svelte-1lktj31{margin-left:0.5rem}#gallery-container-outer.svelte-1lktj31 #gallery-container #options-bar.svelte-1lktj31{align-items:center;margin-bottom:1rem;width:100%;font-size:2rem;display:flex;justify-content:space-between}#gallery-container-outer.svelte-1lktj31 #gallery-container #options-bar .svelte-1lktj31{font-size:0.95rem}#gallery-container-outer.svelte-1lktj31 #gallery-container #options-bar .svelte-1lktj31 svg{fill:white}#gallery-container-outer.svelte-1lktj31 #gallery-container #options-bar #button.svelte-1lktj31{display:flex;cursor:pointer;padding:0rem 0.2rem}#gallery-container-outer.svelte-1lktj31 #gallery-container #options-bar #button.svelte-1lktj31 svg{height:100%}#gallery-container-outer.svelte-1lktj31 #gallery-container #options-bar #button.svelte-1lktj31:active{filter:invert(1);background:black}#gallery-container-outer.svelte-1lktj31 #gallery-container .ok-button.svelte-1lktj31 svg{transform:scale(0.96) !important}#gallery-container-outer.svelte-1lktj31 #gallery-container #back-button.svelte-1lktj31>svg{transform:scale(1.5) translate(0.2rem, 0px);fill:white;width:3rem;aspect-ratio:1/1;cursor:pointer}#gallery-container-outer.svelte-1lktj31 #gallery-container #back-button.svelte-1lktj31>svg:active{filter:invert(1);background:black}#gallery-container-outer.svelte-1lktj31 #gallery-container #gallery-elements.svelte-1lktj31{width:100%;display:grid;grid-template-columns:repeat(3, 1fr);gap:10px;grid-auto-rows:minmax(100px, auto)}#gallery-container-outer.svelte-1lktj31 #gallery-container #gallery-elements #element.svelte-1lktj31{cursor:pointer;user-select:none}#gallery-container-outer.svelte-1lktj31 #gallery-container #gallery-elements #element #element-name.svelte-1lktj31{margin-bottom:0.5rem}#gallery-container-outer.svelte-1lktj31 #gallery-container #gallery-elements #element.svelte-1lktj31:active{background:white}#gallery-container-outer.svelte-1lktj31 #gallery-container #gallery-elements #element:active .svelte-1lktj31{color:black}#gallery-container-outer.svelte-1lktj31 #gallery-container #current-project.svelte-1lktj31{display:flex;justify-content:space-between;width:100%;margin-bottom:1rem}#gallery-container-outer.svelte-1lktj31 #gallery-container #current-project #project-options.svelte-1lktj31{display:flex;flex-direction:column;justify-content:space-between}#gallery-container-outer.svelte-1lktj31 #gallery-container #current-project #project-options .svelte-1lktj31{font-size:1.3rem}#gallery-container-outer.svelte-1lktj31 #gallery-container #current-project #project-options #project-save-button-title.svelte-1lktj31{margin-right:0.5rem}#gallery-container-outer.svelte-1lktj31 #gallery-container #current-project #project-options #project-save-button.svelte-1lktj31{margin-right:1.5rem;cursor:pointer;justify-content:flex-end;display:flex;flex-direction:row;align-items:center;height:2rem;max-width:30rem;width:100%}#gallery-container-outer.svelte-1lktj31 #gallery-container #current-project #project-options #project-save-button.svelte-1lktj31:active{filter:invert(1);background:black}#gallery-container-outer.svelte-1lktj31 #gallery-container #current-project #project-options #project-save-button .icon.svelte-1lktj31{width:2rem}#gallery-container-outer.svelte-1lktj31 #gallery-container #current-project #project-options #project-save-button .svelte-1lktj31{font-size:1rem}#gallery-container-outer.svelte-1lktj31 #gallery-container #current-project #project-options #project-save-button.svelte-1lktj31 svg{aspect-ratio:1/1;fill:white}.knob-container.svelte-1lktj31.svelte-1lktj31{cursor:pointer;box-sizing:border-box;-webkit-box-sizing:border-box;aspect-ratio:1/1;max-height:50%;height:100%;display:flex;justify-content:center;align-items:center;border-radius:50%;margin-right:1rem;margin-bottom:auto;margin-top:auto;pointer-events:all;user-select:none}.knob-container.svelte-1lktj31.svelte-1lktj31:hover{cursor:pointer}.knob.svelte-1lktj31.svelte-1lktj31{display:block;aspect-ratio:1/1;height:100%;padding:0;color:var(--text-color);fill:white;transform-origin:50% 50%}.knob.svelte-1lktj31.svelte-1lktj31:active{filter:invert(1);background:black}.knob.svelte-1lktj31 svg{fill:white;width:100%;height:100%}.knob-container.svelte-1lktj31.svelte-1lktj31{box-sizing:border-box;-webkit-box-sizing:border-box;aspect-ratio:1/1;max-height:50%;height:100%;display:flex;justify-content:center;align-items:center;margin-right:1rem;pointer-events:all;user-select:none;margin-bottom:auto;margin-top:auto;margin-right:0rem}.knob.svelte-1lktj31.svelte-1lktj31{cursor:pointer;display:block;aspect-ratio:1/1;height:100%;padding:0;color:var(--text-color);transform-origin:50% 50%}.knob.svelte-1lktj31.svelte-1lktj31:active{filter:invert(1);background:black}.knob.svelte-1lktj31 svg{fill:white;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FsbGVyeVdpZGdldC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBd1hrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJHYWxsZXJ5V2lkZ2V0LnN2ZWx0ZSJdfQ== */");
}

function GalleryWidget_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[38] = list[i];
	child_ctx[40] = i;
	return child_ctx;
}

// (18:1) {#if $gallery_open}
function create_if_block(ctx) {
	let div27;
	let div26;
	let div2;
	let div0;
	let t1;
	let div1;
	let t2;
	let div13;
	let img;
	let img_src_value;
	let t3;
	let div12;
	let div5;
	let div3;
	let t5;
	let div4;
	let t6;
	let div8;
	let div6;
	let t8;
	let div7;
	let t9;
	let div11;
	let div9;
	let t10_value = /*format_time*/ ctx[15](/*current_project*/ ctx[0].id) + "";
	let t10;
	let t11;
	let div10;
	let t12;
	let div24;
	let div15;
	let div14;
	let t14;
	let html_tag;
	let t15;
	let div17;
	let div16;
	let t17;
	let html_tag_1;
	let t18;
	let div23;
	let div18;
	let t19;
	let div19;
	let t21;
	let div20;
	let t22_value = /*resize_widget_canvas_size*/ ctx[13][0] + "";
	let t22;
	let t23;
	let t24_value = /*resize_widget_canvas_size*/ ctx[13][1] + "";
	let t24;
	let t25;
	let div21;
	let div21_style_value;
	let t26;
	let div22;
	let div23_style_value;
	let t27;
	let button;
	let t29;
	let div25;
	let mounted;
	let dispose;
	let each_value = ensure_array_like_dev(/*gallery_elements*/ ctx[12]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = GalleryWidget_svelte_create_each_block(GalleryWidget_svelte_get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div27 = dom_element("div");
			div26 = dom_element("div");
			div2 = dom_element("div");
			div0 = dom_element("div");
			div0.textContent = "Project";
			t1 = space();
			div1 = dom_element("div");
			t2 = space();
			div13 = dom_element("div");
			img = dom_element("img");
			t3 = space();
			div12 = dom_element("div");
			div5 = dom_element("div");
			div3 = dom_element("div");
			div3.textContent = "Save to dropbox";
			t5 = space();
			div4 = dom_element("div");
			t6 = space();
			div8 = dom_element("div");
			div6 = dom_element("div");
			div6.textContent = "Download";
			t8 = space();
			div7 = dom_element("div");
			t9 = space();
			div11 = dom_element("div");
			div9 = dom_element("div");
			t10 = dom_text(t10_value);
			t11 = space();
			div10 = dom_element("div");
			t12 = space();
			div24 = dom_element("div");
			div15 = dom_element("div");
			div14 = dom_element("div");
			div14.textContent = "New file";
			t14 = space();
			html_tag = new HtmlTag(false);
			t15 = space();
			div17 = dom_element("div");
			div16 = dom_element("div");
			div16.textContent = "Resize";
			t17 = space();
			html_tag_1 = new HtmlTag(false);
			t18 = space();
			div23 = dom_element("div");
			div18 = dom_element("div");
			t19 = space();
			div19 = dom_element("div");
			div19.textContent = "Resize canvas";
			t21 = space();
			div20 = dom_element("div");
			t22 = dom_text(t22_value);
			t23 = dom_text(" x ");
			t24 = dom_text(t24_value);
			t25 = space();
			div21 = dom_element("div");
			t26 = space();
			div22 = dom_element("div");
			t27 = space();
			button = dom_element("button");
			button.textContent = "LOG INTO DROPBOX";
			t29 = space();
			div25 = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div0, "id", "project-title");
			attr_dev(div0, "class", "svelte-1lktj31");
			add_location(div0, GalleryWidget_svelte_file, 21, 5, 548);
			attr_dev(div1, "id", "back-button");
			attr_dev(div1, "role", "button");
			attr_dev(div1, "tabindex", "0");
			attr_dev(div1, "class", "svelte-1lktj31");
			add_location(div1, GalleryWidget_svelte_file, 22, 5, 591);
			attr_dev(div2, "id", "top-bar");
			attr_dev(div2, "class", "svelte-1lktj31");
			add_location(div2, GalleryWidget_svelte_file, 20, 4, 524);
			if (!src_url_equal(img.src, img_src_value = /*canvas_image_src*/ ctx[9])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "id", "canvas-preview-img");
			attr_dev(img, "alt", "");
			attr_dev(img, "class", "svelte-1lktj31");
			add_location(img, GalleryWidget_svelte_file, 33, 5, 841);
			attr_dev(div3, "id", "project-save-button-title");
			attr_dev(div3, "class", "svelte-1lktj31");
			add_location(div3, GalleryWidget_svelte_file, 36, 7, 1033);
			attr_dev(div4, "class", "icon svelte-1lktj31");
			set_style(div4, "transform", "translate(0px,0.2rem)");
			add_location(div4, GalleryWidget_svelte_file, 37, 7, 1098);
			attr_dev(div5, "id", "project-save-button");
			attr_dev(div5, "role", "button");
			attr_dev(div5, "tabindex", "0");
			attr_dev(div5, "class", "svelte-1lktj31");
			add_location(div5, GalleryWidget_svelte_file, 35, 6, 941);
			attr_dev(div6, "id", "project-save-button-title");
			attr_dev(div6, "class", "svelte-1lktj31");
			add_location(div6, GalleryWidget_svelte_file, 50, 7, 1640);
			attr_dev(div7, "class", "icon svelte-1lktj31");
			set_style(div7, "transform", "scale(1.34)");
			add_location(div7, GalleryWidget_svelte_file, 51, 7, 1698);
			attr_dev(div8, "id", "project-save-button");
			attr_dev(div8, "role", "button");
			attr_dev(div8, "tabindex", "0");
			attr_dev(div8, "class", "svelte-1lktj31");
			add_location(div8, GalleryWidget_svelte_file, 49, 6, 1548);
			attr_dev(div9, "id", "project-save-button-title");
			attr_dev(div9, "class", "svelte-1lktj31");
			add_location(div9, GalleryWidget_svelte_file, 56, 7, 1862);
			attr_dev(div10, "class", "icon svelte-1lktj31");
			add_location(div10, GalleryWidget_svelte_file, 57, 7, 1945);
			attr_dev(div11, "id", "project-save-button");
			attr_dev(div11, "class", "date svelte-1lktj31");
			add_location(div11, GalleryWidget_svelte_file, 55, 6, 1811);
			attr_dev(div12, "id", "project-options");
			attr_dev(div12, "class", "svelte-1lktj31");
			add_location(div12, GalleryWidget_svelte_file, 34, 5, 908);
			attr_dev(div13, "id", "current-project");
			attr_dev(div13, "class", "svelte-1lktj31");
			add_location(div13, GalleryWidget_svelte_file, 32, 4, 809);
			attr_dev(div14, "class", "svelte-1lktj31");
			add_location(div14, GalleryWidget_svelte_file, 76, 6, 2444);
			html_tag.a = null;
			attr_dev(div15, "id", "button");
			attr_dev(div15, "role", "button");
			attr_dev(div15, "tabindex", "0");
			attr_dev(div15, "class", "svelte-1lktj31");
			add_location(div15, GalleryWidget_svelte_file, 65, 5, 2072);
			attr_dev(div16, "draggable", "false");
			attr_dev(div16, "class", "svelte-1lktj31");
			add_location(div16, GalleryWidget_svelte_file, 88, 6, 2780);
			html_tag_1.a = null;
			attr_dev(div17, "id", "button");
			attr_dev(div17, "role", "button");
			attr_dev(div17, "tabindex", "0");
			attr_dev(div17, "class", "svelte-1lktj31");
			add_location(div17, GalleryWidget_svelte_file, 81, 5, 2521);
			attr_dev(div18, "id", "back-button");
			attr_dev(div18, "role", "button");
			attr_dev(div18, "tabindex", "0");
			set_style(div18, "margin-bottom", "0.45rem");
			attr_dev(div18, "class", "svelte-1lktj31");
			add_location(div18, GalleryWidget_svelte_file, 94, 6, 2951);
			set_style(div19, "margin-bottom", "1rem");
			attr_dev(div19, "class", "svelte-1lktj31");
			add_location(div19, GalleryWidget_svelte_file, 104, 6, 3177);
			set_style(div20, "margin-bottom", "1rem");
			attr_dev(div20, "class", "svelte-1lktj31");
			add_location(div20, GalleryWidget_svelte_file, 107, 6, 3252);

			attr_dev(div21, "style", div21_style_value = `
							background: white;
							width: 10rem;
							aspect-ratio: 1/${/*resize_widget_canvas_size*/ ctx[13][1] / /*resize_widget_canvas_size*/ ctx[13][0]}
						`);

			attr_dev(div21, "class", "svelte-1lktj31");
			add_location(div21, GalleryWidget_svelte_file, 110, 6, 3377);
			attr_dev(div22, "role", "button");
			attr_dev(div22, "tabindex", "0");
			attr_dev(div22, "id", "back-button");
			attr_dev(div22, "class", "ok-button svelte-1lktj31");
			set_style(div22, "margin-top", "1.14rem");
			add_location(div22, GalleryWidget_svelte_file, 116, 6, 3596);
			attr_dev(div23, "id", "size-modal");
			attr_dev(div23, "style", div23_style_value = /*size_modal_opened*/ ctx[6] ? "" : "display: none;");
			attr_dev(div23, "class", "svelte-1lktj31");
			add_location(div23, GalleryWidget_svelte_file, 93, 5, 2873);
			attr_dev(div24, "id", "options-bar");
			attr_dev(div24, "class", "svelte-1lktj31");
			add_location(div24, GalleryWidget_svelte_file, 64, 4, 2044);
			attr_dev(button, "id", "db-login-button");
			attr_dev(button, "class", "svelte-1lktj31");
			toggle_class(button, "hide", /*authed*/ ctx[11]);
			add_location(button, GalleryWidget_svelte_file, 133, 4, 4064);
			attr_dev(div25, "id", "gallery-elements");
			attr_dev(div25, "class", "svelte-1lktj31");
			add_location(div25, GalleryWidget_svelte_file, 136, 4, 4200);
			attr_dev(div26, "id", "gallery-container");
			attr_dev(div26, "class", "svelte-1lktj31");
			add_location(div26, GalleryWidget_svelte_file, 19, 3, 491);
			attr_dev(div27, "id", "gallery-container-outer");
			attr_dev(div27, "class", "svelte-1lktj31");
			add_location(div27, GalleryWidget_svelte_file, 18, 2, 453);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div27, anchor);
			append_dev(div27, div26);
			append_dev(div26, div2);
			append_dev(div2, div0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			div1.innerHTML = (forbid_default());
			append_dev(div26, t2);
			append_dev(div26, div13);
			append_dev(div13, img);
			append_dev(div13, t3);
			append_dev(div13, div12);
			append_dev(div12, div5);
			append_dev(div5, div3);
			append_dev(div5, t5);
			append_dev(div5, div4);
			div4.innerHTML = (capture_default());
			append_dev(div12, t6);
			append_dev(div12, div8);
			append_dev(div8, div6);
			append_dev(div8, t8);
			append_dev(div8, div7);
			div7.innerHTML = (download_default());
			append_dev(div12, t9);
			append_dev(div12, div11);
			append_dev(div11, div9);
			append_dev(div9, t10);
			append_dev(div11, t11);
			append_dev(div11, div10);
			div10.innerHTML = (time_default());
			append_dev(div26, t12);
			append_dev(div26, div24);
			append_dev(div24, div15);
			append_dev(div15, div14);
			append_dev(div15, t14);
			html_tag.m((launch_default()), div15);
			append_dev(div24, t15);
			append_dev(div24, div17);
			append_dev(div17, div16);
			append_dev(div17, t17);
			html_tag_1.m((resize_default()), div17);
			append_dev(div24, t18);
			append_dev(div24, div23);
			append_dev(div23, div18);
			div18.innerHTML = (forbid_default());
			append_dev(div23, t19);
			append_dev(div23, div19);
			append_dev(div23, t21);
			append_dev(div23, div20);
			append_dev(div20, t22);
			append_dev(div20, t23);
			append_dev(div20, t24);
			append_dev(div23, t25);
			append_dev(div23, div21);
			append_dev(div23, t26);
			append_dev(div23, div22);
			div22.innerHTML = (ok_default());
			append_dev(div26, t27);
			append_dev(div26, button);
			append_dev(div26, t29);
			append_dev(div26, div25);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div25, null);
				}
			}

			if (!mounted) {
				dispose = [
					listen_dev(div1, "click", /*click_handler_1*/ ctx[22], false, false, false, false),
					listen_dev(div5, "click", /*save_to_dropbox*/ ctx[18], false, false, false, false),
					listen_dev(div8, "click", /*download_image*/ ctx[17], false, false, false, false),
					listen_dev(div15, "click", /*click_handler_2*/ ctx[23], false, false, false, false),
					listen_dev(div17, "click", /*click_handler_3*/ ctx[24], false, false, false, false),
					listen_dev(div18, "click", /*click_handler_4*/ ctx[25], false, false, false, false),
					listen_dev(div21, "pointerdown", /*resize_widget_pointer_down*/ ctx[19], false, false, false, false),
					listen_dev(div22, "click", /*click_handler_5*/ ctx[26], false, false, false, false),
					listen_dev(button, "click", /*click_handler_6*/ ctx[27], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*canvas_image_src*/ 512 && !src_url_equal(img.src, img_src_value = /*canvas_image_src*/ ctx[9])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*current_project*/ 1 && t10_value !== (t10_value = /*format_time*/ ctx[15](/*current_project*/ ctx[0].id) + "")) set_data_dev(t10, t10_value);
			if (dirty[0] & /*resize_widget_canvas_size*/ 8192 && t22_value !== (t22_value = /*resize_widget_canvas_size*/ ctx[13][0] + "")) set_data_dev(t22, t22_value);
			if (dirty[0] & /*resize_widget_canvas_size*/ 8192 && t24_value !== (t24_value = /*resize_widget_canvas_size*/ ctx[13][1] + "")) set_data_dev(t24, t24_value);

			if (dirty[0] & /*resize_widget_canvas_size*/ 8192 && div21_style_value !== (div21_style_value = `
							background: white;
							width: 10rem;
							aspect-ratio: 1/${/*resize_widget_canvas_size*/ ctx[13][1] / /*resize_widget_canvas_size*/ ctx[13][0]}
						`)) {
				attr_dev(div21, "style", div21_style_value);
			}

			if (dirty[0] & /*size_modal_opened*/ 64 && div23_style_value !== (div23_style_value = /*size_modal_opened*/ ctx[6] ? "" : "display: none;")) {
				attr_dev(div23, "style", div23_style_value);
			}

			if (dirty[0] & /*authed*/ 2048) {
				toggle_class(button, "hide", /*authed*/ ctx[11]);
			}

			if (dirty[0] & /*gallery_elements, current_project, is_safe_to_switch_to_new_project, dbx, load_project, format_time*/ 37937) {
				each_value = ensure_array_like_dev(/*gallery_elements*/ ctx[12]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = GalleryWidget_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = GalleryWidget_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div25, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div27);
			}

			destroy_each(each_blocks, detaching);
			mounted = false;
			utils_run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(18:1) {#if $gallery_open}",
		ctx
	});

	return block;
}

// (138:5) {#each gallery_elements as element, i}
function GalleryWidget_svelte_create_each_block(ctx) {
	let div1;
	let div0;
	let t0_value = /*format_time*/ ctx[15](/*element*/ ctx[38].name) + "";
	let t0;
	let t1;
	let img;
	let img_src_value;
	let t2;
	let div1_style_value;
	let mounted;
	let dispose;

	function click_handler_7() {
		return /*click_handler_7*/ ctx[28](/*element*/ ctx[38]);
	}

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			t0 = dom_text(t0_value);
			t1 = space();
			img = dom_element("img");
			t2 = space();
			attr_dev(div0, "id", "element-name");
			attr_dev(div0, "class", "svelte-1lktj31");
			add_location(div0, GalleryWidget_svelte_file, 157, 7, 5024);
			attr_dev(img, "draggable", "false");
			if (!src_url_equal(img.src, img_src_value = /*element*/ ctx[38].image_src)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "id", "canvas-preview-img");
			attr_dev(img, "alt", "");
			attr_dev(img, "class", "svelte-1lktj31");
			add_location(img, GalleryWidget_svelte_file, 160, 7, 5105);
			attr_dev(div1, "id", "element");
			attr_dev(div1, "role", "button");
			attr_dev(div1, "tabindex", "0");

			attr_dev(div1, "style", div1_style_value = Number(/*element*/ ctx[38].name) === /*current_project*/ ctx[0].id
			? "border: 0.1rem solid white;"
			: "");

			attr_dev(div1, "class", "svelte-1lktj31");
			add_location(div1, GalleryWidget_svelte_file, 138, 6, 4278);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t0);
			append_dev(div1, t1);
			append_dev(div1, img);
			append_dev(div1, t2);

			if (!mounted) {
				dispose = listen_dev(div1, "click", click_handler_7, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*gallery_elements*/ 4096 && t0_value !== (t0_value = /*format_time*/ ctx[15](/*element*/ ctx[38].name) + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*gallery_elements*/ 4096 && !src_url_equal(img.src, img_src_value = /*element*/ ctx[38].image_src)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*gallery_elements, current_project*/ 4097 && div1_style_value !== (div1_style_value = Number(/*element*/ ctx[38].name) === /*current_project*/ ctx[0].id
			? "border: 0.1rem solid white;"
			: "")) {
				attr_dev(div1, "style", div1_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: GalleryWidget_svelte_create_each_block.name,
		type: "each",
		source: "(138:5) {#each gallery_elements as element, i}",
		ctx
	});

	return block;
}

function GalleryWidget_svelte_create_fragment(ctx) {
	let div1;
	let div0;
	let t;
	let mounted;
	let dispose;
	let if_block = /*$gallery_open*/ ctx[14] && create_if_block(ctx);

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			t = space();
			if (if_block) if_block.c();
			attr_dev(div0, "class", "knob svelte-1lktj31");
			attr_dev(div0, "role", "button");
			attr_dev(div0, "tabindex", "0");
			add_location(div0, GalleryWidget_svelte_file, 3, 1, 60);
			attr_dev(div1, "class", "knob-container svelte-1lktj31");
			add_location(div1, GalleryWidget_svelte_file, 2, 0, 30);
		},
		l: function claim(nodes) {
			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			div0.innerHTML = (solve_default());
			append_dev(div1, t);
			if (if_block) if_block.m(div1, null);

			if (!mounted) {
				dispose = listen_dev(div0, "click", /*click_handler*/ ctx[21], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*$gallery_open*/ ctx[14]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: GalleryWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const resize_widget_pixel_range = 200;
const GalleryWidget_svelte_min = 0;
const GalleryWidget_svelte_max = 4;

function GalleryWidget_svelte_instance($$self, $$props, $$invalidate) {
	let valueRange;
	let $gallery_open;
	validate_store(gallery_open, 'gallery_open');
	component_subscribe($$self, gallery_open, $$value => $$invalidate(14, $gallery_open = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('GalleryWidget', slots, []);
	let { current_project } = $$props;
	let { get_current_canvas_as_image } = $$props;
	let { resize_project } = $$props;
	let { new_project } = $$props;
	let { load_project } = $$props;
	let { project_has_been_modified } = $$props;

	const format_time = t => {
		return new Date(Number(t)).toLocaleString('en-GB', {
			hourCycle: 'h23',
			day: "2-digit",
			month: "2-digit",
			year: "numeric",
			hour: "2-digit",
			minute: "2-digit"
		}).replace(',', '');
	};

	let size_modal_opened = false;
	let canvas_image = undefined;
	let canvas_image_blob = undefined;
	let canvas_image_src = '';

	class Element {
		name;
		image_src;

		constructor(name, image_src) {
			this.name = name;
			this.image_src = image_src;
		}
	}

	let dbx;
	const dbx_auther = new DropboxAuther();
	let authed = false;
	let gallery_elements = [];

	const log_into_dropbox = async () => {
		await dbx_auther.doAuth();
	};

	const is_safe_to_switch_to_new_project = async () => {
		let project_is_saved_to_dropbox = false;

		if (!dbx_auther.authed) {
			project_is_saved_to_dropbox = true;
		} else {
			let response = await dbx.filesListFolder({ path: '' });

			for (let element of response.result.entries) {
				let proj_name = Number(element.name.slice(0, -5));

				if (proj_name === current_project.id) {
					project_is_saved_to_dropbox = true;
					break;
				}
			}
		}

		if (project_has_been_modified || !project_is_saved_to_dropbox) {
			return false;
		} else {
			return true;
		}
	};

	const download_image = async () => {
		const link = document.createElement('a');
		link.href = canvas_image.src;
		link.download = current_project.id + '.png';
		link.click();
	};

	const refetch_canvases = async () => {
		let response = await dbx.filesListFolder({ path: '' });
		console.log(response);
		$$invalidate(12, gallery_elements = []);

		for (let element of response.result.entries) {
			if (element.name.endsWith(".json")) {
				let proj_name = element.name.slice(0, -5);
				let image = await dbx.filesDownload({ path: '/' + proj_name + '.png' });
				let binary = image.result.fileBlob;

				const blobToDataURL = blob => {
					return new Promise((resolve, reject) => {
							const reader = new FileReader();
							reader.onload = _e => resolve(reader.result);
							reader.onerror = _e => reject(reader.error);
							reader.onabort = _e => reject(new Error("Read aborted"));
							reader.readAsDataURL(blob);
						});
				};

				$$invalidate(12, gallery_elements = [...gallery_elements, new Element(proj_name, await blobToDataURL(binary))]);
			}
		}
	};

	const save_to_dropbox = async () => {
		floating_modal_message.set("Starting upload to dropbox.");

		let r = await dbx.filesUpload({
			path: '/' + current_project.id + '.json',
			contents: JSON.stringify(current_project),
			mode: "overwrite"
		});

		r = await dbx.filesUpload({
			path: '/' + current_project.id + '.png',
			contents: await (await fetch(canvas_image.src)).blob(),
			mode: "overwrite"
		});

		floating_modal_message.set("Upload to dropbox succesful.");
		$$invalidate(20, project_has_been_modified = false);
		await refetch_canvases();
	};

	let resize_widget_canvas_size = [0, 0];
	let resize_widget_start_y = 0;
	let resize_wdiget_start_value = [0, 0];
	let resize_widget_start_x = 0;

	function resize_widget_pointer_move({ clientX, clientY }) {
		let valueDiffY = valueRange * (resize_widget_start_y - clientY) / resize_widget_pixel_range;
		let valueDiffX = valueRange * (resize_widget_start_x - clientX) / resize_widget_pixel_range;
		$$invalidate(13, resize_widget_canvas_size[0] = resize_wdiget_start_value[0] - valueDiffX * 1000, resize_widget_canvas_size);
		$$invalidate(13, resize_widget_canvas_size[1] = resize_wdiget_start_value[1] + valueDiffY * 1000, resize_widget_canvas_size);
	}

	function resize_widget_pointer_down(e) {
		let { clientX, clientY } = e;
		console.log('down');
		resize_widget_start_y = clientY;
		resize_widget_start_x = clientX;
		resize_wdiget_start_value = [...resize_widget_canvas_size];
		window.addEventListener('pointermove', resize_widget_pointer_move);
		window.addEventListener('pointerup', resize_widget_pointer_up);
		e.stopPropagation();
	}

	function resize_widget_pointer_up() {
		window.removeEventListener('pointermove', resize_widget_pointer_move);
		window.removeEventListener('pointerup', resize_widget_pointer_up);
	}

	onMount(async () => {
		await dbx_auther.init();
		await dbx_auther.try_init_dropbox();
		$$invalidate(11, authed = dbx_auther.authed);
		$$invalidate(10, dbx = dbx_auther.dbx);

		if (authed) {
			refetch_canvases();
		}
	});

	$$self.$$.on_mount.push(function () {
		if (current_project === undefined && !('current_project' in $$props || $$self.$$.bound[$$self.$$.props['current_project']])) {
			GalleryWidget_svelte_console_1.warn("<GalleryWidget> was created without expected prop 'current_project'");
		}

		if (get_current_canvas_as_image === undefined && !('get_current_canvas_as_image' in $$props || $$self.$$.bound[$$self.$$.props['get_current_canvas_as_image']])) {
			GalleryWidget_svelte_console_1.warn("<GalleryWidget> was created without expected prop 'get_current_canvas_as_image'");
		}

		if (resize_project === undefined && !('resize_project' in $$props || $$self.$$.bound[$$self.$$.props['resize_project']])) {
			GalleryWidget_svelte_console_1.warn("<GalleryWidget> was created without expected prop 'resize_project'");
		}

		if (new_project === undefined && !('new_project' in $$props || $$self.$$.bound[$$self.$$.props['new_project']])) {
			GalleryWidget_svelte_console_1.warn("<GalleryWidget> was created without expected prop 'new_project'");
		}

		if (load_project === undefined && !('load_project' in $$props || $$self.$$.bound[$$self.$$.props['load_project']])) {
			GalleryWidget_svelte_console_1.warn("<GalleryWidget> was created without expected prop 'load_project'");
		}

		if (project_has_been_modified === undefined && !('project_has_been_modified' in $$props || $$self.$$.bound[$$self.$$.props['project_has_been_modified']])) {
			GalleryWidget_svelte_console_1.warn("<GalleryWidget> was created without expected prop 'project_has_been_modified'");
		}
	});

	const writable_props = [
		'current_project',
		'get_current_canvas_as_image',
		'resize_project',
		'new_project',
		'load_project',
		'project_has_been_modified'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') GalleryWidget_svelte_console_1.warn(`<GalleryWidget> was created with unknown prop '${key}'`);
	});

	const click_handler = async () => {
		// gallery_open = !gallery_open
		gallery_open.set(true);

		let [_canvas_image, blob] = await get_current_canvas_as_image();
		$$invalidate(7, canvas_image = _canvas_image);
		$$invalidate(9, canvas_image_src = canvas_image.src);
		$$invalidate(8, canvas_image_blob = blob);
		console.log(canvas_image.src);
	};

	const click_handler_1 = () => {
		// gallery_open = !gallery_open
		gallery_open.set(false);
	};

	const click_handler_2 = async () => {
		let safe = await is_safe_to_switch_to_new_project();

		safe = safe
		? safe
		: confirm('Are you sure you want to create another project? This one is not saved.');

		if (safe) {
			new_project();

			// gallery_open = false
			gallery_open.set(false);
		}
	};

	const click_handler_3 = async () => {
		$$invalidate(6, size_modal_opened = true);
		$$invalidate(13, resize_widget_canvas_size[0] = current_project.canvasRes[0], resize_widget_canvas_size);
		$$invalidate(13, resize_widget_canvas_size[1] = current_project.canvasRes[1], resize_widget_canvas_size);
	};

	const click_handler_4 = () => {
		$$invalidate(6, size_modal_opened = false);
	};

	const click_handler_5 = () => {
		resize_project(resize_widget_canvas_size);
		$$invalidate(6, size_modal_opened = false);

		// gallery_open = false
		gallery_open.set(false);
	};

	const click_handler_6 = async () => await log_into_dropbox();

	const click_handler_7 = async element => {
		let safe = await is_safe_to_switch_to_new_project();

		safe = safe
		? safe
		: confirm('Are you sure you want to switch to another project? This one is not saved.');

		if (safe) {
			let proj = await dbx.filesDownload({ path: '/' + element.name + '.json' });

			// @ts-ignore
			let binary = await proj.result.fileBlob.text();

			let binary_json = JSON.parse(binary);
			load_project(binary_json);

			// gallery_open = false
			gallery_open.set(false);
		}
	};

	$$self.$$set = $$props => {
		if ('current_project' in $$props) $$invalidate(0, current_project = $$props.current_project);
		if ('get_current_canvas_as_image' in $$props) $$invalidate(1, get_current_canvas_as_image = $$props.get_current_canvas_as_image);
		if ('resize_project' in $$props) $$invalidate(2, resize_project = $$props.resize_project);
		if ('new_project' in $$props) $$invalidate(3, new_project = $$props.new_project);
		if ('load_project' in $$props) $$invalidate(4, load_project = $$props.load_project);
		if ('project_has_been_modified' in $$props) $$invalidate(20, project_has_been_modified = $$props.project_has_been_modified);
	};

	$$self.$capture_state = () => ({
		solveIcon: (solve_default()),
		launchIcon: (launch_default()),
		resizeIcon: (resize_default()),
		forbidIcon: (forbid_default()),
		okIcon: (ok_default()),
		captureIcon: (capture_default()),
		downloadIcon: (download_default()),
		timeIcon: (time_default()),
		Dropbox: Dropbox_sdk_min.Dropbox,
		DropboxAuth: Dropbox_sdk_min.DropboxAuth,
		onMount: onMount,
		DropboxAuther: DropboxAuther,
		floating_modal_message: floating_modal_message,
		gallery_open: gallery_open,
		current_project,
		get_current_canvas_as_image,
		resize_project,
		new_project,
		load_project,
		project_has_been_modified,
		format_time,
		size_modal_opened,
		canvas_image,
		canvas_image_blob,
		canvas_image_src,
		Element,
		dbx,
		dbx_auther,
		authed,
		gallery_elements,
		log_into_dropbox,
		is_safe_to_switch_to_new_project,
		download_image,
		refetch_canvases,
		save_to_dropbox,
		resize_widget_pixel_range,
		min: GalleryWidget_svelte_min,
		max: GalleryWidget_svelte_max,
		resize_widget_canvas_size,
		resize_widget_start_y,
		resize_wdiget_start_value,
		resize_widget_start_x,
		resize_widget_pointer_move,
		resize_widget_pointer_down,
		resize_widget_pointer_up,
		valueRange,
		$gallery_open
	});

	$$self.$inject_state = $$props => {
		if ('current_project' in $$props) $$invalidate(0, current_project = $$props.current_project);
		if ('get_current_canvas_as_image' in $$props) $$invalidate(1, get_current_canvas_as_image = $$props.get_current_canvas_as_image);
		if ('resize_project' in $$props) $$invalidate(2, resize_project = $$props.resize_project);
		if ('new_project' in $$props) $$invalidate(3, new_project = $$props.new_project);
		if ('load_project' in $$props) $$invalidate(4, load_project = $$props.load_project);
		if ('project_has_been_modified' in $$props) $$invalidate(20, project_has_been_modified = $$props.project_has_been_modified);
		if ('size_modal_opened' in $$props) $$invalidate(6, size_modal_opened = $$props.size_modal_opened);
		if ('canvas_image' in $$props) $$invalidate(7, canvas_image = $$props.canvas_image);
		if ('canvas_image_blob' in $$props) $$invalidate(8, canvas_image_blob = $$props.canvas_image_blob);
		if ('canvas_image_src' in $$props) $$invalidate(9, canvas_image_src = $$props.canvas_image_src);
		if ('dbx' in $$props) $$invalidate(10, dbx = $$props.dbx);
		if ('authed' in $$props) $$invalidate(11, authed = $$props.authed);
		if ('gallery_elements' in $$props) $$invalidate(12, gallery_elements = $$props.gallery_elements);
		if ('resize_widget_canvas_size' in $$props) $$invalidate(13, resize_widget_canvas_size = $$props.resize_widget_canvas_size);
		if ('resize_widget_start_y' in $$props) resize_widget_start_y = $$props.resize_widget_start_y;
		if ('resize_wdiget_start_value' in $$props) resize_wdiget_start_value = $$props.resize_wdiget_start_value;
		if ('resize_widget_start_x' in $$props) resize_widget_start_x = $$props.resize_widget_start_x;
		if ('valueRange' in $$props) valueRange = $$props.valueRange;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$: valueRange = GalleryWidget_svelte_max - GalleryWidget_svelte_min;

	return [
		current_project,
		get_current_canvas_as_image,
		resize_project,
		new_project,
		load_project,
		is_safe_to_switch_to_new_project,
		size_modal_opened,
		canvas_image,
		canvas_image_blob,
		canvas_image_src,
		dbx,
		authed,
		gallery_elements,
		resize_widget_canvas_size,
		$gallery_open,
		format_time,
		log_into_dropbox,
		download_image,
		save_to_dropbox,
		resize_widget_pointer_down,
		project_has_been_modified,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		click_handler_7
	];
}

class GalleryWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			GalleryWidget_svelte_instance,
			GalleryWidget_svelte_create_fragment,
			safe_not_equal,
			{
				current_project: 0,
				get_current_canvas_as_image: 1,
				resize_project: 2,
				new_project: 3,
				load_project: 4,
				project_has_been_modified: 20,
				is_safe_to_switch_to_new_project: 5
			},
			GalleryWidget_svelte_add_css,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GalleryWidget",
			options,
			id: GalleryWidget_svelte_create_fragment.name
		});
	}

	get current_project() {
		return this.$$.ctx[0];
	}

	set current_project(current_project) {
		this.$$set({ current_project });
		scheduler_flush();
	}

	get get_current_canvas_as_image() {
		return this.$$.ctx[1];
	}

	set get_current_canvas_as_image(get_current_canvas_as_image) {
		this.$$set({ get_current_canvas_as_image });
		scheduler_flush();
	}

	get resize_project() {
		return this.$$.ctx[2];
	}

	set resize_project(resize_project) {
		this.$$set({ resize_project });
		scheduler_flush();
	}

	get new_project() {
		return this.$$.ctx[3];
	}

	set new_project(new_project) {
		this.$$set({ new_project });
		scheduler_flush();
	}

	get load_project() {
		return this.$$.ctx[4];
	}

	set load_project(load_project) {
		this.$$set({ load_project });
		scheduler_flush();
	}

	get project_has_been_modified() {
		return this.$$.ctx[20];
	}

	set project_has_been_modified(project_has_been_modified) {
		this.$$set({ project_has_been_modified });
		scheduler_flush();
	}

	get is_safe_to_switch_to_new_project() {
		return this.$$.ctx[5];
	}

	set is_safe_to_switch_to_new_project(value) {
		throw new Error_1("<GalleryWidget>: Cannot set read-only property 'is_safe_to_switch_to_new_project'");
	}
}

/* harmony default export */ const GalleryWidget_svelte = (GalleryWidget);
;// CONCATENATED MODULE: ./src/components/FloatingModal.svelte
/* src/components/FloatingModal.svelte generated by Svelte v4.0.0 */




const FloatingModal_svelte_file = "src/components/FloatingModal.svelte";

function FloatingModal_svelte_add_css(target) {
	append_styles(target, "svelte-mamaeg", ".svelte-mamaeg.svelte-mamaeg{pointer-events:none}#floating-modal.svelte-mamaeg.svelte-mamaeg{position:fixed;width:fit-content;height:fit-content;top:50%;left:50%;transform:translate(-50%, -50%);z-index:100}#floating-modal.svelte-mamaeg #text.svelte-mamaeg{backdrop-filter:blur(0.3rem) invert(0.3);padding:1rem;border-radius:0.5rem;pointer-events:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmxvYXRpbmdNb2RhbC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNkNrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJGbG9hdGluZ01vZGFsLnN2ZWx0ZSJdfQ== */");
}

function FloatingModal_svelte_create_fragment(ctx) {
	let div1;
	let div0;
	let t;
	let div0_style_value;

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			t = dom_text(/*displayed_message*/ ctx[0]);
			attr_dev(div0, "id", "text");

			attr_dev(div0, "style", div0_style_value = `opacity: ${/*opacity*/ ctx[2]};
    transition: opacity ${/*fading_in*/ ctx[1] ? fade_in_t : fade_out_t}s;`);

			attr_dev(div0, "class", "svelte-mamaeg");
			add_location(div0, FloatingModal_svelte_file, 36, 3, 779);
			attr_dev(div1, "id", "floating-modal");
			attr_dev(div1, "class", "svelte-mamaeg");
			add_location(div1, FloatingModal_svelte_file, 35, 2, 750);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*displayed_message*/ 1) set_data_dev(t, /*displayed_message*/ ctx[0]);

			if (dirty & /*opacity, fading_in*/ 6 && div0_style_value !== (div0_style_value = `opacity: ${/*opacity*/ ctx[2]};
    transition: opacity ${/*fading_in*/ ctx[1] ? fade_in_t : fade_out_t}s;`)) {
				attr_dev(div0, "style", div0_style_value);
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: FloatingModal_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const display_time = 1;
const fade_in_t = 0.2;
const fade_out_t = 1;

function FloatingModal_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FloatingModal', slots, []);
	let seconds_since_modal = 0;
	let displayed_message = undefined;
	let fading_in = true;
	let opacity = 0;

	floating_modal_message.subscribe(message => {
		if (message) {
			$$invalidate(0, displayed_message = message);
			$$invalidate(2, opacity = 1);
			$$invalidate(1, fading_in = true);

			setTimeout(
				() => {
					$$invalidate(2, opacity = 0);
					$$invalidate(1, fading_in = false);

					setTimeout(
						() => {
							$$invalidate(0, displayed_message = undefined);
						},
						fade_out_t * 1000
					);
				},
				display_time * 1000
			);

			floating_modal_message.set(undefined);
		}
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FloatingModal> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		floating_modal_message: floating_modal_message,
		seconds_since_modal,
		displayed_message,
		display_time,
		fade_in_t,
		fade_out_t,
		fading_in,
		opacity
	});

	$$self.$inject_state = $$props => {
		if ('seconds_since_modal' in $$props) seconds_since_modal = $$props.seconds_since_modal;
		if ('displayed_message' in $$props) $$invalidate(0, displayed_message = $$props.displayed_message);
		if ('fading_in' in $$props) $$invalidate(1, fading_in = $$props.fading_in);
		if ('opacity' in $$props) $$invalidate(2, opacity = $$props.opacity);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [displayed_message, fading_in, opacity];
}

class FloatingModal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, FloatingModal_svelte_instance, FloatingModal_svelte_create_fragment, safe_not_equal, {}, FloatingModal_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FloatingModal",
			options,
			id: FloatingModal_svelte_create_fragment.name
		});
	}
}

/* harmony default export */ const FloatingModal_svelte = (FloatingModal);
// EXTERNAL MODULE: ./public/plug.svg
var plug = __webpack_require__(801);
var plug_default = /*#__PURE__*/__webpack_require__.n(plug);
;// CONCATENATED MODULE: ./src/components/PickColourWidget.svelte
/* src/components/PickColourWidget.svelte generated by Svelte v4.0.0 */




const PickColourWidget_svelte_file = "src/components/PickColourWidget.svelte";

function PickColourWidget_svelte_add_css(target) {
	append_styles(target, "svelte-blhu5d", ".picking.svelte-blhu5d{filter:invert();background:black}.svelte-blhu5d{user-select:none;-webkit-tap-highlight-color:transparent}.knob-container.svelte-blhu5d{cursor:pointer;&:hover{\n      cursor: pointer;\n    };box-sizing:border-box;-webkit-box-sizing:border-box;aspect-ratio:1/1;max-height:50%;height:100%;display:flex;justify-content:center;align-items:center;border-radius:50%;margin-right:1rem;margin-bottom:auto;margin-top:auto;pointer-events:all;user-select:none}.knob.svelte-blhu5d{&:active{\n      filter: invert(1);\n      background: black;\n    };display:block;aspect-ratio:1/1;height:100%;padding:0;color:var(--text-color);fill:white;transform-origin:50% 50%}.knob.svelte-blhu5d svg{fill:white;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGlja0NvbG91cldpZGdldC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBQ0EsdUJBQ0EsZ0JBQ0EsZ0JBQ0EsQ0FDQSxlQUNBLGlCQUNBLHVDQUNBLENDUEEsOEJBQ0EsZUFDQTtBQUNBO0FBQ0EsTUFDQSxzQkFDQSw4QkFHQSxpQkFDQSxlQUNBLFlBQ0EsYUFDQSx1QkFDQSxtQkFDQSxrQkFDQSxrQkFDQSxtQkFDQSxnQkFDQSxtQkFDQSxnQkFDQSxDQUlBLG9CQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQ0EsY0FDQSxpQkFDQSxZQUVBLFVBQ0Esd0JBQ0EsV0FDQSx3QkFDQSxDQUVBLHdCQUNBLFdBQ0EsV0FDQSxXQUNBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL3NwbHVuZ2Uvc3BsdW5nZS9zcmMvY29tcG9uZW50cy9QaWNrQ29sb3VyV2lkZ2V0LnN2ZWx0ZSIsIi9ob21lL3J1bm5lci93b3JrL3NwbHVuZ2Uvc3BsdW5nZS9zcmMvc3R5bGVzL2ljb24uc2NzcyJdfQ== */");
}

function PickColourWidget_svelte_create_fragment(ctx) {
	let div1;
	let div0;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			attr_dev(div0, "class", "knob svelte-blhu5d");
			toggle_class(div0, "picking", /*picking*/ ctx[0]);
			add_location(div0, PickColourWidget_svelte_file, 3, 1, 115);
			attr_dev(div1, "class", "knob-container svelte-blhu5d");
			add_location(div1, PickColourWidget_svelte_file, 2, 0, 30);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			div0.innerHTML = (plug_default());
			/*div1_binding*/ ctx[5](div1);

			if (!mounted) {
				dispose = listen_dev(div1, "pointerdown", /*pointerDown*/ ctx[2], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*picking*/ 1) {
				toggle_class(div0, "picking", /*picking*/ ctx[0]);
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			/*div1_binding*/ ctx[5](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: PickColourWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function PickColourWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PickColourWidget', slots, []);
	let { pick_from_canvas } = $$props;
	let pickerElement;
	let { picking = false } = $$props;
	let picked_col = [0, 0, 0];
	let { just_finished_pick = false } = $$props;

	function pointerMove({ clientX, clientY }) {
		pick_from_canvas();
	}

	const pointerUp = () => {
		$$invalidate(0, picking = false);
		$$invalidate(3, just_finished_pick = true);
		window.removeEventListener('pointermove', pointerMove);
		window.removeEventListener('pointerup', pointerUp);
	};

	const pointerDown = e => {
		$$invalidate(0, picking = true);
		window.addEventListener('pointermove', pointerMove);
		window.addEventListener('pointerup', pointerUp);
		e.stopPropagation();
	};

	$$self.$$.on_mount.push(function () {
		if (pick_from_canvas === undefined && !('pick_from_canvas' in $$props || $$self.$$.bound[$$self.$$.props['pick_from_canvas']])) {
			console.warn("<PickColourWidget> was created without expected prop 'pick_from_canvas'");
		}
	});

	const writable_props = ['pick_from_canvas', 'picking', 'just_finished_pick'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PickColourWidget> was created with unknown prop '${key}'`);
	});

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			pickerElement = $$value;
			$$invalidate(1, pickerElement);
		});
	}

	$$self.$$set = $$props => {
		if ('pick_from_canvas' in $$props) $$invalidate(4, pick_from_canvas = $$props.pick_from_canvas);
		if ('picking' in $$props) $$invalidate(0, picking = $$props.picking);
		if ('just_finished_pick' in $$props) $$invalidate(3, just_finished_pick = $$props.just_finished_pick);
	};

	$$self.$capture_state = () => ({
		pickIcon: (plug_default()),
		pick_from_canvas,
		pickerElement,
		picking,
		picked_col,
		just_finished_pick,
		pointerMove,
		pointerUp,
		pointerDown
	});

	$$self.$inject_state = $$props => {
		if ('pick_from_canvas' in $$props) $$invalidate(4, pick_from_canvas = $$props.pick_from_canvas);
		if ('pickerElement' in $$props) $$invalidate(1, pickerElement = $$props.pickerElement);
		if ('picking' in $$props) $$invalidate(0, picking = $$props.picking);
		if ('picked_col' in $$props) picked_col = $$props.picked_col;
		if ('just_finished_pick' in $$props) $$invalidate(3, just_finished_pick = $$props.just_finished_pick);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		picking,
		pickerElement,
		pointerDown,
		just_finished_pick,
		pick_from_canvas,
		div1_binding
	];
}

class PickColourWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			PickColourWidget_svelte_instance,
			PickColourWidget_svelte_create_fragment,
			safe_not_equal,
			{
				pick_from_canvas: 4,
				picking: 0,
				just_finished_pick: 3
			},
			PickColourWidget_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PickColourWidget",
			options,
			id: PickColourWidget_svelte_create_fragment.name
		});
	}

	get pick_from_canvas() {
		return this.$$.ctx[4];
	}

	set pick_from_canvas(pick_from_canvas) {
		this.$$set({ pick_from_canvas });
		scheduler_flush();
	}

	get picking() {
		return this.$$.ctx[0];
	}

	set picking(picking) {
		this.$$set({ picking });
		scheduler_flush();
	}

	get just_finished_pick() {
		return this.$$.ctx[3];
	}

	set just_finished_pick(just_finished_pick) {
		this.$$set({ just_finished_pick });
		scheduler_flush();
	}
}

/* harmony default export */ const PickColourWidget_svelte = (PickColourWidget);
;// CONCATENATED MODULE: ./src/components/TextureWidget.svelte
/* src/components/TextureWidget.svelte generated by Svelte v4.0.0 */





const TextureWidget_svelte_file = "src/components/TextureWidget.svelte";

function TextureWidget_svelte_add_css(target) {
	append_styles(target, "svelte-p1v8di", ".svelte-p1v8di.svelte-p1v8di.svelte-p1v8di{user-select:none;-webkit-tap-highlight-color:transparent}img.svelte-p1v8di.svelte-p1v8di.svelte-p1v8di:active{filter:invert(1);background:black}.knob-container-container.svelte-p1v8di.svelte-p1v8di.svelte-p1v8di{z-index:99;aspect-ratio:1/1;max-height:50%;margin-bottom:auto;margin-top:auto;margin-right:1.5rem;display:block;flex-direction:column;justify-content:center;align-items:center;pointer-events:all;user-select:none;cursor:pointer;min-width:7rem;border:1px solid white;min-width:0px;aspect-ratio:1/1;height:100%}.knob-container-container.svelte-p1v8di #dropdown.svelte-p1v8di.svelte-p1v8di{display:flex;flex-direction:column;position:static;height:unset;background:black}.knob-container-container.svelte-p1v8di #dropdown.svelte-p1v8di>img.svelte-p1v8di{z-index:10000000;aspect-ratio:1/1;width:100%}.knob-container-container.svelte-p1v8di>img.svelte-p1v8di.svelte-p1v8di{aspect-ratio:1/1;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dHVyZVdpZGdldC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBb0NrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUZXh0dXJlV2lkZ2V0LnN2ZWx0ZSJdfQ== */");
}

function TextureWidget_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[7] = i;
	return child_ctx;
}

// (9:1) {#if dropdown_toggled}
function TextureWidget_svelte_create_if_block(ctx) {
	let div;
	let each_value = ensure_array_like_dev(/*brush_textures*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = TextureWidget_svelte_create_each_block(TextureWidget_svelte_get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "id", "dropdown");
			attr_dev(div, "class", "svelte-p1v8di");
			add_location(div, TextureWidget_svelte_file, 9, 2, 235);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*brush_textures, selected_brush_texture, dropdown_toggled*/ 7) {
				each_value = ensure_array_like_dev(/*brush_textures*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = TextureWidget_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = TextureWidget_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: TextureWidget_svelte_create_if_block.name,
		type: "if",
		source: "(9:1) {#if dropdown_toggled}",
		ctx
	});

	return block;
}

// (12:4) {#if texture !== selected_brush_texture}
function create_if_block_1(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[4](/*texture*/ ctx[5]);
	}

	const block = {
		c: function create() {
			img = dom_element("img");
			if (!src_url_equal(img.src, img_src_value = /*texture*/ ctx[5].path)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "class", "svelte-p1v8di");
			add_location(img, TextureWidget_svelte_file, 12, 5, 345);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);

			if (!mounted) {
				dispose = listen_dev(img, "click", click_handler_1, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*brush_textures*/ 2 && !src_url_equal(img.src, img_src_value = /*texture*/ ctx[5].path)) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(12:4) {#if texture !== selected_brush_texture}",
		ctx
	});

	return block;
}

// (11:3) {#each brush_textures as texture, i}
function TextureWidget_svelte_create_each_block(ctx) {
	let if_block_anchor;
	let if_block = /*texture*/ ctx[5] !== /*selected_brush_texture*/ ctx[0] && create_if_block_1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*texture*/ ctx[5] !== /*selected_brush_texture*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: TextureWidget_svelte_create_each_block.name,
		type: "each",
		source: "(11:3) {#each brush_textures as texture, i}",
		ctx
	});

	return block;
}

function TextureWidget_svelte_create_fragment(ctx) {
	let div;
	let img;
	let img_src_value;
	let t;
	let mounted;
	let dispose;
	let if_block = /*dropdown_toggled*/ ctx[2] && TextureWidget_svelte_create_if_block(ctx);

	const block = {
		c: function create() {
			div = dom_element("div");
			img = dom_element("img");
			t = space();
			if (if_block) if_block.c();

			if (!src_url_equal(img.src, img_src_value = /*selected_brush_texture*/ ctx[0]
			? /*selected_brush_texture*/ ctx[0].path
			: '')) attr_dev(img, "src", img_src_value);

			attr_dev(img, "class", "svelte-p1v8di");
			add_location(img, TextureWidget_svelte_file, 3, 1, 70);
			attr_dev(div, "class", "knob-container-container svelte-p1v8di");
			add_location(div, TextureWidget_svelte_file, 2, 0, 30);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
			append_dev(div, t);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = listen_dev(img, "click", /*click_handler*/ ctx[3], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*selected_brush_texture*/ 1 && !src_url_equal(img.src, img_src_value = /*selected_brush_texture*/ ctx[0]
			? /*selected_brush_texture*/ ctx[0].path
			: '')) {
				attr_dev(img, "src", img_src_value);
			}

			if (/*dropdown_toggled*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = TextureWidget_svelte_create_if_block(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: TextureWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function TextureWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('TextureWidget', slots, []);
	let { brush_textures } = $$props;
	let { selected_brush_texture } = $$props;
	let dropdown_toggled = false;

	$$self.$$.on_mount.push(function () {
		if (brush_textures === undefined && !('brush_textures' in $$props || $$self.$$.bound[$$self.$$.props['brush_textures']])) {
			console.warn("<TextureWidget> was created without expected prop 'brush_textures'");
		}

		if (selected_brush_texture === undefined && !('selected_brush_texture' in $$props || $$self.$$.bound[$$self.$$.props['selected_brush_texture']])) {
			console.warn("<TextureWidget> was created without expected prop 'selected_brush_texture'");
		}
	});

	const writable_props = ['brush_textures', 'selected_brush_texture'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextureWidget> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(2, dropdown_toggled = !dropdown_toggled);
	};

	const click_handler_1 = texture => {
		$$invalidate(0, selected_brush_texture = texture);
		$$invalidate(2, dropdown_toggled = false);
	};

	$$self.$$set = $$props => {
		if ('brush_textures' in $$props) $$invalidate(1, brush_textures = $$props.brush_textures);
		if ('selected_brush_texture' in $$props) $$invalidate(0, selected_brush_texture = $$props.selected_brush_texture);
	};

	$$self.$capture_state = () => ({
		BrushType: BrushType,
		onMount: onMount,
		brush_textures,
		selected_brush_texture,
		dropdown_toggled
	});

	$$self.$inject_state = $$props => {
		if ('brush_textures' in $$props) $$invalidate(1, brush_textures = $$props.brush_textures);
		if ('selected_brush_texture' in $$props) $$invalidate(0, selected_brush_texture = $$props.selected_brush_texture);
		if ('dropdown_toggled' in $$props) $$invalidate(2, dropdown_toggled = $$props.dropdown_toggled);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		selected_brush_texture,
		brush_textures,
		dropdown_toggled,
		click_handler,
		click_handler_1
	];
}

class TextureWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			TextureWidget_svelte_instance,
			TextureWidget_svelte_create_fragment,
			safe_not_equal,
			{
				brush_textures: 1,
				selected_brush_texture: 0
			},
			TextureWidget_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TextureWidget",
			options,
			id: TextureWidget_svelte_create_fragment.name
		});
	}

	get brush_textures() {
		return this.$$.ctx[1];
	}

	set brush_textures(brush_textures) {
		this.$$set({ brush_textures });
		scheduler_flush();
	}

	get selected_brush_texture() {
		return this.$$.ctx[0];
	}

	set selected_brush_texture(selected_brush_texture) {
		this.$$set({ selected_brush_texture });
		scheduler_flush();
	}
}

/* harmony default export */ const TextureWidget_svelte = (TextureWidget);
;// CONCATENATED MODULE: ./src/components/BlendingColourSpaceWidget.svelte
/* src/components/BlendingColourSpaceWidget.svelte generated by Svelte v4.0.0 */


const { Object: BlendingColourSpaceWidget_svelte_Object_1 } = globals;


const BlendingColourSpaceWidget_svelte_file = "src/components/BlendingColourSpaceWidget.svelte";

function BlendingColourSpaceWidget_svelte_add_css(target) {
	append_styles(target, "svelte-t1h410", ".svelte-t1h410.svelte-t1h410.svelte-t1h410{user-select:none;-webkit-tap-highlight-color:transparent}div.svelte-t1h410.svelte-t1h410.svelte-t1h410:active{filter:invert(1);background:black}.knob-container-container.svelte-t1h410.svelte-t1h410.svelte-t1h410{z-index:99;margin-bottom:auto;margin-top:auto;margin-right:1.5rem;display:block;flex-direction:column;justify-content:center;align-items:center;pointer-events:all;user-select:none;cursor:pointer;min-width:7rem;border:1px solid white;min-width:0px}.knob-container-container.svelte-t1h410 #dropdown.svelte-t1h410.svelte-t1h410{display:flex;flex-direction:column;position:static;height:unset;background:black}.knob-container-container.svelte-t1h410 #dropdown.svelte-t1h410>div.svelte-t1h410{border:1px solid white;z-index:10000000;width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmxlbmRpbmdDb2xvdXJTcGFjZVdpZGdldC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBb0NrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJCbGVuZGluZ0NvbG91clNwYWNlV2lkZ2V0LnN2ZWx0ZSJdfQ== */");
}

function BlendingColourSpaceWidget_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[6] = i;
	return child_ctx;
}

// (4:1) {#if !dropdown_toggled}
function create_if_block_2(ctx) {
	let div;
	let t_value = BlendingColourSpace[/*selected_colour_space*/ ctx[0]] + "";
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = dom_element("div");
			t = dom_text(t_value);
			attr_dev(div, "class", "svelte-t1h410");
			add_location(div, BlendingColourSpaceWidget_svelte_file, 4, 1, 95);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler*/ ctx[2], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selected_colour_space*/ 1 && t_value !== (t_value = BlendingColourSpace[/*selected_colour_space*/ ctx[0]] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(4:1) {#if !dropdown_toggled}",
		ctx
	});

	return block;
}

// (9:1) {#if dropdown_toggled}
function BlendingColourSpaceWidget_svelte_create_if_block(ctx) {
	let div;
	let each_value = ensure_array_like_dev(Object.keys(BlendingColourSpace));
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = BlendingColourSpaceWidget_svelte_create_each_block(BlendingColourSpaceWidget_svelte_get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "id", "dropdown");
			attr_dev(div, "class", "svelte-t1h410");
			add_location(div, BlendingColourSpaceWidget_svelte_file, 9, 2, 230);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*Object, BlendingColourSpace, selected_colour_space, dropdown_toggled, isNaN*/ 3) {
				each_value = ensure_array_like_dev(Object.keys(BlendingColourSpace));
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = BlendingColourSpaceWidget_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = BlendingColourSpaceWidget_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BlendingColourSpaceWidget_svelte_create_if_block.name,
		type: "if",
		source: "(9:1) {#if dropdown_toggled}",
		ctx
	});

	return block;
}

// (12:4) {#if isNaN(BlendingColourSpace[colour_space])}
function BlendingColourSpaceWidget_svelte_create_if_block_1(ctx) {
	let div;
	let t0_value = BlendingColourSpace[/*colour_space*/ ctx[4]] + "";
	let t0;
	let t1;
	let div_style_value;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[3](/*colour_space*/ ctx[4]);
	}

	const block = {
		c: function create() {
			div = dom_element("div");
			t0 = dom_text(t0_value);
			t1 = space();
			attr_dev(div, "role", "button");
			attr_dev(div, "tabindex", "0");

			attr_dev(div, "style", div_style_value = // @ts-ignore
			/*colour_space*/ ctx[4] === /*selected_colour_space*/ ctx[0]
			? "background: black; filter: invert(1);"
			: "");

			attr_dev(div, "class", "svelte-t1h410");
			add_location(div, BlendingColourSpaceWidget_svelte_file, 12, 5, 369);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (!mounted) {
				dispose = listen_dev(div, "click", click_handler_1, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*selected_colour_space*/ 1 && div_style_value !== (div_style_value = // @ts-ignore
			/*colour_space*/ ctx[4] === /*selected_colour_space*/ ctx[0]
			? "background: black; filter: invert(1);"
			: "")) {
				attr_dev(div, "style", div_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BlendingColourSpaceWidget_svelte_create_if_block_1.name,
		type: "if",
		source: "(12:4) {#if isNaN(BlendingColourSpace[colour_space])}",
		ctx
	});

	return block;
}

// (11:3) {#each Object.keys(BlendingColourSpace) as colour_space, i}
function BlendingColourSpaceWidget_svelte_create_each_block(ctx) {
	let show_if = isNaN(BlendingColourSpace[/*colour_space*/ ctx[4]]);
	let if_block_anchor;
	let if_block = show_if && BlendingColourSpaceWidget_svelte_create_if_block_1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (show_if) if_block.p(ctx, dirty);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BlendingColourSpaceWidget_svelte_create_each_block.name,
		type: "each",
		source: "(11:3) {#each Object.keys(BlendingColourSpace) as colour_space, i}",
		ctx
	});

	return block;
}

function BlendingColourSpaceWidget_svelte_create_fragment(ctx) {
	let div;
	let t;
	let if_block0 = !/*dropdown_toggled*/ ctx[1] && create_if_block_2(ctx);
	let if_block1 = /*dropdown_toggled*/ ctx[1] && BlendingColourSpaceWidget_svelte_create_if_block(ctx);

	const block = {
		c: function create() {
			div = dom_element("div");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "knob-container-container svelte-t1h410");
			add_location(div, BlendingColourSpaceWidget_svelte_file, 2, 0, 30);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t);
			if (if_block1) if_block1.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (!/*dropdown_toggled*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*dropdown_toggled*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = BlendingColourSpaceWidget_svelte_create_if_block(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BlendingColourSpaceWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function BlendingColourSpaceWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BlendingColourSpaceWidget', slots, []);
	let { selected_colour_space } = $$props;
	let dropdown_toggled = false;

	$$self.$$.on_mount.push(function () {
		if (selected_colour_space === undefined && !('selected_colour_space' in $$props || $$self.$$.bound[$$self.$$.props['selected_colour_space']])) {
			console.warn("<BlendingColourSpaceWidget> was created without expected prop 'selected_colour_space'");
		}
	});

	const writable_props = ['selected_colour_space'];

	BlendingColourSpaceWidget_svelte_Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BlendingColourSpaceWidget> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(1, dropdown_toggled = true);
	};

	const click_handler_1 = colour_space => {
		// @ts-ignore
		$$invalidate(0, selected_colour_space = colour_space);

		$$invalidate(1, dropdown_toggled = false);
	};

	$$self.$$set = $$props => {
		if ('selected_colour_space' in $$props) $$invalidate(0, selected_colour_space = $$props.selected_colour_space);
	};

	$$self.$capture_state = () => ({
		BlendingColourSpace: BlendingColourSpace,
		BrushType: BrushType,
		selected_colour_space,
		dropdown_toggled
	});

	$$self.$inject_state = $$props => {
		if ('selected_colour_space' in $$props) $$invalidate(0, selected_colour_space = $$props.selected_colour_space);
		if ('dropdown_toggled' in $$props) $$invalidate(1, dropdown_toggled = $$props.dropdown_toggled);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [selected_colour_space, dropdown_toggled, click_handler, click_handler_1];
}

class BlendingColourSpaceWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, BlendingColourSpaceWidget_svelte_instance, BlendingColourSpaceWidget_svelte_create_fragment, safe_not_equal, { selected_colour_space: 0 }, BlendingColourSpaceWidget_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BlendingColourSpaceWidget",
			options,
			id: BlendingColourSpaceWidget_svelte_create_fragment.name
		});
	}

	get selected_colour_space() {
		return this.$$.ctx[0];
	}

	set selected_colour_space(selected_colour_space) {
		this.$$set({ selected_colour_space });
		scheduler_flush();
	}
}

/* harmony default export */ const BlendingColourSpaceWidget_svelte = (BlendingColourSpaceWidget);
;// CONCATENATED MODULE: ./src/components/RGBSliders.svelte
/* src/components/RGBSliders.svelte generated by Svelte v4.0.0 */






const RGBSliders_svelte_file = "src/components/RGBSliders.svelte";

function RGBSliders_svelte_add_css(target) {
	append_styles(target, "svelte-pzb72g", ".svelte-pzb72g.svelte-pzb72g{user-select:none;-webkit-tap-highlight-color:transparent}.knob-container-container.svelte-pzb72g.svelte-pzb72g{max-height:100% !important;margin-left:0px;margin-right:0px;aspect-ratio:2/1;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;pointer-events:all;user-select:none}.knob-container.svelte-pzb72g.svelte-pzb72g{height:100%;width:100%;margin-right:auto}.knob-container.svelte-pzb72g .inner.svelte-pzb72g{transform-origin:left;height:100%;width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUkdCU2xpZGVycy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBeUZrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJSR0JTbGlkZXJzLnN2ZWx0ZSJdfQ== */");
}

function RGBSliders_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[16] = list;
	child_ctx[17] = i;
	return child_ctx;
}

// (50:4) {#if i !== 3}
function RGBSliders_svelte_create_if_block(ctx) {
	let div1;
	let div0;
	let div0_style_value;
	let i = /*i*/ ctx[17];
	let t;
	let mounted;
	let dispose;
	const assign_div0 = () => /*div0_binding*/ ctx[5](div0, i);
	const unassign_div0 = () => /*div0_binding*/ ctx[5](null, i);

	function pointerdown_handler(...args) {
		return /*pointerdown_handler*/ ctx[6](/*i*/ ctx[17], ...args);
	}

	const assign_div1 = () => /*div1_binding*/ ctx[7](div1, i);
	const unassign_div1 = () => /*div1_binding*/ ctx[7](null, i);

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			t = space();
			attr_dev(div0, "class", "inner svelte-pzb72g");

			attr_dev(div0, "style", div0_style_value = /*i*/ ctx[17] === 0
			? "background: rgba(255,0,0,1);"
			: /*i*/ ctx[17] === 1
				? "background: rgba(0,255,0,1);"
				: "background: rgba(0,0,255,1);");

			add_location(div0, RGBSliders_svelte_file, 78, 9, 1581);
			attr_dev(div1, "class", "knob-container svelte-pzb72g");
			add_location(div1, RGBSliders_svelte_file, 70, 6, 1381);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			assign_div0();
			append_dev(div1, t);
			assign_div1();

			if (!mounted) {
				dispose = listen_dev(div1, "pointerdown", pointerdown_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (i !== /*i*/ ctx[17]) {
				unassign_div0();
				i = /*i*/ ctx[17];
				assign_div0();
			}

			if (i !== /*i*/ ctx[17]) {
				unassign_div1();
				i = /*i*/ ctx[17];
				assign_div1();
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			unassign_div0();
			unassign_div1();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: RGBSliders_svelte_create_if_block.name,
		type: "if",
		source: "(50:4) {#if i !== 3}",
		ctx
	});

	return block;
}

// (49:2) {#each colour as col_element, i}
function RGBSliders_svelte_create_each_block(ctx) {
	let if_block_anchor;
	let if_block = /*i*/ ctx[17] !== 3 && RGBSliders_svelte_create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*i*/ ctx[17] !== 3) if_block.p(ctx, dirty);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: RGBSliders_svelte_create_each_block.name,
		type: "each",
		source: "(49:2) {#each colour as col_element, i}",
		ctx
	});

	return block;
}

function RGBSliders_svelte_create_fragment(ctx) {
	let div;
	let each_value = ensure_array_like_dev(/*colour*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = RGBSliders_svelte_create_each_block(RGBSliders_svelte_get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "draggable", "false");
			attr_dev(div, "class", "knob-container-container svelte-pzb72g");
			add_location(div, RGBSliders_svelte_file, 65, 0, 1249);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*elements, colour_idx, pointerDown, inners, colour*/ 31) {
				each_value = ensure_array_like_dev(/*colour*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = RGBSliders_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = RGBSliders_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: RGBSliders_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function RGBSliders_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('RGBSliders', slots, []);
	let { colour } = $$props;
	let colour_idx = 0;
	let elements = [0, 0, 0];
	let inners = [0, 0, 0];
	let startY = 0;
	let startX = 0;
	let startValue = 0;

	const clamp = (num, min, max) => {
		return Math.max(min, Math.min(num, max));
	};

	const update_style = idx => {
		$$invalidate(3, inners[idx].style.transform = `scaleX(${colour[idx]})`, inners);
	};

	const pointerMove = ({ clientX, clientY }) => {
		let scale = 1. / elements[colour_idx].clientWidth;
		let valueDiff = -(startX - clientX) * scale;
		$$invalidate(0, colour[colour_idx] = clamp(startValue + valueDiff, 0, 1), colour);
		update_style(colour_idx);
	};

	const pointerDown = e => {
		let { clientX, clientY } = e;
		startY = clientY;
		startX = clientX;
		startValue = colour[colour_idx];
		update_style(colour_idx);
		window.addEventListener('pointermove', pointerMove);
		window.addEventListener('pointerup', pointerUp);
	};

	const pointerUp = () => {
		window.removeEventListener('pointermove', pointerMove);
		window.removeEventListener('pointerup', pointerUp);
	};

	onMount(() => {
		update_style(0);
		update_style(1);
		update_style(2);
	});

	$$self.$$.on_mount.push(function () {
		if (colour === undefined && !('colour' in $$props || $$self.$$.bound[$$self.$$.props['colour']])) {
			console.warn("<RGBSliders> was created without expected prop 'colour'");
		}
	});

	const writable_props = ['colour'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RGBSliders> was created with unknown prop '${key}'`);
	});

	function div0_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inners[i] = $$value;
			$$invalidate(3, inners);
		});
	}

	const pointerdown_handler = (i, e) => {
		$$invalidate(1, colour_idx = i);
		pointerDown(e);
		e.stopPropagation();
	};

	function div1_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elements[i] = $$value;
			$$invalidate(2, elements);
		});
	}

	$$self.$$set = $$props => {
		if ('colour' in $$props) $$invalidate(0, colour = $$props.colour);
	};

	$$self.$capture_state = () => ({
		min: min,
		SemiModal: SemiModal_svelte,
		onMount: onMount,
		colour,
		colour_idx,
		elements,
		inners,
		startY,
		startX,
		startValue,
		clamp,
		update_style,
		pointerMove,
		pointerDown,
		pointerUp
	});

	$$self.$inject_state = $$props => {
		if ('colour' in $$props) $$invalidate(0, colour = $$props.colour);
		if ('colour_idx' in $$props) $$invalidate(1, colour_idx = $$props.colour_idx);
		if ('elements' in $$props) $$invalidate(2, elements = $$props.elements);
		if ('inners' in $$props) $$invalidate(3, inners = $$props.inners);
		if ('startY' in $$props) startY = $$props.startY;
		if ('startX' in $$props) startX = $$props.startX;
		if ('startValue' in $$props) startValue = $$props.startValue;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		colour,
		colour_idx,
		elements,
		inners,
		pointerDown,
		div0_binding,
		pointerdown_handler,
		div1_binding
	];
}

class RGBSliders extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, RGBSliders_svelte_instance, RGBSliders_svelte_create_fragment, safe_not_equal, { colour: 0 }, RGBSliders_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RGBSliders",
			options,
			id: RGBSliders_svelte_create_fragment.name
		});
	}

	get colour() {
		return this.$$.ctx[0];
	}

	set colour(colour) {
		this.$$set({ colour });
		scheduler_flush();
	}
}

/* harmony default export */ const RGBSliders_svelte = (RGBSliders);
// EXTERNAL MODULE: ./node_modules/chroma-js/chroma.js
var chroma = __webpack_require__(302);
var chroma_default = /*#__PURE__*/__webpack_require__.n(chroma);
;// CONCATENATED MODULE: ./src/components/ColourDisplay.svelte
/* src/components/ColourDisplay.svelte generated by Svelte v4.0.0 */


const { console: ColourDisplay_svelte_console_1 } = globals;




const ColourDisplay_svelte_file = "src/components/ColourDisplay.svelte";

function ColourDisplay_svelte_add_css(target) {
	append_styles(target, "svelte-p9tje", ".knob-container.svelte-p9tje{box-sizing:border-box;-webkit-box-sizing:border-box;&:hover{\n      cursor: pointer;\n    };margin-right:0.5rem;aspect-ratio:2/1;display:flex;background-color:var(--color);width:14rem;height:100%;max-height:100% !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29sb3VyRGlzcGxheS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBeUhFLDRCQUFlLENBQ2IsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsa0JBQWtCLENBQUUsVUFBVSxDQUM5QixDQUFDLE1BQU07QUFDWCxNQUFNLFFBQVEsT0FBTztBQUNyQixLQUFJLENBQ0EsWUFBWSxDQUFFLE1BQU0sQ0FDcEIsWUFBWSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBR2pCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsZ0JBQWdCLENBQUUsSUFBSSxPQUFPLENBQUMsQ0FDaEMsS0FBSyxDQUFFLEtBQUssQ0FDVixNQUFNLENBQUUsSUFBSSxDQUNaLFVBQVUsQ0FBRSxJQUFJLENBQUMsVUFDbkIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ29sb3VyRGlzcGxheS5zdmVsdGUiXX0= */");
}

function ColourDisplay_svelte_create_fragment(ctx) {
	let div;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = dom_element("div");
			div.innerHTML = ``;
			attr_dev(div, "draggable", "false");
			attr_dev(div, "class", "knob-container svelte-p9tje");
			add_location(div, ColourDisplay_svelte_file, 117, 0, 2248);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			/*div_binding*/ ctx[6](div);

			if (!mounted) {
				dispose = listen_dev(div, "pointerdown", /*pointerDown*/ ctx[1], false, false, false, false);
				mounted = true;
			}
		},
		p: utils_noop,
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			/*div_binding*/ ctx[6](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: ColourDisplay_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const valueRange = 4;

function ColourDisplay_svelte_clamp(num, min, max) {
	return Math.max(min, Math.min(num, max));
}

function ColourDisplay_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ColourDisplay', slots, []);
	let { colour } = $$props;
	let container;

	const re_render_colour = (colour_r, colour_g, colour_b) => {
		if (container) {
			container.style.setProperty('--color', `rgba(${255 * Math.pow(colour_r, 0.45454545454545454545)}, ${255 * Math.pow(colour_g, 0.45454545454545454545)}, ${255 * Math.pow(colour_b, 0.45454545454545454545)}, ${255 * Math.pow(1.0, 0.45454545454545454545)})`);
		}
	};

	let { update_display = (colour_r, colour_g, colour_b) => {
		re_render_colour(colour_r, colour_g, colour_b);
	} } = $$props;

	let { dragging = false } = $$props;
	let { stopped_dragging = false } = $$props;
	let startValue = [0, 0];
	let prevX = 0;
	let prevY = 0;

	const chroma_gl = col => {
		return chroma_default().gl(col[0], col[1], col[2]);
	};

	const chroma_oklch = col => {
		return chroma_default().oklch(col[0], col[1], col[2]);
	};

	const pointerMove = ({ clientX, clientY }) => {
		const valueDiffY = -(clientY - prevY);
		const valueDiffX = clientX - prevX;
		prevX = clientX;
		prevY = clientY;
		let col = chroma_gl(colour).oklch();
		let scale = 1. / min(document.documentElement.clientWidth, document.documentElement.clientHeight);
		col[0] += valueDiffY * 3.0 * scale;
		col[2] += valueDiffX * 360 * 3.0 * scale;
		col[0] = ColourDisplay_svelte_clamp(col[0], 0, 1);
		col[1] = ColourDisplay_svelte_clamp(col[1], 0, 1);
		col[2] = _0b5vr_experimental_esm_mod(col[2], 360);
		col = chroma_oklch(col).gl();
		$$invalidate(2, colour[0] = col[0], colour);
		$$invalidate(2, colour[1] = col[1], colour);
		$$invalidate(2, colour[2] = col[2], colour);
	};

	function pointerDown(e) {
		$$invalidate(3, dragging = true);
		const { clientX, clientY } = e;
		prevY = clientY;
		prevX = clientX;
		startValue = [colour[0], colour[1], colour[2], 1];
		window.addEventListener('pointermove', pointerMove);
		window.addEventListener('pointerup', pointerUp);
		e.stopPropagation();
	}

	function pointerUp() {
		$$invalidate(3, dragging = false);
		$$invalidate(4, stopped_dragging = true);
		console.log('up');
		window.removeEventListener('pointermove', pointerMove);
		window.removeEventListener('pointerup', pointerUp);
	}

	$$self.$$.on_mount.push(function () {
		if (colour === undefined && !('colour' in $$props || $$self.$$.bound[$$self.$$.props['colour']])) {
			ColourDisplay_svelte_console_1.warn("<ColourDisplay> was created without expected prop 'colour'");
		}
	});

	const writable_props = ['colour', 'update_display', 'dragging', 'stopped_dragging'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') ColourDisplay_svelte_console_1.warn(`<ColourDisplay> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$$set = $$props => {
		if ('colour' in $$props) $$invalidate(2, colour = $$props.colour);
		if ('update_display' in $$props) $$invalidate(5, update_display = $$props.update_display);
		if ('dragging' in $$props) $$invalidate(3, dragging = $$props.dragging);
		if ('stopped_dragging' in $$props) $$invalidate(4, stopped_dragging = $$props.stopped_dragging);
	};

	$$self.$capture_state = () => ({
		mod: _0b5vr_experimental_esm_mod,
		chroma: (chroma_default()),
		min: min,
		colour,
		container,
		re_render_colour,
		update_display,
		dragging,
		stopped_dragging,
		startValue,
		prevX,
		prevY,
		valueRange,
		clamp: ColourDisplay_svelte_clamp,
		chroma_gl,
		chroma_oklch,
		pointerMove,
		pointerDown,
		pointerUp
	});

	$$self.$inject_state = $$props => {
		if ('colour' in $$props) $$invalidate(2, colour = $$props.colour);
		if ('container' in $$props) $$invalidate(0, container = $$props.container);
		if ('update_display' in $$props) $$invalidate(5, update_display = $$props.update_display);
		if ('dragging' in $$props) $$invalidate(3, dragging = $$props.dragging);
		if ('stopped_dragging' in $$props) $$invalidate(4, stopped_dragging = $$props.stopped_dragging);
		if ('startValue' in $$props) startValue = $$props.startValue;
		if ('prevX' in $$props) prevX = $$props.prevX;
		if ('prevY' in $$props) prevY = $$props.prevY;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*colour*/ 4) {
			$: re_render_colour(colour[0], colour[1], colour[2]);
		}
	};

	return [
		container,
		pointerDown,
		colour,
		dragging,
		stopped_dragging,
		update_display,
		div_binding
	];
}

class ColourDisplay extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			ColourDisplay_svelte_instance,
			ColourDisplay_svelte_create_fragment,
			safe_not_equal,
			{
				colour: 2,
				update_display: 5,
				dragging: 3,
				stopped_dragging: 4
			},
			ColourDisplay_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ColourDisplay",
			options,
			id: ColourDisplay_svelte_create_fragment.name
		});
	}

	get colour() {
		return this.$$.ctx[2];
	}

	set colour(colour) {
		this.$$set({ colour });
		scheduler_flush();
	}

	get update_display() {
		return this.$$.ctx[5];
	}

	set update_display(update_display) {
		this.$$set({ update_display });
		scheduler_flush();
	}

	get dragging() {
		return this.$$.ctx[3];
	}

	set dragging(dragging) {
		this.$$set({ dragging });
		scheduler_flush();
	}

	get stopped_dragging() {
		return this.$$.ctx[4];
	}

	set stopped_dragging(stopped_dragging) {
		this.$$set({ stopped_dragging });
		scheduler_flush();
	}
}

/* harmony default export */ const ColourDisplay_svelte = (ColourDisplay);
;// CONCATENATED MODULE: ./src/components/FourIconsWidget.svelte
/* src/components/FourIconsWidget.svelte generated by Svelte v4.0.0 */




const FourIconsWidget_svelte_file = "src/components/FourIconsWidget.svelte";

function FourIconsWidget_svelte_add_css(target) {
	append_styles(target, "svelte-1brpmpp", "#four-icons.svelte-1brpmpp{max-height:unset !important;height:100%;aspect-ratio:1/1;display:grid;grid-template-columns:2fr 1fr;grid-template-rows:1fr 1fr;width:5rem;transform:scale(0.7);transform-origin:top}#four-icons.svelte-1brpmpp>div:not(:first-of-type){height:100%;max-height:unset;margin:0}#four-icons.svelte-1brpmpp>div:first-of-type{grid-column:1/-1}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm91ckljb25zV2lkZ2V0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFZa0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRm91ckljb25zV2lkZ2V0LnN2ZWx0ZSJdfQ== */");
}

function FourIconsWidget_svelte_create_fragment(ctx) {
	let div;
	let div_style_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	const block = {
		c: function create() {
			div = dom_element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "id", "four-icons");
			attr_dev(div, "style", div_style_value = /*$gallery_open*/ ctx[0] ? "display: contents;" : "");
			attr_dev(div, "class", "svelte-1brpmpp");
			add_location(div, FourIconsWidget_svelte_file, 8, 0, 98);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*$gallery_open*/ 1 && div_style_value !== (div_style_value = /*$gallery_open*/ ctx[0] ? "display: contents;" : "")) {
				attr_dev(div, "style", div_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: FourIconsWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function FourIconsWidget_svelte_instance($$self, $$props, $$invalidate) {
	let $gallery_open;
	validate_store(gallery_open, 'gallery_open');
	component_subscribe($$self, gallery_open, $$value => $$invalidate(0, $gallery_open = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FourIconsWidget', slots, ['default']);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FourIconsWidget> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ gallery_open: gallery_open, $gallery_open });
	return [$gallery_open, $$scope, slots];
}

class FourIconsWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, FourIconsWidget_svelte_instance, FourIconsWidget_svelte_create_fragment, safe_not_equal, {}, FourIconsWidget_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FourIconsWidget",
			options,
			id: FourIconsWidget_svelte_create_fragment.name
		});
	}
}

/* harmony default export */ const FourIconsWidget_svelte = (FourIconsWidget);
;// CONCATENATED MODULE: ./src/IO.ts

class IO {
    keys = new Map();
    touches = {};
    two_finger_pinch_prev = false;
    two_finger_pinch = false;
    just_finished_pinch = false;
    just_started_pinch = false;
    touches_starting_positions = new Float32Array(4);
    touches_starting_mid_point = new Float32Array(2);
    touches_starting_length = 0;
    touches_mid_point_prev = new Float32Array(2);
    pinch_pos = new Float32Array(2);
    pinch_zoom = 0;
    mouse_pos = Float32Array.from([0, 0]);
    delta_mouse_pos = Float32Array.from([0, 0]);
    mouse_pos_prev = Float32Array.from([0, 0]);
    mouse_down = false;
    _mouse_positions_during_last_frame = new Float32Array(50);
    _mouse_positions_during_last_frame_b = new Float32Array(50);
    _mouse_positions_during_last_frame_cnt = 0;
    _mouse_positions_during_last_frame_cnt_b = 0;
    mouse_positions_arr_idx = 0;
    get mouse_positions_during_last_frame() {
        return this.mouse_positions_arr_idx === 0
            ? this._mouse_positions_during_last_frame
            : this._mouse_positions_during_last_frame_b;
    }
    get mouse_positions_during_last_frame_cnt() {
        return this.mouse_positions_arr_idx === 0
            ? this._mouse_positions_during_last_frame_cnt
            : this._mouse_positions_during_last_frame_cnt_b;
    }
    pointerType = 'mouse';
    mouse_down_prev = false;
    mouse_just_unpressed = false;
    mouse_just_pressed = false;
    mouse_just_moved = false;
    mmb_just_unpressed = false;
    mmb_just_pressed = false;
    mmb_down = false;
    mouse_wheel = 0;
    pressure = 0.0;
    tilt = [0, 0];
    tick() {
        this.delta_mouse_pos[0] = this.mouse_pos[0] - this.mouse_pos_prev[0];
        this.delta_mouse_pos[1] = this.mouse_pos[1] - this.mouse_pos_prev[1];
        this.mouse_pos_prev[0] = this.mouse_pos[0];
        this.mouse_pos_prev[1] = this.mouse_pos[1];
        if (this.mouse_positions_arr_idx === 0) {
            this._mouse_positions_during_last_frame_cnt = 0;
        }
        else {
            this._mouse_positions_during_last_frame_cnt_b = 0;
        }
        this.mouse_positions_arr_idx = 1 - this.mouse_positions_arr_idx;
        if (this.two_finger_pinch === false && this.two_finger_pinch_prev === true) {
            this.just_finished_pinch = true;
        }
        else if (this.two_finger_pinch === true && this.two_finger_pinch_prev === false) {
            this.just_started_pinch = true;
        }
        if (this.mouse_down !== this.mouse_down_prev) {
            if (this.mouse_down) {
                this.mouse_just_pressed = true;
            }
            else {
                this.mouse_just_unpressed = true;
            }
        }
    }
    tick_end() {
        this.mouse_just_pressed = false;
        this.mouse_just_unpressed = false;
        this.mouse_just_moved = false;
        this.mouse_down_prev = this.mouse_down;
        this.mmb_just_unpressed = false;
        this.mmb_just_pressed = false;
        this.mouse_wheel = 0;
        this.two_finger_pinch_prev = this.two_finger_pinch;
        this.just_finished_pinch = false;
        this.just_started_pinch = false;
        Object.values(this.keys).forEach((key) => {
            key.just_unpressed = false;
            key.just_pressed = false;
        });
    }
    getKey(code) {
        let key = this.keys[code];
        if (key) {
            return key;
        }
        else {
            return { down: false, just_pressed: false, just_unpressed: false };
        }
    }
    constructor() {
        window.addEventListener('keydown', (event) => {
            this.keys[event.code] = { down: true, just_pressed: true, just_unpressed: false };
            if (event.code === 'AltLeft')
                event.preventDefault();
        });
        window.addEventListener('keyup', (event) => {
            let just_unpressed = false;
            if (this.getKey(event.code).down)
                just_unpressed = true;
            this.keys[event.code] = { down: false, just_pressed: false, just_unpressed: just_unpressed };
        });
        window.addEventListener('wheel', (e) => {
            this.mouse_wheel = e.deltaY < 0 ? 1 : e.deltaY > 0 ? -1 : 0;
        });
        window.addEventListener('mouseup', (e) => {
            if (e.button === 1) {
                this.mmb_down = false;
                this.mmb_just_unpressed = true;
            }
        });
        window.addEventListener('mousedown', (e) => {
            if (e.button === 1) {
                this.mmb_down = true;
                this.mmb_just_pressed = true;
                e.preventDefault();
            }
        });
        window.addEventListener('focus', () => {
            let l_alt = this.getKey('AltLeft');
            if (l_alt.down) {
                l_alt.just_unpressed = true;
                l_alt.down = false;
            }
        });
        window.addEventListener('pointermove', (e) => {
            function getRelativeMousePosition(event, target) {
                target = target || event.target;
                var rect = target.getBoundingClientRect();
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top,
                };
            }
            function getNoPaddingNoBorderCanvasRelativeMousePosition(event, target) {
                target = target || event.target;
                var pos = getRelativeMousePosition(event, target);
                pos.x = (pos.x * target.width) / target.clientWidth;
                pos.y = (pos.y * target.height) / target.clientHeight;
                return pos;
            }
            let gl = window.gl;
            const pos = getNoPaddingNoBorderCanvasRelativeMousePosition(e, gl.canvas);
            const x = (pos.x / gl.canvas.width) * 2 - 1;
            const y = (pos.y / gl.canvas.height) * -2 + 1;
            this.mouse_pos[0] = x;
            this.mouse_pos[1] = y;
            const is_back = this.mouse_positions_arr_idx === 0;
            const positions = is_back ? this._mouse_positions_during_last_frame_b : this._mouse_positions_during_last_frame;
            const idx = is_back ? this._mouse_positions_during_last_frame_cnt_b : this._mouse_positions_during_last_frame_cnt;
            positions[idx * 2] = x;
            positions[idx * 2 + 1] = y;
            if (is_back)
                this._mouse_positions_during_last_frame_cnt_b++;
            else
                this._mouse_positions_during_last_frame_cnt++;
            this.pressure = e.pointerType === 'mouse' ? 1 : e.pressure ?? this.pressure;
            this.mouse_just_moved = true;
            this.tilt[0] = e.pointerType === 'mouse' ? 0 : e.altitudeAngle ?? this.tilt[0];
            this.tilt[1] = e.pointerType === 'mouse' ? 0 : e.azimuthAngle ?? this.tilt[1];
        });
        document.querySelector('canvas').addEventListener('touchstart', (e) => {
            for (let i = 0; i < e.targetTouches.length; i++) {
                const touch = e.targetTouches[i];
                const touch_id = touch.identifier;
                this.touches[touch_id] = [touch.clientX, touch.clientY];
            }
        });
        const length = (ax, ay, bx, by) => {
            return sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by));
        };
        document.querySelector('canvas').addEventListener('touchmove', (e) => {
            if (e.targetTouches.length === 2) {
                if (this.two_finger_pinch === false) {
                    this.touches_starting_positions[0] = e.targetTouches[0].clientX;
                    this.touches_starting_positions[1] = e.targetTouches[0].clientY;
                    this.touches_starting_positions[2] = e.targetTouches[1].clientX;
                    this.touches_starting_positions[3] = e.targetTouches[1].clientY;
                    this.touches_starting_mid_point[0] = e.targetTouches[0].clientX * 0.5 + e.targetTouches[1].clientX * 0.5;
                    this.touches_starting_mid_point[1] = e.targetTouches[0].clientY * 0.5 + e.targetTouches[1].clientY * 0.5;
                    this.pinch_zoom = 0;
                    this.touches_starting_length = length(e.targetTouches[0].clientX, e.targetTouches[0].clientY, e.targetTouches[1].clientX, e.targetTouches[1].clientY);
                    this.touches_mid_point_prev[0] = this.touches_starting_mid_point[0];
                    this.touches_mid_point_prev[1] = this.touches_starting_mid_point[1];
                    this.pinch_pos[0] = 0;
                    this.pinch_pos[1] = 0;
                }
                this.two_finger_pinch = true;
                const mid_point_x = e.targetTouches[0].clientX * 0.5 + e.targetTouches[1].clientX * 0.5;
                const mid_point_y = e.targetTouches[0].clientY * 0.5 + e.targetTouches[1].clientY * 0.5;
                const len = length(e.targetTouches[0].clientX, e.targetTouches[0].clientY, e.targetTouches[1].clientX, e.targetTouches[1].clientY);
                const res = min(window.innerWidth, window.innerHeight);
                this.pinch_zoom = ((len - this.touches_starting_length) / res) * 4;
                this.pinch_pos[0] += (((mid_point_x - this.touches_mid_point_prev[0]) / res) * 2) / window.zoom[0];
                this.pinch_pos[1] += (((mid_point_y - this.touches_mid_point_prev[1]) / res) * 2) / window.zoom[0];
                this.touches_mid_point_prev[0] = mid_point_x;
                this.touches_mid_point_prev[1] = mid_point_y;
            }
            else {
                if (this.two_finger_pinch === true) {
                    this.two_finger_pinch = false;
                }
            }
        });
        const touch_end = (e) => {
            for (const id in Object.keys(this.touches)) {
                delete this.touches[id];
            }
            this.two_finger_pinch = false;
        };
        document.querySelector('canvas').addEventListener('touchcancel', (e) => {
            touch_end(e);
        });
        document.querySelector('canvas').addEventListener('touchend', (e) => {
            touch_end(e);
        });
        document.querySelector('canvas').addEventListener('pointerdown', (e) => {
            this.pointerType = e.pointerType;
            if (e.pointerType === 'mouse' && e.button !== 0)
                return;
            this.mouse_down = true;
        });
        window.addEventListener('pointerup', () => {
            this.mouse_down = false;
        });
    }
}

// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js
var earcut = __webpack_require__(720);
// EXTERNAL MODULE: ./node_modules/libtess/libtess.min.js
var libtess_min = __webpack_require__(587);
var libtess_min_default = /*#__PURE__*/__webpack_require__.n(libtess_min);
;// CONCATENATED MODULE: ./src/gl/Buffer.ts


class UBO {
    buff;
    uniforms = [];
    constructor() {
        this.buff = new VertexBuffer(0, gl.FLOAT, 96, gl.UNIFORM_BUFFER);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, this.buff.buff);
    }
}
class VertexBuffer {
    buff;
    cpu_buff;
    type;
    usage;
    stride;
    single_vert_sz;
    sz;
    max_sz;
    constructor(single_vert_sz, type = gl.FLOAT, max_size = 10000000, usage = gl.ARRAY_BUFFER) {
        this.buff = gl.createBuffer();
        this.usage = usage;
        gl.bindBuffer(usage, this.buff);
        this.type = type;
        this.single_vert_sz = single_vert_sz;
        this.max_sz = max_size;
        this.stride = 0;
        if (type === gl.FLOAT) {
            this.cpu_buff = new Float32Array(max_size);
        }
        else if (type === gl.INT) {
            this.cpu_buff = new Int32Array(max_size);
        }
        else {
            this.cpu_buff = new Uint32Array(max_size);
        }
        gl.bufferData(usage, this.cpu_buff.byteLength, gl.DYNAMIC_DRAW);
        this.sz = 0;
    }
    bindToAttrib(idx, params = undefined) {
        if (params) {
            gl.bindBuffer(this.usage, this.buff);
            gl.vertexAttribPointer(idx, params.vert_sz ?? this.single_vert_sz, params.type ?? this.type, false, params.stride ?? this.stride, params.offset ?? 0);
        }
        else {
            gl.bindBuffer(this.usage, this.buff);
            gl.vertexAttribPointer(idx, this.single_vert_sz, this.type, false, this.stride, 0);
        }
    }
    push_vert(vert) {
        if (vert.length !== this.single_vert_sz) {
        }
        for (let v of vert) {
            this.cpu_buff[this.sz++] = v;
        }
    }
    upload_external_array(input_buff) {
        if (input_buff instanceof Array) {
            gl.bindBuffer(this.usage, this.buff);
            let _buff = Float32Array.from(input_buff);
            this.sz = _buff.length;
            const sz_in_bytes = _buff.byteLength;
            gl.bufferSubData(this.usage, 0, _buff);
            pause_on_gl_error();
        }
        else {
            gl.bindBuffer(this.usage, this.buff);
            const sz_in_bytes = input_buff.byteLength;
            gl.bufferSubData(this.usage, 0, input_buff);
            pause_on_gl_error();
        }
    }
    upload() {
        gl.bindBuffer(this.usage, this.buff);
        const sz_in_bytes = this.sz * this.cpu_buff.BYTES_PER_ELEMENT;
        gl.bufferSubData(this.usage, 0, this.cpu_buff, 0, sz_in_bytes);
        pause_on_gl_error();
    }
}

;// CONCATENATED MODULE: ./src/gl/ShaderProgram.ts

class ShaderProgram {
    program;
    loadShader(type, source) {
        source = source.replaceAll('export default "', ``);
        source = source.replaceAll('";', ``);
        source = source.replaceAll('"', ``);
        source = source.replaceAll(`\\n`, `
		`);
        source = source.replace(/(.*)(#version 300 es)[\t\s]*/g, `$2
			`);
        source = source.replaceAll(/(#define .+)[\t\s]*/g, `
		$1
		`);
        source = source.replaceAll(/	+precision highp float;/gm, `precision highp float;
			`);
        source = source.replaceAll(`\\t`, `	`);
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(`An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`);
            console.error(source);
        }
        return shader;
    }
    constructor(vs, fs) {
        const vertexShader = this.loadShader(gl.VERTEX_SHADER, vs);
        const fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fs);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error(`Unable to initialize the shader program: ${gl.getProgramInfoLog(shaderProgram)}`);
            console.error(vs);
            console.error(fs);
        }
        this.program = shaderProgram;
        gl.useProgram(this.program);
        gl.uniformBlockBinding(this.program, 0, 0);
    }
    use() {
        gl.useProgram(this.program);
    }
    setUniformVec(name, vec) {
        if (vec.length == 2)
            gl.uniform2fv(gl.getUniformLocation(this.program, name), vec);
        else if (vec.length == 3)
            gl.uniform3fv(gl.getUniformLocation(this.program, name), vec);
        else if (vec.length == 4)
            gl.uniform4fv(gl.getUniformLocation(this.program, name), vec);
    }
    setUniformFloat(name, value) {
        gl.uniform1f(gl.getUniformLocation(this.program, name), value);
    }
    setUniformInt(name, value) {
        gl.uniform1i(gl.getUniformLocation(this.program, name), value);
    }
    setUniformTexture(name, texture, binding = 0) {
        gl.activeTexture(gl.TEXTURE0 + binding);
        gl.bindTexture(gl.TEXTURE_2D, texture.tex);
        gl.uniform1i(gl.getUniformLocation(this.program, name), binding);
    }
}

;// CONCATENATED MODULE: ./src/gl/Thing.ts


class Thing {
    vao;
    buffs;
    shader;
    prim_type;
    constructor(buffs, prim_type = gl.TRIANGLES, shader) {
        this.prim_type = prim_type;
        this.shader = shader;
        this.vao = gl.createVertexArray();
        this.buffs = [...buffs];
        gl.bindVertexArray(this.vao);
        let i = 0;
        for (let buff of this.buffs) {
            gl.enableVertexAttribArray(i);
            buff.bindToAttrib(i);
            i++;
        }
    }
    static draw_external_buffs_and_shader(buffs, shader, params) {
        shader.use();
        let i = 0;
        params.prim_type = params.prim_type ?? gl.TRIANGLES;
        params.draw_cnt = params.draw_cnt ?? buffs[0].buff.sz / buffs[0].buff.single_vert_sz;
        if (params.prim_type === gl.TRIANGLES) {
            gl.drawArrays(gl.TRIANGLES, 0, params.draw_cnt);
            console.log('DREW');
            console.log(params.draw_cnt);
        }
        else {
            alert('bleep bloop errrorrr');
        }
    }
    upload_all_buffs() {
        for (let buff of this.buffs) {
            buff.upload();
        }
    }
    draw_with_external_shader(shader) {
        shader.use();
        if (this.prim_type === gl.TRIANGLES) {
            let draw_cnt = this.buffs[0].sz / this.buffs[0].single_vert_sz;
            gl.drawArrays(this.prim_type, 0, draw_cnt);
        }
        else {
            alert('bleep bloop errrorrr');
        }
    }
    draw(offs = 0) {
        this.draw_with_external_shader(this.shader);
    }
}

;// CONCATENATED MODULE: ./src/drawer.ts








const tessy = (function initTesselator() {
    function vertexCallback(data, polyVertArray) {
        polyVertArray[polyVertArray.length] = data[0];
        polyVertArray[polyVertArray.length] = data[1];
    }
    function begincallback(type) {
        if (type !== (libtess_min_default()).primitiveType.GL_TRIANGLES) {
            console.log('expected TRIANGLES but got type: ' + type);
        }
    }
    function errorcallback(errno) {
        console.log('error callback');
        console.log('error number: ' + errno);
    }
    function combinecallback(coords, data, weight) {
        return [coords[0], coords[1], coords[2]];
    }
    function edgeCallback(flag) {
    }
    const tessy = new (libtess_min_default()).GluTesselator();
    tessy.gluTessCallback((libtess_min_default()).gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
    tessy.gluTessCallback((libtess_min_default()).gluEnum.GLU_TESS_BEGIN, begincallback);
    tessy.gluTessCallback((libtess_min_default()).gluEnum.GLU_TESS_ERROR, errorcallback);
    tessy.gluTessCallback((libtess_min_default()).gluEnum.GLU_TESS_COMBINE, combinecallback);
    tessy.gluTessCallback((libtess_min_default()).gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);
    return tessy;
})();
function triangulate(contours) {
    tessy.gluTessNormal(0, 0, 1);
    const triangleVerts = [];
    tessy.gluTessBeginPolygon(triangleVerts);
    for (let i = 0; i < contours.length; i++) {
        tessy.gluTessBeginContour();
        let contour = contours[i];
        for (let j = 0; j < contour.length; j += 2) {
            const coords = [contour[j], contour[j + 1], 0];
            tessy.gluTessVertex(coords, coords);
        }
        tessy.gluTessEndContour();
    }
    tessy.gluTessEndPolygon();
    return triangleVerts;
}
const get_subarray = (arr, offs_begin, offs_end) => {
    return [arr.subarray(offs_begin, offs_end), offs_end - 1];
};
const get_circ_pos_from_ang = (a) => {
    const c = cos(-a);
    const s = sin(-a);
    return [c, s];
};
let drawer_gl;
class Drawer {
    canvas_tex;
    default_framebuffer;
    brush_buffer;
    zoom = 0;
    panning = [0, 0];
    t = 0;
    idx = 0;
    temp_array_a = new Float32Array(1_000_00);
    temp_array_b = new Float32Array(1_000_00);
    recorded_drawcalls = [];
    constructor(_gl, canvas_tex, default_framebuffer) {
        this.canvas_tex = canvas_tex;
        this.default_framebuffer = default_framebuffer;
        drawer_gl = _gl;
    }
    reset() {
        this.idx = 0;
        this.recorded_drawcalls.length = 0;
        this.brush_buffer.buffs[0].sz = 0;
        this.brush_buffer.buffs[1].sz = 0;
    }
    fill_buff_for_blob_brush(stroke) {
        const brush_buffer = this.brush_buffer;
        const iters = stroke.positions.length / 2 - 1;
        let aspect_correction = [0, 0];
        if (this.canvas_tex.res[0] > this.canvas_tex.res[1]) {
            aspect_correction[0] = this.canvas_tex.res[1] / this.canvas_tex.res[0];
            aspect_correction[1] = 1;
        }
        else {
            aspect_correction[0] = 1;
            aspect_correction[1] = this.canvas_tex.res[0] / this.canvas_tex.res[1];
        }
        const add_ang_to_pos = (pos, ang_x, ang_y, positive, sz_x, sz_y) => {
            if (positive) {
                pos[0] += ang_x[0] * sz_x * aspect_correction[0];
                pos[1] += ang_x[1] * sz_x * aspect_correction[1];
                pos[0] += ang_y[0] * sz_y * aspect_correction[0];
                pos[1] += ang_y[1] * sz_y * aspect_correction[1];
            }
            else {
                pos[0] -= ang_x[0] * sz_x * aspect_correction[0];
                pos[1] -= ang_x[1] * sz_x * aspect_correction[1];
                pos[0] += ang_y[0] * sz_y * aspect_correction[0];
                pos[1] += ang_y[1] * sz_y * aspect_correction[1];
            }
            return pos;
        };
        let idx = brush_buffer.buffs[0].sz;
        for (let i = 0; i < iters; i++) {
            let sz_x = stroke.sizes[i * 2] / 2;
            let sz_y = stroke.sizes[i * 2 + 1] / 2;
            let ang_x = get_circ_pos_from_ang(stroke.rotations[i * 2 + 1]);
            let ang_y = [ang_x[1], -ang_x[0]];
            let curr_pos = [stroke.positions[i * 2], stroke.positions[i * 2 + 1]];
            let curr_pos_left = add_ang_to_pos([...curr_pos], ang_x, ang_y, true, sz_x, sz_y);
            let curr_pos_right = add_ang_to_pos([...curr_pos], ang_x, ang_y, false, sz_x, sz_y);
            let next_pos_left = [...curr_pos_left];
            let next_pos_right = [...curr_pos_right];
            next_pos_left[0] -= ang_y[0] * sz_y * aspect_correction[0] * 2;
            next_pos_left[1] -= ang_y[1] * sz_y * aspect_correction[1] * 2;
            next_pos_right[0] -= ang_y[0] * sz_y * aspect_correction[0] * 2;
            next_pos_right[1] -= ang_y[1] * sz_y * aspect_correction[1] * 2;
            let curr_col = [stroke.colours[i * 3], stroke.colours[i * 3 + 1], stroke.colours[i * 3 + 2]];
            let curr_opacity = stroke.opacities[i];
            const curr_v = i / iters;
            const next_v = (i + 1) / iters;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
        }
        brush_buffer.buffs[0].sz += iters * 6 * 4;
        brush_buffer.buffs[1].sz += iters * 6 * 4;
        this.recorded_drawcalls.push(this.brush_buffer.buffs[0].sz);
    }
    fill_buff_for_long_brush(stroke) {
        const brush_buffer = this.brush_buffer;
        const iters = stroke.positions.length / 2 - 1;
        let aspect_correction = [0, 0];
        if (this.canvas_tex.res[0] > this.canvas_tex.res[1]) {
            aspect_correction[0] = this.canvas_tex.res[1] / this.canvas_tex.res[0];
            aspect_correction[1] = 1;
        }
        else {
            aspect_correction[0] = 1;
            aspect_correction[1] = this.canvas_tex.res[0] / this.canvas_tex.res[1];
        }
        const add_ang_to_pos = (pos, ang_offs, positive, amt, aspect_correction) => {
            if (positive) {
                pos[0] += ang_offs[0] * amt * aspect_correction[0];
                pos[1] += ang_offs[1] * amt * aspect_correction[1];
            }
            else {
                pos[0] -= ang_offs[0] * amt * aspect_correction[0];
                pos[1] -= ang_offs[1] * amt * aspect_correction[1];
            }
            return pos;
        };
        let idx = brush_buffer.buffs[0].sz;
        for (let i = 0; i < iters; i++) {
            let curr_sz = stroke.sizes[i * 2];
            let next_sz = stroke.sizes[i * 2 + 2];
            let curr_ang = get_circ_pos_from_ang(stroke.rotations[i * 2 + 1]);
            let next_ang = get_circ_pos_from_ang(stroke.rotations[i * 2 + 3]);
            let curr_pos = [stroke.positions[i * 2], stroke.positions[i * 2 + 1]];
            let next_pos = [stroke.positions[i * 2 + 2], stroke.positions[i * 2 + 3]];
            let curr_pos_left = add_ang_to_pos([...curr_pos], curr_ang, true, curr_sz, aspect_correction);
            let curr_pos_right = add_ang_to_pos([...curr_pos], curr_ang, false, curr_sz, aspect_correction);
            let next_pos_left = add_ang_to_pos([...next_pos], next_ang, true, next_sz, aspect_correction);
            let next_pos_right = add_ang_to_pos([...next_pos], next_ang, false, next_sz, aspect_correction);
            let curr_col = [stroke.colours[i * 3], stroke.colours[i * 3 + 1], stroke.colours[i * 3 + 2]];
            let curr_opacity = stroke.opacities[i];
            let next_col = [stroke.colours[i * 3 + 3], stroke.colours[i * 3 + 4], stroke.colours[i * 3 + 5]];
            let next_opacity = stroke.opacities[i + 1];
            const curr_v = i / iters;
            const next_v = (i + 1) / iters;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = next_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = next_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = next_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_opacity;
        }
        brush_buffer.buffs[0].sz += iters * 6 * 4;
        brush_buffer.buffs[1].sz += iters * 6 * 4;
        this.recorded_drawcalls.push(this.brush_buffer.buffs[0].sz);
    }
    fill_buff_for_triangulated_brush(stroke) {
        const brush_buffer = this.brush_buffer;
        const { colours, opacities, positions } = stroke;
        const iters = positions.length / 2 - 1;
        let idx = brush_buffer.buffs[0].sz;
        for (let i = 0; i < iters; i++) {
            let u = 0;
            let v = 0;
            brush_buffer.buffs[0].cpu_buff[idx] = positions[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[0];
            brush_buffer.buffs[0].cpu_buff[idx] = positions[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[1];
            brush_buffer.buffs[0].cpu_buff[idx] = i / (iters + 1);
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = opacities[1];
            brush_buffer.buffs[0].cpu_buff[idx] = positions[i * 2];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3];
            brush_buffer.buffs[0].cpu_buff[idx] = positions[i * 2 + 1];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3 + 1];
            brush_buffer.buffs[0].cpu_buff[idx] = i / (iters + 1);
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3 + 2];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = opacities[i];
            brush_buffer.buffs[0].cpu_buff[idx] = positions[i * 2 + 2];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3 + 3];
            brush_buffer.buffs[0].cpu_buff[idx] = positions[i * 2 + 3];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3 + 4];
            brush_buffer.buffs[0].cpu_buff[idx] = (i + 1) / (iters + 1);
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3 + 5];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = opacities[i + 1];
        }
        brush_buffer.buffs[0].sz += iters * 3 * 4;
        brush_buffer.buffs[1].sz += iters * 3 * 4;
        this.recorded_drawcalls.push(this.brush_buffer.buffs[0].sz);
    }
    push_any_stroke(stroke) {
        if (stroke.brush_type === BrushType.Blobs) {
            this.fill_buff_for_blob_brush(stroke);
        }
        else if (stroke.brush_type === BrushType.Long) {
            this.fill_buff_for_long_brush(stroke);
        }
        else if (stroke.brush_type === BrushType.Tri) {
            this.fill_buff_for_triangulated_brush(stroke);
        }
    }
    draw_stroke_idx(idx) {
        let draw_start = idx === 0 ? 0 : this.recorded_drawcalls[idx - 1];
        let draw_cnt = idx === 0 ? this.recorded_drawcalls[0] : this.recorded_drawcalls[idx] - this.recorded_drawcalls[idx - 1];
        drawer_gl.drawArrays(drawer_gl.TRIANGLES, draw_start / 4, draw_cnt / 4);
    }
    draw_any_stroke(stroke, t, brush_buffer, zoom, panning) {
        this.brush_buffer = brush_buffer;
        console.log('START DRAWING');
        this.t = t;
        this.zoom = zoom;
        this.panning = [...panning];
        brush_buffer.draw();
    }
}

;// CONCATENATED MODULE: ./src/components/App.svelte
/* src/components/App.svelte generated by Svelte v4.0.0 */


const { Object: App_svelte_Object_1, console: App_svelte_console_1 } = globals;



































const App_svelte_file = "src/components/App.svelte";

function App_svelte_add_css(target) {
	append_styles(target, "svelte-1rm0ahf", ".svelte-1rm0ahf .svelte-1rm0ahf{color:white;font-family:\"Jetbrains Mono\"}main.svelte-1rm0ahf.svelte-1rm0ahf{width:100%;height:100%;display:flex;flex-direction:column}main.svelte-1rm0ahf #bar-container.svelte-1rm0ahf{width:100%;position:absolute;display:flex;flex-direction:column}main.svelte-1rm0ahf #bar-container #bar.svelte-1rm0ahf{flex-wrap:wrap;background:black;width:100%;height:100px;display:flex;padding:0rem 1rem;align-items:center}main.svelte-1rm0ahf #bar-container #bar.svelte-1rm0ahf>div{max-height:2.5rem}main.svelte-1rm0ahf canvas.svelte-1rm0ahf{width:100%;height:100%;display:block;margin:auto;padding:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXBwLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL3NwbHVuZ2Uvc3BsdW5nZS9zcmMvY29tcG9uZW50cy9BcHAuc3ZlbHRlIl19 */");
}

// (33:3) <FourIconsWidget>
function create_default_slot_3(ctx) {
	let undoredowidget;
	let t0;
	let gallerywidget;
	let updating_current_project;
	let updating_resize_project;
	let updating_project_has_been_modified;
	let updating_is_safe_to_switch_to_new_project;
	let t1;
	let pickcolourwidget;
	let updating_picking;
	let updating_just_finished_pick;
	let current;

	undoredowidget = new UndoRedoWidget_svelte({
			props: {
				undo: /*func*/ ctx[44],
				redo: /*func_1*/ ctx[45]
			},
			$$inline: true
		});

	function gallerywidget_current_project_binding(value) {
		/*gallerywidget_current_project_binding*/ ctx[49](value);
	}

	function gallerywidget_resize_project_binding(value) {
		/*gallerywidget_resize_project_binding*/ ctx[50](value);
	}

	function gallerywidget_project_has_been_modified_binding(value) {
		/*gallerywidget_project_has_been_modified_binding*/ ctx[51](value);
	}

	function gallerywidget_is_safe_to_switch_to_new_project_binding(value) {
		/*gallerywidget_is_safe_to_switch_to_new_project_binding*/ ctx[52](value);
	}

	let gallerywidget_props = {
		get_current_canvas_as_image: /*func_2*/ ctx[46],
		new_project: /*func_3*/ ctx[47],
		load_project: /*func_4*/ ctx[48]
	};

	if (/*project*/ ctx[20] !== void 0) {
		gallerywidget_props.current_project = /*project*/ ctx[20];
	}

	if (/*resize_project*/ ctx[23] !== void 0) {
		gallerywidget_props.resize_project = /*resize_project*/ ctx[23];
	}

	if (/*project_has_been_modified*/ ctx[22] !== void 0) {
		gallerywidget_props.project_has_been_modified = /*project_has_been_modified*/ ctx[22];
	}

	if (/*is_safe_to_switch_to_new_project*/ ctx[24] !== void 0) {
		gallerywidget_props.is_safe_to_switch_to_new_project = /*is_safe_to_switch_to_new_project*/ ctx[24];
	}

	gallerywidget = new GalleryWidget_svelte({
			props: gallerywidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(gallerywidget, 'current_project', gallerywidget_current_project_binding));
	binding_callbacks.push(() => bind(gallerywidget, 'resize_project', gallerywidget_resize_project_binding));
	binding_callbacks.push(() => bind(gallerywidget, 'project_has_been_modified', gallerywidget_project_has_been_modified_binding));
	binding_callbacks.push(() => bind(gallerywidget, 'is_safe_to_switch_to_new_project', gallerywidget_is_safe_to_switch_to_new_project_binding));

	function pickcolourwidget_picking_binding(value) {
		/*pickcolourwidget_picking_binding*/ ctx[54](value);
	}

	function pickcolourwidget_just_finished_pick_binding(value) {
		/*pickcolourwidget_just_finished_pick_binding*/ ctx[55](value);
	}

	let pickcolourwidget_props = { pick_from_canvas: /*func_5*/ ctx[53] };

	if (/*picking*/ ctx[18] !== void 0) {
		pickcolourwidget_props.picking = /*picking*/ ctx[18];
	}

	if (/*just_finished_pick*/ ctx[19] !== void 0) {
		pickcolourwidget_props.just_finished_pick = /*just_finished_pick*/ ctx[19];
	}

	pickcolourwidget = new PickColourWidget_svelte({
			props: pickcolourwidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(pickcolourwidget, 'picking', pickcolourwidget_picking_binding));
	binding_callbacks.push(() => bind(pickcolourwidget, 'just_finished_pick', pickcolourwidget_just_finished_pick_binding));

	const block = {
		c: function create() {
			create_component(undoredowidget.$$.fragment);
			t0 = space();
			create_component(gallerywidget.$$.fragment);
			t1 = space();
			create_component(pickcolourwidget.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(undoredowidget, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(gallerywidget, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(pickcolourwidget, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const undoredowidget_changes = {};
			if (dirty[0] & /*undo_pending*/ 65536) undoredowidget_changes.undo = /*func*/ ctx[44];
			if (dirty[0] & /*redo_pending*/ 131072) undoredowidget_changes.redo = /*func_1*/ ctx[45];
			undoredowidget.$set(undoredowidget_changes);
			const gallerywidget_changes = {};
			if (dirty[0] & /*canvas_read_tex*/ 67108864) gallerywidget_changes.get_current_canvas_as_image = /*func_2*/ ctx[46];
			if (dirty[0] & /*new_project_pending*/ 32768) gallerywidget_changes.new_project = /*func_3*/ ctx[47];
			if (dirty[0] & /*project_pending_load*/ 2097152) gallerywidget_changes.load_project = /*func_4*/ ctx[48];

			if (!updating_current_project && dirty[0] & /*project*/ 1048576) {
				updating_current_project = true;
				gallerywidget_changes.current_project = /*project*/ ctx[20];
				add_flush_callback(() => updating_current_project = false);
			}

			if (!updating_resize_project && dirty[0] & /*resize_project*/ 8388608) {
				updating_resize_project = true;
				gallerywidget_changes.resize_project = /*resize_project*/ ctx[23];
				add_flush_callback(() => updating_resize_project = false);
			}

			if (!updating_project_has_been_modified && dirty[0] & /*project_has_been_modified*/ 4194304) {
				updating_project_has_been_modified = true;
				gallerywidget_changes.project_has_been_modified = /*project_has_been_modified*/ ctx[22];
				add_flush_callback(() => updating_project_has_been_modified = false);
			}

			if (!updating_is_safe_to_switch_to_new_project && dirty[0] & /*is_safe_to_switch_to_new_project*/ 16777216) {
				updating_is_safe_to_switch_to_new_project = true;
				gallerywidget_changes.is_safe_to_switch_to_new_project = /*is_safe_to_switch_to_new_project*/ ctx[24];
				add_flush_callback(() => updating_is_safe_to_switch_to_new_project = false);
			}

			gallerywidget.$set(gallerywidget_changes);
			const pickcolourwidget_changes = {};

			if (!updating_picking && dirty[0] & /*picking*/ 262144) {
				updating_picking = true;
				pickcolourwidget_changes.picking = /*picking*/ ctx[18];
				add_flush_callback(() => updating_picking = false);
			}

			if (!updating_just_finished_pick && dirty[0] & /*just_finished_pick*/ 524288) {
				updating_just_finished_pick = true;
				pickcolourwidget_changes.just_finished_pick = /*just_finished_pick*/ ctx[19];
				add_flush_callback(() => updating_just_finished_pick = false);
			}

			pickcolourwidget.$set(pickcolourwidget_changes);
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(undoredowidget.$$.fragment, local);
			transitions_transition_in(gallerywidget.$$.fragment, local);
			transitions_transition_in(pickcolourwidget.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(undoredowidget.$$.fragment, local);
			transitions_transition_out(gallerywidget.$$.fragment, local);
			transitions_transition_out(pickcolourwidget.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
			}

			destroy_component(undoredowidget, detaching);
			destroy_component(gallerywidget, detaching);
			destroy_component(pickcolourwidget, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(33:3) <FourIconsWidget>",
		ctx
	});

	return block;
}

// (66:2) <SemiModal bind:this={chaosSemiModal} knob={chaosKnob}>
function create_default_slot_2(ctx) {
	let knob0;
	let updating_value;
	let t0;
	let knob1;
	let updating_value_1;
	let t1;
	let knob2;
	let updating_value_2;
	let t2;
	let knob3;
	let updating_value_3;
	let current;

	function knob0_value_binding_1(value) {
		/*knob0_value_binding_1*/ ctx[57](value);
	}

	let knob0_props = { title: 'Chaos L' };

	if (/*curr_brush*/ ctx[12].chaos_lch[0] !== void 0) {
		knob0_props.value = /*curr_brush*/ ctx[12].chaos_lch[0];
	}

	knob0 = new Knob_svelte({ props: knob0_props, $$inline: true });
	binding_callbacks.push(() => bind(knob0, 'value', knob0_value_binding_1));

	function knob1_value_binding_1(value) {
		/*knob1_value_binding_1*/ ctx[58](value);
	}

	let knob1_props = { title: 'Chaos C' };

	if (/*curr_brush*/ ctx[12].chaos_lch[1] !== void 0) {
		knob1_props.value = /*curr_brush*/ ctx[12].chaos_lch[1];
	}

	knob1 = new Knob_svelte({ props: knob1_props, $$inline: true });
	binding_callbacks.push(() => bind(knob1, 'value', knob1_value_binding_1));

	function knob2_value_binding_1(value) {
		/*knob2_value_binding_1*/ ctx[59](value);
	}

	let knob2_props = { title: 'Chaos H' };

	if (/*curr_brush*/ ctx[12].chaos_lch[2] !== void 0) {
		knob2_props.value = /*curr_brush*/ ctx[12].chaos_lch[2];
	}

	knob2 = new Knob_svelte({ props: knob2_props, $$inline: true });
	binding_callbacks.push(() => bind(knob2, 'value', knob2_value_binding_1));

	function knob3_value_binding(value) {
		/*knob3_value_binding*/ ctx[60](value);
	}

	let knob3_props = { title: 'Chaos Speed' };

	if (/*curr_brush*/ ctx[12].chaos_speed !== void 0) {
		knob3_props.value = /*curr_brush*/ ctx[12].chaos_speed;
	}

	knob3 = new Knob_svelte({ props: knob3_props, $$inline: true });
	binding_callbacks.push(() => bind(knob3, 'value', knob3_value_binding));

	const block = {
		c: function create() {
			create_component(knob0.$$.fragment);
			t0 = space();
			create_component(knob1.$$.fragment);
			t1 = space();
			create_component(knob2.$$.fragment);
			t2 = space();
			create_component(knob3.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(knob0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(knob1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(knob2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(knob3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const knob0_changes = {};

			if (!updating_value && dirty[0] & /*curr_brush*/ 4096) {
				updating_value = true;
				knob0_changes.value = /*curr_brush*/ ctx[12].chaos_lch[0];
				add_flush_callback(() => updating_value = false);
			}

			knob0.$set(knob0_changes);
			const knob1_changes = {};

			if (!updating_value_1 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_1 = true;
				knob1_changes.value = /*curr_brush*/ ctx[12].chaos_lch[1];
				add_flush_callback(() => updating_value_1 = false);
			}

			knob1.$set(knob1_changes);
			const knob2_changes = {};

			if (!updating_value_2 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_2 = true;
				knob2_changes.value = /*curr_brush*/ ctx[12].chaos_lch[2];
				add_flush_callback(() => updating_value_2 = false);
			}

			knob2.$set(knob2_changes);
			const knob3_changes = {};

			if (!updating_value_3 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_3 = true;
				knob3_changes.value = /*curr_brush*/ ctx[12].chaos_speed;
				add_flush_callback(() => updating_value_3 = false);
			}

			knob3.$set(knob3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(knob0.$$.fragment, local);
			transitions_transition_in(knob1.$$.fragment, local);
			transitions_transition_in(knob2.$$.fragment, local);
			transitions_transition_in(knob3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(knob0.$$.fragment, local);
			transitions_transition_out(knob1.$$.fragment, local);
			transitions_transition_out(knob2.$$.fragment, local);
			transitions_transition_out(knob3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
				detach_dev(t2);
			}

			destroy_component(knob0, detaching);
			destroy_component(knob1, detaching);
			destroy_component(knob2, detaching);
			destroy_component(knob3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(66:2) <SemiModal bind:this={chaosSemiModal} knob={chaosKnob}>",
		ctx
	});

	return block;
}

// (72:2) <SemiModal bind:this={dynamicsSemiModal} knob={dynamicsKnob}>
function create_default_slot_1(ctx) {
	let knob0;
	let updating_value;
	let t0;
	let knob1;
	let updating_value_1;
	let t1;
	let knob2;
	let updating_value_2;
	let t2;
	let knob3;
	let updating_value_3;
	let t3;
	let knob4;
	let updating_value_4;
	let t4;
	let knob5;
	let updating_value_5;
	let current;

	function knob0_value_binding_2(value) {
		/*knob0_value_binding_2*/ ctx[62](value);
	}

	let knob0_props = { title: 'Opacity min' };

	if (/*curr_brush*/ ctx[12].stroke_opacity_dynamics[0] !== void 0) {
		knob0_props.value = /*curr_brush*/ ctx[12].stroke_opacity_dynamics[0];
	}

	knob0 = new Knob_svelte({ props: knob0_props, $$inline: true });
	binding_callbacks.push(() => bind(knob0, 'value', knob0_value_binding_2));

	function knob1_value_binding_2(value) {
		/*knob1_value_binding_2*/ ctx[63](value);
	}

	let knob1_props = { title: 'Opacity max' };

	if (/*curr_brush*/ ctx[12].stroke_opacity_dynamics[1] !== void 0) {
		knob1_props.value = /*curr_brush*/ ctx[12].stroke_opacity_dynamics[1];
	}

	knob1 = new Knob_svelte({ props: knob1_props, $$inline: true });
	binding_callbacks.push(() => bind(knob1, 'value', knob1_value_binding_2));

	function knob2_value_binding_2(value) {
		/*knob2_value_binding_2*/ ctx[64](value);
	}

	let knob2_props = { title: 'Size min' };

	if (/*curr_brush*/ ctx[12].stroke_size_dynamics[0] !== void 0) {
		knob2_props.value = /*curr_brush*/ ctx[12].stroke_size_dynamics[0];
	}

	knob2 = new Knob_svelte({ props: knob2_props, $$inline: true });
	binding_callbacks.push(() => bind(knob2, 'value', knob2_value_binding_2));

	function knob3_value_binding_1(value) {
		/*knob3_value_binding_1*/ ctx[65](value);
	}

	let knob3_props = { title: 'Size max' };

	if (/*curr_brush*/ ctx[12].stroke_size_dynamics[1] !== void 0) {
		knob3_props.value = /*curr_brush*/ ctx[12].stroke_size_dynamics[1];
	}

	knob3 = new Knob_svelte({ props: knob3_props, $$inline: true });
	binding_callbacks.push(() => bind(knob3, 'value', knob3_value_binding_1));

	function knob4_value_binding(value) {
		/*knob4_value_binding*/ ctx[66](value);
	}

	let knob4_props = { title: 'Rot jitt' };

	if (/*curr_brush*/ ctx[12].rot_jitter !== void 0) {
		knob4_props.value = /*curr_brush*/ ctx[12].rot_jitter;
	}

	knob4 = new Knob_svelte({ props: knob4_props, $$inline: true });
	binding_callbacks.push(() => bind(knob4, 'value', knob4_value_binding));

	function knob5_value_binding(value) {
		/*knob5_value_binding*/ ctx[67](value);
	}

	let knob5_props = { title: 'Pos jitt' };

	if (/*curr_brush*/ ctx[12].pos_jitter !== void 0) {
		knob5_props.value = /*curr_brush*/ ctx[12].pos_jitter;
	}

	knob5 = new Knob_svelte({ props: knob5_props, $$inline: true });
	binding_callbacks.push(() => bind(knob5, 'value', knob5_value_binding));

	const block = {
		c: function create() {
			create_component(knob0.$$.fragment);
			t0 = space();
			create_component(knob1.$$.fragment);
			t1 = space();
			create_component(knob2.$$.fragment);
			t2 = space();
			create_component(knob3.$$.fragment);
			t3 = space();
			create_component(knob4.$$.fragment);
			t4 = space();
			create_component(knob5.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(knob0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(knob1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(knob2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(knob3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(knob4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(knob5, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const knob0_changes = {};

			if (!updating_value && dirty[0] & /*curr_brush*/ 4096) {
				updating_value = true;
				knob0_changes.value = /*curr_brush*/ ctx[12].stroke_opacity_dynamics[0];
				add_flush_callback(() => updating_value = false);
			}

			knob0.$set(knob0_changes);
			const knob1_changes = {};

			if (!updating_value_1 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_1 = true;
				knob1_changes.value = /*curr_brush*/ ctx[12].stroke_opacity_dynamics[1];
				add_flush_callback(() => updating_value_1 = false);
			}

			knob1.$set(knob1_changes);
			const knob2_changes = {};

			if (!updating_value_2 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_2 = true;
				knob2_changes.value = /*curr_brush*/ ctx[12].stroke_size_dynamics[0];
				add_flush_callback(() => updating_value_2 = false);
			}

			knob2.$set(knob2_changes);
			const knob3_changes = {};

			if (!updating_value_3 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_3 = true;
				knob3_changes.value = /*curr_brush*/ ctx[12].stroke_size_dynamics[1];
				add_flush_callback(() => updating_value_3 = false);
			}

			knob3.$set(knob3_changes);
			const knob4_changes = {};

			if (!updating_value_4 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_4 = true;
				knob4_changes.value = /*curr_brush*/ ctx[12].rot_jitter;
				add_flush_callback(() => updating_value_4 = false);
			}

			knob4.$set(knob4_changes);
			const knob5_changes = {};

			if (!updating_value_5 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_5 = true;
				knob5_changes.value = /*curr_brush*/ ctx[12].pos_jitter;
				add_flush_callback(() => updating_value_5 = false);
			}

			knob5.$set(knob5_changes);
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(knob0.$$.fragment, local);
			transitions_transition_in(knob1.$$.fragment, local);
			transitions_transition_in(knob2.$$.fragment, local);
			transitions_transition_in(knob3.$$.fragment, local);
			transitions_transition_in(knob4.$$.fragment, local);
			transitions_transition_in(knob5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(knob0.$$.fragment, local);
			transitions_transition_out(knob1.$$.fragment, local);
			transitions_transition_out(knob2.$$.fragment, local);
			transitions_transition_out(knob3.$$.fragment, local);
			transitions_transition_out(knob4.$$.fragment, local);
			transitions_transition_out(knob5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
				detach_dev(t2);
				detach_dev(t3);
				detach_dev(t4);
			}

			destroy_component(knob0, detaching);
			destroy_component(knob1, detaching);
			destroy_component(knob2, detaching);
			destroy_component(knob3, detaching);
			destroy_component(knob4, detaching);
			destroy_component(knob5, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(72:2) <SemiModal bind:this={dynamicsSemiModal} knob={dynamicsKnob}>",
		ctx
	});

	return block;
}

// (80:2) <SemiModal bind:this={texDynamicsSemiModal} knob={texDynamicsKnob}>
function create_default_slot(ctx) {
	let knob0;
	let updating_value;
	let t0;
	let knob1;
	let updating_value_1;
	let t1;
	let knob2;
	let updating_value_2;
	let t2;
	let knob3;
	let updating_value_3;
	let t3;
	let knob4;
	let updating_value_4;
	let t4;
	let texturewidget;
	let updating_brush_textures;
	let updating_selected_brush_texture;
	let current;

	function knob0_value_binding_3(value) {
		/*knob0_value_binding_3*/ ctx[69](value);
	}

	let knob0_props = { title: 'Stretch X' };

	if (/*curr_brush*/ ctx[12].tex_stretch[0] !== void 0) {
		knob0_props.value = /*curr_brush*/ ctx[12].tex_stretch[0];
	}

	knob0 = new Knob_svelte({ props: knob0_props, $$inline: true });
	binding_callbacks.push(() => bind(knob0, 'value', knob0_value_binding_3));

	function knob1_value_binding_3(value) {
		/*knob1_value_binding_3*/ ctx[70](value);
	}

	let knob1_props = { title: 'Stretch Y' };

	if (/*curr_brush*/ ctx[12].tex_stretch[1] !== void 0) {
		knob1_props.value = /*curr_brush*/ ctx[12].tex_stretch[1];
	}

	knob1 = new Knob_svelte({ props: knob1_props, $$inline: true });
	binding_callbacks.push(() => bind(knob1, 'value', knob1_value_binding_3));

	function knob2_value_binding_3(value) {
		/*knob2_value_binding_3*/ ctx[71](value);
	}

	let knob2_props = { title: 'Tex V' };

	if (/*curr_brush*/ ctx[12].tex_lch_dynamics[0] !== void 0) {
		knob2_props.value = /*curr_brush*/ ctx[12].tex_lch_dynamics[0];
	}

	knob2 = new Knob_svelte({ props: knob2_props, $$inline: true });
	binding_callbacks.push(() => bind(knob2, 'value', knob2_value_binding_3));

	function knob3_value_binding_2(value) {
		/*knob3_value_binding_2*/ ctx[72](value);
	}

	let knob3_props = { title: 'Tex S' };

	if (/*curr_brush*/ ctx[12].tex_lch_dynamics[1] !== void 0) {
		knob3_props.value = /*curr_brush*/ ctx[12].tex_lch_dynamics[1];
	}

	knob3 = new Knob_svelte({ props: knob3_props, $$inline: true });
	binding_callbacks.push(() => bind(knob3, 'value', knob3_value_binding_2));

	function knob4_value_binding_1(value) {
		/*knob4_value_binding_1*/ ctx[73](value);
	}

	let knob4_props = { title: 'Tex H' };

	if (/*curr_brush*/ ctx[12].tex_lch_dynamics[2] !== void 0) {
		knob4_props.value = /*curr_brush*/ ctx[12].tex_lch_dynamics[2];
	}

	knob4 = new Knob_svelte({ props: knob4_props, $$inline: true });
	binding_callbacks.push(() => bind(knob4, 'value', knob4_value_binding_1));

	function texturewidget_brush_textures_binding(value) {
		/*texturewidget_brush_textures_binding*/ ctx[74](value);
	}

	function texturewidget_selected_brush_texture_binding(value) {
		/*texturewidget_selected_brush_texture_binding*/ ctx[75](value);
	}

	let texturewidget_props = {};

	if (/*brush_textures*/ ctx[14] !== void 0) {
		texturewidget_props.brush_textures = /*brush_textures*/ ctx[14];
	}

	if (/*curr_brush*/ ctx[12].selected_brush_texture !== void 0) {
		texturewidget_props.selected_brush_texture = /*curr_brush*/ ctx[12].selected_brush_texture;
	}

	texturewidget = new TextureWidget_svelte({
			props: texturewidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(texturewidget, 'brush_textures', texturewidget_brush_textures_binding));
	binding_callbacks.push(() => bind(texturewidget, 'selected_brush_texture', texturewidget_selected_brush_texture_binding));

	const block = {
		c: function create() {
			create_component(knob0.$$.fragment);
			t0 = space();
			create_component(knob1.$$.fragment);
			t1 = space();
			create_component(knob2.$$.fragment);
			t2 = space();
			create_component(knob3.$$.fragment);
			t3 = space();
			create_component(knob4.$$.fragment);
			t4 = space();
			create_component(texturewidget.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(knob0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(knob1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(knob2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(knob3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(knob4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(texturewidget, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const knob0_changes = {};

			if (!updating_value && dirty[0] & /*curr_brush*/ 4096) {
				updating_value = true;
				knob0_changes.value = /*curr_brush*/ ctx[12].tex_stretch[0];
				add_flush_callback(() => updating_value = false);
			}

			knob0.$set(knob0_changes);
			const knob1_changes = {};

			if (!updating_value_1 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_1 = true;
				knob1_changes.value = /*curr_brush*/ ctx[12].tex_stretch[1];
				add_flush_callback(() => updating_value_1 = false);
			}

			knob1.$set(knob1_changes);
			const knob2_changes = {};

			if (!updating_value_2 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_2 = true;
				knob2_changes.value = /*curr_brush*/ ctx[12].tex_lch_dynamics[0];
				add_flush_callback(() => updating_value_2 = false);
			}

			knob2.$set(knob2_changes);
			const knob3_changes = {};

			if (!updating_value_3 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_3 = true;
				knob3_changes.value = /*curr_brush*/ ctx[12].tex_lch_dynamics[1];
				add_flush_callback(() => updating_value_3 = false);
			}

			knob3.$set(knob3_changes);
			const knob4_changes = {};

			if (!updating_value_4 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_4 = true;
				knob4_changes.value = /*curr_brush*/ ctx[12].tex_lch_dynamics[2];
				add_flush_callback(() => updating_value_4 = false);
			}

			knob4.$set(knob4_changes);
			const texturewidget_changes = {};

			if (!updating_brush_textures && dirty[0] & /*brush_textures*/ 16384) {
				updating_brush_textures = true;
				texturewidget_changes.brush_textures = /*brush_textures*/ ctx[14];
				add_flush_callback(() => updating_brush_textures = false);
			}

			if (!updating_selected_brush_texture && dirty[0] & /*curr_brush*/ 4096) {
				updating_selected_brush_texture = true;
				texturewidget_changes.selected_brush_texture = /*curr_brush*/ ctx[12].selected_brush_texture;
				add_flush_callback(() => updating_selected_brush_texture = false);
			}

			texturewidget.$set(texturewidget_changes);
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(knob0.$$.fragment, local);
			transitions_transition_in(knob1.$$.fragment, local);
			transitions_transition_in(knob2.$$.fragment, local);
			transitions_transition_in(knob3.$$.fragment, local);
			transitions_transition_in(knob4.$$.fragment, local);
			transitions_transition_in(texturewidget.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(knob0.$$.fragment, local);
			transitions_transition_out(knob1.$$.fragment, local);
			transitions_transition_out(knob2.$$.fragment, local);
			transitions_transition_out(knob3.$$.fragment, local);
			transitions_transition_out(knob4.$$.fragment, local);
			transitions_transition_out(texturewidget.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
				detach_dev(t2);
				detach_dev(t3);
				detach_dev(t4);
			}

			destroy_component(knob0, detaching);
			destroy_component(knob1, detaching);
			destroy_component(knob2, detaching);
			destroy_component(knob3, detaching);
			destroy_component(knob4, detaching);
			destroy_component(texturewidget, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(80:2) <SemiModal bind:this={texDynamicsSemiModal} knob={texDynamicsKnob}>",
		ctx
	});

	return block;
}

function App_svelte_create_fragment(ctx) {
	let main;
	let div1;
	let div0;
	let rgbsliders;
	let updating_colour;
	let t0;
	let colourdisplay;
	let updating_colour_1;
	let updating_update_display;
	let t1;
	let knob0;
	let updating_value;
	let t2;
	let brushsizewidget;
	let updating_brush_sz;
	let updating_dragging;
	let updating_stopped_dragging;
	let t3;
	let knob1;
	let updating_value_1;
	let t4;
	let knob2;
	let updating_value_2;
	let t5;
	let brushtypewidget;
	let updating_curr_brush;
	let t6;
	let brushpresetwidget;
	let updating_brush_presets;
	let updating_selected_brush_preset;
	let t7;
	let fouriconswidget;
	let t8;
	let blendingcolourspacewidget;
	let updating_selected_colour_space;
	let t9;
	let floatingmodal;
	let t10;
	let semimodal0;
	let t11;
	let semimodal1;
	let t12;
	let semimodal2;
	let t13;
	let canvas;
	let current;

	function rgbsliders_colour_binding(value) {
		/*rgbsliders_colour_binding*/ ctx[29](value);
	}

	let rgbsliders_props = {};

	if (/*stroke_col*/ ctx[9] !== void 0) {
		rgbsliders_props.colour = /*stroke_col*/ ctx[9];
	}

	rgbsliders = new RGBSliders_svelte({ props: rgbsliders_props, $$inline: true });
	binding_callbacks.push(() => bind(rgbsliders, 'colour', rgbsliders_colour_binding));

	function colourdisplay_colour_binding(value) {
		/*colourdisplay_colour_binding*/ ctx[30](value);
	}

	function colourdisplay_update_display_binding(value) {
		/*colourdisplay_update_display_binding*/ ctx[31](value);
	}

	let colourdisplay_props = {};

	if (/*stroke_col*/ ctx[9] !== void 0) {
		colourdisplay_props.colour = /*stroke_col*/ ctx[9];
	}

	if (/*trigger_colour_display_update*/ ctx[25] !== void 0) {
		colourdisplay_props.update_display = /*trigger_colour_display_update*/ ctx[25];
	}

	colourdisplay = new ColourDisplay_svelte({
			props: colourdisplay_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(colourdisplay, 'colour', colourdisplay_colour_binding));
	binding_callbacks.push(() => bind(colourdisplay, 'update_display', colourdisplay_update_display_binding));

	function knob0_value_binding(value) {
		/*knob0_value_binding*/ ctx[33](value);
	}

	let knob0_props = {
		title: 'Chaos',
		triggerModal: /*openModal*/ ctx[28],
		modal: /*chaosSemiModal*/ ctx[1]
	};

	if (/*curr_brush*/ ctx[12].chaos !== void 0) {
		knob0_props.value = /*curr_brush*/ ctx[12].chaos;
	}

	knob0 = new Knob_svelte({ props: knob0_props, $$inline: true });
	/*knob0_binding*/ ctx[32](knob0);
	binding_callbacks.push(() => bind(knob0, 'value', knob0_value_binding));

	function brushsizewidget_brush_sz_binding(value) {
		/*brushsizewidget_brush_sz_binding*/ ctx[34](value);
	}

	function brushsizewidget_dragging_binding(value) {
		/*brushsizewidget_dragging_binding*/ ctx[35](value);
	}

	function brushsizewidget_stopped_dragging_binding(value) {
		/*brushsizewidget_stopped_dragging_binding*/ ctx[36](value);
	}

	let brushsizewidget_props = {};

	if (/*brush_sz*/ ctx[10] !== void 0) {
		brushsizewidget_props.brush_sz = /*brush_sz*/ ctx[10];
	}

	if (/*brushSizeWidgetDragging*/ ctx[4] !== void 0) {
		brushsizewidget_props.dragging = /*brushSizeWidgetDragging*/ ctx[4];
	}

	if (/*brushSizeWidgetStoppedDragging*/ ctx[5] !== void 0) {
		brushsizewidget_props.stopped_dragging = /*brushSizeWidgetStoppedDragging*/ ctx[5];
	}

	brushsizewidget = new BrushSizeWidget_svelte({
			props: brushsizewidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(brushsizewidget, 'brush_sz', brushsizewidget_brush_sz_binding));
	binding_callbacks.push(() => bind(brushsizewidget, 'dragging', brushsizewidget_dragging_binding));
	binding_callbacks.push(() => bind(brushsizewidget, 'stopped_dragging', brushsizewidget_stopped_dragging_binding));

	function knob1_value_binding(value) {
		/*knob1_value_binding*/ ctx[38](value);
	}

	let knob1_props = {
		title: 'Dynamics',
		triggerModal: /*openModal*/ ctx[28],
		modal: /*dynamicsSemiModal*/ ctx[2]
	};

	if (/*curr_brush*/ ctx[12].dynamics !== void 0) {
		knob1_props.value = /*curr_brush*/ ctx[12].dynamics;
	}

	knob1 = new Knob_svelte({ props: knob1_props, $$inline: true });
	/*knob1_binding*/ ctx[37](knob1);
	binding_callbacks.push(() => bind(knob1, 'value', knob1_value_binding));

	function knob2_value_binding(value) {
		/*knob2_value_binding*/ ctx[40](value);
	}

	let knob2_props = {
		title: 'Tex',
		triggerModal: /*openModal*/ ctx[28],
		modal: /*texDynamicsSemiModal*/ ctx[3]
	};

	if (/*curr_brush*/ ctx[12].tex_dynamics !== void 0) {
		knob2_props.value = /*curr_brush*/ ctx[12].tex_dynamics;
	}

	knob2 = new Knob_svelte({ props: knob2_props, $$inline: true });
	/*knob2_binding*/ ctx[39](knob2);
	binding_callbacks.push(() => bind(knob2, 'value', knob2_value_binding));

	function brushtypewidget_curr_brush_binding(value) {
		/*brushtypewidget_curr_brush_binding*/ ctx[41](value);
	}

	let brushtypewidget_props = {};

	if (/*curr_brush*/ ctx[12] !== void 0) {
		brushtypewidget_props.curr_brush = /*curr_brush*/ ctx[12];
	}

	brushtypewidget = new BrushTypeWidget_svelte({
			props: brushtypewidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(brushtypewidget, 'curr_brush', brushtypewidget_curr_brush_binding));

	function brushpresetwidget_brush_presets_binding(value) {
		/*brushpresetwidget_brush_presets_binding*/ ctx[42](value);
	}

	function brushpresetwidget_selected_brush_preset_binding(value) {
		/*brushpresetwidget_selected_brush_preset_binding*/ ctx[43](value);
	}

	let brushpresetwidget_props = {};

	if (/*brush_presets*/ ctx[11] !== void 0) {
		brushpresetwidget_props.brush_presets = /*brush_presets*/ ctx[11];
	}

	if (/*curr_brush*/ ctx[12] !== void 0) {
		brushpresetwidget_props.selected_brush_preset = /*curr_brush*/ ctx[12];
	}

	brushpresetwidget = new BrushPresetWidget_svelte({
			props: brushpresetwidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(brushpresetwidget, 'brush_presets', brushpresetwidget_brush_presets_binding));
	binding_callbacks.push(() => bind(brushpresetwidget, 'selected_brush_preset', brushpresetwidget_selected_brush_preset_binding));

	fouriconswidget = new FourIconsWidget_svelte({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	function blendingcolourspacewidget_selected_colour_space_binding(value) {
		/*blendingcolourspacewidget_selected_colour_space_binding*/ ctx[56](value);
	}

	let blendingcolourspacewidget_props = {};

	if (/*blending_colour_space*/ ctx[13] !== void 0) {
		blendingcolourspacewidget_props.selected_colour_space = /*blending_colour_space*/ ctx[13];
	}

	blendingcolourspacewidget = new BlendingColourSpaceWidget_svelte({
			props: blendingcolourspacewidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(blendingcolourspacewidget, 'selected_colour_space', blendingcolourspacewidget_selected_colour_space_binding));
	floatingmodal = new FloatingModal_svelte({ $$inline: true });

	let semimodal0_props = {
		knob: /*chaosKnob*/ ctx[6],
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	};

	semimodal0 = new SemiModal_svelte({ props: semimodal0_props, $$inline: true });
	/*semimodal0_binding*/ ctx[61](semimodal0);

	let semimodal1_props = {
		knob: /*dynamicsKnob*/ ctx[7],
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	};

	semimodal1 = new SemiModal_svelte({ props: semimodal1_props, $$inline: true });
	/*semimodal1_binding*/ ctx[68](semimodal1);

	let semimodal2_props = {
		knob: /*texDynamicsKnob*/ ctx[8],
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	semimodal2 = new SemiModal_svelte({ props: semimodal2_props, $$inline: true });
	/*semimodal2_binding*/ ctx[76](semimodal2);

	const block = {
		c: function create() {
			main = dom_element("main");
			div1 = dom_element("div");
			div0 = dom_element("div");
			create_component(rgbsliders.$$.fragment);
			t0 = space();
			create_component(colourdisplay.$$.fragment);
			t1 = space();
			create_component(knob0.$$.fragment);
			t2 = space();
			create_component(brushsizewidget.$$.fragment);
			t3 = space();
			create_component(knob1.$$.fragment);
			t4 = space();
			create_component(knob2.$$.fragment);
			t5 = space();
			create_component(brushtypewidget.$$.fragment);
			t6 = space();
			create_component(brushpresetwidget.$$.fragment);
			t7 = space();
			create_component(fouriconswidget.$$.fragment);
			t8 = space();
			create_component(blendingcolourspacewidget.$$.fragment);
			t9 = space();
			create_component(floatingmodal.$$.fragment);
			t10 = space();
			create_component(semimodal0.$$.fragment);
			t11 = space();
			create_component(semimodal1.$$.fragment);
			t12 = space();
			create_component(semimodal2.$$.fragment);
			t13 = space();
			canvas = dom_element("canvas");
			attr_dev(div0, "id", "bar");
			attr_dev(div0, "class", "svelte-1rm0ahf");
			add_location(div0, App_svelte_file, 2, 2, 35);
			attr_dev(div1, "id", "bar-container");
			attr_dev(div1, "class", "svelte-1rm0ahf");
			add_location(div1, App_svelte_file, 1, 1, 8);
			attr_dev(canvas, "id", "canvas");
			attr_dev(canvas, "class", "svelte-1rm0ahf");
			add_location(canvas, App_svelte_file, 88, 1, 3692);
			attr_dev(main, "class", "svelte-1rm0ahf");
			add_location(main, App_svelte_file, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div1);
			append_dev(div1, div0);
			mount_component(rgbsliders, div0, null);
			append_dev(div0, t0);
			mount_component(colourdisplay, div0, null);
			append_dev(div0, t1);
			mount_component(knob0, div0, null);
			append_dev(div0, t2);
			mount_component(brushsizewidget, div0, null);
			append_dev(div0, t3);
			mount_component(knob1, div0, null);
			append_dev(div0, t4);
			mount_component(knob2, div0, null);
			append_dev(div0, t5);
			mount_component(brushtypewidget, div0, null);
			append_dev(div0, t6);
			mount_component(brushpresetwidget, div0, null);
			append_dev(div0, t7);
			mount_component(fouriconswidget, div0, null);
			append_dev(div0, t8);
			mount_component(blendingcolourspacewidget, div0, null);
			append_dev(div0, t9);
			mount_component(floatingmodal, div0, null);
			append_dev(div1, t10);
			mount_component(semimodal0, div1, null);
			append_dev(div1, t11);
			mount_component(semimodal1, div1, null);
			append_dev(div1, t12);
			mount_component(semimodal2, div1, null);
			append_dev(main, t13);
			append_dev(main, canvas);
			/*canvas_binding*/ ctx[77](canvas);
			current = true;
		},
		p: function update(ctx, dirty) {
			const rgbsliders_changes = {};

			if (!updating_colour && dirty[0] & /*stroke_col*/ 512) {
				updating_colour = true;
				rgbsliders_changes.colour = /*stroke_col*/ ctx[9];
				add_flush_callback(() => updating_colour = false);
			}

			rgbsliders.$set(rgbsliders_changes);
			const colourdisplay_changes = {};

			if (!updating_colour_1 && dirty[0] & /*stroke_col*/ 512) {
				updating_colour_1 = true;
				colourdisplay_changes.colour = /*stroke_col*/ ctx[9];
				add_flush_callback(() => updating_colour_1 = false);
			}

			if (!updating_update_display && dirty[0] & /*trigger_colour_display_update*/ 33554432) {
				updating_update_display = true;
				colourdisplay_changes.update_display = /*trigger_colour_display_update*/ ctx[25];
				add_flush_callback(() => updating_update_display = false);
			}

			colourdisplay.$set(colourdisplay_changes);
			const knob0_changes = {};
			if (dirty[0] & /*chaosSemiModal*/ 2) knob0_changes.modal = /*chaosSemiModal*/ ctx[1];

			if (!updating_value && dirty[0] & /*curr_brush*/ 4096) {
				updating_value = true;
				knob0_changes.value = /*curr_brush*/ ctx[12].chaos;
				add_flush_callback(() => updating_value = false);
			}

			knob0.$set(knob0_changes);
			const brushsizewidget_changes = {};

			if (!updating_brush_sz && dirty[0] & /*brush_sz*/ 1024) {
				updating_brush_sz = true;
				brushsizewidget_changes.brush_sz = /*brush_sz*/ ctx[10];
				add_flush_callback(() => updating_brush_sz = false);
			}

			if (!updating_dragging && dirty[0] & /*brushSizeWidgetDragging*/ 16) {
				updating_dragging = true;
				brushsizewidget_changes.dragging = /*brushSizeWidgetDragging*/ ctx[4];
				add_flush_callback(() => updating_dragging = false);
			}

			if (!updating_stopped_dragging && dirty[0] & /*brushSizeWidgetStoppedDragging*/ 32) {
				updating_stopped_dragging = true;
				brushsizewidget_changes.stopped_dragging = /*brushSizeWidgetStoppedDragging*/ ctx[5];
				add_flush_callback(() => updating_stopped_dragging = false);
			}

			brushsizewidget.$set(brushsizewidget_changes);
			const knob1_changes = {};
			if (dirty[0] & /*dynamicsSemiModal*/ 4) knob1_changes.modal = /*dynamicsSemiModal*/ ctx[2];

			if (!updating_value_1 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_1 = true;
				knob1_changes.value = /*curr_brush*/ ctx[12].dynamics;
				add_flush_callback(() => updating_value_1 = false);
			}

			knob1.$set(knob1_changes);
			const knob2_changes = {};
			if (dirty[0] & /*texDynamicsSemiModal*/ 8) knob2_changes.modal = /*texDynamicsSemiModal*/ ctx[3];

			if (!updating_value_2 && dirty[0] & /*curr_brush*/ 4096) {
				updating_value_2 = true;
				knob2_changes.value = /*curr_brush*/ ctx[12].tex_dynamics;
				add_flush_callback(() => updating_value_2 = false);
			}

			knob2.$set(knob2_changes);
			const brushtypewidget_changes = {};

			if (!updating_curr_brush && dirty[0] & /*curr_brush*/ 4096) {
				updating_curr_brush = true;
				brushtypewidget_changes.curr_brush = /*curr_brush*/ ctx[12];
				add_flush_callback(() => updating_curr_brush = false);
			}

			brushtypewidget.$set(brushtypewidget_changes);
			const brushpresetwidget_changes = {};

			if (!updating_brush_presets && dirty[0] & /*brush_presets*/ 2048) {
				updating_brush_presets = true;
				brushpresetwidget_changes.brush_presets = /*brush_presets*/ ctx[11];
				add_flush_callback(() => updating_brush_presets = false);
			}

			if (!updating_selected_brush_preset && dirty[0] & /*curr_brush*/ 4096) {
				updating_selected_brush_preset = true;
				brushpresetwidget_changes.selected_brush_preset = /*curr_brush*/ ctx[12];
				add_flush_callback(() => updating_selected_brush_preset = false);
			}

			brushpresetwidget.$set(brushpresetwidget_changes);
			const fouriconswidget_changes = {};

			if (dirty[0] & /*picking, just_finished_pick, canvas_read_tex, new_project_pending, project_pending_load, project, resize_project, project_has_been_modified, is_safe_to_switch_to_new_project, undo_pending, redo_pending*/ 100630528 | dirty[3] & /*$$scope*/ 256) {
				fouriconswidget_changes.$$scope = { dirty, ctx };
			}

			fouriconswidget.$set(fouriconswidget_changes);
			const blendingcolourspacewidget_changes = {};

			if (!updating_selected_colour_space && dirty[0] & /*blending_colour_space*/ 8192) {
				updating_selected_colour_space = true;
				blendingcolourspacewidget_changes.selected_colour_space = /*blending_colour_space*/ ctx[13];
				add_flush_callback(() => updating_selected_colour_space = false);
			}

			blendingcolourspacewidget.$set(blendingcolourspacewidget_changes);
			const semimodal0_changes = {};
			if (dirty[0] & /*chaosKnob*/ 64) semimodal0_changes.knob = /*chaosKnob*/ ctx[6];

			if (dirty[0] & /*curr_brush*/ 4096 | dirty[3] & /*$$scope*/ 256) {
				semimodal0_changes.$$scope = { dirty, ctx };
			}

			semimodal0.$set(semimodal0_changes);
			const semimodal1_changes = {};
			if (dirty[0] & /*dynamicsKnob*/ 128) semimodal1_changes.knob = /*dynamicsKnob*/ ctx[7];

			if (dirty[0] & /*curr_brush*/ 4096 | dirty[3] & /*$$scope*/ 256) {
				semimodal1_changes.$$scope = { dirty, ctx };
			}

			semimodal1.$set(semimodal1_changes);
			const semimodal2_changes = {};
			if (dirty[0] & /*texDynamicsKnob*/ 256) semimodal2_changes.knob = /*texDynamicsKnob*/ ctx[8];

			if (dirty[0] & /*brush_textures, curr_brush*/ 20480 | dirty[3] & /*$$scope*/ 256) {
				semimodal2_changes.$$scope = { dirty, ctx };
			}

			semimodal2.$set(semimodal2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(rgbsliders.$$.fragment, local);
			transitions_transition_in(colourdisplay.$$.fragment, local);
			transitions_transition_in(knob0.$$.fragment, local);
			transitions_transition_in(brushsizewidget.$$.fragment, local);
			transitions_transition_in(knob1.$$.fragment, local);
			transitions_transition_in(knob2.$$.fragment, local);
			transitions_transition_in(brushtypewidget.$$.fragment, local);
			transitions_transition_in(brushpresetwidget.$$.fragment, local);
			transitions_transition_in(fouriconswidget.$$.fragment, local);
			transitions_transition_in(blendingcolourspacewidget.$$.fragment, local);
			transitions_transition_in(floatingmodal.$$.fragment, local);
			transitions_transition_in(semimodal0.$$.fragment, local);
			transitions_transition_in(semimodal1.$$.fragment, local);
			transitions_transition_in(semimodal2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(rgbsliders.$$.fragment, local);
			transitions_transition_out(colourdisplay.$$.fragment, local);
			transitions_transition_out(knob0.$$.fragment, local);
			transitions_transition_out(brushsizewidget.$$.fragment, local);
			transitions_transition_out(knob1.$$.fragment, local);
			transitions_transition_out(knob2.$$.fragment, local);
			transitions_transition_out(brushtypewidget.$$.fragment, local);
			transitions_transition_out(brushpresetwidget.$$.fragment, local);
			transitions_transition_out(fouriconswidget.$$.fragment, local);
			transitions_transition_out(blendingcolourspacewidget.$$.fragment, local);
			transitions_transition_out(floatingmodal.$$.fragment, local);
			transitions_transition_out(semimodal0.$$.fragment, local);
			transitions_transition_out(semimodal1.$$.fragment, local);
			transitions_transition_out(semimodal2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(main);
			}

			destroy_component(rgbsliders);
			destroy_component(colourdisplay);
			/*knob0_binding*/ ctx[32](null);
			destroy_component(knob0);
			destroy_component(brushsizewidget);
			/*knob1_binding*/ ctx[37](null);
			destroy_component(knob1);
			/*knob2_binding*/ ctx[39](null);
			destroy_component(knob2);
			destroy_component(brushtypewidget);
			destroy_component(brushpresetwidget);
			destroy_component(fouriconswidget);
			destroy_component(blendingcolourspacewidget);
			destroy_component(floatingmodal);
			/*semimodal0_binding*/ ctx[61](null);
			destroy_component(semimodal0);
			/*semimodal1_binding*/ ctx[68](null);
			destroy_component(semimodal1);
			/*semimodal2_binding*/ ctx[76](null);
			destroy_component(semimodal2);
			/*canvas_binding*/ ctx[77](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: App_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const undo_cache_steps = 25;

function App_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('App', slots, []);
	let hash = new Hash();
	let io;
	let gl;
	let zoom = Float32Array.from([1]);
	window.zoom = zoom;
	let desired_zoom = 1;
	let panning_temp_pinch = [0, 0];
	let panning = [0, 0];
	let userAgentRes = [0, 0];
	let default_framebuffer;
	let canvasElement;
	let chaosSemiModal;
	let dynamicsSemiModal;
	let texDynamicsSemiModal;
	let modals = [];
	let brushSizeWidgetDragging;
	let brushSizeWidgetStoppedDragging;
	let chaosKnob;
	let dynamicsKnob;
	let texDynamicsKnob;
	let stroke_col = [0.5, 0.4, 0.3, 1];
	let stroke_opacity = 0;
	let brush_rot = [0, 0];
	let brush_pos_ndc_screen = [0, 0];
	let brush_pos_ndc_canvas = [0, 0];
	let brush_sz = [1, 0.2];
	let brush_presets = [];

	for (let i = 0; i < 6; i++) {
		brush_presets.push(new BrushPreset());
	}

	let curr_brush = brush_presets[0];
	let blending_colour_space = BlendingColourSpace.OkLCH;
	let brush_textures = [];
	let new_project_pending = false;
	let undo_pending = false;
	let redo_pending = false;
	let picking;
	let just_finished_pick;
	let picked_col = [0, 0, 0];
	let project = new Project();
	let project_pending_load;
	let project_has_been_modified = false;
	let resize_project;
	let is_safe_to_switch_to_new_project;
	let full_redraw_needed = false;
	let trigger_colour_display_update;
	let canvas_fb;
	let canvas_read_tex;
	let temp_undo_fb;
	let drawer;
	let ubo;

	const set_shared_uniforms = () => {
		ubo.buff.sz = 0;
		ubo.buff.cpu_buff[0] = canvas_fb._textures[0].res[0];
		ubo.buff.cpu_buff[1] = canvas_fb._textures[0].res[1];
		ubo.buff.cpu_buff[2] = default_framebuffer.textures[0].res[0];
		ubo.buff.cpu_buff[3] = default_framebuffer.textures[0].res[1];
		ubo.buff.cpu_buff[4] = isOnMobile ? 1 : 0;
		ubo.buff.upload();
	};

	const pick_from_canvas = () => {
		let coord = Utils.texture_NDC_to_texture_pixel_coords(Utils.screen_NDC_to_canvas_NDC([...io.mouse_pos], default_framebuffer.textures[0], canvas_read_tex, zoom[0], panning), canvas_read_tex);
		let c = canvas_read_tex.read_back_pixel(coord);
		picked_col = [...c];
		picked_col[0] = c[0] / 255;
		picked_col[1] = c[1] / 255;
		picked_col[2] = c[2] / 255;
		picked_col[0] = pow(picked_col[0], 0.45454545454545);
		picked_col[1] = pow(picked_col[1], 0.45454545454545);
		picked_col[2] = pow(picked_col[2], 0.45454545454545);
		picked_col.pop();
		return c;
	};

	const openModal = modal => {
		for (let m of modals) {
			if (m === modal) {
				if (m.hidden) {
					m.hidden = false;
					m.knob.modalHidden = false;
				} else {
					m.hidden = true;
					m.knob.modalHidden = true;
				}
			} else {
				m.hidden = true;
				m.knob.modalHidden = true;
			}
		}
	};

	const init_web_gl = () => {
		window.isOnMobile = Utils.isOnMobile();

		window.gl = gl = canvasElement.getContext('webgl2', {
			preserveDrawingBuffer: true,
			alpha: false,
			premultipliedAlpha: false,
			antialias: true
		});

		gl.getExtension('OES_texture_float');
		gl.getExtension('OES_texture_float_linear');
		gl.getExtension('EXT_color_buffer_float');
		gl.debugEnabled = "production" === 'development';
		gl.debugEnabled = false;
		init_gl_error_handling();
		userAgentRes = [canvasElement.clientWidth, canvasElement.clientWidth];
		default_framebuffer = Object.create(Framebuffer.prototype);
		default_framebuffer.default = true;
		default_framebuffer.pongable = false;
		default_framebuffer.needs_pong = false;
		default_framebuffer.pong_idx = 0;
		default_framebuffer._fb = null;
		default_framebuffer._textures = [Object.create(Texture.prototype)];
		default_framebuffer.textures[0].res = [...userAgentRes];
		default_framebuffer.bind();

		canvas_fb = new Framebuffer([
				new Texture([project.canvasRes[0], project.canvasRes[1]], gl.RGBA16F, !isOnMobile)
			],
		true);

		temp_undo_fb = new Framebuffer([
				new Texture([project.canvasRes[0], project.canvasRes[1]], gl.RGBA16F, false)
			],
		false);

		ubo = new UBO();
		window.ubo = ubo;

		resizeIfNeeded(
			canvasElement,
			default_framebuffer,
			userAgentRes,
			e => {
				
			},
			() => {
				set_shared_uniforms();
			}
		);

		set_shared_uniforms();
		gl.disable(gl.CULL_FACE);
		gl.disable(gl.DEPTH_TEST);
		gl.enable(gl.BLEND);
		gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
	};

	const init_other_stuff = async () => {
		window.addEventListener("dragstart", event => {
			event.preventDefault();
		});

		if ("wakeLock" in navigator) {
			const wakeLock = await navigator.wakeLock.request("screen");
		}

		io = new IO();
		document.addEventListener('contextmenu', event => event.preventDefault());
		window.history.pushState(null, null, window.location.href);

		window.addEventListener('popstate', () => {
			window.history.pushState(null, null, window.location.href);
		});

		brush_textures.push(await BrushTexture.create((__webpack_require__(737)/* ["default"] */ .Z), 0));
		brush_textures.push(await BrushTexture.create((__webpack_require__(616)/* ["default"] */ .Z), 1));
		brush_textures.push(await BrushTexture.create((__webpack_require__(130)/* ["default"] */ .Z), 2));
		brush_textures.push(await BrushTexture.create((__webpack_require__(229)/* ["default"] */ .Z), 3));
		brush_textures.push(await BrushTexture.create((__webpack_require__(949)/* ["default"] */ .Z), 4));
		brush_textures.push(await BrushTexture.create((__webpack_require__(157)/* ["default"] */ .Z), 5));
		brush_textures.push(await BrushTexture.create((__webpack_require__(928)/* ["default"] */ .Z), 6));
		$$invalidate(14, brush_textures = [...brush_textures]);

		for (let brush of brush_presets) {
			brush.selected_brush_texture = brush_textures[0];
		}

		modals = [chaosSemiModal, dynamicsSemiModal, texDynamicsSemiModal];
	};

	onMount(async () => {
		init_web_gl();
		await init_other_stuff();
		default_framebuffer.bind();
		default_framebuffer.clear([0, 0, 0, 1]);
		canvas_fb.clear([0, 0, 0, 0]);
		canvas_fb.pong();
		canvas_fb.back_textures[0].bind_to_unit(1);
		canvas_fb.clear([0, 0, 0, 0]);

		const temp_stroke_fb = new Framebuffer([
				new Texture([project.canvasRes[0], project.canvasRes[1]], gl.RGBA16F, !isOnMobile)
			]);

		temp_stroke_fb.clear([0, 0, 0, 0]);

		const init_texture_uniforms = program => {
			program.setUniformTexture('temp_tex', temp_stroke_fb.textures[0], 0);
			program.setUniformTexture('canvas_back', canvas_fb.back_textures[0], 1);
			program.setUniformTexture('canvas_b', canvas_fb._textures[0], 2);
			program.setUniformTexture('canvas_a', canvas_fb._back_textures[0], 3);
			const brush_tex_start_idx = 5;

			brush_textures.forEach((brush_tex, i) => {
				const name = `brush_texture[${i}]`;
				console.log(name);
				const brush_textures_loc = gl.getUniformLocation(program.program, name);
				brush_tex.gpu_tex.bind_to_unit(brush_tex_start_idx + i);
				gl.uniform1i(brush_textures_loc, brush_tex_start_idx + i);
			});

			gl.activeTexture(gl.TEXTURE0);
		};

		const brush_preview_program = new ShaderProgram(__webpack_require__(218), __webpack_require__(175));
		const picker_program = new ShaderProgram(__webpack_require__(451), __webpack_require__(754));
		const composite_stroke_to_canvas_program = new ShaderProgram(__webpack_require__(275), __webpack_require__(7));
		const composite_stroke_to_canvas_b_program = new ShaderProgram(__webpack_require__(275), __webpack_require__(493));
		const post_canvas_program = new ShaderProgram(__webpack_require__(929), __webpack_require__(38));
		post_canvas_program.zoom_loc = gl.getUniformLocation(post_canvas_program.program, "zoom");
		post_canvas_program.panning_loc = gl.getUniformLocation(post_canvas_program.program, "panning");
		post_canvas_program.blending_colour_space_loc = gl.getUniformLocation(post_canvas_program.program, "blending_colour_space");
		const brush_long_program = new ShaderProgram(__webpack_require__(580), __webpack_require__(385));
		brush_preview_program.use();
		init_texture_uniforms(brush_preview_program);
		picker_program.use();
		init_texture_uniforms(picker_program);
		composite_stroke_to_canvas_program.use();
		init_texture_uniforms(composite_stroke_to_canvas_program);
		composite_stroke_to_canvas_b_program.use();
		init_texture_uniforms(composite_stroke_to_canvas_b_program);
		composite_stroke_to_canvas_program.blending_colour_space_loc = gl.getUniformLocation(composite_stroke_to_canvas_program.program, "blending_colour_space");
		composite_stroke_to_canvas_b_program.blending_colour_space_loc = gl.getUniformLocation(composite_stroke_to_canvas_b_program.program, "blending_colour_space");
		post_canvas_program.use();
		init_texture_uniforms(post_canvas_program);
		brush_long_program.use();
		init_texture_uniforms(brush_long_program);
		brush_long_program.brush_texture_idx_loc = gl.getUniformLocation(brush_long_program.program, "brush_texture_idx");
		brush_long_program.tex_hsv_dynamics_loc = gl.getUniformLocation(brush_long_program.program, "tex_hsv_dynamics");
		brush_long_program.tex_stretch_loc = gl.getUniformLocation(brush_long_program.program, "tex_stretch");
		let frame = 0;
		$$invalidate(26, canvas_read_tex = canvas_fb.textures[0]);
		let brush_buffer = new Thing([new VertexBuffer(4, gl.FLOAT), new VertexBuffer(4, gl.FLOAT)], gl.TRIANGLES, brush_long_program);
		gl.bindVertexArray(brush_buffer.vao);
		let t = 0;
		let delta_t = 0;
		let redraw_needed = false;
		let redrawing = false;
		let redo_history_length = 0;
		let brush_stroke = new BrushStroke(curr_brush.selected_brush_type, new DrawParams(curr_brush.tex_dynamics, curr_brush.tex_lch_dynamics, curr_brush.tex_stretch, BlendingColourSpace.Pigments), curr_brush.selected_brush_texture);
		drawer = new Drawer(gl, canvas_fb.textures[0], default_framebuffer);

		const composite_stroke = () => {
			canvas_fb.bind();
			canvas_fb.clear();

			const comp_program = canvas_fb.pong_idx === 0
			? composite_stroke_to_canvas_program
			: composite_stroke_to_canvas_b_program;

			if (canvas_fb.pong_idx === 0) {
				
			}

			comp_program.use();
			gl.uniform1i(comp_program.blending_colour_space_loc, blending_colour_space);
			canvas_fb.back_textures[0].bind_to_unit(1);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			temp_stroke_fb.clear();
		};

		const draw_n_strokes = (start_idx, end_idx, full_redraw = false) => {
			let k = 0;
			drawer.brush_buffer = brush_buffer;
			drawer.reset();
			start_idx = start_idx ?? 0;
			end_idx = end_idx ?? project.brush_strokes.length;

			for (k = start_idx; k < end_idx; k++) {
				drawer.push_any_stroke(project.brush_strokes[k]);
			}

			drawer.brush_buffer.upload_all_buffs();
			const brush_shader = drawer.brush_buffer.shader;
			brush_shader.use();
			let prev_colour_space = -1;
			let prev_colour_space_b = -1;
			let prev_brush_tex_idx = -1;
			let prev_hsv_dynamics = [0, 0, 0];
			let prev_tex_stretch = [0, 0];
			gl.useProgram(composite_stroke_to_canvas_program.program);
			canvas_fb._textures[0].bind_to_unit(2);
			canvas_fb._back_textures[0].bind_to_unit(3);
			gl.activeTexture(gl.TEXTURE15);
			let comp_program = composite_stroke_to_canvas_program;
			gl.clearColor(0, 0, 0, 0);
			gl.viewport(0, 0, project.canvasRes[0], project.canvasRes[1]);
			k = start_idx;
			let j = 0;

			for (let amogus of drawer.recorded_drawcalls) {
				const new_tex_stretch = project.brush_strokes[k].draw_params.tex_stretch;
				const new_hsv_dynamics = project.brush_strokes[k].draw_params.tex_lch_dynamics;
				const new_brush_tex_idx = project.brush_strokes[k].brush_texture.idx;
				const new_col_space = project.brush_strokes[k].draw_params.blending_colour_space;
				gl.bindFramebuffer(gl.FRAMEBUFFER, temp_stroke_fb.fb);
				gl.clear(gl.COLOR_BUFFER_BIT);
				brush_shader.use();

				if (new_brush_tex_idx !== prev_brush_tex_idx) {
					gl.uniform1i(brush_shader.brush_texture_idx_loc, prev_brush_tex_idx = new_brush_tex_idx);
				}

				if (prev_hsv_dynamics[0] !== new_hsv_dynamics[0] || prev_hsv_dynamics[1] !== new_hsv_dynamics[1] || prev_hsv_dynamics[2] !== new_hsv_dynamics[2]) {
					gl.uniform3fv(brush_shader.tex_hsv_dynamics_loc, project.brush_strokes[k].draw_params.tex_lch_dynamics);
				}

				if (prev_tex_stretch[0] !== new_tex_stretch[0] || prev_tex_stretch[1] !== new_tex_stretch[1]) {
					gl.uniform2fv(brush_shader.tex_stretch_loc, project.brush_strokes[k].draw_params.tex_stretch);
				}

				drawer.draw_stroke_idx(j);
				gl.bindFramebuffer(gl.FRAMEBUFFER, canvas_fb.fb);

				comp_program = canvas_fb.pong_idx === 0
				? composite_stroke_to_canvas_program
				: composite_stroke_to_canvas_b_program;

				comp_program.use();

				if (canvas_fb.pong_idx === 0) {
					if (new_col_space !== prev_colour_space) {
						gl.uniform1i(comp_program.blending_colour_space_loc, prev_colour_space = new_col_space);
					}
				} else {
					if (new_col_space !== prev_colour_space_b) {
						gl.uniform1i(comp_program.blending_colour_space_loc, prev_colour_space_b = new_col_space);
					}
				}

				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				canvas_fb.pong();

				if (full_redraw && j === end_idx - end_idx % undo_cache_steps - 1) {
					copy_fb_to_fb(canvas_fb.fb_back, temp_undo_fb.fb, canvas_fb._textures[0].res);
				}

				prev_hsv_dynamics[0] = new_hsv_dynamics[0];
				prev_hsv_dynamics[1] = new_hsv_dynamics[1];
				prev_hsv_dynamics[2] = new_hsv_dynamics[2];
				prev_tex_stretch[0] = new_tex_stretch[0];
				prev_tex_stretch[1] = new_tex_stretch[1];
				k++;
				j++;
			}

			redraw_needed = true;
			temp_stroke_fb.clear();
		};

		const redraw_whole_project = () => {
			console.log('REDRAW EVERYTHING');
			console.time("REDRAW ALL");
			canvas_fb.clear();
			canvas_fb.pong();
			canvas_fb.back_textures[0].bind_to_unit(1);
			canvas_fb.clear();
			temp_stroke_fb.clear();
			draw_n_strokes(0, project.brush_strokes.length - redo_history_length, true);
			console.timeEnd("REDRAW ALL");
		};

		$$invalidate(23, resize_project = new_sz => {
			$$invalidate(20, project.canvasRes = [...new_sz], project);
			temp_stroke_fb.textures[0].resize(new_sz);
			canvas_fb.back_textures[0].resize(new_sz);
			canvas_fb.textures[0].resize(new_sz);
			canvas_fb.recreate();
			canvas_fb.back_textures[0].bind_to_unit(1);
			temp_stroke_fb.recreate();
			temp_stroke_fb.textures[0].bind_to_unit(0);
			temp_undo_fb.textures[0].resize(new_sz);
			temp_undo_fb.recreate();
			set_shared_uniforms();
			full_redraw_needed = true;
			$$invalidate(22, project_has_been_modified = false);
			redo_history_length = 0;
		});

		let load_project = new_project => {
			$$invalidate(20, project = new Project());
			$$invalidate(22, project_has_been_modified = false);
			redo_history_length = 0;

			for (let key of Object.keys(new_project)) {
				$$invalidate(20, project[key] = new_project[key], project);
			}

			$$invalidate(20, project.canvasRes = [...new_project.canvasRes], project);
			resize_project(project.canvasRes);
			redraw_whole_project();
		};

		let local_storage_proj = localStorage.getItem('project');

		if (local_storage_proj) {
			local_storage_proj = JSON.parse(local_storage_proj);
			load_project(local_storage_proj);
		} else {
			load_project(new Project());
		}

		const handle_input_actions = () => {
			if (io.getKey('AltLeft').down) {
				if (io.getKey('AltLeft').just_pressed) {
					$$invalidate(18, picking = true);
				}

				pick_from_canvas();
			} else if (io.getKey('AltLeft').just_unpressed) {
				$$invalidate(19, just_finished_pick = true);
				$$invalidate(18, picking = false);
			}

			redraw_needed = true;

			if (io.just_finished_pinch) {
				zoom[0] = desired_zoom = pow(2, log2(desired_zoom) + io.pinch_zoom);
			}

			if (io.two_finger_pinch) {
				redraw_needed = true;
				zoom[0] = pow(2, log2(desired_zoom) + io.pinch_zoom);

				if (io.just_started_pinch) {
					panning_temp_pinch[0] = panning[0];
					panning_temp_pinch[1] = panning[1];
				}

				panning[0] = panning_temp_pinch[0] + io.pinch_pos[0];
				panning[1] = panning_temp_pinch[1] - io.pinch_pos[1];
			} else if (abs(desired_zoom - zoom[0]) > 0.00000001) {
				redraw_needed = true;
				zoom[0] = mix(zoom[0], desired_zoom, delta_t * 20);
			}

			if (frame === 0 || picking || just_finished_pick || io.mouse_wheel || io.mmb_down) {
				redraw_needed = true;

				if (just_finished_pick) {
					let coords = Utils.screen_NDC_to_canvas_NDC([...io.mouse_pos], default_framebuffer.textures[0], canvas_fb._textures[0], zoom[0], panning);

					if (coords[0] > -1 && coords[0] < 1 && coords[1] > -1 && coords[1] < 1) {
						$$invalidate(9, stroke_col[0] = picked_col[0], stroke_col);
						$$invalidate(9, stroke_col[1] = picked_col[1], stroke_col);
						$$invalidate(9, stroke_col[2] = picked_col[2], stroke_col);
						Utils.gamma_correct(stroke_col, true, true);
						$$invalidate(9, stroke_col[3] = 1, stroke_col);
						trigger_colour_display_update(stroke_col[0], stroke_col[1], stroke_col[2]);
					}

					console.log(coords);
					$$invalidate(19, just_finished_pick = false);
					$$invalidate(18, picking = false);
					console.log("finished pick");
				}

				if (io.mmb_down) {
					panning[0] += io.delta_mouse_pos[0] / zoom[0];
					panning[1] += io.delta_mouse_pos[1] / zoom[0];
				}

				if (io.mouse_wheel) {
					if (io.mouse_wheel > 0) {
						desired_zoom *= 1.2;
					} else {
						desired_zoom /= 1.2;
					}
				}
			}

			let l_ctrl_down = io.getKey('ControlLeft').down;
			let l_shift_down = io.getKey('ShiftLeft').down;
			let z_just_pressed = io.getKey('KeyZ').just_pressed;
			const idx_before = project.brush_strokes.length - redo_history_length;

			if (redo_pending || l_shift_down && l_ctrl_down && z_just_pressed) {
				redo_history_length -= 1;
				const idx_now = idx_before + 1;

				if (redo_history_length >= 0) {
					if (idx_now % undo_cache_steps === 0) {
						temp_stroke_fb.clear();
						draw_n_strokes(idx_before, idx_before + 1);
						copy_fb_to_fb(canvas_fb.fb_back, temp_undo_fb.fb, canvas_fb.textures[0].res);
					} else {
						temp_stroke_fb.clear();
						draw_n_strokes(idx_before, idx_before + 1);
					}
				} else {
					redo_history_length = 0;
				}
			} else if (undo_pending || l_ctrl_down && z_just_pressed) {
				redo_history_length += 1;
				const idx_now = idx_before - 1;

				if (redo_history_length <= project.brush_strokes.length) {
					if (idx_before % undo_cache_steps === 0) {
						canvas_fb.clear();
						canvas_fb.pong();
						canvas_fb.back_textures[0].bind_to_unit(1);
						canvas_fb.clear();
						temp_stroke_fb.clear();
						draw_n_strokes(0, idx_before - undo_cache_steps);
						copy_fb_to_fb(canvas_fb.fb_back, temp_undo_fb.fb, canvas_fb.textures[0].res);
						temp_stroke_fb.clear();
						draw_n_strokes(idx_before - undo_cache_steps, project.brush_strokes.length - redo_history_length);
					} else {
						copy_fb_to_fb(temp_undo_fb.fb, canvas_fb.fb_back, canvas_fb.textures[0].res);
						canvas_fb.back_textures[0].bind_to_unit(1);
						temp_stroke_fb.clear();
						const undo_mod_offs = idx_now % undo_cache_steps;
						draw_n_strokes(idx_now - undo_mod_offs, project.brush_strokes.length - redo_history_length);
					}

					gl.activeTexture(gl.TEXTURE15);
				} else {
					redo_history_length -= 1;
				}
			}
		};

		const record_stroke = () => {
			if (io.mouse_just_pressed && !(redo_pending || undo_pending)) {
				brush_stroke = new BrushStroke(curr_brush.selected_brush_type, new DrawParams(curr_brush.tex_dynamics, curr_brush.tex_lch_dynamics, curr_brush.tex_stretch, blending_colour_space), curr_brush.selected_brush_texture);

				for (let i = 0; i < redo_history_length; i++) {
					project.brush_strokes.pop();
				}

				redo_history_length = 0;
			}

			brush_rot = [...io.tilt];

			for (let i = 0; i < io.mouse_positions_during_last_frame_cnt; i++) {
				brush_pos_ndc_screen = [
					io.mouse_positions_during_last_frame[i * 2],
					io.mouse_positions_during_last_frame[i * 2 + 1]
				];

				brush_pos_ndc_canvas = Utils.screen_NDC_to_canvas_NDC(brush_pos_ndc_screen, default_framebuffer.textures[0], canvas_read_tex, zoom[0], panning);
				brush_pos_ndc_canvas[0] += curr_brush.pos_jitter * (2 * hash.valueNoiseSmooth(t * 100 + 251, 2) - 1);
				brush_pos_ndc_canvas[1] += curr_brush.pos_jitter * (2 * hash.valueNoiseSmooth(t * 100 + 1251, 2) - 1);
				let col = [...stroke_col];

				{
					const chroma_gl = col => {
						return chroma_default().gl(col[0], col[1], col[2]);
					};

					const chroma_oklch = col => {
						return chroma_default().oklch(col[0], col[1], col[2]);
					};

					col = chroma_gl(col).oklch();
					const c = col[1];
					let hue_jitt_amt = (1 - pow(c, 0.2) * 1.2) * 4;
					hue_jitt_amt = max(hue_jitt_amt, 0);
					hue_jitt_amt += pow(smoothstep(0., 1., 1 - c), 57.) * 2.2;
					col[0] += (-0.5 + hash.valueNoiseSmooth(t * 100 * curr_brush.chaos_speed, 2)) * curr_brush.chaos * curr_brush.chaos_lch[0];
					col[1] += (-0.5 + hash.valueNoiseSmooth(t * 100 * curr_brush.chaos_speed + 100, 2)) * curr_brush.chaos * curr_brush.chaos_lch[1];
					col[2] += hue_jitt_amt * (-0.5 + hash.valueNoiseSmooth(t * 100 * curr_brush.chaos_speed + 200, 2)) * 300 * curr_brush.chaos * curr_brush.chaos_lch[2];
					col[0] = clamp(col[0], 0, 1);
					col[1] = clamp(col[1], 0, 1);
					col[2] = _0b5vr_experimental_esm_mod(col[2], 360);
					col = chroma_oklch(col).gl();
				}

				{
					stroke_opacity = lerp(curr_brush.stroke_opacity_dynamics[0], curr_brush.stroke_opacity_dynamics[1], io.pressure);
				}

				brush_rot[1] += 10 * curr_brush.rot_jitter * (2 * hash.valueNoiseSmooth(t * 10 + 100, 2) - 1);
				let sz = [...brush_sz];
				let size_pressure_weight = lerp(curr_brush.stroke_size_dynamics[0], curr_brush.stroke_size_dynamics[1], io.pressure);
				let size_tilt_weight = lerp(0.4, 1, io.tilt[0] / tau);
				sz[0] *= size_pressure_weight * size_tilt_weight;
				sz[1] *= size_pressure_weight * size_tilt_weight;
				brush_stroke.push_stroke(brush_pos_ndc_canvas, brush_rot, sz, stroke_opacity, col);
			}
		};

		const draw = _t => {
			redraw_needed = false;
			const new_t = _t / 1000;
			delta_t = new_t - t;
			t = new_t;

			resizeIfNeeded(
				canvasElement,
				default_framebuffer,
				userAgentRes,
				v => {
					redraw_needed = v;
				},
				() => {
					set_shared_uniforms();
				}
			);

			io.tick();

			if (new_project_pending) {
				load_project(new Project());
				$$invalidate(15, new_project_pending = false);
			}

			if (project_pending_load) {
				load_project(project_pending_load);
				$$invalidate(21, project_pending_load = undefined);
			}

			if (full_redraw_needed) {
				redraw_whole_project();
			}

			handle_input_actions();

			if ((io.mouse_just_pressed || io.mouse_down && io.mouse_just_moved) && io.pointerType !== 'touch') {
				$$invalidate(22, project_has_been_modified = true);
				redraw_needed = true;
				record_stroke();
				temp_stroke_fb.clear();
				temp_stroke_fb.bind();
				drawer.brush_buffer = brush_buffer;
				drawer.reset();
				drawer.push_any_stroke(brush_stroke);
				drawer.brush_buffer.upload_all_buffs();
				const brush_shader = drawer.brush_buffer.shader;
				brush_shader.use();
				gl.uniform1i(brush_shader.brush_texture_idx_loc, curr_brush.selected_brush_texture.idx);
				gl.uniform3fv(brush_shader.tex_hsv_dynamics_loc, curr_brush.tex_lch_dynamics);
				gl.uniform2fv(brush_shader.tex_stretch_loc, curr_brush.tex_stretch);
				drawer.draw_stroke_idx(0);
			}

			if (io.mouse_just_unpressed && io.pointerType !== 'touch' && !(undo_pending || redo_pending)) {
				if (frame % 15 === 0 || !isOnMobile) {
					localStorage.setItem('project', JSON.stringify(project));
				}

				project.push_stroke(brush_stroke);
				redraw_needed = true;
				composite_stroke();
				canvas_fb.pong();
				canvas_fb.back_textures[0].bind_to_unit(1);

				if (project.brush_strokes.length % undo_cache_steps === 0) {
					copy_fb_to_fb(canvas_fb.fb_back, temp_undo_fb.fb, canvas_fb.textures[0].res);
				}
			}

			if (brushSizeWidgetDragging || brushSizeWidgetStoppedDragging) redraw_needed = true;

			if (redraw_needed) {
				if (canvas_fb._textures[0].mipmapped) {
					gl.bindTexture(gl.TEXTURE_2D, canvas_fb._textures[0].tex);
					gl.generateMipmap(gl.TEXTURE_2D);
					gl.bindTexture(gl.TEXTURE_2D, canvas_fb._back_textures[0].tex);
					gl.generateMipmap(gl.TEXTURE_2D);
					gl.bindTexture(gl.TEXTURE_2D, null);
				}

				if (temp_stroke_fb.textures[0].mipmapped) {
					gl.bindTexture(gl.TEXTURE_2D, temp_stroke_fb.textures[0].tex);
					gl.generateMipmap(gl.TEXTURE_2D);
					gl.bindTexture(gl.TEXTURE_2D, null);
				}

				default_framebuffer.clear([0, 0, 0, 1]);
				default_framebuffer.bind();
				post_canvas_program.use();
				gl.uniform1f(post_canvas_program.zoom_loc, zoom);
				gl.uniform2fv(post_canvas_program.panning_loc, panning);
				gl.uniform1i(post_canvas_program.blending_colour_space_loc, blending_colour_space);
				canvas_fb.back_textures[0].bind_to_unit(1);
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

				if (brushSizeWidgetDragging) {
					brush_preview_program.use();
					brush_preview_program.setUniformFloat("zoom", zoom[0]);
					brush_preview_program.setUniformVec("brush_sz", brush_sz);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				}

				if (picking) {
					picker_program.use();
					picker_program.setUniformVec('picked_col', picked_col);
					picker_program.setUniformVec('picker_pos', [...io.mouse_pos]);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				}
			}

			print_on_gl_error();
			$$invalidate(5, brushSizeWidgetStoppedDragging = false);
			$$invalidate(17, redo_pending = false);
			$$invalidate(16, undo_pending = false);
			full_redraw_needed = false;
			io.tick_end();
			frame++;

			for (let framebuffer of Framebuffer.framebuffers) {
				if (framebuffer.needs_pong) {
					framebuffer.pong();
				}
			}

			requestAnimationFrame(draw);
		};

		(() => {
			draw(0);
		})();
	});

	onDestroy(() => {
		
	});

	const writable_props = [];

	App_svelte_Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') App_svelte_console_1.warn(`<App> was created with unknown prop '${key}'`);
	});

	function rgbsliders_colour_binding(value) {
		stroke_col = value;
		$$invalidate(9, stroke_col);
	}

	function colourdisplay_colour_binding(value) {
		stroke_col = value;
		$$invalidate(9, stroke_col);
	}

	function colourdisplay_update_display_binding(value) {
		trigger_colour_display_update = value;
		$$invalidate(25, trigger_colour_display_update);
	}

	function knob0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			chaosKnob = $$value;
			$$invalidate(6, chaosKnob);
		});
	}

	function knob0_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.chaos, value)) {
			curr_brush.chaos = value;
			$$invalidate(12, curr_brush);
		}
	}

	function brushsizewidget_brush_sz_binding(value) {
		brush_sz = value;
		$$invalidate(10, brush_sz);
	}

	function brushsizewidget_dragging_binding(value) {
		brushSizeWidgetDragging = value;
		$$invalidate(4, brushSizeWidgetDragging);
	}

	function brushsizewidget_stopped_dragging_binding(value) {
		brushSizeWidgetStoppedDragging = value;
		$$invalidate(5, brushSizeWidgetStoppedDragging);
	}

	function knob1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			dynamicsKnob = $$value;
			$$invalidate(7, dynamicsKnob);
		});
	}

	function knob1_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.dynamics, value)) {
			curr_brush.dynamics = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			texDynamicsKnob = $$value;
			$$invalidate(8, texDynamicsKnob);
		});
	}

	function knob2_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.tex_dynamics, value)) {
			curr_brush.tex_dynamics = value;
			$$invalidate(12, curr_brush);
		}
	}

	function brushtypewidget_curr_brush_binding(value) {
		curr_brush = value;
		$$invalidate(12, curr_brush);
	}

	function brushpresetwidget_brush_presets_binding(value) {
		brush_presets = value;
		$$invalidate(11, brush_presets);
	}

	function brushpresetwidget_selected_brush_preset_binding(value) {
		curr_brush = value;
		$$invalidate(12, curr_brush);
	}

	const func = () => {
		$$invalidate(16, undo_pending = true);
		floating_modal_message.set("undo");
	};

	const func_1 = () => {
		$$invalidate(17, redo_pending = true);
	};

	const func_2 = async () => {
		let [img, blob] = await canvas_read_tex.read_back_image(true);
		return [img, blob];
	};

	const func_3 = () => {
		$$invalidate(15, new_project_pending = true);
	};

	const func_4 = project => {
		$$invalidate(21, project_pending_load = project);
	};

	function gallerywidget_current_project_binding(value) {
		project = value;
		$$invalidate(20, project);
	}

	function gallerywidget_resize_project_binding(value) {
		resize_project = value;
		$$invalidate(23, resize_project);
	}

	function gallerywidget_project_has_been_modified_binding(value) {
		project_has_been_modified = value;
		$$invalidate(22, project_has_been_modified);
	}

	function gallerywidget_is_safe_to_switch_to_new_project_binding(value) {
		is_safe_to_switch_to_new_project = value;
		$$invalidate(24, is_safe_to_switch_to_new_project);
	}

	const func_5 = () => pick_from_canvas();

	function pickcolourwidget_picking_binding(value) {
		picking = value;
		$$invalidate(18, picking);
	}

	function pickcolourwidget_just_finished_pick_binding(value) {
		just_finished_pick = value;
		$$invalidate(19, just_finished_pick);
	}

	function blendingcolourspacewidget_selected_colour_space_binding(value) {
		blending_colour_space = value;
		$$invalidate(13, blending_colour_space);
	}

	function knob0_value_binding_1(value) {
		if ($$self.$$.not_equal(curr_brush.chaos_lch[0], value)) {
			curr_brush.chaos_lch[0] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob1_value_binding_1(value) {
		if ($$self.$$.not_equal(curr_brush.chaos_lch[1], value)) {
			curr_brush.chaos_lch[1] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob2_value_binding_1(value) {
		if ($$self.$$.not_equal(curr_brush.chaos_lch[2], value)) {
			curr_brush.chaos_lch[2] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob3_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.chaos_speed, value)) {
			curr_brush.chaos_speed = value;
			$$invalidate(12, curr_brush);
		}
	}

	function semimodal0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			chaosSemiModal = $$value;
			$$invalidate(1, chaosSemiModal);
		});
	}

	function knob0_value_binding_2(value) {
		if ($$self.$$.not_equal(curr_brush.stroke_opacity_dynamics[0], value)) {
			curr_brush.stroke_opacity_dynamics[0] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob1_value_binding_2(value) {
		if ($$self.$$.not_equal(curr_brush.stroke_opacity_dynamics[1], value)) {
			curr_brush.stroke_opacity_dynamics[1] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob2_value_binding_2(value) {
		if ($$self.$$.not_equal(curr_brush.stroke_size_dynamics[0], value)) {
			curr_brush.stroke_size_dynamics[0] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob3_value_binding_1(value) {
		if ($$self.$$.not_equal(curr_brush.stroke_size_dynamics[1], value)) {
			curr_brush.stroke_size_dynamics[1] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob4_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.rot_jitter, value)) {
			curr_brush.rot_jitter = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob5_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.pos_jitter, value)) {
			curr_brush.pos_jitter = value;
			$$invalidate(12, curr_brush);
		}
	}

	function semimodal1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			dynamicsSemiModal = $$value;
			$$invalidate(2, dynamicsSemiModal);
		});
	}

	function knob0_value_binding_3(value) {
		if ($$self.$$.not_equal(curr_brush.tex_stretch[0], value)) {
			curr_brush.tex_stretch[0] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob1_value_binding_3(value) {
		if ($$self.$$.not_equal(curr_brush.tex_stretch[1], value)) {
			curr_brush.tex_stretch[1] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob2_value_binding_3(value) {
		if ($$self.$$.not_equal(curr_brush.tex_lch_dynamics[0], value)) {
			curr_brush.tex_lch_dynamics[0] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob3_value_binding_2(value) {
		if ($$self.$$.not_equal(curr_brush.tex_lch_dynamics[1], value)) {
			curr_brush.tex_lch_dynamics[1] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function knob4_value_binding_1(value) {
		if ($$self.$$.not_equal(curr_brush.tex_lch_dynamics[2], value)) {
			curr_brush.tex_lch_dynamics[2] = value;
			$$invalidate(12, curr_brush);
		}
	}

	function texturewidget_brush_textures_binding(value) {
		brush_textures = value;
		$$invalidate(14, brush_textures);
	}

	function texturewidget_selected_brush_texture_binding(value) {
		if ($$self.$$.not_equal(curr_brush.selected_brush_texture, value)) {
			curr_brush.selected_brush_texture = value;
			$$invalidate(12, curr_brush);
		}
	}

	function semimodal2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			texDynamicsSemiModal = $$value;
			$$invalidate(3, texDynamicsSemiModal);
		});
	}

	function canvas_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvasElement = $$value;
			$$invalidate(0, canvasElement);
		});
	}

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		floating_modal_message: floating_modal_message,
		resizeDefaultFramebufferIfNeeded: resizeIfNeeded,
		print_on_gl_error: print_on_gl_error,
		init_gl_error_handling: init_gl_error_handling,
		copy_fb_to_texture: copy_fb_to_texture,
		copy_fb_to_fb: copy_fb_to_fb,
		Knob: Knob_svelte,
		BrushSizeWidget: BrushSizeWidget_svelte,
		BrushTypeWidget: BrushTypeWidget_svelte,
		BrushPresetWidget: BrushPresetWidget_svelte,
		UndoRedoWidget: UndoRedoWidget_svelte,
		GalleryWidget: GalleryWidget_svelte,
		FloatingModal: FloatingModal_svelte,
		PickColourWidget: PickColourWidget_svelte,
		TextureWidget: TextureWidget_svelte,
		BlendingColourSpaceWidget: BlendingColourSpaceWidget_svelte,
		RGBSliders: RGBSliders_svelte,
		ColourDisplay: ColourDisplay_svelte,
		SemiModal: SemiModal_svelte,
		FourIconsWidget: FourIconsWidget_svelte,
		IO: IO,
		chroma: (chroma_default()),
		Hash: Hash,
		abs: abs,
		cos: cos,
		floor: floor,
		pow: pow,
		sin: sin,
		tau: tau,
		tri: tri,
		mix: mix,
		max: max,
		log2: log2,
		clamp: clamp,
		lerp: lerp,
		mod: _0b5vr_experimental_esm_mod,
		smootheststep: smootheststep,
		smoothstep: smoothstep,
		BrushTexture: BrushTexture,
		Project: Project,
		Utils: Utils,
		BlendingColourSpace: BlendingColourSpace,
		BrushPreset: BrushPreset,
		BrushStroke: BrushStroke,
		BrushType: BrushType,
		DrawParams: DrawParams,
		Drawer: Drawer,
		Framebuffer: Framebuffer,
		VertexBuffer: VertexBuffer,
		UBO: UBO,
		Texture: Texture,
		ShaderProgram: ShaderProgram,
		Thing: Thing,
		undo_cache_steps,
		hash,
		io,
		gl,
		zoom,
		desired_zoom,
		panning_temp_pinch,
		panning,
		userAgentRes,
		default_framebuffer,
		canvasElement,
		chaosSemiModal,
		dynamicsSemiModal,
		texDynamicsSemiModal,
		modals,
		brushSizeWidgetDragging,
		brushSizeWidgetStoppedDragging,
		chaosKnob,
		dynamicsKnob,
		texDynamicsKnob,
		stroke_col,
		stroke_opacity,
		brush_rot,
		brush_pos_ndc_screen,
		brush_pos_ndc_canvas,
		brush_sz,
		brush_presets,
		curr_brush,
		blending_colour_space,
		brush_textures,
		new_project_pending,
		undo_pending,
		redo_pending,
		picking,
		just_finished_pick,
		picked_col,
		project,
		project_pending_load,
		project_has_been_modified,
		resize_project,
		is_safe_to_switch_to_new_project,
		full_redraw_needed,
		trigger_colour_display_update,
		canvas_fb,
		canvas_read_tex,
		temp_undo_fb,
		drawer,
		ubo,
		set_shared_uniforms,
		pick_from_canvas,
		openModal,
		init_web_gl,
		init_other_stuff
	});

	$$self.$inject_state = $$props => {
		if ('hash' in $$props) hash = $$props.hash;
		if ('io' in $$props) io = $$props.io;
		if ('gl' in $$props) gl = $$props.gl;
		if ('zoom' in $$props) zoom = $$props.zoom;
		if ('desired_zoom' in $$props) desired_zoom = $$props.desired_zoom;
		if ('panning_temp_pinch' in $$props) panning_temp_pinch = $$props.panning_temp_pinch;
		if ('panning' in $$props) panning = $$props.panning;
		if ('userAgentRes' in $$props) userAgentRes = $$props.userAgentRes;
		if ('default_framebuffer' in $$props) default_framebuffer = $$props.default_framebuffer;
		if ('canvasElement' in $$props) $$invalidate(0, canvasElement = $$props.canvasElement);
		if ('chaosSemiModal' in $$props) $$invalidate(1, chaosSemiModal = $$props.chaosSemiModal);
		if ('dynamicsSemiModal' in $$props) $$invalidate(2, dynamicsSemiModal = $$props.dynamicsSemiModal);
		if ('texDynamicsSemiModal' in $$props) $$invalidate(3, texDynamicsSemiModal = $$props.texDynamicsSemiModal);
		if ('modals' in $$props) modals = $$props.modals;
		if ('brushSizeWidgetDragging' in $$props) $$invalidate(4, brushSizeWidgetDragging = $$props.brushSizeWidgetDragging);
		if ('brushSizeWidgetStoppedDragging' in $$props) $$invalidate(5, brushSizeWidgetStoppedDragging = $$props.brushSizeWidgetStoppedDragging);
		if ('chaosKnob' in $$props) $$invalidate(6, chaosKnob = $$props.chaosKnob);
		if ('dynamicsKnob' in $$props) $$invalidate(7, dynamicsKnob = $$props.dynamicsKnob);
		if ('texDynamicsKnob' in $$props) $$invalidate(8, texDynamicsKnob = $$props.texDynamicsKnob);
		if ('stroke_col' in $$props) $$invalidate(9, stroke_col = $$props.stroke_col);
		if ('stroke_opacity' in $$props) stroke_opacity = $$props.stroke_opacity;
		if ('brush_rot' in $$props) brush_rot = $$props.brush_rot;
		if ('brush_pos_ndc_screen' in $$props) brush_pos_ndc_screen = $$props.brush_pos_ndc_screen;
		if ('brush_pos_ndc_canvas' in $$props) brush_pos_ndc_canvas = $$props.brush_pos_ndc_canvas;
		if ('brush_sz' in $$props) $$invalidate(10, brush_sz = $$props.brush_sz);
		if ('brush_presets' in $$props) $$invalidate(11, brush_presets = $$props.brush_presets);
		if ('curr_brush' in $$props) $$invalidate(12, curr_brush = $$props.curr_brush);
		if ('blending_colour_space' in $$props) $$invalidate(13, blending_colour_space = $$props.blending_colour_space);
		if ('brush_textures' in $$props) $$invalidate(14, brush_textures = $$props.brush_textures);
		if ('new_project_pending' in $$props) $$invalidate(15, new_project_pending = $$props.new_project_pending);
		if ('undo_pending' in $$props) $$invalidate(16, undo_pending = $$props.undo_pending);
		if ('redo_pending' in $$props) $$invalidate(17, redo_pending = $$props.redo_pending);
		if ('picking' in $$props) $$invalidate(18, picking = $$props.picking);
		if ('just_finished_pick' in $$props) $$invalidate(19, just_finished_pick = $$props.just_finished_pick);
		if ('picked_col' in $$props) picked_col = $$props.picked_col;
		if ('project' in $$props) $$invalidate(20, project = $$props.project);
		if ('project_pending_load' in $$props) $$invalidate(21, project_pending_load = $$props.project_pending_load);
		if ('project_has_been_modified' in $$props) $$invalidate(22, project_has_been_modified = $$props.project_has_been_modified);
		if ('resize_project' in $$props) $$invalidate(23, resize_project = $$props.resize_project);
		if ('is_safe_to_switch_to_new_project' in $$props) $$invalidate(24, is_safe_to_switch_to_new_project = $$props.is_safe_to_switch_to_new_project);
		if ('full_redraw_needed' in $$props) full_redraw_needed = $$props.full_redraw_needed;
		if ('trigger_colour_display_update' in $$props) $$invalidate(25, trigger_colour_display_update = $$props.trigger_colour_display_update);
		if ('canvas_fb' in $$props) canvas_fb = $$props.canvas_fb;
		if ('canvas_read_tex' in $$props) $$invalidate(26, canvas_read_tex = $$props.canvas_read_tex);
		if ('temp_undo_fb' in $$props) temp_undo_fb = $$props.temp_undo_fb;
		if ('drawer' in $$props) drawer = $$props.drawer;
		if ('ubo' in $$props) ubo = $$props.ubo;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		canvasElement,
		chaosSemiModal,
		dynamicsSemiModal,
		texDynamicsSemiModal,
		brushSizeWidgetDragging,
		brushSizeWidgetStoppedDragging,
		chaosKnob,
		dynamicsKnob,
		texDynamicsKnob,
		stroke_col,
		brush_sz,
		brush_presets,
		curr_brush,
		blending_colour_space,
		brush_textures,
		new_project_pending,
		undo_pending,
		redo_pending,
		picking,
		just_finished_pick,
		project,
		project_pending_load,
		project_has_been_modified,
		resize_project,
		is_safe_to_switch_to_new_project,
		trigger_colour_display_update,
		canvas_read_tex,
		pick_from_canvas,
		openModal,
		rgbsliders_colour_binding,
		colourdisplay_colour_binding,
		colourdisplay_update_display_binding,
		knob0_binding,
		knob0_value_binding,
		brushsizewidget_brush_sz_binding,
		brushsizewidget_dragging_binding,
		brushsizewidget_stopped_dragging_binding,
		knob1_binding,
		knob1_value_binding,
		knob2_binding,
		knob2_value_binding,
		brushtypewidget_curr_brush_binding,
		brushpresetwidget_brush_presets_binding,
		brushpresetwidget_selected_brush_preset_binding,
		func,
		func_1,
		func_2,
		func_3,
		func_4,
		gallerywidget_current_project_binding,
		gallerywidget_resize_project_binding,
		gallerywidget_project_has_been_modified_binding,
		gallerywidget_is_safe_to_switch_to_new_project_binding,
		func_5,
		pickcolourwidget_picking_binding,
		pickcolourwidget_just_finished_pick_binding,
		blendingcolourspacewidget_selected_colour_space_binding,
		knob0_value_binding_1,
		knob1_value_binding_1,
		knob2_value_binding_1,
		knob3_value_binding,
		semimodal0_binding,
		knob0_value_binding_2,
		knob1_value_binding_2,
		knob2_value_binding_2,
		knob3_value_binding_1,
		knob4_value_binding,
		knob5_value_binding,
		semimodal1_binding,
		knob0_value_binding_3,
		knob1_value_binding_3,
		knob2_value_binding_3,
		knob3_value_binding_2,
		knob4_value_binding_1,
		texturewidget_brush_textures_binding,
		texturewidget_selected_brush_texture_binding,
		semimodal2_binding,
		canvas_binding
	];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, App_svelte_instance, App_svelte_create_fragment, safe_not_equal, {}, App_svelte_add_css, [-1, -1, -1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: App_svelte_create_fragment.name
		});
	}
}

/* harmony default export */ const App_svelte = (App);
;// CONCATENATED MODULE: ./src/index.ts



const app = new App_svelte({
    target: document.body,
    props: {},
});
/* harmony default export */ const src = ((/* unused pure expression or super */ null && (app)));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBOztBQUVBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakMsTUFBTTtBQUNOLDRCQUE0QixZQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQzs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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Q0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsRUFBRSxhQUFhLEVBQUU7QUFDbkQsbUNBQW1DLEVBQUUsYUFBYSxFQUFFOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDO0FBQ3pDLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMERBQTBEO0FBQzFELFVBQVU7QUFDVjtBQUNBLDBEQUEwRDtBQUMxRCxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsaUVBQWlFO0FBQzlGLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEU7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFD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TSxNQUFNLE1BQU0sTUFBTSxLQUN0RCxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxLQUN0RCxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxLQUN0RCxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxLQUN0RCxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxLQUN0RCxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUV4RCxRQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBRTlFLE1BQUssUUFBUSxHQUFNO0FBQUUsV0FBTyxTQUFVLEdBQUc7QUFBQTtBQUV6QyxTQUFPLFNBQVU7QUFBQSxJQUNmLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzlCLE1BQU0sTUFBTSxNQUFNLE1B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QU0sTUFBTSxNQUFNLE1BQU07QUFBQSxJQUMxQyxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBQUEsSUFDMUMsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU07QUFBQSxJQUUxQyxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBQUEsSUFDMUMsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU07QUFBQSxJQUMxQyxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBQUEsSUFFMUMsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU07QUFBQSxJQUMxQyxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBQUEsSUFDMUMsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBRTFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU07QUFBQSxJQUMxQyxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBQUEsSUFDMUMsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU07QUFBQTtBQUFBOzs7QUMvQnZDLHlCQUNMLE1BQU0sSUFDTixPQUFPLE1BQ1AsTUFBTSxLQUNOLFNBQVMsR0FDRztBQUNaLFFBQU0sSUFBSSxJQUFNLEtBQUssSUFBSyxNQUFNLEtBQUssS0FBSztBQUMxQyxRQUFNLElBQU0sTUFBTTtBQUNsQixTQUFPO0FBQUEsSUFDTCxJQUFJO0FBQUEsSUFBUTtBQUFBLElBQUs7QUFBQSxJQUFLO0FBQUEsSUFDdEI7QUFBQSxJQUFLO0FBQUEsSUFBRztBQUFBLElBQUs7QUFBQSxJQUNiO0FBQUEsSUFBSztBQUFBLElBQUssQ0FBRyxPQUFNLFFBQVM7QUFBQSxJQUFHO0FBQUEsSUFDL0I7QUFBQSxJQUFLO0FBQUEsSUFBSyxLQUFLLE1BQU0sT0FBTztBQUFBLElBQUc7QUFBQTtBQUFBOzs7QUNqQjVCLHVCQUF3QixPQUE0QjtBQUN6RCxRQUFNLElBQUksS0FBSyxJQUFLO0FBQ3BCLFFBQU0sSUFBSSxLQUFLLElBQUs7QUFFcEIsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBLElBQUc7QUFBQSxJQUNUO0FBQUEsSUFBRztBQUFBLElBQUcsQ0FBQztBQUFBLElBQUc7QUFBQSxJQUNWO0FBQUEsSUFBRztBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFDVDtBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBO0FBQUE7OztBQ1JOLHVCQUF3QixPQUE0QjtBQUN6RCxRQUFNLElBQUksS0FBSyxJQUFLO0FBQ3BCLFFBQU0sSUFBSSxLQUFLLElBQUs7QUFFcEIsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBLElBQUc7QUFBQSxJQUNUO0FBQUEsSUFBRztBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFDVCxDQUFDO0FBQUEsSUFBRztBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFDVjtBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBO0FBQUE7OztBQ1JOLHVCQUF3QixPQUE0QjtBQUN6RCxRQUFNLElBQUksS0FBSyxJQUFLO0FBQ3BCLFFBQU0sSUFBSSxLQUFLLElBQUs7QUFFcEIsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUFHLENBQUM7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBLElBQ1Y7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBLElBQUc7QUFBQSxJQUNUO0FBQUEsSUFBRztBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFDVDtBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBO0FBQUE7OztBQ1BOLG1CQUFvQixLQUE4QjtBQUN2RCxTQUFPO0FBQUEsSUFDTCxJQUFLO0FBQUEsSUFBSztBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFDaEI7QUFBQSxJQUFHLElBQUs7QUFBQSxJQUFLO0FBQUEsSUFBRztBQUFBLElBQ2hCO0FBQUEsSUFBRztBQUFBLElBQUcsSUFBSztBQUFBLElBQUs7QUFBQSxJQUNoQjtBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBO0FBQUE7OztBQ05OLHlCQUEwQixRQUE2QjtBQUM1RCxTQUFPO0FBQUEsSUFDTDtBQUFBLElBQVE7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBLElBQ2Q7QUFBQSxJQUFHO0FBQUEsSUFBUTtBQUFBLElBQUc7QUFBQSxJQUNkO0FBQUEsSUFBRztBQUFBLElBQUc7QUFBQSxJQUFRO0FBQUEsSUFDZDtBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBO0FBQUE7OztBQ0pOLHVCQUF3QixLQUE4QjtBQUMzRCxTQUFPO0FBQUEsSUFDTDtBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBLElBQ1Q7QUFBQSxJQUFHO0FBQUEsSUFBRztBQUFBLElBQUc7QUFBQSxJQUNUO0FBQUEsSUFBRztBQUFBLElBQUc7QUFBQSxJQUFHO0FBQUEsSUFDVCxJQUFLO0FBQUEsSUFBSyxJQUFLO0FBQUEsSUFBSyxJQUFLO0FBQUEsSUFBSztBQUFBO0FBQUE7OztBQ04zQix1QkFBd0IsR0FBNEI7QUFDekQsU0FBTztBQUFBLElBQ0wsRUFBRztBQUFBLElBQUssRUFBRztBQUFBLElBQUssRUFBRztBQUFBLElBQUssRUFBRztBQUFBLElBQzNCLEVBQUc7QUFBQSxJQUFLLEVBQUc7QUFBQSxJQUFLLEVBQUc7QUFBQSxJQUFLLEVBQUc7QUFBQSxJQUMzQixFQUFHO0FBQUEsSUFBSyxFQUFHO0FBQUEsSUFBSyxFQUFHO0FBQUEsSUFBTSxFQUFHO0FBQUEsSUFDNUIsRUFBRztBQUFBLElBQUssRUFBRztBQUFBLElBQUssRUFBRztBQUFBLElBQU0sRUFBRztBQUFBO0FBQUE7OztBQ2FoQyxJQUFNLHFCQUFpQztBQUFBLEVBQ3JDO0FBQUEsRUFBSztBQUFBLEVBQUs7QUFBQSxFQUFLO0FBQUEsRUFDZjtBQUFBLEVBQUs7QUFBQSxFQUFLO0FBQUEsRUFBSztBQUFBLEVBQ2Y7QUFBQSxFQUFLO0FBQUEsRUFBSztBQUFBLEVBQUs7QUFBQSxFQUNmO0FBQUEsRUFBSztBQUFBLEVBQUs7QUFBQSxFQUFLO0FBQUE7QUFNVixvQkFBYztBQUFBLEVBR1osWUFBYSxJQUFnQixvQkFBcUI7QUFDdkQsU0FBSyxXQUFXO0FBQUE7QUFBQSxNQU1QLFlBQXFCO0FBQzlCLFdBQU8sSUFBSSxRQUFTLGNBQWUsS0FBSztBQUFBO0FBQUEsTUFNL0IsY0FBc0I7QUFDL0IsV0FBTyxnQkFBaUIsS0FBSztBQUFBO0FBQUEsTUFNcEIsVUFBbUI7QUFDNUIsV0FBTyxJQUFJLFFBQVMsWUFBYSxLQUFLO0FBQUE7QUFBQSxNQU03QixVQUFtQjtBQUM1QixXQUFPLFFBQVEsWUFBYTtBQUFBO0FBQUEsTUFNbkIsZUFBd0I7QUFDakMsV0FBTyxRQUFRLG1CQUFvQjtBQUFBO0FBQUEsRUFHOUIsV0FBbUI7QUFDeEIsVUFBTSxJQUFJLEtBQUssU0FBUyxJQUFLLENBQUUsTUFBTyxFQUFFLFFBQVM7QUFDakQsV0FBTyxZQUFhLEVBQUcsT0FBVSxFQUFHLE9BQVUsRUFBRyxPQUFVLEVBQUcsUUFBVyxFQUFHLE9BQVUsRUFBRyxPQUFVLEVBQUcsT0FBVSxFQUFHLFFBQVcsRUFBRyxPQUFVLEVBQUcsT0FBVSxFQUFHLFFBQVcsRUFBRyxRQUFXLEVBQUcsT0FBVSxFQUFHLE9BQVUsRUFBRyxRQUFXLEVBQUc7QUFBQTtBQUFBLEVBTTFOLFFBQWlCO0FBQ3RCLFdBQU8sSUFBSSxRQUFTLEtBQUssU0FBUztBQUFBO0FBQUEsRUFNN0IsWUFBYSxVQUErQjtBQUNqRCxXQUFPLFFBQVEsU0FBVSxNQUFNLEdBQUc7QUFBQTtBQUFBLEVBTTdCLFlBQWEsUUFBMEI7QUFDNUMsV0FBTyxJQUFJLFFBQVMsU0FBVSxLQUFLLFVBQVU7QUFBQTtBQUFBLEVBTXhDLFlBQXlFO0FBQzlFLFVBQU0sRUFBRSxVQUFVLE9BQU8sYUFBYSxjQUFlLEtBQUs7QUFFMUQsV0FBTztBQUFBLE1BQ0wsVUFBVSxJQUFJLFFBQVM7QUFBQSxNQUN2QixPQUFPLElBQUksUUFBUztBQUFBLE1BQ3BCLFVBQVUsSUFBSSxXQUFZO0FBQUE7QUFBQTtBQUFBLGFBT1osV0FBb0I7QUFDcEMsV0FBTyxJQUFJLFFBQVM7QUFBQTtBQUFBLFNBT1IsWUFBYSxVQUErQjtBQUN4RCxRQUFLLFNBQVMsV0FBVyxHQUFJO0FBQzNCLGFBQU8sUUFBUTtBQUFBLFdBQ1Y7QUFDTCxhQUFPLElBQUksUUFBUyxhQUFjLEdBQUcsU0FBUyxJQUFLLENBQUUsTUFBTyxFQUFFO0FBQUE7QUFBQTtBQUFBLFNBUXBELGVBQWdCLFlBQWtDO0FBQzlELFdBQU8sSUFBSSxRQUFTLG1CQUFvQixXQUFXO0FBQUE7QUFBQSxTQU92QyxZQUFhLFNBQTRCO0FBQ3JELFdBQU8sSUFBSSxRQUFTLGFBQWMsUUFBUTtBQUFBO0FBQUEsU0FPOUIsVUFBVyxRQUEyQjtBQUNsRCxXQUFPLElBQUksUUFBUyxjQUFlLE9BQU87QUFBQTtBQUFBLFNBTzlCLE1BQU8sUUFBMkI7QUFDOUMsV0FBTyxJQUFJLFFBQVMsVUFBVyxPQUFPO0FBQUE7QUFBQSxTQU8xQixZQUFhLFFBQTBCO0FBQ25ELFdBQU8sSUFBSSxRQUFTLGdCQUFpQjtBQUFBO0FBQUEsU0FPekIsVUFBVyxPQUF5QjtBQUNoRCxXQUFPLElBQUksUUFBUyxjQUFlO0FBQUE7QUFBQSxTQU92QixVQUFXLE9BQXlCO0FBQ2hELFdBQU8sSUFBSSxRQUFTLGNBQWU7QUFBQTtBQUFBLFNBT3ZCLFVBQVcsT0FBeUI7QUFDaEQsV0FBTyxJQUFJLFFBQVMsY0FBZTtBQUFBO0FBQUEsU0FRdkIsT0FDWixVQUNBLFNBQVMsSUFBSSxRQUFTLENBQUUsR0FBSyxHQUFLLEtBQ2xDLEtBQUssSUFBSSxRQUFTLENBQUUsR0FBSyxHQUFLLEtBQzlCLE9BQU8sR0FDRTtBQUNULFdBQU8sSUFBSSxRQUFTLFdBQ2xCLFNBQVMsVUFDVCxPQUFPLFVBQ1AsR0FBRyxVQUNIO0FBQUE7QUFBQSxTQVNVLGNBQ1osVUFDQSxTQUFTLElBQUksUUFBUyxDQUFFLEdBQUssR0FBSyxLQUNsQyxLQUFLLElBQUksUUFBUyxDQUFFLEdBQUssR0FBSyxLQUM5QixPQUFPLEdBQ0U7QUFDVCxXQUFPLElBQUksUUFBUyxrQkFDbEIsU0FBUyxVQUNULE9BQU8sVUFDUCxHQUFHLFVBQ0g7QUFBQTtBQUFBLFNBUVUsWUFBYSxNQUFNLElBQU0sT0FBTyxNQUFNLE1BQU0sS0FBaUI7QUFDekUsV0FBTyxJQUFJLFFBQVMsZ0JBQWlCLEtBQUssTUFBTTtBQUFBO0FBQUEsU0FPcEMsUUFBUyxVQUFtQixVQUFzQixPQUEwQjtBQUN4RixXQUFPLElBQUksUUFBUyxZQUFhLFNBQVMsVUFBVSxTQUFTLFVBQVUsTUFBTTtBQUFBO0FBQUE7OztBQ2xQMUUsMkJBQTRCLE1BQWtCLE9BQStCO0FBQ2xGLFFBQU0sWUFBWSxRQUFRO0FBQzFCLFFBQU0sZUFBZSxLQUFLLElBQUs7QUFDL0IsU0FBTztBQUFBLElBQ0wsS0FBTSxLQUFNO0FBQUEsSUFDWixLQUFNLEtBQU07QUFBQSxJQUNaLEtBQU0sS0FBTTtBQUFBLElBQ1osS0FBSyxJQUFLO0FBQUE7QUFBQTs7O0FDTlAsMEJBQTJCLE1BQWtCLElBQWlDO0FBQ25GLFFBQU0sRUFBRSxRQUFRLFNBQVMsYUFBYSxtQkFBb0IsTUFBTSxrQkFBTSxDQUFFLEdBQUssR0FBSztBQUVsRixRQUFNLElBQUksS0FBSyxLQUFNLElBQU0sU0FBVSxLQUFNLFFBQVMsS0FBTSxPQUFRLE1BQVE7QUFDMUUsUUFBTSxRQUFRLE9BQU87QUFFckIsU0FBTztBQUFBLElBQ0gsU0FBUyxLQUFNLE9BQVEsTUFBUTtBQUFBLElBQy9CLFFBQVEsS0FBTSxTQUFVLE1BQVE7QUFBQSxJQUNoQyxVQUFVLEtBQU0sUUFBUyxNQUFRO0FBQUEsSUFDbkM7QUFBQTtBQUFBOzs7QUNORyx1QkFBd0IsS0FBb0M7QUFDakUsUUFBTSxNQUFNLFVBQVc7QUFDdkIsTUFBSyxRQUFRLEdBQU07QUFDakIsV0FBTyxDQUFFLEdBQUssR0FBSyxHQUFLO0FBQUE7QUFFMUIsU0FBTyxTQUFVLEtBQUssSUFBTTtBQUFBOzs7QUNWdkIsdUJBQXdCLE9BQStCO0FBQzVELFNBQU8sQ0FBRSxLQUFLLElBQUssUUFBUSxJQUFPLEdBQUssR0FBSyxLQUFLLElBQUssUUFBUTtBQUFBOzs7QUNEekQsdUJBQXdCLE9BQStCO0FBQzVELFNBQU8sQ0FBRSxHQUFLLEtBQUssSUFBSyxRQUFRLElBQU8sR0FBSyxLQUFLLElBQUssUUFBUTtBQUFBOzs7QUNEekQsdUJBQXdCLE9BQStCO0FBQzVELFNBQU8sQ0FBRSxHQUFLLEdBQUssS0FBSyxJQUFLLFFBQVEsSUFBTyxLQUFLLElBQUssUUFBUTtBQUFBOzs7QUNFekQsbUJBQW9CLEdBQWtCLEdBQWtCLEdBQTJCO0FBQ3hGLE1BQUssTUFBTSxHQUFNO0FBQUUsV0FBTyxFQUFFO0FBQUE7QUFDNUIsTUFBSyxNQUFNLEdBQU07QUFBRSxXQUFPLEVBQUU7QUFBQTtBQUs1QixNQUFJLGVBQWUsT0FBUSxHQUFHO0FBRTlCLE1BQUssZUFBZSxHQUFNO0FBQ3hCLFFBQUksT0FBUTtBQUNaLG1CQUFlLENBQUM7QUFBQTtBQUlsQixNQUFLLGdCQUFnQixHQUFNO0FBQ3pCLFdBQU8sRUFBRTtBQUFBO0FBR1gsUUFBTSxrQkFBa0IsSUFBTSxlQUFlO0FBRzdDLE1BQUssbUJBQW1CLE9BQU8sU0FBVTtBQUN2QyxVQUFNLElBQUksSUFBTTtBQUVoQixXQUFPLGFBQWM7QUFBQSxNQUNuQixJQUFJLEVBQUcsS0FBTSxJQUFJLEVBQUc7QUFBQSxNQUNwQixJQUFJLEVBQUcsS0FBTSxJQUFJLEVBQUc7QUFBQSxNQUNwQixJQUFJLEVBQUcsS0FBTSxJQUFJLEVBQUc7QUFBQSxNQUNwQixJQUFJLEVBQUcsS0FBTSxJQUFJLEVBQUc7QUFBQTtBQUFBO0FBS3hCLFFBQU0sZUFBZSxLQUFLLEtBQU07QUFDaEMsUUFBTSxZQUFZLEtBQUssTUFBTyxjQUFjO0FBQzVDLFFBQU0sU0FBUyxLQUFLLElBQU8sS0FBTSxLQUFNLGFBQWM7QUFDckQsUUFBTSxTQUFTLEtBQUssSUFBSyxJQUFJLGFBQWM7QUFFM0MsU0FBTztBQUFBLElBQ0wsRUFBRyxLQUFNLFNBQVMsRUFBRyxLQUFNO0FBQUEsSUFDM0IsRUFBRyxLQUFNLFNBQVMsRUFBRyxLQUFNO0FBQUEsSUFDM0IsRUFBRyxLQUFNLFNBQVMsRUFBRyxLQUFNO0FBQUEsSUFDM0IsRUFBRyxLQUFNLFNBQVMsRUFBRyxLQUFNO0FBQUE7QUFBQTs7O0FDbkMvQixJQUFNLHdCQUF1QyxpREFBRSxHQUFLLEdBQUssR0FBSztBQUt2RCx1QkFBaUI7QUFBQSxFQUdmLFlBQWEsV0FBMEIsdUJBQXdCO0FBQ3BFLFNBQUssV0FBVztBQUFBO0FBQUEsTUFNUCxJQUFZO0FBQ3JCLFdBQU8sS0FBSyxTQUFVO0FBQUE7QUFBQSxNQU1iLElBQVk7QUFDckIsV0FBTyxLQUFLLFNBQVU7QUFBQTtBQUFBLE1BTWIsSUFBWTtBQUNyQixXQUFPLEtBQUssU0FBVTtBQUFBO0FBQUEsTUFNYixJQUFZO0FBQ3JCLFdBQU8sS0FBSyxTQUFVO0FBQUE7QUFBQSxFQUdqQixXQUFtQjtBQUN4QixXQUFPLGVBQWdCLEtBQUssRUFBRSxRQUFTLE9BQVUsS0FBSyxFQUFFLFFBQVMsT0FBVSxLQUFLLEVBQUUsUUFBUyxPQUFVLEtBQUssRUFBRSxRQUFTO0FBQUE7QUFBQSxFQU1oSCxRQUFvQjtBQUN6QixXQUFPLElBQUksV0FBWSxLQUFLLFNBQVM7QUFBQTtBQUFBLE1BTTVCLFVBQW1CO0FBQzVCLFdBQU8sSUFBSSxRQUFTLG1CQUFvQixLQUFLO0FBQUE7QUFBQSxNQU1wQyxXQUF1QjtBQUNoQyxXQUFPLElBQUksV0FBWSxZQUFhLEtBQUs7QUFBQTtBQUFBLE1BTWhDLFNBQWlCO0FBQzFCLFdBQU8sVUFBVyxLQUFLO0FBQUE7QUFBQSxNQU1kLFdBQW1CO0FBQzVCLFdBQU8sWUFBYSxLQUFLO0FBQUE7QUFBQSxNQU1oQixhQUF5QjtBQUNsQyxXQUFPLElBQUksV0FBWSxjQUFlLEtBQUs7QUFBQTtBQUFBLEVBT3RDLFlBQWEsYUFBd0M7QUFDMUQsV0FBTyxXQUFXLFNBQVUsTUFBTSxHQUFHO0FBQUE7QUFBQSxFQVFoQyxNQUFPLEdBQWUsR0FBd0I7QUFDbkQsV0FBTyxXQUFXLE1BQU8sTUFBTSxHQUFHO0FBQUE7QUFBQSxhQU1sQixXQUF1QjtBQUN2QyxXQUFPLElBQUksV0FBWTtBQUFBO0FBQUEsU0FPWCxZQUFhLGFBQXdDO0FBQ2pFLFFBQUssWUFBWSxXQUFXLEdBQUk7QUFDOUIsYUFBTyxXQUFXO0FBQUEsV0FDYjtBQUNMLGFBQU8sSUFBSSxXQUFZLGFBQWMsR0FBRyxZQUFZLElBQUssQ0FBRSxNQUFPLEVBQUU7QUFBQTtBQUFBO0FBQUEsU0FVMUQsTUFBTyxHQUFlLEdBQWUsR0FBd0I7QUFDekUsV0FBTyxJQUFJLFdBQVksVUFBVyxFQUFFLFVBQVUsRUFBRSxVQUFVO0FBQUE7QUFBQSxTQU85QyxVQUFXLE9BQTRCO0FBQ25ELFdBQU8sSUFBSSxXQUFZLGNBQWU7QUFBQTtBQUFBLFNBTzFCLFVBQVcsT0FBNEI7QUFDbkQsV0FBTyxJQUFJLFdBQVksY0FBZTtBQUFBO0FBQUEsU0FPMUIsVUFBVyxPQUE0QjtBQUNuRCxXQUFPLElBQUksV0FBWSxjQUFlO0FBQUE7QUFBQSxTQVExQixhQUFjLE1BQWUsSUFBMEI7QUFDbkUsV0FBTyxJQUFJLFdBQVksaUJBQWtCLEtBQUssVUFBVSxHQUFHO0FBQUE7QUFBQSxTQU0vQyxjQUFlLE1BQWUsT0FBNEI7QUFDdEUsV0FBTyxJQUFJLFdBQVksa0JBQW1CLEtBQUssVUFBVTtBQUFBO0FBQUEsU0FNN0MsWUFBYSxRQUE4QjtBQUN2RCxXQUFPLElBQUksV0FBWSxnQkFBaUIsT0FBTztBQUFBO0FBQUE7OztBQzdMNUMsU0FBUywyQkFBRyxDQUFFLE9BQWUsU0FBMEI7QUFDNUQsU0FBTyxRQUFRLEtBQUssTUFBTyxRQUFRLFdBQVk7QUFBQTs7O0FDQTFDLHVCQUF3QixPQUF3QjtBQUNyRCxTQUFPLDJCQUFHLENBQUUsUUFBUSxLQUFLLElBQUksSUFBTSxLQUFLLE1BQU8sS0FBSztBQUFBOzs7QUNRL0MsdUJBQXdCLEdBQWUsT0FBaUM7QUFDN0UsUUFBTSxDQUFFLEdBQUcsR0FBRyxHQUFHLFFBQ2YsQ0FBQyxTQUFTLFVBQVUsUUFBUSxDQUFFLEdBQUcsR0FBRyxHQUFHLEtBQ3ZDLFVBQVUsUUFBUSxDQUFFLEdBQUcsR0FBRyxHQUFHLE1BQzdCLFVBQVUsUUFBUSxDQUFFLEdBQUcsR0FBRyxHQUFHLE1BQzdCLFVBQVUsUUFBUSxDQUFFLEdBQUcsR0FBRyxHQUFHLEtBQzdCLFVBQVUsUUFBUSxDQUFFLEdBQUcsR0FBRyxHQUFHLEtBQzdCLENBQUUsR0FBRyxHQUFHLEdBQUc7QUFFYixRQUFNLFNBQXFCLENBQUUsR0FBSyxHQUFLO0FBRXZDLFFBQU0sSUFBSSxFQUFHLElBQUksSUFBSTtBQUNyQixTQUFRLEtBQU0sQ0FBQyxPQUFPLEtBQUssS0FBTSxNQUFPLEdBQUcsSUFBTTtBQUVqRCxNQUFLLEtBQUssSUFBSyxLQUFNLFVBQVc7QUFDOUIsV0FBUSxLQUFNLE9BQU8sS0FBSyxNQUFPLEVBQUcsSUFBSSxJQUFJLElBQUssRUFBRyxJQUFJO0FBQ3hELFdBQVEsS0FBTSxPQUFPLEtBQUssTUFBTyxFQUFHLElBQUksSUFBSSxJQUFLLEVBQUcsSUFBSTtBQUFBLFNBQ25EO0FBRUwsV0FBUSxLQUFNLE9BQU8sS0FBSyxNQUFPLENBQUMsRUFBRyxJQUFJLElBQUksSUFBSyxFQUFHLElBQUk7QUFBQTtBQUczRCxNQUFLLG1CQUFvQixVQUFXLE1BQU0sS0FBSyxJQUFLO0FBRWxELFdBQVEsS0FBTSxjQUFlLE9BQVEsS0FBTSxLQUFLO0FBQ2hELFdBQVEsS0FBTSxjQUFlLEtBQUssS0FBSyxPQUFRO0FBQy9DLFdBQVEsS0FBTSxjQUFlLE9BQVEsS0FBTSxLQUFLO0FBQUE7QUFHbEQsU0FBTztBQUFBOzs7QUM5QkYsdUJBQXdCLEdBQWUsT0FBaUM7QUFDN0UsU0FBTyxjQUFlLGFBQWMsSUFBSztBQUFBOzs7QUNGcEMsNkJBQThCLEdBQWtCLE9BQWlDO0FBQ3RGLFNBQU8sY0FBZSxtQkFBb0IsSUFBSztBQUFBOzs7QUNOMUMsdUJBQXdCLE9BQW1CLE9BQW9DO0FBQ3BGLFFBQU0sQ0FBRSxHQUFHLEdBQUcsR0FBRyxRQUNmLENBQUMsU0FBUyxVQUFVLFFBQVEsQ0FBRSxHQUFHLEdBQUcsR0FBRyxLQUN2QyxVQUFVLFFBQVEsQ0FBRSxHQUFHLEdBQUcsR0FBRyxNQUM3QixVQUFVLFFBQVEsQ0FBRSxHQUFHLEdBQUcsR0FBRyxNQUM3QixVQUFVLFFBQVEsQ0FBRSxHQUFHLEdBQUcsR0FBRyxLQUM3QixVQUFVLFFBQVEsQ0FBRSxHQUFHLEdBQUcsR0FBRyxLQUM3QixDQUFFLEdBQUcsR0FBRyxHQUFHO0FBRWIsUUFBTSxLQUFLLE1BQU0sTUFBTztBQUN4QixRQUFNLEtBQUssTUFBTSxPQUFPLE1BQU87QUFDL0IsUUFBTSxLQUFLLE1BQU0sTUFBTztBQUV4QixRQUFNLEtBQUssS0FBSyxJQUFLO0FBQ3JCLFFBQU0sS0FBSyxLQUFLLElBQUs7QUFDckIsUUFBTSxLQUFLLEtBQUssSUFBSztBQUNyQixRQUFNLEtBQUssS0FBSyxJQUFLO0FBQ3JCLFFBQU0sS0FBSyxLQUFLLElBQUs7QUFDckIsUUFBTSxLQUFLLEtBQUssSUFBSztBQUVyQixRQUFNLFNBQXdCO0FBQUEsSUFDNUI7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0EsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLO0FBQUE7QUFFM0IsU0FBUSxLQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSztBQUN2QyxTQUFRLEtBQU0sT0FBUyxNQUFLLEtBQUssS0FBSyxLQUFLLEtBQUs7QUFDaEQsU0FBUSxLQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSztBQUV2QyxTQUFPO0FBQUE7OztBQ3hCRixrQkFBWTtBQUFBLEVBWVYsWUFBYSxXQUF1QixDQUFFLEdBQUssR0FBSyxJQUFPLFFBQW9CLE9BQVE7QUFDeEYsU0FBSyxXQUFXO0FBQ2hCLFNBQUssUUFBUTtBQUFBO0FBQUEsTUFNSixJQUFZO0FBQ3JCLFdBQU8sS0FBSyxTQUFVO0FBQUE7QUFBQSxNQU1iLElBQVk7QUFDckIsV0FBTyxLQUFLLFNBQVU7QUFBQTtBQUFBLE1BTWIsSUFBWTtBQUNyQixXQUFPLEtBQUssU0FBVTtBQUFBO0FBQUEsRUFHakIsV0FBbUI7QUFDeEIsV0FBTyxVQUFXLEtBQUssRUFBRSxRQUFTLE9BQVUsS0FBSyxFQUFFLFFBQVMsT0FBVSxLQUFLLEVBQUUsUUFBUyxPQUFVLEtBQUs7QUFBQTtBQUFBLEVBTWhHLFFBQWU7QUFDcEIsV0FBTyxJQUFJLE1BQU8sS0FBSyxTQUFTLFVBQXdCLEtBQUs7QUFBQTtBQUFBLE1BTXBELGFBQXlCO0FBQ2xDLFdBQU8sSUFBSSxXQUFZLGNBQWUsS0FBSyxVQUFVLEtBQUs7QUFBQTtBQUFBLE1BTWpELFVBQW1CO0FBQzVCLFdBQU8sS0FBSyxXQUFXO0FBQUE7QUFBQSxTQU1YLFlBQWEsUUFBaUIsT0FBMkI7QUFDckUsV0FBTyxJQUFJLE1BQU8sY0FBZSxPQUFPLFVBQVUsUUFBUztBQUFBO0FBQUEsU0FNL0MsWUFBYSxRQUFpQixPQUEyQjtBQUNyRSxXQUFPLElBQUksTUFBTyxjQUFlLE9BQU8sVUFBVSxRQUFTO0FBQUE7QUFBQSxTQU0vQyxlQUFnQixZQUF3QixPQUEyQjtBQUMvRSxXQUFPLElBQUksTUFBTyxvQkFBcUIsV0FBVyxVQUFVLFFBQVM7QUFBQTtBQUFBOzs7QUM5RWxFLDhCQUNMLENBQUUsSUFBSSxLQUNOLFFBQzJCO0FBQzNCLFFBQU0sSUFBSSxPQUFRLElBQUksT0FBUTtBQUM5QixRQUFNLElBQUksT0FBUSxHQUFHO0FBQ3JCLFFBQU0sSUFBSSxPQUFRLEdBQUcsS0FBTSxPQUFRO0FBQ25DLFFBQU0sSUFBSSxJQUFJLElBQUk7QUFFbEIsTUFBSyxJQUFJLEdBQU07QUFBRSxXQUFPO0FBQUE7QUFFeEIsUUFBTSxRQUFRLEtBQUssS0FBTTtBQUV6QixTQUFPLENBQUUsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJO0FBQUE7OztBQ3BCckIsb0JBQXFCLE1BQTZCO0FBQ3ZELFNBQU8sT0FBUSxLQUFNLElBQUssS0FBTTtBQUFBOzs7QUNBM0IsdUJBQXdCLE1BQTBCO0FBQ3ZELFNBQU87QUFBQSxJQUNMLEtBQU07QUFBQSxJQUNOLGFBQWMsV0FBWTtBQUFBO0FBQUE7OztBQ0h2QixpQkFBVztBQUFBLEVBWVQsWUFBYSxRQUFpQixRQUFRLE1BQU0sTUFBZSxRQUFRLElBQUs7QUFDN0UsU0FBSyxTQUFTO0FBQ2QsU0FBSyxZQUFZO0FBQUE7QUFBQSxNQU1SLE1BQWU7QUFDeEIsV0FBTyxDQUFFLEtBQUssT0FBTyxVQUFVLEtBQUssVUFBVTtBQUFBO0FBQUEsRUFhekMsaUJBQWtCLFFBQTZDO0FBQ3BFLFdBQU8scUJBQXNCLEtBQUssS0FBSyxPQUFPO0FBQUE7QUFBQSxTQU9sQyxRQUFTLEtBQXFCO0FBQzFDLFdBQU8sSUFBSSxLQUFNLElBQUksUUFBUyxJQUFLLEtBQU8sSUFBSSxRQUFTLElBQUs7QUFBQTtBQUFBLFNBUWhELFVBQVcsTUFBb0I7QUFDM0MsV0FBTyxLQUFLLFFBQVMsY0FBZSxLQUFLO0FBQUE7QUFBQTs7O0FDcER0QywyQkFDTCxDQUFFLE9BQU8sTUFDVCxRQUNVO0FBQ1YsU0FBTztBQUFBLElBQ0wsaUJBQWtCLE9BQU87QUFBQSxJQUN6QixpQkFBa0IsS0FBSztBQUFBO0FBQUE7OztBQ0pwQixpQkFBa0IsTUFBZ0IsR0FBd0I7QUFDL0QsU0FBTyxPQUNMLFNBQVUsS0FBTSxJQUFLLElBQU0sSUFDM0IsU0FBVSxLQUFNLElBQUs7QUFBQTs7O0FDRWxCLGtDQUNMLE1BQ0EsT0FDQSxTQUNZO0FBQ1osUUFBTSxLQUFLLE9BQVEsT0FBTyxLQUFNO0FBQ2hDLFFBQU0sS0FBSyxPQUFRLEtBQU0sSUFBSyxLQUFNO0FBRXBDLE1BQUksSUFBSSxPQUFRLElBQUksTUFBTyxPQUFRLElBQUk7QUFDdkMsYUFBYSxLQUFJLFNBQVU7QUFFM0IsU0FBTyxRQUFTLE1BQU07QUFBQTs7O0FDWmpCLDhCQUNMLE1BQ0EsT0FDQSxTQUNRO0FBQ1IsU0FBTyxVQUFXLE9BQ2hCLHlCQUEwQixNQUFNLE9BQU8sVUFDdkM7QUFBQTs7O0FDVkcsa0JBQVk7QUFBQSxFQUlWLFlBQWEsUUFBaUIsUUFBUSxNQUFNLE1BQWUsUUFBUSxNQUFPO0FBQy9FLFNBQUssUUFBUTtBQUNiLFNBQUssTUFBTTtBQUFBO0FBQUEsTUFNRixNQUFnQjtBQUN6QixXQUFPLENBQUUsS0FBSyxNQUFNLFVBQVUsS0FBSyxJQUFJO0FBQUE7QUFBQSxNQU05QixNQUFZO0FBQ3JCLFdBQU8sS0FBSyxVQUFXO0FBQUE7QUFBQSxFQU1sQixRQUFpQjtBQUN0QixXQUFPLElBQUksUUFBUyxXQUFZLEtBQUs7QUFBQTtBQUFBLEVBTWhDLFNBQWlCO0FBQ3RCLFdBQU8sS0FBSyxNQUFNO0FBQUE7QUFBQSxFQVNiLEdBQUksR0FBcUI7QUFDOUIsV0FBTyxJQUFJLFFBQVMsUUFBUyxLQUFLLEtBQUs7QUFBQTtBQUFBLEVBUWxDLGFBQWMsUUFBeUI7QUFDNUMsV0FBTyxNQUFNLFFBQ1gsa0JBQ0UsS0FBSyxLQUNMLE9BQU87QUFBQTtBQUFBLEVBY04sb0JBQXFCLE9BQWdCLFNBQTRCO0FBQ3RFLFdBQU8sSUFBSSxRQUFTLHlCQUEwQixLQUFLLEtBQUssTUFBTSxVQUFVO0FBQUE7QUFBQSxFQVluRSxnQkFBaUIsT0FBZ0IsU0FBMkI7QUFDakUsV0FBTyxxQkFBc0IsS0FBSyxLQUFLLE1BQU0sVUFBVTtBQUFBO0FBQUEsU0FPM0MsUUFBUyxNQUF3QjtBQUM3QyxXQUFPLElBQUksTUFBTyxJQUFJLFFBQVMsS0FBTSxLQUFPLElBQUksUUFBUyxLQUFNO0FBQUE7QUFBQTs7O0FDdkc1RCx5QkFBMEIsR0FBd0I7QUFDdkQsU0FBTyxFQUFHLEtBQU0sRUFBRyxLQUFNLEVBQUcsS0FBTSxFQUFHO0FBQUE7OztBQ0doQyxxQkFBc0IsR0FBNEI7QUFDdkQsUUFDRSxNQUFNLEVBQUcsSUFBSyxNQUFNLEVBQUcsSUFDdkIsTUFBTSxFQUFHLElBQUssTUFBTSxFQUFHLElBQ3ZCLE1BQU0sTUFBTSxNQUFNLE1BQU07QUFFMUIsTUFBSyxRQUFRLEdBQU07QUFBRSxXQUFPLFNBQVUsR0FBRztBQUFBO0FBRXpDLFNBQU8sU0FBVTtBQUFBLElBQ2Y7QUFBQSxJQUFLLENBQUM7QUFBQSxJQUNOLENBQUM7QUFBQSxJQUFLO0FBQUEsS0FDTCxJQUFNO0FBQUE7OztBQ1pKLHlCQUEwQixNQUFpQztBQUNoRSxNQUFLLEtBQUssU0FBUyxHQUFJO0FBQ3JCLFdBQU8sS0FBTTtBQUFBO0FBR2YsUUFBTSxJQUFJLEtBQUs7QUFDZixRQUFNLElBQUksYUFBYyxHQUFHO0FBQzNCLFFBQ0UsTUFBTSxFQUFHLElBQUssTUFBTSxFQUFHLElBQ3ZCLE1BQU0sRUFBRyxJQUFLLE1BQU0sRUFBRyxJQUN2QixNQUFNLEVBQUcsSUFBSyxNQUFNLEVBQUcsSUFDdkIsTUFBTSxFQUFHLElBQUssTUFBTSxFQUFHO0FBRXpCLFNBQU87QUFBQSxJQUNMLE1BQU0sTUFBTSxNQUFNO0FBQUEsSUFDbEIsTUFBTSxNQUFNLE1BQU07QUFBQSxJQUVsQixNQUFNLE1BQU0sTUFBTTtBQUFBLElBQ2xCLE1BQU0sTUFBTSxNQUFNO0FBQUE7QUFBQTs7O0FDbEJmLHVCQUNMLFFBQ1k7QUFDWixTQUFPO0FBQUEsSUFDTCxPQUFRO0FBQUEsSUFBSyxPQUFRO0FBQUEsSUFDckIsT0FBUTtBQUFBLElBQUssT0FBUTtBQUFBO0FBQUE7OztBQ0h6QixJQUFNLHFCQUFpQztBQUFBLEVBQ3JDO0FBQUEsRUFBSztBQUFBLEVBQ0w7QUFBQSxFQUFLO0FBQUE7QUFNQSxvQkFBYztBQUFBLEVBR1osWUFBYSxJQUFnQixvQkFBcUI7QUFDdkQsU0FBSyxXQUFXO0FBQUE7QUFBQSxNQU1QLFlBQXFCO0FBQzlCLFdBQU8sSUFBSSxRQUFTLGNBQWUsS0FBSztBQUFBO0FBQUEsTUFNL0IsY0FBc0I7QUFDL0IsV0FBTyxnQkFBaUIsS0FBSztBQUFBO0FBQUEsTUFNcEIsVUFBbUI7QUFDNUIsV0FBTyxJQUFJLFFBQVMsWUFBYSxLQUFLO0FBQUE7QUFBQSxFQUdqQyxXQUFtQjtBQUN4QixVQUFNLElBQUksS0FBSyxTQUFTLElBQUssQ0FBRSxNQUFPLEVBQUUsUUFBUztBQUNqRCxXQUFPLFlBQWEsRUFBRyxPQUFVLEVBQUcsT0FBVSxFQUFHLE9BQVUsRUFBRztBQUFBO0FBQUEsRUFNekQsUUFBaUI7QUFDdEIsV0FBTyxJQUFJLFFBQVMsS0FBSyxTQUFTO0FBQUE7QUFBQSxFQU03QixZQUFhLFVBQStCO0FBQ2pELFdBQU8sUUFBUSxTQUFVLE1BQU0sR0FBRztBQUFBO0FBQUEsRUFNN0IsWUFBYSxRQUEwQjtBQUM1QyxXQUFPLElBQUksUUFBUyxTQUFVLEtBQUssVUFBVTtBQUFBO0FBQUEsYUFNN0IsV0FBb0I7QUFDcEMsV0FBTyxJQUFJLFFBQVM7QUFBQTtBQUFBLFNBT1IsWUFBYSxVQUErQjtBQUN4RCxRQUFLLFNBQVMsV0FBVyxHQUFJO0FBQzNCLGFBQU8sUUFBUTtBQUFBLFdBQ1Y7QUFDTCxhQUFPLElBQUksUUFBUyxhQUFjLEdBQUcsU0FBUyxJQUFLLENBQUUsTUFBTyxFQUFFO0FBQUE7QUFBQTtBQUFBOzs7QUM5RTdELDBCQUEyQixHQUFlLEdBQTRCO0FBQzNFLFNBQU87QUFBQSxJQUNMLEVBQUcsS0FBTSxFQUFHLEtBQU0sRUFBRyxLQUFNLEVBQUcsS0FBTSxFQUFHLEtBQU0sRUFBRztBQUFBLElBQ2hELEVBQUcsS0FBTSxFQUFHLEtBQU0sRUFBRyxLQUFNLEVBQUcsS0FBTSxFQUFHLEtBQU0sRUFBRztBQUFBLElBQ2hELEVBQUcsS0FBTSxFQUFHLEtBQU0sRUFBRyxLQUFNLEVBQUcsS0FBTSxFQUFHLEtBQU0sRUFBRztBQUFBO0FBQUE7OztBQ003Qyw0QkFDTCxDQUFFLFFBQVEsV0FDVixRQUNBLGNBQ1c7QUFFWCxRQUFNLFlBQVksYUFBYyxpQkFBa0IsUUFBUTtBQUcxRCxRQUFNLFdBQVcsU0FBVSxRQUFRLENBQUM7QUFDcEMsUUFBTSxXQUFXLGlCQUFrQixVQUFVO0FBQzdDLFFBQU0sY0FBYyxDQUFDLE9BQVEsVUFBVTtBQUV2QyxTQUFPLENBQUUsV0FBVztBQUFBOzs7QUNyQmYsK0JBQ0wsQ0FBRSxRQUFRLFdBQ1YsT0FDUTtBQUNSLFNBQU8sT0FBUSxRQUFRLFNBQVU7QUFBQTs7O0FDQTVCLHlCQUEwQixDQUFFLFFBQVEsV0FBbUM7QUFDNUUsUUFBTSxPQUFPLElBQU0sVUFBVztBQUM5QixTQUFPLENBQUUsU0FBVSxRQUFRLE9BQVEsV0FBVztBQUFBOzs7QUNIekMsbUJBQWE7QUFBQSxNQU9QLE1BQWlCO0FBQzFCLFdBQU8sQ0FBRSxLQUFLLE9BQU8sVUFBVSxLQUFLO0FBQUE7QUFBQSxNQU8zQixhQUFxQjtBQUM5QixXQUFPLE9BQU8sUUFBUyxnQkFBaUIsS0FBSztBQUFBO0FBQUEsRUFHeEMsWUFBYSxTQUFrQixRQUFRLElBQUksV0FBVyxHQUFNO0FBQ2pFLFNBQUssU0FBUztBQUNkLFNBQUssV0FBVztBQUFBO0FBQUEsRUFTWCxhQUFjLFFBQWlCLGNBQWlDO0FBekN6RTtBQTBDSSxXQUFPLE9BQU8sUUFDWixtQkFDRSxLQUFLLEtBQ0wsT0FBTyxVQUNQLG1EQUFjLGFBQWQsWUFBMEIsT0FBTyxhQUFhO0FBQUE7QUFBQSxFQVU3QyxnQkFBaUIsT0FBeUI7QUFDL0MsV0FBTyxzQkFBdUIsS0FBSyxLQUFLLE1BQU07QUFBQTtBQUFBLFNBT2xDLFFBQVMsT0FBMkI7QUFDaEQsV0FBTyxJQUFJLE9BQVEsSUFBSSxRQUFTLE1BQU8sS0FBTyxNQUFPO0FBQUE7QUFBQTs7O0FDdkRsRCw2QkFBOEIsUUFBcUIsT0FBNkI7QUFDckYsU0FBTyxPQUFPLE1BQU8sQ0FBRSxVQUFXLHNCQUF1QixPQUFPLFVBQVc7QUFBQTs7O0FDSHRFLHlCQUEwQixLQUE0QjtBQUMzRCxTQUFPO0FBQUEsSUFDTCxDQUFFLENBQUUsR0FBSyxHQUFLLElBQU8sQ0FBQyxJQUFLLEdBQUs7QUFBQSxJQUNoQyxDQUFFLENBQUUsSUFBTSxHQUFLLElBQU8sSUFBSyxHQUFLO0FBQUEsSUFDaEMsQ0FBRSxDQUFFLEdBQUssR0FBSyxJQUFPLENBQUMsSUFBSyxHQUFLO0FBQUEsSUFDaEMsQ0FBRSxDQUFFLEdBQUssSUFBTSxJQUFPLElBQUssR0FBSztBQUFBLElBQ2hDLENBQUUsQ0FBRSxHQUFLLEdBQUssSUFBTyxDQUFDLElBQUssR0FBSztBQUFBLElBQ2hDLENBQUUsQ0FBRSxHQUFLLEdBQUssS0FBUSxJQUFLLEdBQUs7QUFBQTtBQUFBOzs7QUNON0IscUNBQXNDLEdBQTZCO0FBQ3hFLFFBQ0UsTUFBTSxFQUFHLElBQUssTUFBTSxFQUFHLElBQUssTUFBTSxFQUFHLElBQUssTUFBTSxFQUFHLEtBQ25ELE1BQU0sRUFBRyxJQUFLLE1BQU0sRUFBRyxJQUFLLE1BQU0sRUFBRyxJQUFLLE1BQU0sRUFBRyxLQUNuRCxNQUFNLEVBQUcsSUFBSyxNQUFNLEVBQUcsSUFBSyxNQUFNLEVBQUcsS0FBTSxNQUFNLEVBQUcsS0FDcEQsTUFBTSxFQUFHLElBQUssTUFBTSxFQUFHLElBQUssTUFBTSxFQUFHLEtBQU0sTUFBTSxFQUFHO0FBRXRELFNBQU87QUFBQSxJQUNMLGdCQUFpQixDQUFFLENBQUUsTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLE1BQU8sTUFBTTtBQUFBLElBQzlELGdCQUFpQixDQUFFLENBQUUsTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLE1BQU8sTUFBTTtBQUFBLElBQzlELGdCQUFpQixDQUFFLENBQUUsTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLE1BQU8sTUFBTTtBQUFBLElBQzlELGdCQUFpQixDQUFFLENBQUUsTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLE1BQU8sTUFBTTtBQUFBLElBQzlELGdCQUFpQixDQUFFLENBQUUsTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLE1BQU8sTUFBTTtBQUFBLElBQzlELGdCQUFpQixDQUFFLENBQUUsTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLE1BQU8sTUFBTTtBQUFBO0FBQUE7OztBQ1gzRCw4QkFBK0IsUUFBcUIsS0FBd0I7QUFDakYsU0FBTyxPQUFPLE1BQU8sQ0FBRSxVQUFXO0FBQ2hDLFVBQU0sSUFBSSxNQUFPLEdBQUksSUFBSyxDQUFFLElBQUksTUFBTyxJQUFLLEtBQUssSUFBTSxJQUFJLEdBQUs7QUFDaEUsV0FBTyxzQkFBdUIsT0FBTyxNQUFPO0FBQUE7QUFBQTs7O0FDRHpDLGlDQUFrQyxRQUFxQixRQUE4QjtBQUMxRixTQUFPLE9BQU8sTUFBTyxDQUFFLFVBQ3JCLHNCQUF1QixPQUFPLE9BQVEsT0FBUyxDQUFDLE9BQVE7QUFBQTs7O0FDQXJELG9CQUFjO0FBQUEsTUFNUixNQUFtQjtBQUM1QixXQUFPLEtBQUssT0FBTyxJQUFLLENBQUUsVUFBVyxNQUFNO0FBQUE7QUFBQSxFQUd0QyxZQUFhLFFBQW1CO0FBQ3JDLFNBQUssU0FBUztBQUFBO0FBQUEsRUFRVCxhQUFjLE9BQTBCO0FBQzdDLFdBQU8sb0JBQXFCLEtBQUssS0FBSyxNQUFNO0FBQUE7QUFBQSxFQVF2QyxjQUFlLEtBQXFCO0FBQ3pDLFdBQU8scUJBQXNCLEtBQUssS0FBSyxJQUFJO0FBQUE7QUFBQSxFQVd0QyxpQkFBa0IsUUFBMkI7QUFDbEQsV0FBTyx3QkFBeUIsS0FBSyxLQUFLLE9BQU87QUFBQTtBQUFBLFNBUXJDLFFBQVMsUUFBK0I7QUFDcEQsV0FBTyxJQUFJLFFBQVMsT0FBTyxJQUFLLENBQUUsVUFBVyxPQUFPLFFBQVM7QUFBQTtBQUFBLFNBUWpELFNBQVUsS0FBcUI7QUFDM0MsV0FBTyxRQUFRLFFBQVMsZ0JBQWlCLElBQUk7QUFBQTtBQUFBLFNBUWpDLHFCQUFzQixRQUEyQjtBQUM3RCxXQUFPLFFBQVEsUUFBUyw0QkFBNkIsT0FBTztBQUFBO0FBQUE7OztBQ3pFekQsOEJBQStCLFFBQW9CLE9BQTZCO0FBQ3JGLFNBQU8sWUFBYSxPQUFRLE9BQVEsSUFBSyxXQUFhLE9BQVEsS0FBTSxPQUFRO0FBQUE7OztBQ0p2RSxvQkFBYztBQUFBLEVBSVosWUFBYSxTQUFrQixRQUFRLE1BQU0sU0FBaUIsR0FBTTtBQUN6RSxTQUFLLFNBQVM7QUFDZCxTQUFLLFNBQVM7QUFBQTtBQUFBLE1BTUwsTUFBa0I7QUFDM0IsV0FBTyxDQUFFLEtBQUssT0FBTyxVQUFVLEtBQUs7QUFBQTtBQUFBLEVBUS9CLGNBQWUsT0FBMEI7QUFDOUMsV0FBTyxxQkFBc0IsS0FBSyxLQUFLLE1BQU07QUFBQTtBQUFBLFNBT2pDLFFBQVMsUUFBOEI7QUFDbkQsV0FBTyxJQUFJLFFBQVMsSUFBSSxRQUFTLE9BQVEsS0FBTyxPQUFRO0FBQUE7QUFBQTs7O0FDN0JyRCwwQkFBMkIsR0FBZSxHQUE0QjtBQUMzRSxRQUFNLEtBQWlCLENBQUUsRUFBRyxJQUFLLEVBQUcsSUFBSyxFQUFHO0FBQzVDLFFBQU0sTUFBTSxpQkFBa0IsSUFBSTtBQUNsQyxRQUFNLElBQUksRUFBRztBQUNiLFNBQU8sQ0FBRSxJQUFLLElBQUssSUFBSyxJQUFLLElBQUssSUFBSztBQUFBOzs7QUNGbEMsNEJBQXNCLHNEQUFNLEdBQVU7QUFBQSxFQUdwQyxZQUFhLElBQWdCLENBQUUsR0FBSyxHQUFLLEdBQUssSUFBUTtBQUMzRDtBQUNBLFNBQUssV0FBVztBQUFBO0FBQUEsTUFNUCxJQUFZO0FBQ3JCLFdBQU8sS0FBSyxTQUFVO0FBQUE7QUFBQSxNQUdiLEVBQUcsR0FBWTtBQUN4QixTQUFLLFNBQVUsS0FBTTtBQUFBO0FBQUEsTUFNWixJQUFZO0FBQ3JCLFdBQU8sS0FBSyxTQUFVO0FBQUE7QUFBQSxNQUdiLEVBQUcsR0FBWTtBQUN4QixTQUFLLFNBQVUsS0FBTTtBQUFBO0FBQUEsTUFNWixJQUFZO0FBQ3JCLFdBQU8sS0FBSyxTQUFVO0FBQUE7QUFBQSxNQUdiLEVBQUcsR0FBWTtBQUN4QixTQUFLLFNBQVUsS0FBTTtBQUFBO0FBQUEsTUFNWixJQUFZO0FBQ3JCLFdBQU8sS0FBSyxTQUFVO0FBQUE7QUFBQSxNQUdiLEVBQUcsR0FBWTtBQUN4QixTQUFLLFNBQVUsS0FBTTtBQUFBO0FBQUEsRUFHaEIsV0FBbUI7QUFDeEIsV0FBTyxZQUFhLEtBQUssRUFBRSxRQUFTLE9BQVUsS0FBSyxFQUFFLFFBQVMsT0FBVSxLQUFLLEVBQUUsUUFBUyxPQUFVLEtBQUssRUFBRSxRQUFTO0FBQUE7QUFBQSxFQU03RyxhQUFjLFFBQTJCO0FBQzlDLFdBQU8sSUFBSSxRQUFTLGlCQUFrQixLQUFLLFVBQVUsT0FBTztBQUFBO0FBQUEsRUFNdkQsYUFBYyxRQUEyQjtBQUM5QyxXQUFPLElBQUksUUFBUyxpQkFBa0IsS0FBSyxVQUFVLE9BQU87QUFBQTtBQUFBLEVBR3BELE1BQU8sR0FBeUI7QUFDeEMsV0FBTyxJQUFJLFFBQVM7QUFBQTtBQUFBLGFBTUosT0FBZ0I7QUFDaEMsV0FBTyxJQUFJLFFBQVMsQ0FBRSxHQUFLLEdBQUssR0FBSztBQUFBO0FBQUEsYUFNckIsTUFBZTtBQUMvQixXQUFPLElBQUksUUFBUyxDQUFFLEdBQUssR0FBSyxHQUFLO0FBQUE7QUFBQTs7O0FDNUZ6QyxnQkFBaUIsT0FBbUIsU0FBOEI7QUFDaEUsU0FBTyxNQUFPLFFBQVM7QUFBQTtBQU16QixpQkFBa0IsT0FBbUIsU0FBOEI7QUFDakUsU0FBTyxPQUFRLE9BQU8sV0FBWSxNQUFNLE9BQVEsT0FBTztBQUFBO0FBTXpELGlCQUFrQixPQUFtQixTQUE4QjtBQUNqRSxTQUFPLFFBQVMsT0FBTyxXQUFZLFFBQVEsUUFBUyxPQUFPO0FBQUE7QUFHN0Qsa0JBQW1CLE9BQW1CLFNBQThCO0FBQ2xFLE1BQUksSUFBSTtBQUNSLGFBQVc7QUFDVCxVQUFNLEtBQUssT0FBUSxPQUFPO0FBQzFCLFFBQUksSUFBSSxNQUFRLE1BQUs7QUFFckIsUUFBSyxLQUFLLEtBQU07QUFDZCxhQUFPO0FBQUE7QUFBQTtBQUFBO0FBS2IscUJBQXNCLE9BQW1CLFNBQTZDO0FBR3BGLFVBQVMsTUFBTztBQUVoQixTQUFPO0FBQUEsSUFDTCxRQUFTLE9BQU87QUFBQSxJQUNoQixRQUFTLE9BQU87QUFBQSxJQUNoQixRQUFTLE9BQU87QUFBQTtBQUFBO0FBSXBCLG9CQUFxQixPQUFtQixTQUE0QztBQUVsRixVQUFTLE1BQU87QUFFaEIsUUFBTSxhQUFhLFFBQVMsS0FBTSxRQUFTLE9BQU8sV0FBWTtBQUU5RCxRQUFNLFFBQThCO0FBQ3BDLE1BQUksT0FBTztBQUVYLFNBQVEsUUFBUyxLQUFNLFlBQWE7QUFDbEMsVUFBTSxRQUFRLFNBQVUsT0FBTztBQUMvQixVQUFNLFNBQVMsT0FBUSxPQUFPO0FBQzlCLFdBQU8sU0FBUyxNQUFNLE9BQU87QUFDN0IsVUFBTSxRQUFRLFNBQVMsTUFBTSxTQUFTLE9BQVEsT0FBTztBQUVyRCxRQUFLLE9BQU8sS0FBTztBQUdqQixZQUFNLEtBQU07QUFBQSxRQUNWO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBLE9BQVEsT0FBTztBQUFBO0FBQUEsZUFFUCxTQUFTLEtBQU87QUFHMUIsWUFBTSxjQUFjLE9BQVEsT0FBTztBQUVuQyxZQUFNLEtBQU07QUFBQSxRQUNWO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBLFlBQWEsYUFBYyxJQUFLLE1BQU0sT0FBUSxPQUFPO0FBQUE7QUFHdkQsVUFBSyxVQUFVLElBQU87QUFDcEI7QUFBQTtBQUFBLFdBRUc7QUFDTCxZQUFNLElBQUksTUFBTyxHQUFJO0FBQUE7QUFBQTtBQUl6QixTQUFPO0FBQUE7QUFHRixtQkFBb0IsUUFBdUM7QUFDaEUsUUFBTSxRQUFRLElBQUksV0FBWTtBQUM5QixRQUFNLFVBQXNCLENBQUU7QUFFOUIsUUFBTSxTQUFTLFlBQWEsT0FBTztBQUNuQyxRQUFNLFNBQWlDO0FBRXZDLFNBQVEsUUFBUyxLQUFNLE1BQU0sUUFBUztBQUNwQyxXQUFPLEtBQU0sV0FBWSxPQUFPO0FBQUE7QUFHbEMsU0FBTyxDQUFFLFFBQVE7QUFBQTs7O0FDckdaLElBQU0sdUJBQW9DO0FBQUEsRUFDL0M7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQTs7O0FDYkssSUFBTSxvQkFBaUM7QUFBQSxFQUM1QztBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBOzs7QUNFSywyQkFBd0M7QUFDN0MsUUFBTSxRQUFxQjtBQUUzQixvQkFBa0IsSUFBSyxDQUFFLFNBQ3ZCLHFCQUFxQixJQUFLLENBQUUsU0FDMUIsTUFBTSxLQUFNLE9BQU87QUFJdkIsU0FBTztBQUFBOzs7QUNmRixJQUFNLHVCQUEwRDtBQUFBLEVBQ3JFLFlBQVk7QUFBQSxFQUNaLFdBQVc7QUFBQSxFQUNYLFdBQVc7QUFBQSxFQUNYLGdCQUFnQjtBQUFBLEVBQ2hCLFlBQVk7QUFBQSxFQUNaLFNBQVM7QUFBQSxFQUNULGFBQWE7QUFBQSxFQUNiLGVBQWU7QUFBQSxFQUNmLGlCQUFpQjtBQUFBOzs7QUNUWixJQUFNLHVCQUEwRDtBQUFBLEVBQ3JFLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQTs7O0FDYkEsSUFBTSxvQkFBdUQ7QUFBQSxFQUNsRSxLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUE7OztBQ0dBLDhCQUErQixPQUFrQztBQUN0RSxTQUFPLE1BQ0osS0FBTSxDQUFFLEdBQUcsTUFDVixrQkFBbUIsRUFBRyxNQUFxQixrQkFBbUIsRUFBRyxLQUVsRSxLQUFNLENBQUUsR0FBRyxNQUNWLHFCQUFzQixFQUFHLE1BQXFCLHFCQUFzQixFQUFHO0FBQUE7OztBQ0N0RSwyQkFBNEIsT0FBOEM7QUFFL0UsUUFBTSxTQUFTLE1BQU07QUFFckIsUUFBTSxjQUFjLElBQUk7QUFDeEIsUUFBTSxjQUFjLElBQUk7QUFFeEIsU0FBTyxJQUFLLENBQUUsU0FBVTtBQUN0QixVQUFNLE9BQU8sS0FBTTtBQUNuQixVQUFNLE9BQU8sS0FBTTtBQUNuQixnQkFBWSxJQUFLLE1BQU07QUFDdkIsZ0JBQVksSUFBSyxNQUFNO0FBQUE7QUFJekIsUUFBTSxRQUFxQjtBQUMzQixRQUFNLFNBQXNCO0FBQzVCLFFBQU0sT0FBb0I7QUFFMUIsdUJBQXFCLElBQUssQ0FBRSxTQUFVO0FBQ3BDLFVBQU0sU0FBUSxZQUFZLElBQUs7QUFDL0IsUUFBSyxPQUFNLE9BQU8sR0FBSTtBQUNwQixZQUFNLEtBQU07QUFBQSxlQUNGLE9BQU0sT0FBTyxHQUFJO0FBQzNCLGFBQU8sS0FBTTtBQUFBLGVBQ0gsT0FBTSxPQUFPLEdBQUk7QUFDM0IsV0FBSyxLQUFNO0FBQUE7QUFBQTtBQUtmLE1BQUk7QUFDSjtBQUNFLFFBQUksVUFBdUI7QUFHM0IsVUFBTSxJQUFJLE1BQU0sS0FBTSxZQUFZLElBQUssTUFBUztBQUNoRCxRQUFLLEdBQUk7QUFDUCxjQUFRLEtBQU07QUFBQTtBQUdoQix5QkFBcUIsSUFBSyxDQUFFLFNBQVU7QUFDcEMsWUFBTSxPQUFPLE1BQU0sS0FBTSxZQUFZLElBQUssT0FBVTtBQUNwRCxVQUFLLE1BQU87QUFDVixnQkFBUSxLQUFNO0FBRWQsWUFBSyxRQUFRLFNBQVMsR0FBSTtBQUN4QiwwQkFBZ0I7QUFBQTtBQUFBLGFBRWI7QUFDTCxrQkFBVTtBQUFBO0FBQUE7QUFBQTtBQU1oQixNQUFLLGVBQWdCO0FBQ25CLGVBQVksQ0FBRSxNQUFNLGFBQWMsWUFBWSxLQUFNO0FBQ2xELFVBQUssU0FBUyxPQUFPLEdBQUk7QUFDdkIsWUFBSTtBQUNKLFlBQUksVUFBdUI7QUFHM0IsY0FBTSxTQUFTLE1BQU07QUFDckIsY0FBTSxJQUFJLFNBQVMsSUFBSztBQUN4QixZQUFLLEdBQUk7QUFDUCxrQkFBUSxLQUFNO0FBQUE7QUFHaEIsNkJBQXFCLElBQUssQ0FBRSxTQUFVO0FBQ3BDLGdCQUFNLFVBQVMsT0FBTztBQUN0QixjQUFLLFNBQVMsSUFBSyxVQUFXO0FBQzVCLG9CQUFRLEtBQU07QUFFZCxnQkFBSyxRQUFRLFNBQVMsR0FBSTtBQUN4QixtQ0FBcUI7QUFBQTtBQUFBLGlCQUVsQjtBQUNMLHNCQUFVO0FBQUE7QUFBQTtBQUlkLFlBQUssb0JBQXFCO0FBQ3hCLDZCQUFtQixPQUFRLEdBQUcsbUJBQW1CLFNBQVM7QUFFMUQsZ0JBQU0sT0FBTztBQUNiLGdCQUFNLFdBQVc7QUFBQSxZQUNmLHFCQUFzQjtBQUFBLFlBQ3RCLHFCQUFzQixtQkFBb0IsR0FBSztBQUFBO0FBR2pELGlCQUFPO0FBQUEsWUFDTDtBQUFBLFlBQ0EsT0FBTztBQUFBLFlBQ1A7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUVYsTUFBSyxNQUFNLFNBQVMsR0FBSTtBQUN0QixVQUFNLEtBQU0sQ0FBRSxHQUFHLE1BQU8scUJBQXNCLEtBQU0scUJBQXNCO0FBQzFFLFVBQU0sT0FBUSxHQUFHLE1BQU0sU0FBUztBQUloQyxVQUFNLFlBQVksTUFBTSxLQUFNLFlBQVksSUFBSyxNQUFPO0FBQ3RELGNBQVUsSUFBSyxDQUFFLFNBQ2YsT0FBTyxPQUFRLE9BQU8sUUFBUyxPQUFRO0FBSXpDLHlCQUFzQixRQUFTLE9BQVEsR0FBRyxPQUFPLFNBQVM7QUFHMUQsVUFBTSxPQUFPO0FBQ2IsVUFBTSxXQUFXO0FBQUEsTUFDZixxQkFBc0I7QUFBQSxNQUN0QixxQkFBc0IsTUFBTztBQUFBLE1BQzdCLHFCQUFzQixPQUFRLEdBQUs7QUFBQTtBQUdyQyxXQUFPLEtBQU0sR0FBRztBQUNoQix5QkFBc0I7QUFHdEIsV0FBTztBQUFBLE1BQ0w7QUFBQSxNQUNBLE9BQU87QUFBQSxNQUNQO0FBQUE7QUFBQTtBQUtKLE1BQUssT0FBTyxTQUFTLEtBQUssT0FBTyxTQUFTLEtBQUssU0FBUyxHQUFJO0FBQzFELFdBQU8sS0FBTSxDQUFFLEdBQUcsTUFBTyxxQkFBc0IsS0FBTSxxQkFBc0I7QUFLM0UsU0FBSyxLQUFNLEdBQUcsT0FBTyxPQUFRLEdBQUcsT0FBTyxTQUFTO0FBRWhELFNBQUssS0FBTSxDQUFFLEdBQUcsTUFBTyxxQkFBc0IsS0FBTSxxQkFBc0I7QUFDekUsU0FBSyxPQUFRLEdBQUcsS0FBSyxTQUFTO0FBSTlCLFVBQU0sWUFBWSxNQUFNLEtBQU0sWUFBWSxJQUFLLE9BQVE7QUFDdkQsY0FBVSxLQUFNLEdBQUcsTUFBTSxLQUFNLFlBQVksSUFBSyxLQUFNO0FBR3RELHlCQUFzQixXQUFZLE9BQVEsR0FBRyxVQUFVLFNBQVM7QUFHaEUsVUFBTSxPQUFPO0FBQ2IsVUFBTSxXQUFXO0FBQUEsTUFDZixxQkFBc0I7QUFBQSxNQUN0QixxQkFBc0IsT0FBUTtBQUFBLE1BQzlCLHFCQUFzQixLQUFNO0FBQUE7QUFHOUIsV0FBTztBQUFBLE1BQ0w7QUFBQSxNQUNBLE9BQU87QUFBQSxNQUNQO0FBQUE7QUFBQTtBQUtKLGFBQVksQ0FBRSxPQUFPLGFBQWMsWUFBWSxLQUFNO0FBQ25ELFFBQUssU0FBUyxPQUFPLEdBQUk7QUFDdkIsWUFBTSxTQUFRLHFCQUFzQixNQUFNLEtBQU07QUFDaEQsYUFBTSxPQUFRLEdBQUcsT0FBTSxTQUFTO0FBRWhDLFlBQU0sT0FBTztBQUNiLFlBQU0sV0FBVztBQUFBLFFBQ2YscUJBQXNCO0FBQUEsUUFDdEIsR0FBRyxPQUNBLFNBQ0EsVUFDQSxJQUFLLENBQUUsU0FDTixxQkFBc0IsS0FBTTtBQUFBO0FBSWxDLGFBQU87QUFBQSxRQUNMO0FBQUEsUUFDQSxPQUFPO0FBQUEsUUFDUDtBQUFBO0FBQUE7QUFBQTtBQU1OLE1BQUssZUFBZ0I7QUFDbkIsa0JBQWMsT0FBUSxHQUFHLGNBQWMsU0FBUztBQUVoRCxVQUFNLE9BQU87QUFDYixVQUFNLFdBQVc7QUFBQSxNQUNmLHFCQUFzQjtBQUFBLE1BQ3RCLHFCQUFzQixjQUFlLEdBQUs7QUFBQTtBQUc1QyxXQUFPO0FBQUEsTUFDTDtBQUFBLE1BQ0EsT0FBTztBQUFBLE1BQ1A7QUFBQTtBQUFBO0FBS0osTUFBSyxPQUFPLFNBQVMsR0FBSTtBQUN2QixXQUFPLEtBQU0sQ0FBRSxHQUFHLE1BQU8scUJBQXNCLEtBQU0scUJBQXNCO0FBQzNFLFdBQU8sT0FBUSxHQUFHLE9BQU8sU0FBUztBQUlsQyxVQUFNLFlBQVksTUFBTSxLQUFNLFlBQVksSUFBSyxPQUFRO0FBQ3ZELGNBQVUsSUFBSyxDQUFFLFNBQ2YsT0FBTyxPQUFRLE9BQU8sUUFBUyxPQUFRO0FBSXpDLHlCQUFzQixRQUFTLE9BQVEsR0FBRyxPQUFPLFNBQVM7QUFHMUQsVUFBTSxPQUFPO0FBQ2IsVUFBTSxXQUFXO0FBQUEsTUFDZixxQkFBc0I7QUFBQSxNQUN0QixxQkFBc0IsT0FBUTtBQUFBLE1BQzlCLHFCQUFzQixPQUFRLEdBQUs7QUFBQSxNQUNuQyxxQkFBc0IsT0FBUSxHQUFLO0FBQUE7QUFHckMsV0FBTyxLQUFNLEdBQUc7QUFDaEIseUJBQXNCO0FBR3RCLFdBQU87QUFBQSxNQUNMO0FBQUEsTUFDQSxPQUFPO0FBQUEsTUFDUDtBQUFBO0FBQUE7QUFLSixNQUFLLEtBQUssU0FBUyxHQUFJO0FBQ3JCLFNBQUssS0FBTSxDQUFFLEdBQUcsTUFBTyxxQkFBc0IsS0FBTSxxQkFBc0I7QUFDekUsU0FBSyxPQUFRLEdBQUcsS0FBSyxTQUFTO0FBSTlCLFVBQU0sUUFBUSxNQUFNLEtBQU0sWUFBWSxJQUFLLEtBQU07QUFDakQsVUFBTSxLQUFNLEdBQUcsTUFBTSxLQUFNLFlBQVksSUFBSyxLQUFNO0FBQ2xELFVBQU0sSUFBSyxDQUFFLFNBQ1gsT0FBTyxPQUFRLE9BQU8sUUFBUyxPQUFRO0FBSXpDLHlCQUFzQixRQUFTLE9BQVEsR0FBRyxPQUFPLFNBQVM7QUFHMUQsVUFBTSxPQUFPO0FBQ2IsVUFBTSxXQUFXO0FBQUEsTUFDZixxQkFBc0I7QUFBQSxNQUN0QixxQkFBc0IsS0FBTTtBQUFBLE1BQzVCLHFCQUFzQixLQUFNO0FBQUEsTUFDNUIscUJBQXNCLE9BQVEsR0FBSztBQUFBO0FBR3JDLFdBQU8sS0FBTSxHQUFHO0FBQ2hCLHlCQUFzQjtBQUd0QixXQUFPO0FBQUEsTUFDTDtBQUFBLE1BQ0EsT0FBTztBQUFBLE1BQ1A7QUFBQTtBQUFBO0FBS0osTUFBSyxLQUFLLFNBQVMsR0FBSTtBQUdyQixVQUFNLE9BQU8sTUFBTSxLQUFNLFlBQVksSUFBSyxLQUFNO0FBQ2hELFNBQUssSUFBSyxDQUFFLFNBQ1YsT0FBTyxPQUFRLE9BQU8sUUFBUyxPQUFRO0FBSXpDLHlCQUFzQixRQUFTLE9BQVEsR0FBRyxPQUFPLFNBQVM7QUFHMUQsVUFBTSxPQUFPO0FBQ2IsVUFBTSxXQUFXO0FBQUEsTUFDZixxQkFBc0I7QUFBQSxNQUN0QixxQkFBc0IsS0FBTTtBQUFBLE1BQzVCLHFCQUFzQixPQUFRLEdBQUs7QUFBQSxNQUNuQyxxQkFBc0IsT0FBUSxHQUFLO0FBQUEsTUFDbkMscUJBQXNCLE9BQVEsR0FBSztBQUFBO0FBR3JDLFdBQU8sS0FBTSxHQUFHO0FBQ2hCLHlCQUFzQjtBQUd0QixXQUFPO0FBQUEsTUFDTDtBQUFBLE1BQ0EsT0FBTztBQUFBLE1BQ1A7QUFBQTtBQUFBO0FBS0o7QUFDRSxVQUFNLE9BQU87QUFJYix5QkFBc0I7QUFHdEIsV0FBTyxPQUFRLEdBQUcsT0FBTyxTQUFTO0FBR2xDLFVBQU0sV0FBVztBQUFBLE1BQ2YscUJBQXNCO0FBQUEsTUFDdEIscUJBQXNCLE9BQVEsR0FBSztBQUFBLE1BQ25DLHFCQUFzQixPQUFRLEdBQUs7QUFBQSxNQUNuQyxxQkFBc0IsT0FBUSxHQUFLO0FBQUEsTUFDbkMscUJBQXNCLE9BQVEsR0FBSztBQUFBLE1BQ25DLHFCQUFzQixPQUFRLEdBQUs7QUFBQTtBQUdyQyxXQUFPO0FBQUEsTUFDTDtBQUFBLE1BQ0EsT0FBTztBQUFBLE1BQ1A7QUFBQTtBQUFBO0FBQUE7OztBQ2xXQyxJQUFNLHVCQUFvQztBQUFBLEVBQy9DO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQTs7O0FDTkYsb0JBQXFDLE1BQXdCLEdBQXdCO0FBQUE7QUFDbkYsV0FBTyxNQUFNLE9BQU8sTUFBTyxDQUFFLFVBQVc7QUFDdEMsVUFBSyxLQUFLLEdBQUk7QUFDWixjQUFNO0FBQUE7QUFHUixhQUFPLFdBQVksTUFBTSxJQUFJO0FBQUE7QUFBQTtBQUFBOzs7QUNOMUIsZUFBbUIsTUFBZSxHQUFlO0FBQ3RELE1BQUk7QUFDRixXQUFPO0FBQUEsV0FDQyxPQUFSO0FBQ0EsUUFBSyxLQUFLLEdBQUk7QUFDWixZQUFNO0FBQUE7QUFHUixXQUFPLE1BQU8sTUFBTSxJQUFJO0FBQUE7QUFBQTs7O0FDTnJCLHNCQUF1QixRQUFzQztBQUNsRSxRQUFNLFNBQXlCO0FBRS9CLFFBQU0sUUFBUSxJQUFJLFdBQVk7QUFFOUIsUUFBTSxVQUFVLElBQUksWUFBYTtBQUVqQyxNQUFJLE9BQU87QUFHWCxNQUFJLGFBQWE7QUFHakIsTUFBSSxZQUFZO0FBR2hCLGFBQVc7QUFJVCxVQUFNLFFBQVEsTUFBTztBQUNyQixVQUFNLGFBQWUsU0FBUSxPQUFRO0FBQ3JDLFVBQU0sYUFBZSxVQUFTLElBQUksT0FBUTtBQUMxQyxVQUFNLGNBQWdCLFVBQVMsSUFBSSxPQUFRO0FBRzNDLFFBQUssWUFBYTtBQUVoQixZQUFNLFVBQVUsTUFBTyxXQUFhLElBQUksTUFBTztBQUcvQyxlQUFVLElBQUksR0FBRyxJQUFJLElBQUksS0FBTztBQUM5QixZQUFLLFdBQWEsS0FBSyxJQUFNLEdBQUk7QUFPL0Isa0JBQVMsS0FBTSxNQUFPLFdBQWEsSUFBSSxNQUFPO0FBQUE7QUFBQTtBQUFBO0FBTXBELFFBQUssYUFBYztBQUVqQixZQUFNLFlBQVksTUFBTztBQU96QixZQUFNLFdBQVcsTUFBTSxTQUFVLE1BQU0sT0FBTyxJQUFJO0FBQ2xELGNBQVEsSUFBSTtBQUVaLFlBQU0sV0FBd0Q7QUFHOUQsaUJBQVc7QUFRVCxjQUFNLGFBQWEsTUFBTztBQUUxQixZQUFLLGVBQWUsS0FBTztBQUN6QjtBQUFBLG1CQUVVLGVBQWUsS0FBTztBQUNoQyx1QkFBYTtBQUNiO0FBQUEsbUJBRVUsZUFBZSxLQUFPO0FBQ2hDLHNCQUFZO0FBQ1o7QUFBQTtBQUlGLGNBQU0sYUFBYSxjQUFjLElBQUk7QUFDckMsY0FBTSxXQUFXLGFBQWE7QUFNOUIsY0FBTSxVQUFVLE1BQU0sU0FBVSxNQUFNLE9BQU87QUFDN0MsZ0JBQVE7QUFFUixpQkFBUyxLQUFNO0FBQUEsVUFDYjtBQUFBLFVBQ0EsU0FBUyxNQUFNLEtBQU07QUFBQTtBQUFBO0FBSXpCLGFBQU8sS0FBTTtBQUFBLFFBQ1g7QUFBQSxRQUNBO0FBQUEsUUFDQSxTQUFTLE1BQU0sS0FBTTtBQUFBLFFBQ3JCLFVBQVUsTUFBTSxLQUFNO0FBQUEsUUFDdEI7QUFBQTtBQUFBLFdBSUc7QUFDTCxZQUFNLFdBQXlEO0FBRy9ELGlCQUFXO0FBRVQsY0FBTSxhQUFhLE1BQU87QUFFMUIsWUFBSyxlQUFlLEtBQU87QUFDekI7QUFBQSxtQkFFVSxlQUFlLEtBQU87QUFDaEMsdUJBQWE7QUFDYjtBQUFBLG1CQUVVLGVBQWUsS0FBTztBQUNoQyxzQkFBWTtBQUNaO0FBQUE7QUFJRixjQUFNLGFBQWEsY0FBYyxJQUFJO0FBQ3JDLGNBQU0sWUFBWSxhQUFhO0FBTS9CLGNBQU0sV0FBVyxNQUFNLFNBQVUsTUFBTSxPQUFPLElBQUk7QUFDbEQsZ0JBQVEsSUFBSTtBQUVaLGlCQUFTLEtBQU07QUFBQSxVQUNiO0FBQUEsVUFDQSxVQUFVLE1BQU0sS0FBTTtBQUFBO0FBQUE7QUFJMUIsYUFBTyxLQUFNO0FBQUEsUUFDWDtBQUFBLFFBQ0E7QUFBQSxRQUNBLFNBQVMsTUFBTSxLQUFNO0FBQUEsUUFDckI7QUFBQTtBQUFBO0FBSUosUUFBSyxZQUFhO0FBQ2hCLGFBQVMsTUFBSyxNQUFPLE9BQU8sU0FBWSxLQUFNO0FBQzlDLG1CQUFhO0FBQUE7QUFHZixRQUFLLFdBQVk7QUFDZjtBQUFBO0FBQUE7QUFJSixTQUFPO0FBQUE7OztBQ3RLRixzQkFBdUIsUUFBd0IsVUFFbEQsSUFBYTtBQU5qQjtBQU9FLFFBQU0sUUFBUSxJQUFRLDBDQUFTLFFBQVQsWUFBZ0I7QUFFdEMsTUFBSSxNQUFNO0FBRVYsTUFBSSxRQUFRLDBDQUE2QyxTQUFRLE9BQU8sUUFBUyxRQUFTLHNHQUF5RyxNQUFRLE9BQU87QUFFbE4sU0FBTyxJQUFLLENBQUUsT0FBTyxXQUFZO0FBQy9CLFVBQU0sRUFBRSxhQUFhLFNBQVMsYUFBYTtBQUUzQyxhQUFTLEtBQU0sMEJBQThCLFNBQVEsUUFBUyxRQUFTO0FBRXZFLFVBQU0sZUFBZSxRQUFRLElBQUssQ0FBRSxZQUFhO0FBQy9DLFlBQU0sUUFBUSxpQkFBa0I7QUFDaEMsYUFBTyxXQUFZO0FBQUE7QUFHckIsUUFBSSxjQUFjO0FBRWxCLFFBQUksb0JBQW9CO0FBQ3hCLFFBQUksSUFBSTtBQUVSLFFBQUssYUFBYztBQUNqQixZQUFNLEVBQUUsYUFBYTtBQUVyQixlQUFTLElBQUssQ0FBRSxFQUFFLFlBQVksY0FBZTtBQUMzQyxZQUFLLHNCQUFzQixZQUFhO0FBQ3RDLGNBQUssc0JBQXNCLElBQUs7QUFDOUIsa0JBQU0sWUFBVyxhQUFjO0FBQy9CLDJCQUFlLFlBQWEsWUFBYztBQUFBO0FBRzVDLDhCQUFvQjtBQUNwQixjQUFJO0FBQUE7QUFHTixpQkFBVSxJQUFJLEdBQUcsSUFBSSxRQUFRLFFBQVEsS0FBTztBQUMxQyxnQkFBTSxRQUFRLFFBQVM7QUFDdkIsZ0JBQU0sSUFBSSxTQUFVLElBQUk7QUFDeEIsZ0JBQU0sSUFBSSxTQUFVLElBQUksUUFBUTtBQUVoQyxlQUFLLE1BQU0sSUFDUCxJQUFLLEtBQU8sTUFDWixJQUFLLEtBQU87QUFBQTtBQUFBO0FBQUEsV0FHZjtBQUNMLGVBQVMsSUFBSyxDQUFFLEVBQUUsWUFBWSxlQUFnQjtBQUM1QyxZQUFLLHNCQUFzQixZQUFhO0FBQ3RDLGNBQUssc0JBQXNCLElBQUs7QUFDOUIsa0JBQU0sWUFBVyxhQUFjO0FBQy9CLDJCQUFlLFlBQWEsWUFBYztBQUFBO0FBRzVDLDhCQUFvQjtBQUNwQixjQUFJO0FBQUE7QUFHTixpQkFBVSxJQUFJLEdBQUcsSUFBSSxTQUFTLFFBQVEsS0FBSyxHQUFJO0FBQzdDLGdCQUFNLElBQUksU0FBVTtBQUNwQixnQkFBTSxJQUFJLFNBQVUsSUFBSTtBQUV4QixlQUFLLE1BQU0sSUFDUCxJQUFLLEtBQU8sTUFDWixJQUFLLEtBQU87QUFBQTtBQUFBO0FBQUE7QUFLdEIsVUFBTSxXQUFXLGFBQWM7QUFDL0IsbUJBQWUsWUFBYSxZQUFjO0FBRTFDLFdBQU8sV0FBWSxXQUFhO0FBQUE7QUFHbEMsU0FBTyxVQUFVO0FBRWpCLFNBQU87QUFBQTs7O0FDM0VGLHVCQUFpQjtBQUFBLEVBQWpCLGNBUlA7QUFTUyxzQkFBYTtBQUNiLG9CQUFXO0FBQ1gsaUJBQVE7QUFDUixrQkFBUztBQUFBO0FBQUEsRUFFVCxPQUFRLFdBQTRCO0FBQ3pDLFVBQU0sUUFBUSxJQUFNLEtBQUs7QUFDekIsVUFBTSxJQUFJLFFBQVE7QUFDbEIsVUFBTSxNQUFNLElBQVEsS0FBTSxJQUFJLE9BQU8sSUFBSSxJQUFJLFFBQVEsSUFBSSxJQUFJO0FBQzdELFVBQU0sUUFBUSxLQUFLLFFBQVEsS0FBSztBQUNoQyxVQUFNLE9BQVMsTUFBSyxXQUFXLFFBQVEsU0FBVTtBQUNqRCxTQUFLLFdBQWEsTUFBSyxXQUFXLFFBQVEsUUFBUztBQUNuRCxTQUFLLFFBQVEsS0FBSyxTQUFXLFNBQVEsUUFBUztBQUM5QyxXQUFPLEtBQUs7QUFBQTtBQUFBOzs7QUNuQlQsaUJBQWM7QUFBQSxFQUlaLFlBQWEsR0FBTSxHQUFPO0FBQy9CLFNBQUssSUFBSTtBQUNULFNBQUssSUFBSTtBQUFBO0FBQUEsRUFHSixPQUFhO0FBQ2xCLFVBQU0sSUFBSSxLQUFLO0FBQ2YsU0FBSyxJQUFJLEtBQUs7QUFDZCxTQUFLLElBQUk7QUFBQTtBQUFBOzs7QUNiTixxQkFBZTtBQUFBLEVBQWYsY0FGUDtBQUdVLGlCQUFRO0FBQ1IscUJBQVk7QUFDWixzQkFBYTtBQUNiLHNCQUFhO0FBQ2Isa0JBQWdDLElBQUksc0JBQXVCO0FBQUE7QUFBQSxNQUV4RCxlQUF1QjtBQUNoQyxXQUFPLEtBQU8sS0FBSztBQUFBO0FBQUEsTUFHVixNQUFjO0FBQ3ZCLFdBQU8sS0FBSztBQUFBO0FBQUEsTUFHSCxJQUFLLEtBQWM7QUFDNUIsU0FBSyxhQUFhLEtBQUs7QUFDdkIsU0FBSyxhQUFhLFlBQVk7QUFDOUIsU0FBSyxRQUFRO0FBQUE7QUFBQSxNQUdKLE9BQWU7QUFDeEIsV0FBTyxLQUFLLGFBQWUsYUFBWSxRQUFRLEtBQUssY0FBZSxPQUFRLEtBQUs7QUFBQTtBQUFBLEVBRzNFLFFBQWM7QUFDbkIsU0FBSyxPQUFPO0FBQUE7QUFBQSxFQUdQLE1BQU8sUUFBdUI7QUFDbkMsU0FBSyxhQUFhLEtBQUssT0FBTztBQUM5QixTQUFLLGFBQWEsWUFBWTtBQUFBO0FBQUEsRUFHekIsTUFBWTtBQUNqQixVQUFNLE1BQU0sWUFBWTtBQUN4QixVQUFNLFFBQVUsT0FBTSxLQUFLLGFBQWM7QUFFekMsUUFBSyxJQUFNLE9BQVE7QUFDakIsV0FBSztBQUFBLFdBQ0E7QUFDTCxXQUFLLE9BQU8sS0FBTTtBQUNsQixXQUFLLFFBQVEsS0FBUyxLQUFLLE9BQU87QUFBQTtBQUdwQyxTQUFLLFlBQVk7QUFDakIsU0FBSyxhQUFhO0FBQ2xCLFNBQUssYUFBYTtBQUFBO0FBQUE7OztBQzFDZixpQ0FDTCxRQUNBLFVBS0ksSUFDa0I7QUFmeEI7QUFnQkUsUUFBTSxPQUFPLGNBQVEsU0FBUixZQUFnQjtBQUM3QixRQUFNLFlBQVksY0FBUSxjQUFSLFlBQXFCO0FBQ3ZDLFFBQU0sYUFBYSxjQUFRLGVBQVIsWUFBc0I7QUFDekMsUUFBTSxpQkFBaUIsY0FBUSxtQkFBUixZQUEwQjtBQUVqRCxNQUFJLFVBQVU7QUFDZCxNQUFJLE1BQU07QUFDVixNQUFJO0FBQ0osUUFBTSxRQUFRLFlBQWEsTUFBTyxLQUFNO0FBQ3hDLFFBQU0sWUFBWSxZQUFhLE1BQU8sS0FBTTtBQUM1QyxRQUFNLGVBQWUsWUFBYSxNQUFPLEtBQU07QUFDL0MsTUFBSSxXQUFXO0FBRWYsU0FBTyxNQUFNO0FBQ1gsVUFBTSxNQUFNLFlBQWEsTUFBTyxJQUFLLE1BQU0sSUFBSSxhQUFjLElBQUk7QUFFakUsZ0JBQWEsV0FBWSxJQUFLLENBQUUsWUFBYTtBQUMzQyxZQUFNLElBQUksVUFBVTtBQUNwQixZQUFNLElBQUksSUFBSTtBQUVkLFVBQUssS0FBSyxVQUFXO0FBQ25CLGNBQU0sWUFBWSxPQUFRO0FBQzFCLGNBQU0saUJBQWlCLE9BQVEsTUFBTTtBQUVyQyxlQUFXLFNBQVEsSUFBSSxLQUFLLFFBQVMsWUFBYztBQUduRCxZQUFJLFFBQVEsTUFBTSxRQUFTO0FBRzNCLFlBQUksWUFBWTtBQUVoQixZQUFLLFVBQVUsSUFBSztBQUNsQixvQkFBVSxJQUFLLENBQUUsS0FBSyxVQUFXO0FBQy9CLGtCQUFNLE9BQU8sYUFBYztBQUMzQixnQkFBSyxPQUFPLE1BQU87QUFDakIsa0JBQUssT0FBTyxXQUFZO0FBQ3RCLHdCQUFRO0FBQ1IsNEJBQVk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9wQixZQUFLLFVBQVUsSUFBSztBQUNsQixvQkFBVSxJQUFLLENBQUUsS0FBSyxVQUFXO0FBQy9CLGdCQUFLLE1BQU0sV0FBWTtBQUNyQixzQkFBUTtBQUNSLDBCQUFZO0FBQUE7QUFBQTtBQUFBO0FBS2xCLGNBQU8sU0FBVTtBQUVqQixZQUFLLFlBQVksS0FBTTtBQUNyQixjQUFLLGFBQWMsU0FBVSxVQUFXLFFBQVU7QUFDaEQseUJBQWMsU0FBVTtBQUFBO0FBQUEsZUFFckI7QUFDTCxjQUFLLGFBQWMsVUFBVyxVQUFXLFFBQVU7QUFDakQsc0JBQVcsU0FBVTtBQUFBO0FBQUE7QUFJekIsb0JBQVk7QUFFWixjQUFRLE9BQU0sS0FBTSxPQUFPO0FBQUE7QUFHN0I7QUFFQSxrQkFBYSxNQUFPLElBQUssQ0FBRSxVQUFXO0FBQ3BDLGNBQU0sV0FBVyxVQUFXO0FBQzVCLGNBQU0sY0FBYyxhQUFjO0FBRWxDLFlBQUssT0FBUyxJQUFJLFVBQVUsS0FBTSxJQUFJO0FBQ3RDLFlBQUssT0FBUyxJQUFJLFVBQVUsS0FBTSxjQUFjLFdBQVcsSUFBTSxJQUFJO0FBQ3JFLFlBQUssT0FBUyxJQUFJLFVBQVUsS0FBTSxNQUFPO0FBQ3pDLFlBQUssT0FBUyxJQUFJLFVBQVUsS0FBTTtBQUFBO0FBQUE7QUFJdEMsV0FBTztBQUFBO0FBQUE7OztBQzdGSiw2QkFDTCxRQUNBLFVBSUksSUFDZ0I7QUFkdEI7QUFlRSxRQUFNLFlBQVksY0FBUSxjQUFSLFlBQXFCO0FBQ3ZDLFFBQU0sYUFBYSxjQUFRLGVBQVIsWUFBc0I7QUFDekMsUUFBTSxpQkFBaUIsY0FBUSxtQkFBUixZQUEwQjtBQUVqRCxNQUFJLFVBQVU7QUFDZCxNQUFJLE1BQU07QUFDVixNQUFJO0FBQ0osTUFBSSxXQUFXO0FBQ2YsTUFBSSxjQUFjO0FBQ2xCLE1BQUksV0FBVztBQUVmLFNBQU8sTUFBTTtBQUNYLFdBQU8sSUFBSSxhQUFjLFlBQWEsV0FBWSxJQUFLLE1BQU07QUFDM0QsWUFBTSxJQUFJLFVBQVU7QUFDcEIsWUFBTSxJQUFJLElBQUk7QUFFZCxVQUFLLEtBQUssVUFBVztBQUNuQixjQUFNLFlBQVksT0FBUTtBQUMxQixjQUFNLGlCQUFpQixPQUFRLE1BQU07QUFFckMsZUFBVyxTQUFRLElBQUksS0FBSyxRQUFTLFlBQWM7QUFDbkQsWUFBSyxZQUFZLEtBQU07QUFDckIsY0FBSyxjQUFjLFVBQVc7QUFDNUIsMEJBQWM7QUFBQTtBQUFBLGVBRVg7QUFDTCxjQUFLLGVBQWUsVUFBVztBQUM3Qix1QkFBVztBQUFBO0FBQUE7QUFJZixvQkFBWTtBQUVaLGNBQVEsT0FBTSxLQUFNLE9BQU87QUFBQTtBQUc3QjtBQUVBLGFBQU87QUFBQSxRQUNMLElBQUk7QUFBQSxRQUNKLGNBQWMsV0FBVyxJQUFNLElBQUk7QUFBQSxRQUNuQztBQUFBLFFBQ0E7QUFBQTtBQUFBLE9BRUE7QUFBQTtBQUFBOzs7QUM5Q0Qsb0NBQ0wsTUFDQSxFQUFFLE9BQU8sbUJBR0wsSUFDUTtBQUNaLFFBQU0sT0FBaUI7QUFDdkIsTUFBSSxXQUFXO0FBQ2YsTUFBSSxRQUFRO0FBRVosUUFBTSxjQUFjLEtBQU0sR0FBSyx3QkFBUztBQUt4QyxjQUFhLFlBQVksU0FBUyxHQUFJLElBQUssQ0FBRSxNQUFPO0FBN0J0RDtBQThCSSxhQUFXLHlCQUFhLE9BQWIsbUJBQW9CLE9BQXBCLFlBQTJCLEtBQVEsMkNBQWtCO0FBRWhFLFFBQUssVUFBVSxLQUFLLE1BQU0sR0FBSTtBQUFFO0FBQUE7QUFFaEMsVUFBTSxRQUFRLHdCQUFhLElBQUksT0FBakIsbUJBQXdCLE9BQXhCLFlBQStCO0FBQzdDLFVBQU0sU0FBUyx3QkFBYSxJQUFJLE9BQWpCLG1CQUF3QixPQUF4QixZQUErQjtBQUU5QyxRQUFLLFNBQVMsS0FBTTtBQUFFO0FBQUE7QUFFdEIsVUFBTSxZQUFjLFNBQVMsV0FBVyxNQUFRO0FBQ2hELGVBQVc7QUFDWCxVQUFNLFFBQVEsUUFBUSxNQUFNLE1BQU07QUFHbEMsUUFBSSxlQUFlLEtBQUssTUFBTyxLQUFLLElBQUssT0FBTztBQUNoRCxTQUFLLEtBQU0sWUFBWSxPQUFPO0FBQzlCLGFBQVM7QUFFVCxXQUFRLFNBQVMsR0FBSTtBQUNuQixxQkFBZSxLQUFLLE1BQU8sS0FBSyxJQUFLLE9BQU87QUFDNUMsV0FBSyxLQUFNLE9BQU87QUFDbEIsZUFBUztBQUFBO0FBQUE7QUFJYixTQUFPLElBQUksV0FBWTtBQUFBOzs7QUN2RGxCLHFCQUFlO0FBQUEsRUFHYixZQUFhLE1BQWdCO0FBQ2xDLFNBQUssT0FBTyxRQUFRO0FBQUE7QUFBQSxFQUdmLElBQUssTUFBd0I7QUFDbEMsUUFBSyxNQUFPO0FBQ1YsV0FBSyxPQUFPO0FBQUE7QUFHZCxTQUFLLE9BQU8sS0FBSyxPQUFTLEtBQUssUUFBUTtBQUN2QyxTQUFLLE9BQU8sS0FBSyxPQUFTLEtBQUssU0FBUztBQUN4QyxTQUFLLE9BQU8sS0FBSyxPQUFTLEtBQUssUUFBUTtBQUN2QyxXQUFPLEtBQUssT0FBTyxLQUFLLElBQUssR0FBRyxNQUFPO0FBQUE7QUFBQSxFQUdsQyxJQUFLLE1BQXNCO0FBQ2hDLFNBQUssT0FBTyxRQUFRLEtBQUssUUFBUTtBQUFBO0FBQUE7OztBQ1Y5QixzQkFBdUIsTUFBYyxPQUFlLGNBQWMsS0FBYztBQUNyRixNQUFLLFNBQVMsR0FBTTtBQUFFLFdBQU87QUFBQTtBQUM3QixNQUFLLFFBQVEsR0FBTTtBQUFFLFdBQU87QUFBQTtBQWU1QixRQUFNLGVBQWUsV0FBWSxHQUFLLElBQU0sYUFBYTtBQUN6RCxRQUFNLFdBQVcsV0FBWSxhQUFhLEdBQUs7QUFFL0MsUUFBTSxnQkFBZ0IsSUFBTSxLQUFLLE1BQU8sZUFBaUIsTUFBSyxTQUFTO0FBQ3ZFLFFBQU0sWUFBWSxRQUFRLGNBQWMsSUFBSSxJQUFNLEtBQUssTUFBTyxXQUFhLE1BQUssU0FBUztBQUN6RixRQUFNLGVBQWUsZ0JBQWdCO0FBRXJDLFFBQU0sWUFBWSxDQUFFLEdBQUcsTUFBTyxlQUMzQixJQUFLLE1BQU0sT0FBTyxhQUFjLEtBQUssS0FBSyxNQUFPLEtBQUssS0FBSyxZQUMzRCxLQUFNO0FBRVQsU0FBTyxLQUFLLFVBQVcsR0FBRyxhQUFjO0FBQUE7OztBQ3JDbkMsdUJBQW9CO0FBQUEsU0FLWCxrQkFBbUIsR0FBUSxHQUFpQjtBQUN4RCxVQUFNLE9BQU8sR0FBSTtBQUNqQixVQUFNLE9BQU8sR0FBSTtBQUVqQixRQUFLLE9BQU8sTUFBTztBQUNqQixhQUFPO0FBQUEsZUFDRyxPQUFPLE1BQU87QUFDeEIsYUFBTztBQUFBLFdBQ0Y7QUFDTCxhQUFPO0FBQUE7QUFBQTtBQUFBLE1BSUEsU0FBaUI7QUFDMUIsV0FBTyxLQUFLLE1BQU07QUFBQTtBQUFBLE1BR1QsVUFBbUI7QUFDNUIsV0FBTyxLQUFLLE1BQU0sV0FBVztBQUFBO0FBQUEsTUFHcEIsT0FBVTtBQUNuQixXQUFPLEtBQUssTUFBTztBQUFBO0FBQUEsRUFHZCxZQUFhLE1BQVksWUFBd0M7QUFDdEUsU0FBSyxRQUFRO0FBQ2IsU0FBSyxrQkFBa0Isb0JBQUk7QUFDM0IsU0FBSyxhQUFhLGtDQUFjLFdBQVc7QUFFM0MsUUFBSyxRQUFRLE1BQU87QUFDbEIsaUJBQVksTUFBTSxNQUFPO0FBQ3ZCLGFBQUssS0FBTTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS1YsUUFBUyxVQUFzQjtBQUNwQyxhQUFTLElBQUssQ0FBRSxPQUFRO0FBQ3RCLFlBQU0sSUFBSSxLQUFLO0FBQ2YsV0FBSyxNQUFNLEtBQU07QUFDakIsV0FBSyxnQkFBZ0IsSUFBSyxJQUFJO0FBQzlCLFdBQUssS0FBTSxHQUFHO0FBQUE7QUFBQTtBQUFBLEVBSVgsTUFBZ0I7QUFDckIsUUFBSyxLQUFLLFNBQVU7QUFDbEIsYUFBTztBQUFBO0FBR1QsVUFBTSxLQUFLLEtBQUssTUFBTztBQUN2QixTQUFLLGdCQUFnQixPQUFRO0FBRTdCLFFBQUssS0FBSyxXQUFXLEdBQUk7QUFDdkIsV0FBSyxNQUFNLE9BQVE7QUFBQSxXQUNkO0FBQ0wsWUFBTSxNQUFNLEtBQUssTUFBTTtBQUN2QixXQUFLLE9BQVEsR0FBRztBQUFBO0FBR2xCLFdBQU87QUFBQTtBQUFBLEVBR0YsT0FBUSxHQUFxQjtBQUNsQyxTQUFLLGdCQUFnQixPQUFRLEtBQUssTUFBTztBQUV6QyxVQUFNLE1BQU0sS0FBSyxNQUFNO0FBQ3ZCLFFBQUssT0FBTyxNQUFPO0FBQ2pCLFVBQUksS0FBSyxLQUFNLEdBQUc7QUFDbEIsVUFBSSxLQUFLLE9BQVEsR0FBRztBQUFBO0FBR3RCLFdBQU87QUFBQTtBQUFBLEVBR0YsUUFBUyxHQUFXLEtBQXdCO0FBQ2pELFFBQUssS0FBSyxNQUFPO0FBQ2YsV0FBSyxnQkFBZ0IsT0FBUSxLQUFLLE1BQU87QUFFekMsVUFBSSxLQUFLLEtBQU0sR0FBRztBQUNsQixVQUFJLEtBQUssT0FBUSxHQUFHO0FBQUE7QUFHdEIsV0FBTyxnQkFBSztBQUFBO0FBQUEsRUFHTixLQUFNLEdBQVcsSUFBZ0I7QUFDdkMsUUFBSSxLQUFLO0FBRVQsV0FBUSxPQUFPLEdBQUk7QUFDakIsWUFBTSxLQUFPLEtBQUssS0FBTztBQUV6QixZQUFNLElBQUksS0FBSyxNQUFPO0FBQ3RCLFVBQUssS0FBSyxXQUFZLElBQUksS0FBTSxHQUFJO0FBQ2xDLGFBQUssTUFBTyxNQUFPO0FBQ25CLGFBQUssZ0JBQWdCLElBQUssR0FBRztBQUM3QixhQUFLO0FBQUEsYUFDQTtBQUNMO0FBQUE7QUFBQTtBQUlKLFNBQUssTUFBTyxNQUFPO0FBQ25CLFNBQUssZ0JBQWdCLElBQUssSUFBSTtBQUM5QixXQUFPO0FBQUE7QUFBQSxFQUdELE9BQVEsR0FBVyxJQUFnQjtBQUN6QyxRQUFJLEtBQUs7QUFFVCxXQUFVLE9BQU0sS0FBTSxJQUFJLEtBQUssUUFBUztBQUN0QyxZQUFNLE1BQVEsT0FBTSxLQUFNO0FBQzFCLFlBQU0sTUFBUSxPQUFNLEtBQU07QUFFMUIsVUFBSyxNQUFNLEtBQUssUUFBUztBQUN2QixjQUFNLEtBQUssS0FBSyxNQUFPO0FBQ3ZCLGNBQU0sS0FBSyxLQUFLLE1BQU87QUFFdkIsY0FBTSxXQUFXLEtBQUssV0FBWSxJQUFJLE1BQU87QUFDN0MsY0FBTSxJQUFJLFdBQVcsS0FBSztBQUMxQixjQUFNLEtBQUssV0FBVyxNQUFNO0FBRTVCLFlBQUssS0FBSyxXQUFZLEdBQUcsTUFBTyxHQUFJO0FBQ2xDLGVBQUssTUFBTyxNQUFPO0FBQ25CLGVBQUssZ0JBQWdCLElBQUssR0FBRztBQUM3QixlQUFLO0FBQUEsZUFDQTtBQUNMO0FBQUE7QUFBQSxpQkFFUSxLQUFLLFdBQVksS0FBSyxNQUFPLE1BQU8sTUFBTyxHQUFJO0FBQ3pELGFBQUssTUFBTyxNQUFPLEtBQUssTUFBTztBQUMvQixhQUFLLGdCQUFnQixJQUFLLEtBQUssTUFBTyxLQUFNO0FBQzVDLGFBQUs7QUFBQSxhQUNBO0FBQ0w7QUFBQTtBQUFBO0FBSUosU0FBSyxNQUFPLE1BQU87QUFDbkIsU0FBSyxnQkFBZ0IsSUFBSyxJQUFJO0FBQzlCLFdBQU87QUFBQTtBQUFBOzs7QUMvSEoseUJBQTBCLFdBQTJDLE9BQW9CO0FBQzlGLGFBQVksWUFBWSxXQUFZO0FBQ2xDLGFBQVU7QUFBQTtBQUFBOzs7Ozs7Ozs7OztBQ25CeUI7QUFHaEMsU0FBUyxLQUFLLENBQUMsQ0FBUztJQUM5QixPQUFPLDJCQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNqQixDQUFDO0FBRU0sTUFBTSxHQUFHLEdBQVcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHO0FBQ2pDLE1BQU0sRUFBRSxHQUFXLElBQUksQ0FBQyxFQUFFO0FBQzFCLE1BQU0sTUFBTSxHQUFXLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQztBQUVsQyxTQUFTLEdBQUcsQ0FBQyxDQUFTLEVBQUUsQ0FBUztJQUN2QyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN0QixDQUFDO0FBQ00sU0FBUyxHQUFHLENBQUMsQ0FBUyxFQUFFLENBQVM7SUFDdkMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdEIsQ0FBQztBQUNNLFNBQVMsR0FBRyxDQUFDLENBQVMsRUFBRSxDQUFTLEVBQUUsQ0FBUztJQUNsRCxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztBQUM3QixDQUFDO0FBRU0sU0FBUyxHQUFHLENBQUMsQ0FBUztJQUM1QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUM7QUFDTSxTQUFTLElBQUksQ0FBQyxDQUFTO0lBQzdCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDcEIsQ0FBQztBQUVNLE1BQU0sSUFBSTtJQUNoQixJQUFJLEdBQUcsQ0FBQztJQUNSLFlBQVksSUFBSSxHQUFHLE9BQU87UUFDekIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJO0lBQ2pCLENBQUM7SUFDRCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQVM7UUFDbkIsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSztRQUNkLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNWLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNoQixDQUFDO0lBQ0QsR0FBRyxDQUFDLENBQVM7UUFDWixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDdEMsQ0FBQztJQUNELE1BQU0sQ0FBQyxDQUFDO1FBQ1AsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDO1FBQ3pCLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3BDLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUN6QyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxVQUFVO0lBQzdDLENBQUM7SUFFRCxVQUFVLENBQUMsQ0FBUztRQUNuQixNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLE1BQU0sS0FBSyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ3JCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1FBQzNCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO1FBQzdCLElBQUksRUFBRSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDakIsRUFBRSxHQUFHLGdCQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDekIsT0FBTyxVQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUM7SUFDOUIsQ0FBQztJQUVELGdCQUFnQixDQUFDLENBQVMsRUFBRSxVQUFrQjtRQUM3QyxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLE1BQU0sS0FBSyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ3JCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1FBQzNCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO1FBQzdCLElBQUksRUFBRSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDakIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNwQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUU7Z0JBQ25DLEVBQUUsR0FBRyxVQUFJLENBQUMsRUFBRSxFQUFFLGdCQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDO2dCQUNuRCxNQUFLO2FBQ0w7aUJBQU07Z0JBQ04sRUFBRSxHQUFHLGdCQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7YUFDekI7U0FDRDtRQUNELE9BQU8sVUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDO0lBQzlCLENBQUM7Q0FDRDtBQVlELE1BQU0sSUFBSSxHQUFHLGFBQWE7QUFFbkIsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFTLEVBQUUsRUFBRTtJQUNyQyxNQUFNLElBQUksR0FBRyxDQUFDLEdBQUcsR0FBRztJQUNwQixJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRTtRQUNqQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQztRQUMvQixPQUFPLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztLQUNwQjtTQUFNO1FBQ04sTUFBTSxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDO1FBQ3hCLE9BQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHO0tBQ3BCO0FBQ0YsQ0FBQztBQUVELE1BQU0sU0FBUyxHQUFHLENBQUMsQ0FBUyxFQUFFLEVBQUU7SUFDL0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ2pDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQzNCLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDdkIsQ0FBQztBQUNELE1BQU0sYUFBYSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDM0IsTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFTLEVBQUUsRUFBRTtJQUNwQyxDQUFDLElBQUksYUFBYTtJQUVsQixNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN4QixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7SUFFVCxJQUFJLElBQUksR0FBRyxDQUFDO0lBQ1osSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3JCLElBQUksR0FBRyxDQUFDLENBQUM7S0FDVDtJQUNELElBQUksRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDakIsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO0tBQ1Q7SUFDRCxJQUFJLE1BQU0sR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQ3pCLE1BQU0sSUFBSSxJQUFJO0lBQ2QsT0FBTyxNQUFNO0FBQ2QsQ0FBQztBQUVNLFNBQVMsUUFBUSxDQUFDLENBQVMsRUFBRSxDQUFTO0lBQzVDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUM3QixDQUFDO0FBRU0sU0FBUyxJQUFJLENBQUMsQ0FBUyxFQUFFLENBQVMsRUFBRSxJQUFhLENBQUM7SUFDeEQsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBRU0sU0FBUyxHQUFHLENBQUMsQ0FBUztJQUM1QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUM7QUFDTSxTQUFTLElBQUksQ0FBQyxDQUFTO0lBQzdCLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEIsQ0FBQztBQUVNLFNBQVMsR0FBRyxDQUFDLENBQVM7SUFDNUIsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzVCLE9BQU8sR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztBQUM3QixDQUFDO0FBRU0sU0FBUyxHQUFHLENBQUMsQ0FBUztJQUc1QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUM7QUFDTSxTQUFTLEdBQUcsQ0FBQyxDQUFTO0lBRTVCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbkIsQ0FBQztBQUNNLFNBQVMsS0FBSyxDQUFDLENBQVM7SUFDOUIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNyQixDQUFDO0FBQ00sU0FBUyxHQUFHLENBQUMsQ0FBUyxFQUFFLENBQVM7SUFDdkMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdEIsQ0FBQztBQUNNLFNBQVMsSUFBSSxDQUFDLENBQVM7SUFDN0IsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNwQixDQUFDO0FBQ00sU0FBUyxVQUFJLENBQUMsQ0FBUyxFQUFFLElBQVksRUFBRSxFQUFVO0lBQ3ZELE1BQU0sS0FBSyxHQUFHLEVBQUUsR0FBRyxJQUFJO0lBQ3ZCLENBQUMsSUFBSSxJQUFJO0lBQ1QsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDO0lBQ2pCLE9BQU8sSUFBSSxHQUFHLENBQUM7QUFDaEIsQ0FBQztBQUVNLE1BQU0sVUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ3pDLE1BQU0sV0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RELE1BQU0sY0FBUSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQztBQUN2RCxNQUFNLGdCQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsY0FBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzNELE1BQU0sZ0JBQVUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDckMsTUFBTSxDQUFDLEdBQUcsZ0JBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM3QixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUMvQixDQUFDO0FBRU0sU0FBUyxJQUFJO0lBQ25CLE9BQU8sSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNyQixDQUFDO0FBR0QsTUFBTSxJQUFJO0lBRVQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFTO1FBQ3RCLENBQUM7UUFBQSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRCxNQUFNLENBQUMsVUFBVSxDQUFDLENBQVM7UUFDMUIsT0FBTyxDQUFDLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRCxNQUFNLENBQUMsV0FBVyxDQUFDLENBQVM7UUFDM0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLENBQUM7SUFFRCxNQUFNLENBQUMsYUFBYSxDQUFDLENBQVM7UUFDN0IsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7SUFDbEQsQ0FBQztJQUVELE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBUztRQUMzQixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUNqQixDQUFDO0lBRUQsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFTO1FBQzVCLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLENBQVM7UUFDOUIsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQztJQUN6RSxDQUFDO0lBRUQsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFTO1FBQzNCLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUNyQixDQUFDO0lBRUQsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFTO1FBQzVCLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUMzQixDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFTO1FBQzlCLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7SUFDN0QsQ0FBQztJQUVELE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBUztRQUMzQixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO0lBQ3pCLENBQUM7SUFFRCxNQUFNLENBQUMsWUFBWSxDQUFDLENBQVM7UUFDNUIsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUMvQixDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFTO1FBQzlCLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUN2RSxDQUFDO0lBQ0QsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFTO1FBQzdCLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDO1FBRTVCLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDL0YsQ0FBQztJQUNELE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBUztRQUM5QixNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQztRQUM1QixPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO0lBQzdGLENBQUM7Q0FPRDtBQUVNLE1BQU0sS0FBSztJQUNqQixNQUFNLENBQUMsS0FBSyxDQUFDLENBQVM7UUFDckIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNwQixDQUFDO0lBQ0QsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFTO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQUNELE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDaEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNaLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNaLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1osT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1osT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDWixPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBQ0QsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ1YsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNmLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDZixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUNELE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDaEIsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2YsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDZixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDZixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2YsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNaLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuRixDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNqQixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFDRCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2pCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNqQixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNmLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNmLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFDRCxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNuQixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUM3QixDQUFDO0lBQ0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDckIsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlFLENBQUM7SUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNsQixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUM3QixDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDbEIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFBRSxD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QUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUU7UUFDdEIsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBQ0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUU7UUFDdkIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ2hCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNwRixDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUNoQixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDcEYsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDaEIsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BGLENBQUM7SUFDRCxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDZixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0UsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xGLENBQUM7Q0FDRDs7O0FDMVl5QztBQUNOO0FBQ0s7QUFFbEMsTUFBTSxPQUFPO0lBRW5CLEdBQUcsQ0FBYztJQUNqQixlQUFlLENBQVE7SUFDdkIsTUFBTSxDQUFRO0lBQ2QsSUFBSSxDQUFRO0lBQ1osR0FBRyxDQUFlO0lBRVYsUUFBUSxDQUFTO0lBQ3pCLFNBQVMsQ0FBUztJQUNWLFVBQVUsQ0FBUTtJQUUxQixZQUFZLEdBQWEsRUFBRSxrQkFBMEIsRUFBRSxDQUFDLElBQUksRUFBRSxTQUFTLEdBQUcsS0FBSyxFQUFFLGFBQXFCLENBQUM7UUFDdEcsTUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFNLEVBQUUsQ0FBUSxFQUFXLEVBQUU7WUFDNUMsSUFBSSxFQUFFLEdBQUcsS0FBSztZQUNkLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtnQkFDZixJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQ1osRUFBRSxHQUFHLElBQUk7aUJBRVQ7WUFDRixDQUFDLENBQUM7WUFDRixPQUFPLEVBQUU7UUFDVixDQUFDO1FBQ0QsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQyxlQUFlLEdBQUcsZUFBZTtRQUV0QyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVM7UUFDMUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVO1FBRTVCLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV2RixJQUFJLFFBQVEsR0FBRyxDQUFDO1FBQ2hCLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7WUFDM0gsUUFBUSxHQUFHLENBQUM7U0FDWjtRQUNELElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7WUFDbkgsUUFBUSxHQUFHLENBQUM7U0FDWjtRQUVELElBQUksQ0FBQyxNQUFNLEdBQUcsUUFBUSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUc7UUFDL0MsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsYUFBYTtRQUV2RCxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7WUFDdkcsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsWUFBWTtTQUMzQjtRQUNELElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRTtZQUNqRyxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxHQUFHO1NBQ2xCO1FBQ0QsSUFBSSxDQUFDLFFBQVEsRUFBRTtJQUNoQixDQUFDO0lBQ0QsUUFBUTtRQUVQLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLGFBQWEsRUFBRTtRQUU3QixFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUV2QyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDbEIsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDO1lBQ2xFLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQztTQUNsRTthQUFNO1lBQ04sRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDO1lBQ2pFLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQztTQUNqRTtRQUNELEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUM7UUFDcEUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQztRQUVwRSxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLENBQUMsRUFBRTtnQkFDMUIsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRTtvQkFDdkMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLENBQUMsb0JBQW9CLENBQUM7b0JBQy9FLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQztvQkFDakUsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDbkg7cUJBQU07b0JBQ04sRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztpQkFDaEg7YUFDRDtZQUNELGlCQUFpQixFQUFFO1NBQ25CO2FBQU07WUFDTixFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO1NBQ2hIO1FBR0QsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzVCLE9BQU8sQ0FBQyxLQUFLLENBQUMsb0JBQW9CLENBQUM7U0FDbkM7SUFDRixDQUFDO0lBRUQsTUFBTSxDQUFDLE9BQWlCO1FBQ3ZCLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1lBQzFCLElBQUksQ0FBQyxRQUFRLEVBQUU7U0FDZjthQUFNO1lBQ04sRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDO1lBQzlCLEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7U0FDaEg7SUFDRixDQUFDO0lBQ0QsTUFBTSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsUUFBZ0I7UUFDNUMsU0FBUyxTQUFTLENBQUMsR0FBVztZQUM3QixPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQzlCLE1BQU0sS0FBSyxHQUFHLElBQUksS0FBSyxFQUFFO2dCQUN6QixLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRTtvQkFDbkMsT0FBTyxDQUFDLEtBQUssQ0FBQztnQkFDZixDQUFDLENBQUM7Z0JBQ0YsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHO1lBQ2hCLENBQUMsQ0FBQztRQUNILENBQUM7UUFFRCxNQUFNLEdBQUcsR0FBRyxNQUFNLFNBQVMsQ0FBQyxRQUFRLENBQUM7UUFDckMsTUFBTSxHQUFHLEdBQUcsSUFBSSxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLEdBQUcsQ0FBQyxhQUFhLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFHakYsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDO1FBQzNGLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQztRQUNoQyxpQkFBaUIsRUFBRTtRQUVuQixFQUFFLENBQUMsTUFBTSxFQUFFO1FBQ1gsR0FBRyxDQUFDLE1BQU0sRUFBRTtRQUNaLE9BQU8sR0FBRztJQUNYLENBQUM7SUFFRCxlQUFlLENBQUMsS0FBaUQ7UUFDaEUsSUFBSSxLQUFLLFlBQVksZ0JBQWdCLEVBQUU7WUFDdEMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQztTQUNqSDthQUFNO1lBQ04sUUFBUTtTQUNSO0lBQ0YsQ0FBQztJQUVELEtBQUs7UUFDSixPQUFPLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDcEYsQ0FBQztJQUNELFlBQVksQ0FBQyxJQUFZO1FBQ3hCLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDcEMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDeEMsQ0FBQztJQUVELGVBQWUsQ0FBQyxPQUFpQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxnQkFBMEIsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDL0UsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixFQUFzQjtRQUN4RCxJQUFJLGFBQWEsR0FBRyxXQUFXLENBQUMsZUFBZTtRQUMvQyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDO1FBQzNDLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBSXpGLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRO1lBQ3pCLENBQUMsQ0FBQyxJQUFJLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMzRCxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDMUQsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztRQUVqRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDO1FBQzdCLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxhQUFhLENBQUMsRUFBRSxDQUFDO1FBQ3BELE9BQU8sSUFBSTtJQUNaLENBQUM7SUFDRCxlQUFlLENBQUMsSUFBYztRQUM3QixJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM3QyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDbEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3hCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHO1lBQ1osQ0FBQyxDQUFDO1NBQ0Y7UUFDRCxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRztRQUViLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDeEIsQ0FBQztJQUNELEtBQUssQ0FBQyxlQUFlLENBQ3BCLGdCQUF5QixLQUFLLEVBQzlCLE9BQWlCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUN2QixnQkFBMEIsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFFdkMsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDO1FBRXBELElBQUksQ0FBQyxHQUFHLENBQUM7UUFDVCxJQUFJLEdBQUcsR0FBRyxDQUFDO1FBQ1gsS0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUU7WUFDdkIsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUNaLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtvQkFDbEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUc7aUJBQ2Y7cUJBQU07b0JBQ04sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUc7aUJBQ2Y7Z0JBQ0QsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNOO2lCQUFNO2dCQUNOLElBQUksYUFBYSxFQUFFO29CQUNsQixJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7d0JBQ2xCLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxZQUFZLENBQUM7cUJBQzlDO3lCQUFNO3dCQUNOLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEVBQUUsWUFBWSxDQUFDO3FCQUNwRDtpQkFDRDthQUVEO1lBQ0QsR0FBRyxFQUFFO1lBQ0wsQ0FBQyxFQUFFO1NBQ0g7UUFHRCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQztRQUMvQyxNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzFCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDM0IsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQTZCO1FBRW5FLElBQUksSUFBVTtRQUVkLE1BQU0sYUFBYSxHQUFHLENBQUMsTUFBeUIsRUFBaUIsRUFBRTtZQUNsRSxPQUFPLElBQUksT0FBTyxDQUFDLFVBQVUsT0FBTyxFQUFFLE1BQU07Z0JBQzNDLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJO29CQUUzQixPQUFPLENBQUMsSUFBSSxDQUFDO2dCQUNkLENBQUMsRUFBRSxXQUFXLENBQUM7WUFDaEIsQ0FBQyxDQUFDO1FBQ0gsQ0FBQztRQUVELElBQUksR0FBRyxNQUFNLGFBQWEsQ0FBQyxNQUFNLENBQUM7UUFDbEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7UUFDdkIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFXakIsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDdEUsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO1FBQ3hCLE9BQU8sQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDckMsTUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFLLEVBQUU7UUFDdkIsR0FBRyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsU0FBUyxFQUFFO1FBRTVCLE1BQU0sQ0FBQyxNQUFNLEVBQUU7UUFFZixPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQztJQUNuQixDQUFDO0NBQ0Q7OztBQ2pQZ0M7QUFFMUIsTUFBTSxXQUFXO0lBQ3ZCLE1BQU0sQ0FBQyxlQUFlLENBQWE7SUFDbkMsTUFBTSxDQUFDLFlBQVksR0FBa0IsRUFBRTtJQUN2QyxTQUFTLENBQWdCO0lBQ3pCLGNBQWMsQ0FBZ0I7SUFDdEIsR0FBRyxDQUFrQjtJQUVyQixRQUFRLEdBQXFCLFNBQVM7SUFDOUMsT0FBTyxHQUFZLEtBQUs7SUFDeEIsUUFBUSxHQUFZLEtBQUs7SUFDekIsVUFBVSxHQUFZLEtBQUs7SUFDM0IsUUFBUSxHQUFXLENBQUM7SUFFcEIsSUFBVyxRQUFRO1FBQ2xCLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxDQUFDO1lBQUUsT0FBTyxJQUFJLENBQUMsU0FBUzs7WUFDekMsT0FBTyxJQUFJLENBQUMsY0FBYztJQUNoQyxDQUFDO0lBQ0QsSUFBVyxhQUFhO1FBQ3ZCLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxDQUFDO1lBQUUsT0FBTyxJQUFJLENBQUMsY0FBYzs7WUFDOUMsT0FBTyxJQUFJLENBQUMsU0FBUztJQUMzQixDQUFDO0lBRUQsSUFBVyxFQUFFO1FBQ1osSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLENBQUM7WUFBRSxPQUFPLElBQUksQ0FBQyxHQUFHOztZQUNuQyxPQUFPLElBQUksQ0FBQyxRQUFRO0lBQzFCLENBQUM7SUFDRCxJQUFXLE9BQU87UUFDakIsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLENBQUM7WUFBRSxPQUFPLElBQUksQ0FBQyxRQUFROztZQUN4QyxPQUFPLElBQUksQ0FBQyxHQUFHO0lBQ3JCLENBQUM7SUFFTSxJQUFJO1FBQ1YsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVE7UUFDakMsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLO0lBQ3hCLENBQUM7SUFFTSxRQUFRO1FBQ2QsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2xCLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDO1lBRWpELElBQUksQ0FBQyxHQUFHLENBQUM7WUFDVCxLQUFLLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ3BDLEVBQUUsQ0FBQyxvQkFBb0IsQ0FDdEIsRUFBRSxDQUFDLFdBQVcsRUFDZCxFQUFFLENBQUMsaUJBQWlCLEdBQUcsQ0FBQyxFQUN4QixFQUFFLENBQUMsVUFBVSxFQUNiLEdBQUcsQ0FBQyxHQUFHLEVBQ1AsQ0FBQyxDQUNEO2FBQ0Q7WUFFRCxJQUFJLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDLG9CQUFvQixFQUFFO2dCQUMxRSxPQUFPLENBQUMsS0FBSyxDQUFDLHdCQUF3QixDQUFDO2FBQ3ZDO1NBQ0Q7UUFFRCxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUU1QyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ1QsS0FBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQy9CLEVBQUUsQ0FBQyxvQkFBb0IsQ0FDdEIsRUFBRSxDQUFDLFdBQVcsRUFDZCxFQUFFLENBQUMsaUJBQWlCLEdBQUcsQ0FBQyxFQUN4QixFQUFFLENBQUMsVUFBVSxFQUNiLEdBQUcsQ0FBQyxHQUFHLEVBQ1AsQ0FBQyxDQUNEO1lBQ0QsQ0FBQyxFQUFFO1NBQ0g7UUFFRCxJQUFJLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDLG9CQUFvQixFQUFFO1lBQzFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsd0JBQXdCLENBQUM7U0FDdkM7SUFDRixDQUFDO0lBQ0QsWUFBWSxRQUF3QixFQUFFLFdBQW9CLEtBQUs7UUFDOUQsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsaUJBQWlCLEVBQXNCO1FBQ3JELElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQztRQUM5QixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVE7UUFDeEIsSUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFO1FBRXhCLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNsQixJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsRUFBc0I7WUFDMUQsS0FBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUM5QixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDckM7U0FDRDtRQUVELElBQUksQ0FBQyxRQUFRLEVBQUU7UUFHZixFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUM7UUFDbkUsV0FBVyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3BDLENBQUM7SUFDRCxJQUFJO1FBQ0gsSUFBSSxJQUFJLENBQUMsUUFBUTtZQUFFLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSTtRQUN6QyxJQUFJLFVBQVUsR0FBYSxFQUFFO1FBRTdCLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNqQixVQUFVLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDO1NBQ3RCO2FBQU07WUFDTixJQUFJLENBQUMsR0FBRyxDQUFDO1lBQ1QsS0FBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUM5QixVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLENBQUM7Z0JBQ3pDLENBQUMsRUFBRTthQUNIO1NBQ0Q7UUFFRCxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkUsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDM0MsV0FBVyxDQUFDLGVBQWUsR0FBRyxJQUFJO0lBRW5DLENBQUM7SUFDRCxLQUFLLENBQUMsU0FBbUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFcEMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDM0MsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekQsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUM7UUFFN0IsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDO0lBQ25FLENBQUM7Ozs7QUN6SHdDO0FBQ1I7QUFFM0IsU0FBUyxzQkFBc0I7SUFDckMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZO1FBQUUsT0FBTTtJQUM1QixFQUFFLENBQUMsT0FBTyxHQUFHLEVBQUU7SUFDZixFQUFFLENBQUMsaUJBQWlCLEdBQUcsRUFBRTtJQUN6QixLQUFLLElBQUksWUFBWSxJQUFJLEVBQUUsRUFBRTtRQUM1QixJQUFJLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUN6QyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLFlBQVk7WUFDM0MsRUFBRSxDQUFDLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUM7U0FDckQ7S0FDRDtBQUNGLENBQUM7QUFFTSxTQUFTLGlCQUFpQixDQUFDLEtBQUs7SUFFdEMsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO0lBQ3JDLE9BQU8sSUFBSSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsMkJBQTJCLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFO0FBQ2pHLENBQUM7QUFDTSxTQUFTLGlCQUFpQjtJQUNoQyxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVk7UUFBRSxPQUFNO0lBQzVCLElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFO0lBQzlCLElBQUksR0FBRyxLQUFLLENBQUMsRUFBRTtRQUNkLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ2xCLE9BQU8sQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDckM7QUFDRixDQUFDO0FBQ00sU0FBUyxpQkFBaUI7SUFDaEMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZO1FBQUUsT0FBTTtJQUM1QixJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRTtJQUM5QixJQUFJLEdBQUcsS0FBSyxDQUFDLEVBQUU7UUFDZCxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUNsQixPQUFPLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3JDLFFBQVE7S0FDUjtBQUNGLENBQUM7QUFFTSxTQUFTLGtCQUFrQixDQUFDLGNBQWdDLEVBQUUsV0FBb0I7SUFDeEYsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLGNBQWMsQ0FBQztJQUNsRCxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsV0FBVyxDQUFDLEdBQUcsQ0FBQztJQUM5QyxFQUFFLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2xILENBQUM7QUFDTSxTQUFTLGFBQWEsQ0FBQyxjQUFnQyxFQUFFLGVBQWlDLEVBQUUsR0FBYTtJQUMvRyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUM7SUFDdkQsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsZUFBZSxDQUFDO0lBQ3hELEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQztBQUloRyxDQUFDO0FBRU0sU0FBUyxjQUFjLENBQzdCLE1BQXlCLEVBQ3pCLG1CQUFnQyxFQUNoQyxVQUFvQixFQUNwQixpQkFBdUMsRUFDdkMsbUJBQTZCO0lBRTdCLE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxXQUFXO0lBQ3ZDLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxZQUFZO0lBRXpDLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxLQUFLLEtBQUssWUFBWSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssYUFBYTtJQUVuRixJQUFJLFVBQVUsRUFBRTtRQUNmLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxHQUFHLFlBQVk7UUFDM0MsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsYUFBYTtRQUk3QyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM7UUFFdkIsbUJBQW1CLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsVUFBVSxDQUFDO1FBQ3RELG1CQUFtQixFQUFFO0tBQ3JCO0lBRUQsT0FBTyxVQUFVO0FBQ2xCLENBQUM7Ozs7Ozs7QUMxRStCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VEQVFWLEdBQU0sTUFBRyxnQkFBZ0IsR0FBRyxFQUFFOzs7Ozs7OztHQUFwRCxVQUVLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkZBRmlCLEdBQU0sTUFBRyxnQkFBZ0IsR0FBRyxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FMdkMsTUFBTSxHQUFZO09BQ2xCLElBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0pRO0FBQ2U7QUFDWjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBb0Z4QixHQUFLOzs7Ozs7Ozs7Ozs7Ozs7OERBWnlDLEdBQVE7Ozs7MkVBUzFDLEdBQVksTUFBRyxhQUFhLEdBQUcsRUFBRTtzRUFFdEMsR0FBVyxPQUFJLG1EQUFtRCxxQkFBRyxHQUFLLE9BQUksa0JBQWtCOzs7Ozs7Ozs7O0dBYjdHLFVBZUs7R0FkSCxVQVFLO0dBUEgsVUFNSztHQUxILFVBSUs7R0FISCxVQUVHO0dBREQsVUFBMkM7O0dBS25ELFVBSWU7Ozs7OzhEQVp1RSxHQUFXOzs7Ozs7K0RBQS9DLEdBQVE7Ozt1REFZdEQsR0FBSzs7MkdBSE8sR0FBWSxNQUFHLGFBQWEsR0FBRyxFQUFFOzs7OzRHQUV0QyxHQUFXLE9BQUksbURBQW1ELHFCQUFHLEdBQUssT0FBSSxrQkFBa0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0EvRG5HLGlCQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHO1FBQ3BCLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUc7Ozs7Ozs7T0FuQjVCO09BRUMsWUFBWSxHQUEyQztPQUN2RCxLQUFLLEdBQTBCO0tBQ3RDLFdBQWE7T0FFTixXQUFXLEdBQUc7T0FDZCxLQUFLLEdBQUcsRUFBQztPQUVmLFFBQVEsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJO0tBRS9CLE1BQU0sR0FBRztLQUNSLE1BQU0sR0FBRyxDQUFDO0tBQ1YsVUFBVSxHQUFHOztVQVNULFdBQVcsR0FBRyxPQUFPLEVBQUUsT0FBTztNQUNsQyxLQUFLLEdBQUcsRUFBRSxHQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsZUFBZSxDQUFDLFlBQVk7TUFFMUYsU0FBUyxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksS0FBSztFQUMxQyxTQUFTLEtBQUssTUFBTSxHQUFHLE9BQU8sSUFBRyxLQUFLO2tCQUN0QyxLQUFLLEdBQUcsaUJBQUssQ0FBQyxVQUFVLEdBQUcsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDOzs7VUFHbEMsV0FBVyxDQUFDLENBQWU7UUFDM0IsT0FBTyxFQUFFLE9BQU8sS0FBSztFQUM3QixNQUFNLEdBQUcsT0FBTztFQUNoQixNQUFNLEdBQUcsT0FBTztFQUNoQixVQUFVLEdBQUcsS0FBSztFQUVsQixNQUFNLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLFdBQVc7RUFDbEQsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxTQUFTO0VBQzVDLENBQUMsQ0FBQyxlQUFlOzs7VUFHWCxTQUFTO0VBQ2pCLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxhQUFhLEVBQUUsV0FBVztFQUNyRCxNQUFNLENBQUMsbUJBQW1CLENBQUMsV0FBVyxFQUFFLFNBQVM7OztLQUc3Qzs7Q0FFSixPQUFPO01BQ0Q7O01BQ0EsU0FBUztPQUNSLEtBQUs7SUFDTixZQUFZLEdBQUcsS0FBSztvQkFDcEIsV0FBVyxHQUFHLEtBQUssQ0FBQyxNQUFVOzs7R0FHaEMsWUFBWSxDQUFDLG1CQUFtQixDQUFFLGFBQWEsRUFBRSxXQUFXOzs7RUFFOUQsV0FBVztHQUNULFlBQVksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsU0FBUztHQUN2RCxZQUFZLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLFNBQVM7OztFQUV0RCxZQUFZLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLFdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0I3QyxZQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbEUxQixDQUFDLGtCQUFFLFFBQVEsSUFBSSxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksR0FBSSxLQUFLLEdBQUksUUFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNFSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29EQXJCWSxHQUFROzs7Ozs7O0dBQW5FLFVBaUJLO0dBaEJKLFVBZUs7R0FkSixVQWFLO29CQVBHLGdCQUFhOzs7OERBUjhELEdBQVc7Ozs7OztxREFBckMsR0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0F5Q3pELDRCQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHO1FBQ3BCLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUc7Ozs7Ozs7T0FuQjVCLFFBQVEsSUFBYyxHQUFHLEVBQUUsR0FBRztPQUc5QixVQUFVLEdBQUc7S0FDcEIsS0FBSyxJQUFJLENBQUMsRUFBRSxDQUFDO0tBQ2IsR0FBRyxHQUFHO0tBQ04sR0FBRyxHQUFHO09BRUMsUUFBUSxHQUFZO09BQ3BCLGdCQUFnQixHQUFZO0tBRW5DLE1BQU0sR0FBRyxDQUFDLEVBQ2IsVUFBVSxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQ2xCLE1BQU0sR0FBRzs7VUFTRCxXQUFXLEdBQUUsT0FBTyxFQUFFLE9BQU87TUFDakMsVUFBVSxHQUFJLFVBQVUsSUFBSSxNQUFNLEdBQUcsT0FBTyxJQUFLO01BQ2pELFVBQVUsR0FBSSxVQUFVLElBQUksTUFBTSxHQUFHLE9BQU8sSUFBSztrQkFDckQsUUFBUSxDQUFDLENBQUMsSUFBSSw0QkFBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksVUFBVSxFQUFFLEdBQUcsRUFBRSxHQUFHO2tCQUN4RCxRQUFRLENBQUMsQ0FBQyxJQUFJLDRCQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxVQUFVLEVBQUUsR0FBRyxFQUFFLEdBQUc7OztVQUdoRCxXQUFXLENBQUMsQ0FBZTtrQkFDbkMsUUFBUSxHQUFHO1FBQ04sT0FBTyxFQUFFLE9BQU8sS0FBSTtFQUV6QixPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU07RUFDbEIsTUFBTSxHQUFHO0VBQ1QsTUFBTSxHQUFHO0VBQ1QsVUFBVSxPQUFPLFFBQVE7RUFFekIsTUFBTSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxXQUFXO0VBQ2xELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsU0FBUztFQUM5QyxDQUFDLENBQUMsZUFBZTs7O1VBR1QsU0FBUztrQkFDakIsUUFBUSxHQUFHO2tCQUNYLGdCQUFnQixHQUFHO0VBQ25CLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSTtFQUNoQixNQUFNLENBQUMsbUJBQW1CLENBQUMsYUFBYSxFQUFFLFdBQVc7RUFDckQsTUFBTSxDQUFDLG1CQUFtQixDQUFDLFdBQVcsRUFBRSxTQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWpDbEQsQ0FBQyxFQUFFLFVBQVUsR0FBRyxHQUFHLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Q2lCO0FBQ047QUFDVDtBQUVsQixTQUFTLE1BQU0sQ0FBQyxDQUFVO0lBQ2hDLElBQUksQ0FBQyxDQUFDO1FBQUUsUUFBUTtBQUNqQixDQUFDO0FBRU0sTUFBTSxZQUFZO0lBRXhCLE9BQU8sR0FBWSxTQUFTO0lBRTVCLElBQUksR0FBVyxTQUFTO0lBRXhCLEdBQUcsQ0FBUTtJQUVYLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxHQUFXO1FBQ3BDLElBQUksT0FBTyxHQUFHLE1BQU0sT0FBTyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUM7UUFFakQsT0FBTztZQUNOLE9BQU87WUFDUCxJQUFJO1lBQ0osR0FBRztTQUNIO0lBQ0YsQ0FBQztDQUNEO0FBRU0sTUFBTSxPQUFPO0lBQ25CLEVBQUUsR0FBVyxJQUFJLENBQUMsR0FBRyxFQUFFO0lBQ3ZCLEtBQUssR0FBWSxLQUFLO0lBQ3RCLGFBQWEsR0FBa0IsRUFBRTtJQUNqQyxTQUFTLEdBQWEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0lBRWxDLGdCQUFlLENBQUM7SUFDaEIsV0FBVyxDQUFDLE1BQW1CO1FBQzlCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNoQyxDQUFDO0NBQ0Q7QUFFTSxNQUFNLEtBQUs7SUFDakIsTUFBTSxDQUFDLFVBQVUsR0FBRyxHQUFZLEVBQUU7UUFDakMsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUNoQjtRQUFBLENBQUMsVUFBVSxDQUFDO1lBQ1osSUFDQyxxVkFBcVYsQ0FBQyxJQUFJLENBQ3pWLENBQUMsQ0FDRDtnQkFDRCx5a0RBQXlrRCxDQUFDLElBQUksQ0FDN2tELENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUNkO2dCQUVELEtBQUssR0FBRyxJQUFJO1FBRWQsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFNBQVMsSUFBSSxTQUFTLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDM0QsT0FBTyxLQUFLO0lBQ2IsQ0FBQztJQUNELE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBVyxFQUFFLFVBQW1CLEtBQUssRUFBRSxTQUFrQixLQUFLO1FBQ2xGLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxnQkFBZ0I7UUFDbEUsSUFBSSxDQUFDLE1BQU07WUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNyQixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUM7UUFDeEIsQ0FBQyxDQUFDO1FBQ0YsT0FBTyxDQUFDO0lBQ1QsQ0FBQztJQUNELE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBVyxFQUFFLFNBQW1CLEVBQUUsT0FBaUI7UUFDckUsSUFBSSxRQUFRLEdBQUcsU0FBUztRQUN4QixJQUFJLFVBQVUsR0FBRyxPQUFPO1FBRXhCLElBQUksV0FBVyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQzNDLElBQUksU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQzdDLElBQUksS0FBSyxHQUFHLFdBQVcsR0FBRyxTQUFTO1FBRW5DLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtZQUNkLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMzQjthQUFNO1lBQ04sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQzNCO0lBQ0YsQ0FBQztJQUNELE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFXLEVBQUUsUUFBaUIsRUFBRSxVQUFtQixFQUFFLElBQVksRUFBRSxHQUFhO1FBQy9HLElBQUksUUFBUSxHQUFHLFFBQVEsQ0FBQyxHQUFHO1FBQzNCLElBQUksVUFBVSxHQUFHLFVBQVUsQ0FBQyxHQUFHO1FBRS9CLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRVYsSUFBSSxXQUFXLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDM0MsSUFBSSxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDN0MsSUFBSSxLQUFLLEdBQUcsV0FBVyxHQUFHLFNBQVM7UUFFbkMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFO1lBQ2QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssR0FBRyxJQUFJO1lBQ3BCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJO1lBRVosSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUsVUFBVSxDQUFDO1lBRTFELENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDeEI7YUFBTTtZQUVOLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJO1lBQ1osQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssR0FBRyxJQUFJO1lBRXBCLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsUUFBUSxFQUFFLFVBQVUsQ0FBQztZQUUxRCxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ3hCO1FBQ0QsT0FBTyxDQUFDO0lBQ1QsQ0FBQztJQUNELE1BQU0sQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFXLEVBQUUsR0FBWTtRQUNuRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUUsQ0FBQzs7OztBQzlHZ0M7QUFFbEMsSUFBWSxtQkFJWDtBQUpELFdBQVksbUJBQW1CO0lBQzlCLDJEQUFHO0lBQ0gsK0RBQUs7SUFDTCxxRUFBUTtBQUNULENBQUMsRUFKVyxtQkFBbUIsS0FBbkIsbUJBQW1CLFFBSTlCO0FBRU0sTUFBTSxVQUFVO0lBQ3RCLFlBQVksR0FBVyxHQUFHO0lBQzFCLGdCQUFnQixHQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUM7SUFDeEMsV0FBVyxHQUFhLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztJQUNoQyxxQkFBcUIsR0FBRyxtQkFBbUIsQ0FBQyxRQUFRO0lBQ3BELFlBQ0MsWUFBb0IsRUFDcEIsZ0JBQTBCLEVBQzFCLFdBQXFCLEVBQ3JCLHFCQUEwQztRQUUxQyxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVk7UUFDaEMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQztRQUM3QyxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsR0FBRyxXQUFXLENBQUM7UUFDbkMsSUFBSSxDQUFDLHFCQUFxQixHQUFHLHFCQUFxQjtJQUNuRCxDQUFDO0NBQ0Q7QUFFTSxNQUFNLFdBQVc7SUFDdkIsbUJBQW1CLEdBQWMsU0FBUyxDQUFDLEtBQUs7SUFFaEQsU0FBUyxHQUFrQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3BDLFdBQVcsR0FBVyxHQUFHO0lBQ3pCLEtBQUssR0FBVyxHQUFHO0lBRW5CLFFBQVEsR0FBVyxHQUFHO0lBQ3RCLHVCQUF1QixHQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUMxQyxvQkFBb0IsR0FBYSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDekMsVUFBVSxHQUFXLENBQUM7SUFDdEIsVUFBVSxHQUFXLENBQUM7SUFHdEIsc0JBQXNCLEdBQWlCLFNBQVM7SUFFaEQsWUFBWSxHQUFXLEdBQUc7SUFDMUIsZ0JBQWdCLEdBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQztJQUN6QyxXQUFXLEdBQWEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0lBRWhDLGdCQUFlLENBQUM7Q0FDaEI7QUFFRCxJQUFZLFNBSVg7QUFKRCxXQUFZLFNBQVM7SUFDcEIsMkNBQUs7SUFDTCx5Q0FBSTtJQUNKLHVDQUFHO0FBQ0osQ0FBQyxFQUpXLFNBQVMsS0FBVCxTQUFTLFFBSXBCO0FBQ00sTUFBTSxXQUFXO0lBQ3ZCLFVBQVUsQ0FBVztJQUNyQixhQUFhLENBQWM7SUFDM0IsV0FBVyxDQUFZO0lBQ3ZCLFNBQVMsR0FBYSxFQUFFO0lBQ3hCLFNBQVMsR0FBYSxFQUFFO0lBQ3hCLEtBQUssR0FBYSxFQUFFO0lBQ3BCLFNBQVMsR0FBYSxFQUFFO0lBQ3hCLE9BQU8sR0FBYSxFQUFFO0lBRXRCLEdBQUcsR0FBVyxDQUFDO0lBQ2YsWUFBWSxVQUFxQixFQUFFLFdBQXVCLEVBQUUsYUFBMkI7UUFDdEYsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXO1FBQzlCLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVTtRQUM1QixJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWE7SUFDbkMsQ0FBQztJQUNELFdBQVcsQ0FBQyxRQUFrQixFQUFFLFFBQWtCLEVBQUUsSUFBYyxFQUFFLE9BQWUsRUFBRSxNQUFnQjtRQUlwRyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRztRQUN6QixJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDO1FBQzFCLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxJQUFJLENBQUM7UUFDMUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQztRQUN0QixJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDO1FBQzFCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxJQUFJLENBQUM7UUFDeEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUMxQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxPQUFPO1FBQ2xDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFD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QyxDQUFDO0FBQ2I7QUFDRjs7UUFHRCxLQUFLLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzVCLGtCQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQ3RELGFBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLElBQUksVUFBVSxDQUFDO0FBQzdDO1FBRUQsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQzs7UUFHVCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzNCLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRTtnQkFDVixJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUU7QUFDVixxQkFBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3RCLENBQUMsR0FBRyxVQUFVLENBQUM7QUFDaEI7QUFBTTtB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QUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1lBSXBELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1lBSXBELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDdEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDdEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1lBSXBELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1lBSXBELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDdEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDdEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1lBSXBELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1NBQ3BEO1FBQ0QsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDO1FBQ3pDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFB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LENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNO1lBQzVDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsWUFBWTtZQUlwRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ3RELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ3RELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNO1lBQzVDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsWUFBWTtZQUtwRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNO1lBQzVDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsWUFBWTtZQUlwRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ3RELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ3RELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNO1lBQzVDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsWUFBWTtZQUlwRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNO1lBQzVDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsWUFBWTtTQUNwRDtRQUNELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQztRQUN6QyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUM7UUFDekMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDNUQsQ0FBQztJQUNELGdDQUFnQyxDQUFDLE1BQW1CO1FBQ25ELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZO1FBQ3RDLE1BQU0sRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBQyxHQUFHLE1BQU07UUFJOUMsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQztRQUN0QyxJQUFJLEdBQUcsR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDbEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMvQixJQUFJLENBQUMsR0FBRyxDQUFDO1lBQ1QsSUFBSSxDQUFDLEdBQUcsQ0FBQztZQVdULFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2xELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2xELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDckQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2xELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBV3BELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3RELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzFELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzFELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDckQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDMUQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztZQUN2QyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFVcEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzFELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzFELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMxRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMxRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDM0QsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDMUQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztZQUN2QyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3hEO1FBQ0QsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksS0FBSyxH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Ozs7Ozs7MEJBQ3hCLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztHQUF4QixVQUFVLENBQUMsV0FBVyxDQUFDLENBQUM7Ozs7OzswQkFDeEIsVUFBVSxDQUFDLGdCQUFnQixDQUFDLENBQUM7R0FBN0IsVUFBVSxDQUFDLGdCQUFnQixDQUFDLENBQUM7Ozs7OzswQkFDN0IsVUFBVSxDQUFDLGdCQUFnQixDQUFDLENBQUM7R0FBN0IsVUFBVSxDQUFDLGdCQUFnQixDQUFDLENBQUM7Ozs7OzswQkFDN0IsVUFBVSxDQUFDLGdCQUFnQixDQUFDLENBQUM7R0FBN0IsVUFBVSxDQUFDLGdCQUFnQixDQUFDLENBQUM7Ozs7OztFQUNYLGNBQWM7Ozs7OzBCQUErQixVQUFVLENBQUMsc0JBQXNCO0dBQWpDLFVBQVUsQ0FBQyxzQkFBc0I7Ozs7Ozs7R0FON0Ysb0JBQW9COzs7Ozs7O0dBU1osYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hGRDtBQUNoQjtBQUVhO0FBRXpDLE1BQU0sR0FBRyxHQUFHLElBQUksVUFBRyxDQUFDO0lBQ25CLE1BQU0sRUFBRSxRQUFRLENBQUMsSUFBSTtJQUNyQixLQUFLLEVBQUUsRUFBRTtDQUNULENBQUM7QUFFRiwwQ0FBZSxtREFBRyIsInNvdXJjZXMiOlsid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvc3R5bGUuY3NzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL2Ryb3Bib3gvZGlzdC9Ecm9wYm94LXNkay5taW4uanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9lYXJjdXQvc3JjL2VhcmN1dC5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL2xpYnRlc3MvbGlidGVzcy5taW4uanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2JydXNoLWJsb2JzLnN2ZyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2JydXNoLWxvbmcuc3ZnIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvYnJ1c2gtdHJpYW5nbGVzLnN2ZyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2NhcHR1cmUuc3ZnIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvY29weS5zdmciLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9kb3dubG9hZC5zdmciLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9mb3JiaWQuc3ZnIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvbGF1bmNoLnN2ZyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL29rLnN2ZyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL3BsdWcuc3ZnIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvcmVkby5zdmciLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9yZXNpemUuc3ZnIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvc29sdmUuc3ZnIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvdGltZS5zdmciLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy91bmRvLnN2ZyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2ltYWdlcy9icm93LndlYnAiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9pbWFnZXMvY2hhcmNvYWwud2VicCIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2ltYWdlcy9jaXJjbGUud2VicCIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2ltYWdlcy9ncmFkaWVudF9ib3R0b21fdG9fdG9wLndlYnAiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9pbWFnZXMvb2lsXzAxLndlYnAiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9pbWFnZXMvb2lsX3RhcGVyLndlYnAiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9pbWFnZXMvc3F1YXJlLndlYnAiLCJ3ZWJwYWNrOi8vc3BsdW5nZS9pZ25vcmVkfC9ob21lL3J1bm5lci93b3JrL3NwbHVuZ2Uvc3BsdW5nZS9ub2RlX21vZHVsZXMvZHJvcGJveC9kaXN0fGNyeXB0byIsIndlYnBhY2s6Ly9zcGx1bmdlL2lnbm9yZWR8L2hvbWUvcnVubmVyL3dvcmsvc3BsdW5nZS9zcGx1bmdlL25vZGVfbW9kdWxlcy9kcm9wYm94L2Rpc3R8dXRpbCIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL2Nocm9tYS1qcy9jaHJvbWEuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9zcGx1bmdlL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3NwbHVuZ2Uvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3NwbHVuZ2Uvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9zcGx1bmdlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vc3BsdW5nZS93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9zcGx1bmdlL3dlYnBhY2svcnVudGltZS9ub25jZSIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL0pldEJyYWluc01vbm8tUmVndWxhci50dGYiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9zdHlsZS5jc3M/Y2VjNyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9lbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9sb29wLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2dsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZG9tLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3N0eWxlX21hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvYW5pbWF0aW9ucy5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC91dGlscy5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9saWZlY3ljbGUuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvc2NoZWR1bGVyLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3RyYW5zaXRpb25zLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2F3YWl0X2Jsb2NrLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2VhY2guanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3NoYXJlZC9ib29sZWFuX2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvc3NyLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc2hhcmVkL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZGV2LmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2luZGV4LmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2Rpc2Nsb3NlLXZlcnNpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvc3RvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9zdG9yZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2FsZ29yaXRobS9iaW5hcnlTZWFyY2gudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9hbGdvcml0aG0vdHJhdmVyc2UudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9hcnJheS9hcnJheVJhbmdlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvYXJyYXkvYXJyYXlTZXJpYWwudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9hcnJheS9hcnJheVNldC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2FycmF5L2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2FycmF5L3V0aWxzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvQ0RTL0NEUy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL0Nsb2NrL0Nsb2NrLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvQ2xvY2svQ2xvY2tGcmFtZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL0Nsb2NrL0Nsb2NrUmVhbHRpbWUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9jb2xvci9jb2xvckZyb21BdGFyaVNULnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC91dGlscy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2NvbG9yL2NvbG9ySFNWMlJHQi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2NvbG9yL2NvbG9yVG9IZXgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYy92ZWNEb3QudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9jb2xvci9jb2xvclR1cmJvLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvY29sb3IvZW90ZlJlYzcwOS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2NvbG9yL29ldGZSZWM3MDkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9kYWcvZGFnRWRnZXNQYXJlbnRzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvZGFnL2RhZ0VkZ2VzQW5jZXN0b3JzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvZGFnL2RhZ0VkZ2VzQ2hpbGRyZW4udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9kYWcvZGFnRWRnZXNEZXNjZW5kYW50cy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2RhZy9kYWdFZGdlc1BhcmVudC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2RhZy9kYWdFZGdlc1Jlc29sdmUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9lZHQvZWR0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvRXhwU21vb3RoL0V4cFNtb290aC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL1Bvb2wvUG9vbC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL0dQVVRpbWVyL0dQVVRpbWVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvSGlzdG9yeU1lYW5DYWxjdWxhdG9yL0hpc3RvcnlNZWFuQ2FsY3VsYXRvci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL0hpc3RvcnlNZWFuQ2FsY3VsYXRvci9IaXN0b3J5UGVyY2VudGlsZUNhbGN1bGF0b3IudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9IaXN0b3J5TWVhbkNhbGN1bGF0b3IvSGlzdG9yeU1lZGlhbkNhbGN1bGF0b3IudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9NYXBPZlNldC9NYXBPZlNldC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjL3ZlY0Ficy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjL3ZlY0FkZC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjL3ZlY0RpdmlkZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjL3ZlY0xlbmd0aC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjL3ZlY0xlbmd0aFNxLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWMvdmVjTWFuaGF0dGFuTGVuZ3RoLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWMvdmVjTXVsdGlwbHkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYy92ZWNOZWcudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYy92ZWNTY2FsZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjL3ZlY05vcm1hbGl6ZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjL3ZlY1N1Yi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjL1ZlY3Rvci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjNC92ZWM0QXBwbHlNYXRyaXg0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWMzL3ZlYzNBcHBseU1hdHJpeDQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3F1YXQvcXVhdEludmVyc2UudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3F1YXQvcXVhdE11bHRpcGx5LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWMzL3ZlYzNBcHBseVF1YXRlcm5pb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYzMvdmVjM0Nyb3NzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWMzL3ZlYzNPcnRob05vcm1hbGl6ZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjMy9WZWN0b3IzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9ib3gzL2JveDNDb250YWluc1BvaW50LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9ib3gzL0JveDMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDMvbWF0M0Zyb21NYXQ0VHJhbnNwb3NlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQzL21hdDNJbnZlcnNlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQzL21hdDNDcmVhdGVOb3JtYWxNYXRyaXgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDMvbWF0M0RldGVybWluYW50LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQzL21hdDNGcm9tTWF0NC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0My9tYXQzRnJvbVF1YXRlcm5pb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDMvbWF0M011bHRpcGx5LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQzL21hdDNUcmFuc3Bvc2UudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDMvTWF0cml4My50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0NC9tYXQ0RnJvbVF1YXRlcm5pb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NENvbXBvc2UudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NERldGVybWluYW50LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9xdWF0L3F1YXRGcm9tTWF0cml4My50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcXVhdC9xdWF0RnJvbU1hdHJpeDQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NERlY29tcG9zZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0NC9tYXQ0RnJvbU1hdDMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NEludmVyc2UudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NExvb2tBdC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0NC9tYXQ0TG9va0F0SW52ZXJzZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0NC9tYXQ0TXVsdGlwbHkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NFBlcnNwZWN0aXZlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQ0L21hdDRSb3RhdGlvblgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NFJvdGF0aW9uWS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0NC9tYXQ0Um90YXRpb25aLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQ0L21hdDRTY2FsZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0NC9tYXQ0U2NhbGVTY2FsYXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NFRyYW5zbGF0ZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0NC9tYXQ0VHJhbnNwb3NlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQ0L01hdHJpeDQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3F1YXQvcXVhdEZyb21BeGlzQW5nbGUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3F1YXQvcXVhdExvb2tSb3RhdGlvbi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcXVhdC9xdWF0Tm9ybWFsaXplLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9xdWF0L3F1YXRSb3RhdGlvblgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3F1YXQvcXVhdFJvdGF0aW9uWS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcXVhdC9xdWF0Um90YXRpb25aLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9xdWF0L3F1YXRTbGVycC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcXVhdC9RdWF0ZXJuaW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tb2QudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3Nhbml0aXplQW5nbGUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL2V1bGVyL2V1bGVyRnJvbU1hdDMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL2V1bGVyL2V1bGVyRnJvbU1hdDQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL2V1bGVyL2V1bGVyRnJvbVF1YXRlcm5pb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3F1YXQvcXVhdEZyb21FdWxlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvZXVsZXIvRXVsZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3JheTMvcmF5M0Rpc3RhbmNlVG9TcGhlcmUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL2xpbmUzL2xpbmUzRGVsdGEudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3JheTMvcmF5M0Zyb21MaW5lMy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcmF5My9SYXkzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9saW5lMy9saW5lM0FwcGx5TWF0cml4NC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbGluZTMvbGluZTNBdC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbGluZTMvbGluZTNDbG9zZXN0UG9pbnRUb1BvaW50LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9saW5lMy9saW5lM0Rpc3RhbmNlVG9Qb2ludC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbGluZTMvTGluZTMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDIvbWF0MkRldGVybWluYW50LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQyL21hdDJJbnZlcnNlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQyL21hdDJNdWx0aXBseS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0Mi9tYXQyVHJhbnNwb3NlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQyL01hdHJpeDIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYzMvdmVjM0FwcGx5TWF0cml4My50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcGxhbmUzL3BsYW5lM0FwcGx5TWF0cml4NC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcGxhbmUzL3BsYW5lM0Rpc3RhbmNlVG9Qb2ludC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcGxhbmUzL3BsYW5lM05vcm1hbGl6ZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcGxhbmUzL1BsYW5lMy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcGxhbmUzL3BsYW5lczNDb250YWluUG9pbnQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3BsYW5lMy9wbGFuZXMzRnJvbUJveDMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3BsYW5lMy9wbGFuZXMzRnJvbVByb2plY3Rpb25NYXRyaXgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3BsYW5lMy9wbGFuZXMzSW50ZXJzZWN0Qm94My50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcGxhbmUzL3BsYW5lczNJbnRlcnNlY3RTcGhlcmUzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9wbGFuZTMvUGxhbmVzMy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvc3BoZXJlMy9zcGhlcmUzQ29udGFpbnNQb2ludC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvc3BoZXJlMy9TcGhlcmUzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWM0L3ZlYzRBcHBseU1hdHJpeDMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYzQvVmVjdG9yNC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21pZGkvbWlkaVBhcnNlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvcG9rZXIvcG9rZXJSYW5rc0J5U3RyZW5ndGgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9wb2tlci9wb2tlclN1aXRzQnlJbmRleC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL3Bva2VyL2NyZWF0ZVBva2VyRGVjay50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL3Bva2VyL3Bva2VySGFuZFN0cmVuZ3RoTWFwLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvcG9rZXIvcG9rZXJSYW5rU3RyZW5ndGhNYXAudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9wb2tlci9wb2tlclN1aXRJbmRleE1hcC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL3Bva2VyL3NvcnRQb2tlckNhcmRzQnlSYW5rLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvcG9rZXIvZXZhbHVhdGVQb2tlckhhbmQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9wb2tlci9wb2tlckhhbmRzQnlTdHJlbmd0aC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL3JldHJ5L2FzeW5jUmV0cnkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9yZXRyeS9yZXRyeS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL3N0bmljY2MvcGFyc2VTVE5JQ0NDLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvc3RuaWNjYy9zdG5pY2NjVG9TVkcudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9TbW9vdGhEYW1wL1Ntb290aERhbXAudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9Td2FwL1N3YXAudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9UYXBUZW1wby9UYXBUZW1wby50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL3RpbnlzZXEvY3JlYXRlVGlueXNlcVBvbHlSZWFkZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy90aW55c2VxL2NyZWF0ZVRpbnlzZXFSZWFkZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy90aW55c2VxL3RpbnlzZXFGcm9tTWlkaVBhcnNlUmVzdWx0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvWG9yc2hpZnQvWG9yc2hpZnQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy95dWdvcC9nZXRZdWdvcFRleHQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9CaW5hcnlIZWFwLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbm90aWZ5T2JzZXJ2ZXJzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvd21hdGgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9nbC9UZXh0dXJlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvZ2wvRnJhbWVidWZmZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9nbF91dGlscy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2NvbXBvbmVudHMvU2VtaU1vZGFsLnN2ZWx0ZSIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2NvbXBvbmVudHMvS25vYi5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL0JydXNoU2l6ZVdpZGdldC5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9zdHVmZi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2JydXNoX3N0cm9rZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2NvbXBvbmVudHMvQnJ1c2hUeXBlV2lkZ2V0LnN2ZWx0ZSIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2NvbXBvbmVudHMvQnJ1c2hQcmVzZXRXaWRnZXQuc3ZlbHRlIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvY29tcG9uZW50cy9VbmRvUmVkb1dpZGdldC5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvY29uc3RhbnRzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL2Fzc2VydC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy9jcnlwdC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy9kZWVwQ29weS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy9nbG9iYWwudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvZGVmYXVsdHMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvZGVmZXJyZWQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvZW11bGF0b3IudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvZW52aXJvbm1lbnQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvZXJyb3JzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL2pzb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvand0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL29iai50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy9wcm9taXNlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL3F1ZXJ5LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL3NoYTEudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvc3Vic2NyaWJlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL3ZhbGlkYXRpb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvdXRmOC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy91dWlkLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL2V4cG9uZW50aWFsX2JhY2tvZmYudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvZm9ybWF0dGVycy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy9jb21wYXQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L3NyYy9jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L3NyYy9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L3NyYy9wcm92aWRlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9jb21wb25lbnQvc3JjL2NvbXBvbmVudF9jb250YWluZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbG9nZ2VyL3NyYy9sb2dnZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvd3JhcC1pZGItdmFsdWUuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL3NyYy9wbGF0Zm9ybUxvZ2dlclNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL3NyYy9sb2dnZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL3NyYy9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL3NyYy9pbnRlcm5hbC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvc3JjL2Vycm9ycy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvc3JjL2ZpcmViYXNlQXBwLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9zcmMvYXBpLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9zcmMvaW5kZXhlZGRiLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9zcmMvaGVhcnRiZWF0U2VydmljZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvc3JjL3JlZ2lzdGVyQ29yZUNvbXBvbmVudHMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvbW9kZWwvZW51bV9tYXBzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvZXJyb3JzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC9sb2cudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91dGlsL2Fzc2VydC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3V0aWwvbG9jYXRpb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91dGlsL25hdmlnYXRvci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3V0aWwvZGVsYXkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91dGlsL2VtdWxhdG9yLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC9mZXRjaF9wcm92aWRlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvZXJyb3JzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2FwaS9pbmRleC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L2FjY291bnQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91dGlsL3RpbWUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91c2VyL2lkX3Rva2VuX3Jlc3VsdC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3VzZXIvaW52YWxpZGF0aW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXNlci9wcm9hY3RpdmVfcmVmcmVzaC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3VzZXIvdXNlcl9tZXRhZGF0YS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3VzZXIvcmVsb2FkLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2FwaS9hdXRoZW50aWNhdGlvbi90b2tlbi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3VzZXIvdG9rZW5fbWFuYWdlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3VzZXIvdXNlcl9pbXBsLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC9pbnN0YW50aWF0b3IudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9wZXJzaXN0ZW5jZS9pbl9tZW1vcnkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9wZXJzaXN0ZW5jZS9wZXJzaXN0ZW5jZV91c2VyX21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91dGlsL2Jyb3dzZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91dGlsL3ZlcnNpb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL2F1dGhlbnRpY2F0aW9uL3JlY2FwdGNoYS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL3JlY2FwdGNoYS9yZWNhcHRjaGEudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9sb2FkX2pzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvcmVjYXB0Y2hhL3JlY2FwdGNoYV9lbnRlcnByaXNlX3ZlcmlmaWVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvYXV0aC9taWRkbGV3YXJlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvYXV0aC9hdXRoX2ltcGwudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9hdXRoL2luaXRpYWxpemUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9hdXRoL2VtdWxhdG9yLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvY3JlZGVudGlhbHMvYXV0aF9jcmVkZW50aWFsLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2FwaS9hY2NvdW50X21hbmFnZW1lbnQvZW1haWxfYW5kX3Bhc3N3b3JkLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2FwaS9hdXRoZW50aWNhdGlvbi9lbWFpbF9hbmRfcGFzc3dvcmQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL2F1dGhlbnRpY2F0aW9uL2VtYWlsX2xpbmsudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9jcmVkZW50aWFscy9lbWFpbC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvYXV0aGVudGljYXRpb24vaWRwLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvY3JlZGVudGlhbHMvb2F1dGgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL2F1dGhlbnRpY2F0aW9uL3Ntcy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL2NyZWRlbnRpYWxzL3Bob25lLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvYWN0aW9uX2NvZGVfdXJsLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvcHJvdmlkZXJzL2VtYWlsLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvcHJvdmlkZXJzL2ZlZGVyYXRlZC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3Byb3ZpZGVycy9vYXV0aC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3Byb3ZpZGVycy9mYWNlYm9vay50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3Byb3ZpZGVycy9nb29nbGUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9wcm92aWRlcnMvZ2l0aHViLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvY3JlZGVudGlhbHMvc2FtbC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3Byb3ZpZGVycy9zYW1sLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvcHJvdmlkZXJzL3R3aXR0ZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL2F1dGhlbnRpY2F0aW9uL3NpZ25fdXAudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91c2VyL3VzZXJfY3JlZGVudGlhbF9pbXBsLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvc3RyYXRlZ2llcy9hbm9ueW1vdXMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvbWZhL21mYV9lcnJvci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3V0aWwvcHJvdmlkZXJzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXNlci9saW5rX3VubGluay50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3VzZXIvcmVhdXRoZW50aWNhdGUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9zdHJhdGVnaWVzL2NyZWRlbnRpYWwudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL2F1dGhlbnRpY2F0aW9uL2N1c3RvbV90b2tlbi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3N0cmF0ZWdpZXMvY3VzdG9tX3Rva2VuLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL21mYS9tZmFfaW5mby50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3N0cmF0ZWdpZXMvYWN0aW9uX2NvZGVfc2V0dGluZ3MudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9zdHJhdGVnaWVzL2VtYWlsX2FuZF9wYXNzd29yZC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3N0cmF0ZWdpZXMvZW1haWxfbGluay50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvYXV0aGVudGljYXRpb24vY3JlYXRlX2F1dGhfdXJpLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvc3RyYXRlZ2llcy9lbWFpbC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L3Byb2ZpbGUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91c2VyL2FjY291bnRfaW5mby50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3VzZXIvYWRkaXRpb25hbF91c2VyX2luZm8udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9pbmRleC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9tZmEvbWZhX3Nlc3Npb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvbWZhL21mYV9yZXNvbHZlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L21mYS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9tZmEvbWZhX3VzZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9wZXJzaXN0ZW5jZS9pbmRleC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL3BlcnNpc3RlbmNlL2Jyb3dzZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9wZXJzaXN0ZW5jZS9sb2NhbF9zdG9yYWdlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvcGVyc2lzdGVuY2Uvc2Vzc2lvbl9zdG9yYWdlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvbWVzc2FnZWNoYW5uZWwvcHJvbWlzZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL21lc3NhZ2VjaGFubmVsL3JlY2VpdmVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC9ldmVudF9pZC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL21lc3NhZ2VjaGFubmVsL3NlbmRlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL2F1dGhfd2luZG93LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvdXRpbC93b3JrZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9wZXJzaXN0ZW5jZS9pbmRleGVkX2RiLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2FwaS9hdXRoZW50aWNhdGlvbi9tZmEudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9yZWNhcHRjaGEvcmVjYXB0Y2hhX21vY2sudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9yZWNhcHRjaGEvcmVjYXB0Y2hhX2xvYWRlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL3JlY2FwdGNoYS9yZWNhcHRjaGFfdmVyaWZpZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9zdHJhdGVnaWVzL3Bob25lLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvcHJvdmlkZXJzL3Bob25lLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC9yZXNvbHZlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3N0cmF0ZWdpZXMvaWRwLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvc3RyYXRlZ2llcy9hYnN0cmFjdF9wb3B1cF9yZWRpcmVjdF9vcGVyYXRpb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9zdHJhdGVnaWVzL3BvcHVwLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvc3RyYXRlZ2llcy9yZWRpcmVjdC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL3N0cmF0ZWdpZXMvcmVkaXJlY3QudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9hdXRoL2F1dGhfZXZlbnRfbWFuYWdlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvcHJvamVjdF9jb25maWcvZ2V0X3Byb2plY3RfY29uZmlnLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC92YWxpZGF0ZV9vcmlnaW4udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9pZnJhbWUvZ2FwaS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL2lmcmFtZS9pZnJhbWUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci91dGlsL3BvcHVwLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC9oYW5kbGVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvcG9wdXBfcmVkaXJlY3QudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvbWZhL21mYV9hc3NlcnRpb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9tZmEvYXNzZXJ0aW9ucy9waG9uZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9tZmEvYXNzZXJ0aW9ucy90b3RwLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvYXV0aC9maXJlYmFzZV9pbnRlcm5hbC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL2F1dGgvcmVnaXN0ZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9pbmRleC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL2FwcC9pbmRleC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2Ryb3Bib3hfYXV0aC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2NvbXBvbmVudHMvR2FsbGVyeVdpZGdldC5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL0Zsb2F0aW5nTW9kYWwuc3ZlbHRlIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvY29tcG9uZW50cy9QaWNrQ29sb3VyV2lkZ2V0LnN2ZWx0ZSIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2NvbXBvbmVudHMvVGV4dHVyZVdpZGdldC5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL0JsZW5kaW5nQ29sb3VyU3BhY2VXaWRnZXQuc3ZlbHRlIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvY29tcG9uZW50cy9SR0JTbGlkZXJzLnN2ZWx0ZSIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2NvbXBvbmVudHMvQ29sb3VyRGlzcGxheS5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL0ZvdXJJY29uc1dpZGdldC5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9JTy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2dsL0J1ZmZlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2dsL1NoYWRlclByb2dyYW0udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9nbC9UaGluZy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2RyYXdlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2NvbXBvbmVudHMvQXBwLnN2ZWx0ZSIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGBib2R5IHtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwO1xuICB3aWR0aDogMTAwdnc7XG4gIGhlaWdodDogMTAwdmg7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAvKiBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjazsgKi9cbiAgdG91Y2gtYWN0aW9uOiBub25lO1xufVxuaHRtbCB7XG4gIHRvdWNoLWFjdGlvbjogbm9uZTtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbn1cbmJvZHl7XG4gIG1hcmdpbjogMHB4O1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xufVxuXG5jYW52YXMge1xuICBtYXgtd2lkdGg6IDEwMCU7XG4gIG1heC1oZWlnaHQ6IDEwMCU7XG4gIC8qIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7ICovXG4gIHRvdWNoLWFjdGlvbjogbm9uZTtcbn1cbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vcHVibGljL3N0eWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLFNBQVM7RUFDVCxVQUFVO0VBQ1YsWUFBWTtFQUNaLGFBQWE7RUFDYixnQkFBZ0I7RUFDaEIsYUFBYTtFQUNiLG1CQUFtQjtFQUNuQix1QkFBdUI7RUFDdkIsNkJBQTZCO0VBQzdCLGtCQUFrQjtBQUNwQjtBQUNBO0VBQ0Usa0JBQWtCO0VBQ2xCLFdBQVc7RUFDWCxZQUFZO0FBQ2Q7QUFDQTtFQUNFLFdBQVc7RUFDWCxXQUFXO0VBQ1gsWUFBWTtBQUNkOztBQUVBO0VBQ0UsZUFBZTtFQUNmLGdCQUFnQjtFQUNoQjtpQkFDZTtFQUNmLGtCQUFrQjtBQUNwQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJib2R5IHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICB3aWR0aDogMTAwdnc7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAvKiBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjazsgKi9cXG4gIHRvdWNoLWFjdGlvbjogbm9uZTtcXG59XFxuaHRtbCB7XFxuICB0b3VjaC1hY3Rpb246IG5vbmU7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuYm9keXtcXG4gIG1hcmdpbjogMHB4O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmNhbnZhcyB7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxuICBtYXgtaGVpZ2h0OiAxMDAlO1xcbiAgLyogd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7ICovXFxuICB0b3VjaC1hY3Rpb246IG5vbmU7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTtcblxuICAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTtcblxuICAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/dChleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sdCk6dCgoZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOmV8fHNlbGYpLkRyb3Bib3g9e30pfSh0aGlzLChmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiByKGUsdCl7Zm9yKHZhciByPTA7dC5sZW5ndGg+cjtyKyspe3ZhciBpPXRbcl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGkua2V5LGkpfX1mdW5jdGlvbiBpKGUsdCxpKXtyZXR1cm4gdCYmcihlLnByb3RvdHlwZSx0KSxpJiZyKGUsaSksZX1mdW5jdGlvbiBzKGUpe3JldHVybihzPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiBuKGUsdCl7cmV0dXJuKG49T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfWZ1bmN0aW9uIGEoKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaChlKXtyZXR1cm4hMX19ZnVuY3Rpb24gbyhlLHQscil7cmV0dXJuKG89YSgpP1JlZmxlY3QuY29uc3RydWN0OmZ1bmN0aW9uKGUsdCxyKXt2YXIgaT1bbnVsbF07aS5wdXNoLmFwcGx5KGksdCk7dmFyIHM9bmV3KEZ1bmN0aW9uLmJpbmQuYXBwbHkoZSxpKSk7cmV0dXJuIHImJm4ocyxyLnByb3RvdHlwZSksc30pLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiB1KGUpe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIE1hcD9uZXcgTWFwOnZvaWQgMDtyZXR1cm4odT1mdW5jdGlvbihlKXtpZihudWxsPT09ZXx8LTE9PT1GdW5jdGlvbi50b1N0cmluZy5jYWxsKGUpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpKXJldHVybiBlO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2lmKHZvaWQgMCE9PXQpe2lmKHQuaGFzKGUpKXJldHVybiB0LmdldChlKTt0LnNldChlLHIpfWZ1bmN0aW9uIHIoKXtyZXR1cm4gbyhlLGFyZ3VtZW50cyxzKHRoaXMpLmNvbnN0cnVjdG9yKX1yZXR1cm4gci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnIsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksbihyLGUpfSkoZSl9ZnVuY3Rpb24gYyhlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9mdW5jdGlvbihlKXtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gZX0oZSk6dH12YXIgcD1cImFwcFwiLGw9XCJ1c2VyXCIsZj1cInRlYW1cIixtPVwiZHJvcGJveGFwaS5jb21cIixoPVwiZHJvcGJveC5jb21cIixkPXthcGk6XCJhcGlcIixub3RpZnk6XCJib2x0XCIsY29udGVudDpcImFwaS1jb250ZW50XCJ9LF89e307ZnVuY3Rpb24gZyhlKXt2YXIgdD1cIjAwMFwiLmNvbmNhdChlLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7cmV0dXJuXCJcXFxcdVwiLmNvbmNhdCh0KX1fLmFjY291bnRTZXRQcm9maWxlUGhvdG89ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImFjY291bnQvc2V0X3Byb2ZpbGVfcGhvdG9cIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImFjY291bnRfaW5mby53cml0ZVwiKX0sXy5hdXRoVG9rZW5Gcm9tT2F1dGgxPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJhdXRoL3Rva2VuL2Zyb21fb2F1dGgxXCIsZSxcImFwcFwiLFwiYXBpXCIsXCJycGNcIixudWxsKX0sXy5hdXRoVG9rZW5SZXZva2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiYXV0aC90b2tlbi9yZXZva2VcIixudWxsLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixudWxsKX0sXy5jaGVja0FwcD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiY2hlY2svYXBwXCIsZSxcImFwcFwiLFwiYXBpXCIsXCJycGNcIixudWxsKX0sXy5jaGVja1VzZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImNoZWNrL3VzZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImFjY291bnRfaW5mby5yZWFkXCIpfSxfLmNvbnRhY3RzRGVsZXRlTWFudWFsQ29udGFjdHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiY29udGFjdHMvZGVsZXRlX21hbnVhbF9jb250YWN0c1wiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiY29udGFjdHMud3JpdGVcIil9LF8uY29udGFjdHNEZWxldGVNYW51YWxDb250YWN0c0JhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJjb250YWN0cy9kZWxldGVfbWFudWFsX2NvbnRhY3RzX2JhdGNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJjb250YWN0cy53cml0ZVwiKX0sXy5maWxlUHJvcGVydGllc1Byb3BlcnRpZXNBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy9wcm9wZXJ0aWVzL2FkZFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEud3JpdGVcIil9LF8uZmlsZVByb3BlcnRpZXNQcm9wZXJ0aWVzT3ZlcndyaXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3Byb3BlcnRpZXMvcHJvcGVydGllcy9vdmVyd3JpdGVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVQcm9wZXJ0aWVzUHJvcGVydGllc1JlbW92ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3Byb3BlcnRpZXMvcmVtb3ZlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlUHJvcGVydGllc1Byb3BlcnRpZXNTZWFyY2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy9wcm9wZXJ0aWVzL3NlYXJjaFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlUHJvcGVydGllc1Byb3BlcnRpZXNTZWFyY2hDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3Byb3BlcnRpZXMvc2VhcmNoL2NvbnRpbnVlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVQcm9wZXJ0aWVzUHJvcGVydGllc1VwZGF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3Byb3BlcnRpZXMvdXBkYXRlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlUHJvcGVydGllc1RlbXBsYXRlc0FkZEZvclRlYW09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy90ZW1wbGF0ZXMvYWRkX2Zvcl90ZWFtXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy50ZWFtX21ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVQcm9wZXJ0aWVzVGVtcGxhdGVzQWRkRm9yVXNlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3RlbXBsYXRlcy9hZGRfZm9yX3VzZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVQcm9wZXJ0aWVzVGVtcGxhdGVzR2V0Rm9yVGVhbT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3RlbXBsYXRlcy9nZXRfZm9yX3RlYW1cIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLnRlYW1fbWV0YWRhdGEud3JpdGVcIil9LF8uZmlsZVByb3BlcnRpZXNUZW1wbGF0ZXNHZXRGb3JVc2VyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3Byb3BlcnRpZXMvdGVtcGxhdGVzL2dldF9mb3JfdXNlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlUHJvcGVydGllc1RlbXBsYXRlc0xpc3RGb3JUZWFtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy90ZW1wbGF0ZXMvbGlzdF9mb3JfdGVhbVwiLG51bGwsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMudGVhbV9tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlUHJvcGVydGllc1RlbXBsYXRlc0xpc3RGb3JVc2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy90ZW1wbGF0ZXMvbGlzdF9mb3JfdXNlclwiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlUHJvcGVydGllc1RlbXBsYXRlc1JlbW92ZUZvclRlYW09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy90ZW1wbGF0ZXMvcmVtb3ZlX2Zvcl90ZWFtXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy50ZWFtX21ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVQcm9wZXJ0aWVzVGVtcGxhdGVzUmVtb3ZlRm9yVXNlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3RlbXBsYXRlcy9yZW1vdmVfZm9yX3VzZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVQcm9wZXJ0aWVzVGVtcGxhdGVzVXBkYXRlRm9yVGVhbT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3RlbXBsYXRlcy91cGRhdGVfZm9yX3RlYW1cIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLnRlYW1fbWV0YWRhdGEud3JpdGVcIil9LF8uZmlsZVByb3BlcnRpZXNUZW1wbGF0ZXNVcGRhdGVGb3JVc2VyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3Byb3BlcnRpZXMvdGVtcGxhdGVzL3VwZGF0ZV9mb3JfdXNlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEud3JpdGVcIil9LF8uZmlsZVJlcXVlc3RzQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9yZXF1ZXN0cy9jb3VudFwiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZV9yZXF1ZXN0cy5yZWFkXCIpfSxfLmZpbGVSZXF1ZXN0c0NyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9yZXF1ZXN0cy9jcmVhdGVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVfcmVxdWVzdHMud3JpdGVcIil9LF8uZmlsZVJlcXVlc3RzRGVsZXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3JlcXVlc3RzL2RlbGV0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZV9yZXF1ZXN0cy53cml0ZVwiKX0sXy5maWxlUmVxdWVzdHNEZWxldGVBbGxDbG9zZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9yZXF1ZXN0cy9kZWxldGVfYWxsX2Nsb3NlZFwiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZV9yZXF1ZXN0cy53cml0ZVwiKX0sXy5maWxlUmVxdWVzdHNHZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcmVxdWVzdHMvZ2V0XCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlX3JlcXVlc3RzLnJlYWRcIil9LF8uZmlsZVJlcXVlc3RzTGlzdFYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3JlcXVlc3RzL2xpc3RfdjJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVfcmVxdWVzdHMucmVhZFwiKX0sXy5maWxlUmVxdWVzdHNMaXN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcmVxdWVzdHMvbGlzdFwiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZV9yZXF1ZXN0cy5yZWFkXCIpfSxfLmZpbGVSZXF1ZXN0c0xpc3RDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9yZXF1ZXN0cy9saXN0L2NvbnRpbnVlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlX3JlcXVlc3RzLnJlYWRcIil9LF8uZmlsZVJlcXVlc3RzVXBkYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3JlcXVlc3RzL3VwZGF0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZV9yZXF1ZXN0cy53cml0ZVwiKX0sXy5maWxlc0FscGhhR2V0TWV0YWRhdGE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2FscGhhL2dldF9tZXRhZGF0YVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlc0FscGhhVXBsb2FkPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9hbHBoYS91cGxvYWRcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwidXBsb2FkXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weVYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9jb3B5X3YyXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY29weVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0NvcHlCYXRjaFYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9jb3B5X2JhdGNoX3YyXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weUJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9jb3B5X2JhdGNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weUJhdGNoQ2hlY2tWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY29weV9iYXRjaC9jaGVja192MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0NvcHlCYXRjaENoZWNrPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9jb3B5X2JhdGNoL2NoZWNrXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weVJlZmVyZW5jZUdldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY29weV9yZWZlcmVuY2UvZ2V0XCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weVJlZmVyZW5jZVNhdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2NvcHlfcmVmZXJlbmNlL3NhdmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNDcmVhdGVGb2xkZXJWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY3JlYXRlX2ZvbGRlcl92MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0NyZWF0ZUZvbGRlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY3JlYXRlX2ZvbGRlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0NyZWF0ZUZvbGRlckJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9jcmVhdGVfZm9sZGVyX2JhdGNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ3JlYXRlRm9sZGVyQmF0Y2hDaGVjaz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY3JlYXRlX2ZvbGRlcl9iYXRjaC9jaGVja1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0RlbGV0ZVYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9kZWxldGVfdjJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNEZWxldGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2RlbGV0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0RlbGV0ZUJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9kZWxldGVfYmF0Y2hcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNEZWxldGVCYXRjaENoZWNrPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9kZWxldGVfYmF0Y2gvY2hlY2tcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNEb3dubG9hZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZG93bmxvYWRcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwiZG93bmxvYWRcIixcImZpbGVzLmNvbnRlbnQucmVhZFwiKX0sXy5maWxlc0Rvd25sb2FkWmlwPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9kb3dubG9hZF96aXBcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwiZG93bmxvYWRcIixcImZpbGVzLmNvbnRlbnQucmVhZFwiKX0sXy5maWxlc0V4cG9ydD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZXhwb3J0XCIsZSxcInVzZXJcIixcImNvbnRlbnRcIixcImRvd25sb2FkXCIsXCJmaWxlcy5jb250ZW50LnJlYWRcIil9LF8uZmlsZXNHZXRGaWxlTG9ja0JhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9nZXRfZmlsZV9sb2NrX2JhdGNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LnJlYWRcIil9LF8uZmlsZXNHZXRNZXRhZGF0YT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZ2V0X21ldGFkYXRhXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVzR2V0UHJldmlldz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZ2V0X3ByZXZpZXdcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwiZG93bmxvYWRcIixcImZpbGVzLmNvbnRlbnQucmVhZFwiKX0sXy5maWxlc0dldFRlbXBvcmFyeUxpbms9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2dldF90ZW1wb3JhcnlfbGlua1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC5yZWFkXCIpfSxfLmZpbGVzR2V0VGVtcG9yYXJ5VXBsb2FkTGluaz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZ2V0X3RlbXBvcmFyeV91cGxvYWRfbGlua1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0dldFRodW1ibmFpbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZ2V0X3RodW1ibmFpbFwiLGUsXCJ1c2VyXCIsXCJjb250ZW50XCIsXCJkb3dubG9hZFwiLFwiZmlsZXMuY29udGVudC5yZWFkXCIpfSxfLmZpbGVzR2V0VGh1bWJuYWlsVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2dldF90aHVtYm5haWxfdjJcIixlLFwiYXBwLCB1c2VyXCIsXCJjb250ZW50XCIsXCJkb3dubG9hZFwiLFwiZmlsZXMuY29udGVudC5yZWFkXCIpfSxfLmZpbGVzR2V0VGh1bWJuYWlsQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2dldF90aHVtYm5haWxfYmF0Y2hcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LnJlYWRcIil9LF8uZmlsZXNMaXN0Rm9sZGVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9saXN0X2ZvbGRlclwiLGUsXCJhcHAsIHVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVzTGlzdEZvbGRlckNvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9saXN0X2ZvbGRlci9jb250aW51ZVwiLGUsXCJhcHAsIHVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVzTGlzdEZvbGRlckdldExhdGVzdEN1cnNvcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvbGlzdF9mb2xkZXIvZ2V0X2xhdGVzdF9jdXJzb3JcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLnJlYWRcIil9LF8uZmlsZXNMaXN0Rm9sZGVyTG9uZ3BvbGw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2xpc3RfZm9sZGVyL2xvbmdwb2xsXCIsZSxcIm5vYXV0aFwiLFwibm90aWZ5XCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLnJlYWRcIil9LF8uZmlsZXNMaXN0UmV2aXNpb25zPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9saXN0X3JldmlzaW9uc1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlc0xvY2tGaWxlQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2xvY2tfZmlsZV9iYXRjaFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc01vdmVWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvbW92ZV92MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc01vdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL21vdmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNNb3ZlQmF0Y2hWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvbW92ZV9iYXRjaF92MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc01vdmVCYXRjaD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvbW92ZV9iYXRjaFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc01vdmVCYXRjaENoZWNrVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL21vdmVfYmF0Y2gvY2hlY2tfdjJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNNb3ZlQmF0Y2hDaGVjaz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvbW92ZV9iYXRjaC9jaGVja1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1BhcGVyQ3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9wYXBlci9jcmVhdGVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJ1cGxvYWRcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNQYXBlclVwZGF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvcGFwZXIvdXBkYXRlXCIsZSxcInVzZXJcIixcImFwaVwiLFwidXBsb2FkXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzUGVybWFuZW50bHlEZWxldGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Blcm1hbmVudGx5X2RlbGV0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMucGVybWFuZW50X2RlbGV0ZVwiKX0sXy5maWxlc1Byb3BlcnRpZXNBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Byb3BlcnRpZXMvYWRkXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlc1Byb3BlcnRpZXNPdmVyd3JpdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Byb3BlcnRpZXMvb3ZlcndyaXRlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlc1Byb3BlcnRpZXNSZW1vdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Byb3BlcnRpZXMvcmVtb3ZlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlc1Byb3BlcnRpZXNUZW1wbGF0ZUdldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvcHJvcGVydGllcy90ZW1wbGF0ZS9nZXRcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLnJlYWRcIil9LF8uZmlsZXNQcm9wZXJ0aWVzVGVtcGxhdGVMaXN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Byb3BlcnRpZXMvdGVtcGxhdGUvbGlzdFwiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlc1Byb3BlcnRpZXNVcGRhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Byb3BlcnRpZXMvdXBkYXRlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlc1Jlc3RvcmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Jlc3RvcmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNTYXZlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9zYXZlX3VybFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1NhdmVVcmxDaGVja0pvYlN0YXR1cz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvc2F2ZV91cmwvY2hlY2tfam9iX3N0YXR1c1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1NlYXJjaD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvc2VhcmNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVzU2VhcmNoVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3NlYXJjaF92MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlc1NlYXJjaENvbnRpbnVlVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3NlYXJjaC9jb250aW51ZV92MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlc1RhZ3NBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3RhZ3MvYWRkXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlc1RhZ3NHZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3RhZ3MvZ2V0XCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVzVGFnc1JlbW92ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvdGFncy9yZW1vdmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVzVW5sb2NrRmlsZUJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy91bmxvY2tfZmlsZV9iYXRjaFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1VwbG9hZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvdXBsb2FkXCIsZSxcInVzZXJcIixcImNvbnRlbnRcIixcInVwbG9hZFwiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1VwbG9hZFNlc3Npb25BcHBlbmRWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvdXBsb2FkX3Nlc3Npb24vYXBwZW5kX3YyXCIsZSxcInVzZXJcIixcImNvbnRlbnRcIixcInVwbG9hZFwiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1VwbG9hZFNlc3Npb25BcHBlbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3VwbG9hZF9zZXNzaW9uL2FwcGVuZFwiLGUsXCJ1c2VyXCIsXCJjb250ZW50XCIsXCJ1cGxvYWRcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNVcGxvYWRTZXNzaW9uRmluaXNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy91cGxvYWRfc2Vzc2lvbi9maW5pc2hcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwidXBsb2FkXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzVXBsb2FkU2Vzc2lvbkZpbmlzaEJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy91cGxvYWRfc2Vzc2lvbi9maW5pc2hfYmF0Y2hcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNVcGxvYWRTZXNzaW9uRmluaXNoQmF0Y2hWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvdXBsb2FkX3Nlc3Npb24vZmluaXNoX2JhdGNoX3YyXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzVXBsb2FkU2Vzc2lvbkZpbmlzaEJhdGNoQ2hlY2s9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3VwbG9hZF9zZXNzaW9uL2ZpbmlzaF9iYXRjaC9jaGVja1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1VwbG9hZFNlc3Npb25TdGFydD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvdXBsb2FkX3Nlc3Npb24vc3RhcnRcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwidXBsb2FkXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzVXBsb2FkU2Vzc2lvblN0YXJ0QmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3VwbG9hZF9zZXNzaW9uL3N0YXJ0X2JhdGNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLm9wZW5pZFVzZXJpbmZvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJvcGVuaWQvdXNlcmluZm9cIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcIm9wZW5pZFwiKX0sXy5wYXBlckRvY3NBcmNoaXZlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL2FyY2hpdmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8ucGFwZXJEb2NzQ3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL2NyZWF0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInVwbG9hZFwiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5wYXBlckRvY3NEb3dubG9hZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwicGFwZXIvZG9jcy9kb3dubG9hZFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcImRvd25sb2FkXCIsXCJmaWxlcy5jb250ZW50LnJlYWRcIil9LF8ucGFwZXJEb2NzRm9sZGVyVXNlcnNMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL2ZvbGRlcl91c2Vycy9saXN0XCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLnJlYWRcIil9LF8ucGFwZXJEb2NzRm9sZGVyVXNlcnNMaXN0Q29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInBhcGVyL2RvY3MvZm9sZGVyX3VzZXJzL2xpc3QvY29udGludWVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5wYXBlckRvY3NHZXRGb2xkZXJJbmZvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL2dldF9mb2xkZXJfaW5mb1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnBhcGVyRG9jc0xpc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInBhcGVyL2RvY3MvbGlzdFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5wYXBlckRvY3NMaXN0Q29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInBhcGVyL2RvY3MvbGlzdC9jb250aW51ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5wYXBlckRvY3NQZXJtYW5lbnRseURlbGV0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwicGFwZXIvZG9jcy9wZXJtYW5lbnRseV9kZWxldGVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLnBlcm1hbmVudF9kZWxldGVcIil9LF8ucGFwZXJEb2NzU2hhcmluZ1BvbGljeUdldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwicGFwZXIvZG9jcy9zaGFyaW5nX3BvbGljeS9nZXRcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5wYXBlckRvY3NTaGFyaW5nUG9saWN5U2V0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL3NoYXJpbmdfcG9saWN5L3NldFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5wYXBlckRvY3NVcGRhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInBhcGVyL2RvY3MvdXBkYXRlXCIsZSxcInVzZXJcIixcImFwaVwiLFwidXBsb2FkXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLnBhcGVyRG9jc1VzZXJzQWRkPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL3VzZXJzL2FkZFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5wYXBlckRvY3NVc2Vyc0xpc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInBhcGVyL2RvY3MvdXNlcnMvbGlzdFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnBhcGVyRG9jc1VzZXJzTGlzdENvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL3VzZXJzL2xpc3QvY29udGludWVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5wYXBlckRvY3NVc2Vyc1JlbW92ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwicGFwZXIvZG9jcy91c2Vycy9yZW1vdmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8ucGFwZXJGb2xkZXJzQ3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9mb2xkZXJzL2NyZWF0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5zaGFyaW5nQWRkRmlsZU1lbWJlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9hZGRfZmlsZV9tZW1iZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ0FkZEZvbGRlck1lbWJlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9hZGRfZm9sZGVyX21lbWJlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nQ2hlY2tKb2JTdGF0dXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvY2hlY2tfam9iX3N0YXR1c1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nQ2hlY2tSZW1vdmVNZW1iZXJKb2JTdGF0dXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvY2hlY2tfcmVtb3ZlX21lbWJlcl9qb2Jfc3RhdHVzXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdDaGVja1NoYXJlSm9iU3RhdHVzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL2NoZWNrX3NoYXJlX2pvYl9zdGF0dXNcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ0NyZWF0ZVNoYXJlZExpbms9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvY3JlYXRlX3NoYXJlZF9saW5rXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdDcmVhdGVTaGFyZWRMaW5rV2l0aFNldHRpbmdzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL2NyZWF0ZV9zaGFyZWRfbGlua193aXRoX3NldHRpbmdzXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdHZXRGaWxlTWV0YWRhdGE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvZ2V0X2ZpbGVfbWV0YWRhdGFcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nR2V0RmlsZU1ldGFkYXRhQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvZ2V0X2ZpbGVfbWV0YWRhdGEvYmF0Y2hcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nR2V0Rm9sZGVyTWV0YWRhdGE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvZ2V0X2ZvbGRlcl9tZXRhZGF0YVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnNoYXJpbmdHZXRTaGFyZWRMaW5rRmlsZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9nZXRfc2hhcmVkX2xpbmtfZmlsZVwiLGUsXCJ1c2VyXCIsXCJjb250ZW50XCIsXCJkb3dubG9hZFwiLFwic2hhcmluZy5yZWFkXCIpfSxfLnNoYXJpbmdHZXRTaGFyZWRMaW5rTWV0YWRhdGE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvZ2V0X3NoYXJlZF9saW5rX21ldGFkYXRhXCIsZSxcImFwcCwgdXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nR2V0U2hhcmVkTGlua3M9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvZ2V0X3NoYXJlZF9saW5rc1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnNoYXJpbmdMaXN0RmlsZU1lbWJlcnM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9maWxlX21lbWJlcnNcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdEZpbGVNZW1iZXJzQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9maWxlX21lbWJlcnMvYmF0Y2hcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdEZpbGVNZW1iZXJzQ29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9maWxlX21lbWJlcnMvY29udGludWVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdEZvbGRlck1lbWJlcnM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9mb2xkZXJfbWVtYmVyc1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnNoYXJpbmdMaXN0Rm9sZGVyTWVtYmVyc0NvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL2xpc3RfZm9sZGVyX21lbWJlcnMvY29udGludWVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdEZvbGRlcnM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9mb2xkZXJzXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLnJlYWRcIil9LF8uc2hhcmluZ0xpc3RGb2xkZXJzQ29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9mb2xkZXJzL2NvbnRpbnVlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLnJlYWRcIil9LF8uc2hhcmluZ0xpc3RNb3VudGFibGVGb2xkZXJzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL2xpc3RfbW91bnRhYmxlX2ZvbGRlcnNcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdE1vdW50YWJsZUZvbGRlcnNDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9saXN0X21vdW50YWJsZV9mb2xkZXJzL2NvbnRpbnVlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLnJlYWRcIil9LF8uc2hhcmluZ0xpc3RSZWNlaXZlZEZpbGVzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL2xpc3RfcmVjZWl2ZWRfZmlsZXNcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdFJlY2VpdmVkRmlsZXNDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9saXN0X3JlY2VpdmVkX2ZpbGVzL2NvbnRpbnVlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLnJlYWRcIil9LF8uc2hhcmluZ0xpc3RTaGFyZWRMaW5rcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9saXN0X3NoYXJlZF9saW5rc1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnNoYXJpbmdNb2RpZnlTaGFyZWRMaW5rU2V0dGluZ3M9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbW9kaWZ5X3NoYXJlZF9saW5rX3NldHRpbmdzXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdNb3VudEZvbGRlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9tb3VudF9mb2xkZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ1JlbGlucXVpc2hGaWxlTWVtYmVyc2hpcD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9yZWxpbnF1aXNoX2ZpbGVfbWVtYmVyc2hpcFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nUmVsaW5xdWlzaEZvbGRlck1lbWJlcnNoaXA9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvcmVsaW5xdWlzaF9mb2xkZXJfbWVtYmVyc2hpcFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nUmVtb3ZlRmlsZU1lbWJlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9yZW1vdmVfZmlsZV9tZW1iZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ1JlbW92ZUZpbGVNZW1iZXIyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL3JlbW92ZV9maWxlX21lbWJlcl8yXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdSZW1vdmVGb2xkZXJNZW1iZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvcmVtb3ZlX2ZvbGRlcl9tZW1iZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ1Jldm9rZVNoYXJlZExpbms9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvcmV2b2tlX3NoYXJlZF9saW5rXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdTZXRBY2Nlc3NJbmhlcml0YW5jZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9zZXRfYWNjZXNzX2luaGVyaXRhbmNlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdTaGFyZUZvbGRlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9zaGFyZV9mb2xkZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ1RyYW5zZmVyRm9sZGVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL3RyYW5zZmVyX2ZvbGRlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nVW5tb3VudEZvbGRlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy91bm1vdW50X2ZvbGRlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nVW5zaGFyZUZpbGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvdW5zaGFyZV9maWxlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdVbnNoYXJlRm9sZGVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL3Vuc2hhcmVfZm9sZGVyXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdVcGRhdGVGaWxlTWVtYmVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL3VwZGF0ZV9maWxlX21lbWJlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nVXBkYXRlRm9sZGVyTWVtYmVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL3VwZGF0ZV9mb2xkZXJfbWVtYmVyXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdVcGRhdGVGb2xkZXJQb2xpY3k9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvdXBkYXRlX2ZvbGRlcl9wb2xpY3lcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8udGVhbURldmljZXNMaXN0TWVtYmVyRGV2aWNlcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9kZXZpY2VzL2xpc3RfbWVtYmVyX2RldmljZXNcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInNlc3Npb25zLmxpc3RcIil9LF8udGVhbURldmljZXNMaXN0TWVtYmVyc0RldmljZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vZGV2aWNlcy9saXN0X21lbWJlcnNfZGV2aWNlc1wiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwic2Vzc2lvbnMubGlzdFwiKX0sXy50ZWFtRGV2aWNlc0xpc3RUZWFtRGV2aWNlcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9kZXZpY2VzL2xpc3RfdGVhbV9kZXZpY2VzXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJzZXNzaW9ucy5saXN0XCIpfSxfLnRlYW1EZXZpY2VzUmV2b2tlRGV2aWNlU2Vzc2lvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9kZXZpY2VzL3Jldm9rZV9kZXZpY2Vfc2Vzc2lvblwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwic2Vzc2lvbnMubW9kaWZ5XCIpfSxfLnRlYW1EZXZpY2VzUmV2b2tlRGV2aWNlU2Vzc2lvbkJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2RldmljZXMvcmV2b2tlX2RldmljZV9zZXNzaW9uX2JhdGNoXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJzZXNzaW9ucy5tb2RpZnlcIil9LF8udGVhbUZlYXR1cmVzR2V0VmFsdWVzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2ZlYXR1cmVzL2dldF92YWx1ZXNcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1faW5mby5yZWFkXCIpfSxfLnRlYW1HZXRJbmZvPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vZ2V0X2luZm9cIixudWxsLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1faW5mby5yZWFkXCIpfSxfLnRlYW1Hcm91cHNDcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vZ3JvdXBzL2NyZWF0ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLndyaXRlXCIpfSxfLnRlYW1Hcm91cHNEZWxldGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vZ3JvdXBzL2RlbGV0ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLndyaXRlXCIpfSxfLnRlYW1Hcm91cHNHZXRJbmZvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2dyb3Vwcy9nZXRfaW5mb1wiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLnJlYWRcIil9LF8udGVhbUdyb3Vwc0pvYlN0YXR1c0dldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9ncm91cHMvam9iX3N0YXR1cy9nZXRcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImdyb3Vwcy53cml0ZVwiKX0sXy50ZWFtR3JvdXBzTGlzdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9ncm91cHMvbGlzdFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLnJlYWRcIil9LF8udGVhbUdyb3Vwc0xpc3RDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9ncm91cHMvbGlzdC9jb250aW51ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLnJlYWRcIil9LF8udGVhbUdyb3Vwc01lbWJlcnNBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vZ3JvdXBzL21lbWJlcnMvYWRkXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJncm91cHMud3JpdGVcIil9LF8udGVhbUdyb3Vwc01lbWJlcnNMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2dyb3Vwcy9tZW1iZXJzL2xpc3RcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImdyb3Vwcy5yZWFkXCIpfSxfLnRlYW1Hcm91cHNNZW1iZXJzTGlzdENvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2dyb3Vwcy9tZW1iZXJzL2xpc3QvY29udGludWVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImdyb3Vwcy5yZWFkXCIpfSxfLnRlYW1Hcm91cHNNZW1iZXJzUmVtb3ZlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2dyb3Vwcy9tZW1iZXJzL3JlbW92ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLndyaXRlXCIpfSxfLnRlYW1Hcm91cHNNZW1iZXJzU2V0QWNjZXNzVHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9ncm91cHMvbWVtYmVycy9zZXRfYWNjZXNzX3R5cGVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImdyb3Vwcy53cml0ZVwiKX0sXy50ZWFtR3JvdXBzVXBkYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2dyb3Vwcy91cGRhdGVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImdyb3Vwcy53cml0ZVwiKX0sXy50ZWFtTGVnYWxIb2xkc0NyZWF0ZVBvbGljeT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9sZWdhbF9ob2xkcy9jcmVhdGVfcG9saWN5XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuZ292ZXJuYW5jZS53cml0ZVwiKX0sXy50ZWFtTGVnYWxIb2xkc0dldFBvbGljeT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9sZWdhbF9ob2xkcy9nZXRfcG9saWN5XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuZ292ZXJuYW5jZS53cml0ZVwiKX0sXy50ZWFtTGVnYWxIb2xkc0xpc3RIZWxkUmV2aXNpb25zPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2xlZ2FsX2hvbGRzL2xpc3RfaGVsZF9yZXZpc2lvbnNcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5nb3Zlcm5hbmNlLndyaXRlXCIpfSxfLnRlYW1MZWdhbEhvbGRzTGlzdEhlbGRSZXZpc2lvbnNDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9sZWdhbF9ob2xkcy9saXN0X2hlbGRfcmV2aXNpb25zX2NvbnRpbnVlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuZ292ZXJuYW5jZS53cml0ZVwiKX0sXy50ZWFtTGVnYWxIb2xkc0xpc3RQb2xpY2llcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9sZWdhbF9ob2xkcy9saXN0X3BvbGljaWVzXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuZ292ZXJuYW5jZS53cml0ZVwiKX0sXy50ZWFtTGVnYWxIb2xkc1JlbGVhc2VQb2xpY3k9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbGVnYWxfaG9sZHMvcmVsZWFzZV9wb2xpY3lcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5nb3Zlcm5hbmNlLndyaXRlXCIpfSxfLnRlYW1MZWdhbEhvbGRzVXBkYXRlUG9saWN5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2xlZ2FsX2hvbGRzL3VwZGF0ZV9wb2xpY3lcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5nb3Zlcm5hbmNlLndyaXRlXCIpfSxfLnRlYW1MaW5rZWRBcHBzTGlzdE1lbWJlckxpbmtlZEFwcHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbGlua2VkX2FwcHMvbGlzdF9tZW1iZXJfbGlua2VkX2FwcHNcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInNlc3Npb25zLmxpc3RcIil9LF8udGVhbUxpbmtlZEFwcHNMaXN0TWVtYmVyc0xpbmtlZEFwcHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbGlua2VkX2FwcHMvbGlzdF9tZW1iZXJzX2xpbmtlZF9hcHBzXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJzZXNzaW9ucy5saXN0XCIpfSxfLnRlYW1MaW5rZWRBcHBzTGlzdFRlYW1MaW5rZWRBcHBzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2xpbmtlZF9hcHBzL2xpc3RfdGVhbV9saW5rZWRfYXBwc1wiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwic2Vzc2lvbnMubGlzdFwiKX0sXy50ZWFtTGlua2VkQXBwc1Jldm9rZUxpbmtlZEFwcD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9saW5rZWRfYXBwcy9yZXZva2VfbGlua2VkX2FwcFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwic2Vzc2lvbnMubW9kaWZ5XCIpfSxfLnRlYW1MaW5rZWRBcHBzUmV2b2tlTGlua2VkQXBwQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbGlua2VkX2FwcHMvcmV2b2tlX2xpbmtlZF9hcHBfYmF0Y2hcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInNlc3Npb25zLm1vZGlmeVwiKX0sXy50ZWFtTWVtYmVyU3BhY2VMaW1pdHNFeGNsdWRlZFVzZXJzQWRkPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcl9zcGFjZV9saW1pdHMvZXhjbHVkZWRfdXNlcnMvYWRkXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJTcGFjZUxpbWl0c0V4Y2x1ZGVkVXNlcnNMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcl9zcGFjZV9saW1pdHMvZXhjbHVkZWRfdXNlcnMvbGlzdFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy5yZWFkXCIpfSxfLnRlYW1NZW1iZXJTcGFjZUxpbWl0c0V4Y2x1ZGVkVXNlcnNMaXN0Q29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVyX3NwYWNlX2xpbWl0cy9leGNsdWRlZF91c2Vycy9saXN0L2NvbnRpbnVlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlclNwYWNlTGltaXRzRXhjbHVkZWRVc2Vyc1JlbW92ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJfc3BhY2VfbGltaXRzL2V4Y2x1ZGVkX3VzZXJzL3JlbW92ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyU3BhY2VMaW1pdHNHZXRDdXN0b21RdW90YT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJfc3BhY2VfbGltaXRzL2dldF9jdXN0b21fcXVvdGFcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMucmVhZFwiKX0sXy50ZWFtTWVtYmVyU3BhY2VMaW1pdHNSZW1vdmVDdXN0b21RdW90YT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJfc3BhY2VfbGltaXRzL3JlbW92ZV9jdXN0b21fcXVvdGFcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlclNwYWNlTGltaXRzU2V0Q3VzdG9tUXVvdGE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVyX3NwYWNlX2xpbWl0cy9zZXRfY3VzdG9tX3F1b3RhXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNBZGRWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL2FkZF92MlwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc0FkZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL2FkZFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc0FkZEpvYlN0YXR1c0dldFYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvYWRkL2pvYl9zdGF0dXMvZ2V0X3YyXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzQWRkSm9iU3RhdHVzR2V0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvYWRkL2pvYl9zdGF0dXMvZ2V0XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzRGVsZXRlUHJvZmlsZVBob3RvVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9kZWxldGVfcHJvZmlsZV9waG90b192MlwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc0RlbGV0ZVByb2ZpbGVQaG90bz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL2RlbGV0ZV9wcm9maWxlX3Bob3RvXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzR2V0QXZhaWxhYmxlVGVhbU1lbWJlclJvbGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9nZXRfYXZhaWxhYmxlX3RlYW1fbWVtYmVyX3JvbGVzXCIsbnVsbCxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNHZXRJbmZvVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9nZXRfaW5mb192MlwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy5yZWFkXCIpfSxfLnRlYW1NZW1iZXJzR2V0SW5mbz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL2dldF9pbmZvXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNMaXN0VjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9saXN0X3YyXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvbGlzdFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy5yZWFkXCIpfSxfLnRlYW1NZW1iZXJzTGlzdENvbnRpbnVlVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9saXN0L2NvbnRpbnVlX3YyXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNMaXN0Q29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9saXN0L2NvbnRpbnVlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNNb3ZlRm9ybWVyTWVtYmVyRmlsZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9tb3ZlX2Zvcm1lcl9tZW1iZXJfZmlsZXNcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNNb3ZlRm9ybWVyTWVtYmVyRmlsZXNKb2JTdGF0dXNDaGVjaz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL21vdmVfZm9ybWVyX21lbWJlcl9maWxlcy9qb2Jfc3RhdHVzL2NoZWNrXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzUmVjb3Zlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL3JlY292ZXJcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMuZGVsZXRlXCIpfSxfLnRlYW1NZW1iZXJzUmVtb3ZlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvcmVtb3ZlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLmRlbGV0ZVwiKX0sXy50ZWFtTWVtYmVyc1JlbW92ZUpvYlN0YXR1c0dldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL3JlbW92ZS9qb2Jfc3RhdHVzL2dldFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy5kZWxldGVcIil9LF8udGVhbU1lbWJlcnNTZWNvbmRhcnlFbWFpbHNBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9zZWNvbmRhcnlfZW1haWxzL2FkZFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc1NlY29uZGFyeUVtYWlsc0RlbGV0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL3NlY29uZGFyeV9lbWFpbHMvZGVsZXRlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzU2Vjb25kYXJ5RW1haWxzUmVzZW5kVmVyaWZpY2F0aW9uRW1haWxzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc2Vjb25kYXJ5X2VtYWlscy9yZXNlbmRfdmVyaWZpY2F0aW9uX2VtYWlsc1wiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc1NlbmRXZWxjb21lRW1haWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9zZW5kX3dlbGNvbWVfZW1haWxcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNTZXRBZG1pblBlcm1pc3Npb25zVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9zZXRfYWRtaW5fcGVybWlzc2lvbnNfdjJcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNTZXRBZG1pblBlcm1pc3Npb25zPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc2V0X2FkbWluX3Blcm1pc3Npb25zXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzU2V0UHJvZmlsZVYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc2V0X3Byb2ZpbGVfdjJcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNTZXRQcm9maWxlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc2V0X3Byb2ZpbGVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNTZXRQcm9maWxlUGhvdG9WMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL3NldF9wcm9maWxlX3Bob3RvX3YyXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzU2V0UHJvZmlsZVBob3RvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc2V0X3Byb2ZpbGVfcGhvdG9cIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNTdXNwZW5kPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc3VzcGVuZFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc1Vuc3VzcGVuZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL3Vuc3VzcGVuZFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTmFtZXNwYWNlc0xpc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbmFtZXNwYWNlcy9saXN0XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEubWVtYmVyXCIpfSxfLnRlYW1OYW1lc3BhY2VzTGlzdENvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL25hbWVzcGFjZXMvbGlzdC9jb250aW51ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9kYXRhLm1lbWJlclwiKX0sXy50ZWFtUHJvcGVydGllc1RlbXBsYXRlQWRkPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3Byb3BlcnRpZXMvdGVtcGxhdGUvYWRkXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy50ZWFtX21ldGFkYXRhLndyaXRlXCIpfSxfLnRlYW1Qcm9wZXJ0aWVzVGVtcGxhdGVHZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vcHJvcGVydGllcy90ZW1wbGF0ZS9nZXRcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLnRlYW1fbWV0YWRhdGEud3JpdGVcIil9LF8udGVhbVByb3BlcnRpZXNUZW1wbGF0ZUxpc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9wcm9wZXJ0aWVzL3RlbXBsYXRlL2xpc3RcIixudWxsLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLnRlYW1fbWV0YWRhdGEud3JpdGVcIil9LF8udGVhbVByb3BlcnRpZXNUZW1wbGF0ZVVwZGF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9wcm9wZXJ0aWVzL3RlbXBsYXRlL3VwZGF0ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMudGVhbV9tZXRhZGF0YS53cml0ZVwiKX0sXy50ZWFtUmVwb3J0c0dldEFjdGl2aXR5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3JlcG9ydHMvZ2V0X2FjdGl2aXR5XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2luZm8ucmVhZFwiKX0sXy50ZWFtUmVwb3J0c0dldERldmljZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vcmVwb3J0cy9nZXRfZGV2aWNlc1wiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9pbmZvLnJlYWRcIil9LF8udGVhbVJlcG9ydHNHZXRNZW1iZXJzaGlwPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3JlcG9ydHMvZ2V0X21lbWJlcnNoaXBcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1faW5mby5yZWFkXCIpfSxfLnRlYW1SZXBvcnRzR2V0U3RvcmFnZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9yZXBvcnRzL2dldF9zdG9yYWdlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2luZm8ucmVhZFwiKX0sXy50ZWFtU2hhcmluZ0FsbG93bGlzdEFkZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9zaGFyaW5nX2FsbG93bGlzdC9hZGRcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1faW5mby53cml0ZVwiKX0sXy50ZWFtU2hhcmluZ0FsbG93bGlzdExpc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vc2hhcmluZ19hbGxvd2xpc3QvbGlzdFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9pbmZvLnJlYWRcIil9LF8udGVhbVNoYXJpbmdBbGxvd2xpc3RMaXN0Q29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vc2hhcmluZ19hbGxvd2xpc3QvbGlzdC9jb250aW51ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9pbmZvLnJlYWRcIil9LF8udGVhbVNoYXJpbmdBbGxvd2xpc3RSZW1vdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vc2hhcmluZ19hbGxvd2xpc3QvcmVtb3ZlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2luZm8ud3JpdGVcIil9LF8udGVhbVRlYW1Gb2xkZXJBY3RpdmF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS90ZWFtX2ZvbGRlci9hY3RpdmF0ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9kYXRhLmNvbnRlbnQud3JpdGVcIil9LF8udGVhbVRlYW1Gb2xkZXJBcmNoaXZlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL2FyY2hpdmVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5jb250ZW50LndyaXRlXCIpfSxfLnRlYW1UZWFtRm9sZGVyQXJjaGl2ZUNoZWNrPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL2FyY2hpdmUvY2hlY2tcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5jb250ZW50LndyaXRlXCIpfSxfLnRlYW1UZWFtRm9sZGVyQ3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL2NyZWF0ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9kYXRhLmNvbnRlbnQud3JpdGVcIil9LF8udGVhbVRlYW1Gb2xkZXJHZXRJbmZvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL2dldF9pbmZvXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuY29udGVudC5yZWFkXCIpfSxfLnRlYW1UZWFtRm9sZGVyTGlzdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS90ZWFtX2ZvbGRlci9saXN0XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuY29udGVudC5yZWFkXCIpfSxfLnRlYW1UZWFtRm9sZGVyTGlzdENvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL2xpc3QvY29udGludWVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5jb250ZW50LnJlYWRcIil9LF8udGVhbVRlYW1Gb2xkZXJQZXJtYW5lbnRseURlbGV0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS90ZWFtX2ZvbGRlci9wZXJtYW5lbnRseV9kZWxldGVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5jb250ZW50LndyaXRlXCIpfSxfLnRlYW1UZWFtRm9sZGVyUmVuYW1lPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL3JlbmFtZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9kYXRhLmNvbnRlbnQud3JpdGVcIil9LF8udGVhbVRlYW1Gb2xkZXJVcGRhdGVTeW5jU2V0dGluZ3M9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vdGVhbV9mb2xkZXIvdXBkYXRlX3N5bmNfc2V0dGluZ3NcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5jb250ZW50LndyaXRlXCIpfSxfLnRlYW1Ub2tlbkdldEF1dGhlbnRpY2F0ZWRBZG1pbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3Rva2VuL2dldF9hdXRoZW50aWNhdGVkX2FkbWluXCIsbnVsbCxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2luZm8ucmVhZFwiKX0sXy50ZWFtTG9nR2V0RXZlbnRzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtX2xvZy9nZXRfZXZlbnRzXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJldmVudHMucmVhZFwiKX0sXy50ZWFtTG9nR2V0RXZlbnRzQ29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW1fbG9nL2dldF9ldmVudHMvY29udGludWVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImV2ZW50cy5yZWFkXCIpfSxfLnVzZXJzRmVhdHVyZXNHZXRWYWx1ZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInVzZXJzL2ZlYXR1cmVzL2dldF92YWx1ZXNcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImFjY291bnRfaW5mby5yZWFkXCIpfSxfLnVzZXJzR2V0QWNjb3VudD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidXNlcnMvZ2V0X2FjY291bnRcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy51c2Vyc0dldEFjY291bnRCYXRjaD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidXNlcnMvZ2V0X2FjY291bnRfYmF0Y2hcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy51c2Vyc0dldEN1cnJlbnRBY2NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcInVzZXJzL2dldF9jdXJyZW50X2FjY291bnRcIixudWxsLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImFjY291bnRfaW5mby5yZWFkXCIpfSxfLnVzZXJzR2V0U3BhY2VVc2FnZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ1c2Vycy9nZXRfc3BhY2VfdXNhZ2VcIixudWxsLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImFjY291bnRfaW5mby5yZWFkXCIpfTt2YXIgcT1mdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06bSxyPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpcIi5cIjtyZXR1cm4gcj8odCE9PW0mJnZvaWQgMCE9PWRbZV0mJihlPWRbZV0scj1cIi1cIiksXCJodHRwczovL1wiLmNvbmNhdChlKS5jb25jYXQocikuY29uY2F0KHQsXCIvMi9cIikpOlwiaHR0cHM6Ly9cIi5jb25jYXQodCxcIi8yL1wiKX0sYj1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpoO3JldHVybiBlIT09aCYmKGU9XCJtZXRhLVwiLmNvbmNhdChlKSksXCJodHRwczovL1wiLmNvbmNhdChlLFwiL29hdXRoMi9hdXRob3JpemVcIil9LHY9ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06bSx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpcIi5cIixyPVwiYXBpXCI7cmV0dXJuIGUhPT1tJiYocj1kW3JdLHQ9XCItXCIpLFwiaHR0cHM6Ly9cIi5jb25jYXQocikuY29uY2F0KHQpLmNvbmNhdChlLFwiL29hdXRoMi90b2tlblwiKX07ZnVuY3Rpb24gdyhlKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSkucmVwbGFjZSgvW1xcdTAwN2YtXFx1ZmZmZl0vZyxnKX1mdW5jdGlvbiBrKGUpe3JldHVybiBuZXcgRGF0ZShEYXRlLm5vdygpKzFlMyplKX1mdW5jdGlvbiB5KCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlJiZzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGV8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBtb2R1bGV8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3d9ZnVuY3Rpb24gQSgpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3d9ZnVuY3Rpb24gUygpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSYmc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlfWZ1bmN0aW9uIEMoZSl7cmV0dXJuIGUudG9TdHJpbmcoXCJiYXNlNjRcIikucmVwbGFjZSgvXFwrL2csXCItXCIpLnJlcGxhY2UoL1xcLy9nLFwiX1wiKS5yZXBsYWNlKC89L2csXCJcIil9dmFyIFQsTCxNLFA9ZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiZuKGUsdCl9KHUsZSk7dmFyIHIsaSxvPShyPXUsaT1hKCksZnVuY3Rpb24oKXt2YXIgZSx0PXMocik7aWYoaSl7dmFyIG49cyh0aGlzKS5jb25zdHJ1Y3RvcjtlPVJlZmxlY3QuY29uc3RydWN0KHQsYXJndW1lbnRzLG4pfWVsc2UgZT10LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gYyh0aGlzLGUpfSk7ZnVuY3Rpb24gdShlLHIsaSl7dmFyIHM7cmV0dXJuIHQodGhpcyx1KSwocz1vLmNhbGwodGhpcyxcIlJlc3BvbnNlIGZhaWxlZCB3aXRoIGEgXCIuY29uY2F0KGUsXCIgY29kZVwiKSkpLm5hbWU9XCJEcm9wYm94UmVzcG9uc2VFcnJvclwiLHMuc3RhdHVzPWUscy5oZWFkZXJzPXIscy5lcnJvcj1pLHN9cmV0dXJuIHV9KHUoRXJyb3IpKSxSPWZ1bmN0aW9uIGUocixpLHMpe3QodGhpcyxlKSx0aGlzLnN0YXR1cz1yLHRoaXMuaGVhZGVycz1pLHRoaXMucmVzdWx0PXN9O2Z1bmN0aW9uIEYoZSl7cmV0dXJuIGUudGV4dCgpLnRoZW4oKGZ1bmN0aW9uKHQpe3ZhciByO3RyeXtyPUpTT04ucGFyc2UodCl9Y2F0Y2goZSl7cj10fXRocm93IG5ldyBQKGUuc3RhdHVzLGUuaGVhZGVycyxyKX0pKX1mdW5jdGlvbiBEKGUpe3JldHVybiBlLm9rP2UudGV4dCgpLnRoZW4oKGZ1bmN0aW9uKHQpe3ZhciByO3RyeXtyPUpTT04ucGFyc2UodCl9Y2F0Y2goZSl7cj10fXJldHVybiBuZXcgUihlLnN0YXR1cyxlLmhlYWRlcnMscil9KSk6RihlKX12YXIgRz1bXCJsZWdhY3lcIixcIm9mZmxpbmVcIixcIm9ubGluZVwiXSxVPVtcImNvZGVcIixcInRva2VuXCJdLHg9W1wibm9uZVwiLFwidXNlclwiLFwidGVhbVwiXSxFPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShyKXt0KHRoaXMsZSkscj1yfHx7fSxBKCk/KFQ9d2luZG93LmZldGNoLmJpbmQod2luZG93KSxMPXdpbmRvdy5jcnlwdG98fHdpbmRvdy5tc0NyeXB0byk6UygpPyhUPXNlbGYuZmV0Y2guYmluZChzZWxmKSxMPXNlbGYuY3J5cHRvKTooVD1yZXF1aXJlKFwibm9kZS1mZXRjaFwiKSxMPXJlcXVpcmUoXCJjcnlwdG9cIikpLE09XCJ1bmRlZmluZWRcIj09dHlwZW9mIFRleHRFbmNvZGVyP3JlcXVpcmUoXCJ1dGlsXCIpLlRleHRFbmNvZGVyOlRleHRFbmNvZGVyLHRoaXMuZmV0Y2g9ci5mZXRjaHx8VCx0aGlzLmFjY2Vzc1Rva2VuPXIuYWNjZXNzVG9rZW4sdGhpcy5hY2Nlc3NUb2tlbkV4cGlyZXNBdD1yLmFjY2Vzc1Rva2VuRXhwaXJlc0F0LHRoaXMucmVmcmVzaFRva2VuPXIucmVmcmVzaFRva2VuLHRoaXMuY2xpZW50SWQ9ci5jbGllbnRJZCx0aGlzLmNsaWVudFNlY3JldD1yLmNsaWVudFNlY3JldCx0aGlzLmRvbWFpbj1yLmRvbWFpbix0aGlzLmRvbWFpbkRlbGltaXRlcj1yLmRvbWFpbkRlbGltaXRlcix0aGlzLmN1c3RvbUhlYWRlcnM9ci5jdXN0b21IZWFkZXJzLHRoaXMuZGF0YU9uQm9keT1yLmRhdGFPbkJvZHl9cmV0dXJuIGkoZSxbe2tleTpcInNldEFjY2Vzc1Rva2VuXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5hY2Nlc3NUb2tlbj1lfX0se2tleTpcImdldEFjY2Vzc1Rva2VuXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbn19LHtrZXk6XCJzZXRDbGllbnRJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuY2xpZW50SWQ9ZX19LHtrZXk6XCJnZXRDbGllbnRJZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xpZW50SWR9fSx7a2V5Olwic2V0Q2xpZW50U2VjcmV0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5jbGllbnRTZWNyZXQ9ZX19LHtrZXk6XCJnZXRDbGllbnRTZWNyZXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsaWVudFNlY3JldH19LHtrZXk6XCJnZXRSZWZyZXNoVG9rZW5cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlZnJlc2hUb2tlbn19LHtrZXk6XCJzZXRSZWZyZXNoVG9rZW5cIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnJlZnJlc2hUb2tlbj1lfX0se2tleTpcImdldEFjY2Vzc1Rva2VuRXhwaXJlc0F0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbkV4cGlyZXNBdH19LHtrZXk6XCJzZXRBY2Nlc3NUb2tlbkV4cGlyZXNBdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuYWNjZXNzVG9rZW5FeHBpcmVzQXQ9ZX19LHtrZXk6XCJzZXRDb2RlVmVyaWZpZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmNvZGVWZXJpZmllcj1lfX0se2tleTpcImdldENvZGVWZXJpZmllclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29kZVZlcmlmaWVyfX0se2tleTpcImdlbmVyYXRlQ29kZUNoYWxsZW5nZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGUsdD10aGlzLHI9KG5ldyBNKS5lbmNvZGUodGhpcy5jb2RlVmVyaWZpZXIpO2lmKEEoKXx8UygpKXJldHVybiBMLnN1YnRsZS5kaWdlc3QoXCJTSEEtMjU2XCIscikudGhlbigoZnVuY3Rpb24ocil7dmFyIGk9YnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkocikpKTtlPUMoaSkuc3Vic3RyKDAsMTI4KSx0LmNvZGVDaGFsbGVuZ2U9ZX0pKTt2YXIgaT1MLmNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKHIpLmRpZ2VzdCgpO3JldHVybiBlPUMoaSksdGhpcy5jb2RlQ2hhbGxlbmdlPWUsUHJvbWlzZS5yZXNvbHZlKCl9fSx7a2V5OlwiZ2VuZXJhdGVQS0NFQ29kZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlO2lmKEEoKXx8UygpKXt2YXIgdD1uZXcgVWludDhBcnJheSgxMjgpLHI9TC5nZXRSYW5kb21WYWx1ZXModCk7ZT1DKGJ0b2EocikpLnN1YnN0cigwLDEyOCl9ZWxzZXtlPUMoTC5yYW5kb21CeXRlcygxMjgpKS5zdWJzdHIoMCwxMjgpfXJldHVybiB0aGlzLmNvZGVWZXJpZmllcj1lLHRoaXMuZ2VuZXJhdGVDb2RlQ2hhbGxlbmdlKCl9fSx7a2V5OlwiZ2V0QXV0aGVudGljYXRpb25VcmxcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByLGk9dGhpcyxzPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpcInRva2VuXCIsbj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106bnVsbCxhPWFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdP2FyZ3VtZW50c1s0XTpudWxsLG89YXJndW1lbnRzLmxlbmd0aD41JiZ2b2lkIDAhPT1hcmd1bWVudHNbNV0/YXJndW1lbnRzWzVdOlwibm9uZVwiLHU9YXJndW1lbnRzLmxlbmd0aD42JiZ2b2lkIDAhPT1hcmd1bWVudHNbNl0mJmFyZ3VtZW50c1s2XSxjPXRoaXMuZ2V0Q2xpZW50SWQoKSxwPWIodGhpcy5kb21haW4pO2lmKCFjKXRocm93IEVycm9yKFwiQSBjbGllbnQgaWQgaXMgcmVxdWlyZWQuIFlvdSBjYW4gc2V0IHRoZSBjbGllbnQgaWQgdXNpbmcgLnNldENsaWVudElkKCkuXCIpO2lmKFwiY29kZVwiIT09cyYmIWUpdGhyb3cgRXJyb3IoXCJBIHJlZGlyZWN0IHVyaSBpcyByZXF1aXJlZC5cIik7aWYoIVUuaW5jbHVkZXMocykpdGhyb3cgRXJyb3IoXCJBdXRob3JpemF0aW9uIHR5cGUgbXVzdCBiZSBjb2RlIG9yIHRva2VuXCIpO2lmKG4mJiFHLmluY2x1ZGVzKG4pKXRocm93IEVycm9yKFwiVG9rZW4gQWNjZXNzIFR5cGUgbXVzdCBiZSBsZWdhY3ksIG9mZmxpbmUsIG9yIG9ubGluZVwiKTtpZihhJiYhKGEgaW5zdGFuY2VvZiBBcnJheSkpdGhyb3cgRXJyb3IoXCJTY29wZSBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3NcIik7aWYoIXguaW5jbHVkZXMobykpdGhyb3cgRXJyb3IoXCJpbmNsdWRlR3JhbnRlZFNjb3BlcyBtdXN0IGJlIG5vbmUsIHVzZXIsIG9yIHRlYW1cIik7cmV0dXJuIHI9XCJjb2RlXCI9PT1zP1wiXCIuY29uY2F0KHAsXCI/cmVzcG9uc2VfdHlwZT1jb2RlJmNsaWVudF9pZD1cIikuY29uY2F0KGMpOlwiXCIuY29uY2F0KHAsXCI/cmVzcG9uc2VfdHlwZT10b2tlbiZjbGllbnRfaWQ9XCIpLmNvbmNhdChjKSxlJiYocis9XCImcmVkaXJlY3RfdXJpPVwiLmNvbmNhdChlKSksdCYmKHIrPVwiJnN0YXRlPVwiLmNvbmNhdCh0KSksbiYmKHIrPVwiJnRva2VuX2FjY2Vzc190eXBlPVwiLmNvbmNhdChuKSksYSYmKHIrPVwiJnNjb3BlPVwiLmNvbmNhdChhLmpvaW4oXCIgXCIpKSksXCJub25lXCIhPT1vJiYocis9XCImaW5jbHVkZV9ncmFudGVkX3Njb3Blcz1cIi5jb25jYXQobykpLHU/dGhpcy5nZW5lcmF0ZVBLQ0VDb2RlcygpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIHIrPVwiJmNvZGVfY2hhbGxlbmdlX21ldGhvZD1TMjU2XCIscis9XCImY29kZV9jaGFsbGVuZ2U9XCIuY29uY2F0KGkuY29kZUNoYWxsZW5nZSl9KSk6UHJvbWlzZS5yZXNvbHZlKHIpfX0se2tleTpcImdldEFjY2Vzc1Rva2VuRnJvbUNvZGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuZ2V0Q2xpZW50SWQoKSxpPXRoaXMuZ2V0Q2xpZW50U2VjcmV0KCk7aWYoIXIpdGhyb3cgRXJyb3IoXCJBIGNsaWVudCBpZCBpcyByZXF1aXJlZC4gWW91IGNhbiBzZXQgdGhlIGNsaWVudCBpZCB1c2luZyAuc2V0Q2xpZW50SWQoKS5cIik7dmFyIHM9dih0aGlzLmRvbWFpbix0aGlzLmRvbWFpbkRlbGltaXRlcik7aWYocys9XCI/Z3JhbnRfdHlwZT1hdXRob3JpemF0aW9uX2NvZGVcIixzKz1cIiZjb2RlPVwiLmNvbmNhdCh0KSxzKz1cIiZjbGllbnRfaWQ9XCIuY29uY2F0KHIpLGkpcys9XCImY2xpZW50X3NlY3JldD1cIi5jb25jYXQoaSk7ZWxzZXtpZighdGhpcy5jb2RlVmVyaWZpZXIpdGhyb3cgRXJyb3IoXCJZb3UgbXVzdCB1c2UgUEtDRSB3aGVuIGdlbmVyYXRpbmcgdGhlIGF1dGhvcml6YXRpb24gVVJMIHRvIG5vdCBpbmNsdWRlIGEgY2xpZW50IHNlY3JldFwiKTtzKz1cIiZjb2RlX3ZlcmlmaWVyPVwiLmNvbmNhdCh0aGlzLmNvZGVWZXJpZmllcil9ZSYmKHMrPVwiJnJlZGlyZWN0X3VyaT1cIi5jb25jYXQoZSkpO3JldHVybiB0aGlzLmZldGNoKHMse21ldGhvZDpcIlBPU1RcIixoZWFkZXJzOntcIkNvbnRlbnQtVHlwZVwiOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJ9fSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIEQoZSl9KSl9fSx7a2V5OlwiY2hlY2tBbmRSZWZyZXNoQWNjZXNzVG9rZW5cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuZ2V0UmVmcmVzaFRva2VuKCkmJnRoaXMuZ2V0Q2xpZW50SWQoKSx0PSF0aGlzLmdldEFjY2Vzc1Rva2VuRXhwaXJlc0F0KCl8fG5ldyBEYXRlKERhdGUubm93KCkrM2U1KT49dGhpcy5nZXRBY2Nlc3NUb2tlbkV4cGlyZXNBdCgpLHI9IXRoaXMuZ2V0QWNjZXNzVG9rZW4oKTtyZXR1cm4odHx8cikmJmU/dGhpcy5yZWZyZXNoQWNjZXNzVG9rZW4oKTpQcm9taXNlLnJlc29sdmUoKX19LHtrZXk6XCJyZWZyZXNoQWNjZXNzVG9rZW5cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06bnVsbCxyPXRoaXMuZ2V0Q2xpZW50SWQoKSxpPXRoaXMuZ2V0Q2xpZW50U2VjcmV0KCk7aWYoIXIpdGhyb3cgRXJyb3IoXCJBIGNsaWVudCBpZCBpcyByZXF1aXJlZC4gWW91IGNhbiBzZXQgdGhlIGNsaWVudCBpZCB1c2luZyAuc2V0Q2xpZW50SWQoKS5cIik7aWYodCYmISh0IGluc3RhbmNlb2YgQXJyYXkpKXRocm93IEVycm9yKFwiU2NvcGUgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzXCIpO3ZhciBzPXYodGhpcy5kb21haW4sdGhpcy5kb21haW5EZWxpbWl0ZXIpLG49e2hlYWRlcnM6e1wiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uXCJ9LG1ldGhvZDpcIlBPU1RcIn07aWYodGhpcy5kYXRhT25Cb2R5KXt2YXIgYT17Z3JhbnRfdHlwZTpcInJlZnJlc2hfdG9rZW5cIixjbGllbnRfaWQ6cixyZWZyZXNoX3Rva2VuOnRoaXMuZ2V0UmVmcmVzaFRva2VuKCl9O2kmJihhLmNsaWVudF9zZWNyZXQ9aSksdCYmKGEuc2NvcGU9dC5qb2luKFwiIFwiKSksbi5ib2R5PWF9ZWxzZSBzKz1cIj9ncmFudF90eXBlPXJlZnJlc2hfdG9rZW4mcmVmcmVzaF90b2tlbj1cIi5jb25jYXQodGhpcy5nZXRSZWZyZXNoVG9rZW4oKSkscys9XCImY2xpZW50X2lkPVwiLmNvbmNhdChyKSxpJiYocys9XCImY2xpZW50X3NlY3JldD1cIi5jb25jYXQoaSkpLHQmJihzKz1cIiZzY29wZT1cIi5jb25jYXQodC5qb2luKFwiIFwiKSkpO3JldHVybiB0aGlzLmZldGNoKHMsbikudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIEQoZSl9KSkudGhlbigoZnVuY3Rpb24odCl7ZS5zZXRBY2Nlc3NUb2tlbih0LnJlc3VsdC5hY2Nlc3NfdG9rZW4pLGUuc2V0QWNjZXNzVG9rZW5FeHBpcmVzQXQoayh0LnJlc3VsdC5leHBpcmVzX2luKSl9KSl9fV0pLGV9KCksQj1cInVuZGVmaW5lZFwiPT10eXBlb2YgYnRvYT9mdW5jdGlvbihlKXtyZXR1cm4gQnVmZmVyLmZyb20oZSkudG9TdHJpbmcoXCJiYXNlNjRcIil9OmJ0b2E7ZS5Ecm9wYm94PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShyKXt0KHRoaXMsZSksdGhpcy5hdXRoPShyPXJ8fHt9KS5hdXRoP3IuYXV0aDpuZXcgRShyKSx0aGlzLmZldGNoPXIuZmV0Y2h8fHRoaXMuYXV0aC5mZXRjaCx0aGlzLnNlbGVjdFVzZXI9ci5zZWxlY3RVc2VyLHRoaXMuc2VsZWN0QWRtaW49ci5zZWxlY3RBZG1pbix0aGlzLnBhdGhSb290PXIucGF0aFJvb3QsdGhpcy5kb21haW49ci5kb21haW58fHRoaXMuYXV0aC5kb21haW4sdGhpcy5kb21haW5EZWxpbWl0ZXI9ci5kb21haW5EZWxpbWl0ZXJ8fHRoaXMuYXV0aC5kb21haW5EZWxpbWl0ZXIsdGhpcy5jdXN0b21IZWFkZXJzPXIuY3VzdG9tSGVhZGVyc3x8dGhpcy5hdXRoLmN1c3RvbUhlYWRlcnMsT2JqZWN0LmFzc2lnbih0aGlzLF8pfXJldHVybiBpKGUsW3trZXk6XCJyZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsaSxzKXtzd2l0Y2gocyl7Y2FzZVwicnBjXCI6cmV0dXJuIHRoaXMucnBjUmVxdWVzdChlLHQscixpKTtjYXNlXCJkb3dubG9hZFwiOnJldHVybiB0aGlzLmRvd25sb2FkUmVxdWVzdChlLHQscixpKTtjYXNlXCJ1cGxvYWRcIjpyZXR1cm4gdGhpcy51cGxvYWRSZXF1ZXN0KGUsdCxyLGkpO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJlcXVlc3Qgc3R5bGU6IFwiLmNvbmNhdChzKSl9fX0se2tleTpcInJwY1JlcXVlc3RcIix2YWx1ZTpmdW5jdGlvbihlLHQscixpKXt2YXIgcz10aGlzO3JldHVybiB0aGlzLmF1dGguY2hlY2tBbmRSZWZyZXNoQWNjZXNzVG9rZW4oKS50aGVuKChmdW5jdGlvbigpe3ZhciBlPXttZXRob2Q6XCJQT1NUXCIsYm9keTp0P0pTT04uc3RyaW5naWZ5KHQpOm51bGwsaGVhZGVyczp7fX07cmV0dXJuIHQmJihlLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl09XCJhcHBsaWNhdGlvbi9qc29uXCIpLHMuc2V0QXV0aEhlYWRlcnMocixlKSxzLnNldENvbW1vbkhlYWRlcnMoZSksZX0pKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gcy5mZXRjaChxKGkscy5kb21haW4scy5kb21haW5EZWxpbWl0ZXIpK2UsdCl9KSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIEQoZSl9KSl9fSx7a2V5OlwiZG93bmxvYWRSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsaSl7dmFyIHM9dGhpcztyZXR1cm4gdGhpcy5hdXRoLmNoZWNrQW5kUmVmcmVzaEFjY2Vzc1Rva2VuKCkudGhlbigoZnVuY3Rpb24oKXt2YXIgZT17bWV0aG9kOlwiUE9TVFwiLGhlYWRlcnM6e1wiRHJvcGJveC1BUEktQXJnXCI6dyh0KX19O3JldHVybiBzLnNldEF1dGhIZWFkZXJzKHIsZSkscy5zZXRDb21tb25IZWFkZXJzKGUpLGV9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHMuZmV0Y2gocShpLHMuZG9tYWluLHMuZG9tYWluRGVsaW1pdGVyKStlLHQpfSkpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZS5vaz9uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7eSgpP2UuYmxvYigpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiB0KGUpfSkpOmUuYnVmZmVyKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIHQoZSl9KSl9KSkudGhlbigoZnVuY3Rpb24odCl7dmFyIHI9SlNPTi5wYXJzZShlLmhlYWRlcnMuZ2V0KFwiZHJvcGJveC1hcGktcmVzdWx0XCIpKTtyZXR1cm4geSgpP3IuZmlsZUJsb2I9dDpyLmZpbGVCaW5hcnk9dCxuZXcgUihlLnN0YXR1cyxlLmhlYWRlcnMscil9KSk6RihlKX0oZSl9KSl9fSx7a2V5OlwidXBsb2FkUmVxdWVzdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLGkpe3ZhciBzPXRoaXM7cmV0dXJuIHRoaXMuYXV0aC5jaGVja0FuZFJlZnJlc2hBY2Nlc3NUb2tlbigpLnRoZW4oKGZ1bmN0aW9uKCl7dmFyIGU9dC5jb250ZW50cztkZWxldGUgdC5jb250ZW50czt2YXIgaT17Ym9keTplLG1ldGhvZDpcIlBPU1RcIixoZWFkZXJzOntcIkNvbnRlbnQtVHlwZVwiOlwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXCJEcm9wYm94LUFQSS1BcmdcIjp3KHQpfX07cmV0dXJuIHMuc2V0QXV0aEhlYWRlcnMocixpKSxzLnNldENvbW1vbkhlYWRlcnMoaSksaX0pKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gcy5mZXRjaChxKGkscy5kb21haW4scy5kb21haW5EZWxpbWl0ZXIpK2UsdCl9KSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIEQoZSl9KSl9fSx7a2V5Olwic2V0QXV0aEhlYWRlcnNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKGUuc3BsaXQoXCIsXCIpLmxlbmd0aD4xKXt2YXIgcj1lLnJlcGxhY2UoXCIgXCIsXCJcIikuc3BsaXQoXCIsXCIpO3IuaW5jbHVkZXMobCkmJnRoaXMuYXV0aC5nZXRBY2Nlc3NUb2tlbigpP2U9bDpyLmluY2x1ZGVzKGYpJiZ0aGlzLmF1dGguZ2V0QWNjZXNzVG9rZW4oKT9lPWY6ci5pbmNsdWRlcyhwKSYmKGU9cCl9c3dpdGNoKGUpe2Nhc2UgcDppZih0aGlzLmF1dGguY2xpZW50SWQmJnRoaXMuYXV0aC5jbGllbnRTZWNyZXQpe3ZhciBpPUIoXCJcIi5jb25jYXQodGhpcy5hdXRoLmNsaWVudElkLFwiOlwiKS5jb25jYXQodGhpcy5hdXRoLmNsaWVudFNlY3JldCkpO3QuaGVhZGVycy5BdXRob3JpemF0aW9uPVwiQmFzaWMgXCIuY29uY2F0KGkpfWJyZWFrO2Nhc2UgZjpjYXNlIGw6dGhpcy5hdXRoLmdldEFjY2Vzc1Rva2VuKCkmJih0LmhlYWRlcnMuQXV0aG9yaXphdGlvbj1cIkJlYXJlciBcIi5jb25jYXQodGhpcy5hdXRoLmdldEFjY2Vzc1Rva2VuKCkpKTticmVhaztjYXNlXCJub2F1dGhcIjpjYXNlXCJjb29raWVcIjpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiVW5oYW5kbGVkIGF1dGggdHlwZTogXCIuY29uY2F0KGUpKX19fSx7a2V5Olwic2V0Q29tbW9uSGVhZGVyc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7KHRoaXMuc2VsZWN0VXNlciYmKGUuaGVhZGVyc1tcIkRyb3Bib3gtQVBJLVNlbGVjdC1Vc2VyXCJdPXRoaXMuc2VsZWN0VXNlciksdGhpcy5zZWxlY3RBZG1pbiYmKGUuaGVhZGVyc1tcIkRyb3Bib3gtQVBJLVNlbGVjdC1BZG1pblwiXT10aGlzLnNlbGVjdEFkbWluKSx0aGlzLnBhdGhSb290JiYoZS5oZWFkZXJzW1wiRHJvcGJveC1BUEktUGF0aC1Sb290XCJdPXRoaXMucGF0aFJvb3QpLHRoaXMuY3VzdG9tSGVhZGVycykmJk9iamVjdC5rZXlzKHRoaXMuY3VzdG9tSGVhZGVycykuZm9yRWFjaCgoZnVuY3Rpb24ocil7ZS5oZWFkZXJzW3JdPXQuY3VzdG9tSGVhZGVyc1tyXX0pKX19XSksZX0oKSxlLkRyb3Bib3hBdXRoPUUsZS5Ecm9wYm94UmVzcG9uc2U9UixlLkRyb3Bib3hSZXNwb25zZUVycm9yPVAsT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGVhcmN1dDtcblxuZnVuY3Rpb24gZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcblxuICAgIGRpbSA9IGRpbSB8fCAyO1xuXG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoLFxuICAgICAgICBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSxcbiAgICAgICAgdHJpYW5nbGVzID0gW107XG5cbiAgICBpZiAoIW91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYpIHJldHVybiB0cmlhbmdsZXM7XG5cbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcblxuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcbiAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcbiAgICAgICAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIGludlNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgICAgICBpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDMyNzY3IC8gaW52U2l6ZSA6IDA7XG4gICAgfVxuXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG4gICAgdmFyIGksIGxhc3Q7XG5cbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICAgIHByZXYsIG5leHQ7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0gfCAwKTtcblxuICAgICAgICAgICAgcmVtb3ZlTm9kZShlYXIpO1xuXG4gICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0ZXggbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuICAgIHZhciBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgeDAgPSBheCA8IGJ4ID8gKGF4IDwgY3ggPyBheCA6IGN4KSA6IChieCA8IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkwID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICB4MSA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTEgPSBheSA+IGJ5ID8gKGF5ID4gY3kgPyBheSA6IGN5KSA6IChieSA+IGN5ID8gYnkgOiBjeSk7XG5cbiAgICB2YXIgcCA9IGMubmV4dDtcbiAgICB3aGlsZSAocCAhPT0gYSkge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIHZhciBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgeDAgPSBheCA8IGJ4ID8gKGF4IDwgY3ggPyBheCA6IGN4KSA6IChieCA8IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkwID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICB4MSA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTEgPSBheSA+IGJ5ID8gKGF5ID4gY3kgPyBheSA6IGN5KSA6IChieSA+IGN5ID8gYnkgOiBjeSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIHZhciBtaW5aID0gek9yZGVyKHgwLCB5MCwgbWluWCwgbWluWSwgaW52U2l6ZSksXG4gICAgICAgIG1heFogPSB6T3JkZXIoeDEsIHkxLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBwID0gZWFyLnByZXZaLFxuICAgICAgICBuID0gZWFyLm5leHRaO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gYm90aCBkaXJlY3Rpb25zXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuXG4gICAgICAgIGlmIChuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG4gICAgd2hpbGUgKG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcbmZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBhID0gcC5wcmV2LFxuICAgICAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xuXG4gICAgICAgIGlmICghZXF1YWxzKGEsIGIpICYmIGludGVyc2VjdHMoYSwgcCwgcC5uZXh0LCBiKSAmJiBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkpIHtcblxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSB8IDApO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhwKTtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cblxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gICAgcmV0dXJuIGEueCAtIGIueDtcbn1cblxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBicmlkZ2UgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmICghYnJpZGdlKSB7XG4gICAgICAgIHJldHVybiBvdXRlck5vZGU7XG4gICAgfVxuXG4gICAgdmFyIGJyaWRnZVJldmVyc2UgPSBzcGxpdFBvbHlnb24oYnJpZGdlLCBob2xlKTtcblxuICAgIC8vIGZpbHRlciBjb2xsaW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgIGZpbHRlclBvaW50cyhicmlkZ2VSZXZlcnNlLCBicmlkZ2VSZXZlcnNlLm5leHQpO1xuICAgIHJldHVybiBmaWx0ZXJQb2ludHMoYnJpZGdlLCBicmlkZ2UubmV4dCk7XG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBwID0gb3V0ZXJOb2RlLFxuICAgICAgICBoeCA9IGhvbGUueCxcbiAgICAgICAgaHkgPSBob2xlLnksXG4gICAgICAgIHF4ID0gLUluZmluaXR5LFxuICAgICAgICBtO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICBkbyB7XG4gICAgICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHJldHVybiBtOyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsZWZ0bW9zdCBlbmRwb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBzdG9wID0gbSxcbiAgICAgICAgbXggPSBtLngsXG4gICAgICAgIG15ID0gbS55LFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgdGFuO1xuXG4gICAgcCA9IG07XG5cbiAgICBkbyB7XG4gICAgICAgIGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKGxvY2FsbHlJbnNpZGUocCwgaG9sZSkgJiZcbiAgICAgICAgICAgICAgICAodGFuIDwgdGFuTWluIHx8ICh0YW4gPT09IHRhbk1pbiAmJiAocC54ID4gbS54IHx8IChwLnggPT09IG0ueCAmJiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSkpKSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0b3ApO1xuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIHdoZXRoZXIgc2VjdG9yIGluIHZlcnRleCBtIGNvbnRhaW5zIHNlY3RvciBpbiB2ZXJ0ZXggcCBpbiB0aGUgc2FtZSBjb29yZGluYXRlc1xuZnVuY3Rpb24gc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkge1xuICAgIHJldHVybiBhcmVhKG0ucHJldiwgbSwgcC5wcmV2KSA8IDAgJiYgYXJlYShwLm5leHQsIG0sIG0ubmV4dCkgPCAwO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IDApIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9ICh4IC0gbWluWCkgKiBpbnZTaXplIHwgMDtcbiAgICB5ID0gKHkgLSBtaW5ZKSAqIGludlNpemUgfCAwO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCB8fCAocC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpKSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSA+PSAoYXggLSBweCkgKiAoY3kgLSBweSkgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpID49IChieCAtIHB4KSAqIChheSAtIHB5KSAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgPj0gKGN4IC0gcHgpICogKGJ5IC0gcHkpO1xufVxuXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiYgLy8gZG9uZXMndCBpbnRlcnNlY3Qgb3RoZXIgZWRnZXNcbiAgICAgICAgICAgKGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYikgJiYgLy8gbG9jYWxseSB2aXNpYmxlXG4gICAgICAgICAgICAoYXJlYShhLnByZXYsIGEsIGIucHJldikgfHwgYXJlYShhLCBiLnByZXYsIGIpKSB8fCAvLyBkb2VzIG5vdCBjcmVhdGUgb3Bwb3NpdGUtZmFjaW5nIHNlY3RvcnNcbiAgICAgICAgICAgIGVxdWFscyhhLCBiKSAmJiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA+IDAgJiYgYXJlYShiLnByZXYsIGIsIGIubmV4dCkgPiAwKTsgLy8gc3BlY2lhbCB6ZXJvLWxlbmd0aCBjYXNlXG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgdmFyIG8xID0gc2lnbihhcmVhKHAxLCBxMSwgcDIpKTtcbiAgICB2YXIgbzIgPSBzaWduKGFyZWEocDEsIHExLCBxMikpO1xuICAgIHZhciBvMyA9IHNpZ24oYXJlYShwMiwgcTIsIHAxKSk7XG4gICAgdmFyIG80ID0gc2lnbihhcmVhKHAyLCBxMiwgcTEpKTtcblxuICAgIGlmIChvMSAhPT0gbzIgJiYgbzMgIT09IG80KSByZXR1cm4gdHJ1ZTsgLy8gZ2VuZXJhbCBjYXNlXG5cbiAgICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBwMiBhcmUgY29sbGluZWFyIGFuZCBwMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBxMiBhcmUgY29sbGluZWFyIGFuZCBxMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzMgPT09IDAgJiYgb25TZWdtZW50KHAyLCBwMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBwMSBhcmUgY29sbGluZWFyIGFuZCBwMSBsaWVzIG9uIHAycTJcbiAgICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBxMSBhcmUgY29sbGluZWFyIGFuZCBxMSBsaWVzIG9uIHAycTJcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gZm9yIGNvbGxpbmVhciBwb2ludHMgcCwgcSwgciwgY2hlY2sgaWYgcG9pbnQgcSBsaWVzIG9uIHNlZ21lbnQgcHJcbmZ1bmN0aW9uIG9uU2VnbWVudChwLCBxLCByKSB7XG4gICAgcmV0dXJuIHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSAmJiBxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSk7XG59XG5cbmZ1bmN0aW9uIHNpZ24obnVtKSB7XG4gICAgcmV0dXJuIG51bSA+IDAgPyAxIDogbnVtIDwgMCA/IC0xIDogMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgcCA9IGE7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID9cbiAgICAgICAgYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxuICAgICAgICBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgICB2YXIgcCA9IGEsXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxuICAgICAgICBweCA9IChhLnggKyBiLngpIC8gMixcbiAgICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XG4gICAgZG8ge1xuICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxuICAgICAgICAgICAgICAgIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gICAgLy8gdmVydGV4IGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG4gICAgdGhpcy5pID0gaTtcblxuICAgIC8vIHZlcnRleCBjb29yZGluYXRlc1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSAwO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cblxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgaiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qXG5cbiBDb3B5cmlnaHQgMjAwMCwgU2lsaWNvbiBHcmFwaGljcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuIENvcHlyaWdodCAyMDE1LCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbiByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBpbmNsdWRpbmcgdGhlIGRhdGVzIG9mIGZpcnN0IHB1YmxpY2F0aW9uIGFuZFxuIGVpdGhlciB0aGlzIHBlcm1pc3Npb24gbm90aWNlIG9yIGEgcmVmZXJlbmNlIHRvIGh0dHA6Ly9vc3Muc2dpLmNvbS9wcm9qZWN0cy9GcmVlQi9cbiBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTFxuIFNJTElDT04gR1JBUEhJQ1MsIElOQy4gQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1JcbiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4gT3JpZ2luYWwgQ29kZS4gVGhlIE9yaWdpbmFsIENvZGUgaXM6IE9wZW5HTCBTYW1wbGUgSW1wbGVtZW50YXRpb24sXG4gVmVyc2lvbiAxLjIuMSwgcmVsZWFzZWQgSmFudWFyeSAyNiwgMjAwMCwgZGV2ZWxvcGVkIGJ5IFNpbGljb24gR3JhcGhpY3MsXG4gSW5jLiBUaGUgT3JpZ2luYWwgQ29kZSBpcyBDb3B5cmlnaHQgKGMpIDE5OTEtMjAwMCBTaWxpY29uIEdyYXBoaWNzLCBJbmMuXG4gQ29weXJpZ2h0IGluIGFueSBwb3J0aW9ucyBjcmVhdGVkIGJ5IHRoaXJkIHBhcnRpZXMgaXMgYXMgaW5kaWNhdGVkXG4gZWxzZXdoZXJlIGhlcmVpbi4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiovXG4ndXNlIHN0cmljdCc7dmFyIG47ZnVuY3Rpb24gdChhLGIpe3JldHVybiBhLmI9PT1iLmImJmEuYT09PWIuYX1mdW5jdGlvbiB1KGEsYil7cmV0dXJuIGEuYjxiLmJ8fGEuYj09PWIuYiYmYS5hPD1iLmF9ZnVuY3Rpb24gdihhLGIsYyl7dmFyIGQ9Yi5iLWEuYixlPWMuYi1iLmI7cmV0dXJuIDA8ZCtlP2Q8ZT9iLmEtYS5hK2QvKGQrZSkqKGEuYS1jLmEpOmIuYS1jLmErZS8oZCtlKSooYy5hLWEuYSk6MH1mdW5jdGlvbiB4KGEsYixjKXt2YXIgZD1iLmItYS5iLGU9Yy5iLWIuYjtyZXR1cm4gMDxkK2U/KGIuYS1jLmEpKmQrKGIuYS1hLmEpKmU6MH1mdW5jdGlvbiB6KGEsYil7cmV0dXJuIGEuYTxiLmF8fGEuYT09PWIuYSYmYS5iPD1iLmJ9ZnVuY3Rpb24gYWEoYSxiLGMpe3ZhciBkPWIuYS1hLmEsZT1jLmEtYi5hO3JldHVybiAwPGQrZT9kPGU/Yi5iLWEuYitkLyhkK2UpKihhLmItYy5iKTpiLmItYy5iK2UvKGQrZSkqKGMuYi1hLmIpOjB9XG5mdW5jdGlvbiBiYShhLGIsYyl7dmFyIGQ9Yi5hLWEuYSxlPWMuYS1iLmE7cmV0dXJuIDA8ZCtlPyhiLmItYy5iKSpkKyhiLmItYS5iKSplOjB9ZnVuY3Rpb24gY2EoYSl7cmV0dXJuIHUoYS5iLmEsYS5hKX1mdW5jdGlvbiBkYShhKXtyZXR1cm4gdShhLmEsYS5iLmEpfWZ1bmN0aW9uIEEoYSxiLGMsZCl7YT0wPmE/MDphO2M9MD5jPzA6YztyZXR1cm4gYTw9Yz8wPT09Yz8oYitkKS8yOmIrYS8oYStjKSooZC1iKTpkK2MvKGErYykqKGItZCl9O2Z1bmN0aW9uIGVhKGEpe3ZhciBiPUIoYS5iKTtDKGIsYS5jKTtDKGIuYixhLmMpO0QoYixhLmEpO3JldHVybiBifWZ1bmN0aW9uIEUoYSxiKXt2YXIgYz0hMSxkPSExO2EhPT1iJiYoYi5hIT09YS5hJiYoZD0hMCxGKGIuYSxhLmEpKSxiLmQhPT1hLmQmJihjPSEwLEcoYi5kLGEuZCkpLEgoYixhKSxkfHwoQyhiLGEuYSksYS5hLmM9YSksY3x8KEQoYixhLmQpLGEuZC5hPWEpKX1mdW5jdGlvbiBJKGEpe3ZhciBiPWEuYixjPSExO2EuZCE9PWEuYi5kJiYoYz0hMCxHKGEuZCxhLmIuZCkpO2EuYz09PWE/RihhLmEsbnVsbCk6KGEuYi5kLmE9SihhKSxhLmEuYz1hLmMsSChhLEooYSkpLGN8fEQoYSxhLmQpKTtiLmM9PT1iPyhGKGIuYSxudWxsKSxHKGIuZCxudWxsKSk6KGEuZC5hPUooYiksYi5hLmM9Yi5jLEgoYixKKGIpKSk7ZmEoYSl9XG5mdW5jdGlvbiBLKGEpe3ZhciBiPUIoYSksYz1iLmI7SChiLGEuZSk7Yi5hPWEuYi5hO0MoYyxiLmEpO2IuZD1jLmQ9YS5kO2I9Yi5iO0goYS5iLEooYS5iKSk7SChhLmIsYik7YS5iLmE9Yi5hO2IuYi5hLmM9Yi5iO2IuYi5kPWEuYi5kO2IuZj1hLmY7Yi5iLmY9YS5iLmY7cmV0dXJuIGJ9ZnVuY3Rpb24gTChhLGIpe3ZhciBjPSExLGQ9QihhKSxlPWQuYjtiLmQhPT1hLmQmJihjPSEwLEcoYi5kLGEuZCkpO0goZCxhLmUpO0goZSxiKTtkLmE9YS5iLmE7ZS5hPWIuYTtkLmQ9ZS5kPWEuZDthLmQuYT1lO2N8fEQoZCxhLmQpO3JldHVybiBkfWZ1bmN0aW9uIEIoYSl7dmFyIGI9bmV3IE0sYz1uZXcgTSxkPWEuYi5oO2MuaD1kO2QuYi5oPWI7Yi5oPWE7YS5iLmg9YztiLmI9YztiLmM9YjtiLmU9YztjLmI9YjtjLmM9YztyZXR1cm4gYy5lPWJ9ZnVuY3Rpb24gSChhLGIpe3ZhciBjPWEuYyxkPWIuYztjLmIuZT1iO2QuYi5lPWE7YS5jPWQ7Yi5jPWN9XG5mdW5jdGlvbiBDKGEsYil7dmFyIGM9Yi5mLGQ9bmV3IE4oYixjKTtjLmU9ZDtiLmY9ZDtjPWQuYz1hO2RvIGMuYT1kLGM9Yy5jO3doaWxlKGMhPT1hKX1mdW5jdGlvbiBEKGEsYil7dmFyIGM9Yi5kLGQ9bmV3IGdhKGIsYyk7Yy5iPWQ7Yi5kPWQ7ZC5hPWE7ZC5jPWIuYztjPWE7ZG8gYy5kPWQsYz1jLmU7d2hpbGUoYyE9PWEpfWZ1bmN0aW9uIGZhKGEpe3ZhciBiPWEuaDthPWEuYi5oO2IuYi5oPWE7YS5iLmg9Yn1mdW5jdGlvbiBGKGEsYil7dmFyIGM9YS5jLGQ9YztkbyBkLmE9YixkPWQuYzt3aGlsZShkIT09Yyk7Yz1hLmY7ZD1hLmU7ZC5mPWM7Yy5lPWR9ZnVuY3Rpb24gRyhhLGIpe3ZhciBjPWEuYSxkPWM7ZG8gZC5kPWIsZD1kLmU7d2hpbGUoZCE9PWMpO2M9YS5kO2Q9YS5iO2QuZD1jO2MuYj1kfTtmdW5jdGlvbiBoYShhKXt2YXIgYj0wO01hdGguYWJzKGFbMV0pPk1hdGguYWJzKGFbMF0pJiYoYj0xKTtNYXRoLmFicyhhWzJdKT5NYXRoLmFicyhhW2JdKSYmKGI9Mik7cmV0dXJuIGJ9O3ZhciBPPTQqMUUxNTA7ZnVuY3Rpb24gUChhLGIpe2EuZis9Yi5mO2EuYi5mKz1iLmIuZn1mdW5jdGlvbiBpYShhLGIsYyl7YT1hLmE7Yj1iLmE7Yz1jLmE7aWYoYi5iLmE9PT1hKXJldHVybiBjLmIuYT09PWE/dShiLmEsYy5hKT8wPj14KGMuYi5hLGIuYSxjLmEpOjA8PXgoYi5iLmEsYy5hLGIuYSk6MD49eChjLmIuYSxhLGMuYSk7aWYoYy5iLmE9PT1hKXJldHVybiAwPD14KGIuYi5hLGEsYi5hKTtiPXYoYi5iLmEsYSxiLmEpO2E9dihjLmIuYSxhLGMuYSk7cmV0dXJuIGI+PWF9ZnVuY3Rpb24gUShhKXthLmEuaT1udWxsO3ZhciBiPWEuZTtiLmEuYz1iLmM7Yi5jLmE9Yi5hO2EuZT1udWxsfWZ1bmN0aW9uIGphKGEsYil7SShhLmEpO2EuYz0hMTthLmE9YjtiLmk9YX1mdW5jdGlvbiBrYShhKXt2YXIgYj1hLmEuYTtkbyBhPVIoYSk7d2hpbGUoYS5hLmE9PT1iKTthLmMmJihiPUwoUyhhKS5hLmIsYS5hLmUpLGphKGEsYiksYT1SKGEpKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIGxhKGEsYixjKXt2YXIgZD1uZXcgbWE7ZC5hPWM7ZC5lPW5hKGEuZixiLmUsZCk7cmV0dXJuIGMuaT1kfWZ1bmN0aW9uIG9hKGEsYil7c3dpdGNoKGEucyl7Y2FzZSAxMDAxMzA6cmV0dXJuIDAhPT0oYiYxKTtjYXNlIDEwMDEzMTpyZXR1cm4gMCE9PWI7Y2FzZSAxMDAxMzI6cmV0dXJuIDA8YjtjYXNlIDEwMDEzMzpyZXR1cm4gMD5iO2Nhc2UgMTAwMTM0OnJldHVybiAyPD1ifHwtMj49Yn1yZXR1cm4hMX1mdW5jdGlvbiBwYShhKXt2YXIgYj1hLmEsYz1iLmQ7Yy5jPWEuZDtjLmE9YjtRKGEpfWZ1bmN0aW9uIFQoYSxiLGMpe2E9Yjtmb3IoYj1iLmE7YSE9PWM7KXthLmM9ITE7dmFyIGQ9UyhhKSxlPWQuYTtpZihlLmEhPT1iLmEpe2lmKCFkLmMpe3BhKGEpO2JyZWFrfWU9TChiLmMuYixlLmIpO2phKGQsZSl9Yi5jIT09ZSYmKEUoSihlKSxlKSxFKGIsZSkpO3BhKGEpO2I9ZC5hO2E9ZH1yZXR1cm4gYn1cbmZ1bmN0aW9uIFUoYSxiLGMsZCxlLGYpe3ZhciBnPSEwO2RvIGxhKGEsYixjLmIpLGM9Yy5jO3doaWxlKGMhPT1kKTtmb3IobnVsbD09PWUmJihlPVMoYikuYS5iLmMpOzspe2Q9UyhiKTtjPWQuYS5iO2lmKGMuYSE9PWUuYSlicmVhaztjLmMhPT1lJiYoRShKKGMpLGMpLEUoSihlKSxjKSk7ZC5mPWIuZi1jLmY7ZC5kPW9hKGEsZC5mKTtiLmI9ITA7IWcmJnFhKGEsYikmJihQKGMsZSksUShiKSxJKGUpKTtnPSExO2I9ZDtlPWN9Yi5iPSEwO2YmJnJhKGEsYil9ZnVuY3Rpb24gc2EoYSxiLGMsZCxlKXt2YXIgZj1bYi5nWzBdLGIuZ1sxXSxiLmdbMl1dO2IuZD1udWxsO2IuZD1hLm8/YS5vKGYsYyxkLGEuYyl8fG51bGw6bnVsbDtudWxsPT09Yi5kJiYoZT9hLm58fChWKGEsMTAwMTU2KSxhLm49ITApOmIuZD1jWzBdKX1cbmZ1bmN0aW9uIHRhKGEsYixjKXt2YXIgZD1bbnVsbCxudWxsLG51bGwsbnVsbF07ZFswXT1iLmEuZDtkWzFdPWMuYS5kO3NhKGEsYi5hLGQsWy41LC41LDAsMF0sITEpO0UoYixjKX1mdW5jdGlvbiB1YShhLGIsYyxkLGUpe3ZhciBmPU1hdGguYWJzKGIuYi1hLmIpK01hdGguYWJzKGIuYS1hLmEpLGc9TWF0aC5hYnMoYy5iLWEuYikrTWF0aC5hYnMoYy5hLWEuYSksaD1lKzE7ZFtlXT0uNSpnLyhmK2cpO2RbaF09LjUqZi8oZitnKTthLmdbMF0rPWRbZV0qYi5nWzBdK2RbaF0qYy5nWzBdO2EuZ1sxXSs9ZFtlXSpiLmdbMV0rZFtoXSpjLmdbMV07YS5nWzJdKz1kW2VdKmIuZ1syXStkW2hdKmMuZ1syXX1cbmZ1bmN0aW9uIHFhKGEsYil7dmFyIGM9UyhiKSxkPWIuYSxlPWMuYTtpZih1KGQuYSxlLmEpKXtpZigwPHgoZS5iLmEsZC5hLGUuYSkpcmV0dXJuITE7aWYoIXQoZC5hLGUuYSkpSyhlLmIpLEUoZCxKKGUpKSxiLmI9Yy5iPSEwO2Vsc2UgaWYoZC5hIT09ZS5hKXt2YXIgYz1hLmUsZj1kLmEuaDtpZigwPD1mKXt2YXIgYz1jLmIsZz1jLmQsaD1jLmUsaz1jLmMsbD1rW2ZdO2dbbF09Z1tjLmFdO2tbZ1tsXV09bDtsPD0tLWMuYSYmKDE+PWw/VyhjLGwpOnUoaFtnW2w+PjFdXSxoW2dbbF1dKT9XKGMsbCk6dmEoYyxsKSk7aFtmXT1udWxsO2tbZl09Yy5iO2MuYj1mfWVsc2UgZm9yKGMuY1stKGYrMSldPW51bGw7MDxjLmEmJm51bGw9PT1jLmNbYy5kW2MuYS0xXV07KS0tYy5hO3RhKGEsSihlKSxkKX19ZWxzZXtpZigwPngoZC5iLmEsZS5hLGQuYSkpcmV0dXJuITE7UihiKS5iPWIuYj0hMDtLKGQuYik7RShKKGUpLGQpfXJldHVybiEwfVxuZnVuY3Rpb24gd2EoYSxiKXt2YXIgYz1TKGIpLGQ9Yi5hLGU9Yy5hLGY9ZC5hLGc9ZS5hLGg9ZC5iLmEsaz1lLmIuYSxsPW5ldyBOO3goaCxhLmEsZik7eChrLGEuYSxnKTtpZihmPT09Z3x8TWF0aC5taW4oZi5hLGguYSk+TWF0aC5tYXgoZy5hLGsuYSkpcmV0dXJuITE7aWYodShmLGcpKXtpZigwPHgoayxmLGcpKXJldHVybiExfWVsc2UgaWYoMD54KGgsZyxmKSlyZXR1cm4hMTt2YXIgcj1oLHA9ZixxPWsseT1nLG0sdzt1KHIscCl8fChtPXIscj1wLHA9bSk7dShxLHkpfHwobT1xLHE9eSx5PW0pO3UocixxKXx8KG09cixyPXEscT1tLG09cCxwPXkseT1tKTt1KHEscCk/dShwLHkpPyhtPXYocixxLHApLHc9dihxLHAseSksMD5tK3cmJihtPS1tLHc9LXcpLGwuYj1BKG0scS5iLHcscC5iKSk6KG09eChyLHEscCksdz0teChyLHkscCksMD5tK3cmJihtPS1tLHc9LXcpLGwuYj1BKG0scS5iLHcseS5iKSk6bC5iPShxLmIrcC5iKS8yO3oocixwKXx8KG09cixyPXAscD1tKTt6KHEseSl8fFxuKG09cSxxPXkseT1tKTt6KHIscSl8fChtPXIscj1xLHE9bSxtPXAscD15LHk9bSk7eihxLHApP3oocCx5KT8obT1hYShyLHEscCksdz1hYShxLHAseSksMD5tK3cmJihtPS1tLHc9LXcpLGwuYT1BKG0scS5hLHcscC5hKSk6KG09YmEocixxLHApLHc9LWJhKHIseSxwKSwwPm0rdyYmKG09LW0sdz0tdyksbC5hPUEobSxxLmEsdyx5LmEpKTpsLmE9KHEuYStwLmEpLzI7dShsLGEuYSkmJihsLmI9YS5hLmIsbC5hPWEuYS5hKTtyPXUoZixnKT9mOmc7dShyLGwpJiYobC5iPXIuYixsLmE9ci5hKTtpZih0KGwsZil8fHQobCxnKSlyZXR1cm4gcWEoYSxiKSwhMTtpZighdChoLGEuYSkmJjA8PXgoaCxhLmEsbCl8fCF0KGssYS5hKSYmMD49eChrLGEuYSxsKSl7aWYoaz09PWEuYSlyZXR1cm4gSyhkLmIpLEUoZS5iLGQpLGI9a2EoYiksZD1TKGIpLmEsVChhLFMoYiksYyksVShhLGIsSihkKSxkLGQsITApLCEwO2lmKGg9PT1hLmEpe0soZS5iKTtFKGQuZSxKKGUpKTtmPWM9YjtnPWYuYS5iLmE7XG5kbyBmPVIoZik7d2hpbGUoZi5hLmIuYT09PWcpO2I9ZjtmPVMoYikuYS5iLmM7Yy5hPUooZSk7ZT1UKGEsYyxudWxsKTtVKGEsYixlLmMsZC5iLmMsZiwhMCk7cmV0dXJuITB9MDw9eChoLGEuYSxsKSYmKFIoYikuYj1iLmI9ITAsSyhkLmIpLGQuYS5iPWEuYS5iLGQuYS5hPWEuYS5hKTswPj14KGssYS5hLGwpJiYoYi5iPWMuYj0hMCxLKGUuYiksZS5hLmI9YS5hLmIsZS5hLmE9YS5hLmEpO3JldHVybiExfUsoZC5iKTtLKGUuYik7RShKKGUpLGQpO2QuYS5iPWwuYjtkLmEuYT1sLmE7ZC5hLmg9eGEoYS5lLGQuYSk7ZD1kLmE7ZT1bMCwwLDAsMF07bD1bZi5kLGguZCxnLmQsay5kXTtkLmdbMF09ZC5nWzFdPWQuZ1syXT0wO3VhKGQsZixoLGUsMCk7dWEoZCxnLGssZSwyKTtzYShhLGQsbCxlLCEwKTtSKGIpLmI9Yi5iPWMuYj0hMDtyZXR1cm4hMX1cbmZ1bmN0aW9uIHJhKGEsYil7Zm9yKHZhciBjPVMoYik7Oyl7Zm9yKDtjLmI7KWI9YyxjPVMoYyk7aWYoIWIuYiYmKGM9YixiPVIoYiksbnVsbD09PWJ8fCFiLmIpKWJyZWFrO2IuYj0hMTt2YXIgZD1iLmEsZT1jLmEsZjtpZihmPWQuYi5hIT09ZS5iLmEpYTp7Zj1iO3ZhciBnPVMoZiksaD1mLmEsaz1nLmEsbD12b2lkIDA7aWYodShoLmIuYSxrLmIuYSkpe2lmKDA+eChoLmIuYSxrLmIuYSxoLmEpKXtmPSExO2JyZWFrIGF9UihmKS5iPWYuYj0hMDtsPUsoaCk7RShrLmIsbCk7bC5kLmM9Zi5kfWVsc2V7aWYoMDx4KGsuYi5hLGguYi5hLGsuYSkpe2Y9ITE7YnJlYWsgYX1mLmI9Zy5iPSEwO2w9SyhrKTtFKGguZSxrLmIpO2wuYi5kLmM9Zi5kfWY9ITB9ZiYmKGMuYz8oUShjKSxJKGUpLGM9UyhiKSxlPWMuYSk6Yi5jJiYoUShiKSxJKGQpLGI9UihjKSxkPWIuYSkpO2lmKGQuYSE9PWUuYSlpZihkLmIuYT09PWUuYi5hfHxiLmN8fGMuY3x8ZC5iLmEhPT1hLmEmJmUuYi5hIT09YS5hKXFhKGEsXG5iKTtlbHNlIGlmKHdhKGEsYikpYnJlYWs7ZC5hPT09ZS5hJiZkLmIuYT09PWUuYi5hJiYoUChlLGQpLFEoYiksSShkKSxiPVIoYykpfX1cbmZ1bmN0aW9uIHlhKGEsYil7YS5hPWI7Zm9yKHZhciBjPWIuYztudWxsPT09Yy5pOylpZihjPWMuYyxjPT09Yi5jKXt2YXIgYz1hLGQ9YixlPW5ldyBtYTtlLmE9ZC5jLmI7dmFyIGY9Yy5mLGc9Zi5hO2RvIGc9Zy5hO3doaWxlKG51bGwhPT1nLmImJiFmLmMoZi5iLGUsZy5iKSk7dmFyIGY9Zy5iLGg9UyhmKSxlPWYuYSxnPWguYTtpZigwPT09eChlLmIuYSxkLGUuYSkpZT1mLmEsdChlLmEsZCl8fHQoZS5iLmEsZCl8fChLKGUuYiksZi5jJiYoSShlLmMpLGYuYz0hMSksRShkLmMsZSkseWEoYyxkKSk7ZWxzZXt2YXIgaz11KGcuYi5hLGUuYi5hKT9mOmgsaD12b2lkIDA7Zi5kfHxrLmM/KGs9PT1mP2g9TChkLmMuYixlLmUpOmg9TChnLmIuYy5iLGQuYykuYixrLmM/amEoayxoKTooZT1jLGY9bGEoYyxmLGgpLGYuZj1SKGYpLmYrZi5hLmYsZi5kPW9hKGUsZi5mKSkseWEoYyxkKSk6VShjLGYsZC5jLGQuYyxudWxsLCEwKX1yZXR1cm59Yz1rYShjLmkpO2U9UyhjKTtmPWUuYTtlPVQoYSxcbmUsbnVsbCk7aWYoZS5jPT09Zil7dmFyIGY9ZSxlPWYuYyxnPVMoYyksaD1jLmEsaz1nLmEsbD0hMTtoLmIuYSE9PWsuYi5hJiZ3YShhLGMpO3QoaC5hLGEuYSkmJihFKEooZSksaCksYz1rYShjKSxlPVMoYykuYSxUKGEsUyhjKSxnKSxsPSEwKTt0KGsuYSxhLmEpJiYoRShmLEooaykpLGY9VChhLGcsbnVsbCksbD0hMCk7bD9VKGEsYyxmLmMsZSxlLCEwKToodShrLmEsaC5hKT9kPUooayk6ZD1oLGQ9TChmLmMuYixkKSxVKGEsYyxkLGQuYyxkLmMsITEpLGQuYi5pLmM9ITAscmEoYSxjKSl9ZWxzZSBVKGEsYyxlLmMsZixmLCEwKX1mdW5jdGlvbiB6YShhLGIpe3ZhciBjPW5ldyBtYSxkPWVhKGEuYik7ZC5hLmI9TztkLmEuYT1iO2QuYi5hLmI9LU87ZC5iLmEuYT1iO2EuYT1kLmIuYTtjLmE9ZDtjLmY9MDtjLmQ9ITE7Yy5jPSExO2MuaD0hMDtjLmI9ITE7ZD1hLmY7ZD1uYShkLGQuYSxjKTtjLmU9ZH07ZnVuY3Rpb24gQWEoYSl7dGhpcy5hPW5ldyBCYTt0aGlzLmI9YTt0aGlzLmM9aWF9ZnVuY3Rpb24gbmEoYSxiLGMpe2RvIGI9Yi5jO3doaWxlKG51bGwhPT1iLmImJiFhLmMoYS5iLGIuYixjKSk7YT1uZXcgQmEoYyxiLmEsYik7Yi5hLmM9YTtyZXR1cm4gYi5hPWF9O2Z1bmN0aW9uIEJhKGEsYixjKXt0aGlzLmI9YXx8bnVsbDt0aGlzLmE9Ynx8dGhpczt0aGlzLmM9Y3x8dGhpc307ZnVuY3Rpb24gWCgpe3RoaXMuZD1ZO3RoaXMucD10aGlzLmI9dGhpcy5xPW51bGw7dGhpcy5qPVswLDAsMF07dGhpcy5zPTEwMDEzMDt0aGlzLm49ITE7dGhpcy5vPXRoaXMuYT10aGlzLmU9dGhpcy5mPW51bGw7dGhpcy5tPSExO3RoaXMuYz10aGlzLnI9dGhpcy5pPXRoaXMuaz10aGlzLmw9dGhpcy5oPW51bGx9dmFyIFk9MDtuPVgucHJvdG90eXBlO24ueD1mdW5jdGlvbigpe1oodGhpcyxZKX07bi5CPWZ1bmN0aW9uKGEsYil7c3dpdGNoKGEpe2Nhc2UgMTAwMTQyOnJldHVybjtjYXNlIDEwMDE0MDpzd2l0Y2goYil7Y2FzZSAxMDAxMzA6Y2FzZSAxMDAxMzE6Y2FzZSAxMDAxMzI6Y2FzZSAxMDAxMzM6Y2FzZSAxMDAxMzQ6dGhpcy5zPWI7cmV0dXJufWJyZWFrO2Nhc2UgMTAwMTQxOnRoaXMubT0hIWI7cmV0dXJuO2RlZmF1bHQ6Vih0aGlzLDEwMDkwMCk7cmV0dXJufVYodGhpcywxMDA5MDEpfTtcbm4ueT1mdW5jdGlvbihhKXtzd2l0Y2goYSl7Y2FzZSAxMDAxNDI6cmV0dXJuIDA7Y2FzZSAxMDAxNDA6cmV0dXJuIHRoaXMucztjYXNlIDEwMDE0MTpyZXR1cm4gdGhpcy5tO2RlZmF1bHQ6Vih0aGlzLDEwMDkwMCl9cmV0dXJuITF9O24uQT1mdW5jdGlvbihhLGIsYyl7dGhpcy5qWzBdPWE7dGhpcy5qWzFdPWI7dGhpcy5qWzJdPWN9O1xubi56PWZ1bmN0aW9uKGEsYil7dmFyIGM9Yj9iOm51bGw7c3dpdGNoKGEpe2Nhc2UgMTAwMTAwOmNhc2UgMTAwMTA2OnRoaXMuaD1jO2JyZWFrO2Nhc2UgMTAwMTA0OmNhc2UgMTAwMTEwOnRoaXMubD1jO2JyZWFrO2Nhc2UgMTAwMTAxOmNhc2UgMTAwMTA3OnRoaXMuaz1jO2JyZWFrO2Nhc2UgMTAwMTAyOmNhc2UgMTAwMTA4OnRoaXMuaT1jO2JyZWFrO2Nhc2UgMTAwMTAzOmNhc2UgMTAwMTA5OnRoaXMucD1jO2JyZWFrO2Nhc2UgMTAwMTA1OmNhc2UgMTAwMTExOnRoaXMubz1jO2JyZWFrO2Nhc2UgMTAwMTEyOnRoaXMucj1jO2JyZWFrO2RlZmF1bHQ6Vih0aGlzLDEwMDkwMCl9fTtcbm4uQz1mdW5jdGlvbihhLGIpe3ZhciBjPSExLGQ9WzAsMCwwXTtaKHRoaXMsMik7Zm9yKHZhciBlPTA7Mz5lOysrZSl7dmFyIGY9YVtlXTstMUUxNTA+ZiYmKGY9LTFFMTUwLGM9ITApOzFFMTUwPGYmJihmPTFFMTUwLGM9ITApO2RbZV09Zn1jJiZWKHRoaXMsMTAwMTU1KTtjPXRoaXMucTtudWxsPT09Yz8oYz1lYSh0aGlzLmIpLEUoYyxjLmIpKTooSyhjKSxjPWMuZSk7Yy5hLmQ9YjtjLmEuZ1swXT1kWzBdO2MuYS5nWzFdPWRbMV07Yy5hLmdbMl09ZFsyXTtjLmY9MTtjLmIuZj0tMTt0aGlzLnE9Y307bi51PWZ1bmN0aW9uKGEpe1oodGhpcyxZKTt0aGlzLmQ9MTt0aGlzLmI9bmV3IENhO3RoaXMuYz1hfTtuLnQ9ZnVuY3Rpb24oKXtaKHRoaXMsMSk7dGhpcy5kPTI7dGhpcy5xPW51bGx9O24udj1mdW5jdGlvbigpe1oodGhpcywyKTt0aGlzLmQ9MX07XG5uLnc9ZnVuY3Rpb24oKXtaKHRoaXMsMSk7dGhpcy5kPVk7dmFyIGE9dGhpcy5qWzBdLGI9dGhpcy5qWzFdLGM9dGhpcy5qWzJdLGQ9ITEsZT1bYSxiLGNdO2lmKDA9PT1hJiYwPT09YiYmMD09PWMpe2Zvcih2YXIgYj1bLTIqMUUxNTAsLTIqMUUxNTAsLTIqMUUxNTBdLGY9WzIqMUUxNTAsMioxRTE1MCwyKjFFMTUwXSxjPVtdLGc9W10sZD10aGlzLmIuYyxhPWQuZTthIT09ZDthPWEuZSlmb3IodmFyIGg9MDszPmg7KytoKXt2YXIgaz1hLmdbaF07azxmW2hdJiYoZltoXT1rLGdbaF09YSk7az5iW2hdJiYoYltoXT1rLGNbaF09YSl9YT0wO2JbMV0tZlsxXT5iWzBdLWZbMF0mJihhPTEpO2JbMl0tZlsyXT5iW2FdLWZbYV0mJihhPTIpO2lmKGZbYV0+PWJbYV0pZVswXT0wLGVbMV09MCxlWzJdPTE7ZWxzZXtiPTA7Zj1nW2FdO2M9Y1thXTtnPVswLDAsMF07Zj1bZi5nWzBdLWMuZ1swXSxmLmdbMV0tYy5nWzFdLGYuZ1syXS1jLmdbMl1dO2g9WzAsMCwwXTtmb3IoYT1kLmU7YSE9PWQ7YT1cbmEuZSloWzBdPWEuZ1swXS1jLmdbMF0saFsxXT1hLmdbMV0tYy5nWzFdLGhbMl09YS5nWzJdLWMuZ1syXSxnWzBdPWZbMV0qaFsyXS1mWzJdKmhbMV0sZ1sxXT1mWzJdKmhbMF0tZlswXSpoWzJdLGdbMl09ZlswXSpoWzFdLWZbMV0qaFswXSxrPWdbMF0qZ1swXStnWzFdKmdbMV0rZ1syXSpnWzJdLGs+YiYmKGI9ayxlWzBdPWdbMF0sZVsxXT1nWzFdLGVbMl09Z1syXSk7MD49YiYmKGVbMF09ZVsxXT1lWzJdPTAsZVtoYShmKV09MSl9ZD0hMH1nPWhhKGUpO2E9dGhpcy5iLmM7Yj0oZysxKSUzO2M9KGcrMiklMztnPTA8ZVtnXT8xOi0xO2ZvcihlPWEuZTtlIT09YTtlPWUuZSllLmI9ZS5nW2JdLGUuYT1nKmUuZ1tjXTtpZihkKXtlPTA7ZD10aGlzLmIuYTtmb3IoYT1kLmI7YSE9PWQ7YT1hLmIpaWYoYj1hLmEsISgwPj1iLmYpKXtkbyBlKz0oYi5hLmItYi5iLmEuYikqKGIuYS5hK2IuYi5hLmEpLGI9Yi5lO3doaWxlKGIhPT1hLmEpfWlmKDA+ZSlmb3IoZT10aGlzLmIuYyxkPWUuZTtkIT09XG5lO2Q9ZC5lKWQuYT0tZC5hfXRoaXMubj0hMTtlPXRoaXMuYi5iO2ZvcihhPWUuaDthIT09ZTthPWQpaWYoZD1hLmgsYj1hLmUsdChhLmEsYS5iLmEpJiZhLmUuZSE9PWEmJih0YSh0aGlzLGIsYSksSShhKSxhPWIsYj1hLmUpLGIuZT09PWEpe2lmKGIhPT1hKXtpZihiPT09ZHx8Yj09PWQuYilkPWQuaDtJKGIpfWlmKGE9PT1kfHxhPT09ZC5iKWQ9ZC5oO0koYSl9dGhpcy5lPWU9bmV3IERhO2Q9dGhpcy5iLmM7Zm9yKGE9ZC5lO2EhPT1kO2E9YS5lKWEuaD14YShlLGEpO0VhKGUpO3RoaXMuZj1uZXcgQWEodGhpcyk7emEodGhpcywtTyk7Zm9yKHphKHRoaXMsTyk7bnVsbCE9PShlPUZhKHRoaXMuZSkpOyl7Zm9yKDs7KXthOmlmKGE9dGhpcy5lLDA9PT1hLmEpZD1HYShhLmIpO2Vsc2UgaWYoZD1hLmNbYS5kW2EuYS0xXV0sMCE9PWEuYi5hJiYoYT1HYShhLmIpLHUoYSxkKSkpe2Q9YTticmVhayBhfWlmKG51bGw9PT1kfHwhdChkLGUpKWJyZWFrO2Q9RmEodGhpcy5lKTt0YSh0aGlzLGUuYyxcbmQuYyl9eWEodGhpcyxlKX10aGlzLmE9dGhpcy5mLmEuYS5iLmEuYTtmb3IoZT0wO251bGwhPT0oZD10aGlzLmYuYS5hLmIpOylkLmh8fCsrZSxRKGQpO3RoaXMuZj1udWxsO2U9dGhpcy5lO2UuYj1udWxsO2UuZD1udWxsO3RoaXMuZT1lLmM9bnVsbDtlPXRoaXMuYjtmb3IoYT1lLmEuYjthIT09ZS5hO2E9ZClkPWEuYixhPWEuYSxhLmUuZT09PWEmJihQKGEuYyxhKSxJKGEpKTtpZighdGhpcy5uKXtlPXRoaXMuYjtpZih0aGlzLm0pZm9yKGE9ZS5iLmg7YSE9PWUuYjthPWQpZD1hLmgsYS5iLmQuYyE9PWEuZC5jP2EuZj1hLmQuYz8xOi0xOkkoYSk7ZWxzZSBmb3IoYT1lLmEuYjthIT09ZS5hO2E9ZClpZihkPWEuYixhLmMpe2ZvcihhPWEuYTt1KGEuYi5hLGEuYSk7YT1hLmMuYik7Zm9yKDt1KGEuYSxhLmIuYSk7YT1hLmUpO2I9YS5jLmI7Zm9yKGM9dm9pZCAwO2EuZSE9PWI7KWlmKHUoYS5iLmEsYi5hKSl7Zm9yKDtiLmUhPT1hJiYoY2EoYi5lKXx8MD49eChiLmEsYi5iLmEsYi5lLmIuYSkpOyljPVxuTChiLmUsYiksYj1jLmI7Yj1iLmMuYn1lbHNle2Zvcig7Yi5lIT09YSYmKGRhKGEuYy5iKXx8MDw9eChhLmIuYSxhLmEsYS5jLmIuYSkpOyljPUwoYSxhLmMuYiksYT1jLmI7YT1hLmV9Zm9yKDtiLmUuZSE9PWE7KWM9TChiLmUsYiksYj1jLmJ9aWYodGhpcy5ofHx0aGlzLml8fHRoaXMua3x8dGhpcy5sKWlmKHRoaXMubSlmb3IoZT10aGlzLmIsZD1lLmEuYjtkIT09ZS5hO2Q9ZC5iKXtpZihkLmMpe3RoaXMuaCYmdGhpcy5oKDIsdGhpcy5jKTthPWQuYTtkbyB0aGlzLmsmJnRoaXMuayhhLmEuZCx0aGlzLmMpLGE9YS5lO3doaWxlKGEhPT1kLmEpO3RoaXMuaSYmdGhpcy5pKHRoaXMuYyl9fWVsc2V7ZT10aGlzLmI7ZD0hIXRoaXMubDthPSExO2I9LTE7Zm9yKGM9ZS5hLmQ7YyE9PWUuYTtjPWMuZClpZihjLmMpe2F8fCh0aGlzLmgmJnRoaXMuaCg0LHRoaXMuYyksYT0hMCk7Zz1jLmE7ZG8gZCYmKGY9Zy5iLmQuYz8wOjEsYiE9PWYmJihiPWYsdGhpcy5sJiZ0aGlzLmwoISFiLHRoaXMuYykpKSxcbnRoaXMuayYmdGhpcy5rKGcuYS5kLHRoaXMuYyksZz1nLmU7d2hpbGUoZyE9PWMuYSl9YSYmdGhpcy5pJiZ0aGlzLmkodGhpcy5jKX1pZih0aGlzLnIpe2U9dGhpcy5iO2ZvcihhPWUuYS5iO2EhPT1lLmE7YT1kKWlmKGQ9YS5iLCFhLmMpe2I9YS5hO2M9Yi5lO2c9dm9pZCAwO2RvIGc9YyxjPWcuZSxnLmQ9bnVsbCxudWxsPT09Zy5iLmQmJihnLmM9PT1nP0YoZy5hLG51bGwpOihnLmEuYz1nLmMsSChnLEooZykpKSxmPWcuYixmLmM9PT1mP0YoZi5hLG51bGwpOihmLmEuYz1mLmMsSChmLEooZikpKSxmYShnKSk7d2hpbGUoZyE9PWIpO2I9YS5kO2E9YS5iO2EuZD1iO2IuYj1hfXRoaXMucih0aGlzLmIpO3RoaXMuYz10aGlzLmI9bnVsbDtyZXR1cm59fXRoaXMuYj10aGlzLmM9bnVsbH07XG5mdW5jdGlvbiBaKGEsYil7aWYoYS5kIT09Yilmb3IoO2EuZCE9PWI7KWlmKGEuZDxiKXN3aXRjaChhLmQpe2Nhc2UgWTpWKGEsMTAwMTUxKTthLnUobnVsbCk7YnJlYWs7Y2FzZSAxOlYoYSwxMDAxNTIpLGEudCgpfWVsc2Ugc3dpdGNoKGEuZCl7Y2FzZSAyOlYoYSwxMDAxNTQpO2EudigpO2JyZWFrO2Nhc2UgMTpWKGEsMTAwMTUzKSxhLncoKX19ZnVuY3Rpb24gVihhLGIpe2EucCYmYS5wKGIsYS5jKX07ZnVuY3Rpb24gZ2EoYSxiKXt0aGlzLmI9YXx8dGhpczt0aGlzLmQ9Ynx8dGhpczt0aGlzLmE9bnVsbDt0aGlzLmM9ITF9O2Z1bmN0aW9uIE0oKXt0aGlzLmg9dGhpczt0aGlzLmk9dGhpcy5kPXRoaXMuYT10aGlzLmU9dGhpcy5jPXRoaXMuYj1udWxsO3RoaXMuZj0wfWZ1bmN0aW9uIEooYSl7cmV0dXJuIGEuYi5lfTtmdW5jdGlvbiBDYSgpe3RoaXMuYz1uZXcgTjt0aGlzLmE9bmV3IGdhO3RoaXMuYj1uZXcgTTt0aGlzLmQ9bmV3IE07dGhpcy5iLmI9dGhpcy5kO3RoaXMuZC5iPXRoaXMuYn07ZnVuY3Rpb24gTihhLGIpe3RoaXMuZT1hfHx0aGlzO3RoaXMuZj1ifHx0aGlzO3RoaXMuZD10aGlzLmM9bnVsbDt0aGlzLmc9WzAsMCwwXTt0aGlzLmg9dGhpcy5hPXRoaXMuYj0wfTtmdW5jdGlvbiBEYSgpe3RoaXMuYz1bXTt0aGlzLmQ9bnVsbDt0aGlzLmE9MDt0aGlzLmU9ITE7dGhpcy5iPW5ldyBIYX1mdW5jdGlvbiBFYShhKXthLmQ9W107Zm9yKHZhciBiPTA7YjxhLmE7YisrKWEuZFtiXT1iO2EuZC5zb3J0KGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiLGUpe3JldHVybiB1KGFbYl0sYVtlXSk/MTotMX19KGEuYykpO2EuZT0hMDtJYShhLmIpfWZ1bmN0aW9uIHhhKGEsYil7aWYoYS5lKXt2YXIgYz1hLmIsZD0rK2MuYTsyKmQ+Yy5mJiYoYy5mKj0yLGMuYz1KYShjLmMsYy5mKzEpKTt2YXIgZTswPT09Yy5iP2U9ZDooZT1jLmIsYy5iPWMuY1tjLmJdKTtjLmVbZV09YjtjLmNbZV09ZDtjLmRbZF09ZTtjLmgmJnZhKGMsZCk7cmV0dXJuIGV9Yz1hLmErKzthLmNbY109YjtyZXR1cm4tKGMrMSl9XG5mdW5jdGlvbiBGYShhKXtpZigwPT09YS5hKXJldHVybiBLYShhLmIpO3ZhciBiPWEuY1thLmRbYS5hLTFdXTtpZigwIT09YS5iLmEmJnUoR2EoYS5iKSxiKSlyZXR1cm4gS2EoYS5iKTtkby0tYS5hO3doaWxlKDA8YS5hJiZudWxsPT09YS5jW2EuZFthLmEtMV1dKTtyZXR1cm4gYn07ZnVuY3Rpb24gSGEoKXt0aGlzLmQ9SmEoWzBdLDMzKTt0aGlzLmU9W251bGwsbnVsbF07dGhpcy5jPVswLDBdO3RoaXMuYT0wO3RoaXMuZj0zMjt0aGlzLmI9MDt0aGlzLmg9ITE7dGhpcy5kWzFdPTF9ZnVuY3Rpb24gSmEoYSxiKXtmb3IodmFyIGM9QXJyYXkoYiksZD0wO2Q8YS5sZW5ndGg7ZCsrKWNbZF09YVtkXTtmb3IoO2Q8YjtkKyspY1tkXT0wO3JldHVybiBjfWZ1bmN0aW9uIElhKGEpe2Zvcih2YXIgYj1hLmE7MTw9YjstLWIpVyhhLGIpO2EuaD0hMH1mdW5jdGlvbiBHYShhKXtyZXR1cm4gYS5lW2EuZFsxXV19ZnVuY3Rpb24gS2EoYSl7dmFyIGI9YS5kLGM9YS5lLGQ9YS5jLGU9YlsxXSxmPWNbZV07MDxhLmEmJihiWzFdPWJbYS5hXSxkW2JbMV1dPTEsY1tlXT1udWxsLGRbZV09YS5iLGEuYj1lLDA8LS1hLmEmJlcoYSwxKSk7cmV0dXJuIGZ9XG5mdW5jdGlvbiBXKGEsYil7Zm9yKHZhciBjPWEuZCxkPWEuZSxlPWEuYyxmPWIsZz1jW2ZdOzspe3ZhciBoPWY8PDE7aDxhLmEmJnUoZFtjW2grMV1dLGRbY1toXV0pJiYoaCs9MSk7dmFyIGs9Y1toXTtpZihoPmEuYXx8dShkW2ddLGRba10pKXtjW2ZdPWc7ZVtnXT1mO2JyZWFrfWNbZl09aztlW2tdPWY7Zj1ofX1mdW5jdGlvbiB2YShhLGIpe2Zvcih2YXIgYz1hLmQsZD1hLmUsZT1hLmMsZj1iLGc9Y1tmXTs7KXt2YXIgaD1mPj4xLGs9Y1toXTtpZigwPT09aHx8dShkW2tdLGRbZ10pKXtjW2ZdPWc7ZVtnXT1mO2JyZWFrfWNbZl09aztlW2tdPWY7Zj1ofX07ZnVuY3Rpb24gbWEoKXt0aGlzLmU9dGhpcy5hPW51bGw7dGhpcy5mPTA7dGhpcy5jPXRoaXMuYj10aGlzLmg9dGhpcy5kPSExfWZ1bmN0aW9uIFMoYSl7cmV0dXJuIGEuZS5jLmJ9ZnVuY3Rpb24gUihhKXtyZXR1cm4gYS5lLmEuYn07dGhpcy5saWJ0ZXNzPXtHbHVUZXNzZWxhdG9yOlgsd2luZGluZ1J1bGU6e0dMVV9URVNTX1dJTkRJTkdfT0REOjEwMDEzMCxHTFVfVEVTU19XSU5ESU5HX05PTlpFUk86MTAwMTMxLEdMVV9URVNTX1dJTkRJTkdfUE9TSVRJVkU6MTAwMTMyLEdMVV9URVNTX1dJTkRJTkdfTkVHQVRJVkU6MTAwMTMzLEdMVV9URVNTX1dJTkRJTkdfQUJTX0dFUV9UV086MTAwMTM0fSxwcmltaXRpdmVUeXBlOntHTF9MSU5FX0xPT1A6MixHTF9UUklBTkdMRVM6NCxHTF9UUklBTkdMRV9TVFJJUDo1LEdMX1RSSUFOR0xFX0ZBTjo2fSxlcnJvclR5cGU6e0dMVV9URVNTX01JU1NJTkdfQkVHSU5fUE9MWUdPTjoxMDAxNTEsR0xVX1RFU1NfTUlTU0lOR19FTkRfUE9MWUdPTjoxMDAxNTMsR0xVX1RFU1NfTUlTU0lOR19CRUdJTl9DT05UT1VSOjEwMDE1MixHTFVfVEVTU19NSVNTSU5HX0VORF9DT05UT1VSOjEwMDE1NCxHTFVfVEVTU19DT09SRF9UT09fTEFSR0U6MTAwMTU1LEdMVV9URVNTX05FRURfQ09NQklORV9DQUxMQkFDSzoxMDAxNTZ9LFxuZ2x1RW51bTp7R0xVX1RFU1NfTUVTSDoxMDAxMTIsR0xVX1RFU1NfVE9MRVJBTkNFOjEwMDE0MixHTFVfVEVTU19XSU5ESU5HX1JVTEU6MTAwMTQwLEdMVV9URVNTX0JPVU5EQVJZX09OTFk6MTAwMTQxLEdMVV9JTlZBTElEX0VOVU06MTAwOTAwLEdMVV9JTlZBTElEX1ZBTFVFOjEwMDkwMSxHTFVfVEVTU19CRUdJTjoxMDAxMDAsR0xVX1RFU1NfVkVSVEVYOjEwMDEwMSxHTFVfVEVTU19FTkQ6MTAwMTAyLEdMVV9URVNTX0VSUk9SOjEwMDEwMyxHTFVfVEVTU19FREdFX0ZMQUc6MTAwMTA0LEdMVV9URVNTX0NPTUJJTkU6MTAwMTA1LEdMVV9URVNTX0JFR0lOX0RBVEE6MTAwMTA2LEdMVV9URVNTX1ZFUlRFWF9EQVRBOjEwMDEwNyxHTFVfVEVTU19FTkRfREFUQToxMDAxMDgsR0xVX1RFU1NfRVJST1JfREFUQToxMDAxMDksR0xVX1RFU1NfRURHRV9GTEFHX0RBVEE6MTAwMTEwLEdMVV9URVNTX0NPTUJJTkVfREFUQToxMDAxMTF9fTtYLnByb3RvdHlwZS5nbHVEZWxldGVUZXNzPVgucHJvdG90eXBlLng7XG5YLnByb3RvdHlwZS5nbHVUZXNzUHJvcGVydHk9WC5wcm90b3R5cGUuQjtYLnByb3RvdHlwZS5nbHVHZXRUZXNzUHJvcGVydHk9WC5wcm90b3R5cGUueTtYLnByb3RvdHlwZS5nbHVUZXNzTm9ybWFsPVgucHJvdG90eXBlLkE7WC5wcm90b3R5cGUuZ2x1VGVzc0NhbGxiYWNrPVgucHJvdG90eXBlLno7WC5wcm90b3R5cGUuZ2x1VGVzc1ZlcnRleD1YLnByb3RvdHlwZS5DO1gucHJvdG90eXBlLmdsdVRlc3NCZWdpblBvbHlnb249WC5wcm90b3R5cGUudTtYLnByb3RvdHlwZS5nbHVUZXNzQmVnaW5Db250b3VyPVgucHJvdG90eXBlLnQ7WC5wcm90b3R5cGUuZ2x1VGVzc0VuZENvbnRvdXI9WC5wcm90b3R5cGUudjtYLnByb3RvdHlwZS5nbHVUZXNzRW5kUG9seWdvbj1YLnByb3RvdHlwZS53OyBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHsgbW9kdWxlLmV4cG9ydHMgPSB0aGlzLmxpYnRlc3M7IH1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gdGhlIG9ubHkgcmVsaWFibGUgbWVhbnMgdG8gZ2V0IHRoZSBnbG9iYWwgb2JqZWN0IGlzXG5cdC8vIGBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpYFxuXHQvLyBIb3dldmVyLCB0aGlzIGNhdXNlcyBDU1AgdmlvbGF0aW9ucyBpbiBDaHJvbWUgYXBwcy5cblx0aWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gc2VsZjsgfVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHdpbmRvdzsgfVxuXHRpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfVxuXHR0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCcpO1xufVxuXG52YXIgZ2xvYmFsT2JqZWN0ID0gZ2V0R2xvYmFsKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGdsb2JhbE9iamVjdC5mZXRjaDtcblxuLy8gTmVlZGVkIGZvciBUeXBlU2NyaXB0IGFuZCBXZWJwYWNrLlxuaWYgKGdsb2JhbE9iamVjdC5mZXRjaCkge1xuXHRleHBvcnRzLmRlZmF1bHQgPSBnbG9iYWxPYmplY3QuZmV0Y2guYmluZChnbG9iYWxPYmplY3QpO1xufVxuXG5leHBvcnRzLkhlYWRlcnMgPSBnbG9iYWxPYmplY3QuSGVhZGVycztcbmV4cG9ydHMuUmVxdWVzdCA9IGdsb2JhbE9iamVjdC5SZXF1ZXN0O1xuZXhwb3J0cy5SZXNwb25zZSA9IGdsb2JhbE9iamVjdC5SZXNwb25zZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG4gIGNzcyArPSBvYmouY3NzO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9XG5cbiAgLy8gRm9yIG9sZCBJRVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge30sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfVxuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgaWQ9XFxcIkxheWVyXzFcXFwiIGRhdGEtbmFtZT1cXFwiTGF5ZXIgMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgNjg5IDQ1Ni4zXFxcIj48Y2lyY2xlIGN4PVxcXCI3OC45OVxcXCIgY3k9XFxcIjIyNi42M1xcXCIgcj1cXFwiNzguOTlcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcIjI5Ni41XFxcIiBjeT1cXFwiMzQ0LjVcXFwiIHI9XFxcIjExMS44XFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXCI1NDEuMzZcXFwiIGN5PVxcXCIxNDcuNjRcXFwiIHI9XFxcIjE0Ny42NFxcXCI+PC9jaXJjbGU+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBpZD1cXFwiTGF5ZXJfMVxcXCIgZGF0YS1uYW1lPVxcXCJMYXllciAxXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCA2MjMuOTggNTMyLjExXFxcIj48cGF0aCBkPVxcXCJNNTkxLjMxLDQ5NS4yNWM1Ny45LTE0MC42MS0yMjAuNzUtMzExLTM2Ni45MS03Ny40Mkw2NCwyMjguODlDNDA5LDQ0LjM0LDYwNS40MiwxNjAuNzIsNjY4LjE2LDMwOGM3MC4zNSwxNjUuMTEtNjEuMTgsMzQ1LTE2MywzNTYuODgtOTQuNywxMS4wOS0yMTQuOC01OC4wOS0yNDUuNTYtODQuNDVsODEuMjktMTU2UzUzMy40LDYzNS44Niw1OTEuMzEsNDk1LjI1WlxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoLTY0LjAyIC0xMzMuOTQpXFxcIj48L3BhdGg+PHBhdGggZD1cXFwiTTU5OCw0MjhcXFwiIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKC02NC4wMiAtMTMzLjk0KVxcXCI+PC9wYXRoPjwvc3ZnPlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgaWQ9XFxcIkxheWVyXzFcXFwiIGRhdGEtbmFtZT1cXFwiTGF5ZXIgMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgNTk2IDYxMFxcXCI+PHBhdGggZD1cXFwiTTYzNCw1NzIsMjE2LDczMiw5Miw0NzQsMzI4LDE3NGwzNjAtNTJcXFwiIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKC05MiAtMTIyKVxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcIk01OTgsNDI4XFxcIiB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtOTIgLTEyMilcXFwiPjwvcGF0aD48L3N2Zz5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGZpbGw9XFxcIiMwMDAwMDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjx0aXRsZT5jYXB0dXJlPC90aXRsZT48cGF0aCBkPVxcXCJNNCAydjI4aDI0di0yOGgtMjR6TTI0IDIyaC0xNnYtMTZoMTZ2MTZ6XFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBpZD1cXFwiTGF5ZXJfMVxcXCIgZGF0YS1uYW1lPVxcXCJMYXllciAxXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCA2MDAgNjAwXFxcIj48cGF0aCBkPVxcXCJNMzAwLDEwMFYyMDBINjAwVjUwMEg3MDBWMTAwWlxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoLTEwMCAtMTAwKVxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcIk0zMjgsNzAwVjYwMEgyMDBWNDcySDEwMFY3MDBaXFxcIiB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtMTAwIC0xMDApXFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBmaWxsPVxcXCIjMDAwMDAwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48dGl0bGU+ZG93bmxvYWQ8L3RpdGxlPjxwYXRoIGQ9XFxcIk0xNi4wMDEgMTkuMzE0bC04LjQ4NS04LjQ4NSAyLjgyOC0yLjgyOSA1LjY1NyA1LjY1NyA1LjY1Ny01LjY1NyAyLjgyOCAyLjgyOC04LjQ4NSA4LjQ4NnpNOCAyOGgxNnYtNGgtMTZ2NHpcXFwiPjwvcGF0aD48L3N2Zz5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGZpbGw9XFxcIiMwMDAwMDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjx0aXRsZT5mb3JiaWQ8L3RpdGxlPjxwYXRoIGQ9XFxcIk0xOC44MjggMTZsNC4yNDMgNC4yNDMtMi44MjggMi44MjgtNC4yNDMtNC4yNDMtNC4yNDMgNC4yNDMtMi44MjgtMi44MjggNC4yNDMtNC4yNDMtNC4yNDMtNC4yNDMgMi44MjgtMi44MjggNC4yNDMgNC4yNDMgNC4yNDMtNC4yNDMgMi44MjggMi44MjgtNC4yNDMgNC4yNDN6XFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBmaWxsPVxcXCIjMDAwMDAwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48dGl0bGU+bGF1bmNoPC90aXRsZT48cGF0aCBkPVxcXCJNMjQgMjRoLTZ2NGgtNHYtNGgtNmw0LTR2LTEzbDQtNCA0IDR2MTNsNCA0elxcXCI+PC9wYXRoPjwvc3ZnPlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgaWQ9XFxcIkxheWVyXzFcXFwiIGRhdGEtbmFtZT1cXFwiTGF5ZXIgMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgNTI1Ljg2IDQzMS45NVxcXCI+PHBhdGggZD1cXFwiTTM4NSw2MDcuMzgsMTQ4LjY0LDQyMi42Mmw2MS41Ny03OC44TDM2Ny43OCw0NjdsMjI4LTI5MS41N0w2NzQuNSwyMzdaXFxcIiB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtMTQ4LjY0IC0xNzUuNDMpXFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBmaWxsPVxcXCIjMDAwMDAwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48dGl0bGU+cGx1ZzwvdGl0bGU+PHBhdGggZD1cXFwiTTIyIDExdi04aC0xMnY4aC0ydjE0aDZ2NGg0di00aDZ2LTE0aC0yek0xOCAxMWgtNHYtNGg0djR6XFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBmaWxsPVxcXCIjMDAwMDAwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48dGl0bGU+cmVkbzwvdGl0bGU+PHBhdGggZD1cXFwiTTI4IDI0djRoLTI0di0yMGgxMC4wNzFsLTMuNjU3LTMuNjU0IDIuODI4LTIuODI2IDguNDg1IDguNDg1LTguNDg1IDguNDg0LTIuODI4LTIuODMgMy42NTctMy42NTloLTYuMDcxdjEyaDIwelxcXCI+PC9wYXRoPjwvc3ZnPlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgZmlsbD1cXFwiIzAwMDAwMFxcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHRpdGxlPnJlc2l6ZTwvdGl0bGU+PHBhdGggZD1cXFwiTTI4IDEydi04aC04djJoLTh2LTJoLTh2OGgydjhoLTJ2OGg4di0yaDh2Mmg4di04aC0ydi04aDJ6TTIyIDIwaC0ydjJoLTh2LTJoLTJ2LThoMnYtMmg4djJoMnY4elxcXCI+PC9wYXRoPjwvc3ZnPlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgZmlsbD1cXFwiIzAwMDAwMFxcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHRpdGxlPnNvbHZlPC90aXRsZT48cGF0aCBkPVxcXCJNMjggMTJ2NGgtNHY2aC02djRoLTR2LTRoLTZ2LTZoLTR2LTRoNHYtNmg2djRoNHYtNGg2djZoNHpcXFwiPjwvcGF0aD48L3N2Zz5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGZpbGw9XFxcIiMwMDAwMDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjx0aXRsZT50aW1lPC90aXRsZT48cGF0aCBkPVxcXCJNMjIgMThoLTh2LThoNHY0aDR2NHpNMzAgMnYyOGgtMjh2LTI4aDI4ek0yNiA2aC0yMHYyMGgyMHYtMjB6XFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBmaWxsPVxcXCIjMDAwMDAwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48dGl0bGU+dW5kbzwvdGl0bGU+PHBhdGggZD1cXFwiTTI4IDh2MjBoLTI0di00aDIwdi0xMmgtNi4wNzFsMy42NTcgMy42Ni0yLjgyOCAyLjgzLTguNDg1LTguNDg0IDguNDg1LTguNDg1IDIuODI4IDIuODI2LTMuNjU3IDMuNjUzaDEwLjA3MXpcXFwiPjwvcGF0aD48L3N2Zz5cIiIsImV4cG9ydCBkZWZhdWx0IFwiL2ltYWdlcy9jOWVjMjc0NjZmZWVjNjYzOWMwZTdjZGQ3OThlNTcwNy53ZWJwXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCIvaW1hZ2VzLzExZDE4MTljMzI5MDk3YmQ0MmQ2MTJhZjUxOTg0ZWJmLndlYnBcIjsiLCJleHBvcnQgZGVmYXVsdCBcIi9pbWFnZXMvZjU4MjIxNGZmMzM1MGYxOTU3ZDJlNWY3MWFjNjA4OWMud2VicFwiOyIsImV4cG9ydCBkZWZhdWx0IFwiL2ltYWdlcy9mMDY5MzJhYzUxNmY3YzcyY2U4NDhkZmU1YTE1NTdjYS53ZWJwXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCIvaW1hZ2VzL2Y3NDQyMDQxY2I5ZDZkYjAyYjdmODBlOWEzYWEyOThmLndlYnBcIjsiLCJleHBvcnQgZGVmYXVsdCBcIi9pbWFnZXMvMmVlNWRkMmY3NjU0NDg5OWQ5MTc0NjRmMWM3ZWQ2ODcud2VicFwiOyIsImV4cG9ydCBkZWZhdWx0IFwiL2ltYWdlcy8zMjBmYzdiN2IxYTY1ODU4OGQ1YjAyMGE5MGMzZWUyNi53ZWJwXCI7IiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyoqXG4gKiBjaHJvbWEuanMgLSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGNvbG9yIGNvbnZlcnNpb25zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTksIEdyZWdvciBBaXNjaFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gVGhlIG5hbWUgR3JlZ29yIEFpc2NoIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiAqIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAqIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdSRUdPUiBBSVNDSCBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuICogSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsXG4gKiBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWVxuICogT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiAqIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIGNocm9tYS5qcyBpbmNsdWRlcyBjb2xvcnMgZnJvbSBjb2xvcmJyZXdlcjIub3JnLCB3aGljaCBhcmUgcmVsZWFzZWQgdW5kZXJcbiAqIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDIgQ3ludGhpYSBCcmV3ZXIsIE1hcmsgSGFycm93ZXIsXG4gKiBhbmQgVGhlIFBlbm5zeWx2YW5pYSBTdGF0ZSBVbml2ZXJzaXR5LlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELFxuICogZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWNcbiAqIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogTmFtZWQgY29sb3JzIGFyZSB0YWtlbiBmcm9tIFgxMSBDb2xvciBOYW1lcy5cbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI3N2Zy1jb2xvclxuICpcbiAqIEBwcmVzZXJ2ZVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmNocm9tYSA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbGltaXQkMiA9IGZ1bmN0aW9uICh4LCBtaW4sIG1heCkge1xuICAgICAgICBpZiAoIG1pbiA9PT0gdm9pZCAwICkgbWluPTA7XG4gICAgICAgIGlmICggbWF4ID09PSB2b2lkIDAgKSBtYXg9MTtcblxuICAgICAgICByZXR1cm4geCA8IG1pbiA/IG1pbiA6IHggPiBtYXggPyBtYXggOiB4O1xuICAgIH07XG5cbiAgICB2YXIgbGltaXQkMSA9IGxpbWl0JDI7XG5cbiAgICB2YXIgY2xpcF9yZ2IkMyA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgICAgcmdiLl9jbGlwcGVkID0gZmFsc2U7XG4gICAgICAgIHJnYi5fdW5jbGlwcGVkID0gcmdiLnNsaWNlKDApO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8PTM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJnYltpXSA8IDAgfHwgcmdiW2ldID4gMjU1KSB7IHJnYi5fY2xpcHBlZCA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICByZ2JbaV0gPSBsaW1pdCQxKHJnYltpXSwgMCwgMjU1KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJnYltpXSA9IGxpbWl0JDEocmdiW2ldLCAwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH07XG5cbiAgICAvLyBwb3J0ZWQgZnJvbSBqUXVlcnkncyAkLnR5cGVcbiAgICB2YXIgY2xhc3NUb1R5cGUgPSB7fTtcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBbJ0Jvb2xlYW4nLCAnTnVtYmVyJywgJ1N0cmluZycsICdGdW5jdGlvbicsICdBcnJheScsICdEYXRlJywgJ1JlZ0V4cCcsICdVbmRlZmluZWQnLCAnTnVsbCddOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgbmFtZSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICAgIGNsYXNzVG9UeXBlWyhcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIpXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgdmFyIHR5cGUkcCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gY2xhc3NUb1R5cGVbT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaildIHx8IFwib2JqZWN0XCI7XG4gICAgfTtcblxuICAgIHZhciB0eXBlJG8gPSB0eXBlJHA7XG5cbiAgICB2YXIgdW5wYWNrJEIgPSBmdW5jdGlvbiAoYXJncywga2V5T3JkZXIpIHtcbiAgICAgICAgaWYgKCBrZXlPcmRlciA9PT0gdm9pZCAwICkga2V5T3JkZXI9bnVsbDtcblxuICAgIFx0Ly8gaWYgY2FsbGVkIHdpdGggbW9yZSB0aGFuIDMgYXJndW1lbnRzLCB3ZSByZXR1cm4gdGhlIGFyZ3VtZW50c1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPj0gMykgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7IH1cbiAgICAgICAgLy8gd2l0aCBsZXNzIHRoYW4gMyBhcmdzIHdlIGNoZWNrIGlmIGZpcnN0IGFyZyBpcyBvYmplY3RcbiAgICAgICAgLy8gYW5kIHVzZSB0aGUga2V5T3JkZXIgc3RyaW5nIHRvIGV4dHJhY3QgYW5kIHNvcnQgcHJvcGVydGllc1xuICAgIFx0aWYgKHR5cGUkbyhhcmdzWzBdKSA9PSAnb2JqZWN0JyAmJiBrZXlPcmRlcikge1xuICAgIFx0XHRyZXR1cm4ga2V5T3JkZXIuc3BsaXQoJycpXG4gICAgXHRcdFx0LmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gYXJnc1swXVtrXSAhPT0gdW5kZWZpbmVkOyB9KVxuICAgIFx0XHRcdC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGFyZ3NbMF1ba107IH0pO1xuICAgIFx0fVxuICAgIFx0Ly8gb3RoZXJ3aXNlIHdlIGp1c3QgcmV0dXJuIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgIFx0Ly8gKHdoaWNoIHdlIHN1cHBvc2UgaXMgYW4gYXJyYXkgb2YgYXJncylcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcblxuICAgIHZhciB0eXBlJG4gPSB0eXBlJHA7XG5cbiAgICB2YXIgbGFzdCQ0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB2YXIgbCA9IGFyZ3MubGVuZ3RoLTE7XG4gICAgICAgIGlmICh0eXBlJG4oYXJnc1tsXSkgPT0gJ3N0cmluZycpIHsgcmV0dXJuIGFyZ3NbbF0udG9Mb3dlckNhc2UoKTsgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIFBJJDIgPSBNYXRoLlBJO1xuXG4gICAgdmFyIHV0aWxzID0ge1xuICAgIFx0Y2xpcF9yZ2I6IGNsaXBfcmdiJDMsXG4gICAgXHRsaW1pdDogbGltaXQkMixcbiAgICBcdHR5cGU6IHR5cGUkcCxcbiAgICBcdHVucGFjazogdW5wYWNrJEIsXG4gICAgXHRsYXN0OiBsYXN0JDQsXG4gICAgXHRQSTogUEkkMixcbiAgICBcdFRXT1BJOiBQSSQyKjIsXG4gICAgXHRQSVRISVJEOiBQSSQyLzMsXG4gICAgXHRERUcyUkFEOiBQSSQyIC8gMTgwLFxuICAgIFx0UkFEMkRFRzogMTgwIC8gUEkkMlxuICAgIH07XG5cbiAgICB2YXIgaW5wdXQkaCA9IHtcbiAgICBcdGZvcm1hdDoge30sXG4gICAgXHRhdXRvZGV0ZWN0OiBbXVxuICAgIH07XG5cbiAgICB2YXIgbGFzdCQzID0gdXRpbHMubGFzdDtcbiAgICB2YXIgY2xpcF9yZ2IkMiA9IHV0aWxzLmNsaXBfcmdiO1xuICAgIHZhciB0eXBlJG0gPSB1dGlscy50eXBlO1xuICAgIHZhciBfaW5wdXQgPSBpbnB1dCRoO1xuXG4gICAgdmFyIENvbG9yJEQgPSBmdW5jdGlvbiBDb2xvcigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZSRtKGFyZ3NbMF0pID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgYXJnc1swXS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgYXJnc1swXS5jb25zdHJ1Y3RvciA9PT0gdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgLy8gdGhlIGFyZ3VtZW50IGlzIGFscmVhZHkgYSBDb2xvciBpbnN0YW5jZVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsYXN0IGFyZ3VtZW50IGNvdWxkIGJlIHRoZSBtb2RlXG4gICAgICAgIHZhciBtb2RlID0gbGFzdCQzKGFyZ3MpO1xuICAgICAgICB2YXIgYXV0b2RldGVjdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgICAgYXV0b2RldGVjdCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIV9pbnB1dC5zb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBfaW5wdXQuYXV0b2RldGVjdCA9IF9pbnB1dC5hdXRvZGV0ZWN0LnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYi5wIC0gYS5wOyB9KTtcbiAgICAgICAgICAgICAgICBfaW5wdXQuc29ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGF1dG8tZGV0ZWN0IGZvcm1hdFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBfaW5wdXQuYXV0b2RldGVjdDsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hrID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgICAgIG1vZGUgPSBjaGsudGVzdC5hcHBseShjaGssIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2lucHV0LmZvcm1hdFttb2RlXSkge1xuICAgICAgICAgICAgdmFyIHJnYiA9IF9pbnB1dC5mb3JtYXRbbW9kZV0uYXBwbHkobnVsbCwgYXV0b2RldGVjdCA/IGFyZ3MgOiBhcmdzLnNsaWNlKDAsLTEpKTtcbiAgICAgICAgICAgIG1lLl9yZ2IgPSBjbGlwX3JnYiQyKHJnYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZm9ybWF0OiAnK2FyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGFscGhhIGNoYW5uZWxcbiAgICAgICAgaWYgKG1lLl9yZ2IubGVuZ3RoID09PSAzKSB7IG1lLl9yZ2IucHVzaCgxKTsgfVxuICAgIH07XG5cbiAgICBDb2xvciRELnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgaWYgKHR5cGUkbSh0aGlzLmhleCkgPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gdGhpcy5oZXgoKTsgfVxuICAgICAgICByZXR1cm4gKFwiW1wiICsgKHRoaXMuX3JnYi5qb2luKCcsJykpICsgXCJdXCIpO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3JfMSA9IENvbG9yJEQ7XG5cbiAgICB2YXIgY2hyb21hJGsgPSBmdW5jdGlvbiAoKSB7XG4gICAgXHR2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIFx0d2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIFx0cmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIGNocm9tYSRrLkNvbG9yLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MpICkpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkay5Db2xvciA9IENvbG9yXzE7XG4gICAgY2hyb21hJGsudmVyc2lvbiA9ICcyLjQuMic7XG5cbiAgICB2YXIgY2hyb21hXzEgPSBjaHJvbWEkaztcblxuICAgIHZhciB1bnBhY2skQSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbWF4JDIgPSBNYXRoLm1heDtcblxuICAgIHZhciByZ2IyY215ayQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skQShhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHIgPSByIC8gMjU1O1xuICAgICAgICBnID0gZyAvIDI1NTtcbiAgICAgICAgYiA9IGIgLyAyNTU7XG4gICAgICAgIHZhciBrID0gMSAtIG1heCQyKHIsbWF4JDIoZyxiKSk7XG4gICAgICAgIHZhciBmID0gayA8IDEgPyAxIC8gKDEtaykgOiAwO1xuICAgICAgICB2YXIgYyA9ICgxLXItaykgKiBmO1xuICAgICAgICB2YXIgbSA9ICgxLWctaykgKiBmO1xuICAgICAgICB2YXIgeSA9ICgxLWItaykgKiBmO1xuICAgICAgICByZXR1cm4gW2MsbSx5LGtdO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmNteWtfMSA9IHJnYjJjbXlrJDE7XG5cbiAgICB2YXIgdW5wYWNrJHogPSB1dGlscy51bnBhY2s7XG5cbiAgICB2YXIgY215azJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayR6KGFyZ3MsICdjbXlrJyk7XG4gICAgICAgIHZhciBjID0gYXJnc1swXTtcbiAgICAgICAgdmFyIG0gPSBhcmdzWzFdO1xuICAgICAgICB2YXIgeSA9IGFyZ3NbMl07XG4gICAgICAgIHZhciBrID0gYXJnc1szXTtcbiAgICAgICAgdmFyIGFscGhhID0gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IDE7XG4gICAgICAgIGlmIChrID09PSAxKSB7IHJldHVybiBbMCwwLDAsYWxwaGFdOyB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjID49IDEgPyAwIDogMjU1ICogKDEtYykgKiAoMS1rKSwgLy8gclxuICAgICAgICAgICAgbSA+PSAxID8gMCA6IDI1NSAqICgxLW0pICogKDEtayksIC8vIGdcbiAgICAgICAgICAgIHkgPj0gMSA/IDAgOiAyNTUgKiAoMS15KSAqICgxLWspLCAvLyBiXG4gICAgICAgICAgICBhbHBoYVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICB2YXIgY215azJyZ2JfMSA9IGNteWsycmdiO1xuXG4gICAgdmFyIGNocm9tYSRqID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJEMgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCRnID0gaW5wdXQkaDtcbiAgICB2YXIgdW5wYWNrJHkgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkbCA9IHV0aWxzLnR5cGU7XG5cbiAgICB2YXIgcmdiMmNteWsgPSByZ2IyY215a18xO1xuXG4gICAgQ29sb3IkQy5wcm90b3R5cGUuY215ayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmdiMmNteWsodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGouY215ayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkQywgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2NteWsnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JGcuZm9ybWF0LmNteWsgPSBjbXlrMnJnYl8xO1xuXG4gICAgaW5wdXQkZy5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAyLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayR5KGFyZ3MsICdjbXlrJyk7XG4gICAgICAgICAgICBpZiAodHlwZSRsKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjbXlrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayR4ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsYXN0JDIgPSB1dGlscy5sYXN0O1xuICAgIHZhciBybmQgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gTWF0aC5yb3VuZChhKjEwMCkvMTAwOyB9O1xuXG4gICAgLypcbiAgICAgKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICAgICAqIC0gaHNsMmNzcyhoLHMsbClcbiAgICAgKiAtIGhzbDJjc3MoaCxzLGwsYSlcbiAgICAgKiAtIGhzbDJjc3MoW2gscyxsXSwgbW9kZSlcbiAgICAgKiAtIGhzbDJjc3MoW2gscyxsLGFdLCBtb2RlKVxuICAgICAqIC0gaHNsMmNzcyh7aCxzLGwsYX0sIG1vZGUpXG4gICAgICovXG4gICAgdmFyIGhzbDJjc3MkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgaHNsYSA9IHVucGFjayR4KGFyZ3MsICdoc2xhJyk7XG4gICAgICAgIHZhciBtb2RlID0gbGFzdCQyKGFyZ3MpIHx8ICdsc2EnO1xuICAgICAgICBoc2xhWzBdID0gcm5kKGhzbGFbMF0gfHwgMCk7XG4gICAgICAgIGhzbGFbMV0gPSBybmQoaHNsYVsxXSoxMDApICsgJyUnO1xuICAgICAgICBoc2xhWzJdID0gcm5kKGhzbGFbMl0qMTAwKSArICclJztcbiAgICAgICAgaWYgKG1vZGUgPT09ICdoc2xhJyB8fCAoaHNsYS5sZW5ndGggPiAzICYmIGhzbGFbM108MSkpIHtcbiAgICAgICAgICAgIGhzbGFbM10gPSBoc2xhLmxlbmd0aCA+IDMgPyBoc2xhWzNdIDogMTtcbiAgICAgICAgICAgIG1vZGUgPSAnaHNsYSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoc2xhLmxlbmd0aCA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChtb2RlICsgXCIoXCIgKyAoaHNsYS5qb2luKCcsJykpICsgXCIpXCIpO1xuICAgIH07XG5cbiAgICB2YXIgaHNsMmNzc18xID0gaHNsMmNzcyQxO1xuXG4gICAgdmFyIHVucGFjayR3ID0gdXRpbHMudW5wYWNrO1xuXG4gICAgLypcbiAgICAgKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICAgICAqIC0gcmdiMmhzbChyLGcsYilcbiAgICAgKiAtIHJnYjJoc2wocixnLGIsYSlcbiAgICAgKiAtIHJnYjJoc2woW3IsZyxiXSlcbiAgICAgKiAtIHJnYjJoc2woW3IsZyxiLGFdKVxuICAgICAqIC0gcmdiMmhzbCh7cixnLGIsYX0pXG4gICAgICovXG4gICAgdmFyIHJnYjJoc2wkMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJHcoYXJncywgJ3JnYmEnKTtcbiAgICAgICAgdmFyIHIgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgZyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBiID0gYXJnc1syXTtcblxuICAgICAgICByIC89IDI1NTtcbiAgICAgICAgZyAvPSAyNTU7XG4gICAgICAgIGIgLz0gMjU1O1xuXG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXG4gICAgICAgIHZhciBsID0gKG1heCArIG1pbikgLyAyO1xuICAgICAgICB2YXIgcywgaDtcblxuICAgICAgICBpZiAobWF4ID09PSBtaW4pe1xuICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBsIDwgMC41ID8gKG1heCAtIG1pbikgLyAobWF4ICsgbWluKSA6IChtYXggLSBtaW4pIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIgPT0gbWF4KSB7IGggPSAoZyAtIGIpIC8gKG1heCAtIG1pbik7IH1cbiAgICAgICAgZWxzZSBpZiAoZyA9PSBtYXgpIHsgaCA9IDIgKyAoYiAtIHIpIC8gKG1heCAtIG1pbik7IH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSBtYXgpIHsgaCA9IDQgKyAociAtIGcpIC8gKG1heCAtIG1pbik7IH1cblxuICAgICAgICBoICo9IDYwO1xuICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoPjMgJiYgYXJnc1szXSE9PXVuZGVmaW5lZCkgeyByZXR1cm4gW2gscyxsLGFyZ3NbM11dOyB9XG4gICAgICAgIHJldHVybiBbaCxzLGxdO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmhzbF8xID0gcmdiMmhzbCQzO1xuXG4gICAgdmFyIHVucGFjayR2ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsYXN0JDEgPSB1dGlscy5sYXN0O1xuICAgIHZhciBoc2wyY3NzID0gaHNsMmNzc18xO1xuICAgIHZhciByZ2IyaHNsJDIgPSByZ2IyaHNsXzE7XG4gICAgdmFyIHJvdW5kJDYgPSBNYXRoLnJvdW5kO1xuXG4gICAgLypcbiAgICAgKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICAgICAqIC0gcmdiMmNzcyhyLGcsYilcbiAgICAgKiAtIHJnYjJjc3MocixnLGIsYSlcbiAgICAgKiAtIHJnYjJjc3MoW3IsZyxiXSwgbW9kZSlcbiAgICAgKiAtIHJnYjJjc3MoW3IsZyxiLGFdLCBtb2RlKVxuICAgICAqIC0gcmdiMmNzcyh7cixnLGIsYX0sIG1vZGUpXG4gICAgICovXG4gICAgdmFyIHJnYjJjc3MkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmdiYSA9IHVucGFjayR2KGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgIHZhciBtb2RlID0gbGFzdCQxKGFyZ3MpIHx8ICdyZ2InO1xuICAgICAgICBpZiAobW9kZS5zdWJzdHIoMCwzKSA9PSAnaHNsJykge1xuICAgICAgICAgICAgcmV0dXJuIGhzbDJjc3MocmdiMmhzbCQyKHJnYmEpLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZ2JhWzBdID0gcm91bmQkNihyZ2JhWzBdKTtcbiAgICAgICAgcmdiYVsxXSA9IHJvdW5kJDYocmdiYVsxXSk7XG4gICAgICAgIHJnYmFbMl0gPSByb3VuZCQ2KHJnYmFbMl0pO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ3JnYmEnIHx8IChyZ2JhLmxlbmd0aCA+IDMgJiYgcmdiYVszXTwxKSkge1xuICAgICAgICAgICAgcmdiYVszXSA9IHJnYmEubGVuZ3RoID4gMyA/IHJnYmFbM10gOiAxO1xuICAgICAgICAgICAgbW9kZSA9ICdyZ2JhJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG1vZGUgKyBcIihcIiArIChyZ2JhLnNsaWNlKDAsbW9kZT09PSdyZ2InPzM6NCkuam9pbignLCcpKSArIFwiKVwiKTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJjc3NfMSA9IHJnYjJjc3MkMTtcblxuICAgIHZhciB1bnBhY2skdSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgcm91bmQkNSA9IE1hdGgucm91bmQ7XG5cbiAgICB2YXIgaHNsMnJnYiQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXNzaWduO1xuXG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG4gICAgICAgIGFyZ3MgPSB1bnBhY2skdShhcmdzLCAnaHNsJyk7XG4gICAgICAgIHZhciBoID0gYXJnc1swXTtcbiAgICAgICAgdmFyIHMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgbCA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByLGcsYjtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIHIgPSBnID0gYiA9IGwqMjU1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHQzID0gWzAsMCwwXTtcbiAgICAgICAgICAgIHZhciBjID0gWzAsMCwwXTtcbiAgICAgICAgICAgIHZhciB0MiA9IGwgPCAwLjUgPyBsICogKDErcykgOiBsK3MtbCpzO1xuICAgICAgICAgICAgdmFyIHQxID0gMiAqIGwgLSB0MjtcbiAgICAgICAgICAgIHZhciBoXyA9IGggLyAzNjA7XG4gICAgICAgICAgICB0M1swXSA9IGhfICsgMS8zO1xuICAgICAgICAgICAgdDNbMV0gPSBoXztcbiAgICAgICAgICAgIHQzWzJdID0gaF8gLSAxLzM7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8MzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQzW2ldIDwgMCkgeyB0M1tpXSArPSAxOyB9XG4gICAgICAgICAgICAgICAgaWYgKHQzW2ldID4gMSkgeyB0M1tpXSAtPSAxOyB9XG4gICAgICAgICAgICAgICAgaWYgKDYgKiB0M1tpXSA8IDEpXG4gICAgICAgICAgICAgICAgICAgIHsgY1tpXSA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzW2ldOyB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoMiAqIHQzW2ldIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgeyBjW2ldID0gdDI7IH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgzICogdDNbaV0gPCAyKVxuICAgICAgICAgICAgICAgICAgICB7IGNbaV0gPSB0MSArICh0MiAtIHQxKSAqICgoMiAvIDMpIC0gdDNbaV0pICogNjsgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgeyBjW2ldID0gdDE7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChhc3NpZ24gPSBbcm91bmQkNShjWzBdKjI1NSkscm91bmQkNShjWzFdKjI1NSkscm91bmQkNShjWzJdKjI1NSldLCByID0gYXNzaWduWzBdLCBnID0gYXNzaWduWzFdLCBiID0gYXNzaWduWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAvLyBrZWVwIGFscGhhIGNoYW5uZWxcbiAgICAgICAgICAgIHJldHVybiBbcixnLGIsYXJnc1szXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyLGcsYiwxXTtcbiAgICB9O1xuXG4gICAgdmFyIGhzbDJyZ2JfMSA9IGhzbDJyZ2IkMTtcblxuICAgIHZhciBoc2wycmdiID0gaHNsMnJnYl8xO1xuICAgIHZhciBpbnB1dCRmID0gaW5wdXQkaDtcblxuICAgIHZhciBSRV9SR0IgPSAvXnJnYlxcKFxccyooLT9cXGQrKSxcXHMqKC0/XFxkKylcXHMqLFxccyooLT9cXGQrKVxccypcXCkkLztcbiAgICB2YXIgUkVfUkdCQSA9IC9ecmdiYVxcKFxccyooLT9cXGQrKSxcXHMqKC0/XFxkKylcXHMqLFxccyooLT9cXGQrKVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbiAgICB2YXIgUkVfUkdCX1BDVCA9IC9ecmdiXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJSxcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcKSQvO1xuICAgIHZhciBSRV9SR0JBX1BDVCA9IC9ecmdiYVxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSUsXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbiAgICB2YXIgUkVfSFNMID0gL15oc2xcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgICB2YXIgUkVfSFNMQSA9IC9eaHNsYVxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSxcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFswMV18WzAxXT9cXC5cXGQrKVxcKSQvO1xuXG4gICAgdmFyIHJvdW5kJDQgPSBNYXRoLnJvdW5kO1xuXG4gICAgdmFyIGNzczJyZ2IkMSA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgICAgICAgY3NzID0gY3NzLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICB2YXIgbTtcblxuICAgICAgICBpZiAoaW5wdXQkZi5mb3JtYXQubmFtZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0JGYuZm9ybWF0Lm5hbWVkKGNzcyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZ2IoMjUwLDIwLDApXG4gICAgICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9SR0IpKSkge1xuICAgICAgICAgICAgdmFyIHJnYiA9IG0uc2xpY2UoMSw0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTwzOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZ2JbaV0gPSArcmdiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmdiWzNdID0gMTsgIC8vIGRlZmF1bHQgYWxwaGFcbiAgICAgICAgICAgIHJldHVybiByZ2I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZ2JhKDI1MCwyMCwwLDAuNClcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX1JHQkEpKSkge1xuICAgICAgICAgICAgdmFyIHJnYiQxID0gbS5zbGljZSgxLDUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxPTA7IGkkMTw0OyBpJDErKykge1xuICAgICAgICAgICAgICAgIHJnYiQxW2kkMV0gPSArcmdiJDFbaSQxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZ2IkMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJnYigxMDAlLDAlLDAlKVxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfUkdCX1BDVCkpKSB7XG4gICAgICAgICAgICB2YXIgcmdiJDIgPSBtLnNsaWNlKDEsNCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDI9MDsgaSQyPDM7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgcmdiJDJbaSQyXSA9IHJvdW5kJDQocmdiJDJbaSQyXSAqIDIuNTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmdiJDJbM10gPSAxOyAgLy8gZGVmYXVsdCBhbHBoYVxuICAgICAgICAgICAgcmV0dXJuIHJnYiQyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmdiYSgxMDAlLDAlLDAlLDAuNClcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX1JHQkFfUENUKSkpIHtcbiAgICAgICAgICAgIHZhciByZ2IkMyA9IG0uc2xpY2UoMSw1KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMz0wOyBpJDM8MzsgaSQzKyspIHtcbiAgICAgICAgICAgICAgICByZ2IkM1tpJDNdID0gcm91bmQkNChyZ2IkM1tpJDNdICogMi41NSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZ2IkM1szXSA9ICtyZ2IkM1szXTtcbiAgICAgICAgICAgIHJldHVybiByZ2IkMztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhzbCgwLDEwMCUsNTAlKVxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfSFNMKSkpIHtcbiAgICAgICAgICAgIHZhciBoc2wgPSBtLnNsaWNlKDEsNCk7XG4gICAgICAgICAgICBoc2xbMV0gKj0gMC4wMTtcbiAgICAgICAgICAgIGhzbFsyXSAqPSAwLjAxO1xuICAgICAgICAgICAgdmFyIHJnYiQ0ID0gaHNsMnJnYihoc2wpO1xuICAgICAgICAgICAgcmdiJDRbM10gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHJnYiQ0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHNsYSgwLDEwMCUsNTAlLDAuNSlcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX0hTTEEpKSkge1xuICAgICAgICAgICAgdmFyIGhzbCQxID0gbS5zbGljZSgxLDQpO1xuICAgICAgICAgICAgaHNsJDFbMV0gKj0gMC4wMTtcbiAgICAgICAgICAgIGhzbCQxWzJdICo9IDAuMDE7XG4gICAgICAgICAgICB2YXIgcmdiJDUgPSBoc2wycmdiKGhzbCQxKTtcbiAgICAgICAgICAgIHJnYiQ1WzNdID0gK21bNF07ICAvLyBkZWZhdWx0IGFscGhhID0gMVxuICAgICAgICAgICAgcmV0dXJuIHJnYiQ1O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNzczJyZ2IkMS50ZXN0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIFJFX1JHQi50ZXN0KHMpIHx8XG4gICAgICAgICAgICBSRV9SR0JBLnRlc3QocykgfHxcbiAgICAgICAgICAgIFJFX1JHQl9QQ1QudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfUkdCQV9QQ1QudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfSFNMLnRlc3QocykgfHxcbiAgICAgICAgICAgIFJFX0hTTEEudGVzdChzKTtcbiAgICB9O1xuXG4gICAgdmFyIGNzczJyZ2JfMSA9IGNzczJyZ2IkMTtcblxuICAgIHZhciBjaHJvbWEkaSA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciRCID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkZSA9IGlucHV0JGg7XG4gICAgdmFyIHR5cGUkayA9IHV0aWxzLnR5cGU7XG5cbiAgICB2YXIgcmdiMmNzcyA9IHJnYjJjc3NfMTtcbiAgICB2YXIgY3NzMnJnYiA9IGNzczJyZ2JfMTtcblxuICAgIENvbG9yJEIucHJvdG90eXBlLmNzcyA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJjc3ModGhpcy5fcmdiLCBtb2RlKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGkuY3NzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRCLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnY3NzJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCRlLmZvcm1hdC5jc3MgPSBjc3MycmdiO1xuXG4gICAgaW5wdXQkZS5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiA1LFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICAgICAgICAgIGlmICghcmVzdC5sZW5ndGggJiYgdHlwZSRrKGgpID09PSAnc3RyaW5nJyAmJiBjc3MycmdiLnRlc3QoaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Nzcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBDb2xvciRBID0gQ29sb3JfMTtcbiAgICB2YXIgY2hyb21hJGggPSBjaHJvbWFfMTtcbiAgICB2YXIgaW5wdXQkZCA9IGlucHV0JGg7XG4gICAgdmFyIHVucGFjayR0ID0gdXRpbHMudW5wYWNrO1xuXG4gICAgaW5wdXQkZC5mb3JtYXQuZ2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJnYiA9IHVucGFjayR0KGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgIHJnYlswXSAqPSAyNTU7XG4gICAgICAgIHJnYlsxXSAqPSAyNTU7XG4gICAgICAgIHJnYlsyXSAqPSAyNTU7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfTtcblxuICAgIGNocm9tYSRoLmdsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRBLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnZ2wnXSkgKSk7XG4gICAgfTtcblxuICAgIENvbG9yJEEucHJvdG90eXBlLmdsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgICAgIHJldHVybiBbcmdiWzBdLzI1NSwgcmdiWzFdLzI1NSwgcmdiWzJdLzI1NSwgcmdiWzNdXTtcbiAgICB9O1xuXG4gICAgdmFyIHVucGFjayRzID0gdXRpbHMudW5wYWNrO1xuXG4gICAgdmFyIHJnYjJoY2ckMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJHMoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICAgICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuICAgICAgICB2YXIgYyA9IGRlbHRhICogMTAwIC8gMjU1O1xuICAgICAgICB2YXIgX2cgPSBtaW4gLyAoMjU1IC0gZGVsdGEpICogMTAwO1xuICAgICAgICB2YXIgaDtcbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyID09PSBtYXgpIHsgaCA9IChnIC0gYikgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaWYgKGcgPT09IG1heCkgeyBoID0gMisoYiAtIHIpIC8gZGVsdGE7IH1cbiAgICAgICAgICAgIGlmIChiID09PSBtYXgpIHsgaCA9IDQrKHIgLSBnKSAvIGRlbHRhOyB9XG4gICAgICAgICAgICBoICo9IDYwO1xuICAgICAgICAgICAgaWYgKGggPCAwKSB7IGggKz0gMzYwOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtoLCBjLCBfZ107XG4gICAgfTtcblxuICAgIHZhciByZ2IyaGNnXzEgPSByZ2IyaGNnJDE7XG5cbiAgICB2YXIgdW5wYWNrJHIgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGZsb29yJDMgPSBNYXRoLmZsb29yO1xuXG4gICAgLypcbiAgICAgKiB0aGlzIGlzIGJhc2ljYWxseSBqdXN0IEhTViB3aXRoIHNvbWUgbWlub3IgdHdlYWtzXG4gICAgICpcbiAgICAgKiBodWUuLiBbMC4uMzYwXVxuICAgICAqIGNocm9tYSAuLiBbMC4uMV1cbiAgICAgKiBncmF5bmVzcyAuLiBbMC4uMV1cbiAgICAgKi9cblxuICAgIHZhciBoY2cycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXNzaWduLCBhc3NpZ24kMSwgYXNzaWduJDIsIGFzc2lnbiQzLCBhc3NpZ24kNCwgYXNzaWduJDU7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcbiAgICAgICAgYXJncyA9IHVucGFjayRyKGFyZ3MsICdoY2cnKTtcbiAgICAgICAgdmFyIGggPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBfZyA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByLGcsYjtcbiAgICAgICAgX2cgPSBfZyAqIDI1NTtcbiAgICAgICAgdmFyIF9jID0gYyAqIDI1NTtcbiAgICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgICAgIHIgPSBnID0gYiA9IF9nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGggPT09IDM2MCkgeyBoID0gMDsgfVxuICAgICAgICAgICAgaWYgKGggPiAzNjApIHsgaCAtPSAzNjA7IH1cbiAgICAgICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICAgICAgaCAvPSA2MDtcbiAgICAgICAgICAgIHZhciBpID0gZmxvb3IkMyhoKTtcbiAgICAgICAgICAgIHZhciBmID0gaCAtIGk7XG4gICAgICAgICAgICB2YXIgcCA9IF9nICogKDEgLSBjKTtcbiAgICAgICAgICAgIHZhciBxID0gcCArIF9jICogKDEgLSBmKTtcbiAgICAgICAgICAgIHZhciB0ID0gcCArIF9jICogZjtcbiAgICAgICAgICAgIHZhciB2ID0gcCArIF9jO1xuICAgICAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiAoYXNzaWduID0gW3YsIHQsIHBdLCByID0gYXNzaWduWzBdLCBnID0gYXNzaWduWzFdLCBiID0gYXNzaWduWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IChhc3NpZ24kMSA9IFtxLCB2LCBwXSwgciA9IGFzc2lnbiQxWzBdLCBnID0gYXNzaWduJDFbMV0sIGIgPSBhc3NpZ24kMVsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAoYXNzaWduJDIgPSBbcCwgdiwgdF0sIHIgPSBhc3NpZ24kMlswXSwgZyA9IGFzc2lnbiQyWzFdLCBiID0gYXNzaWduJDJbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgMzogKGFzc2lnbiQzID0gW3AsIHEsIHZdLCByID0gYXNzaWduJDNbMF0sIGcgPSBhc3NpZ24kM1sxXSwgYiA9IGFzc2lnbiQzWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IChhc3NpZ24kNCA9IFt0LCBwLCB2XSwgciA9IGFzc2lnbiQ0WzBdLCBnID0gYXNzaWduJDRbMV0sIGIgPSBhc3NpZ24kNFsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSA1OiAoYXNzaWduJDUgPSBbdiwgcCwgcV0sIHIgPSBhc3NpZ24kNVswXSwgZyA9IGFzc2lnbiQ1WzFdLCBiID0gYXNzaWduJDVbMl0pOyBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbciwgZywgYiwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICAgIH07XG5cbiAgICB2YXIgaGNnMnJnYl8xID0gaGNnMnJnYjtcblxuICAgIHZhciB1bnBhY2skcSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSRqID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2hyb21hJGcgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkeiA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JGMgPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJoY2cgPSByZ2IyaGNnXzE7XG5cbiAgICBDb2xvciR6LnByb3RvdHlwZS5oY2cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJoY2codGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGcuaGNnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR6LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaGNnJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCRjLmZvcm1hdC5oY2cgPSBoY2cycmdiXzE7XG5cbiAgICBpbnB1dCRjLmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDEsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJHEoYXJncywgJ2hjZycpO1xuICAgICAgICAgICAgaWYgKHR5cGUkaihhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaGNnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayRwID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsYXN0ID0gdXRpbHMubGFzdDtcbiAgICB2YXIgcm91bmQkMyA9IE1hdGgucm91bmQ7XG5cbiAgICB2YXIgcmdiMmhleCQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skcChhcmdzLCAncmdiYScpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgYSA9IHJlZlszXTtcbiAgICAgICAgdmFyIG1vZGUgPSBsYXN0KGFyZ3MpIHx8ICdhdXRvJztcbiAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgeyBhID0gMTsgfVxuICAgICAgICBpZiAobW9kZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBtb2RlID0gYSA8IDEgPyAncmdiYScgOiAncmdiJztcbiAgICAgICAgfVxuICAgICAgICByID0gcm91bmQkMyhyKTtcbiAgICAgICAgZyA9IHJvdW5kJDMoZyk7XG4gICAgICAgIGIgPSByb3VuZCQzKGIpO1xuICAgICAgICB2YXIgdSA9IHIgPDwgMTYgfCBnIDw8IDggfCBiO1xuICAgICAgICB2YXIgc3RyID0gXCIwMDAwMDBcIiArIHUudG9TdHJpbmcoMTYpOyAvLyMudG9VcHBlckNhc2UoKTtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cihzdHIubGVuZ3RoIC0gNik7XG4gICAgICAgIHZhciBoeGEgPSAnMCcgKyByb3VuZCQzKGEgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaHhhID0gaHhhLnN1YnN0cihoeGEubGVuZ3RoIC0gMik7XG4gICAgICAgIHN3aXRjaCAobW9kZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdyZ2JhJzogcmV0dXJuIChcIiNcIiArIHN0ciArIGh4YSk7XG4gICAgICAgICAgICBjYXNlICdhcmdiJzogcmV0dXJuIChcIiNcIiArIGh4YSArIHN0cik7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gKFwiI1wiICsgc3RyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmdiMmhleF8xID0gcmdiMmhleCQyO1xuXG4gICAgdmFyIFJFX0hFWCA9IC9eIz8oW0EtRmEtZjAtOV17Nn18W0EtRmEtZjAtOV17M30pJC87XG4gICAgdmFyIFJFX0hFWEEgPSAvXiM/KFtBLUZhLWYwLTldezh9fFtBLUZhLWYwLTldezR9KSQvO1xuXG4gICAgdmFyIGhleDJyZ2IkMSA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICAgICAgaWYgKGhleC5tYXRjaChSRV9IRVgpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgb3B0aW9uYWwgbGVhZGluZyAjXG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV4cGFuZCBzaG9ydC1ub3RhdGlvbiB0byBmdWxsIHNpeC1kaWdpdFxuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXguc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIGhleCA9IGhleFswXStoZXhbMF0raGV4WzFdK2hleFsxXStoZXhbMl0raGV4WzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHUgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgICAgIHZhciByID0gdSA+PiAxNjtcbiAgICAgICAgICAgIHZhciBnID0gdSA+PiA4ICYgMHhGRjtcbiAgICAgICAgICAgIHZhciBiID0gdSAmIDB4RkY7XG4gICAgICAgICAgICByZXR1cm4gW3IsZyxiLDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWF0Y2ggcmdiYSBoZXggZm9ybWF0LCBlZyAjRkYwMDAwNzdcbiAgICAgICAgaWYgKGhleC5tYXRjaChSRV9IRVhBKSkge1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDUgfHwgaGV4Lmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBvcHRpb25hbCBsZWFkaW5nICNcbiAgICAgICAgICAgICAgICBoZXggPSBoZXguc3Vic3RyKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXhwYW5kIHNob3J0LW5vdGF0aW9uIHRvIGZ1bGwgZWlnaHQtZGlnaXRcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXhbMF0raGV4WzBdK2hleFsxXStoZXhbMV0raGV4WzJdK2hleFsyXStoZXhbM10raGV4WzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHUkMSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgdmFyIHIkMSA9IHUkMSA+PiAyNCAmIDB4RkY7XG4gICAgICAgICAgICB2YXIgZyQxID0gdSQxID4+IDE2ICYgMHhGRjtcbiAgICAgICAgICAgIHZhciBiJDEgPSB1JDEgPj4gOCAmIDB4RkY7XG4gICAgICAgICAgICB2YXIgYSA9IE1hdGgucm91bmQoKHUkMSAmIDB4RkYpIC8gMHhGRiAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gW3IkMSxnJDEsYiQxLGFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgdXNlZCB0byBjaGVjayBmb3IgY3NzIGNvbG9ycyBoZXJlXG4gICAgICAgIC8vIGlmIF9pbnB1dC5jc3M/IGFuZCByZ2IgPSBfaW5wdXQuY3NzIGhleFxuICAgICAgICAvLyAgICAgcmV0dXJuIHJnYlxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJ1bmtub3duIGhleCBjb2xvcjogXCIgKyBoZXgpKTtcbiAgICB9O1xuXG4gICAgdmFyIGhleDJyZ2JfMSA9IGhleDJyZ2IkMTtcblxuICAgIHZhciBjaHJvbWEkZiA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciR5ID0gQ29sb3JfMTtcbiAgICB2YXIgdHlwZSRpID0gdXRpbHMudHlwZTtcbiAgICB2YXIgaW5wdXQkYiA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMmhleCQxID0gcmdiMmhleF8xO1xuXG4gICAgQ29sb3IkeS5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24obW9kZSkge1xuICAgICAgICByZXR1cm4gcmdiMmhleCQxKHRoaXMuX3JnYiwgbW9kZSk7XG4gICAgfTtcblxuICAgIGNocm9tYSRmLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkeSwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hleCddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkYi5mb3JtYXQuaGV4ID0gaGV4MnJnYl8xO1xuICAgIGlucHV0JGIuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogNCxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSByZXN0WyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3QubGVuZ3RoICYmIHR5cGUkaShoKSA9PT0gJ3N0cmluZycgJiYgWzMsNCw1LDYsNyw4LDldLmluZGV4T2YoaC5sZW5ndGgpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hleCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB1bnBhY2skbyA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgVFdPUEkkMiA9IHV0aWxzLlRXT1BJO1xuICAgIHZhciBtaW4kMiA9IE1hdGgubWluO1xuICAgIHZhciBzcXJ0JDQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIGFjb3MgPSBNYXRoLmFjb3M7XG5cbiAgICB2YXIgcmdiMmhzaSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIC8qXG4gICAgICAgIGJvcnJvd2VkIGZyb20gaGVyZTpcbiAgICAgICAgaHR0cDovL2h1bW1lci5zdGFuZm9yZC5lZHUvbXVzZWluZm8vZG9jL2V4YW1wbGVzL2h1bWRydW0va2V5c2NhcGUyL3JnYjJoc2kuY3BwXG4gICAgICAgICovXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skbyhhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHIgLz0gMjU1O1xuICAgICAgICBnIC89IDI1NTtcbiAgICAgICAgYiAvPSAyNTU7XG4gICAgICAgIHZhciBoO1xuICAgICAgICB2YXIgbWluXyA9IG1pbiQyKHIsZyxiKTtcbiAgICAgICAgdmFyIGkgPSAocitnK2IpIC8gMztcbiAgICAgICAgdmFyIHMgPSBpID4gMCA/IDEgLSBtaW5fL2kgOiAwO1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgaCA9IE5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGggPSAoKHItZykrKHItYikpIC8gMjtcbiAgICAgICAgICAgIGggLz0gc3FydCQ0KChyLWcpKihyLWcpICsgKHItYikqKGctYikpO1xuICAgICAgICAgICAgaCA9IGFjb3MoaCk7XG4gICAgICAgICAgICBpZiAoYiA+IGcpIHtcbiAgICAgICAgICAgICAgICBoID0gVFdPUEkkMiAtIGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoIC89IFRXT1BJJDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtoKjM2MCxzLGldO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmhzaV8xID0gcmdiMmhzaSQxO1xuXG4gICAgdmFyIHVucGFjayRuID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsaW1pdCA9IHV0aWxzLmxpbWl0O1xuICAgIHZhciBUV09QSSQxID0gdXRpbHMuVFdPUEk7XG4gICAgdmFyIFBJVEhJUkQgPSB1dGlscy5QSVRISVJEO1xuICAgIHZhciBjb3MkNCA9IE1hdGguY29zO1xuXG4gICAgLypcbiAgICAgKiBodWUgWzAuLjM2MF1cbiAgICAgKiBzYXR1cmF0aW9uIFswLi4xXVxuICAgICAqIGludGVuc2l0eSBbMC4uMV1cbiAgICAgKi9cbiAgICB2YXIgaHNpMnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAvKlxuICAgICAgICBib3Jyb3dlZCBmcm9tIGhlcmU6XG4gICAgICAgIGh0dHA6Ly9odW1tZXIuc3RhbmZvcmQuZWR1L211c2VpbmZvL2RvYy9leGFtcGxlcy9odW1kcnVtL2tleXNjYXBlMi9oc2kycmdiLmNwcFxuICAgICAgICAqL1xuICAgICAgICBhcmdzID0gdW5wYWNrJG4oYXJncywgJ2hzaScpO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBzID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGkgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgcixnLGI7XG5cbiAgICAgICAgaWYgKGlzTmFOKGgpKSB7IGggPSAwOyB9XG4gICAgICAgIGlmIChpc05hTihzKSkgeyBzID0gMDsgfVxuICAgICAgICAvLyBub3JtYWxpemUgaHVlXG4gICAgICAgIGlmIChoID4gMzYwKSB7IGggLT0gMzYwOyB9XG4gICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICBoIC89IDM2MDtcbiAgICAgICAgaWYgKGggPCAxLzMpIHtcbiAgICAgICAgICAgIGIgPSAoMS1zKS8zO1xuICAgICAgICAgICAgciA9ICgxK3MqY29zJDQoVFdPUEkkMSpoKS9jb3MkNChQSVRISVJELVRXT1BJJDEqaCkpLzM7XG4gICAgICAgICAgICBnID0gMSAtIChiK3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGggPCAyLzMpIHtcbiAgICAgICAgICAgIGggLT0gMS8zO1xuICAgICAgICAgICAgciA9ICgxLXMpLzM7XG4gICAgICAgICAgICBnID0gKDErcypjb3MkNChUV09QSSQxKmgpL2NvcyQ0KFBJVEhJUkQtVFdPUEkkMSpoKSkvMztcbiAgICAgICAgICAgIGIgPSAxIC0gKHIrZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoIC09IDIvMztcbiAgICAgICAgICAgIGcgPSAoMS1zKS8zO1xuICAgICAgICAgICAgYiA9ICgxK3MqY29zJDQoVFdPUEkkMSpoKS9jb3MkNChQSVRISVJELVRXT1BJJDEqaCkpLzM7XG4gICAgICAgICAgICByID0gMSAtIChnK2IpO1xuICAgICAgICB9XG4gICAgICAgIHIgPSBsaW1pdChpKnIqMyk7XG4gICAgICAgIGcgPSBsaW1pdChpKmcqMyk7XG4gICAgICAgIGIgPSBsaW1pdChpKmIqMyk7XG4gICAgICAgIHJldHVybiBbcioyNTUsIGcqMjU1LCBiKjI1NSwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICAgIH07XG5cbiAgICB2YXIgaHNpMnJnYl8xID0gaHNpMnJnYjtcblxuICAgIHZhciB1bnBhY2skbSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSRoID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2hyb21hJGUgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkeCA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JGEgPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJoc2kgPSByZ2IyaHNpXzE7XG5cbiAgICBDb2xvciR4LnByb3RvdHlwZS5oc2kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJoc2kodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGUuaHNpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR4LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaHNpJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCRhLmZvcm1hdC5oc2kgPSBoc2kycmdiXzE7XG5cbiAgICBpbnB1dCRhLmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJG0oYXJncywgJ2hzaScpO1xuICAgICAgICAgICAgaWYgKHR5cGUkaChhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaHNpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayRsID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJGcgPSB1dGlscy50eXBlO1xuICAgIHZhciBjaHJvbWEkZCA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciR3ID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkOSA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMmhzbCQxID0gcmdiMmhzbF8xO1xuXG4gICAgQ29sb3Ikdy5wcm90b3R5cGUuaHNsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IyaHNsJDEodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGQuaHNsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR3LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaHNsJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCQ5LmZvcm1hdC5oc2wgPSBoc2wycmdiXzE7XG5cbiAgICBpbnB1dCQ5LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJGwoYXJncywgJ2hzbCcpO1xuICAgICAgICAgICAgaWYgKHR5cGUkZyhhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaHNsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayRrID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBtaW4kMSA9IE1hdGgubWluO1xuICAgIHZhciBtYXgkMSA9IE1hdGgubWF4O1xuXG4gICAgLypcbiAgICAgKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICAgICAqIC0gcmdiMmhzdihyLGcsYilcbiAgICAgKiAtIHJnYjJoc3YoW3IsZyxiXSlcbiAgICAgKiAtIHJnYjJoc3Yoe3IsZyxifSlcbiAgICAgKi9cbiAgICB2YXIgcmdiMmhzbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJGsoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBnID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGIgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgbWluXyA9IG1pbiQxKHIsIGcsIGIpO1xuICAgICAgICB2YXIgbWF4XyA9IG1heCQxKHIsIGcsIGIpO1xuICAgICAgICB2YXIgZGVsdGEgPSBtYXhfIC0gbWluXztcbiAgICAgICAgdmFyIGgscyx2O1xuICAgICAgICB2ID0gbWF4XyAvIDI1NS4wO1xuICAgICAgICBpZiAobWF4XyA9PT0gMCkge1xuICAgICAgICAgICAgaCA9IE51bWJlci5OYU47XG4gICAgICAgICAgICBzID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBkZWx0YSAvIG1heF87XG4gICAgICAgICAgICBpZiAociA9PT0gbWF4XykgeyBoID0gKGcgLSBiKSAvIGRlbHRhOyB9XG4gICAgICAgICAgICBpZiAoZyA9PT0gbWF4XykgeyBoID0gMisoYiAtIHIpIC8gZGVsdGE7IH1cbiAgICAgICAgICAgIGlmIChiID09PSBtYXhfKSB7IGggPSA0KyhyIC0gZykgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaCAqPSA2MDtcbiAgICAgICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbaCwgcywgdl1cbiAgICB9O1xuXG4gICAgdmFyIHJnYjJoc3YkMSA9IHJnYjJoc2w7XG5cbiAgICB2YXIgdW5wYWNrJGogPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGZsb29yJDIgPSBNYXRoLmZsb29yO1xuXG4gICAgdmFyIGhzdjJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxLCBhc3NpZ24kMiwgYXNzaWduJDMsIGFzc2lnbiQ0LCBhc3NpZ24kNTtcblxuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuICAgICAgICBhcmdzID0gdW5wYWNrJGooYXJncywgJ2hzdicpO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBzID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIHYgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgcixnLGI7XG4gICAgICAgIHYgKj0gMjU1O1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgciA9IGcgPSBiID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoID09PSAzNjApIHsgaCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChoID4gMzYwKSB7IGggLT0gMzYwOyB9XG4gICAgICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgICAgIGggLz0gNjA7XG5cbiAgICAgICAgICAgIHZhciBpID0gZmxvb3IkMihoKTtcbiAgICAgICAgICAgIHZhciBmID0gaCAtIGk7XG4gICAgICAgICAgICB2YXIgcCA9IHYgKiAoMSAtIHMpO1xuICAgICAgICAgICAgdmFyIHEgPSB2ICogKDEgLSBzICogZik7XG4gICAgICAgICAgICB2YXIgdCA9IHYgKiAoMSAtIHMgKiAoMSAtIGYpKTtcblxuICAgICAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiAoYXNzaWduID0gW3YsIHQsIHBdLCByID0gYXNzaWduWzBdLCBnID0gYXNzaWduWzFdLCBiID0gYXNzaWduWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IChhc3NpZ24kMSA9IFtxLCB2LCBwXSwgciA9IGFzc2lnbiQxWzBdLCBnID0gYXNzaWduJDFbMV0sIGIgPSBhc3NpZ24kMVsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAoYXNzaWduJDIgPSBbcCwgdiwgdF0sIHIgPSBhc3NpZ24kMlswXSwgZyA9IGFzc2lnbiQyWzFdLCBiID0gYXNzaWduJDJbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgMzogKGFzc2lnbiQzID0gW3AsIHEsIHZdLCByID0gYXNzaWduJDNbMF0sIGcgPSBhc3NpZ24kM1sxXSwgYiA9IGFzc2lnbiQzWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IChhc3NpZ24kNCA9IFt0LCBwLCB2XSwgciA9IGFzc2lnbiQ0WzBdLCBnID0gYXNzaWduJDRbMV0sIGIgPSBhc3NpZ24kNFsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSA1OiAoYXNzaWduJDUgPSBbdiwgcCwgcV0sIHIgPSBhc3NpZ24kNVswXSwgZyA9IGFzc2lnbiQ1WzFdLCBiID0gYXNzaWduJDVbMl0pOyBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcixnLGIsYXJncy5sZW5ndGggPiAzP2FyZ3NbM106MV07XG4gICAgfTtcblxuICAgIHZhciBoc3YycmdiXzEgPSBoc3YycmdiO1xuXG4gICAgdmFyIHVucGFjayRpID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJGYgPSB1dGlscy50eXBlO1xuICAgIHZhciBjaHJvbWEkYyA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciR2ID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkOCA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMmhzdiA9IHJnYjJoc3YkMTtcblxuICAgIENvbG9yJHYucHJvdG90eXBlLmhzdiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmdiMmhzdih0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkYy5oc3YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHYsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydoc3YnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JDguZm9ybWF0LmhzdiA9IGhzdjJyZ2JfMTtcblxuICAgIGlucHV0JDguYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skaShhcmdzLCAnaHN2Jyk7XG4gICAgICAgICAgICBpZiAodHlwZSRmKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoc3YnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbGFiQ29uc3RhbnRzID0ge1xuICAgICAgICAvLyBDb3JyZXNwb25kcyByb3VnaGx5IHRvIFJHQiBicmlnaHRlci9kYXJrZXJcbiAgICAgICAgS246IDE4LFxuXG4gICAgICAgIC8vIEQ2NSBzdGFuZGFyZCByZWZlcmVudFxuICAgICAgICBYbjogMC45NTA0NzAsXG4gICAgICAgIFluOiAxLFxuICAgICAgICBabjogMS4wODg4MzAsXG5cbiAgICAgICAgdDA6IDAuMTM3OTMxMDM0LCAgLy8gNCAvIDI5XG4gICAgICAgIHQxOiAwLjIwNjg5NjU1MiwgIC8vIDYgLyAyOVxuICAgICAgICB0MjogMC4xMjg0MTg1NSwgICAvLyAzICogdDEgKiB0MVxuICAgICAgICB0MzogMC4wMDg4NTY0NTIsICAvLyB0MSAqIHQxICogdDFcbiAgICB9O1xuXG4gICAgdmFyIExBQl9DT05TVEFOVFMkMyA9IGxhYkNvbnN0YW50cztcbiAgICB2YXIgdW5wYWNrJGggPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHBvdyRhID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgcmdiMmxhYiQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skaChhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IHJnYjJ4eXoocixnLGIpO1xuICAgICAgICB2YXIgeCA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgeSA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgeiA9IHJlZiQxWzJdO1xuICAgICAgICB2YXIgbCA9IDExNiAqIHkgLSAxNjtcbiAgICAgICAgcmV0dXJuIFtsIDwgMCA/IDAgOiBsLCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopXTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYl94eXogPSBmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAoKHIgLz0gMjU1KSA8PSAwLjA0MDQ1KSB7IHJldHVybiByIC8gMTIuOTI7IH1cbiAgICAgICAgcmV0dXJuIHBvdyRhKChyICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gICAgfTtcblxuICAgIHZhciB4eXpfbGFiID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgPiBMQUJfQ09OU1RBTlRTJDMudDMpIHsgcmV0dXJuIHBvdyRhKHQsIDEgLyAzKTsgfVxuICAgICAgICByZXR1cm4gdCAvIExBQl9DT05TVEFOVFMkMy50MiArIExBQl9DT05TVEFOVFMkMy50MDtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJ4eXogPSBmdW5jdGlvbiAocixnLGIpIHtcbiAgICAgICAgciA9IHJnYl94eXoocik7XG4gICAgICAgIGcgPSByZ2JfeHl6KGcpO1xuICAgICAgICBiID0gcmdiX3h5eihiKTtcbiAgICAgICAgdmFyIHggPSB4eXpfbGFiKCgwLjQxMjQ1NjQgKiByICsgMC4zNTc1NzYxICogZyArIDAuMTgwNDM3NSAqIGIpIC8gTEFCX0NPTlNUQU5UUyQzLlhuKTtcbiAgICAgICAgdmFyIHkgPSB4eXpfbGFiKCgwLjIxMjY3MjkgKiByICsgMC43MTUxNTIyICogZyArIDAuMDcyMTc1MCAqIGIpIC8gTEFCX0NPTlNUQU5UUyQzLlluKTtcbiAgICAgICAgdmFyIHogPSB4eXpfbGFiKCgwLjAxOTMzMzkgKiByICsgMC4xMTkxOTIwICogZyArIDAuOTUwMzA0MSAqIGIpIC8gTEFCX0NPTlNUQU5UUyQzLlpuKTtcbiAgICAgICAgcmV0dXJuIFt4LHksel07XG4gICAgfTtcblxuICAgIHZhciByZ2IybGFiXzEgPSByZ2IybGFiJDI7XG5cbiAgICB2YXIgTEFCX0NPTlNUQU5UUyQyID0gbGFiQ29uc3RhbnRzO1xuICAgIHZhciB1bnBhY2skZyA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgcG93JDkgPSBNYXRoLnBvdztcblxuICAgIC8qXG4gICAgICogTCogWzAuLjEwMF1cbiAgICAgKiBhIFstMTAwLi4xMDBdXG4gICAgICogYiBbLTEwMC4uMTAwXVxuICAgICAqL1xuICAgIHZhciBsYWIycmdiJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayRnKGFyZ3MsICdsYWInKTtcbiAgICAgICAgdmFyIGwgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYSA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBiID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHgseSx6LCByLGcsYl87XG5cbiAgICAgICAgeSA9IChsICsgMTYpIC8gMTE2O1xuICAgICAgICB4ID0gaXNOYU4oYSkgPyB5IDogeSArIGEgLyA1MDA7XG4gICAgICAgIHogPSBpc05hTihiKSA/IHkgOiB5IC0gYiAvIDIwMDtcblxuICAgICAgICB5ID0gTEFCX0NPTlNUQU5UUyQyLlluICogbGFiX3h5eih5KTtcbiAgICAgICAgeCA9IExBQl9DT05TVEFOVFMkMi5YbiAqIGxhYl94eXooeCk7XG4gICAgICAgIHogPSBMQUJfQ09OU1RBTlRTJDIuWm4gKiBsYWJfeHl6KHopO1xuXG4gICAgICAgIHIgPSB4eXpfcmdiKDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gMC40OTg1MzE0ICogeik7ICAvLyBENjUgLT4gc1JHQlxuICAgICAgICBnID0geHl6X3JnYigtMC45NjkyNjYwICogeCArIDEuODc2MDEwOCAqIHkgKyAwLjA0MTU1NjAgKiB6KTtcbiAgICAgICAgYl8gPSB4eXpfcmdiKDAuMDU1NjQzNCAqIHggLSAwLjIwNDAyNTkgKiB5ICsgMS4wNTcyMjUyICogeik7XG5cbiAgICAgICAgcmV0dXJuIFtyLGcsYl8sYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICAgIH07XG5cbiAgICB2YXIgeHl6X3JnYiA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiAyNTUgKiAociA8PSAwLjAwMzA0ID8gMTIuOTIgKiByIDogMS4wNTUgKiBwb3ckOShyLCAxIC8gMi40KSAtIDAuMDU1KVxuICAgIH07XG5cbiAgICB2YXIgbGFiX3h5eiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID4gTEFCX0NPTlNUQU5UUyQyLnQxID8gdCAqIHQgKiB0IDogTEFCX0NPTlNUQU5UUyQyLnQyICogKHQgLSBMQUJfQ09OU1RBTlRTJDIudDApXG4gICAgfTtcblxuICAgIHZhciBsYWIycmdiXzEgPSBsYWIycmdiJDE7XG5cbiAgICB2YXIgdW5wYWNrJGYgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkZSA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNocm9tYSRiID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHUgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQ3ID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2IybGFiJDEgPSByZ2IybGFiXzE7XG5cbiAgICBDb2xvciR1LnByb3RvdHlwZS5sYWIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJsYWIkMSh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkYi5sYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHUsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydsYWInXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JDcuZm9ybWF0LmxhYiA9IGxhYjJyZ2JfMTtcblxuICAgIGlucHV0JDcuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skZihhcmdzLCAnbGFiJyk7XG4gICAgICAgICAgICBpZiAodHlwZSRlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdsYWInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJGUgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIFJBRDJERUcgPSB1dGlscy5SQUQyREVHO1xuICAgIHZhciBzcXJ0JDMgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIGF0YW4yJDIgPSBNYXRoLmF0YW4yO1xuICAgIHZhciByb3VuZCQyID0gTWF0aC5yb3VuZDtcblxuICAgIHZhciBsYWIybGNoJDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayRlKGFyZ3MsICdsYWInKTtcbiAgICAgICAgdmFyIGwgPSByZWZbMF07XG4gICAgICAgIHZhciBhID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgdmFyIGMgPSBzcXJ0JDMoYSAqIGEgKyBiICogYik7XG4gICAgICAgIHZhciBoID0gKGF0YW4yJDIoYiwgYSkgKiBSQUQyREVHICsgMzYwKSAlIDM2MDtcbiAgICAgICAgaWYgKHJvdW5kJDIoYyoxMDAwMCkgPT09IDApIHsgaCA9IE51bWJlci5OYU47IH1cbiAgICAgICAgcmV0dXJuIFtsLCBjLCBoXTtcbiAgICB9O1xuXG4gICAgdmFyIGxhYjJsY2hfMSA9IGxhYjJsY2gkMjtcblxuICAgIHZhciB1bnBhY2skZCA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgcmdiMmxhYiA9IHJnYjJsYWJfMTtcbiAgICB2YXIgbGFiMmxjaCQxID0gbGFiMmxjaF8xO1xuXG4gICAgdmFyIHJnYjJsY2gkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJGQoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSByZ2IybGFiKHIsZyxiKTtcbiAgICAgICAgdmFyIGwgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGEgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGJfID0gcmVmJDFbMl07XG4gICAgICAgIHJldHVybiBsYWIybGNoJDEobCxhLGJfKTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJsY2hfMSA9IHJnYjJsY2gkMTtcblxuICAgIHZhciB1bnBhY2skYyA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgREVHMlJBRCA9IHV0aWxzLkRFRzJSQUQ7XG4gICAgdmFyIHNpbiQzID0gTWF0aC5zaW47XG4gICAgdmFyIGNvcyQzID0gTWF0aC5jb3M7XG5cbiAgICB2YXIgbGNoMmxhYiQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIC8qXG4gICAgICAgIENvbnZlcnQgZnJvbSBhIHF1YWxpdGF0aXZlIHBhcmFtZXRlciBoIGFuZCBhIHF1YW50aXRhdGl2ZSBwYXJhbWV0ZXIgbCB0byBhIDI0LWJpdCBwaXhlbC5cbiAgICAgICAgVGhlc2UgZm9ybXVsYXMgd2VyZSBpbnZlbnRlZCBieSBEYXZpZCBEYWxyeW1wbGUgdG8gb2J0YWluIG1heGltdW0gY29udHJhc3Qgd2l0aG91dCBnb2luZ1xuICAgICAgICBvdXQgb2YgZ2FtdXQgaWYgdGhlIHBhcmFtZXRlcnMgYXJlIGluIHRoZSByYW5nZSAwLTEuXG5cbiAgICAgICAgQSBzYXR1cmF0aW9uIG11bHRpcGxpZXIgd2FzIGFkZGVkIGJ5IEdyZWdvciBBaXNjaFxuICAgICAgICAqL1xuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJGMoYXJncywgJ2xjaCcpO1xuICAgICAgICB2YXIgbCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGMgPSByZWZbMV07XG4gICAgICAgIHZhciBoID0gcmVmWzJdO1xuICAgICAgICBpZiAoaXNOYU4oaCkpIHsgaCA9IDA7IH1cbiAgICAgICAgaCA9IGggKiBERUcyUkFEO1xuICAgICAgICByZXR1cm4gW2wsIGNvcyQzKGgpICogYywgc2luJDMoaCkgKiBjXVxuICAgIH07XG5cbiAgICB2YXIgbGNoMmxhYl8xID0gbGNoMmxhYiQyO1xuXG4gICAgdmFyIHVucGFjayRiID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsY2gybGFiJDEgPSBsY2gybGFiXzE7XG4gICAgdmFyIGxhYjJyZ2IgPSBsYWIycmdiXzE7XG5cbiAgICB2YXIgbGNoMnJnYiQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2skYihhcmdzLCAnbGNoJyk7XG4gICAgICAgIHZhciBsID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByZWYgPSBsY2gybGFiJDEgKGwsYyxoKTtcbiAgICAgICAgdmFyIEwgPSByZWZbMF07XG4gICAgICAgIHZhciBhID0gcmVmWzFdO1xuICAgICAgICB2YXIgYl8gPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IGxhYjJyZ2IgKEwsYSxiXyk7XG4gICAgICAgIHZhciByID0gcmVmJDFbMF07XG4gICAgICAgIHZhciBnID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBiID0gcmVmJDFbMl07XG4gICAgICAgIHJldHVybiBbciwgZywgYiwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICAgIH07XG5cbiAgICB2YXIgbGNoMnJnYl8xID0gbGNoMnJnYiQxO1xuXG4gICAgdmFyIHVucGFjayRhID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsY2gycmdiID0gbGNoMnJnYl8xO1xuXG4gICAgdmFyIGhjbDJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIGhjbCA9IHVucGFjayRhKGFyZ3MsICdoY2wnKS5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiBsY2gycmdiLmFwcGx5KHZvaWQgMCwgaGNsKTtcbiAgICB9O1xuXG4gICAgdmFyIGhjbDJyZ2JfMSA9IGhjbDJyZ2I7XG5cbiAgICB2YXIgdW5wYWNrJDkgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkZCA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNocm9tYSRhID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHQgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQ2ID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2IybGNoID0gcmdiMmxjaF8xO1xuXG4gICAgQ29sb3IkdC5wcm90b3R5cGUubGNoID0gZnVuY3Rpb24oKSB7IHJldHVybiByZ2IybGNoKHRoaXMuX3JnYik7IH07XG4gICAgQ29sb3IkdC5wcm90b3R5cGUuaGNsID0gZnVuY3Rpb24oKSB7IHJldHVybiByZ2IybGNoKHRoaXMuX3JnYikucmV2ZXJzZSgpOyB9O1xuXG4gICAgY2hyb21hJGEubGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR0LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnbGNoJ10pICkpO1xuICAgIH07XG4gICAgY2hyb21hJGEuaGNsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR0LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaGNsJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCQ2LmZvcm1hdC5sY2ggPSBsY2gycmdiXzE7XG4gICAgaW5wdXQkNi5mb3JtYXQuaGNsID0gaGNsMnJnYl8xO1xuXG4gICAgWydsY2gnLCdoY2wnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldHVybiBpbnB1dCQ2LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJDkoYXJncywgbSk7XG4gICAgICAgICAgICBpZiAodHlwZSRkKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTsgfSk7XG5cbiAgICAvKipcbiAgICBcdFgxMSBjb2xvciBuYW1lc1xuXG4gICAgXHRodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiAgICAqL1xuXG4gICAgdmFyIHczY3gxMSQxID0ge1xuICAgICAgICBhbGljZWJsdWU6ICcjZjBmOGZmJyxcbiAgICAgICAgYW50aXF1ZXdoaXRlOiAnI2ZhZWJkNycsXG4gICAgICAgIGFxdWE6ICcjMDBmZmZmJyxcbiAgICAgICAgYXF1YW1hcmluZTogJyM3ZmZmZDQnLFxuICAgICAgICBhenVyZTogJyNmMGZmZmYnLFxuICAgICAgICBiZWlnZTogJyNmNWY1ZGMnLFxuICAgICAgICBiaXNxdWU6ICcjZmZlNGM0JyxcbiAgICAgICAgYmxhY2s6ICcjMDAwMDAwJyxcbiAgICAgICAgYmxhbmNoZWRhbG1vbmQ6ICcjZmZlYmNkJyxcbiAgICAgICAgYmx1ZTogJyMwMDAwZmYnLFxuICAgICAgICBibHVldmlvbGV0OiAnIzhhMmJlMicsXG4gICAgICAgIGJyb3duOiAnI2E1MmEyYScsXG4gICAgICAgIGJ1cmx5d29vZDogJyNkZWI4ODcnLFxuICAgICAgICBjYWRldGJsdWU6ICcjNWY5ZWEwJyxcbiAgICAgICAgY2hhcnRyZXVzZTogJyM3ZmZmMDAnLFxuICAgICAgICBjaG9jb2xhdGU6ICcjZDI2OTFlJyxcbiAgICAgICAgY29yYWw6ICcjZmY3ZjUwJyxcbiAgICAgICAgY29ybmZsb3dlcjogJyM2NDk1ZWQnLFxuICAgICAgICBjb3JuZmxvd2VyYmx1ZTogJyM2NDk1ZWQnLFxuICAgICAgICBjb3Juc2lsazogJyNmZmY4ZGMnLFxuICAgICAgICBjcmltc29uOiAnI2RjMTQzYycsXG4gICAgICAgIGN5YW46ICcjMDBmZmZmJyxcbiAgICAgICAgZGFya2JsdWU6ICcjMDAwMDhiJyxcbiAgICAgICAgZGFya2N5YW46ICcjMDA4YjhiJyxcbiAgICAgICAgZGFya2dvbGRlbnJvZDogJyNiODg2MGInLFxuICAgICAgICBkYXJrZ3JheTogJyNhOWE5YTknLFxuICAgICAgICBkYXJrZ3JlZW46ICcjMDA2NDAwJyxcbiAgICAgICAgZGFya2dyZXk6ICcjYTlhOWE5JyxcbiAgICAgICAgZGFya2toYWtpOiAnI2JkYjc2YicsXG4gICAgICAgIGRhcmttYWdlbnRhOiAnIzhiMDA4YicsXG4gICAgICAgIGRhcmtvbGl2ZWdyZWVuOiAnIzU1NmIyZicsXG4gICAgICAgIGRhcmtvcmFuZ2U6ICcjZmY4YzAwJyxcbiAgICAgICAgZGFya29yY2hpZDogJyM5OTMyY2MnLFxuICAgICAgICBkYXJrcmVkOiAnIzhiMDAwMCcsXG4gICAgICAgIGRhcmtzYWxtb246ICcjZTk5NjdhJyxcbiAgICAgICAgZGFya3NlYWdyZWVuOiAnIzhmYmM4ZicsXG4gICAgICAgIGRhcmtzbGF0ZWJsdWU6ICcjNDgzZDhiJyxcbiAgICAgICAgZGFya3NsYXRlZ3JheTogJyMyZjRmNGYnLFxuICAgICAgICBkYXJrc2xhdGVncmV5OiAnIzJmNGY0ZicsXG4gICAgICAgIGRhcmt0dXJxdW9pc2U6ICcjMDBjZWQxJyxcbiAgICAgICAgZGFya3Zpb2xldDogJyM5NDAwZDMnLFxuICAgICAgICBkZWVwcGluazogJyNmZjE0OTMnLFxuICAgICAgICBkZWVwc2t5Ymx1ZTogJyMwMGJmZmYnLFxuICAgICAgICBkaW1ncmF5OiAnIzY5Njk2OScsXG4gICAgICAgIGRpbWdyZXk6ICcjNjk2OTY5JyxcbiAgICAgICAgZG9kZ2VyYmx1ZTogJyMxZTkwZmYnLFxuICAgICAgICBmaXJlYnJpY2s6ICcjYjIyMjIyJyxcbiAgICAgICAgZmxvcmFsd2hpdGU6ICcjZmZmYWYwJyxcbiAgICAgICAgZm9yZXN0Z3JlZW46ICcjMjI4YjIyJyxcbiAgICAgICAgZnVjaHNpYTogJyNmZjAwZmYnLFxuICAgICAgICBnYWluc2Jvcm86ICcjZGNkY2RjJyxcbiAgICAgICAgZ2hvc3R3aGl0ZTogJyNmOGY4ZmYnLFxuICAgICAgICBnb2xkOiAnI2ZmZDcwMCcsXG4gICAgICAgIGdvbGRlbnJvZDogJyNkYWE1MjAnLFxuICAgICAgICBncmF5OiAnIzgwODA4MCcsXG4gICAgICAgIGdyZWVuOiAnIzAwODAwMCcsXG4gICAgICAgIGdyZWVueWVsbG93OiAnI2FkZmYyZicsXG4gICAgICAgIGdyZXk6ICcjODA4MDgwJyxcbiAgICAgICAgaG9uZXlkZXc6ICcjZjBmZmYwJyxcbiAgICAgICAgaG90cGluazogJyNmZjY5YjQnLFxuICAgICAgICBpbmRpYW5yZWQ6ICcjY2Q1YzVjJyxcbiAgICAgICAgaW5kaWdvOiAnIzRiMDA4MicsXG4gICAgICAgIGl2b3J5OiAnI2ZmZmZmMCcsXG4gICAgICAgIGtoYWtpOiAnI2YwZTY4YycsXG4gICAgICAgIGxhc2VybGVtb246ICcjZmZmZjU0JyxcbiAgICAgICAgbGF2ZW5kZXI6ICcjZTZlNmZhJyxcbiAgICAgICAgbGF2ZW5kZXJibHVzaDogJyNmZmYwZjUnLFxuICAgICAgICBsYXduZ3JlZW46ICcjN2NmYzAwJyxcbiAgICAgICAgbGVtb25jaGlmZm9uOiAnI2ZmZmFjZCcsXG4gICAgICAgIGxpZ2h0Ymx1ZTogJyNhZGQ4ZTYnLFxuICAgICAgICBsaWdodGNvcmFsOiAnI2YwODA4MCcsXG4gICAgICAgIGxpZ2h0Y3lhbjogJyNlMGZmZmYnLFxuICAgICAgICBsaWdodGdvbGRlbnJvZDogJyNmYWZhZDInLFxuICAgICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNmYWZhZDInLFxuICAgICAgICBsaWdodGdyYXk6ICcjZDNkM2QzJyxcbiAgICAgICAgbGlnaHRncmVlbjogJyM5MGVlOTAnLFxuICAgICAgICBsaWdodGdyZXk6ICcjZDNkM2QzJyxcbiAgICAgICAgbGlnaHRwaW5rOiAnI2ZmYjZjMScsXG4gICAgICAgIGxpZ2h0c2FsbW9uOiAnI2ZmYTA3YScsXG4gICAgICAgIGxpZ2h0c2VhZ3JlZW46ICcjMjBiMmFhJyxcbiAgICAgICAgbGlnaHRza3libHVlOiAnIzg3Y2VmYScsXG4gICAgICAgIGxpZ2h0c2xhdGVncmF5OiAnIzc3ODg5OScsXG4gICAgICAgIGxpZ2h0c2xhdGVncmV5OiAnIzc3ODg5OScsXG4gICAgICAgIGxpZ2h0c3RlZWxibHVlOiAnI2IwYzRkZScsXG4gICAgICAgIGxpZ2h0eWVsbG93OiAnI2ZmZmZlMCcsXG4gICAgICAgIGxpbWU6ICcjMDBmZjAwJyxcbiAgICAgICAgbGltZWdyZWVuOiAnIzMyY2QzMicsXG4gICAgICAgIGxpbmVuOiAnI2ZhZjBlNicsXG4gICAgICAgIG1hZ2VudGE6ICcjZmYwMGZmJyxcbiAgICAgICAgbWFyb29uOiAnIzgwMDAwMCcsXG4gICAgICAgIG1hcm9vbjI6ICcjN2YwMDAwJyxcbiAgICAgICAgbWFyb29uMzogJyNiMDMwNjAnLFxuICAgICAgICBtZWRpdW1hcXVhbWFyaW5lOiAnIzY2Y2RhYScsXG4gICAgICAgIG1lZGl1bWJsdWU6ICcjMDAwMGNkJyxcbiAgICAgICAgbWVkaXVtb3JjaGlkOiAnI2JhNTVkMycsXG4gICAgICAgIG1lZGl1bXB1cnBsZTogJyM5MzcwZGInLFxuICAgICAgICBtZWRpdW1zZWFncmVlbjogJyMzY2IzNzEnLFxuICAgICAgICBtZWRpdW1zbGF0ZWJsdWU6ICcjN2I2OGVlJyxcbiAgICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46ICcjMDBmYTlhJyxcbiAgICAgICAgbWVkaXVtdHVycXVvaXNlOiAnIzQ4ZDFjYycsXG4gICAgICAgIG1lZGl1bXZpb2xldHJlZDogJyNjNzE1ODUnLFxuICAgICAgICBtaWRuaWdodGJsdWU6ICcjMTkxOTcwJyxcbiAgICAgICAgbWludGNyZWFtOiAnI2Y1ZmZmYScsXG4gICAgICAgIG1pc3R5cm9zZTogJyNmZmU0ZTEnLFxuICAgICAgICBtb2NjYXNpbjogJyNmZmU0YjUnLFxuICAgICAgICBuYXZham93aGl0ZTogJyNmZmRlYWQnLFxuICAgICAgICBuYXZ5OiAnIzAwMDA4MCcsXG4gICAgICAgIG9sZGxhY2U6ICcjZmRmNWU2JyxcbiAgICAgICAgb2xpdmU6ICcjODA4MDAwJyxcbiAgICAgICAgb2xpdmVkcmFiOiAnIzZiOGUyMycsXG4gICAgICAgIG9yYW5nZTogJyNmZmE1MDAnLFxuICAgICAgICBvcmFuZ2VyZWQ6ICcjZmY0NTAwJyxcbiAgICAgICAgb3JjaGlkOiAnI2RhNzBkNicsXG4gICAgICAgIHBhbGVnb2xkZW5yb2Q6ICcjZWVlOGFhJyxcbiAgICAgICAgcGFsZWdyZWVuOiAnIzk4ZmI5OCcsXG4gICAgICAgIHBhbGV0dXJxdW9pc2U6ICcjYWZlZWVlJyxcbiAgICAgICAgcGFsZXZpb2xldHJlZDogJyNkYjcwOTMnLFxuICAgICAgICBwYXBheWF3aGlwOiAnI2ZmZWZkNScsXG4gICAgICAgIHBlYWNocHVmZjogJyNmZmRhYjknLFxuICAgICAgICBwZXJ1OiAnI2NkODUzZicsXG4gICAgICAgIHBpbms6ICcjZmZjMGNiJyxcbiAgICAgICAgcGx1bTogJyNkZGEwZGQnLFxuICAgICAgICBwb3dkZXJibHVlOiAnI2IwZTBlNicsXG4gICAgICAgIHB1cnBsZTogJyM4MDAwODAnLFxuICAgICAgICBwdXJwbGUyOiAnIzdmMDA3ZicsXG4gICAgICAgIHB1cnBsZTM6ICcjYTAyMGYwJyxcbiAgICAgICAgcmViZWNjYXB1cnBsZTogJyM2NjMzOTknLFxuICAgICAgICByZWQ6ICcjZmYwMDAwJyxcbiAgICAgICAgcm9zeWJyb3duOiAnI2JjOGY4ZicsXG4gICAgICAgIHJveWFsYmx1ZTogJyM0MTY5ZTEnLFxuICAgICAgICBzYWRkbGVicm93bjogJyM4YjQ1MTMnLFxuICAgICAgICBzYWxtb246ICcjZmE4MDcyJyxcbiAgICAgICAgc2FuZHlicm93bjogJyNmNGE0NjAnLFxuICAgICAgICBzZWFncmVlbjogJyMyZThiNTcnLFxuICAgICAgICBzZWFzaGVsbDogJyNmZmY1ZWUnLFxuICAgICAgICBzaWVubmE6ICcjYTA1MjJkJyxcbiAgICAgICAgc2lsdmVyOiAnI2MwYzBjMCcsXG4gICAgICAgIHNreWJsdWU6ICcjODdjZWViJyxcbiAgICAgICAgc2xhdGVibHVlOiAnIzZhNWFjZCcsXG4gICAgICAgIHNsYXRlZ3JheTogJyM3MDgwOTAnLFxuICAgICAgICBzbGF0ZWdyZXk6ICcjNzA4MDkwJyxcbiAgICAgICAgc25vdzogJyNmZmZhZmEnLFxuICAgICAgICBzcHJpbmdncmVlbjogJyMwMGZmN2YnLFxuICAgICAgICBzdGVlbGJsdWU6ICcjNDY4MmI0JyxcbiAgICAgICAgdGFuOiAnI2QyYjQ4YycsXG4gICAgICAgIHRlYWw6ICcjMDA4MDgwJyxcbiAgICAgICAgdGhpc3RsZTogJyNkOGJmZDgnLFxuICAgICAgICB0b21hdG86ICcjZmY2MzQ3JyxcbiAgICAgICAgdHVycXVvaXNlOiAnIzQwZTBkMCcsXG4gICAgICAgIHZpb2xldDogJyNlZTgyZWUnLFxuICAgICAgICB3aGVhdDogJyNmNWRlYjMnLFxuICAgICAgICB3aGl0ZTogJyNmZmZmZmYnLFxuICAgICAgICB3aGl0ZXNtb2tlOiAnI2Y1ZjVmNScsXG4gICAgICAgIHllbGxvdzogJyNmZmZmMDAnLFxuICAgICAgICB5ZWxsb3dncmVlbjogJyM5YWNkMzInXG4gICAgfTtcblxuICAgIHZhciB3M2N4MTFfMSA9IHczY3gxMSQxO1xuXG4gICAgdmFyIENvbG9yJHMgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQ1ID0gaW5wdXQkaDtcbiAgICB2YXIgdHlwZSRjID0gdXRpbHMudHlwZTtcblxuICAgIHZhciB3M2N4MTEgPSB3M2N4MTFfMTtcbiAgICB2YXIgaGV4MnJnYiA9IGhleDJyZ2JfMTtcbiAgICB2YXIgcmdiMmhleCA9IHJnYjJoZXhfMTtcblxuICAgIENvbG9yJHMucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhleCA9IHJnYjJoZXgodGhpcy5fcmdiLCAncmdiJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gT2JqZWN0LmtleXModzNjeDExKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBuID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgaWYgKHczY3gxMVtuXSA9PT0gaGV4KSB7IHJldHVybiBuLnRvTG93ZXJDYXNlKCk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4O1xuICAgIH07XG5cbiAgICBpbnB1dCQ1LmZvcm1hdC5uYW1lZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh3M2N4MTFbbmFtZV0pIHsgcmV0dXJuIGhleDJyZ2IodzNjeDExW25hbWVdKTsgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29sb3IgbmFtZTogJytuYW1lKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkNS5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiA1LFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICAgICAgICAgIGlmICghcmVzdC5sZW5ndGggJiYgdHlwZSRjKGgpID09PSAnc3RyaW5nJyAmJiB3M2N4MTFbaC50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbmFtZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJDggPSB1dGlscy51bnBhY2s7XG5cbiAgICB2YXIgcmdiMm51bSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skOChhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHJldHVybiAociA8PCAxNikgKyAoZyA8PCA4KSArIGI7XG4gICAgfTtcblxuICAgIHZhciByZ2IybnVtXzEgPSByZ2IybnVtJDE7XG5cbiAgICB2YXIgdHlwZSRiID0gdXRpbHMudHlwZTtcblxuICAgIHZhciBudW0ycmdiID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgICBpZiAodHlwZSRiKG51bSkgPT0gXCJudW1iZXJcIiAmJiBudW0gPj0gMCAmJiBudW0gPD0gMHhGRkZGRkYpIHtcbiAgICAgICAgICAgIHZhciByID0gbnVtID4+IDE2O1xuICAgICAgICAgICAgdmFyIGcgPSAobnVtID4+IDgpICYgMHhGRjtcbiAgICAgICAgICAgIHZhciBiID0gbnVtICYgMHhGRjtcbiAgICAgICAgICAgIHJldHVybiBbcixnLGIsMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBudW0gY29sb3I6IFwiK251bSk7XG4gICAgfTtcblxuICAgIHZhciBudW0ycmdiXzEgPSBudW0ycmdiO1xuXG4gICAgdmFyIGNocm9tYSQ5ID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHIgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQ0ID0gaW5wdXQkaDtcbiAgICB2YXIgdHlwZSRhID0gdXRpbHMudHlwZTtcblxuICAgIHZhciByZ2IybnVtID0gcmdiMm51bV8xO1xuXG4gICAgQ29sb3Ikci5wcm90b3R5cGUubnVtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IybnVtKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSQ5Lm51bSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkciwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ251bSddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkNC5mb3JtYXQubnVtID0gbnVtMnJnYl8xO1xuXG4gICAgaW5wdXQkNC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiA1LFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGUkYShhcmdzWzBdKSA9PT0gJ251bWJlcicgJiYgYXJnc1swXSA+PSAwICYmIGFyZ3NbMF0gPD0gMHhGRkZGRkYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ251bSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBjaHJvbWEkOCA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciRxID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkMyA9IGlucHV0JGg7XG4gICAgdmFyIHVucGFjayQ3ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJDkgPSB1dGlscy50eXBlO1xuICAgIHZhciByb3VuZCQxID0gTWF0aC5yb3VuZDtcblxuICAgIENvbG9yJHEucHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKHJuZCkge1xuICAgICAgICBpZiAoIHJuZCA9PT0gdm9pZCAwICkgcm5kPXRydWU7XG5cbiAgICAgICAgaWYgKHJuZCA9PT0gZmFsc2UpIHsgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLDMpOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZ2Iuc2xpY2UoMCwzKS5tYXAocm91bmQkMSk7XG4gICAgfTtcblxuICAgIENvbG9yJHEucHJvdG90eXBlLnJnYmEgPSBmdW5jdGlvbihybmQpIHtcbiAgICAgICAgaWYgKCBybmQgPT09IHZvaWQgMCApIHJuZD10cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZ2Iuc2xpY2UoMCw0KS5tYXAoZnVuY3Rpb24gKHYsaSkge1xuICAgICAgICAgICAgcmV0dXJuIGk8MyA/IChybmQgPT09IGZhbHNlID8gdiA6IHJvdW5kJDEodikpIDogdjtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNocm9tYSQ4LnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkcSwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ3JnYiddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkMy5mb3JtYXQucmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZ2JhID0gdW5wYWNrJDcoYXJncywgJ3JnYmEnKTtcbiAgICAgICAgaWYgKHJnYmFbM10gPT09IHVuZGVmaW5lZCkgeyByZ2JhWzNdID0gMTsgfVxuICAgICAgICByZXR1cm4gcmdiYTtcbiAgICB9O1xuXG4gICAgaW5wdXQkMy5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAzLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayQ3KGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgICAgICBpZiAodHlwZSQ5KGFyZ3MpID09PSAnYXJyYXknICYmIChhcmdzLmxlbmd0aCA9PT0gMyB8fFxuICAgICAgICAgICAgICAgIGFyZ3MubGVuZ3RoID09PSA0ICYmIHR5cGUkOShhcmdzWzNdKSA9PSAnbnVtYmVyJyAmJiBhcmdzWzNdID49IDAgJiYgYXJnc1szXSA8PSAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncmdiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKiBCYXNlZCBvbiBpbXBsZW1lbnRhdGlvbiBieSBOZWlsIEJhcnRsZXR0XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL25laWxiYXJ0bGV0dC9jb2xvci10ZW1wZXJhdHVyZVxuICAgICAqL1xuXG4gICAgdmFyIGxvZyQxID0gTWF0aC5sb2c7XG5cbiAgICB2YXIgdGVtcGVyYXR1cmUycmdiJDEgPSBmdW5jdGlvbiAoa2VsdmluKSB7XG4gICAgICAgIHZhciB0ZW1wID0ga2VsdmluIC8gMTAwO1xuICAgICAgICB2YXIgcixnLGI7XG4gICAgICAgIGlmICh0ZW1wIDwgNjYpIHtcbiAgICAgICAgICAgIHIgPSAyNTU7XG4gICAgICAgICAgICBnID0gdGVtcCA8IDYgPyAwIDogLTE1NS4yNTQ4NTU2MjcwOTE3OSAtIDAuNDQ1OTY5NTA0Njk1NzkxMzMgKiAoZyA9IHRlbXAtMikgKyAxMDQuNDkyMTYxOTkzOTM4ODggKiBsb2ckMShnKTtcbiAgICAgICAgICAgIGIgPSB0ZW1wIDwgMjAgPyAwIDogLTI1NC43NjkzNTE4NDEyMDkwMiArIDAuODI3NDA5NjA2NDAwNzM5NSAqIChiID0gdGVtcC0xMCkgKyAxMTUuNjc5OTQ0MDEwNjYxNDcgKiBsb2ckMShiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHIgPSAzNTEuOTc2OTA1NjY4MDU2OTMgKyAwLjExNDIwNjQ1Mzc4NDE2NSAqIChyID0gdGVtcC01NSkgLSA0MC4yNTM2NjMwOTMzMjEyNyAqIGxvZyQxKHIpO1xuICAgICAgICAgICAgZyA9IDMyNS40NDk0MTI1NzExOTc0ICsgMC4wNzk0MzQ1NjUzNjY2MjM0MiAqIChnID0gdGVtcC01MCkgLSAyOC4wODUyOTYzNTA3OTU3ICogbG9nJDEoZyk7XG4gICAgICAgICAgICBiID0gMjU1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcixnLGIsMV07XG4gICAgfTtcblxuICAgIHZhciB0ZW1wZXJhdHVyZTJyZ2JfMSA9IHRlbXBlcmF0dXJlMnJnYiQxO1xuXG4gICAgLypcbiAgICAgKiBCYXNlZCBvbiBpbXBsZW1lbnRhdGlvbiBieSBOZWlsIEJhcnRsZXR0XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL25laWxiYXJ0bGV0dC9jb2xvci10ZW1wZXJhdHVyZVxuICAgICAqKi9cblxuICAgIHZhciB0ZW1wZXJhdHVyZTJyZ2IgPSB0ZW1wZXJhdHVyZTJyZ2JfMTtcbiAgICB2YXIgdW5wYWNrJDYgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuICAgIHZhciByZ2IydGVtcGVyYXR1cmUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmdiID0gdW5wYWNrJDYoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJnYlswXSwgYiA9IHJnYlsyXTtcbiAgICAgICAgdmFyIG1pblRlbXAgPSAxMDAwO1xuICAgICAgICB2YXIgbWF4VGVtcCA9IDQwMDAwO1xuICAgICAgICB2YXIgZXBzID0gMC40O1xuICAgICAgICB2YXIgdGVtcDtcbiAgICAgICAgd2hpbGUgKG1heFRlbXAgLSBtaW5UZW1wID4gZXBzKSB7XG4gICAgICAgICAgICB0ZW1wID0gKG1heFRlbXAgKyBtaW5UZW1wKSAqIDAuNTtcbiAgICAgICAgICAgIHZhciByZ2IkMSA9IHRlbXBlcmF0dXJlMnJnYih0ZW1wKTtcbiAgICAgICAgICAgIGlmICgocmdiJDFbMl0gLyByZ2IkMVswXSkgPj0gKGIgLyByKSkge1xuICAgICAgICAgICAgICAgIG1heFRlbXAgPSB0ZW1wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5UZW1wID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm91bmQodGVtcCk7XG4gICAgfTtcblxuICAgIHZhciByZ2IydGVtcGVyYXR1cmVfMSA9IHJnYjJ0ZW1wZXJhdHVyZSQxO1xuXG4gICAgdmFyIGNocm9tYSQ3ID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHAgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQyID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2IydGVtcGVyYXR1cmUgPSByZ2IydGVtcGVyYXR1cmVfMTtcblxuICAgIENvbG9yJHAucHJvdG90eXBlLnRlbXAgPVxuICAgIENvbG9yJHAucHJvdG90eXBlLmtlbHZpbiA9XG4gICAgQ29sb3IkcC5wcm90b3R5cGUudGVtcGVyYXR1cmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJ0ZW1wZXJhdHVyZSh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkNy50ZW1wID1cbiAgICBjaHJvbWEkNy5rZWx2aW4gPVxuICAgIGNocm9tYSQ3LnRlbXBlcmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRwLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsndGVtcCddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkMi5mb3JtYXQudGVtcCA9XG4gICAgaW5wdXQkMi5mb3JtYXQua2VsdmluID1cbiAgICBpbnB1dCQyLmZvcm1hdC50ZW1wZXJhdHVyZSA9IHRlbXBlcmF0dXJlMnJnYl8xO1xuXG4gICAgdmFyIHVucGFjayQ1ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBjYnJ0ID0gTWF0aC5jYnJ0O1xuICAgIHZhciBwb3ckOCA9IE1hdGgucG93O1xuICAgIHZhciBzaWduJDEgPSBNYXRoLnNpZ247XG5cbiAgICB2YXIgcmdiMm9rbGFiJDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgLy8gT0tMYWIgY29sb3Igc3BhY2UgaW1wbGVtZW50YXRpb24gdGFrZW4gZnJvbVxuICAgICAgICAvLyBodHRwczovL2JvdHRvc3Nvbi5naXRodWIuaW8vcG9zdHMvb2tsYWIvXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skNShhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IFtyZ2IybHJnYihyIC8gMjU1KSwgcmdiMmxyZ2IoZyAvIDI1NSksIHJnYjJscmdiKGIgLyAyNTUpXTtcbiAgICAgICAgdmFyIGxyID0gcmVmJDFbMF07XG4gICAgICAgIHZhciBsZyA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgbGIgPSByZWYkMVsyXTtcbiAgICAgICAgdmFyIGwgPSBjYnJ0KDAuNDEyMjIxNDcwOCAqIGxyICsgMC41MzYzMzI1MzYzICogbGcgKyAwLjA1MTQ0NTk5MjkgKiBsYik7XG4gICAgICAgIHZhciBtID0gY2JydCgwLjIxMTkwMzQ5ODIgKiBsciArIDAuNjgwNjk5NTQ1MSAqIGxnICsgMC4xMDczOTY5NTY2ICogbGIpO1xuICAgICAgICB2YXIgcyA9IGNicnQoMC4wODgzMDI0NjE5ICogbHIgKyAwLjI4MTcxODgzNzYgKiBsZyArIDAuNjI5OTc4NzAwNSAqIGxiKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMC4yMTA0NTQyNTUzICogbCArIDAuNzkzNjE3Nzg1ICogbSAtIDAuMDA0MDcyMDQ2OCAqIHMsXG4gICAgICAgICAgICAxLjk3Nzk5ODQ5NTEgKiBsIC0gMi40Mjg1OTIyMDUgKiBtICsgMC40NTA1OTM3MDk5ICogcyxcbiAgICAgICAgICAgIDAuMDI1OTA0MDM3MSAqIGwgKyAwLjc4Mjc3MTc2NjIgKiBtIC0gMC44MDg2NzU3NjYgKiBzXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIHZhciByZ2Iyb2tsYWJfMSA9IHJnYjJva2xhYiQyO1xuXG4gICAgZnVuY3Rpb24gcmdiMmxyZ2IoYykge1xuICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMoYyk7XG4gICAgICAgIGlmIChhYnMgPCAwLjA0MDQ1KSB7XG4gICAgICAgICAgICByZXR1cm4gYyAvIDEyLjkyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2lnbiQxKGMpIHx8IDEpICogcG93JDgoKGFicyArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICAgIH1cblxuICAgIHZhciB1bnBhY2skNCA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgcG93JDcgPSBNYXRoLnBvdztcbiAgICB2YXIgc2lnbiA9IE1hdGguc2lnbjtcblxuICAgIC8qXG4gICAgICogTCogWzAuLjEwMF1cbiAgICAgKiBhIFstMTAwLi4xMDBdXG4gICAgICogYiBbLTEwMC4uMTAwXVxuICAgICAqL1xuICAgIHZhciBva2xhYjJyZ2IkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJDQoYXJncywgJ2xhYicpO1xuICAgICAgICB2YXIgTCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBhID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGIgPSBhcmdzWzJdO1xuXG4gICAgICAgIHZhciBsID0gcG93JDcoTCArIDAuMzk2MzM3Nzc3NCAqIGEgKyAwLjIxNTgwMzc1NzMgKiBiLCAzKTtcbiAgICAgICAgdmFyIG0gPSBwb3ckNyhMIC0gMC4xMDU1NjEzNDU4ICogYSAtIDAuMDYzODU0MTcyOCAqIGIsIDMpO1xuICAgICAgICB2YXIgcyA9IHBvdyQ3KEwgLSAwLjA4OTQ4NDE3NzUgKiBhIC0gMS4yOTE0ODU1NDggKiBiLCAzKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMjU1ICogbHJnYjJyZ2IoKzQuMDc2NzQxNjYyMSAqIGwgLSAzLjMwNzcxMTU5MTMgKiBtICsgMC4yMzA5Njk5MjkyICogcyksXG4gICAgICAgICAgICAyNTUgKiBscmdiMnJnYigtMS4yNjg0MzgwMDQ2ICogbCArIDIuNjA5NzU3NDAxMSAqIG0gLSAwLjM0MTMxOTM5NjUgKiBzKSxcbiAgICAgICAgICAgIDI1NSAqIGxyZ2IycmdiKC0wLjAwNDE5NjA4NjMgKiBsIC0gMC43MDM0MTg2MTQ3ICogbSArIDEuNzA3NjE0NzAxICogcyksXG4gICAgICAgICAgICBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICB2YXIgb2tsYWIycmdiXzEgPSBva2xhYjJyZ2IkMTtcblxuICAgIGZ1bmN0aW9uIGxyZ2IycmdiKGMpIHtcbiAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKGMpO1xuICAgICAgICBpZiAoYWJzID4gMC4wMDMxMzA4KSB7XG4gICAgICAgICAgICByZXR1cm4gKHNpZ24oYykgfHwgMSkgKiAoMS4wNTUgKiBwb3ckNyhhYnMsIDEgLyAyLjQpIC0gMC4wNTUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjICogMTIuOTI7XG4gICAgfVxuXG4gICAgdmFyIHVucGFjayQzID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJDggPSB1dGlscy50eXBlO1xuICAgIHZhciBjaHJvbWEkNiA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciRvID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkMSA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMm9rbGFiJDEgPSByZ2Iyb2tsYWJfMTtcblxuICAgIENvbG9yJG8ucHJvdG90eXBlLm9rbGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmdiMm9rbGFiJDEodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJDYub2tsYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJG8sIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydva2xhYiddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkMS5mb3JtYXQub2tsYWIgPSBva2xhYjJyZ2JfMTtcblxuICAgIGlucHV0JDEuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMyxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skMyhhcmdzLCAnb2tsYWInKTtcbiAgICAgICAgICAgIGlmICh0eXBlJDgoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29rbGFiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayQyID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciByZ2Iyb2tsYWIgPSByZ2Iyb2tsYWJfMTtcbiAgICB2YXIgbGFiMmxjaCA9IGxhYjJsY2hfMTtcblxuICAgIHZhciByZ2Iyb2tsY2gkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJDIoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSByZ2Iyb2tsYWIociwgZywgYik7XG4gICAgICAgIHZhciBsID0gcmVmJDFbMF07XG4gICAgICAgIHZhciBhID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBiXyA9IHJlZiQxWzJdO1xuICAgICAgICByZXR1cm4gbGFiMmxjaChsLCBhLCBiXyk7XG4gICAgfTtcblxuICAgIHZhciByZ2Iyb2tsY2hfMSA9IHJnYjJva2xjaCQxO1xuXG4gICAgdmFyIHVucGFjayQxID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsY2gybGFiID0gbGNoMmxhYl8xO1xuICAgIHZhciBva2xhYjJyZ2IgPSBva2xhYjJyZ2JfMTtcblxuICAgIHZhciBva2xjaDJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayQxKGFyZ3MsICdsY2gnKTtcbiAgICAgICAgdmFyIGwgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBoID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHJlZiA9IGxjaDJsYWIobCwgYywgaCk7XG4gICAgICAgIHZhciBMID0gcmVmWzBdO1xuICAgICAgICB2YXIgYSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGJfID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSBva2xhYjJyZ2IoTCwgYSwgYl8pO1xuICAgICAgICB2YXIgciA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZiQxWzJdO1xuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgICB9O1xuXG4gICAgdmFyIG9rbGNoMnJnYl8xID0gb2tsY2gycmdiO1xuXG4gICAgdmFyIHVucGFjayA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSQ3ID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2hyb21hJDUgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkbiA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0ID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2Iyb2tsY2ggPSByZ2Iyb2tsY2hfMTtcblxuICAgIENvbG9yJG4ucHJvdG90eXBlLm9rbGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmdiMm9rbGNoKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSQ1Lm9rbGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRuLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnb2tsY2gnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0LmZvcm1hdC5va2xjaCA9IG9rbGNoMnJnYl8xO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMyxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ29rbGNoJyk7XG4gICAgICAgICAgICBpZiAodHlwZSQ3KGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdva2xjaCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBDb2xvciRtID0gQ29sb3JfMTtcbiAgICB2YXIgdHlwZSQ2ID0gdXRpbHMudHlwZTtcblxuICAgIENvbG9yJG0ucHJvdG90eXBlLmFscGhhID0gZnVuY3Rpb24oYSwgbXV0YXRlKSB7XG4gICAgICAgIGlmICggbXV0YXRlID09PSB2b2lkIDAgKSBtdXRhdGU9ZmFsc2U7XG5cbiAgICAgICAgaWYgKGEgIT09IHVuZGVmaW5lZCAmJiB0eXBlJDYoYSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAobXV0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmdiWzNdID0gYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkbShbdGhpcy5fcmdiWzBdLCB0aGlzLl9yZ2JbMV0sIHRoaXMuX3JnYlsyXSwgYV0sICdyZ2InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmdiWzNdO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkbCA9IENvbG9yXzE7XG5cbiAgICBDb2xvciRsLnByb3RvdHlwZS5jbGlwcGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZ2IuX2NsaXBwZWQgfHwgZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRrID0gQ29sb3JfMTtcbiAgICB2YXIgTEFCX0NPTlNUQU5UUyQxID0gbGFiQ29uc3RhbnRzO1xuXG4gICAgQ29sb3Ikay5wcm90b3R5cGUuZGFya2VuID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgXHRpZiAoIGFtb3VudCA9PT0gdm9pZCAwICkgYW1vdW50PTE7XG5cbiAgICBcdHZhciBtZSA9IHRoaXM7XG4gICAgXHR2YXIgbGFiID0gbWUubGFiKCk7XG4gICAgXHRsYWJbMF0gLT0gTEFCX0NPTlNUQU5UUyQxLktuICogYW1vdW50O1xuICAgIFx0cmV0dXJuIG5ldyBDb2xvciRrKGxhYiwgJ2xhYicpLmFscGhhKG1lLmFscGhhKCksIHRydWUpO1xuICAgIH07XG5cbiAgICBDb2xvciRrLnByb3RvdHlwZS5icmlnaHRlbiA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIFx0aWYgKCBhbW91bnQgPT09IHZvaWQgMCApIGFtb3VudD0xO1xuXG4gICAgXHRyZXR1cm4gdGhpcy5kYXJrZW4oLWFtb3VudCk7XG4gICAgfTtcblxuICAgIENvbG9yJGsucHJvdG90eXBlLmRhcmtlciA9IENvbG9yJGsucHJvdG90eXBlLmRhcmtlbjtcbiAgICBDb2xvciRrLnByb3RvdHlwZS5icmlnaHRlciA9IENvbG9yJGsucHJvdG90eXBlLmJyaWdodGVuO1xuXG4gICAgdmFyIENvbG9yJGogPSBDb2xvcl8xO1xuXG4gICAgQ29sb3Ikai5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG1jKSB7XG4gICAgICAgIHZhciByZWYgPSBtYy5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgbW9kZSA9IHJlZlswXTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSByZWZbMV07XG4gICAgICAgIHZhciBzcmMgPSB0aGlzW21vZGVdKCk7XG4gICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG1vZGUuaW5kZXhPZihjaGFubmVsKSAtIChtb2RlLnN1YnN0cigwLCAyKSA9PT0gJ29rJyA/IDIgOiAwKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHsgcmV0dXJuIHNyY1tpXTsgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcInVua25vd24gY2hhbm5lbCBcIiArIGNoYW5uZWwgKyBcIiBpbiBtb2RlIFwiICsgbW9kZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkaSA9IENvbG9yXzE7XG4gICAgdmFyIHR5cGUkNSA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIHBvdyQ2ID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgRVBTID0gMWUtNztcbiAgICB2YXIgTUFYX0lURVIgPSAyMDtcblxuICAgIENvbG9yJGkucHJvdG90eXBlLmx1bWluYW5jZSA9IGZ1bmN0aW9uKGx1bSkge1xuICAgICAgICBpZiAobHVtICE9PSB1bmRlZmluZWQgJiYgdHlwZSQ1KGx1bSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAobHVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHB1cmUgYmxhY2tcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yJGkoWzAsMCwwLHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsdW0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcHVyZSB3aGl0ZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkaShbMjU1LDI1NSwyNTUsdGhpcy5fcmdiWzNdXSwgJ3JnYicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29tcHV0ZSBuZXcgY29sb3IgdXNpbmcuLi5cbiAgICAgICAgICAgIHZhciBjdXJfbHVtID0gdGhpcy5sdW1pbmFuY2UoKTtcbiAgICAgICAgICAgIHZhciBtb2RlID0gJ3JnYic7XG4gICAgICAgICAgICB2YXIgbWF4X2l0ZXIgPSBNQVhfSVRFUjtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pZCA9IGxvdy5pbnRlcnBvbGF0ZShoaWdoLCAwLjUsIG1vZGUpO1xuICAgICAgICAgICAgICAgIHZhciBsbSA9IG1pZC5sdW1pbmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobHVtIC0gbG0pIDwgRVBTIHx8ICFtYXhfaXRlci0tKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsb3NlIGVub3VnaFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbG0gPiBsdW0gPyB0ZXN0KGxvdywgbWlkKSA6IHRlc3QobWlkLCBoaWdoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZ2IgPSAoY3VyX2x1bSA+IGx1bSA/IHRlc3QobmV3IENvbG9yJGkoWzAsMCwwXSksIHRoaXMpIDogdGVzdCh0aGlzLCBuZXcgQ29sb3IkaShbMjU1LDI1NSwyNTVdKSkpLnJnYigpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciRpKHJnYi5jb25jYXQoIFt0aGlzLl9yZ2JbM11dKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJnYjJsdW1pbmFuY2UuYXBwbHkodm9pZCAwLCAodGhpcy5fcmdiKS5zbGljZSgwLDMpKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgcmdiMmx1bWluYW5jZSA9IGZ1bmN0aW9uIChyLGcsYikge1xuICAgICAgICAvLyByZWxhdGl2ZSBsdW1pbmFuY2VcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgICAgciA9IGx1bWluYW5jZV94KHIpO1xuICAgICAgICBnID0gbHVtaW5hbmNlX3goZyk7XG4gICAgICAgIGIgPSBsdW1pbmFuY2VfeChiKTtcbiAgICAgICAgcmV0dXJuIDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYjtcbiAgICB9O1xuXG4gICAgdmFyIGx1bWluYW5jZV94ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeCAvPSAyNTU7XG4gICAgICAgIHJldHVybiB4IDw9IDAuMDM5MjggPyB4LzEyLjkyIDogcG93JDYoKHgrMC4wNTUpLzEuMDU1LCAyLjQpO1xuICAgIH07XG5cbiAgICB2YXIgaW50ZXJwb2xhdG9yJDEgPSB7fTtcblxuICAgIHZhciBDb2xvciRoID0gQ29sb3JfMTtcbiAgICB2YXIgdHlwZSQ0ID0gdXRpbHMudHlwZTtcbiAgICB2YXIgaW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdG9yJDE7XG5cbiAgICB2YXIgbWl4JDEgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICBpZiAoIGYgPT09IHZvaWQgMCApIGY9MC41O1xuICAgICAgICB2YXIgcmVzdCA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMztcbiAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSByZXN0WyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMyBdO1xuXG4gICAgICAgIHZhciBtb2RlID0gcmVzdFswXSB8fCAnbHJnYic7XG4gICAgICAgIGlmICghaW50ZXJwb2xhdG9yW21vZGVdICYmICFyZXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBmaXJzdCBzdXBwb3J0ZWQgbW9kZVxuICAgICAgICAgICAgbW9kZSA9IE9iamVjdC5rZXlzKGludGVycG9sYXRvcilbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnRlcnBvbGF0b3JbbW9kZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJpbnRlcnBvbGF0aW9uIG1vZGUgXCIgKyBtb2RlICsgXCIgaXMgbm90IGRlZmluZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlJDQoY29sMSkgIT09ICdvYmplY3QnKSB7IGNvbDEgPSBuZXcgQ29sb3IkaChjb2wxKTsgfVxuICAgICAgICBpZiAodHlwZSQ0KGNvbDIpICE9PSAnb2JqZWN0JykgeyBjb2wyID0gbmV3IENvbG9yJGgoY29sMik7IH1cbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRvclttb2RlXShjb2wxLCBjb2wyLCBmKVxuICAgICAgICAgICAgLmFscGhhKGNvbDEuYWxwaGEoKSArIGYgKiAoY29sMi5hbHBoYSgpIC0gY29sMS5hbHBoYSgpKSk7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRnID0gQ29sb3JfMTtcbiAgICB2YXIgbWl4ID0gbWl4JDE7XG5cbiAgICBDb2xvciRnLnByb3RvdHlwZS5taXggPVxuICAgIENvbG9yJGcucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24oY29sMiwgZikge1xuICAgIFx0aWYgKCBmID09PSB2b2lkIDAgKSBmPTAuNTtcbiAgICBcdHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIFx0d2hpbGUgKCBsZW4tLSA+IDAgKSByZXN0WyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG4gICAgXHRyZXR1cm4gbWl4LmFwcGx5KHZvaWQgMCwgWyB0aGlzLCBjb2wyLCBmIF0uY29uY2F0KCByZXN0ICkpO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkZiA9IENvbG9yXzE7XG5cbiAgICBDb2xvciRmLnByb3RvdHlwZS5wcmVtdWx0aXBseSA9IGZ1bmN0aW9uKG11dGF0ZSkge1xuICAgIFx0aWYgKCBtdXRhdGUgPT09IHZvaWQgMCApIG11dGF0ZT1mYWxzZTtcblxuICAgIFx0dmFyIHJnYiA9IHRoaXMuX3JnYjtcbiAgICBcdHZhciBhID0gcmdiWzNdO1xuICAgIFx0aWYgKG11dGF0ZSkge1xuICAgIFx0XHR0aGlzLl9yZ2IgPSBbcmdiWzBdKmEsIHJnYlsxXSphLCByZ2JbMl0qYSwgYV07XG4gICAgXHRcdHJldHVybiB0aGlzO1xuICAgIFx0fSBlbHNlIHtcbiAgICBcdFx0cmV0dXJuIG5ldyBDb2xvciRmKFtyZ2JbMF0qYSwgcmdiWzFdKmEsIHJnYlsyXSphLCBhXSwgJ3JnYicpO1xuICAgIFx0fVxuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkZSA9IENvbG9yXzE7XG4gICAgdmFyIExBQl9DT05TVEFOVFMgPSBsYWJDb25zdGFudHM7XG5cbiAgICBDb2xvciRlLnByb3RvdHlwZS5zYXR1cmF0ZSA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIFx0aWYgKCBhbW91bnQgPT09IHZvaWQgMCApIGFtb3VudD0xO1xuXG4gICAgXHR2YXIgbWUgPSB0aGlzO1xuICAgIFx0dmFyIGxjaCA9IG1lLmxjaCgpO1xuICAgIFx0bGNoWzFdICs9IExBQl9DT05TVEFOVFMuS24gKiBhbW91bnQ7XG4gICAgXHRpZiAobGNoWzFdIDwgMCkgeyBsY2hbMV0gPSAwOyB9XG4gICAgXHRyZXR1cm4gbmV3IENvbG9yJGUobGNoLCAnbGNoJykuYWxwaGEobWUuYWxwaGEoKSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIENvbG9yJGUucHJvdG90eXBlLmRlc2F0dXJhdGUgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgICBcdGlmICggYW1vdW50ID09PSB2b2lkIDAgKSBhbW91bnQ9MTtcblxuICAgIFx0cmV0dXJuIHRoaXMuc2F0dXJhdGUoLWFtb3VudCk7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRkID0gQ29sb3JfMTtcbiAgICB2YXIgdHlwZSQzID0gdXRpbHMudHlwZTtcblxuICAgIENvbG9yJGQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChtYywgdmFsdWUsIG11dGF0ZSkge1xuICAgICAgICBpZiAoIG11dGF0ZSA9PT0gdm9pZCAwICkgbXV0YXRlID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHJlZiA9IG1jLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBtb2RlID0gcmVmWzBdO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHJlZlsxXTtcbiAgICAgICAgdmFyIHNyYyA9IHRoaXNbbW9kZV0oKTtcbiAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIHZhciBpID0gbW9kZS5pbmRleE9mKGNoYW5uZWwpIC0gKG1vZGUuc3Vic3RyKDAsIDIpID09PSAnb2snID8gMiA6IDApO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlJDModmFsdWUpID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUuY2hhckF0KDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbaV0gKz0gK3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldICs9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tpXSAqPSArdmFsdWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldIC89ICt2YWx1ZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tpXSA9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSQzKHZhbHVlKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgdmFsdWUgZm9yIENvbG9yLnNldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBDb2xvciRkKHNyYywgbW9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZ2IgPSBvdXQuX3JnYjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwidW5rbm93biBjaGFubmVsIFwiICsgY2hhbm5lbCArIFwiIGluIG1vZGUgXCIgKyBtb2RlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRjID0gQ29sb3JfMTtcblxuICAgIHZhciByZ2IgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICB2YXIgeHl6MCA9IGNvbDEuX3JnYjtcbiAgICAgICAgdmFyIHh5ejEgPSBjb2wyLl9yZ2I7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IkYyhcbiAgICAgICAgICAgIHh5ejBbMF0gKyBmICogKHh5ejFbMF0teHl6MFswXSksXG4gICAgICAgICAgICB4eXowWzFdICsgZiAqICh4eXoxWzFdLXh5ejBbMV0pLFxuICAgICAgICAgICAgeHl6MFsyXSArIGYgKiAoeHl6MVsyXS14eXowWzJdKSxcbiAgICAgICAgICAgICdyZ2InXG4gICAgICAgIClcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEucmdiID0gcmdiO1xuXG4gICAgdmFyIENvbG9yJGIgPSBDb2xvcl8xO1xuICAgIHZhciBzcXJ0JDIgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIHBvdyQ1ID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgbHJnYiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHZhciByZWYgPSBjb2wxLl9yZ2I7XG4gICAgICAgIHZhciB4MSA9IHJlZlswXTtcbiAgICAgICAgdmFyIHkxID0gcmVmWzFdO1xuICAgICAgICB2YXIgejEgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IGNvbDIuX3JnYjtcbiAgICAgICAgdmFyIHgyID0gcmVmJDFbMF07XG4gICAgICAgIHZhciB5MiA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgejIgPSByZWYkMVsyXTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvciRiKFxuICAgICAgICAgICAgc3FydCQyKHBvdyQ1KHgxLDIpICogKDEtZikgKyBwb3ckNSh4MiwyKSAqIGYpLFxuICAgICAgICAgICAgc3FydCQyKHBvdyQ1KHkxLDIpICogKDEtZikgKyBwb3ckNSh5MiwyKSAqIGYpLFxuICAgICAgICAgICAgc3FydCQyKHBvdyQ1KHoxLDIpICogKDEtZikgKyBwb3ckNSh6MiwyKSAqIGYpLFxuICAgICAgICAgICAgJ3JnYidcbiAgICAgICAgKVxuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5scmdiID0gbHJnYjtcblxuICAgIHZhciBDb2xvciRhID0gQ29sb3JfMTtcblxuICAgIHZhciBsYWIgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICB2YXIgeHl6MCA9IGNvbDEubGFiKCk7XG4gICAgICAgIHZhciB4eXoxID0gY29sMi5sYWIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvciRhKFxuICAgICAgICAgICAgeHl6MFswXSArIGYgKiAoeHl6MVswXS14eXowWzBdKSxcbiAgICAgICAgICAgIHh5ejBbMV0gKyBmICogKHh5ejFbMV0teHl6MFsxXSksXG4gICAgICAgICAgICB4eXowWzJdICsgZiAqICh4eXoxWzJdLXh5ejBbMl0pLFxuICAgICAgICAgICAgJ2xhYidcbiAgICAgICAgKVxuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5sYWIgPSBsYWI7XG5cbiAgICB2YXIgQ29sb3IkOSA9IENvbG9yXzE7XG5cbiAgICB2YXIgX2hzeCA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmLCBtKSB7XG4gICAgICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxO1xuXG4gICAgICAgIHZhciB4eXowLCB4eXoxO1xuICAgICAgICBpZiAobSA9PT0gJ2hzbCcpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzbCgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHNsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hzdicpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzdigpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHN2KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hjZycpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhjZygpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaGNnKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hzaScpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzaSgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHNpKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2xjaCcgfHwgbSA9PT0gJ2hjbCcpIHtcbiAgICAgICAgICAgIG0gPSAnaGNsJztcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhjbCgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaGNsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ29rbGNoJykge1xuICAgICAgICAgICAgeHl6MCA9IGNvbDEub2tsY2goKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB4eXoxID0gY29sMi5va2xjaCgpLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBodWUwLCBodWUxLCBzYXQwLCBzYXQxLCBsYnYwLCBsYnYxO1xuICAgICAgICBpZiAobS5zdWJzdHIoMCwgMSkgPT09ICdoJyB8fCBtID09PSAnb2tsY2gnKSB7XG4gICAgICAgICAgICAoYXNzaWduID0geHl6MCwgaHVlMCA9IGFzc2lnblswXSwgc2F0MCA9IGFzc2lnblsxXSwgbGJ2MCA9IGFzc2lnblsyXSk7XG4gICAgICAgICAgICAoYXNzaWduJDEgPSB4eXoxLCBodWUxID0gYXNzaWduJDFbMF0sIHNhdDEgPSBhc3NpZ24kMVsxXSwgbGJ2MSA9IGFzc2lnbiQxWzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzYXQsIGh1ZSwgbGJ2LCBkaDtcblxuICAgICAgICBpZiAoIWlzTmFOKGh1ZTApICYmICFpc05hTihodWUxKSkge1xuICAgICAgICAgICAgLy8gYm90aCBjb2xvcnMgaGF2ZSBodWVcbiAgICAgICAgICAgIGlmIChodWUxID4gaHVlMCAmJiBodWUxIC0gaHVlMCA+IDE4MCkge1xuICAgICAgICAgICAgICAgIGRoID0gaHVlMSAtIChodWUwICsgMzYwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaHVlMSA8IGh1ZTAgJiYgaHVlMCAtIGh1ZTEgPiAxODApIHtcbiAgICAgICAgICAgICAgICBkaCA9IGh1ZTEgKyAzNjAgLSBodWUwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaCA9IGh1ZTEgLSBodWUwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHVlID0gaHVlMCArIGYgKiBkaDtcbiAgICAgICAgfSBlbHNlIGlmICghaXNOYU4oaHVlMCkpIHtcbiAgICAgICAgICAgIGh1ZSA9IGh1ZTA7XG4gICAgICAgICAgICBpZiAoKGxidjEgPT0gMSB8fCBsYnYxID09IDApICYmIG0gIT0gJ2hzdicpIHsgc2F0ID0gc2F0MDsgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihodWUxKSkge1xuICAgICAgICAgICAgaHVlID0gaHVlMTtcbiAgICAgICAgICAgIGlmICgobGJ2MCA9PSAxIHx8IGxidjAgPT0gMCkgJiYgbSAhPSAnaHN2JykgeyBzYXQgPSBzYXQxOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodWUgPSBOdW1iZXIuTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNhdCA9PT0gdW5kZWZpbmVkKSB7IHNhdCA9IHNhdDAgKyBmICogKHNhdDEgLSBzYXQwKTsgfVxuICAgICAgICBsYnYgPSBsYnYwICsgZiAqIChsYnYxIC0gbGJ2MCk7XG4gICAgICAgIHJldHVybiBtID09PSAnb2tsY2gnID8gbmV3IENvbG9yJDkoW2xidiwgc2F0LCBodWVdLCBtKSA6IG5ldyBDb2xvciQ5KFtodWUsIHNhdCwgbGJ2XSwgbSk7XG4gICAgfTtcblxuICAgIHZhciBpbnRlcnBvbGF0ZV9oc3gkNSA9IF9oc3g7XG5cbiAgICB2YXIgbGNoID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICBcdHJldHVybiBpbnRlcnBvbGF0ZV9oc3gkNShjb2wxLCBjb2wyLCBmLCAnbGNoJyk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLmxjaCA9IGxjaDtcbiAgICBpbnRlcnBvbGF0b3IkMS5oY2wgPSBsY2g7XG5cbiAgICB2YXIgQ29sb3IkOCA9IENvbG9yXzE7XG5cbiAgICB2YXIgbnVtID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgdmFyIGMxID0gY29sMS5udW0oKTtcbiAgICAgICAgdmFyIGMyID0gY29sMi5udW0oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQ4KGMxICsgZiAqIChjMi1jMSksICdudW0nKVxuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5udW0gPSBudW07XG5cbiAgICB2YXIgaW50ZXJwb2xhdGVfaHN4JDQgPSBfaHN4O1xuXG4gICAgdmFyIGhjZyA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgXHRyZXR1cm4gaW50ZXJwb2xhdGVfaHN4JDQoY29sMSwgY29sMiwgZiwgJ2hjZycpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5oY2cgPSBoY2c7XG5cbiAgICB2YXIgaW50ZXJwb2xhdGVfaHN4JDMgPSBfaHN4O1xuXG4gICAgdmFyIGhzaSA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgXHRyZXR1cm4gaW50ZXJwb2xhdGVfaHN4JDMoY29sMSwgY29sMiwgZiwgJ2hzaScpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5oc2kgPSBoc2k7XG5cbiAgICB2YXIgaW50ZXJwb2xhdGVfaHN4JDIgPSBfaHN4O1xuXG4gICAgdmFyIGhzbCA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgXHRyZXR1cm4gaW50ZXJwb2xhdGVfaHN4JDIoY29sMSwgY29sMiwgZiwgJ2hzbCcpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5oc2wgPSBoc2w7XG5cbiAgICB2YXIgaW50ZXJwb2xhdGVfaHN4JDEgPSBfaHN4O1xuXG4gICAgdmFyIGhzdiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgXHRyZXR1cm4gaW50ZXJwb2xhdGVfaHN4JDEoY29sMSwgY29sMiwgZiwgJ2hzdicpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5oc3YgPSBoc3Y7XG5cbiAgICB2YXIgQ29sb3IkNyA9IENvbG9yXzE7XG5cbiAgICB2YXIgb2tsYWIgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICB2YXIgeHl6MCA9IGNvbDEub2tsYWIoKTtcbiAgICAgICAgdmFyIHh5ejEgPSBjb2wyLm9rbGFiKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IkNyhcbiAgICAgICAgICAgIHh5ejBbMF0gKyBmICogKHh5ejFbMF0gLSB4eXowWzBdKSxcbiAgICAgICAgICAgIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSxcbiAgICAgICAgICAgIHh5ejBbMl0gKyBmICogKHh5ejFbMl0gLSB4eXowWzJdKSxcbiAgICAgICAgICAgICdva2xhYidcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEub2tsYWIgPSBva2xhYjtcblxuICAgIHZhciBpbnRlcnBvbGF0ZV9oc3ggPSBfaHN4O1xuXG4gICAgdmFyIG9rbGNoID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlX2hzeChjb2wxLCBjb2wyLCBmLCAnb2tsY2gnKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEub2tsY2ggPSBva2xjaDtcblxuICAgIHZhciBDb2xvciQ2ID0gQ29sb3JfMTtcbiAgICB2YXIgY2xpcF9yZ2IkMSA9IHV0aWxzLmNsaXBfcmdiO1xuICAgIHZhciBwb3ckNCA9IE1hdGgucG93O1xuICAgIHZhciBzcXJ0JDEgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIFBJJDEgPSBNYXRoLlBJO1xuICAgIHZhciBjb3MkMiA9IE1hdGguY29zO1xuICAgIHZhciBzaW4kMiA9IE1hdGguc2luO1xuICAgIHZhciBhdGFuMiQxID0gTWF0aC5hdGFuMjtcblxuICAgIHZhciBhdmVyYWdlID0gZnVuY3Rpb24gKGNvbG9ycywgbW9kZSwgd2VpZ2h0cykge1xuICAgICAgICBpZiAoIG1vZGUgPT09IHZvaWQgMCApIG1vZGU9J2xyZ2InO1xuICAgICAgICBpZiAoIHdlaWdodHMgPT09IHZvaWQgMCApIHdlaWdodHM9bnVsbDtcblxuICAgICAgICB2YXIgbCA9IGNvbG9ycy5sZW5ndGg7XG4gICAgICAgIGlmICghd2VpZ2h0cykgeyB3ZWlnaHRzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkobCkpLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9KTsgfVxuICAgICAgICAvLyBub3JtYWxpemUgd2VpZ2h0c1xuICAgICAgICB2YXIgayA9IGwgLyB3ZWlnaHRzLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhICsgYjsgfSk7XG4gICAgICAgIHdlaWdodHMuZm9yRWFjaChmdW5jdGlvbiAodyxpKSB7IHdlaWdodHNbaV0gKj0gazsgfSk7XG4gICAgICAgIC8vIGNvbnZlcnQgY29sb3JzIHRvIENvbG9yIG9iamVjdHNcbiAgICAgICAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gbmV3IENvbG9yJDYoYyk7IH0pO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ2xyZ2InKSB7XG4gICAgICAgICAgICByZXR1cm4gX2F2ZXJhZ2VfbHJnYihjb2xvcnMsIHdlaWdodHMpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0ID0gY29sb3JzLnNoaWZ0KCk7XG4gICAgICAgIHZhciB4eXogPSBmaXJzdC5nZXQobW9kZSk7XG4gICAgICAgIHZhciBjbnQgPSBbXTtcbiAgICAgICAgdmFyIGR4ID0gMDtcbiAgICAgICAgdmFyIGR5ID0gMDtcbiAgICAgICAgLy8gaW5pdGlhbCBjb2xvclxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8eHl6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4eXpbaV0gPSAoeHl6W2ldIHx8IDApICogd2VpZ2h0c1swXTtcbiAgICAgICAgICAgIGNudC5wdXNoKGlzTmFOKHh5eltpXSkgPyAwIDogd2VpZ2h0c1swXSk7XG4gICAgICAgICAgICBpZiAobW9kZS5jaGFyQXQoaSkgPT09ICdoJyAmJiAhaXNOYU4oeHl6W2ldKSkge1xuICAgICAgICAgICAgICAgIHZhciBBID0geHl6W2ldIC8gMTgwICogUEkkMTtcbiAgICAgICAgICAgICAgICBkeCArPSBjb3MkMihBKSAqIHdlaWdodHNbMF07XG4gICAgICAgICAgICAgICAgZHkgKz0gc2luJDIoQSkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFscGhhID0gZmlyc3QuYWxwaGEoKSAqIHdlaWdodHNbMF07XG4gICAgICAgIGNvbG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjLGNpKSB7XG4gICAgICAgICAgICB2YXIgeHl6MiA9IGMuZ2V0KG1vZGUpO1xuICAgICAgICAgICAgYWxwaGEgKz0gYy5hbHBoYSgpICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx4eXoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHh5ejJbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNudFtpXSArPSB3ZWlnaHRzW2NpKzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZS5jaGFyQXQoaSkgPT09ICdoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEEgPSB4eXoyW2ldIC8gMTgwICogUEkkMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4ICs9IGNvcyQyKEEpICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ICs9IHNpbiQyKEEpICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHh5eltpXSArPSB4eXoyW2ldICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSQxPTA7IGkkMTx4eXoubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKG1vZGUuY2hhckF0KGkkMSkgPT09ICdoJykge1xuICAgICAgICAgICAgICAgIHZhciBBJDEgPSBhdGFuMiQxKGR5IC8gY250W2kkMV0sIGR4IC8gY250W2kkMV0pIC8gUEkkMSAqIDE4MDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoQSQxIDwgMCkgeyBBJDEgKz0gMzYwOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKEEkMSA+PSAzNjApIHsgQSQxIC09IDM2MDsgfVxuICAgICAgICAgICAgICAgIHh5eltpJDFdID0gQSQxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4eXpbaSQxXSA9IHh5eltpJDFdL2NudFtpJDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFscGhhIC89IGw7XG4gICAgICAgIHJldHVybiAobmV3IENvbG9yJDYoeHl6LCBtb2RlKSkuYWxwaGEoYWxwaGEgPiAwLjk5OTk5ID8gMSA6IGFscGhhLCB0cnVlKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgX2F2ZXJhZ2VfbHJnYiA9IGZ1bmN0aW9uIChjb2xvcnMsIHdlaWdodHMpIHtcbiAgICAgICAgdmFyIGwgPSBjb2xvcnMubGVuZ3RoO1xuICAgICAgICB2YXIgeHl6ID0gWzAsMCwwLDBdO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBjb2xvcnNbaV07XG4gICAgICAgICAgICB2YXIgZiA9IHdlaWdodHNbaV0gLyBsO1xuICAgICAgICAgICAgdmFyIHJnYiA9IGNvbC5fcmdiO1xuICAgICAgICAgICAgeHl6WzBdICs9IHBvdyQ0KHJnYlswXSwyKSAqIGY7XG4gICAgICAgICAgICB4eXpbMV0gKz0gcG93JDQocmdiWzFdLDIpICogZjtcbiAgICAgICAgICAgIHh5elsyXSArPSBwb3ckNChyZ2JbMl0sMikgKiBmO1xuICAgICAgICAgICAgeHl6WzNdICs9IHJnYlszXSAqIGY7XG4gICAgICAgIH1cbiAgICAgICAgeHl6WzBdID0gc3FydCQxKHh5elswXSk7XG4gICAgICAgIHh5elsxXSA9IHNxcnQkMSh4eXpbMV0pO1xuICAgICAgICB4eXpbMl0gPSBzcXJ0JDEoeHl6WzJdKTtcbiAgICAgICAgaWYgKHh5elszXSA+IDAuOTk5OTk5OSkgeyB4eXpbM10gPSAxOyB9XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IkNihjbGlwX3JnYiQxKHh5eikpO1xuICAgIH07XG5cbiAgICAvLyBtaW5pbWFsIG11bHRpLXB1cnBvc2UgaW50ZXJmYWNlXG5cbiAgICAvLyBAcmVxdWlyZXMgdXRpbHMgY29sb3IgYW5hbHl6ZVxuXG4gICAgdmFyIGNocm9tYSQ0ID0gY2hyb21hXzE7XG4gICAgdmFyIHR5cGUkMiA9IHV0aWxzLnR5cGU7XG5cbiAgICB2YXIgcG93JDMgPSBNYXRoLnBvdztcblxuICAgIHZhciBzY2FsZSQyID0gZnVuY3Rpb24oY29sb3JzKSB7XG5cbiAgICAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgdmFyIF9tb2RlID0gJ3JnYic7XG4gICAgICAgIHZhciBfbmFjb2wgPSBjaHJvbWEkNCgnI2NjYycpO1xuICAgICAgICB2YXIgX3NwcmVhZCA9IDA7XG4gICAgICAgIC8vIGNvbnN0IF9maXhlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgX2RvbWFpbiA9IFswLCAxXTtcbiAgICAgICAgdmFyIF9wb3MgPSBbXTtcbiAgICAgICAgdmFyIF9wYWRkaW5nID0gWzAsMF07XG4gICAgICAgIHZhciBfY2xhc3NlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2NvbG9ycyA9IFtdO1xuICAgICAgICB2YXIgX291dCA9IGZhbHNlO1xuICAgICAgICB2YXIgX21pbiA9IDA7XG4gICAgICAgIHZhciBfbWF4ID0gMTtcbiAgICAgICAgdmFyIF9jb3JyZWN0TGlnaHRuZXNzID0gZmFsc2U7XG4gICAgICAgIHZhciBfY29sb3JDYWNoZSA9IHt9O1xuICAgICAgICB2YXIgX3VzZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9nYW1tYSA9IDE7XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBtZXRob2RzXG5cbiAgICAgICAgdmFyIHNldENvbG9ycyA9IGZ1bmN0aW9uKGNvbG9ycykge1xuICAgICAgICAgICAgY29sb3JzID0gY29sb3JzIHx8IFsnI2ZmZicsICcjMDAwJ107XG4gICAgICAgICAgICBpZiAoY29sb3JzICYmIHR5cGUkMihjb2xvcnMpID09PSAnc3RyaW5nJyAmJiBjaHJvbWEkNC5icmV3ZXIgJiZcbiAgICAgICAgICAgICAgICBjaHJvbWEkNC5icmV3ZXJbY29sb3JzLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzID0gY2hyb21hJDQuYnJld2VyW2NvbG9ycy50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlJDIoY29sb3JzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzaW5nbGUgY29sb3JcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMgPSBbY29sb3JzWzBdLCBjb2xvcnNbMF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgY29sb3JzXG4gICAgICAgICAgICAgICAgY29sb3JzID0gY29sb3JzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gY2hyb21hIGNsYXNzZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjPTA7IGM8Y29sb3JzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yc1tjXSA9IGNocm9tYSQ0KGNvbG9yc1tjXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGF1dG8tZmlsbCBjb2xvciBwb3NpdGlvblxuICAgICAgICAgICAgICAgIF9wb3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjJDE9MDsgYyQxPGNvbG9ycy5sZW5ndGg7IGMkMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wb3MucHVzaChjJDEvKGNvbG9ycy5sZW5ndGgtMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIHJldHVybiBfY29sb3JzID0gY29sb3JzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRDbGFzcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoX2NsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gX2NsYXNzZXMubGVuZ3RoLTE7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbiAmJiB2YWx1ZSA+PSBfY2xhc3Nlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9O1xuICAgICAgICB2YXIgdE1hcERvbWFpbiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9O1xuXG4gICAgICAgIC8vIGNvbnN0IGNsYXNzaWZ5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyAgICAgbGV0IHZhbCA9IHZhbHVlO1xuICAgICAgICAvLyAgICAgaWYgKF9jbGFzc2VzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBuID0gX2NsYXNzZXMubGVuZ3RoLTE7XG4gICAgICAgIC8vICAgICAgICAgY29uc3QgaSA9IGdldENsYXNzKHZhbHVlKTtcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBtaW5jID0gX2NsYXNzZXNbMF0gKyAoKF9jbGFzc2VzWzFdLV9jbGFzc2VzWzBdKSAqICgwICsgKF9zcHJlYWQgKiAwLjUpKSk7ICAvLyBjZW50ZXIgb2YgMXN0IGNsYXNzXG4gICAgICAgIC8vICAgICAgICAgY29uc3QgbWF4YyA9IF9jbGFzc2VzW24tMV0gKyAoKF9jbGFzc2VzW25dLV9jbGFzc2VzW24tMV0pICogKDEgLSAoX3NwcmVhZCAqIDAuNSkpKTsgIC8vIGNlbnRlciBvZiBsYXN0IGNsYXNzXG4gICAgICAgIC8vICAgICAgICAgdmFsID0gX21pbiArICgoKChfY2xhc3Nlc1tpXSArICgoX2NsYXNzZXNbaSsxXSAtIF9jbGFzc2VzW2ldKSAqIDAuNSkpIC0gbWluYykgLyAobWF4Yy1taW5jKSkgKiAoX21heCAtIF9taW4pKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIHJldHVybiB2YWw7XG4gICAgICAgIC8vIH07XG5cbiAgICAgICAgdmFyIGdldENvbG9yID0gZnVuY3Rpb24odmFsLCBieXBhc3NNYXApIHtcbiAgICAgICAgICAgIHZhciBjb2wsIHQ7XG4gICAgICAgICAgICBpZiAoYnlwYXNzTWFwID09IG51bGwpIHsgYnlwYXNzTWFwID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChpc05hTih2YWwpIHx8ICh2YWwgPT09IG51bGwpKSB7IHJldHVybiBfbmFjb2w7IH1cbiAgICAgICAgICAgIGlmICghYnlwYXNzTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jbGFzc2VzICYmIChfY2xhc3Nlcy5sZW5ndGggPiAyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBjbGFzc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGdldENsYXNzKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBjIC8gKF9jbGFzc2VzLmxlbmd0aC0yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9tYXggIT09IF9taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBpbnRlcnBvbGF0ZSBiZXR3ZWVuIG1pbi9tYXhcbiAgICAgICAgICAgICAgICAgICAgdCA9ICh2YWwgLSBfbWluKSAvIChfbWF4IC0gX21pbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ID0gdmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkb21haW4gbWFwXG4gICAgICAgICAgICB0ID0gdE1hcERvbWFpbih0KTtcblxuICAgICAgICAgICAgaWYgKCFieXBhc3NNYXApIHtcbiAgICAgICAgICAgICAgICB0ID0gdE1hcExpZ2h0bmVzcyh0KTsgIC8vIGxpZ2h0bmVzcyBjb3JyZWN0aW9uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfZ2FtbWEgIT09IDEpIHsgdCA9IHBvdyQzKHQsIF9nYW1tYSk7IH1cblxuICAgICAgICAgICAgdCA9IF9wYWRkaW5nWzBdICsgKHQgKiAoMSAtIF9wYWRkaW5nWzBdIC0gX3BhZGRpbmdbMV0pKTtcblxuICAgICAgICAgICAgdCA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHQpKTtcblxuICAgICAgICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKHQgKiAxMDAwMCk7XG5cbiAgICAgICAgICAgIGlmIChfdXNlQ2FjaGUgJiYgX2NvbG9yQ2FjaGVba10pIHtcbiAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JDYWNoZVtrXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUkMihfY29sb3JzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAvL2ZvciBpIGluIFswLi5fcG9zLmxlbmd0aC0xXVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8X3Bvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBfcG9zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPD0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHQgPj0gcCkgJiYgKGkgPT09IChfcG9zLmxlbmd0aC0xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPiBwICYmIHQgPCBfcG9zW2krMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQtcCkvKF9wb3NbaSsxXS1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBjaHJvbWEkNC5pbnRlcnBvbGF0ZShfY29sb3JzW2ldLCBfY29sb3JzW2krMV0sIHQsIF9tb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSQyKF9jb2xvcnMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnModCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdXNlQ2FjaGUpIHsgX2NvbG9yQ2FjaGVba10gPSBjb2w7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2w7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlc2V0Q2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfY29sb3JDYWNoZSA9IHt9OyB9O1xuXG4gICAgICAgIHNldENvbG9ycyhjb2xvcnMpO1xuXG4gICAgICAgIC8vIHB1YmxpYyBpbnRlcmZhY2VcblxuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2hyb21hJDQoZ2V0Q29sb3IodikpO1xuICAgICAgICAgICAgaWYgKF9vdXQgJiYgY1tfb3V0XSkgeyByZXR1cm4gY1tfb3V0XSgpOyB9IGVsc2UgeyByZXR1cm4gYzsgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGYuY2xhc3NlcyA9IGZ1bmN0aW9uKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIGlmIChjbGFzc2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSQyKGNsYXNzZXMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc2VzID0gY2xhc3NlcztcbiAgICAgICAgICAgICAgICAgICAgX2RvbWFpbiA9IFtjbGFzc2VzWzBdLCBjbGFzc2VzW2NsYXNzZXMubGVuZ3RoLTFdXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGNocm9tYSQ0LmFuYWx5emUoX2RvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NlcyA9IFtkLm1pbiwgZC5tYXhdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzZXMgPSBjaHJvbWEkNC5saW1pdHMoZCwgJ2UnLCBjbGFzc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfY2xhc3NlcztcbiAgICAgICAgfTtcblxuXG4gICAgICAgIGYuZG9tYWluID0gZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2RvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9taW4gPSBkb21haW5bMF07XG4gICAgICAgICAgICBfbWF4ID0gZG9tYWluW2RvbWFpbi5sZW5ndGgtMV07XG4gICAgICAgICAgICBfcG9zID0gW107XG4gICAgICAgICAgICB2YXIgayA9IF9jb2xvcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChkb21haW4ubGVuZ3RoID09PSBrKSAmJiAoX21pbiAhPT0gX21heCkpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBBcnJheS5mcm9tKGRvbWFpbik7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgICAgICAgX3Bvcy5wdXNoKChkLV9taW4pIC8gKF9tYXgtX21pbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYz0wOyBjPGs7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICBfcG9zLnB1c2goYy8oay0xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkb21haW4ubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgZG9tYWluIG1hcFxuICAgICAgICAgICAgICAgICAgICB2YXIgdE91dCA9IGRvbWFpbi5tYXAoZnVuY3Rpb24gKGQsaSkgeyByZXR1cm4gaS8oZG9tYWluLmxlbmd0aC0xKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0QnJlYWtzID0gZG9tYWluLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gKGQgLSBfbWluKSAvIChfbWF4IC0gX21pbik7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRCcmVha3MuZXZlcnkoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gdE91dFtpXSA9PT0gdmFsOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdE1hcERvbWFpbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPD0gMCB8fCB0ID49IDEpIHsgcmV0dXJuIHQ7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHQgPj0gdEJyZWFrc1tpKzFdKSB7IGkrKzsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gKHQgLSB0QnJlYWtzW2ldKSAvICh0QnJlYWtzW2krMV0gLSB0QnJlYWtzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gdE91dFtpXSArIGYgKiAodE91dFtpKzFdIC0gdE91dFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9kb21haW4gPSBbX21pbiwgX21heF07XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLm1vZGUgPSBmdW5jdGlvbihfbSkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9tb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21vZGUgPSBfbTtcbiAgICAgICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYucmFuZ2UgPSBmdW5jdGlvbihjb2xvcnMsIF9wb3MpIHtcbiAgICAgICAgICAgIHNldENvbG9ycyhjb2xvcnMpO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5vdXQgPSBmdW5jdGlvbihfbykge1xuICAgICAgICAgICAgX291dCA9IF9vO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5zcHJlYWQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3ByZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3NwcmVhZCA9IHZhbDtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuY29ycmVjdExpZ2h0bmVzcyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHsgdiA9IHRydWU7IH1cbiAgICAgICAgICAgIF9jb3JyZWN0TGlnaHRuZXNzID0gdjtcbiAgICAgICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIGlmIChfY29ycmVjdExpZ2h0bmVzcykge1xuICAgICAgICAgICAgICAgIHRNYXBMaWdodG5lc3MgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBMMCA9IGdldENvbG9yKDAsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTDEgPSBnZXRDb2xvcigxLCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvbCA9IEwwID4gTDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBMX2FjdHVhbCA9IGdldENvbG9yKHQsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTF9pZGVhbCA9IEwwICsgKChMMSAtIEwwKSAqIHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTF9kaWZmID0gTF9hY3R1YWwgLSBMX2lkZWFsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDAgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDEgPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4X2l0ZXIgPSAyMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChNYXRoLmFicyhMX2RpZmYpID4gMWUtMikgJiYgKG1heF9pdGVyLS0gPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2wpIHsgTF9kaWZmICo9IC0xOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExfZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDAgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9ICh0MSAtIHQpICogMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCArPSAodDAgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTF9hY3R1YWwgPSBnZXRDb2xvcih0LCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTF9kaWZmID0gTF9hY3R1YWwgLSBMX2lkZWFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0TWFwTGlnaHRuZXNzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnBhZGRpbmcgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBpZiAocCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUkMihwKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IFtwLHBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfcGFkZGluZyA9IHA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcGFkZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmLmNvbG9ycyA9IGZ1bmN0aW9uKG51bUNvbG9ycywgb3V0KSB7XG4gICAgICAgICAgICAvLyBJZiBubyBhcmd1bWVudHMgYXJlIGdpdmVuLCByZXR1cm4gdGhlIG9yaWdpbmFsIGNvbG9ycyB0aGF0IHdlcmUgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgeyBvdXQgPSAnaGV4JzsgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb2xvcnMuc2xpY2UoMCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQ29sb3JzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW2YoMC41KV07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQ29sb3JzID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBkbSA9IF9kb21haW5bMF07XG4gICAgICAgICAgICAgICAgdmFyIGRkID0gX2RvbWFpblsxXSAtIGRtO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9fcmFuZ2VfXygwLCBudW1Db2xvcnMsIGZhbHNlKS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGYoIGRtICsgKChpLyhudW1Db2xvcnMtMSkpICogZGQpICk7IH0pO1xuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyByZXR1cm5zIGFsbCBjb2xvcnMgYmFzZWQgb24gdGhlIGRlZmluZWQgY2xhc3Nlc1xuICAgICAgICAgICAgICAgIGNvbG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBzYW1wbGVzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKF9jbGFzc2VzICYmIChfY2xhc3Nlcy5sZW5ndGggPiAyKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgZW5kID0gX2NsYXNzZXMubGVuZ3RoLCBhc2MgPSAxIDw9IGVuZDsgYXNjID8gaSA8IGVuZCA6IGkgPiBlbmQ7IGFzYyA/IGkrKyA6IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKChfY2xhc3Nlc1tpLTFdK19jbGFzc2VzW2ldKSowLjUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcyA9IF9kb21haW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNhbXBsZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBmKHYpOyB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNocm9tYSQ0W291dF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjW291dF0oKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuY2FjaGUgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3VzZUNhY2hlID0gYztcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF91c2VDYWNoZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmLmdhbW1hID0gZnVuY3Rpb24oZykge1xuICAgICAgICAgICAgaWYgKGcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF9nYW1tYSA9IGc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2FtbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5ub2RhdGEgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBpZiAoZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX25hY29sID0gY2hyb21hJDQoZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbmFjb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9fcmFuZ2VfXyhsZWZ0LCByaWdodCwgaW5jbHVzaXZlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBbXTtcbiAgICAgIHZhciBhc2NlbmRpbmcgPSBsZWZ0IDwgcmlnaHQ7XG4gICAgICB2YXIgZW5kID0gIWluY2x1c2l2ZSA/IHJpZ2h0IDogYXNjZW5kaW5nID8gcmlnaHQgKyAxIDogcmlnaHQgLSAxO1xuICAgICAgZm9yICh2YXIgaSA9IGxlZnQ7IGFzY2VuZGluZyA/IGkgPCBlbmQgOiBpID4gZW5kOyBhc2NlbmRpbmcgPyBpKysgOiBpLS0pIHtcbiAgICAgICAgcmFuZ2UucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIGludGVycG9sYXRlcyBiZXR3ZWVuIGEgc2V0IG9mIGNvbG9ycyB1emluZyBhIGJlemllciBzcGxpbmVcbiAgICAvL1xuXG4gICAgLy8gQHJlcXVpcmVzIHV0aWxzIGxhYlxuICAgIHZhciBDb2xvciQ1ID0gQ29sb3JfMTtcblxuICAgIHZhciBzY2FsZSQxID0gc2NhbGUkMjtcblxuICAgIC8vIG50aCByb3cgb2YgdGhlIHBhc2NhbCB0cmlhbmdsZVxuICAgIHZhciBiaW5vbV9yb3cgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciByb3cgPSBbMSwgMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV3cm93ID0gWzFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3cm93W2pdID0gKHJvd1tqXSB8fCAwKSArIHJvd1tqIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3cgPSBuZXdyb3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICB9O1xuXG4gICAgdmFyIGJlemllciA9IGZ1bmN0aW9uKGNvbG9ycykge1xuICAgICAgICB2YXIgYXNzaWduLCBhc3NpZ24kMSwgYXNzaWduJDI7XG5cbiAgICAgICAgdmFyIEksIGxhYjAsIGxhYjEsIGxhYjI7XG4gICAgICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5ldyBDb2xvciQ1KGMpOyB9KTtcbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAoYXNzaWduID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5sYWIoKTsgfSksIGxhYjAgPSBhc3NpZ25bMF0sIGxhYjEgPSBhc3NpZ25bMV0pO1xuICAgICAgICAgICAgSSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiID0gKFswLCAxLCAyXS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGxhYjBbaV0gKyAodCAqIChsYWIxW2ldIC0gbGFiMFtpXSkpOyB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQ1KGxhYiwgJ2xhYicpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAvLyBxdWFkcmF0aWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIChhc3NpZ24kMSA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubGFiKCk7IH0pLCBsYWIwID0gYXNzaWduJDFbMF0sIGxhYjEgPSBhc3NpZ24kMVsxXSwgbGFiMiA9IGFzc2lnbiQxWzJdKTtcbiAgICAgICAgICAgIEkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYiA9IChbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiAoKDEtdCkqKDEtdCkgKiBsYWIwW2ldKSArICgyICogKDEtdCkgKiB0ICogbGFiMVtpXSkgKyAodCAqIHQgKiBsYWIyW2ldKTsgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkNShsYWIsICdsYWInKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgLy8gY3ViaWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIHZhciBsYWIzO1xuICAgICAgICAgICAgKGFzc2lnbiQyID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5sYWIoKTsgfSksIGxhYjAgPSBhc3NpZ24kMlswXSwgbGFiMSA9IGFzc2lnbiQyWzFdLCBsYWIyID0gYXNzaWduJDJbMl0sIGxhYjMgPSBhc3NpZ24kMlszXSk7XG4gICAgICAgICAgICBJID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWIgPSAoWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gKCgxLXQpKigxLXQpKigxLXQpICogbGFiMFtpXSkgKyAoMyAqICgxLXQpICogKDEtdCkgKiB0ICogbGFiMVtpXSkgKyAoMyAqICgxLXQpICogdCAqIHQgKiBsYWIyW2ldKSArICh0KnQqdCAqIGxhYjNbaV0pOyB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQ1KGxhYiwgJ2xhYicpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID49IDUpIHtcbiAgICAgICAgICAgIC8vIGdlbmVyYWwgY2FzZSAoZGVncmVlIG4gYmV6aWVyKVxuICAgICAgICAgICAgdmFyIGxhYnMsIHJvdywgbjtcbiAgICAgICAgICAgIGxhYnMgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmxhYigpOyB9KTtcbiAgICAgICAgICAgIG4gPSBjb2xvcnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHJvdyA9IGJpbm9tX3JvdyhuKTtcbiAgICAgICAgICAgIEkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciB1ID0gMSAtIHQ7XG4gICAgICAgICAgICAgICAgdmFyIGxhYiA9IChbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBsYWJzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBlbCwgaikgeyByZXR1cm4gKHN1bSArIHJvd1tqXSAqIE1hdGgucG93KCB1LCAobiAtIGopICkgKiBNYXRoLnBvdyggdCwgaiApICogZWxbaV0pOyB9LCAwKTsgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkNShsYWIsICdsYWInKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHBvaW50IGluIHJ1bm5pbmcgYmV6aWVyIHdpdGggb25seSBvbmUgY29sb3IuXCIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEk7XG4gICAgfTtcblxuICAgIHZhciBiZXppZXJfMSA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgICAgICAgdmFyIGYgPSBiZXppZXIoY29sb3JzKTtcbiAgICAgICAgZi5zY2FsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjYWxlJDEoZik7IH07XG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIGludGVycG9sYXRlcyBiZXR3ZWVuIGEgc2V0IG9mIGNvbG9ycyB1emluZyBhIGJlemllciBzcGxpbmVcbiAgICAgKiBibGVuZCBtb2RlIGZvcm11bGFzIHRha2VuIGZyb20gaHR0cDovL3d3dy52ZW50dXJlLXdhcmUuY29tL2tldmluL2NvZGluZy9sZXRzLWxlYXJuLW1hdGgtcGhvdG9zaG9wLWJsZW5kLW1vZGVzL1xuICAgICAqL1xuXG4gICAgdmFyIGNocm9tYSQzID0gY2hyb21hXzE7XG5cbiAgICB2YXIgYmxlbmQgPSBmdW5jdGlvbiAoYm90dG9tLCB0b3AsIG1vZGUpIHtcbiAgICAgICAgaWYgKCFibGVuZFttb2RlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJsZW5kIG1vZGUgJyArIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibGVuZFttb2RlXShib3R0b20sIHRvcCk7XG4gICAgfTtcblxuICAgIHZhciBibGVuZF9mID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChib3R0b20sdG9wKSB7XG4gICAgICAgICAgICB2YXIgYzAgPSBjaHJvbWEkMyh0b3ApLnJnYigpO1xuICAgICAgICAgICAgdmFyIGMxID0gY2hyb21hJDMoYm90dG9tKS5yZ2IoKTtcbiAgICAgICAgICAgIHJldHVybiBjaHJvbWEkMy5yZ2IoZihjMCwgYzEpKTtcbiAgICAgICAgfTsgfTtcblxuICAgIHZhciBlYWNoID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChjMCwgYzEpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIG91dFswXSA9IGYoYzBbMF0sIGMxWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IGYoYzBbMV0sIGMxWzFdKTtcbiAgICAgICAgICAgIG91dFsyXSA9IGYoYzBbMl0sIGMxWzJdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07IH07XG5cbiAgICB2YXIgbm9ybWFsID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGE7IH07XG4gICAgdmFyIG11bHRpcGx5ID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYSAqIGIgLyAyNTU7IH07XG4gICAgdmFyIGRhcmtlbiA9IGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIGEgPiBiID8gYiA6IGE7IH07XG4gICAgdmFyIGxpZ2h0ZW4gPSBmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBhID4gYiA/IGEgOiBiOyB9O1xuICAgIHZhciBzY3JlZW4gPSBmdW5jdGlvbiAoYSxiKSB7IHJldHVybiAyNTUgKiAoMSAtICgxLWEvMjU1KSAqICgxLWIvMjU1KSk7IH07XG4gICAgdmFyIG92ZXJsYXkgPSBmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBiIDwgMTI4ID8gMiAqIGEgKiBiIC8gMjU1IDogMjU1ICogKDEgLSAyICogKDEgLSBhIC8gMjU1ICkgKiAoIDEgLSBiIC8gMjU1ICkpOyB9O1xuICAgIHZhciBidXJuID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gMjU1ICogKDEgLSAoMSAtIGIgLyAyNTUpIC8gKGEvMjU1KSk7IH07XG4gICAgdmFyIGRvZGdlID0gZnVuY3Rpb24gKGEsYikge1xuICAgICAgICBpZiAoYSA9PT0gMjU1KSB7IHJldHVybiAyNTU7IH1cbiAgICAgICAgYSA9IDI1NSAqIChiIC8gMjU1KSAvICgxIC0gYSAvIDI1NSk7XG4gICAgICAgIHJldHVybiBhID4gMjU1ID8gMjU1IDogYVxuICAgIH07XG5cbiAgICAvLyAjIGFkZCA9IChhLGIpIC0+XG4gICAgLy8gIyAgICAgaWYgKGEgKyBiID4gMjU1KSB0aGVuIDI1NSBlbHNlIGEgKyBiXG5cbiAgICBibGVuZC5ub3JtYWwgPSBibGVuZF9mKGVhY2gobm9ybWFsKSk7XG4gICAgYmxlbmQubXVsdGlwbHkgPSBibGVuZF9mKGVhY2gobXVsdGlwbHkpKTtcbiAgICBibGVuZC5zY3JlZW4gPSBibGVuZF9mKGVhY2goc2NyZWVuKSk7XG4gICAgYmxlbmQub3ZlcmxheSA9IGJsZW5kX2YoZWFjaChvdmVybGF5KSk7XG4gICAgYmxlbmQuZGFya2VuID0gYmxlbmRfZihlYWNoKGRhcmtlbikpO1xuICAgIGJsZW5kLmxpZ2h0ZW4gPSBibGVuZF9mKGVhY2gobGlnaHRlbikpO1xuICAgIGJsZW5kLmRvZGdlID0gYmxlbmRfZihlYWNoKGRvZGdlKSk7XG4gICAgYmxlbmQuYnVybiA9IGJsZW5kX2YoZWFjaChidXJuKSk7XG4gICAgLy8gYmxlbmQuYWRkID0gYmxlbmRfZihlYWNoKGFkZCkpO1xuXG4gICAgdmFyIGJsZW5kXzEgPSBibGVuZDtcblxuICAgIC8vIGN1YmVoZWxpeCBpbnRlcnBvbGF0aW9uXG4gICAgLy8gYmFzZWQgb24gRC5BLiBHcmVlbiBcIkEgY29sb3VyIHNjaGVtZSBmb3IgdGhlIGRpc3BsYXkgb2YgYXN0cm9ub21pY2FsIGludGVuc2l0eSBpbWFnZXNcIlxuICAgIC8vIGh0dHA6Ly9hc3Ryb24tc29jLmluL2J1bGxldGluLzExSnVuZS8yODkzOTIwMTEucGRmXG5cbiAgICB2YXIgdHlwZSQxID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2xpcF9yZ2IgPSB1dGlscy5jbGlwX3JnYjtcbiAgICB2YXIgVFdPUEkgPSB1dGlscy5UV09QSTtcbiAgICB2YXIgcG93JDIgPSBNYXRoLnBvdztcbiAgICB2YXIgc2luJDEgPSBNYXRoLnNpbjtcbiAgICB2YXIgY29zJDEgPSBNYXRoLmNvcztcbiAgICB2YXIgY2hyb21hJDIgPSBjaHJvbWFfMTtcblxuICAgIHZhciBjdWJlaGVsaXggPSBmdW5jdGlvbihzdGFydCwgcm90YXRpb25zLCBodWUsIGdhbW1hLCBsaWdodG5lc3MpIHtcbiAgICAgICAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQ9MzAwO1xuICAgICAgICBpZiAoIHJvdGF0aW9ucyA9PT0gdm9pZCAwICkgcm90YXRpb25zPS0xLjU7XG4gICAgICAgIGlmICggaHVlID09PSB2b2lkIDAgKSBodWU9MTtcbiAgICAgICAgaWYgKCBnYW1tYSA9PT0gdm9pZCAwICkgZ2FtbWE9MTtcbiAgICAgICAgaWYgKCBsaWdodG5lc3MgPT09IHZvaWQgMCApIGxpZ2h0bmVzcz1bMCwxXTtcblxuICAgICAgICB2YXIgZGggPSAwLCBkbDtcbiAgICAgICAgaWYgKHR5cGUkMShsaWdodG5lc3MpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBkbCA9IGxpZ2h0bmVzc1sxXSAtIGxpZ2h0bmVzc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRsID0gMDtcbiAgICAgICAgICAgIGxpZ2h0bmVzcyA9IFtsaWdodG5lc3MsIGxpZ2h0bmVzc107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uKGZyYWN0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IFRXT1BJICogKCgoc3RhcnQrMTIwKS8zNjApICsgKHJvdGF0aW9ucyAqIGZyYWN0KSk7XG4gICAgICAgICAgICB2YXIgbCA9IHBvdyQyKGxpZ2h0bmVzc1swXSArIChkbCAqIGZyYWN0KSwgZ2FtbWEpO1xuICAgICAgICAgICAgdmFyIGggPSBkaCAhPT0gMCA/IGh1ZVswXSArIChmcmFjdCAqIGRoKSA6IGh1ZTtcbiAgICAgICAgICAgIHZhciBhbXAgPSAoaCAqIGwgKiAoMS1sKSkgLyAyO1xuICAgICAgICAgICAgdmFyIGNvc19hID0gY29zJDEoYSk7XG4gICAgICAgICAgICB2YXIgc2luX2EgPSBzaW4kMShhKTtcbiAgICAgICAgICAgIHZhciByID0gbCArIChhbXAgKiAoKC0wLjE0ODYxICogY29zX2EpICsgKDEuNzgyNzcqIHNpbl9hKSkpO1xuICAgICAgICAgICAgdmFyIGcgPSBsICsgKGFtcCAqICgoLTAuMjkyMjcgKiBjb3NfYSkgLSAoMC45MDY0OSogc2luX2EpKSk7XG4gICAgICAgICAgICB2YXIgYiA9IGwgKyAoYW1wICogKCsxLjk3Mjk0ICogY29zX2EpKTtcbiAgICAgICAgICAgIHJldHVybiBjaHJvbWEkMihjbGlwX3JnYihbcioyNTUsZyoyNTUsYioyNTUsMV0pKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnN0YXJ0ID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgaWYgKChzID09IG51bGwpKSB7IHJldHVybiBzdGFydDsgfVxuICAgICAgICAgICAgc3RhcnQgPSBzO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5yb3RhdGlvbnMgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBpZiAoKHIgPT0gbnVsbCkpIHsgcmV0dXJuIHJvdGF0aW9uczsgfVxuICAgICAgICAgICAgcm90YXRpb25zID0gcjtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuZ2FtbWEgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICBpZiAoKGcgPT0gbnVsbCkpIHsgcmV0dXJuIGdhbW1hOyB9XG4gICAgICAgICAgICBnYW1tYSA9IGc7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLmh1ZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIGlmICgoaCA9PSBudWxsKSkgeyByZXR1cm4gaHVlOyB9XG4gICAgICAgICAgICBodWUgPSBoO1xuICAgICAgICAgICAgaWYgKHR5cGUkMShodWUpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgZGggPSBodWVbMV0gLSBodWVbMF07XG4gICAgICAgICAgICAgICAgaWYgKGRoID09PSAwKSB7IGh1ZSA9IGh1ZVsxXTsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLmxpZ2h0bmVzcyA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIGlmICgoaCA9PSBudWxsKSkgeyByZXR1cm4gbGlnaHRuZXNzOyB9XG4gICAgICAgICAgICBpZiAodHlwZSQxKGgpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgbGlnaHRuZXNzID0gaDtcbiAgICAgICAgICAgICAgICBkbCA9IGhbMV0gLSBoWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaWdodG5lc3MgPSBbaCxoXTtcbiAgICAgICAgICAgICAgICBkbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnNjYWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hyb21hJDIuc2NhbGUoZik7IH07XG5cbiAgICAgICAgZi5odWUoaHVlKTtcblxuICAgICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJDQgPSBDb2xvcl8xO1xuICAgIHZhciBkaWdpdHMgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cbiAgICB2YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7XG4gICAgdmFyIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gICAgdmFyIHJhbmRvbV8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29kZSA9ICcjJztcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPDY7IGkrKykge1xuICAgICAgICAgICAgY29kZSArPSBkaWdpdHMuY2hhckF0KGZsb29yJDEocmFuZG9tKCkgKiAxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IkNChjb2RlLCAnaGV4Jyk7XG4gICAgfTtcblxuICAgIHZhciB0eXBlID0gdHlwZSRwO1xuICAgIHZhciBsb2cgPSBNYXRoLmxvZztcbiAgICB2YXIgcG93JDEgPSBNYXRoLnBvdztcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG5cbiAgICB2YXIgYW5hbHl6ZSA9IGZ1bmN0aW9uIChkYXRhLCBrZXkpIHtcbiAgICAgICAgaWYgKCBrZXkgPT09IHZvaWQgMCApIGtleT1udWxsO1xuXG4gICAgICAgIHZhciByID0ge1xuICAgICAgICAgICAgbWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFKi0xLFxuICAgICAgICAgICAgc3VtOiAwLFxuICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgIGNvdW50OiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZGF0YSA9IE9iamVjdC52YWx1ZXMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmIChrZXkgJiYgdHlwZSh2YWwpID09PSAnb2JqZWN0JykgeyB2YWwgPSB2YWxba2V5XTsgfVxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCAmJiAhaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgICAgIHIudmFsdWVzLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICByLnN1bSArPSB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8IHIubWluKSB7IHIubWluID0gdmFsOyB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA+IHIubWF4KSB7IHIubWF4ID0gdmFsOyB9XG4gICAgICAgICAgICAgICAgci5jb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByLmRvbWFpbiA9IFtyLm1pbiwgci5tYXhdO1xuXG4gICAgICAgIHIubGltaXRzID0gZnVuY3Rpb24gKG1vZGUsIG51bSkgeyByZXR1cm4gbGltaXRzKHIsIG1vZGUsIG51bSk7IH07XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuXG4gICAgdmFyIGxpbWl0cyA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlLCBudW0pIHtcbiAgICAgICAgaWYgKCBtb2RlID09PSB2b2lkIDAgKSBtb2RlPSdlcXVhbCc7XG4gICAgICAgIGlmICggbnVtID09PSB2b2lkIDAgKSBudW09NztcblxuICAgICAgICBpZiAodHlwZShkYXRhKSA9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBkYXRhID0gYW5hbHl6ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluID0gZGF0YS5taW47XG4gICAgICAgIHZhciBtYXggPSBkYXRhLm1heDtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGRhdGEudmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYS1iOyB9KTtcblxuICAgICAgICBpZiAobnVtID09PSAxKSB7IHJldHVybiBbbWluLG1heF07IH1cblxuICAgICAgICB2YXIgbGltaXRzID0gW107XG5cbiAgICAgICAgaWYgKG1vZGUuc3Vic3RyKDAsMSkgPT09ICdjJykgeyAvLyBjb250aW51b3VzXG4gICAgICAgICAgICBsaW1pdHMucHVzaChtaW4pO1xuICAgICAgICAgICAgbGltaXRzLnB1c2gobWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlLnN1YnN0cigwLDEpID09PSAnZScpIHsgLy8gZXF1YWwgaW50ZXJ2YWxcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTE7IGk8bnVtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsaW1pdHMucHVzaChtaW4rKChpL251bSkqKG1heC1taW4pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwxKSA9PT0gJ2wnKSB7IC8vIGxvZyBzY2FsZVxuICAgICAgICAgICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dhcml0aG1pYyBzY2FsZXMgYXJlIG9ubHkgcG9zc2libGUgZm9yIHZhbHVlcyA+IDAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW5fbG9nID0gTWF0aC5MT0cxMEUgKiBsb2cobWluKTtcbiAgICAgICAgICAgIHZhciBtYXhfbG9nID0gTWF0aC5MT0cxMEUgKiBsb2cobWF4KTtcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDE9MTsgaSQxPG51bTsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICBsaW1pdHMucHVzaChwb3ckMSgxMCwgbWluX2xvZyArICgoaSQxL251bSkgKiAobWF4X2xvZyAtIG1pbl9sb2cpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGltaXRzLnB1c2gobWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKG1vZGUuc3Vic3RyKDAsMSkgPT09ICdxJykgeyAvLyBxdWFudGlsZSBzY2FsZVxuICAgICAgICAgICAgbGltaXRzLnB1c2gobWluKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMj0xOyBpJDI8bnVtOyBpJDIrKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gKCh2YWx1ZXMubGVuZ3RoLTEpICogaSQyKS9udW07XG4gICAgICAgICAgICAgICAgdmFyIHBiID0gZmxvb3IocCk7XG4gICAgICAgICAgICAgICAgaWYgKHBiID09PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKHZhbHVlc1twYl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHAgPiBwYlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHIgPSBwIC0gcGI7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKCh2YWx1ZXNbcGJdKigxLXByKSkgKyAodmFsdWVzW3BiKzFdKnByKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGltaXRzLnB1c2gobWF4KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwxKSA9PT0gJ2snKSB7IC8vIGstbWVhbnMgY2x1c3RlcmluZ1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uXG4gICAgICAgICAgICBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZmlndWUvc291cmNlL2Jyb3dzZS90cnVuay9maWd1ZS5qcyMzMzZcbiAgICAgICAgICAgIHNpbXBsaWZpZWQgZm9yIDEtZCBpbnB1dCB2YWx1ZXNcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgY2x1c3RlcjtcbiAgICAgICAgICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBhc3NpZ25tZW50cyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIHZhciBjbHVzdGVyU2l6ZXMgPSBuZXcgQXJyYXkobnVtKTtcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG5iX2l0ZXJzID0gMDtcbiAgICAgICAgICAgIHZhciBjZW50cm9pZHMgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBnZXQgc2VlZCB2YWx1ZXNcbiAgICAgICAgICAgIGNlbnRyb2lkcyA9IFtdO1xuICAgICAgICAgICAgY2VudHJvaWRzLnB1c2gobWluKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMz0xOyBpJDM8bnVtOyBpJDMrKykge1xuICAgICAgICAgICAgICAgIGNlbnRyb2lkcy5wdXNoKG1pbiArICgoaSQzL251bSkgKiAobWF4LW1pbikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbnRyb2lkcy5wdXNoKG1heCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChyZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50IHN0ZXBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8bnVtOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlclNpemVzW2pdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ0PTA7IGkkNDxuOyBpJDQrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaSQ0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbmRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmVzdCA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqJDE9MDsgaiQxPG51bTsgaiQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gYWJzJDEoY2VudHJvaWRzW2okMV0tdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5kaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluZGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdCA9IGokMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJTaXplc1tiZXN0XSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudHNbaSQ0XSA9IGJlc3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY2VudHJvaWRzIHN0ZXBcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2VudHJvaWRzID0gbmV3IEFycmF5KG51bSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQyPTA7IGokMjxudW07IGokMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tqJDJdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ1PTA7IGkkNTxuOyBpJDUrKykge1xuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyID0gYXNzaWdubWVudHNbaSQ1XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tjbHVzdGVyXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2NsdXN0ZXJdID0gdmFsdWVzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZW50cm9pZHNbY2x1c3Rlcl0gKz0gdmFsdWVzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQzPTA7IGokMzxudW07IGokMysrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tqJDNdICo9IDEvY2x1c3RlclNpemVzW2okM107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgY29udmVyZ2VuY2VcbiAgICAgICAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqJDQ9MDsgaiQ0PG51bTsgaiQ0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tqJDRdICE9PSBjZW50cm9pZHNbaiQ0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2VudHJvaWRzID0gbmV3Q2VudHJvaWRzO1xuICAgICAgICAgICAgICAgIG5iX2l0ZXJzKys7XG5cbiAgICAgICAgICAgICAgICBpZiAobmJfaXRlcnMgPiAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaW5pc2hlZCBrLW1lYW5zIGNsdXN0ZXJpbmdcbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IHBhcnQgaXMgYm9ycm93ZWQgZnJvbSBnYWJyaWVsZmxvci5pdFxuICAgICAgICAgICAgdmFyIGtDbHVzdGVycyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaiQ1PTA7IGokNTxudW07IGokNSsrKSB7XG4gICAgICAgICAgICAgICAga0NsdXN0ZXJzW2okNV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkkNj0wOyBpJDY8bjsgaSQ2KyspIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyID0gYXNzaWdubWVudHNbaSQ2XTtcbiAgICAgICAgICAgICAgICBrQ2x1c3RlcnNbY2x1c3Rlcl0ucHVzaCh2YWx1ZXNbaSQ2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG1wS01lYW5zQnJlYWtzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqJDY9MDsgaiQ2PG51bTsgaiQ2KyspIHtcbiAgICAgICAgICAgICAgICB0bXBLTWVhbnNCcmVha3MucHVzaChrQ2x1c3RlcnNbaiQ2XVswXSk7XG4gICAgICAgICAgICAgICAgdG1wS01lYW5zQnJlYWtzLnB1c2goa0NsdXN0ZXJzW2okNl1ba0NsdXN0ZXJzW2okNl0ubGVuZ3RoLTFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcEtNZWFuc0JyZWFrcyA9IHRtcEtNZWFuc0JyZWFrcy5zb3J0KGZ1bmN0aW9uIChhLGIpeyByZXR1cm4gYS1iOyB9KTtcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKHRtcEtNZWFuc0JyZWFrc1swXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDc9MTsgaSQ3IDwgdG1wS01lYW5zQnJlYWtzLmxlbmd0aDsgaSQ3Kz0gMikge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gdG1wS01lYW5zQnJlYWtzW2kkN107XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2KSAmJiAobGltaXRzLmluZGV4T2YodikgPT09IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBsaW1pdHMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbWl0cztcbiAgICB9O1xuXG4gICAgdmFyIGFuYWx5emVfMSA9IHthbmFseXplOiBhbmFseXplLCBsaW1pdHM6IGxpbWl0c307XG5cbiAgICB2YXIgQ29sb3IkMyA9IENvbG9yXzE7XG5cblxuICAgIHZhciBjb250cmFzdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIC8vIFdDQUcgY29udHJhc3QgcmF0aW9cbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jY29udHJhc3QtcmF0aW9kZWZcbiAgICAgICAgYSA9IG5ldyBDb2xvciQzKGEpO1xuICAgICAgICBiID0gbmV3IENvbG9yJDMoYik7XG4gICAgICAgIHZhciBsMSA9IGEubHVtaW5hbmNlKCk7XG4gICAgICAgIHZhciBsMiA9IGIubHVtaW5hbmNlKCk7XG4gICAgICAgIHJldHVybiBsMSA+IGwyID8gKGwxICsgMC4wNSkgLyAobDIgKyAwLjA1KSA6IChsMiArIDAuMDUpIC8gKGwxICsgMC4wNSk7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciQyID0gQ29sb3JfMTtcbiAgICB2YXIgc3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgcG93ID0gTWF0aC5wb3c7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuICAgIHZhciBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgY29zID0gTWF0aC5jb3M7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xuICAgIHZhciBleHAgPSBNYXRoLmV4cDtcbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xuXG4gICAgdmFyIGRlbHRhRSA9IGZ1bmN0aW9uKGEsIGIsIEtsLCBLYywgS2gpIHtcbiAgICAgICAgaWYgKCBLbCA9PT0gdm9pZCAwICkgS2w9MTtcbiAgICAgICAgaWYgKCBLYyA9PT0gdm9pZCAwICkgS2M9MTtcbiAgICAgICAgaWYgKCBLaCA9PT0gdm9pZCAwICkgS2g9MTtcblxuICAgICAgICAvLyBEZWx0YSBFIChDSUUgMjAwMClcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXFuX0RlbHRhRV9DSUUyMDAwLmh0bWxcbiAgICAgICAgdmFyIHJhZDJkZWcgPSBmdW5jdGlvbihyYWQpIHtcbiAgICAgICAgICAgIHJldHVybiAzNjAgKiByYWQgLyAoMiAqIFBJKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlZzJyYWQgPSBmdW5jdGlvbihkZWcpIHtcbiAgICAgICAgICAgIHJldHVybiAoMiAqIFBJICogZGVnKSAvIDM2MDtcbiAgICAgICAgfTtcbiAgICAgICAgYSA9IG5ldyBDb2xvciQyKGEpO1xuICAgICAgICBiID0gbmV3IENvbG9yJDIoYik7XG4gICAgICAgIHZhciByZWYgPSBBcnJheS5mcm9tKGEubGFiKCkpO1xuICAgICAgICB2YXIgTDEgPSByZWZbMF07XG4gICAgICAgIHZhciBhMSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIxID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSBBcnJheS5mcm9tKGIubGFiKCkpO1xuICAgICAgICB2YXIgTDIgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGEyID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBiMiA9IHJlZiQxWzJdO1xuICAgICAgICB2YXIgYXZnTCA9IChMMSArIEwyKS8yO1xuICAgICAgICB2YXIgQzEgPSBzcXJ0KHBvdyhhMSwgMikgKyBwb3coYjEsIDIpKTtcbiAgICAgICAgdmFyIEMyID0gc3FydChwb3coYTIsIDIpICsgcG93KGIyLCAyKSk7XG4gICAgICAgIHZhciBhdmdDID0gKEMxICsgQzIpLzI7XG4gICAgICAgIHZhciBHID0gMC41KigxLXNxcnQocG93KGF2Z0MsIDcpLyhwb3coYXZnQywgNykgKyBwb3coMjUsIDcpKSkpO1xuICAgICAgICB2YXIgYTFwID0gYTEqKDErRyk7XG4gICAgICAgIHZhciBhMnAgPSBhMiooMStHKTtcbiAgICAgICAgdmFyIEMxcCA9IHNxcnQocG93KGExcCwgMikgKyBwb3coYjEsIDIpKTtcbiAgICAgICAgdmFyIEMycCA9IHNxcnQocG93KGEycCwgMikgKyBwb3coYjIsIDIpKTtcbiAgICAgICAgdmFyIGF2Z0NwID0gKEMxcCArIEMycCkvMjtcbiAgICAgICAgdmFyIGFyY3RhbjEgPSByYWQyZGVnKGF0YW4yKGIxLCBhMXApKTtcbiAgICAgICAgdmFyIGFyY3RhbjIgPSByYWQyZGVnKGF0YW4yKGIyLCBhMnApKTtcbiAgICAgICAgdmFyIGgxcCA9IGFyY3RhbjEgPj0gMCA/IGFyY3RhbjEgOiBhcmN0YW4xICsgMzYwO1xuICAgICAgICB2YXIgaDJwID0gYXJjdGFuMiA+PSAwID8gYXJjdGFuMiA6IGFyY3RhbjIgKyAzNjA7XG4gICAgICAgIHZhciBhdmdIcCA9IGFicyhoMXAgLSBoMnApID4gMTgwID8gKGgxcCArIGgycCArIDM2MCkvMiA6IChoMXAgKyBoMnApLzI7XG4gICAgICAgIHZhciBUID0gMSAtIDAuMTcqY29zKGRlZzJyYWQoYXZnSHAgLSAzMCkpICsgMC4yNCpjb3MoZGVnMnJhZCgyKmF2Z0hwKSkgKyAwLjMyKmNvcyhkZWcycmFkKDMqYXZnSHAgKyA2KSkgLSAwLjIqY29zKGRlZzJyYWQoNCphdmdIcCAtIDYzKSk7XG4gICAgICAgIHZhciBkZWx0YUhwID0gaDJwIC0gaDFwO1xuICAgICAgICBkZWx0YUhwID0gYWJzKGRlbHRhSHApIDw9IDE4MCA/IGRlbHRhSHAgOiBoMnAgPD0gaDFwID8gZGVsdGFIcCArIDM2MCA6IGRlbHRhSHAgLSAzNjA7XG4gICAgICAgIGRlbHRhSHAgPSAyKnNxcnQoQzFwKkMycCkqc2luKGRlZzJyYWQoZGVsdGFIcCkvMik7XG4gICAgICAgIHZhciBkZWx0YUwgPSBMMiAtIEwxO1xuICAgICAgICB2YXIgZGVsdGFDcCA9IEMycCAtIEMxcDsgICAgXG4gICAgICAgIHZhciBzbCA9IDEgKyAoMC4wMTUqcG93KGF2Z0wgLSA1MCwgMikpL3NxcnQoMjAgKyBwb3coYXZnTCAtIDUwLCAyKSk7XG4gICAgICAgIHZhciBzYyA9IDEgKyAwLjA0NSphdmdDcDtcbiAgICAgICAgdmFyIHNoID0gMSArIDAuMDE1KmF2Z0NwKlQ7XG4gICAgICAgIHZhciBkZWx0YVRoZXRhID0gMzAqZXhwKC1wb3coKGF2Z0hwIC0gMjc1KS8yNSwgMikpO1xuICAgICAgICB2YXIgUmMgPSAyKnNxcnQocG93KGF2Z0NwLCA3KS8ocG93KGF2Z0NwLCA3KSArIHBvdygyNSwgNykpKTtcbiAgICAgICAgdmFyIFJ0ID0gLVJjKnNpbigyKmRlZzJyYWQoZGVsdGFUaGV0YSkpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gc3FydChwb3coZGVsdGFMLyhLbCpzbCksIDIpICsgcG93KGRlbHRhQ3AvKEtjKnNjKSwgMikgKyBwb3coZGVsdGFIcC8oS2gqc2gpLCAyKSArIFJ0KihkZWx0YUNwLyhLYypzYykpKihkZWx0YUhwLyhLaCpzaCkpKTtcbiAgICAgICAgcmV0dXJuIG1heCgwLCBtaW4oMTAwLCByZXN1bHQpKTtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJDEgPSBDb2xvcl8xO1xuXG4gICAgLy8gc2ltcGxlIEV1Y2xpZGVhbiBkaXN0YW5jZVxuICAgIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIsIG1vZGUpIHtcbiAgICAgICAgaWYgKCBtb2RlID09PSB2b2lkIDAgKSBtb2RlPSdsYWInO1xuXG4gICAgICAgIC8vIERlbHRhIEUgKENJRSAxOTc2KVxuICAgICAgICAvLyBzZWUgaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcXVhdGlvbnMuaHRtbFxuICAgICAgICBhID0gbmV3IENvbG9yJDEoYSk7XG4gICAgICAgIGIgPSBuZXcgQ29sb3IkMShiKTtcbiAgICAgICAgdmFyIGwxID0gYS5nZXQobW9kZSk7XG4gICAgICAgIHZhciBsMiA9IGIuZ2V0KG1vZGUpO1xuICAgICAgICB2YXIgc3VtX3NxID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBsMSkge1xuICAgICAgICAgICAgdmFyIGQgPSAobDFbaV0gfHwgMCkgLSAobDJbaV0gfHwgMCk7XG4gICAgICAgICAgICBzdW1fc3EgKz0gZCpkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoc3VtX3NxKTtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yID0gQ29sb3JfMTtcblxuICAgIHZhciB2YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IsIFsgbnVsbCBdLmNvbmNhdCggYXJncykgKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHNvbWUgcHJlLWRlZmluZWQgY29sb3Igc2NhbGVzOlxuICAgIHZhciBjaHJvbWEkMSA9IGNocm9tYV8xO1xuXG4gICAgdmFyIHNjYWxlID0gc2NhbGUkMjtcblxuICAgIHZhciBzY2FsZXMgPSB7XG4gICAgXHRjb29sOiBmdW5jdGlvbiBjb29sKCkgeyByZXR1cm4gc2NhbGUoW2Nocm9tYSQxLmhzbCgxODAsMSwuOSksIGNocm9tYSQxLmhzbCgyNTAsLjcsLjQpXSkgfSxcbiAgICBcdGhvdDogZnVuY3Rpb24gaG90KCkgeyByZXR1cm4gc2NhbGUoWycjMDAwJywnI2YwMCcsJyNmZjAnLCcjZmZmJ10pLm1vZGUoJ3JnYicpIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIENvbG9yQnJld2VyIGNvbG9ycyBmb3IgY2hyb21hLmpzXG5cbiAgICAgICAgQ29weXJpZ2h0IChjKSAyMDAyIEN5bnRoaWEgQnJld2VyLCBNYXJrIEhhcnJvd2VyLCBhbmQgVGhlXG4gICAgICAgIFBlbm5zeWx2YW5pYSBTdGF0ZSBVbml2ZXJzaXR5LlxuXG4gICAgICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICAgICAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWRcbiAgICAgICAgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1JcbiAgICAgICAgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAgICAgICAgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuXG4gICAgdmFyIGNvbG9yYnJld2VyID0ge1xuICAgICAgICAvLyBzZXF1ZW50aWFsXG4gICAgICAgIE9yUmQ6IFsnI2ZmZjdlYycsICcjZmVlOGM4JywgJyNmZGQ0OWUnLCAnI2ZkYmI4NCcsICcjZmM4ZDU5JywgJyNlZjY1NDgnLCAnI2Q3MzAxZicsICcjYjMwMDAwJywgJyM3ZjAwMDAnXSxcbiAgICAgICAgUHVCdTogWycjZmZmN2ZiJywgJyNlY2U3ZjInLCAnI2QwZDFlNicsICcjYTZiZGRiJywgJyM3NGE5Y2YnLCAnIzM2OTBjMCcsICcjMDU3MGIwJywgJyMwNDVhOGQnLCAnIzAyMzg1OCddLFxuICAgICAgICBCdVB1OiBbJyNmN2ZjZmQnLCAnI2UwZWNmNCcsICcjYmZkM2U2JywgJyM5ZWJjZGEnLCAnIzhjOTZjNicsICcjOGM2YmIxJywgJyM4ODQxOWQnLCAnIzgxMGY3YycsICcjNGQwMDRiJ10sXG4gICAgICAgIE9yYW5nZXM6IFsnI2ZmZjVlYicsICcjZmVlNmNlJywgJyNmZGQwYTInLCAnI2ZkYWU2YicsICcjZmQ4ZDNjJywgJyNmMTY5MTMnLCAnI2Q5NDgwMScsICcjYTYzNjAzJywgJyM3ZjI3MDQnXSxcbiAgICAgICAgQnVHbjogWycjZjdmY2ZkJywgJyNlNWY1ZjknLCAnI2NjZWNlNicsICcjOTlkOGM5JywgJyM2NmMyYTQnLCAnIzQxYWU3NicsICcjMjM4YjQ1JywgJyMwMDZkMmMnLCAnIzAwNDQxYiddLFxuICAgICAgICBZbE9yQnI6IFsnI2ZmZmZlNScsICcjZmZmN2JjJywgJyNmZWUzOTEnLCAnI2ZlYzQ0ZicsICcjZmU5OTI5JywgJyNlYzcwMTQnLCAnI2NjNGMwMicsICcjOTkzNDA0JywgJyM2NjI1MDYnXSxcbiAgICAgICAgWWxHbjogWycjZmZmZmU1JywgJyNmN2ZjYjknLCAnI2Q5ZjBhMycsICcjYWRkZDhlJywgJyM3OGM2NzknLCAnIzQxYWI1ZCcsICcjMjM4NDQzJywgJyMwMDY4MzcnLCAnIzAwNDUyOSddLFxuICAgICAgICBSZWRzOiBbJyNmZmY1ZjAnLCAnI2ZlZTBkMicsICcjZmNiYmExJywgJyNmYzkyNzInLCAnI2ZiNmE0YScsICcjZWYzYjJjJywgJyNjYjE4MWQnLCAnI2E1MGYxNScsICcjNjcwMDBkJ10sXG4gICAgICAgIFJkUHU6IFsnI2ZmZjdmMycsICcjZmRlMGRkJywgJyNmY2M1YzAnLCAnI2ZhOWZiNScsICcjZjc2OGExJywgJyNkZDM0OTcnLCAnI2FlMDE3ZScsICcjN2EwMTc3JywgJyM0OTAwNmEnXSxcbiAgICAgICAgR3JlZW5zOiBbJyNmN2ZjZjUnLCAnI2U1ZjVlMCcsICcjYzdlOWMwJywgJyNhMWQ5OWInLCAnIzc0YzQ3NicsICcjNDFhYjVkJywgJyMyMzhiNDUnLCAnIzAwNmQyYycsICcjMDA0NDFiJ10sXG4gICAgICAgIFlsR25CdTogWycjZmZmZmQ5JywgJyNlZGY4YjEnLCAnI2M3ZTliNCcsICcjN2ZjZGJiJywgJyM0MWI2YzQnLCAnIzFkOTFjMCcsICcjMjI1ZWE4JywgJyMyNTM0OTQnLCAnIzA4MWQ1OCddLFxuICAgICAgICBQdXJwbGVzOiBbJyNmY2ZiZmQnLCAnI2VmZWRmNScsICcjZGFkYWViJywgJyNiY2JkZGMnLCAnIzllOWFjOCcsICcjODA3ZGJhJywgJyM2YTUxYTMnLCAnIzU0Mjc4ZicsICcjM2YwMDdkJ10sXG4gICAgICAgIEduQnU6IFsnI2Y3ZmNmMCcsICcjZTBmM2RiJywgJyNjY2ViYzUnLCAnI2E4ZGRiNScsICcjN2JjY2M0JywgJyM0ZWIzZDMnLCAnIzJiOGNiZScsICcjMDg2OGFjJywgJyMwODQwODEnXSxcbiAgICAgICAgR3JleXM6IFsnI2ZmZmZmZicsICcjZjBmMGYwJywgJyNkOWQ5ZDknLCAnI2JkYmRiZCcsICcjOTY5Njk2JywgJyM3MzczNzMnLCAnIzUyNTI1MicsICcjMjUyNTI1JywgJyMwMDAwMDAnXSxcbiAgICAgICAgWWxPclJkOiBbJyNmZmZmY2MnLCAnI2ZmZWRhMCcsICcjZmVkOTc2JywgJyNmZWIyNGMnLCAnI2ZkOGQzYycsICcjZmM0ZTJhJywgJyNlMzFhMWMnLCAnI2JkMDAyNicsICcjODAwMDI2J10sXG4gICAgICAgIFB1UmQ6IFsnI2Y3ZjRmOScsICcjZTdlMWVmJywgJyNkNGI5ZGEnLCAnI2M5OTRjNycsICcjZGY2NWIwJywgJyNlNzI5OGEnLCAnI2NlMTI1NicsICcjOTgwMDQzJywgJyM2NzAwMWYnXSxcbiAgICAgICAgQmx1ZXM6IFsnI2Y3ZmJmZicsICcjZGVlYmY3JywgJyNjNmRiZWYnLCAnIzllY2FlMScsICcjNmJhZWQ2JywgJyM0MjkyYzYnLCAnIzIxNzFiNScsICcjMDg1MTljJywgJyMwODMwNmInXSxcbiAgICAgICAgUHVCdUduOiBbJyNmZmY3ZmInLCAnI2VjZTJmMCcsICcjZDBkMWU2JywgJyNhNmJkZGInLCAnIzY3YTljZicsICcjMzY5MGMwJywgJyMwMjgxOGEnLCAnIzAxNmM1OScsICcjMDE0NjM2J10sXG4gICAgICAgIFZpcmlkaXM6IFsnIzQ0MDE1NCcsICcjNDgyNzc3JywgJyMzZjRhOGEnLCAnIzMxNjc4ZScsICcjMjY4MzhmJywgJyMxZjlkOGEnLCAnIzZjY2U1YScsICcjYjZkZTJiJywgJyNmZWU4MjUnXSxcblxuICAgICAgICAvLyBkaXZlcmdpbmdcblxuICAgICAgICBTcGVjdHJhbDogWycjOWUwMTQyJywgJyNkNTNlNGYnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOGInLCAnI2ZmZmZiZicsICcjZTZmNTk4JywgJyNhYmRkYTQnLCAnIzY2YzJhNScsICcjMzI4OGJkJywgJyM1ZTRmYTInXSxcbiAgICAgICAgUmRZbEduOiBbJyNhNTAwMjYnLCAnI2Q3MzAyNycsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA4YicsICcjZmZmZmJmJywgJyNkOWVmOGInLCAnI2E2ZDk2YScsICcjNjZiZDYzJywgJyMxYTk4NTAnLCAnIzAwNjgzNyddLFxuICAgICAgICBSZEJ1OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZjdmN2Y3JywgJyNkMWU1ZjAnLCAnIzkyYzVkZScsICcjNDM5M2MzJywgJyMyMTY2YWMnLCAnIzA1MzA2MSddLFxuICAgICAgICBQaVlHOiBbJyM4ZTAxNTInLCAnI2M1MWI3ZCcsICcjZGU3N2FlJywgJyNmMWI2ZGEnLCAnI2ZkZTBlZicsICcjZjdmN2Y3JywgJyNlNmY1ZDAnLCAnI2I4ZTE4NicsICcjN2ZiYzQxJywgJyM0ZDkyMjEnLCAnIzI3NjQxOSddLFxuICAgICAgICBQUkduOiBbJyM0MDAwNGInLCAnIzc2MmE4MycsICcjOTk3MGFiJywgJyNjMmE1Y2YnLCAnI2U3ZDRlOCcsICcjZjdmN2Y3JywgJyNkOWYwZDMnLCAnI2E2ZGJhMCcsICcjNWFhZTYxJywgJyMxYjc4MzcnLCAnIzAwNDQxYiddLFxuICAgICAgICBSZFlsQnU6IFsnI2E1MDAyNicsICcjZDczMDI3JywgJyNmNDZkNDMnLCAnI2ZkYWU2MScsICcjZmVlMDkwJywgJyNmZmZmYmYnLCAnI2UwZjNmOCcsICcjYWJkOWU5JywgJyM3NGFkZDEnLCAnIzQ1NzViNCcsICcjMzEzNjk1J10sXG4gICAgICAgIEJyQkc6IFsnIzU0MzAwNScsICcjOGM1MTBhJywgJyNiZjgxMmQnLCAnI2RmYzI3ZCcsICcjZjZlOGMzJywgJyNmNWY1ZjUnLCAnI2M3ZWFlNScsICcjODBjZGMxJywgJyMzNTk3OGYnLCAnIzAxNjY1ZScsICcjMDAzYzMwJ10sXG4gICAgICAgIFJkR3k6IFsnIzY3MDAxZicsICcjYjIxODJiJywgJyNkNjYwNGQnLCAnI2Y0YTU4MicsICcjZmRkYmM3JywgJyNmZmZmZmYnLCAnI2UwZTBlMCcsICcjYmFiYWJhJywgJyM4Nzg3ODcnLCAnIzRkNGQ0ZCcsICcjMWExYTFhJ10sXG4gICAgICAgIFB1T3I6IFsnIzdmM2IwOCcsICcjYjM1ODA2JywgJyNlMDgyMTQnLCAnI2ZkYjg2MycsICcjZmVlMGI2JywgJyNmN2Y3ZjcnLCAnI2Q4ZGFlYicsICcjYjJhYmQyJywgJyM4MDczYWMnLCAnIzU0Mjc4OCcsICcjMmQwMDRiJ10sXG5cbiAgICAgICAgLy8gcXVhbGl0YXRpdmVcblxuICAgICAgICBTZXQyOiBbJyM2NmMyYTUnLCAnI2ZjOGQ2MicsICcjOGRhMGNiJywgJyNlNzhhYzMnLCAnI2E2ZDg1NCcsICcjZmZkOTJmJywgJyNlNWM0OTQnLCAnI2IzYjNiMyddLFxuICAgICAgICBBY2NlbnQ6IFsnIzdmYzk3ZicsICcjYmVhZWQ0JywgJyNmZGMwODYnLCAnI2ZmZmY5OScsICcjMzg2Y2IwJywgJyNmMDAyN2YnLCAnI2JmNWIxNycsICcjNjY2NjY2J10sXG4gICAgICAgIFNldDE6IFsnI2U0MWExYycsICcjMzc3ZWI4JywgJyM0ZGFmNGEnLCAnIzk4NGVhMycsICcjZmY3ZjAwJywgJyNmZmZmMzMnLCAnI2E2NTYyOCcsICcjZjc4MWJmJywgJyM5OTk5OTknXSxcbiAgICAgICAgU2V0MzogWycjOGRkM2M3JywgJyNmZmZmYjMnLCAnI2JlYmFkYScsICcjZmI4MDcyJywgJyM4MGIxZDMnLCAnI2ZkYjQ2MicsICcjYjNkZTY5JywgJyNmY2NkZTUnLCAnI2Q5ZDlkOScsICcjYmM4MGJkJywgJyNjY2ViYzUnLCAnI2ZmZWQ2ZiddLFxuICAgICAgICBEYXJrMjogWycjMWI5ZTc3JywgJyNkOTVmMDInLCAnIzc1NzBiMycsICcjZTcyOThhJywgJyM2NmE2MWUnLCAnI2U2YWIwMicsICcjYTY3NjFkJywgJyM2NjY2NjYnXSxcbiAgICAgICAgUGFpcmVkOiBbJyNhNmNlZTMnLCAnIzFmNzhiNCcsICcjYjJkZjhhJywgJyMzM2EwMmMnLCAnI2ZiOWE5OScsICcjZTMxYTFjJywgJyNmZGJmNmYnLCAnI2ZmN2YwMCcsICcjY2FiMmQ2JywgJyM2YTNkOWEnLCAnI2ZmZmY5OScsICcjYjE1OTI4J10sXG4gICAgICAgIFBhc3RlbDI6IFsnI2IzZTJjZCcsICcjZmRjZGFjJywgJyNjYmQ1ZTgnLCAnI2Y0Y2FlNCcsICcjZTZmNWM5JywgJyNmZmYyYWUnLCAnI2YxZTJjYycsICcjY2NjY2NjJ10sXG4gICAgICAgIFBhc3RlbDE6IFsnI2ZiYjRhZScsICcjYjNjZGUzJywgJyNjY2ViYzUnLCAnI2RlY2JlNCcsICcjZmVkOWE2JywgJyNmZmZmY2MnLCAnI2U1ZDhiZCcsICcjZmRkYWVjJywgJyNmMmYyZjInXSxcbiAgICB9O1xuXG4gICAgLy8gYWRkIGxvd2VyY2FzZSBhbGlhc2VzIGZvciBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IE9iamVjdC5rZXlzKGNvbG9yYnJld2VyKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGtleSA9IGxpc3RbaV07XG5cbiAgICAgICAgY29sb3JicmV3ZXJba2V5LnRvTG93ZXJDYXNlKCldID0gY29sb3JicmV3ZXJba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgY29sb3JicmV3ZXJfMSA9IGNvbG9yYnJld2VyO1xuXG4gICAgdmFyIGNocm9tYSA9IGNocm9tYV8xO1xuXG4gICAgLy8gZmVlbCBmcmVlIHRvIGNvbW1lbnQgb3V0IGFueXRoaW5nIHRvIHJvbGx1cFxuICAgIC8vIGEgc21hbGxlciBjaHJvbWEuanMgYnVpbHRcblxuICAgIC8vIGlvIC0tPiBjb252ZXJ0IGNvbG9yc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAvLyBvcGVyYXRvcnMgLS0+IG1vZGlmeSBleGlzdGluZyBDb2xvcnNcblxuXG5cblxuXG5cblxuXG5cblxuICAgIC8vIGludGVycG9sYXRvcnNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAvLyBnZW5lcmF0b3JzIC0tID4gY3JlYXRlIG5ldyBjb2xvcnNcbiAgICBjaHJvbWEuYXZlcmFnZSA9IGF2ZXJhZ2U7XG4gICAgY2hyb21hLmJlemllciA9IGJlemllcl8xO1xuICAgIGNocm9tYS5ibGVuZCA9IGJsZW5kXzE7XG4gICAgY2hyb21hLmN1YmVoZWxpeCA9IGN1YmVoZWxpeDtcbiAgICBjaHJvbWEubWl4ID0gY2hyb21hLmludGVycG9sYXRlID0gbWl4JDE7XG4gICAgY2hyb21hLnJhbmRvbSA9IHJhbmRvbV8xO1xuICAgIGNocm9tYS5zY2FsZSA9IHNjYWxlJDI7XG5cbiAgICAvLyBvdGhlciB1dGlsaXR5IG1ldGhvZHNcbiAgICBjaHJvbWEuYW5hbHl6ZSA9IGFuYWx5emVfMS5hbmFseXplO1xuICAgIGNocm9tYS5jb250cmFzdCA9IGNvbnRyYXN0O1xuICAgIGNocm9tYS5kZWx0YUUgPSBkZWx0YUU7XG4gICAgY2hyb21hLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgY2hyb21hLmxpbWl0cyA9IGFuYWx5emVfMS5saW1pdHM7XG4gICAgY2hyb21hLnZhbGlkID0gdmFsaWQ7XG5cbiAgICAvLyBzY2FsZVxuICAgIGNocm9tYS5zY2FsZXMgPSBzY2FsZXM7XG5cbiAgICAvLyBjb2xvcnNcbiAgICBjaHJvbWEuY29sb3JzID0gdzNjeDExXzE7XG4gICAgY2hyb21hLmJyZXdlciA9IGNvbG9yYnJld2VyXzE7XG5cbiAgICB2YXIgY2hyb21hX2pzID0gY2hyb21hO1xuXG4gICAgcmV0dXJuIGNocm9tYV9qcztcblxufSkpO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwidmFyIHNjcmlwdFVybDtcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmcuaW1wb3J0U2NyaXB0cykgc2NyaXB0VXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmxvY2F0aW9uICsgXCJcIjtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5kb2N1bWVudDtcbmlmICghc2NyaXB0VXJsICYmIGRvY3VtZW50KSB7XG5cdGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuXHRpZiAoIXNjcmlwdFVybCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0aWYoc2NyaXB0cy5sZW5ndGgpIHtcblx0XHRcdHZhciBpID0gc2NyaXB0cy5sZW5ndGggLSAxO1xuXHRcdFx0d2hpbGUgKGkgPiAtMSAmJiAhc2NyaXB0VXJsKSBzY3JpcHRVcmwgPSBzY3JpcHRzW2ktLV0uc3JjO1xuXHRcdH1cblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmw7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5uYyA9IHVuZGVmaW5lZDsiLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiNzNmYjdiN2YwZTY4YjM3MmFkZmVjZWZmZTExNTg5MGEudHRmXCI7IiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5leHBvcnQgY29uc3QgaXNfY2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKiBAdHlwZSB7KCkgPT4gbnVtYmVyfSAqL1xuZXhwb3J0IGxldCBub3cgPSBpc19jbGllbnQgPyAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiAoKSA9PiBEYXRlLm5vdygpO1xuXG5leHBvcnQgbGV0IHJhZiA9IGlzX2NsaWVudCA/IChjYikgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSA6IG5vb3A7XG5cbi8vIHVzZWQgaW50ZXJuYWxseSBmb3IgdGVzdGluZ1xuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9ub3coZm4pIHtcblx0bm93ID0gZm47XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfcmFmKGZuKSB7XG5cdHJhZiA9IGZuO1xufVxuIiwiaW1wb3J0IHsgcmFmIH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5cbmNvbnN0IHRhc2tzID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBub3dcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBydW5fdGFza3Mobm93KSB7XG5cdHRhc2tzLmZvckVhY2goKHRhc2spID0+IHtcblx0XHRpZiAoIXRhc2suYyhub3cpKSB7XG5cdFx0XHR0YXNrcy5kZWxldGUodGFzayk7XG5cdFx0XHR0YXNrLmYoKTtcblx0XHR9XG5cdH0pO1xuXHRpZiAodGFza3Muc2l6ZSAhPT0gMCkgcmFmKHJ1bl90YXNrcyk7XG59XG5cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJfbG9vcHMoKSB7XG5cdHRhc2tzLmNsZWFyKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIHRoYXQgcnVucyBvbiBlYWNoIHJhZiBmcmFtZVxuICogdW50aWwgaXQgcmV0dXJucyBhIGZhbHN5IHZhbHVlIG9yIGlzIGFib3J0ZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5UYXNrQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5UYXNrfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuVGFza0VudHJ5fSAqL1xuXHRsZXQgdGFzaztcblx0aWYgKHRhc2tzLnNpemUgPT09IDApIHJhZihydW5fdGFza3MpO1xuXHRyZXR1cm4ge1xuXHRcdHByb21pc2U6IG5ldyBQcm9taXNlKChmdWxmaWxsKSA9PiB7XG5cdFx0XHR0YXNrcy5hZGQoKHRhc2sgPSB7IGM6IGNhbGxiYWNrLCBmOiBmdWxmaWxsIH0pKTtcblx0XHR9KSxcblx0XHRhYm9ydCgpIHtcblx0XHRcdHRhc2tzLmRlbGV0ZSh0YXNrKTtcblx0XHR9XG5cdH07XG59XG4iLCIvKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzfSAqL1xuZXhwb3J0IGNvbnN0IGdsb2JhbHMgPVxuXHR0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuXHRcdD8gd2luZG93XG5cdFx0OiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcblx0XHQ/IGdsb2JhbFRoaXNcblx0XHQ6IC8vIEB0cy1pZ25vcmUgTm9kZSB0eXBpbmdzIGhhdmUgdGhpc1xuXHRcdCAgZ2xvYmFsO1xuIiwiaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5cbi8qKlxuICogUmVzaXplIG9ic2VydmVyIHNpbmdsZXRvbi5cbiAqIE9uZSBsaXN0ZW5lciBwZXIgZWxlbWVudCBvbmx5IVxuICogaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9nL2JsaW5rLWRldi9jL3o2aWVuT05VYjVBL20vRjUtVmNVWnRCQUFKXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge1dlYWtNYXA8RWxlbWVudCwgaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5MaXN0ZW5lcj59XG5cdCAqL1xuXHRfbGlzdGVuZXJzID0gJ1dlYWtNYXAnIGluIGdsb2JhbHMgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAdHlwZSB7UmVzaXplT2JzZXJ2ZXJ9XG5cdCAqL1xuXHRfb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtSZXNpemVPYnNlcnZlck9wdGlvbnN9ICovXG5cdG9wdGlvbnM7XG5cblx0LyoqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJPcHRpb25zfSBvcHRpb25zICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuTGlzdGVuZXJ9IGxpc3RlbmVyXG5cdCAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuXHQgKi9cblx0b2JzZXJ2ZShlbGVtZW50LCBsaXN0ZW5lcikge1xuXHRcdHRoaXMuX2xpc3RlbmVycy5zZXQoZWxlbWVudCwgbGlzdGVuZXIpO1xuXHRcdHRoaXMuX2dldE9ic2VydmVyKCkub2JzZXJ2ZShlbGVtZW50LCB0aGlzLm9wdGlvbnMpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHR0aGlzLl9saXN0ZW5lcnMuZGVsZXRlKGVsZW1lbnQpO1xuXHRcdFx0dGhpcy5fb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpOyAvLyB0aGlzIGxpbmUgY2FuIHByb2JhYmx5IGJlIHJlbW92ZWRcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0T2JzZXJ2ZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMuX29ic2VydmVyID8/XG5cdFx0XHQodGhpcy5fb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcblx0XHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG5cdFx0XHRcdFx0UmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uZW50cmllcy5zZXQoZW50cnkudGFyZ2V0LCBlbnRyeSk7XG5cdFx0XHRcdFx0dGhpcy5fbGlzdGVuZXJzLmdldChlbnRyeS50YXJnZXQpPy4oZW50cnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSlcblx0XHQpO1xuXHR9XG59XG5cbi8vIE5lZWRzIHRvIGJlIHdyaXR0ZW4gbGlrZSB0aGlzIHRvIHBhc3MgdGhlIHRyZWUtc2hha2UtdGVzdFxuUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uZW50cmllcyA9ICdXZWFrTWFwJyBpbiBnbG9iYWxzID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcbiIsImltcG9ydCB7IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5qcyc7XG5pbXBvcnQgeyBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcywgaGFzX3Byb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFRyYWNrIHdoaWNoIG5vZGVzIGFyZSBjbGFpbWVkIGR1cmluZyBoeWRyYXRpb24uIFVuY2xhaW1lZCBub2RlcyBjYW4gdGhlbiBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuLy8gYXQgdGhlIGVuZCBvZiBoeWRyYXRpb24gd2l0aG91dCB0b3VjaGluZyB0aGUgcmVtYWluaW5nIG5vZGVzLlxubGV0IGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRfaHlkcmF0aW5nKCkge1xuXHRpc19oeWRyYXRpbmcgPSB0cnVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5kX2h5ZHJhdGluZygpIHtcblx0aXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqIEBwYXJhbSB7KGluZGV4OiBudW1iZXIpID0+IG51bWJlcn0ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHVwcGVyX2JvdW5kKGxvdywgaGlnaCwga2V5LCB2YWx1ZSkge1xuXHQvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG5cdHdoaWxlIChsb3cgPCBoaWdoKSB7XG5cdFx0Y29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcblx0XHRpZiAoa2V5KG1pZCkgPD0gdmFsdWUpIHtcblx0XHRcdGxvdyA9IG1pZCArIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhpZ2ggPSBtaWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBsb3c7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGluaXRfaHlkcmF0ZSh0YXJnZXQpIHtcblx0aWYgKHRhcmdldC5oeWRyYXRlX2luaXQpIHJldHVybjtcblx0dGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG5cdC8vIFdlIGtub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBjbGFpbV9vcmRlciB2YWx1ZXMgc2luY2UgdGhlIHVuY2xhaW1lZCBoYXZlIGJlZW4gZGV0YWNoZWQgaWYgdGFyZ2V0IGlzIG5vdCA8aGVhZD5cblxuXHRsZXQgY2hpbGRyZW4gPSAvKiogQHR5cGUge0FycmF5TGlrZTxOb2RlRXgyPn0gKi8gKHRhcmdldC5jaGlsZE5vZGVzKTtcblx0Ly8gSWYgdGFyZ2V0IGlzIDxoZWFkPiwgdGhlcmUgbWF5IGJlIGNoaWxkcmVuIHdpdGhvdXQgY2xhaW1fb3JkZXJcblx0aWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG5cdFx0Y29uc3QgbXlDaGlsZHJlbiA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBjaGlsZHJlbltpXTtcblx0XHRcdGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bXlDaGlsZHJlbi5wdXNoKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjaGlsZHJlbiA9IG15Q2hpbGRyZW47XG5cdH1cblx0Lypcblx0ICogUmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseS5cblx0ICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuXHQgKiBub2RlcyB0aGF0IGFyZSBhbHJlYWR5IGNsYWltZWQgaW4gb3JkZXIgYW5kIG9ubHkgbW92aW5nIHRoZSByZXN0LiBUaGUgbG9uZ2VzdFxuXHQgKiBzdWJzZXF1ZW5jZSBvZiBub2RlcyB0aGF0IGFyZSBjbGFpbWVkIGluIG9yZGVyIGNhbiBiZSBmb3VuZCBieVxuXHQgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuXHQgKlxuXHQgKiBUaGlzIGFsZ29yaXRobSBpcyBvcHRpbWFsIGluIGdlbmVyYXRpbmcgdGhlIGxlYXN0IGFtb3VudCBvZiByZW9yZGVyIG9wZXJhdGlvbnNcblx0ICogcG9zc2libGUuXG5cdCAqXG5cdCAqIFByb29mOlxuXHQgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcblx0ICogYWx3YXlzIGZvcm0gYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSwgc2luY2UgdGhleSBkbyBub3QgbW92ZSBhbW9uZyBlYWNoIG90aGVyXG5cdCAqIG1lYW5pbmcgdGhhdCB0aGV5IG11c3QgYmUgYWxyZWFkeSBvcmRlcmVkIGFtb25nIGVhY2ggb3RoZXIuIFRodXMsIHRoZSBtYXhpbWFsXG5cdCAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG5cdCAqL1xuXHQvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuXHQvLyBtOiBzdWJzZXF1ZW5jZSBsZW5ndGggaiA9PiBpbmRleCBrIG9mIHNtYWxsZXN0IHZhbHVlIHRoYXQgZW5kcyBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGxlbmd0aCBqXG5cdGNvbnN0IG0gPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGggKyAxKTtcblx0Ly8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcblx0Y29uc3QgcCA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCk7XG5cdG1bMF0gPSAtMTtcblx0bGV0IGxvbmdlc3QgPSAwO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuXHRcdC8vIEZpbmQgdGhlIGxhcmdlc3Qgc3Vic2VxdWVuY2UgbGVuZ3RoIHN1Y2ggdGhhdCBpdCBlbmRzIGluIGEgdmFsdWUgbGVzcyB0aGFuIG91ciBjdXJyZW50IHZhbHVlXG5cdFx0Ly8gdXBwZXJfYm91bmQgcmV0dXJucyBmaXJzdCBncmVhdGVyIHZhbHVlLCBzbyB3ZSBzdWJ0cmFjdCBvbmVcblx0XHQvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuXHRcdGNvbnN0IHNlcUxlbiA9XG5cdFx0XHQobG9uZ2VzdCA+IDAgJiYgY2hpbGRyZW5bbVtsb25nZXN0XV0uY2xhaW1fb3JkZXIgPD0gY3VycmVudFxuXHRcdFx0XHQ/IGxvbmdlc3QgKyAxXG5cdFx0XHRcdDogdXBwZXJfYm91bmQoMSwgbG9uZ2VzdCwgKGlkeCkgPT4gY2hpbGRyZW5bbVtpZHhdXS5jbGFpbV9vcmRlciwgY3VycmVudCkpIC0gMTtcblx0XHRwW2ldID0gbVtzZXFMZW5dICsgMTtcblx0XHRjb25zdCBuZXdMZW4gPSBzZXFMZW4gKyAxO1xuXHRcdC8vIFdlIGNhbiBndWFyYW50ZWUgdGhhdCBjdXJyZW50IGlzIHRoZSBzbWFsbGVzdCB2YWx1ZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBoYXZlIGdlbmVyYXRlZCBhIGxvbmdlciBzZXF1ZW5jZS5cblx0XHRtW25ld0xlbl0gPSBpO1xuXHRcdGxvbmdlc3QgPSBNYXRoLm1heChuZXdMZW4sIGxvbmdlc3QpO1xuXHR9XG5cdC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcblxuXHQvKipcblx0ICogQHR5cGUge05vZGVFeDJbXX1cblx0ICovXG5cdGNvbnN0IGxpcyA9IFtdO1xuXHQvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7Tm9kZUV4MltdfVxuXHQgKi9cblx0Y29uc3QgdG9Nb3ZlID0gW107XG5cdGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcblx0Zm9yIChsZXQgY3VyID0gbVtsb25nZXN0XSArIDE7IGN1ciAhPSAwOyBjdXIgPSBwW2N1ciAtIDFdKSB7XG5cdFx0bGlzLnB1c2goY2hpbGRyZW5bY3VyIC0gMV0pO1xuXHRcdGZvciAoOyBsYXN0ID49IGN1cjsgbGFzdC0tKSB7XG5cdFx0XHR0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG5cdFx0fVxuXHRcdGxhc3QtLTtcblx0fVxuXHRmb3IgKDsgbGFzdCA+PSAwOyBsYXN0LS0pIHtcblx0XHR0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG5cdH1cblx0bGlzLnJldmVyc2UoKTtcblx0Ly8gV2Ugc29ydCB0aGUgbm9kZXMgYmVpbmcgbW92ZWQgdG8gZ3VhcmFudGVlIHRoYXQgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyIG1hdGNoZXMgdGhlIGNsYWltIG9yZGVyXG5cdHRvTW92ZS5zb3J0KChhLCBiKSA9PiBhLmNsYWltX29yZGVyIC0gYi5jbGFpbV9vcmRlcik7XG5cdC8vIEZpbmFsbHksIHdlIG1vdmUgdGhlIG5vZGVzXG5cdGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvTW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b01vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG5cdFx0XHRqKys7XG5cdFx0fVxuXHRcdGNvbnN0IGFuY2hvciA9IGogPCBsaXMubGVuZ3RoID8gbGlzW2pdIDogbnVsbDtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvTW92ZVtpXSwgYW5jaG9yKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kKHRhcmdldCwgbm9kZSkge1xuXHR0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZV9zaGVldF9pZFxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfc3R5bGVzKHRhcmdldCwgc3R5bGVfc2hlZXRfaWQsIHN0eWxlcykge1xuXHRjb25zdCBhcHBlbmRfc3R5bGVzX3RvID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKHRhcmdldCk7XG5cdGlmICghYXBwZW5kX3N0eWxlc190by5nZXRFbGVtZW50QnlJZChzdHlsZV9zaGVldF9pZCkpIHtcblx0XHRjb25zdCBzdHlsZSA9IGVsZW1lbnQoJ3N0eWxlJyk7XG5cdFx0c3R5bGUuaWQgPSBzdHlsZV9zaGVldF9pZDtcblx0XHRzdHlsZS50ZXh0Q29udGVudCA9IHN0eWxlcztcblx0XHRhcHBlbmRfc3R5bGVzaGVldChhcHBlbmRfc3R5bGVzX3RvLCBzdHlsZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHtTaGFkb3dSb290IHwgRG9jdW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSkge1xuXHRpZiAoIW5vZGUpIHJldHVybiBkb2N1bWVudDtcblx0Y29uc3Qgcm9vdCA9IG5vZGUuZ2V0Um9vdE5vZGUgPyBub2RlLmdldFJvb3ROb2RlKCkgOiBub2RlLm93bmVyRG9jdW1lbnQ7XG5cdGlmIChyb290ICYmIC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8gKHJvb3QpLmhvc3QpIHtcblx0XHRyZXR1cm4gLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCk7XG5cdH1cblx0cmV0dXJuIG5vZGUub3duZXJEb2N1bWVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHtDU1NTdHlsZVNoZWV0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSkge1xuXHRjb25zdCBzdHlsZV9lbGVtZW50ID0gZWxlbWVudCgnc3R5bGUnKTtcblx0Ly8gRm9yIHRyYW5zaXRpb25zIHRvIHdvcmsgd2l0aG91dCAnc3R5bGUtc3JjOiB1bnNhZmUtaW5saW5lJyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSxcblx0Ly8gdGhlc2UgZW1wdHkgdGFncyBuZWVkIHRvIGJlIGFsbG93ZWQgd2l0aCBhIGhhc2ggYXMgYSB3b3JrYXJvdW5kIHVudGlsIHdlIG1vdmUgdG8gdGhlIFdlYiBBbmltYXRpb25zIEFQSS5cblx0Ly8gVXNpbmcgdGhlIGhhc2ggZm9yIHRoZSBlbXB0eSBzdHJpbmcgKGZvciBhbiBlbXB0eSB0YWcpIHdvcmtzIGluIGFsbCBicm93c2VycyBleGNlcHQgU2FmYXJpLlxuXHQvLyBTbyBhcyBhIHdvcmthcm91bmQgZm9yIHRoZSB3b3JrYXJvdW5kLCB3aGVuIHdlIGFwcGVuZCBlbXB0eSBzdHlsZSB0YWdzIHdlIHNldCB0aGVpciBjb250ZW50IHRvIC8qIGVtcHR5ICovLlxuXHQvLyBUaGUgaGFzaCAnc2hhMjU2LTlPbE5PMERORWVhVnpITDRSWndDTHNCSEE4V0JROHRvQnAvNEY1WFYybmM9JyB3aWxsIHRoZW4gd29yayBldmVuIGluIFNhZmFyaS5cblx0c3R5bGVfZWxlbWVudC50ZXh0Q29udGVudCA9ICcvKiBlbXB0eSAqLyc7XG5cdGFwcGVuZF9zdHlsZXNoZWV0KGdldF9yb290X2Zvcl9zdHlsZShub2RlKSwgc3R5bGVfZWxlbWVudCk7XG5cdHJldHVybiBzdHlsZV9lbGVtZW50LnNoZWV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2hhZG93Um9vdCB8IERvY3VtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gKiBAcmV0dXJucyB7Q1NTU3R5bGVTaGVldH1cbiAqL1xuZnVuY3Rpb24gYXBwZW5kX3N0eWxlc2hlZXQobm9kZSwgc3R5bGUpIHtcblx0YXBwZW5kKC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovIChub2RlKS5oZWFkIHx8IG5vZGUsIHN0eWxlKTtcblx0cmV0dXJuIHN0eWxlLnNoZWV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZUV4fSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZUV4fSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKSB7XG5cdGlmIChpc19oeWRyYXRpbmcpIHtcblx0XHRpbml0X2h5ZHJhdGUodGFyZ2V0KTtcblx0XHRpZiAoXG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHQodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwgJiYgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KVxuXHRcdCkge1xuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcblx0XHR9XG5cdFx0Ly8gU2tpcCBub2RlcyBvZiB1bmRlZmluZWQgb3JkZXJpbmdcblx0XHR3aGlsZSAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwgJiYgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQuY2xhaW1fb3JkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5uZXh0U2libGluZztcblx0XHR9XG5cdFx0aWYgKG5vZGUgIT09IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGluc2VydCBpZiB0aGUgb3JkZXJpbmcgb2YgdGhpcyBub2RlIHNob3VsZCBiZSBtb2RpZmllZCBvciB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRhcmdldFxuXHRcdFx0aWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCB8fCBub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCkge1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSBub2RlLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0fSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBbYW5jaG9yXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcblx0dGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlRXh9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZUV4fSBbYW5jaG9yXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG5cdGlmIChpc19oeWRyYXRpbmcgJiYgIWFuY2hvcikge1xuXHRcdGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcblx0fSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9IGFuY2hvcikge1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG5cdGlmIChub2RlLnBhcmVudE5vZGUpIHtcblx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2VhY2goaXRlcmF0aW9ucywgZGV0YWNoaW5nKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChpdGVyYXRpb25zW2ldKSBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSBLXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFRhZ05hbWVNYXBbS119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9IEtcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGlzXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRUYWdOYW1lTWFwW0tdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudF9pcyhuYW1lLCBpcykge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge2tleW9mIFR9IEtcbiAqIEBwYXJhbSB7VH0gb2JqXG4gKiBAcGFyYW0ge0tbXX0gZXhjbHVkZVxuICogQHJldHVybnMge1BpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuXHRjb25zdCB0YXJnZXQgPSAvKiogQHR5cGUge1BpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj59ICovICh7fSk7XG5cdGZvciAoY29uc3QgayBpbiBvYmopIHtcblx0XHRpZiAoXG5cdFx0XHRoYXNfcHJvcChvYmosIGspICYmXG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRleGNsdWRlLmluZGV4T2YoaykgPT09IC0xXG5cdFx0KSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHR0YXJnZXRba10gPSBvYmpba107XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcH0gS1xuICogQHBhcmFtIHtLfSBuYW1lXG4gKiBAcmV0dXJucyB7U1ZHRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHJldHVybnMge1RleHR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0KGRhdGEpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtUZXh0fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwYWNlKCkge1xuXHRyZXR1cm4gdGV4dCgnICcpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtUZXh0fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KCkge1xuXHRyZXR1cm4gdGV4dCgnJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEByZXR1cm5zIHtDb21tZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWVudChjb250ZW50KSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRlbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0fSBoYW5kbGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyB8IEV2ZW50TGlzdGVuZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG5cdHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gYW55fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnRfZGVmYXVsdChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gYW55fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BfcHJvcGFnYXRpb24oZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24oZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGYoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKSBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGlmIChldmVudC5pc1RydXN0ZWQpIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuXHRlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSkgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG4vKipcbiAqIExpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBhbHdheXMgYmUgc2V0IHRocm91Z2ggdGhlIGF0dHIgbWV0aG9kLFxuICogYmVjYXVzZSB1cGRhdGluZyB0aGVtIHRocm91Z2ggdGhlIHByb3BlcnR5IHNldHRlciBkb2Vzbid0IHdvcmsgcmVsaWFibHkuXG4gKiBJbiB0aGUgZXhhbXBsZSBvZiBgd2lkdGhgL2BoZWlnaHRgLCB0aGUgcHJvYmxlbSBpcyB0aGF0IHRoZSBzZXR0ZXIgb25seVxuICogYWNjZXB0cyBudW1lcmljIHZhbHVlcywgYnV0IHRoZSBhdHRyaWJ1dGUgY2FuIGFsc28gYmUgc2V0IHRvIGEgc3RyaW5nIGxpa2UgYDUwJWAuXG4gKiBJZiB0aGlzIGxpc3QgYmVjb21lcyB0b28gYmlnLCByZXRoaW5rIHRoaXMgYXBwcm9hY2guXG4gKi9cbmNvbnN0IGFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7eyBbeDogc3RyaW5nXTogc3RyaW5nIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuXHQvLyBAdHMtaWdub3JlXG5cdGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZS5fX3Byb3RvX18pO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0aWYgKGF0dHJpYnV0ZXNba2V5XSA9PSBudWxsKSB7XG5cdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG5cdFx0XHRub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdfX3ZhbHVlJykge1xuXHRcdFx0LyoqIEB0eXBlIHthbnl9ICovIChub2RlKS52YWx1ZSA9IG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZGVzY3JpcHRvcnNba2V5XSAmJlxuXHRcdFx0ZGVzY3JpcHRvcnNba2V5XS5zZXQgJiZcblx0XHRcdGFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlLmluZGV4T2Yoa2V5KSA9PT0gLTFcblx0XHQpIHtcblx0XHRcdG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge3sgW3g6IHN0cmluZ106IHN0cmluZyB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zdmdfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG5cdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IGRhdGFfbWFwXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcChub2RlLCBkYXRhX21hcCkge1xuXHRPYmplY3Qua2V5cyhkYXRhX21hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG5cdFx0c2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwga2V5LCBkYXRhX21hcFtrZXldKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwgcHJvcCwgdmFsdWUpIHtcblx0aWYgKHByb3AgaW4gbm9kZSkge1xuXHRcdG5vZGVbcHJvcF0gPSB0eXBlb2Ygbm9kZVtwcm9wXSA9PT0gJ2Jvb2xlYW4nICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRhdHRyKG5vZGUsIHByb3AsIHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9keW5hbWljX2VsZW1lbnRfZGF0YSh0YWcpIHtcblx0cmV0dXJuIC8tLy50ZXN0KHRhZykgPyBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAgOiBzZXRfYXR0cmlidXRlcztcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHhsaW5rX2F0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9zdmVsdGVfZGF0YXNldChub2RlKSB7XG5cdHJldHVybiBub2RlLmRhdGFzZXQuc3ZlbHRlSDtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dW5rbm93bltdfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG5cdGNvbnN0IHZhbHVlID0gbmV3IFNldCgpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGdyb3VwW2ldLmNoZWNrZWQpIHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcblx0fVxuXHRpZiAoIWNoZWNrZWQpIHtcblx0XHR2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG5cdH1cblx0cmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudFtdfSBncm91cFxuICogQHJldHVybnMge3sgcCguLi5pbnB1dHM6IEhUTUxJbnB1dEVsZW1lbnRbXSk6IHZvaWQ7IHIoKTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cChncm91cCkge1xuXHQvKipcblx0ICogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnRbXX0gKi9cblx0bGV0IF9pbnB1dHM7XG5cdHJldHVybiB7XG5cdFx0LyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuXHRcdFx0X2lucHV0cyA9IGlucHV0cztcblx0XHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IGdyb3VwLnB1c2goaW5wdXQpKTtcblx0XHR9LFxuXHRcdC8qIHJlbW92ZSAqLyByKCkge1xuXHRcdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gZ3JvdXAuc3BsaWNlKGdyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXNcbiAqIEByZXR1cm5zIHt7IHUobmV3X2luZGV4ZXM6IG51bWJlcltdKTogdm9pZDsgcCguLi5pbnB1dHM6IEhUTUxJbnB1dEVsZW1lbnRbXSk6IHZvaWQ7IHI6ICgpID0+IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0X2JpbmRpbmdfZ3JvdXBfZHluYW1pYyhncm91cCwgaW5kZXhlcykge1xuXHQvKipcblx0ICogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnRbXX0gKi9cblx0bGV0IF9ncm91cCA9IGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKTtcblxuXHQvKipcblx0ICogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnRbXX0gKi9cblx0bGV0IF9pbnB1dHM7XG5cblx0ZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGdyb3VwID0gZ3JvdXBbaW5kZXhlc1tpXV0gPSBncm91cFtpbmRleGVzW2ldXSB8fCBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIGdyb3VwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBwdXNoKCkge1xuXHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IF9ncm91cC5wdXNoKGlucHV0KSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBfZ3JvdXAuc3BsaWNlKF9ncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0LyogdXBkYXRlICovIHUobmV3X2luZGV4ZXMpIHtcblx0XHRcdGluZGV4ZXMgPSBuZXdfaW5kZXhlcztcblx0XHRcdGNvbnN0IG5ld19ncm91cCA9IGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKTtcblx0XHRcdGlmIChuZXdfZ3JvdXAgIT09IF9ncm91cCkge1xuXHRcdFx0XHRyZW1vdmUoKTtcblx0XHRcdFx0X2dyb3VwID0gbmV3X2dyb3VwO1xuXHRcdFx0XHRwdXNoKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG5cdFx0XHRfaW5wdXRzID0gaW5wdXRzO1xuXHRcdFx0cHVzaCgpO1xuXHRcdH0sXG5cdFx0LyogcmVtb3ZlICovIHI6IHJlbW92ZVxuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtudW1iZXJ9ICovXG5leHBvcnQgZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHthbnlbXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcblx0Y29uc3QgYXJyYXkgPSBbXTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuXHR9XG5cdHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtDaGlsZE5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcblx0cmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGluaXRfY2xhaW1faW5mbyhub2Rlcykge1xuXHRpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0bm9kZXMuY2xhaW1faW5mbyA9IHsgbGFzdF9pbmRleDogMCwgdG90YWxfY2xhaW1lZDogMCB9O1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtDaGlsZE5vZGVFeH0gUlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7KG5vZGU6IENoaWxkTm9kZUV4KSA9PiBub2RlIGlzIFJ9IHByZWRpY2F0ZVxuICogQHBhcmFtIHsobm9kZTogQ2hpbGROb2RlRXgpID0+IENoaWxkTm9kZUV4IHwgdW5kZWZpbmVkfSBwcm9jZXNzTm9kZVxuICogQHBhcmFtIHsoKSA9PiBSfSBjcmVhdGVOb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRvbnRVcGRhdGVMYXN0SW5kZXhcbiAqIEByZXR1cm5zIHtSfVxuICovXG5mdW5jdGlvbiBjbGFpbV9ub2RlKG5vZGVzLCBwcmVkaWNhdGUsIHByb2Nlc3NOb2RlLCBjcmVhdGVOb2RlLCBkb250VXBkYXRlTGFzdEluZGV4ID0gZmFsc2UpIHtcblx0Ly8gVHJ5IHRvIGZpbmQgbm9kZXMgaW4gYW4gb3JkZXIgc3VjaCB0aGF0IHdlIGxlbmd0aGVuIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Vcblx0aW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcblx0Y29uc3QgcmVzdWx0Tm9kZSA9ICgoKSA9PiB7XG5cdFx0Ly8gV2UgZmlyc3QgdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCBhZnRlciB0aGUgcHJldmlvdXMgb25lXG5cdFx0Zm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBub2RlID0gbm9kZXNbaV07XG5cdFx0XHRpZiAocHJlZGljYXRlKG5vZGUpKSB7XG5cdFx0XHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG5cdFx0XHRcdGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bm9kZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZmluZCBvbmUgYmVmb3JlXG5cdFx0Ly8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG5cdFx0Zm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRjb25zdCBub2RlID0gbm9kZXNbaV07XG5cdFx0XHRpZiAocHJlZGljYXRlKG5vZGUpKSB7XG5cdFx0XHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG5cdFx0XHRcdGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bm9kZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcblx0XHRcdFx0fSBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ly8gU2luY2Ugd2Ugc3BsaWNlZCBiZWZvcmUgdGhlIGxhc3RfaW5kZXgsIHdlIGRlY3JlYXNlIGl0XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIElmIHdlIGNhbid0IGZpbmQgYW55IG1hdGNoaW5nIG5vZGUsIHdlIGNyZWF0ZSBhIG5ldyBvbmVcblx0XHRyZXR1cm4gY3JlYXRlTm9kZSgpO1xuXHR9KSgpO1xuXHRyZXN1bHROb2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuXHRub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcblx0cmV0dXJuIHJlc3VsdE5vZGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9fSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0geyhuYW1lOiBzdHJpbmcpID0+IEVsZW1lbnQgfCBTVkdFbGVtZW50fSBjcmVhdGVfZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZV9lbGVtZW50KSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBFbGVtZW50IHwgU1ZHRWxlbWVudH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSxcblx0XHQvKiogQHBhcmFtIHtFbGVtZW50fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdGNvbnN0IHJlbW92ZSA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuXHRcdFx0XHRpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG5cdFx0XHRcdFx0cmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZW1vdmUuZm9yRWFjaCgodikgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUodikpO1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdCgpID0+IGNyZWF0ZV9lbGVtZW50KG5hbWUpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudCB8IFNWR0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fc3ZnX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcblx0cmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnX2VsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX3RleHQobm9kZXMsIGRhdGEpIHtcblx0cmV0dXJuIGNsYWltX25vZGUoXG5cdFx0bm9kZXMsXG5cdFx0LyoqIEByZXR1cm5zIHtub2RlIGlzIFRleHR9ICovXG5cdFx0KG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDMsXG5cdFx0LyoqIEBwYXJhbSB7VGV4dH0gbm9kZSAqL1xuXHRcdChub2RlKSA9PiB7XG5cdFx0XHRjb25zdCBkYXRhU3RyID0gJycgKyBkYXRhO1xuXHRcdFx0aWYgKG5vZGUuZGF0YS5zdGFydHNXaXRoKGRhdGFTdHIpKSB7XG5cdFx0XHRcdGlmIChub2RlLmRhdGEubGVuZ3RoICE9PSBkYXRhU3RyLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlLnNwbGl0VGV4dChkYXRhU3RyLmxlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUuZGF0YSA9IGRhdGFTdHI7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQoKSA9PiB0ZXh0KGRhdGEpLFxuXHRcdHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG5cdCk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcblx0cmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEByZXR1cm5zIHtDb21tZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fY29tbWVudChub2RlcywgZGF0YSkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgQ29tbWVudH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCxcblx0XHQvKiogQHBhcmFtIHtDb21tZW50fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdG5vZGUuZGF0YSA9ICcnICsgZGF0YTtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHQoKSA9PiBjb21tZW50KGRhdGEpLFxuXHRcdHRydWVcblx0KTtcbn1cblxuZnVuY3Rpb24gZmluZF9jb21tZW50KG5vZGVzLCB0ZXh0LCBzdGFydCkge1xuXHRmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbm9kZXMubGVuZ3RoO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfc3ZnXG4gKiBAcmV0dXJucyB7SHRtbFRhZ0h5ZHJhdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2h0bWxfdGFnKG5vZGVzLCBpc19zdmcpIHtcblx0Ly8gZmluZCBodG1sIG9wZW5pbmcgdGFnXG5cdGNvbnN0IHN0YXJ0X2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfU1RBUlQnLCAwKTtcblx0Y29uc3QgZW5kX2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfRU5EJywgc3RhcnRfaW5kZXgpO1xuXHRpZiAoc3RhcnRfaW5kZXggPT09IGVuZF9pbmRleCkge1xuXHRcdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbih1bmRlZmluZWQsIGlzX3N2Zyk7XG5cdH1cblx0aW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcblx0Y29uc3QgaHRtbF90YWdfbm9kZXMgPSBub2Rlcy5zcGxpY2Uoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSk7XG5cdGRldGFjaChodG1sX3RhZ19ub2Rlc1swXSk7XG5cdGRldGFjaChodG1sX3RhZ19ub2Rlc1todG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxXSk7XG5cdGNvbnN0IGNsYWltZWRfbm9kZXMgPSBodG1sX3RhZ19ub2Rlcy5zbGljZSgxLCBodG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxKTtcblx0Zm9yIChjb25zdCBuIG9mIGNsYWltZWRfbm9kZXMpIHtcblx0XHRuLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuXHRcdG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuXHR9XG5cdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihjbGFpbWVkX25vZGVzLCBpc19zdmcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhKHRleHQsIGRhdGEpIHtcblx0ZGF0YSA9ICcnICsgZGF0YTtcblx0aWYgKHRleHQuZGF0YSA9PT0gZGF0YSkgcmV0dXJuO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKSB7XG5cdGRhdGEgPSAnJyArIGRhdGE7XG5cdGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSkgcmV0dXJuO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cl92YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSwgYXR0cl92YWx1ZSkge1xuXHRpZiAofmNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLmluZGV4T2YoYXR0cl92YWx1ZSkpIHtcblx0XHRzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSk7XG5cdH0gZWxzZSB7XG5cdFx0c2V0X2RhdGEodGV4dCwgZGF0YSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaW5wdXRfdmFsdWUoaW5wdXQsIHZhbHVlKSB7XG5cdGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lucHV0X3R5cGUoaW5wdXQsIHR5cGUpIHtcblx0dHJ5IHtcblx0XHRpbnB1dC50eXBlID0gdHlwZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGRvIG5vdGhpbmdcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG5cdH0gZWxzZSB7XG5cdFx0bm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlLCBpbXBvcnRhbnQgPyAnaW1wb3J0YW50JyA6ICcnKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSwgbW91bnRpbmcpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuXHRcdGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcblx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cdGlmICghbW91bnRpbmcgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9vcHRpb25zKHNlbGVjdCwgdmFsdWUpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuXHRcdG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X3ZhbHVlKHNlbGVjdCkge1xuXHRjb25zdCBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKTtcblx0cmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcblx0cmV0dXJuIFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCc6Y2hlY2tlZCcpLCAob3B0aW9uKSA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcblxuLyoqXG4gKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbmxldCBjcm9zc29yaWdpbjtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19jcm9zc29yaWdpbigpIHtcblx0aWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpIHtcblx0XHRjcm9zc29yaWdpbiA9IGZhbHNlO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuXHRcdFx0XHR2b2lkIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNyb3Nzb3JpZ2luID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGNyb3Nzb3JpZ2luO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2lmcmFtZV9yZXNpemVfbGlzdGVuZXIobm9kZSwgZm4pIHtcblx0Y29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRpZiAoY29tcHV0ZWRfc3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG5cdFx0bm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdH1cblx0Y29uc3QgaWZyYW1lID0gZWxlbWVudCgnaWZyYW1lJyk7XG5cdGlmcmFtZS5zZXRBdHRyaWJ1dGUoXG5cdFx0J3N0eWxlJyxcblx0XHQnZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyAnICtcblx0XHRcdCdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnXG5cdCk7XG5cdGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblx0aWZyYW1lLnRhYkluZGV4ID0gLTE7XG5cdGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcblxuXHQvKipcblx0ICogQHR5cGUgeygpID0+IHZvaWR9XG5cdCAqL1xuXHRsZXQgdW5zdWJzY3JpYmU7XG5cdGlmIChjcm9zc29yaWdpbikge1xuXHRcdGlmcmFtZS5zcmMgPSBcImRhdGE6dGV4dC9odG1sLDxzY3JpcHQ+b25yZXNpemU9ZnVuY3Rpb24oKXtwYXJlbnQucG9zdE1lc3NhZ2UoMCwnKicpfTwvc2NyaXB0PlwiO1xuXHRcdHVuc3Vic2NyaWJlID0gbGlzdGVuKFxuXHRcdFx0d2luZG93LFxuXHRcdFx0J21lc3NhZ2UnLFxuXHRcdFx0LyoqIEBwYXJhbSB7TWVzc2FnZUV2ZW50fSBldmVudCAqLyAoZXZlbnQpID0+IHtcblx0XHRcdFx0aWYgKGV2ZW50LnNvdXJjZSA9PT0gaWZyYW1lLmNvbnRlbnRXaW5kb3cpIGZuKCk7XG5cdFx0XHR9XG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcblx0XHRpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuXHRcdFx0dW5zdWJzY3JpYmUgPSBsaXN0ZW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBmbik7XG5cdFx0XHQvLyBtYWtlIHN1cmUgYW4gaW5pdGlhbCByZXNpemUgZXZlbnQgaXMgZmlyZWQgX2FmdGVyXyB0aGUgaWZyYW1lIGlzIGxvYWRlZCAod2hpY2ggaXMgYXN5bmNocm9ub3VzKVxuXHRcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzQyMzNcblx0XHRcdGZuKCk7XG5cdFx0fTtcblx0fVxuXHRhcHBlbmQobm9kZSwgaWZyYW1lKTtcblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoY3Jvc3NvcmlnaW4pIHtcblx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0fSBlbHNlIGlmICh1bnN1YnNjcmliZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuXHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdFx0ZGV0YWNoKGlmcmFtZSk7XG5cdH07XG59XG5leHBvcnQgY29uc3QgcmVzaXplX29ic2VydmVyX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7XG5cdGJveDogJ2NvbnRlbnQtYm94J1xufSk7XG5leHBvcnQgY29uc3QgcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHtcblx0Ym94OiAnYm9yZGVyLWJveCdcbn0pO1xuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9kZXZpY2VfcGl4ZWxfY29udGVudF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKFxuXHR7IGJveDogJ2RldmljZS1waXhlbC1jb250ZW50LWJveCcgfVxuKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIH07XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuXHQvLyBUaGUgYCEhYCBpcyByZXF1aXJlZCBiZWNhdXNlIGFuIGB1bmRlZmluZWRgIGZsYWcgbWVhbnMgZmxpcHBpbmcgdGhlIGN1cnJlbnQgc3RhdGUuXG5cdGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShuYW1lLCAhIXRvZ2dsZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1R9IFtkZXRhaWxdXG4gKiBAcGFyYW0ge3sgYnViYmxlcz86IGJvb2xlYW4sIGNhbmNlbGFibGU/OiBib29sZWFuIH19IFtvcHRpb25zXVxuICogQHJldHVybnMge0N1c3RvbUV2ZW50PFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcblx0cmV0dXJuIG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbCwgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge0NoaWxkTm9kZUFycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlfc2VsZWN0b3JfYWxsKHNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XG5cdHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVJZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaGVhZFxuICogQHJldHVybnMge2FueVtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVhZF9zZWxlY3Rvcihub2RlSWQsIGhlYWQpIHtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGxldCBzdGFydGVkID0gMDtcblx0Zm9yIChjb25zdCBub2RlIG9mIGhlYWQuY2hpbGROb2Rlcykge1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLykge1xuXHRcdFx0Y29uc3QgY29tbWVudCA9IG5vZGUudGV4dENvbnRlbnQudHJpbSgpO1xuXHRcdFx0aWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9FTkRgKSB7XG5cdFx0XHRcdHN0YXJ0ZWQgLT0gMTtcblx0XHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9TVEFSVGApIHtcblx0XHRcdFx0c3RhcnRlZCArPSAxO1xuXHRcdFx0XHRyZXN1bHQucHVzaChub2RlKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHN0YXJ0ZWQgPiAwKSB7XG5cdFx0XHRyZXN1bHQucHVzaChub2RlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cbi8qKiAqL1xuZXhwb3J0IGNsYXNzIEh0bWxUYWcge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdGlzX3N2ZyA9IGZhbHNlO1xuXHQvLyBwYXJlbnQgZm9yIGNyZWF0aW5nIG5vZGVcblx0LyoqICovXG5cdGUgPSB1bmRlZmluZWQ7XG5cdC8vIGh0bWwgdGFnIG5vZGVzXG5cdC8qKiAqL1xuXHRuID0gdW5kZWZpbmVkO1xuXHQvLyB0YXJnZXRcblx0LyoqICovXG5cdHQgPSB1bmRlZmluZWQ7XG5cdC8vIGFuY2hvclxuXHQvKiogKi9cblx0YSA9IHVuZGVmaW5lZDtcblx0Y29uc3RydWN0b3IoaXNfc3ZnID0gZmFsc2UpIHtcblx0XHR0aGlzLmlzX3N2ZyA9IGlzX3N2Zztcblx0XHR0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0YyhodG1sKSB7XG5cdFx0dGhpcy5oKGh0bWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSB0YXJnZXRcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IGFuY2hvclxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdG0oaHRtbCwgdGFyZ2V0LCBhbmNob3IgPSBudWxsKSB7XG5cdFx0aWYgKCF0aGlzLmUpIHtcblx0XHRcdGlmICh0aGlzLmlzX3N2Zylcblx0XHRcdFx0dGhpcy5lID0gc3ZnX2VsZW1lbnQoLyoqIEB0eXBlIHtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcH0gKi8gKHRhcmdldC5ub2RlTmFtZSkpO1xuXHRcdFx0LyoqICM3MzY0ICB0YXJnZXQgZm9yIDx0ZW1wbGF0ZT4gbWF5IGJlIHByb3ZpZGVkIGFzICNkb2N1bWVudC1mcmFnbWVudCgxMSkgKi8gZWxzZVxuXHRcdFx0XHR0aGlzLmUgPSBlbGVtZW50KFxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSAqLyAoXG5cdFx0XHRcdFx0XHR0YXJnZXQubm9kZVR5cGUgPT09IDExID8gJ1RFTVBMQVRFJyA6IHRhcmdldC5ub2RlTmFtZVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblx0XHRcdHRoaXMudCA9XG5cdFx0XHRcdHRhcmdldC50YWdOYW1lICE9PSAnVEVNUExBVEUnXG5cdFx0XHRcdFx0PyB0YXJnZXRcblx0XHRcdFx0XHQ6IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKHRhcmdldCkuY29udGVudDtcblx0XHRcdHRoaXMuYyhodG1sKTtcblx0XHR9XG5cdFx0dGhpcy5pKGFuY2hvcik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRoKGh0bWwpIHtcblx0XHR0aGlzLmUuaW5uZXJIVE1MID0gaHRtbDtcblx0XHR0aGlzLm4gPSBBcnJheS5mcm9tKFxuXHRcdFx0dGhpcy5lLm5vZGVOYW1lID09PSAnVEVNUExBVEUnID8gdGhpcy5lLmNvbnRlbnQuY2hpbGROb2RlcyA6IHRoaXMuZS5jaGlsZE5vZGVzXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0aShhbmNob3IpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0aW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdHAoaHRtbCkge1xuXHRcdHRoaXMuZCgpO1xuXHRcdHRoaXMuaChodG1sKTtcblx0XHR0aGlzLmkodGhpcy5hKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZCgpIHtcblx0XHR0aGlzLm4uZm9yRWFjaChkZXRhY2gpO1xuXHR9XG59XG5cbi8qKlxuICogQGV4dGVuZHMgSHRtbFRhZyAqL1xuZXhwb3J0IGNsYXNzIEh0bWxUYWdIeWRyYXRpb24gZXh0ZW5kcyBIdG1sVGFnIHtcblx0Ly8gaHlkcmF0aW9uIGNsYWltZWQgbm9kZXNcblx0LyoqICovXG5cdGwgPSB1bmRlZmluZWQ7XG5cdGNvbnN0cnVjdG9yKGNsYWltZWRfbm9kZXMsIGlzX3N2ZyA9IGZhbHNlKSB7XG5cdFx0c3VwZXIoaXNfc3ZnKTtcblx0XHR0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuXHRcdHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRjKGh0bWwpIHtcblx0XHRpZiAodGhpcy5sKSB7XG5cdFx0XHR0aGlzLm4gPSB0aGlzLmw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN1cGVyLmMoaHRtbCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRpKGFuY2hvcikge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TmFtZWROb2RlTWFwfSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyaWJ1dGVfdG9fb2JqZWN0KGF0dHJpYnV0ZXMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcblx0XHRyZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaChcblx0XHQvKiogQHBhcmFtIHtFbGVtZW50fSBub2RlICovIChub2RlKSA9PiB7XG5cdFx0XHRyZXN1bHRbbm9kZS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuXHRcdH1cblx0KTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50KGNvbXBvbmVudCwgcHJvcHMpIHtcblx0cmV0dXJuIG5ldyBjb21wb25lbnQocHJvcHMpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtOb2RlICYge1xuICogXHRjbGFpbV9vcmRlcj86IG51bWJlcjtcbiAqIFx0aHlkcmF0ZV9pbml0PzogdHJ1ZTtcbiAqIFx0YWN0dWFsX2VuZF9jaGlsZD86IE5vZGVFeDtcbiAqIFx0Y2hpbGROb2RlczogTm9kZUxpc3RPZjxOb2RlRXg+O1xuICogfX0gTm9kZUV4XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtDaGlsZE5vZGUgJiBOb2RlRXh9IENoaWxkTm9kZUV4ICovXG5cbi8qKiBAdHlwZWRlZiB7Tm9kZUV4ICYgeyBjbGFpbV9vcmRlcjogbnVtYmVyIH19IE5vZGVFeDIgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Q2hpbGROb2RlRXhbXSAmIHtcbiAqIFx0Y2xhaW1faW5mbz86IHtcbiAqIFx0XHRsYXN0X2luZGV4OiBudW1iZXI7XG4gKiBcdFx0dG90YWxfY2xhaW1lZDogbnVtYmVyO1xuICogXHR9O1xuICogfX0gQ2hpbGROb2RlQXJyYXlcbiAqL1xuIiwiaW1wb3J0IHsgYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQsIGRldGFjaCwgZ2V0X3Jvb3RfZm9yX3N0eWxlIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgcmFmIH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5cbi8vIHdlIG5lZWQgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGZvciBtdWx0aXBsZSBkb2N1bWVudHMgYmVjYXVzZSBhIFN2ZWx0ZSBhcHBsaWNhdGlvbiBjb3VsZCBhbHNvIGNvbnRhaW4gaWZyYW1lc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvMzYyNFxuLyoqIEB0eXBlIHtNYXA8RG9jdW1lbnQgfCBTaGFkb3dSb290LCBpbXBvcnQoJy4vcHJpdmF0ZS5kLnRzJykuU3R5bGVJbmZvcm1hdGlvbj59ICovXG5jb25zdCBtYW5hZ2VkX3N0eWxlcyA9IG5ldyBNYXAoKTtcblxubGV0IGFjdGl2ZSA9IDA7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG5cdGxldCBoYXNoID0gNTM4MTtcblx0bGV0IGkgPSBzdHIubGVuZ3RoO1xuXHR3aGlsZSAoaS0tKSBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcblx0cmV0dXJuIGhhc2ggPj4+IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtEb2N1bWVudCB8IFNoYWRvd1Jvb3R9IGRvY1xuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcmV0dXJucyB7eyBzdHlsZXNoZWV0OiBhbnk7IHJ1bGVzOiB7fTsgfX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSkge1xuXHRjb25zdCBpbmZvID0geyBzdHlsZXNoZWV0OiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSwgcnVsZXM6IHt9IH07XG5cdG1hbmFnZWRfc3R5bGVzLnNldChkb2MsIGluZm8pO1xuXHRyZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXlcbiAqIEBwYXJhbSB7KHQ6IG51bWJlcikgPT4gbnVtYmVyfSBlYXNlXG4gKiBAcGFyYW0geyh0OiBudW1iZXIsIHU6IG51bWJlcikgPT4gc3RyaW5nfSBmblxuICogQHBhcmFtIHtudW1iZXJ9IHVpZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9ydWxlKG5vZGUsIGEsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzZSwgZm4sIHVpZCA9IDApIHtcblx0Y29uc3Qgc3RlcCA9IDE2LjY2NiAvIGR1cmF0aW9uO1xuXHRsZXQga2V5ZnJhbWVzID0gJ3tcXG4nO1xuXHRmb3IgKGxldCBwID0gMDsgcCA8PSAxOyBwICs9IHN0ZXApIHtcblx0XHRjb25zdCB0ID0gYSArIChiIC0gYSkgKiBlYXNlKHApO1xuXHRcdGtleWZyYW1lcyArPSBwICogMTAwICsgYCV7JHtmbih0LCAxIC0gdCl9fVxcbmA7XG5cdH1cblx0Y29uc3QgcnVsZSA9IGtleWZyYW1lcyArIGAxMDAlIHske2ZuKGIsIDEgLSBiKX19XFxufWA7XG5cdGNvbnN0IG5hbWUgPSBgX19zdmVsdGVfJHtoYXNoKHJ1bGUpfV8ke3VpZH1gO1xuXHRjb25zdCBkb2MgPSBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSk7XG5cdGNvbnN0IHsgc3R5bGVzaGVldCwgcnVsZXMgfSA9IG1hbmFnZWRfc3R5bGVzLmdldChkb2MpIHx8IGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpO1xuXHRpZiAoIXJ1bGVzW25hbWVdKSB7XG5cdFx0cnVsZXNbbmFtZV0gPSB0cnVlO1xuXHRcdHN0eWxlc2hlZXQuaW5zZXJ0UnVsZShgQGtleWZyYW1lcyAke25hbWV9ICR7cnVsZX1gLCBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG5cdH1cblx0Y29uc3QgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG5cdG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gYCR7XG5cdFx0YW5pbWF0aW9uID8gYCR7YW5pbWF0aW9ufSwgYCA6ICcnXG5cdH0ke25hbWV9ICR7ZHVyYXRpb259bXMgbGluZWFyICR7ZGVsYXl9bXMgMSBib3RoYDtcblx0YWN0aXZlICs9IDE7XG5cdHJldHVybiBuYW1lO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVfcnVsZShub2RlLCBuYW1lKSB7XG5cdGNvbnN0IHByZXZpb3VzID0gKG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnKS5zcGxpdCgnLCAnKTtcblx0Y29uc3QgbmV4dCA9IHByZXZpb3VzLmZpbHRlcihcblx0XHRuYW1lXG5cdFx0XHQ/IChhbmltKSA9PiBhbmltLmluZGV4T2YobmFtZSkgPCAwIC8vIHJlbW92ZSBzcGVjaWZpYyBhbmltYXRpb25cblx0XHRcdDogKGFuaW0pID0+IGFuaW0uaW5kZXhPZignX19zdmVsdGUnKSA9PT0gLTEgLy8gcmVtb3ZlIGFsbCBTdmVsdGUgYW5pbWF0aW9uc1xuXHQpO1xuXHRjb25zdCBkZWxldGVkID0gcHJldmlvdXMubGVuZ3RoIC0gbmV4dC5sZW5ndGg7XG5cdGlmIChkZWxldGVkKSB7XG5cdFx0bm9kZS5zdHlsZS5hbmltYXRpb24gPSBuZXh0LmpvaW4oJywgJyk7XG5cdFx0YWN0aXZlIC09IGRlbGV0ZWQ7XG5cdFx0aWYgKCFhY3RpdmUpIGNsZWFyX3J1bGVzKCk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyX3J1bGVzKCkge1xuXHRyYWYoKCkgPT4ge1xuXHRcdGlmIChhY3RpdmUpIHJldHVybjtcblx0XHRtYW5hZ2VkX3N0eWxlcy5mb3JFYWNoKChpbmZvKSA9PiB7XG5cdFx0XHRjb25zdCB7IG93bmVyTm9kZSB9ID0gaW5mby5zdHlsZXNoZWV0O1xuXHRcdFx0Ly8gdGhlcmUgaXMgbm8gb3duZXJOb2RlIGlmIGl0IHJ1bnMgb24ganNkb20uXG5cdFx0XHRpZiAob3duZXJOb2RlKSBkZXRhY2gob3duZXJOb2RlKTtcblx0XHR9KTtcblx0XHRtYW5hZ2VkX3N0eWxlcy5jbGVhcigpO1xuXHR9KTtcbn1cbiIsImltcG9ydCB7IGlkZW50aXR5IGFzIGxpbmVhciwgbm9vcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5pbXBvcnQgeyBsb29wIH0gZnJvbSAnLi9sb29wLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9ydWxlLCBkZWxldGVfcnVsZSB9IGZyb20gJy4vc3R5bGVfbWFuYWdlci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuUG9zaXRpb25SZWN0fSBmcm9tXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuQW5pbWF0aW9uRm59IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfYW5pbWF0aW9uKG5vZGUsIGZyb20sIGZuLCBwYXJhbXMpIHtcblx0aWYgKCFmcm9tKSByZXR1cm4gbm9vcDtcblx0Y29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRpZiAoXG5cdFx0ZnJvbS5sZWZ0ID09PSB0by5sZWZ0ICYmXG5cdFx0ZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiZcblx0XHRmcm9tLnRvcCA9PT0gdG8udG9wICYmXG5cdFx0ZnJvbS5ib3R0b20gPT09IHRvLmJvdHRvbVxuXHQpXG5cdFx0cmV0dXJuIG5vb3A7XG5cdGNvbnN0IHtcblx0XHRkZWxheSA9IDAsXG5cdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdC8vIEB0cy1pZ25vcmUgdG9kbzogc2hvdWxkIHRoaXMgYmUgc2VwYXJhdGVkIGZyb20gZGVzdHJ1Y3R1cmluZz8gT3Igc3RhcnQvZW5kIGFkZGVkIHRvIHB1YmxpYyBhcGkgYW5kIGRvY3VtZW50YXRpb24/XG5cdFx0c3RhcnQ6IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5LFxuXHRcdC8vIEB0cy1pZ25vcmUgdG9kbzpcblx0XHRlbmQgPSBzdGFydF90aW1lICsgZHVyYXRpb24sXG5cdFx0dGljayA9IG5vb3AsXG5cdFx0Y3NzXG5cdH0gPSBmbihub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyk7XG5cdGxldCBydW5uaW5nID0gdHJ1ZTtcblx0bGV0IHN0YXJ0ZWQgPSBmYWxzZTtcblx0bGV0IG5hbWU7XG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gc3RhcnQoKSB7XG5cdFx0aWYgKGNzcykge1xuXHRcdFx0bmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuXHRcdH1cblx0XHRpZiAoIWRlbGF5KSB7XG5cdFx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBzdG9wKCkge1xuXHRcdGlmIChjc3MpIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuXHRcdHJ1bm5pbmcgPSBmYWxzZTtcblx0fVxuXHRsb29wKChub3cpID0+IHtcblx0XHRpZiAoIXN0YXJ0ZWQgJiYgbm93ID49IHN0YXJ0X3RpbWUpIHtcblx0XHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG5cdFx0XHR0aWNrKDEsIDApO1xuXHRcdFx0c3RvcCgpO1xuXHRcdH1cblx0XHRpZiAoIXJ1bm5pbmcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKHN0YXJ0ZWQpIHtcblx0XHRcdGNvbnN0IHAgPSBub3cgLSBzdGFydF90aW1lO1xuXHRcdFx0Y29uc3QgdCA9IDAgKyAxICogZWFzaW5nKHAgLyBkdXJhdGlvbik7XG5cdFx0XHR0aWNrKHQsIDEgLSB0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pO1xuXHRzdGFydCgpO1xuXHR0aWNrKDAsIDEpO1xuXHRyZXR1cm4gc3RvcDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRpZiAoc3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgc3R5bGUucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcblx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHN0eWxlO1xuXHRcdGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcblx0XHRhZGRfdHJhbnNmb3JtKG5vZGUsIGEpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuUG9zaXRpb25SZWN0fSBhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF90cmFuc2Zvcm0obm9kZSwgYSkge1xuXHRjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0aWYgKGEubGVmdCAhPT0gYi5sZWZ0IHx8IGEudG9wICE9PSBiLnRvcCkge1xuXHRcdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0XHRjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuXHRcdG5vZGUuc3R5bGUudHJhbnNmb3JtID0gYCR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHthLmxlZnQgLSBiLmxlZnR9cHgsICR7YS50b3AgLSBiLnRvcH1weClgO1xuXHR9XG59XG4iLCIvKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9ICh4KSA9PiB4O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUgU1xuICogQHBhcmFtIHtUfSB0YXJcbiAqIEBwYXJhbSB7U30gc3JjXG4gKiBAcmV0dXJucyB7VCAmIFN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRmb3IgKGNvbnN0IGsgaW4gc3JjKSB0YXJba10gPSBzcmNba107XG5cdHJldHVybiAvKiogQHR5cGUge1QgJiBTfSAqLyAodGFyKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvTElDRU5TRVxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBQcm9taXNlTGlrZTxhbnk+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuXHRyZXR1cm4gKFxuXHRcdCEhdmFsdWUgJiZcblx0XHQodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmXG5cdFx0dHlwZW9mICgvKiogQHR5cGUge2FueX0gKi8gKHZhbHVlKS50aGVuKSA9PT0gJ2Z1bmN0aW9uJ1xuXHQpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuXHRlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG5cdFx0bG9jOiB7IGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhciB9XG5cdH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydW4oZm4pIHtcblx0cmV0dXJuIGZuKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG5cdHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gZm5zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9hbGwoZm5zKSB7XG5cdGZucy5mb3JFYWNoKHJ1bik7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHRoaW5nXG4gKiBAcmV0dXJucyB7dGhpbmcgaXMgRnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuXHRyZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYiB8fCAoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nO1xufVxuXG5sZXQgc3JjX3VybF9lcXVhbF9hbmNob3I7XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcmNfdXJsX2VxdWFsKGVsZW1lbnRfc3JjLCB1cmwpIHtcblx0aWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuXHRcdHNyY191cmxfZXF1YWxfYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHR9XG5cdHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWYgPSB1cmw7XG5cdHJldHVybiBlbGVtZW50X3NyYyA9PT0gc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZjtcbn1cblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG5cdGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZShzdG9yZSwgLi4uY2FsbGJhY2tzKSB7XG5cdGlmIChzdG9yZSA9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcblx0XHRcdGNhbGxiYWNrKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRcdHJldHVybiBub29wO1xuXHR9XG5cdGNvbnN0IHVuc3ViID0gc3RvcmUuc3Vic2NyaWJlKC4uLmNhbGxiYWNrcyk7XG5cdHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSBhIHN0b3JlIGJ5IHN1YnNjcmliaW5nIGFuZCBpbW1lZGlhdGVseSB1bnN1YnNjcmliaW5nLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNnZXRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vc3RvcmUvcHVibGljLmpzJykuUmVhZGFibGU8VD59IHN0b3JlXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuXHRsZXQgdmFsdWU7XG5cdHN1YnNjcmliZShzdG9yZSwgKF8pID0+ICh2YWx1ZSA9IF8pKSgpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG5cdGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goc3Vic2NyaWJlKHN0b3JlLCBjYWxsYmFjaykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3Nsb3QoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuXHRpZiAoZGVmaW5pdGlvbikge1xuXHRcdGNvbnN0IHNsb3RfY3R4ID0gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKTtcblx0XHRyZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG5cdHJldHVybiBkZWZpbml0aW9uWzFdICYmIGZuID8gYXNzaWduKCQkc2NvcGUuY3R4LnNsaWNlKCksIGRlZmluaXRpb25bMV0oZm4oY3R4KSkpIDogJCRzY29wZS5jdHg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc2xvdF9jaGFuZ2VzKGRlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBmbikge1xuXHRpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuXHRcdGNvbnN0IGxldHMgPSBkZWZpbml0aW9uWzJdKGZuKGRpcnR5KSk7XG5cdFx0aWYgKCQkc2NvcGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGxldHM7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbGV0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGNvbnN0IG1lcmdlZCA9IFtdO1xuXHRcdFx0Y29uc3QgbGVuID0gTWF0aC5tYXgoJCRzY29wZS5kaXJ0eS5sZW5ndGgsIGxldHMubGVuZ3RoKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcblx0XHRcdFx0bWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWVyZ2VkO1xuXHRcdH1cblx0XHRyZXR1cm4gJCRzY29wZS5kaXJ0eSB8IGxldHM7XG5cdH1cblx0cmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKFxuXHRzbG90LFxuXHRzbG90X2RlZmluaXRpb24sXG5cdGN0eCxcblx0JCRzY29wZSxcblx0c2xvdF9jaGFuZ2VzLFxuXHRnZXRfc2xvdF9jb250ZXh0X2ZuXG4pIHtcblx0aWYgKHNsb3RfY2hhbmdlcykge1xuXHRcdGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuXHRcdHNsb3QucChzbG90X2NvbnRleHQsIHNsb3RfY2hhbmdlcyk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zbG90KFxuXHRzbG90LFxuXHRzbG90X2RlZmluaXRpb24sXG5cdGN0eCxcblx0JCRzY29wZSxcblx0ZGlydHksXG5cdGdldF9zbG90X2NoYW5nZXNfZm4sXG5cdGdldF9zbG90X2NvbnRleHRfZm5cbikge1xuXHRjb25zdCBzbG90X2NoYW5nZXMgPSBnZXRfc2xvdF9jaGFuZ2VzKHNsb3RfZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4pO1xuXHR1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pO1xufVxuXG4vKiogQHJldHVybnMge2FueVtdIHwgLTF9ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2FsbF9kaXJ0eV9mcm9tX3Njb3BlKCQkc2NvcGUpIHtcblx0aWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG5cdFx0Y29uc3QgZGlydHkgPSBbXTtcblx0XHRjb25zdCBsZW5ndGggPSAkJHNjb3BlLmN0eC5sZW5ndGggLyAzMjtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkaXJ0eVtpXSA9IC0xO1xuXHRcdH1cblx0XHRyZXR1cm4gZGlydHk7XG5cdH1cblx0cmV0dXJuIC0xO1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMocHJvcHMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGZvciAoY29uc3QgayBpbiBwcm9wcykgaWYgKGtbMF0gIT09ICckJykgcmVzdWx0W2tdID0gcHJvcHNba107XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZV9yZXN0X3Byb3BzKHByb3BzLCBrZXlzKSB7XG5cdGNvbnN0IHJlc3QgPSB7fTtcblx0a2V5cyA9IG5ldyBTZXQoa2V5cyk7XG5cdGZvciAoY29uc3QgayBpbiBwcm9wcykgaWYgKCFrZXlzLmhhcyhrKSAmJiBrWzBdICE9PSAnJCcpIHJlc3Rba10gPSBwcm9wc1trXTtcblx0cmV0dXJuIHJlc3Q7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZV9zbG90cyhzbG90cykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcblx0XHRyZXN1bHRba2V5XSA9IHRydWU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEByZXR1cm5zIHsodGhpczogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmNlKGZuKSB7XG5cdGxldCByYW4gPSBmYWxzZTtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0aWYgKHJhbikgcmV0dXJuO1xuXHRcdHJhbiA9IHRydWU7XG5cdFx0Zm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcblx0fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bGxfdG9fZW1wdHkodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBjb25zdCBoYXNfcHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuXG5leHBvcnQgZnVuY3Rpb24gYWN0aW9uX2Rlc3Ryb3llcihhY3Rpb25fcmVzdWx0KSB7XG5cdHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuXG4vKiogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7W251bWJlciwgc3RyaW5nXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0X2Nzc191bml0KHZhbHVlKSB7XG5cdGNvbnN0IHNwbGl0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5tYXRjaCgvXlxccyooLT9bXFxkLl0rKShbXlxcc10qKVxccyokLyk7XG5cdHJldHVybiBzcGxpdCA/IFtwYXJzZUZsb2F0KHNwbGl0WzFdKSwgc3BsaXRbMl0gfHwgJ3B4J10gOiBbLyoqIEB0eXBlIHtudW1iZXJ9ICovICh2YWx1ZSksICdweCddO1xufVxuXG5leHBvcnQgY29uc3QgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMgPSBbJycsIHRydWUsIDEsICd0cnVlJywgJ2NvbnRlbnRlZGl0YWJsZSddO1xuIiwiaW1wb3J0IHsgY3VzdG9tX2V2ZW50IH0gZnJvbSAnLi9kb20uanMnO1xuXG5leHBvcnQgbGV0IGN1cnJlbnRfY29tcG9uZW50O1xuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCkge1xuXHRjdXJyZW50X2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldF9jdXJyZW50X2NvbXBvbmVudCgpIHtcblx0aWYgKCFjdXJyZW50X2NvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcblx0cmV0dXJuIGN1cnJlbnRfY29tcG9uZW50O1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2JlZm9yZXVwZGF0ZVxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFRoZSBgb25Nb3VudGAgZnVuY3Rpb24gc2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGFzIHNvb24gYXMgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIHRvIHRoZSBET00uXG4gKiBJdCBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgdGhlIGNvbXBvbmVudCdzIGluaXRpYWxpc2F0aW9uIChidXQgZG9lc24ndCBuZWVkIHRvIGxpdmUgKmluc2lkZSogdGhlIGNvbXBvbmVudDtcbiAqIGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBhbiBleHRlcm5hbCBtb2R1bGUpLlxuICpcbiAqIElmIGEgZnVuY3Rpb24gaXMgcmV0dXJuZWQgX3N5bmNocm9ub3VzbHlfIGZyb20gYG9uTW91bnRgLCBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIGBvbk1vdW50YCBkb2VzIG5vdCBydW4gaW5zaWRlIGEgW3NlcnZlci1zaWRlIGNvbXBvbmVudF0oL2RvY3MjcnVuLXRpbWUtc2VydmVyLXNpZGUtY29tcG9uZW50LWFwaSkuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI29ubW91bnRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IGltcG9ydCgnLi9wcml2YXRlLmpzJykuTm90RnVuY3Rpb248VD4gfCBQcm9taXNlPGltcG9ydCgnLi9wcml2YXRlLmpzJykuTm90RnVuY3Rpb248VD4+IHwgKCgpID0+IGFueSl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fbW91bnQucHVzaChmbik7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZC5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGFmdGVyIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNhZnRlcnVwZGF0ZVxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyVXBkYXRlKGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIE91dCBvZiBgb25Nb3VudGAsIGBiZWZvcmVVcGRhdGVgLCBgYWZ0ZXJVcGRhdGVgIGFuZCBgb25EZXN0cm95YCwgdGhpcyBpcyB0aGVcbiAqIG9ubHkgb25lIHRoYXQgcnVucyBpbnNpZGUgYSBzZXJ2ZXItc2lkZSBjb21wb25lbnQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI29uZGVzdHJveVxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9kZXN0cm95LnB1c2goZm4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXZlbnQgZGlzcGF0Y2hlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGRpc3BhdGNoIFtjb21wb25lbnQgZXZlbnRzXSgvZG9jcyN0ZW1wbGF0ZS1zeW50YXgtY29tcG9uZW50LWRpcmVjdGl2ZXMtb24tZXZlbnRuYW1lKS5cbiAqIEV2ZW50IGRpc3BhdGNoZXJzIGFyZSBmdW5jdGlvbnMgdGhhdCBjYW4gdGFrZSB0d28gYXJndW1lbnRzOiBgbmFtZWAgYW5kIGBkZXRhaWxgLlxuICpcbiAqIENvbXBvbmVudCBldmVudHMgY3JlYXRlZCB3aXRoIGBjcmVhdGVFdmVudERpc3BhdGNoZXJgIGNyZWF0ZSBhXG4gKiBbQ3VzdG9tRXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudCkuXG4gKiBUaGVzZSBldmVudHMgZG8gbm90IFtidWJibGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTGVhcm4vSmF2YVNjcmlwdC9CdWlsZGluZ19ibG9ja3MvRXZlbnRzI0V2ZW50X2J1YmJsaW5nX2FuZF9jYXB0dXJlKS5cbiAqIFRoZSBgZGV0YWlsYCBhcmd1bWVudCBjb3JyZXNwb25kcyB0byB0aGUgW0N1c3RvbUV2ZW50LmRldGFpbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L2RldGFpbClcbiAqIHByb3BlcnR5IGFuZCBjYW4gY29udGFpbiBhbnkgdHlwZSBvZiBkYXRhLlxuICpcbiAqIFRoZSBldmVudCBkaXNwYXRjaGVyIGNhbiBiZSB0eXBlZCB0byBuYXJyb3cgdGhlIGFsbG93ZWQgZXZlbnQgbmFtZXMgYW5kIHRoZSB0eXBlIG9mIHRoZSBgZGV0YWlsYCBhcmd1bWVudDpcbiAqIGBgYHRzXG4gKiBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcjx7XG4gKiAgbG9hZGVkOiBuZXZlcjsgLy8gZG9lcyBub3QgdGFrZSBhIGRldGFpbCBhcmd1bWVudFxuICogIGNoYW5nZTogc3RyaW5nOyAvLyB0YWtlcyBhIGRldGFpbCBhcmd1bWVudCBvZiB0eXBlIHN0cmluZywgd2hpY2ggaXMgcmVxdWlyZWRcbiAqICBvcHRpb25hbDogbnVtYmVyIHwgbnVsbDsgLy8gdGFrZXMgYW4gb3B0aW9uYWwgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgbnVtYmVyXG4gKiB9PigpO1xuICogYGBgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2NyZWF0ZWV2ZW50ZGlzcGF0Y2hlclxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbRXZlbnRNYXA9YW55XVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5FdmVudERpc3BhdGNoZXI8RXZlbnRNYXA+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuXHRjb25zdCBjb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcblx0cmV0dXJuICh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuXHRcdGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbdHlwZV07XG5cdFx0aWYgKGNhbGxiYWNrcykge1xuXHRcdFx0Ly8gVE9ETyBhcmUgdGhlcmUgc2l0dWF0aW9ucyB3aGVyZSBldmVudHMgY291bGQgYmUgZGlzcGF0Y2hlZFxuXHRcdFx0Ly8gaW4gYSBzZXJ2ZXIgKG5vbi1ET00pIGVudmlyb25tZW50P1xuXHRcdFx0Y29uc3QgZXZlbnQgPSBjdXN0b21fZXZlbnQoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgfSk7XG5cdFx0XHRjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKChmbikgPT4ge1xuXHRcdFx0XHRmbi5jYWxsKGNvbXBvbmVudCwgZXZlbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xufVxuXG4vKipcbiAqIEFzc29jaWF0ZXMgYW4gYXJiaXRyYXJ5IGBjb250ZXh0YCBvYmplY3Qgd2l0aCB0aGUgY3VycmVudCBjb21wb25lbnQgYW5kIHRoZSBzcGVjaWZpZWQgYGtleWBcbiAqIGFuZCByZXR1cm5zIHRoYXQgb2JqZWN0LiBUaGUgY29udGV4dCBpcyB0aGVuIGF2YWlsYWJsZSB0byBjaGlsZHJlbiBvZiB0aGUgY29tcG9uZW50XG4gKiAoaW5jbHVkaW5nIHNsb3R0ZWQgY29udGVudCkgd2l0aCBgZ2V0Q29udGV4dGAuXG4gKlxuICogTGlrZSBsaWZlY3ljbGUgZnVuY3Rpb25zLCB0aGlzIG11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI3NldGNvbnRleHRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcGFyYW0ge1R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcblx0cmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb250ZXh0IHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50IHdpdGggdGhlIHNwZWNpZmllZCBga2V5YC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2dldGNvbnRleHRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG5cdHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmdldChrZXkpO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgd2hvbGUgY29udGV4dCBtYXAgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLiBVc2VmdWwsIGZvciBleGFtcGxlLCBpZiB5b3VcbiAqIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgY29tcG9uZW50IGFuZCB3YW50IHRvIHBhc3MgdGhlIGV4aXN0aW5nIGNvbnRleHQgdG8gaXQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2dldGFsbGNvbnRleHRzXG4gKiBAdGVtcGxhdGUge01hcDxhbnksIGFueT59IFtUPU1hcDxhbnksIGFueT5dXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuXHRyZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGBrZXlgIGhhcyBiZWVuIHNldCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNoYXNjb250ZXh0XG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0NvbnRleHQoa2V5KSB7XG5cdHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmhhcyhrZXkpO1xufVxuXG4vLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugc3RpbGwgd2FudCB0byBzdXBwb3J0XG4vLyBzaG9ydGhhbmQgZXZlbnRzLCBvciBpZiB3ZSB3YW50IHRvIGltcGxlbWVudFxuLy8gYSByZWFsIGJ1YmJsaW5nIG1lY2hhbmlzbVxuLyoqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKiBAcGFyYW0gZXZlbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnViYmxlKGNvbXBvbmVudCwgZXZlbnQpIHtcblx0Y29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1tldmVudC50eXBlXTtcblx0aWYgKGNhbGxiYWNrcykge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKChmbikgPT4gZm4uY2FsbCh0aGlzLCBldmVudCkpO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBydW5fYWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuXG5leHBvcnQgY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuZXhwb3J0IGNvbnN0IGludHJvcyA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbmV4cG9ydCBjb25zdCBiaW5kaW5nX2NhbGxiYWNrcyA9IFtdO1xuXG5sZXQgcmVuZGVyX2NhbGxiYWNrcyA9IFtdO1xuXG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcblxuY29uc3QgcmVzb2x2ZWRfcHJvbWlzZSA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcblxubGV0IHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlX3VwZGF0ZSgpIHtcblx0aWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG5cdFx0dXBkYXRlX3NjaGVkdWxlZCA9IHRydWU7XG5cdFx0cmVzb2x2ZWRfcHJvbWlzZS50aGVuKGZsdXNoKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge1Byb21pc2U8dm9pZD59ICovXG5leHBvcnQgZnVuY3Rpb24gdGljaygpIHtcblx0c2NoZWR1bGVfdXBkYXRlKCk7XG5cdHJldHVybiByZXNvbHZlZF9wcm9taXNlO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX3JlbmRlcl9jYWxsYmFjayhmbikge1xuXHRyZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2ZsdXNoX2NhbGxiYWNrKGZuKSB7XG5cdGZsdXNoX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cblxuLy8gZmx1c2goKSBjYWxscyBjYWxsYmFja3MgaW4gdGhpcyBvcmRlcjpcbi8vIDEuIEFsbCBiZWZvcmVVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW5cbi8vIDIuIEFsbCBiaW5kOnRoaXMgY2FsbGJhY2tzLCBpbiByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIDMuIEFsbCBhZnRlclVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlbi4gRVhDRVBUXG4vLyAgICBmb3IgYWZ0ZXJVcGRhdGVzIGNhbGxlZCBkdXJpbmcgdGhlIGluaXRpYWwgb25Nb3VudCwgd2hpY2ggYXJlIGNhbGxlZCBpblxuLy8gICAgcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyBTaW5jZSBjYWxsYmFja3MgbWlnaHQgdXBkYXRlIGNvbXBvbmVudCB2YWx1ZXMsIHdoaWNoIGNvdWxkIHRyaWdnZXIgYW5vdGhlclxuLy8gY2FsbCB0byBmbHVzaCgpLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGd1YXJkIGFnYWluc3QgdGhpczpcbi8vIDEuIER1cmluZyBiZWZvcmVVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vICAgIGRpcnR5X2NvbXBvbmVudHMgYXJyYXkgYW5kIHdpbGwgY2F1c2UgYSByZWVudHJhbnQgY2FsbCB0byBmbHVzaCgpLiBCZWNhdXNlXG4vLyAgICB0aGUgZmx1c2ggaW5kZXggaXMga2VwdCBvdXRzaWRlIHRoZSBmdW5jdGlvbiwgdGhlIHJlZW50cmFudCBjYWxsIHdpbGwgcGlja1xuLy8gICAgdXAgd2hlcmUgdGhlIGVhcmxpZXIgY2FsbCBsZWZ0IG9mZiBhbmQgZ28gdGhyb3VnaCBhbGwgZGlydHkgY29tcG9uZW50cy4gVGhlXG4vLyAgICBjdXJyZW50X2NvbXBvbmVudCB2YWx1ZSBpcyBzYXZlZCBhbmQgcmVzdG9yZWQgc28gdGhhdCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbFxuLy8gICAgbm90IGludGVyZmVyZSB3aXRoIHRoZSBcInBhcmVudFwiIGZsdXNoKCkgY2FsbC5cbi8vIDIuIGJpbmQ6dGhpcyBjYWxsYmFja3MgY2Fubm90IHRyaWdnZXIgbmV3IGZsdXNoKCkgY2FsbHMuXG4vLyAzLiBEdXJpbmcgYWZ0ZXJVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBOT1QgaGF2ZSB0aGVpciBhZnRlclVwZGF0ZVxuLy8gICAgY2FsbGJhY2sgY2FsbGVkIGEgc2Vjb25kIHRpbWU7IHRoZSBzZWVuX2NhbGxiYWNrcyBzZXQsIG91dHNpZGUgdGhlIGZsdXNoKClcbi8vICAgIGZ1bmN0aW9uLCBndWFyYW50ZWVzIHRoaXMgYmVoYXZpb3IuXG5jb25zdCBzZWVuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcblxubGV0IGZsdXNoaWR4ID0gMDsgLy8gRG8gKm5vdCogbW92ZSB0aGlzIGluc2lkZSB0aGUgZmx1c2goKSBmdW5jdGlvblxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2goKSB7XG5cdC8vIERvIG5vdCByZWVudGVyIGZsdXNoIHdoaWxlIGRpcnR5IGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGFzIHRoaXMgY2FuXG5cdC8vIHJlc3VsdCBpbiBhbiBpbmZpbml0ZSBsb29wLiBJbnN0ZWFkLCBsZXQgdGhlIGlubmVyIGZsdXNoIGhhbmRsZSBpdC5cblx0Ly8gUmVlbnRyYW5jeSBpcyBvayBhZnRlcndhcmRzIGZvciBiaW5kaW5ncyBldGMuXG5cdGlmIChmbHVzaGlkeCAhPT0gMCkge1xuXHRcdHJldHVybjtcblx0fVxuXHRjb25zdCBzYXZlZF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcblx0ZG8ge1xuXHRcdC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcblx0XHQvLyBhbmQgdXBkYXRlIGNvbXBvbmVudHNcblx0XHR0cnkge1xuXHRcdFx0d2hpbGUgKGZsdXNoaWR4IDwgZGlydHlfY29tcG9uZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0Y29uc3QgY29tcG9uZW50ID0gZGlydHlfY29tcG9uZW50c1tmbHVzaGlkeF07XG5cdFx0XHRcdGZsdXNoaWR4Kys7XG5cdFx0XHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuXHRcdFx0XHR1cGRhdGUoY29tcG9uZW50LiQkKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyByZXNldCBkaXJ0eSBzdGF0ZSB0byBub3QgZW5kIHVwIGluIGEgZGVhZGxvY2tlZCBzdGF0ZSBhbmQgdGhlbiByZXRocm93XG5cdFx0XHRkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG5cdFx0XHRmbHVzaGlkeCA9IDA7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0XHRzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG5cdFx0ZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuXHRcdGZsdXNoaWR4ID0gMDtcblx0XHR3aGlsZSAoYmluZGluZ19jYWxsYmFja3MubGVuZ3RoKSBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuXHRcdC8vIHRoZW4sIG9uY2UgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgY2FsbFxuXHRcdC8vIGFmdGVyVXBkYXRlIGZ1bmN0aW9ucy4gVGhpcyBtYXkgY2F1c2Vcblx0XHQvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuLi5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGNvbnN0IGNhbGxiYWNrID0gcmVuZGVyX2NhbGxiYWNrc1tpXTtcblx0XHRcdGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuXHRcdFx0XHQvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG5cdFx0XHRcdHNlZW5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcblx0fSB3aGlsZSAoZGlydHlfY29tcG9uZW50cy5sZW5ndGgpO1xuXHR3aGlsZSAoZmx1c2hfY2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdGZsdXNoX2NhbGxiYWNrcy5wb3AoKSgpO1xuXHR9XG5cdHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcblx0c2Vlbl9jYWxsYmFja3MuY2xlYXIoKTtcblx0c2V0X2N1cnJlbnRfY29tcG9uZW50KHNhdmVkX2NvbXBvbmVudCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgkJCkge1xuXHRpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcblx0XHQkJC51cGRhdGUoKTtcblx0XHRydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuXHRcdGNvbnN0IGRpcnR5ID0gJCQuZGlydHk7XG5cdFx0JCQuZGlydHkgPSBbLTFdO1xuXHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG5cdFx0JCQuYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG5cdH1cbn1cblxuLyoqXG4gKiBVc2VmdWwgZm9yIGV4YW1wbGUgdG8gZXhlY3V0ZSByZW1haW5pbmcgYGFmdGVyVXBkYXRlYCBjYWxsYmFja3MgYmVmb3JlIGV4ZWN1dGluZyBgZGVzdHJveWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW119IGZuc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKGZucykge1xuXHRjb25zdCBmaWx0ZXJlZCA9IFtdO1xuXHRjb25zdCB0YXJnZXRzID0gW107XG5cdHJlbmRlcl9jYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gKGZucy5pbmRleE9mKGMpID09PSAtMSA/IGZpbHRlcmVkLnB1c2goYykgOiB0YXJnZXRzLnB1c2goYykpKTtcblx0dGFyZ2V0cy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuXHRyZW5kZXJfY2FsbGJhY2tzID0gZmlsdGVyZWQ7XG59XG4iLCJpbXBvcnQgeyBpZGVudGl0eSBhcyBsaW5lYXIsIGlzX2Z1bmN0aW9uLCBub29wLCBydW5fYWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBub3cgfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcbmltcG9ydCB7IGxvb3AgfSBmcm9tICcuL2xvb3AuanMnO1xuaW1wb3J0IHsgY3JlYXRlX3J1bGUsIGRlbGV0ZV9ydWxlIH0gZnJvbSAnLi9zdHlsZV9tYW5hZ2VyLmpzJztcbmltcG9ydCB7IGN1c3RvbV9ldmVudCB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IGFkZF9yZW5kZXJfY2FsbGJhY2sgfSBmcm9tICcuL3NjaGVkdWxlci5qcyc7XG5cbi8qKlxuICogQHR5cGUge1Byb21pc2U8dm9pZD4gfCBudWxsfVxuICovXG5sZXQgcHJvbWlzZTtcblxuLyoqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZnVuY3Rpb24gd2FpdCgpIHtcblx0aWYgKCFwcm9taXNlKSB7XG5cdFx0cHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdHByb21pc2UudGhlbigoKSA9PiB7XG5cdFx0XHRwcm9taXNlID0gbnVsbDtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SU5UUk8gfCBPVVRSTyB8IGJvb2xlYW59IGRpcmVjdGlvblxuICogQHBhcmFtIHsnc3RhcnQnIHwgJ2VuZCd9IGtpbmRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBkaXJlY3Rpb24sIGtpbmQpIHtcblx0bm9kZS5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudChgJHtkaXJlY3Rpb24gPyAnaW50cm8nIDogJ291dHJvJ30ke2tpbmR9YCkpO1xufVxuXG5jb25zdCBvdXRyb2luZyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBAdHlwZSB7T3V0cm99XG4gKi9cbmxldCBvdXRyb3M7XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuXHRvdXRyb3MgPSB7XG5cdFx0cjogMCxcblx0XHRjOiBbXSxcblx0XHRwOiBvdXRyb3MgLy8gcGFyZW50IGdyb3VwXG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuXHRpZiAoIW91dHJvcy5yKSB7XG5cdFx0cnVuX2FsbChvdXRyb3MuYyk7XG5cdH1cblx0b3V0cm9zID0gb3V0cm9zLnA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkZyYWdtZW50fSBibG9ja1xuICogQHBhcmFtIHswIHwgMX0gW2xvY2FsXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2l0aW9uX2luKGJsb2NrLCBsb2NhbCkge1xuXHRpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuXHRcdG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG5cdFx0YmxvY2suaShsb2NhbCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuRnJhZ21lbnR9IGJsb2NrXG4gKiBAcGFyYW0gezAgfCAxfSBsb2NhbFxuICogQHBhcmFtIHswIHwgMX0gW2RldGFjaF1cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcblx0aWYgKGJsb2NrICYmIGJsb2NrLm8pIHtcblx0XHRpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSkgcmV0dXJuO1xuXHRcdG91dHJvaW5nLmFkZChibG9jayk7XG5cdFx0b3V0cm9zLmMucHVzaCgoKSA9PiB7XG5cdFx0XHRvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmIChkZXRhY2gpIGJsb2NrLmQoMSk7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0YmxvY2subyhsb2NhbCk7XG5cdH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjaygpO1xuXHR9XG59XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi4vdHJhbnNpdGlvbi9wdWJsaWMuanMnKS5UcmFuc2l0aW9uQ29uZmlnfVxuICovXG5jb25zdCBudWxsX3RyYW5zaXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge1RyYW5zaXRpb25Gbn0gZm5cbiAqIEBwYXJhbSB7YW55fSBwYXJhbXNcbiAqIEByZXR1cm5zIHt7IHN0YXJ0KCk6IHZvaWQ7IGludmFsaWRhdGUoKTogdm9pZDsgZW5kKCk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfaW5fdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7VHJhbnNpdGlvbk9wdGlvbnN9ICovXG5cdGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2luJyB9O1xuXHRsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcblx0bGV0IHJ1bm5pbmcgPSBmYWxzZTtcblx0bGV0IGFuaW1hdGlvbl9uYW1lO1xuXHRsZXQgdGFzaztcblx0bGV0IHVpZCA9IDA7XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBjbGVhbnVwKCkge1xuXHRcdGlmIChhbmltYXRpb25fbmFtZSkgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBnbygpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IDMwMCxcblx0XHRcdGVhc2luZyA9IGxpbmVhcixcblx0XHRcdHRpY2sgPSBub29wLFxuXHRcdFx0Y3NzXG5cdFx0fSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG5cdFx0aWYgKGNzcykgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzLCB1aWQrKyk7XG5cdFx0dGljaygwLCAxKTtcblx0XHRjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcblx0XHRjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcblx0XHRpZiAodGFzaykgdGFzay5hYm9ydCgpO1xuXHRcdHJ1bm5pbmcgPSB0cnVlO1xuXHRcdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0JykpO1xuXHRcdHRhc2sgPSBsb29wKChub3cpID0+IHtcblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGlmIChub3cgPj0gZW5kX3RpbWUpIHtcblx0XHRcdFx0XHR0aWNrKDEsIDApO1xuXHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIHRydWUsICdlbmQnKTtcblx0XHRcdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRcdFx0cmV0dXJuIChydW5uaW5nID0gZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuXHRcdFx0XHRcdGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuXHRcdFx0XHRcdHRpY2sodCwgMSAtIHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnVubmluZztcblx0XHR9KTtcblx0fVxuXHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0KCkge1xuXHRcdFx0aWYgKHN0YXJ0ZWQpIHJldHVybjtcblx0XHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdFx0ZGVsZXRlX3J1bGUobm9kZSk7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuXHRcdFx0XHRjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG5cdFx0XHRcdHdhaXQoKS50aGVuKGdvKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdvKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbnZhbGlkYXRlKCkge1xuXHRcdFx0c3RhcnRlZCA9IGZhbHNlO1xuXHRcdH0sXG5cdFx0ZW5kKCkge1xuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0XHRydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtUcmFuc2l0aW9uRm59IGZuXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7eyBlbmQocmVzZXQ6IGFueSk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfb3V0X3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuXHQvKiogQHR5cGUge1RyYW5zaXRpb25PcHRpb25zfSAqL1xuXHRjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdvdXQnIH07XG5cdGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHRsZXQgcnVubmluZyA9IHRydWU7XG5cdGxldCBhbmltYXRpb25fbmFtZTtcblx0Y29uc3QgZ3JvdXAgPSBvdXRyb3M7XG5cdGdyb3VwLnIgKz0gMTtcblx0LyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHRsZXQgb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBnbygpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IDMwMCxcblx0XHRcdGVhc2luZyA9IGxpbmVhcixcblx0XHRcdHRpY2sgPSBub29wLFxuXHRcdFx0Y3NzXG5cdFx0fSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG5cblx0XHRpZiAoY3NzKSBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDEsIDAsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuXG5cdFx0Y29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG5cdFx0Y29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG5cdFx0YWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ3N0YXJ0JykpO1xuXG5cdFx0aWYgKCdpbmVydCcgaW4gbm9kZSkge1xuXHRcdFx0b3JpZ2luYWxfaW5lcnRfdmFsdWUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAobm9kZSkuaW5lcnQ7XG5cdFx0XHRub2RlLmluZXJ0ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRsb29wKChub3cpID0+IHtcblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGlmIChub3cgPj0gZW5kX3RpbWUpIHtcblx0XHRcdFx0XHR0aWNrKDAsIDEpO1xuXHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnZW5kJyk7XG5cdFx0XHRcdFx0aWYgKCEtLWdyb3VwLnIpIHtcblx0XHRcdFx0XHRcdC8vIHRoaXMgd2lsbCByZXN1bHQgaW4gYGVuZCgpYCBiZWluZyBjYWxsZWQsXG5cdFx0XHRcdFx0XHQvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGNsZWFuIHVwIGhlcmVcblx0XHRcdFx0XHRcdHJ1bl9hbGwoZ3JvdXAuYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0XHR0aWNrKDEgLSB0LCB0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ1bm5pbmc7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuXHRcdHdhaXQoKS50aGVuKCgpID0+IHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcblx0XHRcdGdvKCk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0Z28oKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0ZW5kKHJlc2V0KSB7XG5cdFx0XHRpZiAocmVzZXQgJiYgJ2luZXJ0JyBpbiBub2RlKSB7XG5cdFx0XHRcdG5vZGUuaW5lcnQgPSBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChyZXNldCAmJiBjb25maWcudGljaykge1xuXHRcdFx0XHRjb25maWcudGljaygxLCAwKTtcblx0XHRcdH1cblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGlmIChhbmltYXRpb25fbmFtZSkgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuXHRcdFx0XHRydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtUcmFuc2l0aW9uRm59IGZuXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludHJvXG4gKiBAcmV0dXJucyB7eyBydW4oYjogMCB8IDEpOiB2b2lkOyBlbmQoKTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtUcmFuc2l0aW9uT3B0aW9uc30gKi9cblx0Y29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnYm90aCcgfTtcblx0bGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG5cdGxldCB0ID0gaW50cm8gPyAwIDogMTtcblxuXHQvKipcblx0ICogQHR5cGUge1Byb2dyYW0gfCBudWxsfSAqL1xuXHRsZXQgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcblxuXHQvKipcblx0ICogQHR5cGUge1BlbmRpbmdQcm9ncmFtIHwgbnVsbH0gKi9cblx0bGV0IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG5cdGxldCBhbmltYXRpb25fbmFtZSA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHRsZXQgb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBjbGVhcl9hbmltYXRpb24oKSB7XG5cdFx0aWYgKGFuaW1hdGlvbl9uYW1lKSBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtQZW5kaW5nUHJvZ3JhbX0gcHJvZ3JhbVxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cblx0ICogQHJldHVybnMge1Byb2dyYW19XG5cdCAqL1xuXHRmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgZCA9IC8qKiBAdHlwZSB7UHJvZ3JhbVsnZCddfSAqLyAocHJvZ3JhbS5iIC0gdCk7XG5cdFx0ZHVyYXRpb24gKj0gTWF0aC5hYnMoZCk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGE6IHQsXG5cdFx0XHRiOiBwcm9ncmFtLmIsXG5cdFx0XHRkLFxuXHRcdFx0ZHVyYXRpb24sXG5cdFx0XHRzdGFydDogcHJvZ3JhbS5zdGFydCxcblx0XHRcdGVuZDogcHJvZ3JhbS5zdGFydCArIGR1cmF0aW9uLFxuXHRcdFx0Z3JvdXA6IHByb2dyYW0uZ3JvdXBcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SU5UUk8gfCBPVVRST30gYlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIGdvKGIpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IDMwMCxcblx0XHRcdGVhc2luZyA9IGxpbmVhcixcblx0XHRcdHRpY2sgPSBub29wLFxuXHRcdFx0Y3NzXG5cdFx0fSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7UGVuZGluZ1Byb2dyYW19ICovXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHtcblx0XHRcdHN0YXJ0OiBub3coKSArIGRlbGF5LFxuXHRcdFx0YlxuXHRcdH07XG5cblx0XHRpZiAoIWIpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG5cdFx0XHRwcm9ncmFtLmdyb3VwID0gb3V0cm9zO1xuXHRcdFx0b3V0cm9zLnIgKz0gMTtcblx0XHR9XG5cblx0XHRpZiAoJ2luZXJ0JyBpbiBub2RlKSB7XG5cdFx0XHRpZiAoYikge1xuXHRcdFx0XHRpZiAob3JpZ2luYWxfaW5lcnRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIGFib3J0ZWQvcmV2ZXJzZWQgb3V0cm8g4oCUIHJlc3RvcmUgcHJldmlvdXMgaW5lcnQgdmFsdWVcblx0XHRcdFx0XHRub2RlLmluZXJ0ID0gb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9yaWdpbmFsX2luZXJ0X3ZhbHVlID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpLmluZXJ0O1xuXHRcdFx0XHRub2RlLmluZXJ0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSkge1xuXHRcdFx0cGVuZGluZ19wcm9ncmFtID0gcHJvZ3JhbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhbiBpbnRybywgYW5kIHRoZXJlJ3MgYSBkZWxheSwgd2UgbmVlZCB0byBkb1xuXHRcdFx0Ly8gYW4gaW5pdGlhbCB0aWNrIGFuZC9vciBhcHBseSBDU1MgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG5cdFx0XHRpZiAoY3NzKSB7XG5cdFx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0XHRhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGIpIHRpY2soMCwgMSk7XG5cdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBpbml0KHByb2dyYW0sIGR1cmF0aW9uKTtcblx0XHRcdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgYiwgJ3N0YXJ0JykpO1xuXHRcdFx0bG9vcCgobm93KSA9PiB7XG5cdFx0XHRcdGlmIChwZW5kaW5nX3Byb2dyYW0gJiYgbm93ID4gcGVuZGluZ19wcm9ncmFtLnN0YXJ0KSB7XG5cdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcblx0XHRcdFx0XHRwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnc3RhcnQnKTtcblx0XHRcdFx0XHRpZiAoY3NzKSB7XG5cdFx0XHRcdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUoXG5cdFx0XHRcdFx0XHRcdG5vZGUsXG5cdFx0XHRcdFx0XHRcdHQsXG5cdFx0XHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbS5iLFxuXHRcdFx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdGVhc2luZyxcblx0XHRcdFx0XHRcdFx0Y29uZmlnLmNzc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJ1bm5pbmdfcHJvZ3JhbSkge1xuXHRcdFx0XHRcdGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuXHRcdFx0XHRcdFx0dGljaygodCA9IHJ1bm5pbmdfcHJvZ3JhbS5iKSwgMSAtIHQpO1xuXHRcdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdlbmQnKTtcblx0XHRcdFx0XHRcdGlmICghcGVuZGluZ19wcm9ncmFtKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHdlJ3JlIGRvbmVcblx0XHRcdFx0XHRcdFx0aWYgKHJ1bm5pbmdfcHJvZ3JhbS5iKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gaW50cm8g4oCUIHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG5cdFx0XHRcdFx0XHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gb3V0cm8g4oCUIG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCEtLXJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5yKSBydW5fYWxsKHJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5jKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtID0gbnVsbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uc3RhcnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHAgPSBub3cgLSBydW5uaW5nX3Byb2dyYW0uc3RhcnQ7XG5cdFx0XHRcdFx0XHR0ID0gcnVubmluZ19wcm9ncmFtLmEgKyBydW5uaW5nX3Byb2dyYW0uZCAqIGVhc2luZyhwIC8gcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uKTtcblx0XHRcdFx0XHRcdHRpY2sodCwgMSAtIHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gISEocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtcblx0XHRydW4oYikge1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcblx0XHRcdFx0d2FpdCgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IG9wdHMgPSB7IGRpcmVjdGlvbjogYiA/ICdpbicgOiAnb3V0JyB9O1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRjb25maWcgPSBjb25maWcob3B0cyk7XG5cdFx0XHRcdFx0Z28oYik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z28oYik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlbmQoKSB7XG5cdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG5cdFx0fVxuXHR9O1xufVxuXG4vKiogQHR5cGVkZWYgezF9IElOVFJPICovXG4vKiogQHR5cGVkZWYgezB9IE9VVFJPICovXG4vKiogQHR5cGVkZWYge3sgZGlyZWN0aW9uOiAnaW4nIHwgJ291dCcgfCAnYm90aCcgfX0gVHJhbnNpdGlvbk9wdGlvbnMgKi9cbi8qKiBAdHlwZWRlZiB7KG5vZGU6IEVsZW1lbnQsIHBhcmFtczogYW55LCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucykgPT4gaW1wb3J0KCcuLi90cmFuc2l0aW9uL3B1YmxpYy5qcycpLlRyYW5zaXRpb25Db25maWd9IFRyYW5zaXRpb25GbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE91dHJvXG4gKiBAcHJvcGVydHkge251bWJlcn0gclxuICogQHByb3BlcnR5IHtGdW5jdGlvbltdfSBjXG4gKiBAcHJvcGVydHkge09iamVjdH0gcFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUGVuZGluZ1Byb2dyYW1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydFxuICogQHByb3BlcnR5IHtJTlRST3xPVVRST30gYlxuICogQHByb3BlcnR5IHtPdXRyb30gW2dyb3VwXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJvZ3JhbVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGFcbiAqIEBwcm9wZXJ0eSB7SU5UUk98T1VUUk99IGJcbiAqIEBwcm9wZXJ0eSB7MXwtMX0gZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbmRcbiAqIEBwcm9wZXJ0eSB7T3V0cm99IFtncm91cF1cbiAqL1xuIiwiaW1wb3J0IHsgaXNfcHJvbWlzZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgY2hlY2tfb3V0cm9zLCBncm91cF9vdXRyb3MsIHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0IH0gZnJvbSAnLi90cmFuc2l0aW9ucy5qcyc7XG5pbXBvcnQgeyBmbHVzaCB9IGZyb20gJy4vc2NoZWR1bGVyLmpzJztcbmltcG9ydCB7IGdldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1Byb21pc2U8VD59IHByb21pc2VcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Qcm9taXNlSW5mbzxUPn0gaW5mb1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVfcHJvbWlzZShwcm9taXNlLCBpbmZvKSB7XG5cdGNvbnN0IHRva2VuID0gKGluZm8udG9rZW4gPSB7fSk7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuRnJhZ21lbnRGYWN0b3J5fSB0eXBlXG5cdCAqIEBwYXJhbSB7MCB8IDEgfCAyfSBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2tleV1cblx0ICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGUodHlwZSwgaW5kZXgsIGtleSwgdmFsdWUpIHtcblx0XHRpZiAoaW5mby50b2tlbiAhPT0gdG9rZW4pIHJldHVybjtcblx0XHRpbmZvLnJlc29sdmVkID0gdmFsdWU7XG5cdFx0bGV0IGNoaWxkX2N0eCA9IGluZm8uY3R4O1xuXHRcdGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2hpbGRfY3R4ID0gY2hpbGRfY3R4LnNsaWNlKCk7XG5cdFx0XHRjaGlsZF9jdHhba2V5XSA9IHZhbHVlO1xuXHRcdH1cblx0XHRjb25zdCBibG9jayA9IHR5cGUgJiYgKGluZm8uY3VycmVudCA9IHR5cGUpKGNoaWxkX2N0eCk7XG5cdFx0bGV0IG5lZWRzX2ZsdXNoID0gZmFsc2U7XG5cdFx0aWYgKGluZm8uYmxvY2spIHtcblx0XHRcdGlmIChpbmZvLmJsb2Nrcykge1xuXHRcdFx0XHRpbmZvLmJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuXHRcdFx0XHRcdGlmIChpICE9PSBpbmRleCAmJiBibG9jaykge1xuXHRcdFx0XHRcdFx0Z3JvdXBfb3V0cm9zKCk7XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5mby5ibG9ja3NbaV0gPT09IGJsb2NrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5mby5ibG9ja3NbaV0gPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGNoZWNrX291dHJvcygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbmZvLmJsb2NrLmQoMSk7XG5cdFx0XHR9XG5cdFx0XHRibG9jay5jKCk7XG5cdFx0XHR0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcblx0XHRcdGJsb2NrLm0oaW5mby5tb3VudCgpLCBpbmZvLmFuY2hvcik7XG5cdFx0XHRuZWVkc19mbHVzaCA9IHRydWU7XG5cdFx0fVxuXHRcdGluZm8uYmxvY2sgPSBibG9jaztcblx0XHRpZiAoaW5mby5ibG9ja3MpIGluZm8uYmxvY2tzW2luZGV4XSA9IGJsb2NrO1xuXHRcdGlmIChuZWVkc19mbHVzaCkge1xuXHRcdFx0Zmx1c2goKTtcblx0XHR9XG5cdH1cblx0aWYgKGlzX3Byb21pc2UocHJvbWlzZSkpIHtcblx0XHRjb25zdCBjdXJyZW50X2NvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuXHRcdHByb21pc2UudGhlbihcblx0XHRcdCh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuXHRcdFx0XHR1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCB2YWx1ZSk7XG5cdFx0XHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcblx0XHRcdH0sXG5cdFx0XHQoZXJyb3IpID0+IHtcblx0XHRcdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcblx0XHRcdFx0dXBkYXRlKGluZm8uY2F0Y2gsIDIsIGluZm8uZXJyb3IsIGVycm9yKTtcblx0XHRcdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuXHRcdFx0XHRpZiAoIWluZm8uaGFzQ2F0Y2gpIHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cdFx0Ly8gaWYgd2UgcHJldmlvdXNseSBoYWQgYSB0aGVuL2NhdGNoIGJsb2NrLCBkZXN0cm95IGl0XG5cdFx0aWYgKGluZm8uY3VycmVudCAhPT0gaW5mby5wZW5kaW5nKSB7XG5cdFx0XHR1cGRhdGUoaW5mby5wZW5kaW5nLCAwKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnRoZW4pIHtcblx0XHRcdHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHByb21pc2UpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGluZm8ucmVzb2x2ZWQgPSAvKiogQHR5cGUge1R9ICovIChwcm9taXNlKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaChpbmZvLCBjdHgsIGRpcnR5KSB7XG5cdGNvbnN0IGNoaWxkX2N0eCA9IGN0eC5zbGljZSgpO1xuXHRjb25zdCB7IHJlc29sdmVkIH0gPSBpbmZvO1xuXHRpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLnRoZW4pIHtcblx0XHRjaGlsZF9jdHhbaW5mby52YWx1ZV0gPSByZXNvbHZlZDtcblx0fVxuXHRpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLmNhdGNoKSB7XG5cdFx0Y2hpbGRfY3R4W2luZm8uZXJyb3JdID0gcmVzb2x2ZWQ7XG5cdH1cblx0aW5mby5ibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xufVxuIiwiaW1wb3J0IHsgdHJhbnNpdGlvbl9pbiwgdHJhbnNpdGlvbl9vdXQgfSBmcm9tICcuL3RyYW5zaXRpb25zLmpzJztcbmltcG9ydCB7IHJ1bl9hbGwgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLy8gZ2VuZXJhbCBlYWNoIGZ1bmN0aW9uczpcblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZV9hcnJheV9saWtlKGFycmF5X2xpa2Vfb3JfaXRlcmF0b3IpIHtcblx0cmV0dXJuIGFycmF5X2xpa2Vfb3JfaXRlcmF0b3I/Lmxlbmd0aCAhPT0gdW5kZWZpbmVkXG5cdFx0PyBhcnJheV9saWtlX29yX2l0ZXJhdG9yXG5cdFx0OiBBcnJheS5mcm9tKGFycmF5X2xpa2Vfb3JfaXRlcmF0b3IpO1xufVxuXG4vLyBrZXllZCBlYWNoIGZ1bmN0aW9uczpcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHRibG9jay5kKDEpO1xuXHRsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG5cdFx0bG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xuXHR9KTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpeF9hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdGJsb2NrLmYoKTtcblx0ZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHRibG9jay5mKCk7XG5cdG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuXG4vKiogQHJldHVybnMge2FueVtdfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9rZXllZF9lYWNoKFxuXHRvbGRfYmxvY2tzLFxuXHRkaXJ0eSxcblx0Z2V0X2tleSxcblx0ZHluYW1pYyxcblx0Y3R4LFxuXHRsaXN0LFxuXHRsb29rdXAsXG5cdG5vZGUsXG5cdGRlc3Ryb3ksXG5cdGNyZWF0ZV9lYWNoX2Jsb2NrLFxuXHRuZXh0LFxuXHRnZXRfY29udGV4dFxuKSB7XG5cdGxldCBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG5cdGxldCBuID0gbGlzdC5sZW5ndGg7XG5cdGxldCBpID0gbztcblx0Y29uc3Qgb2xkX2luZGV4ZXMgPSB7fTtcblx0d2hpbGUgKGktLSkgb2xkX2luZGV4ZXNbb2xkX2Jsb2Nrc1tpXS5rZXldID0gaTtcblx0Y29uc3QgbmV3X2Jsb2NrcyA9IFtdO1xuXHRjb25zdCBuZXdfbG9va3VwID0gbmV3IE1hcCgpO1xuXHRjb25zdCBkZWx0YXMgPSBuZXcgTWFwKCk7XG5cdGNvbnN0IHVwZGF0ZXMgPSBbXTtcblx0aSA9IG47XG5cdHdoaWxlIChpLS0pIHtcblx0XHRjb25zdCBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuXHRcdGNvbnN0IGtleSA9IGdldF9rZXkoY2hpbGRfY3R4KTtcblx0XHRsZXQgYmxvY2sgPSBsb29rdXAuZ2V0KGtleSk7XG5cdFx0aWYgKCFibG9jaykge1xuXHRcdFx0YmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG5cdFx0XHRibG9jay5jKCk7XG5cdFx0fSBlbHNlIGlmIChkeW5hbWljKSB7XG5cdFx0XHQvLyBkZWZlciB1cGRhdGVzIHVudGlsIGFsbCB0aGUgRE9NIHNodWZmbGluZyBpcyBkb25lXG5cdFx0XHR1cGRhdGVzLnB1c2goKCkgPT4gYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KSk7XG5cdFx0fVxuXHRcdG5ld19sb29rdXAuc2V0KGtleSwgKG5ld19ibG9ja3NbaV0gPSBibG9jaykpO1xuXHRcdGlmIChrZXkgaW4gb2xkX2luZGV4ZXMpIGRlbHRhcy5zZXQoa2V5LCBNYXRoLmFicyhpIC0gb2xkX2luZGV4ZXNba2V5XSkpO1xuXHR9XG5cdGNvbnN0IHdpbGxfbW92ZSA9IG5ldyBTZXQoKTtcblx0Y29uc3QgZGlkX21vdmUgPSBuZXcgU2V0KCk7XG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gaW5zZXJ0KGJsb2NrKSB7XG5cdFx0dHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG5cdFx0YmxvY2subShub2RlLCBuZXh0KTtcblx0XHRsb29rdXAuc2V0KGJsb2NrLmtleSwgYmxvY2spO1xuXHRcdG5leHQgPSBibG9jay5maXJzdDtcblx0XHRuLS07XG5cdH1cblx0d2hpbGUgKG8gJiYgbikge1xuXHRcdGNvbnN0IG5ld19ibG9jayA9IG5ld19ibG9ja3NbbiAtIDFdO1xuXHRcdGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuXHRcdGNvbnN0IG5ld19rZXkgPSBuZXdfYmxvY2sua2V5O1xuXHRcdGNvbnN0IG9sZF9rZXkgPSBvbGRfYmxvY2sua2V5O1xuXHRcdGlmIChuZXdfYmxvY2sgPT09IG9sZF9ibG9jaykge1xuXHRcdFx0Ly8gZG8gbm90aGluZ1xuXHRcdFx0bmV4dCA9IG5ld19ibG9jay5maXJzdDtcblx0XHRcdG8tLTtcblx0XHRcdG4tLTtcblx0XHR9IGVsc2UgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfa2V5KSkge1xuXHRcdFx0Ly8gcmVtb3ZlIG9sZCBibG9ja1xuXHRcdFx0ZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG5cdFx0XHRvLS07XG5cdFx0fSBlbHNlIGlmICghbG9va3VwLmhhcyhuZXdfa2V5KSB8fCB3aWxsX21vdmUuaGFzKG5ld19rZXkpKSB7XG5cdFx0XHRpbnNlcnQobmV3X2Jsb2NrKTtcblx0XHR9IGVsc2UgaWYgKGRpZF9tb3ZlLmhhcyhvbGRfa2V5KSkge1xuXHRcdFx0by0tO1xuXHRcdH0gZWxzZSBpZiAoZGVsdGFzLmdldChuZXdfa2V5KSA+IGRlbHRhcy5nZXQob2xkX2tleSkpIHtcblx0XHRcdGRpZF9tb3ZlLmFkZChuZXdfa2V5KTtcblx0XHRcdGluc2VydChuZXdfYmxvY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aWxsX21vdmUuYWRkKG9sZF9rZXkpO1xuXHRcdFx0by0tO1xuXHRcdH1cblx0fVxuXHR3aGlsZSAoby0tKSB7XG5cdFx0Y29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvXTtcblx0XHRpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9ibG9jay5rZXkpKSBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcblx0fVxuXHR3aGlsZSAobikgaW5zZXJ0KG5ld19ibG9ja3NbbiAtIDFdKTtcblx0cnVuX2FsbCh1cGRhdGVzKTtcblx0cmV0dXJuIG5ld19ibG9ja3M7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY3R4LCBsaXN0LCBnZXRfY29udGV4dCwgZ2V0X2tleSkge1xuXHRjb25zdCBrZXlzID0gbmV3IE1hcCgpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBrZXkgPSBnZXRfa2V5KGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSkpO1xuXHRcdGlmIChrZXlzLmhhcyhrZXkpKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSAnJztcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhbHVlID0gYHdpdGggdmFsdWUgJyR7U3RyaW5nKGtleSl9JyBgO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBjYW4ndCBzdHJpbmdpZnlcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0YENhbm5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzIGluIGEga2V5ZWQgZWFjaDogS2V5cyBhdCBpbmRleCAke2tleXMuZ2V0KFxuXHRcdFx0XHRcdGtleVxuXHRcdFx0XHQpfSBhbmQgJHtpfSAke3ZhbHVlfWFyZSBkdXBsaWNhdGVzYFxuXHRcdFx0KTtcblx0XHR9XG5cdFx0a2V5cy5zZXQoa2V5LCBpKTtcblx0fVxufVxuIiwiY29uc3QgX2Jvb2xlYW5fYXR0cmlidXRlcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCdhbGxvd2Z1bGxzY3JlZW4nLFxuXHQnYWxsb3dwYXltZW50cmVxdWVzdCcsXG5cdCdhc3luYycsXG5cdCdhdXRvZm9jdXMnLFxuXHQnYXV0b3BsYXknLFxuXHQnY2hlY2tlZCcsXG5cdCdjb250cm9scycsXG5cdCdkZWZhdWx0Jyxcblx0J2RlZmVyJyxcblx0J2Rpc2FibGVkJyxcblx0J2Zvcm1ub3ZhbGlkYXRlJyxcblx0J2hpZGRlbicsXG5cdCdpbmVydCcsXG5cdCdpc21hcCcsXG5cdCdsb29wJyxcblx0J211bHRpcGxlJyxcblx0J211dGVkJyxcblx0J25vbW9kdWxlJyxcblx0J25vdmFsaWRhdGUnLFxuXHQnb3BlbicsXG5cdCdwbGF5c2lubGluZScsXG5cdCdyZWFkb25seScsXG5cdCdyZXF1aXJlZCcsXG5cdCdyZXZlcnNlZCcsXG5cdCdzZWxlY3RlZCdcbl0pO1xuXG4vKipcbiAqIExpc3Qgb2YgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMgKGUuZy4gYDxpbnB1dCBkaXNhYmxlZD5gKS5cbiAqIFNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG4gKlxuICogQHR5cGUge1NldDxzdHJpbmc+fVxuICovXG5leHBvcnQgY29uc3QgYm9vbGVhbl9hdHRyaWJ1dGVzID0gbmV3IFNldChbLi4uX2Jvb2xlYW5fYXR0cmlidXRlc10pO1xuXG4vKiogQHR5cGVkZWYge3R5cGVvZiBfYm9vbGVhbl9hdHRyaWJ1dGVzW251bWJlcl19IEJvb2xlYW5BdHRyaWJ1dGVzICovXG4iLCJpbXBvcnQgeyBzZXRfY3VycmVudF9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgcnVuX2FsbCwgYmxhbmtfb2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBib29sZWFuX2F0dHJpYnV0ZXMgfSBmcm9tICcuLi8uLi9zaGFyZWQvYm9vbGVhbl9hdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IGVuc3VyZV9hcnJheV9saWtlIH0gZnJvbSAnLi9lYWNoLmpzJztcbmV4cG9ydCB7IGlzX3ZvaWQgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMvbmFtZXMuanMnO1xuXG5leHBvcnQgY29uc3QgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIgPVxuXHQvW1xccydcIj4vPVxcdXtGREQwfS1cXHV7RkRFRn1cXHV7RkZGRX1cXHV7RkZGRn1cXHV7MUZGRkV9XFx1ezFGRkZGfVxcdXsyRkZGRX1cXHV7MkZGRkZ9XFx1ezNGRkZFfVxcdXszRkZGRn1cXHV7NEZGRkV9XFx1ezRGRkZGfVxcdXs1RkZGRX1cXHV7NUZGRkZ9XFx1ezZGRkZFfVxcdXs2RkZGRn1cXHV7N0ZGRkV9XFx1ezdGRkZGfVxcdXs4RkZGRX1cXHV7OEZGRkZ9XFx1ezlGRkZFfVxcdXs5RkZGRn1cXHV7QUZGRkV9XFx1e0FGRkZGfVxcdXtCRkZGRX1cXHV7QkZGRkZ9XFx1e0NGRkZFfVxcdXtDRkZGRn1cXHV7REZGRkV9XFx1e0RGRkZGfVxcdXtFRkZGRX1cXHV7RUZGRkZ9XFx1e0ZGRkZFfVxcdXtGRkZGRn1cXHV7MTBGRkZFfVxcdXsxMEZGRkZ9XS91O1xuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jbm9uY2hhcmFjdGVyXG5cbi8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwcmVhZChhcmdzLCBhdHRyc190b19hZGQpIHtcblx0Y29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmFyZ3MpO1xuXHRpZiAoYXR0cnNfdG9fYWRkKSB7XG5cdFx0Y29uc3QgY2xhc3Nlc190b19hZGQgPSBhdHRyc190b19hZGQuY2xhc3Nlcztcblx0XHRjb25zdCBzdHlsZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLnN0eWxlcztcblx0XHRpZiAoY2xhc3Nlc190b19hZGQpIHtcblx0XHRcdGlmIChhdHRyaWJ1dGVzLmNsYXNzID09IG51bGwpIHtcblx0XHRcdFx0YXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzZXNfdG9fYWRkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cmlidXRlcy5jbGFzcyArPSAnICcgKyBjbGFzc2VzX3RvX2FkZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHN0eWxlc190b19hZGQpIHtcblx0XHRcdGlmIChhdHRyaWJ1dGVzLnN0eWxlID09IG51bGwpIHtcblx0XHRcdFx0YXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVzX3RvX2FkZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhcblx0XHRcdFx0XHRtZXJnZV9zc3Jfc3R5bGVzKGF0dHJpYnV0ZXMuc3R5bGUsIHN0eWxlc190b19hZGQpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGxldCBzdHIgPSAnJztcblx0T2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdGlmIChpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3Rlci50ZXN0KG5hbWUpKSByZXR1cm47XG5cdFx0Y29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gdHJ1ZSkgc3RyICs9ICcgJyArIG5hbWU7XG5cdFx0ZWxzZSBpZiAoYm9vbGVhbl9hdHRyaWJ1dGVzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG5cdFx0XHRpZiAodmFsdWUpIHN0ciArPSAnICcgKyBuYW1lO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0c3RyICs9IGAgJHtuYW1lfT1cIiR7dmFsdWV9XCJgO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBzdHI7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2Vfc3NyX3N0eWxlcyhzdHlsZV9hdHRyaWJ1dGUsIHN0eWxlX2RpcmVjdGl2ZSkge1xuXHRjb25zdCBzdHlsZV9vYmplY3QgPSB7fTtcblx0Zm9yIChjb25zdCBpbmRpdmlkdWFsX3N0eWxlIG9mIHN0eWxlX2F0dHJpYnV0ZS5zcGxpdCgnOycpKSB7XG5cdFx0Y29uc3QgY29sb25faW5kZXggPSBpbmRpdmlkdWFsX3N0eWxlLmluZGV4T2YoJzonKTtcblx0XHRjb25zdCBuYW1lID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZSgwLCBjb2xvbl9pbmRleCkudHJpbSgpO1xuXHRcdGNvbnN0IHZhbHVlID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZShjb2xvbl9pbmRleCArIDEpLnRyaW0oKTtcblx0XHRpZiAoIW5hbWUpIGNvbnRpbnVlO1xuXHRcdHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuXHR9XG5cdGZvciAoY29uc3QgbmFtZSBpbiBzdHlsZV9kaXJlY3RpdmUpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHN0eWxlX2RpcmVjdGl2ZVtuYW1lXTtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgc3R5bGVfb2JqZWN0W25hbWVdO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3R5bGVfb2JqZWN0O1xufVxuXG5jb25zdCBBVFRSX1JFR0VYID0gL1smXCJdL2c7XG5jb25zdCBDT05URU5UX1JFR0VYID0gL1smPF0vZztcblxuLyoqXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBwZXJmb3JtYW5jZSBzZW5zaXRpdmUgYW5kIGhhcyBiZWVuIG9wdGltaXplZFxuICogaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzU3MDFcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGUodmFsdWUsIGlzX2F0dHIgPSBmYWxzZSkge1xuXHRjb25zdCBzdHIgPSBTdHJpbmcodmFsdWUpO1xuXHRjb25zdCBwYXR0ZXJuID0gaXNfYXR0ciA/IEFUVFJfUkVHRVggOiBDT05URU5UX1JFR0VYO1xuXHRwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG5cdGxldCBlc2NhcGVkID0gJyc7XG5cdGxldCBsYXN0ID0gMDtcblx0d2hpbGUgKHBhdHRlcm4udGVzdChzdHIpKSB7XG5cdFx0Y29uc3QgaSA9IHBhdHRlcm4ubGFzdEluZGV4IC0gMTtcblx0XHRjb25zdCBjaCA9IHN0cltpXTtcblx0XHRlc2NhcGVkICs9IHN0ci5zdWJzdHJpbmcobGFzdCwgaSkgKyAoY2ggPT09ICcmJyA/ICcmYW1wOycgOiBjaCA9PT0gJ1wiJyA/ICcmcXVvdDsnIDogJyZsdDsnKTtcblx0XHRsYXN0ID0gaSArIDE7XG5cdH1cblx0cmV0dXJuIGVzY2FwZWQgKyBzdHIuc3Vic3RyaW5nKGxhc3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZSh2YWx1ZSkge1xuXHQvLyBrZWVwIGJvb2xlYW5zLCBudWxsLCBhbmQgdW5kZWZpbmVkIGZvciB0aGUgc2FrZSBvZiBgc3ByZWFkYFxuXHRjb25zdCBzaG91bGRfZXNjYXBlID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jyk7XG5cdHJldHVybiBzaG91bGRfZXNjYXBlID8gZXNjYXBlKHZhbHVlLCB0cnVlKSA6IHZhbHVlO1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZV9vYmplY3Qob2JqKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcblx0XHRyZXN1bHRba2V5XSA9IGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUob2JqW2tleV0pO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2goaXRlbXMsIGZuKSB7XG5cdGl0ZW1zID0gZW5zdXJlX2FycmF5X2xpa2UoaXRlbXMpO1xuXHRsZXQgc3RyID0gJyc7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRzdHIgKz0gZm4oaXRlbXNbaV0sIGkpO1xuXHR9XG5cdHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCBjb25zdCBtaXNzaW5nX2NvbXBvbmVudCA9IHtcblx0JCRyZW5kZXI6ICgpID0+ICcnXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfY29tcG9uZW50KGNvbXBvbmVudCwgbmFtZSkge1xuXHRpZiAoIWNvbXBvbmVudCB8fCAhY29tcG9uZW50LiQkcmVuZGVyKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdzdmVsdGU6Y29tcG9uZW50JykgbmFtZSArPSAnIHRoaXM9ey4uLn0nO1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGA8JHtuYW1lfT4gaXMgbm90IGEgdmFsaWQgU1NSIGNvbXBvbmVudC4gWW91IG1heSBuZWVkIHRvIHJldmlldyB5b3VyIGJ1aWxkIGNvbmZpZyB0byBlbnN1cmUgdGhhdCBkZXBlbmRlbmNpZXMgYXJlIGNvbXBpbGVkLCByYXRoZXIgdGhhbiBpbXBvcnRlZCBhcyBwcmUtY29tcGlsZWQgbW9kdWxlcy4gT3RoZXJ3aXNlIHlvdSBtYXkgbmVlZCB0byBmaXggYSA8JHtuYW1lfT4uYFxuXHRcdCk7XG5cdH1cblx0cmV0dXJuIGNvbXBvbmVudDtcbn1cblxuLyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVidWcoZmlsZSwgbGluZSwgY29sdW1uLCB2YWx1ZXMpIHtcblx0Y29uc29sZS5sb2coYHtAZGVidWd9ICR7ZmlsZSA/IGZpbGUgKyAnICcgOiAnJ30oJHtsaW5lfToke2NvbHVtbn0pYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXHRjb25zb2xlLmxvZyh2YWx1ZXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0cmV0dXJuICcnO1xufVxuXG5sZXQgb25fZGVzdHJveTtcblxuLyoqIEByZXR1cm5zIHt7IHJlbmRlcjogKHByb3BzPzoge30sIHsgJCRzbG90cywgY29udGV4dCB9PzogeyAkJHNsb3RzPzoge307IGNvbnRleHQ/OiBNYXA8YW55LCBhbnk+OyB9KSA9PiB7IGh0bWw6IGFueTsgY3NzOiB7IGNvZGU6IHN0cmluZzsgbWFwOiBhbnk7IH07IGhlYWQ6IHN0cmluZzsgfTsgJCRyZW5kZXI6IChyZXN1bHQ6IGFueSwgcHJvcHM6IGFueSwgYmluZGluZ3M6IGFueSwgc2xvdHM6IGFueSwgY29udGV4dDogYW55KSA9PiBhbnk7IH19ICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3Nzcl9jb21wb25lbnQoZm4pIHtcblx0ZnVuY3Rpb24gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzLCBjb250ZXh0KSB7XG5cdFx0Y29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuXHRcdGNvbnN0ICQkID0ge1xuXHRcdFx0b25fZGVzdHJveSxcblx0XHRcdGNvbnRleHQ6IG5ldyBNYXAoY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG5cdFx0XHQvLyB0aGVzZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGRpc2NhcmRlZFxuXHRcdFx0b25fbW91bnQ6IFtdLFxuXHRcdFx0YmVmb3JlX3VwZGF0ZTogW10sXG5cdFx0XHRhZnRlcl91cGRhdGU6IFtdLFxuXHRcdFx0Y2FsbGJhY2tzOiBibGFua19vYmplY3QoKVxuXHRcdH07XG5cdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KHsgJCQgfSk7XG5cdFx0Y29uc3QgaHRtbCA9IGZuKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cyk7XG5cdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xuXHRcdHJldHVybiBodG1sO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0cmVuZGVyOiAocHJvcHMgPSB7fSwgeyAkJHNsb3RzID0ge30sIGNvbnRleHQgPSBuZXcgTWFwKCkgfSA9IHt9KSA9PiB7XG5cdFx0XHRvbl9kZXN0cm95ID0gW107XG5cdFx0XHRjb25zdCByZXN1bHQgPSB7IHRpdGxlOiAnJywgaGVhZDogJycsIGNzczogbmV3IFNldCgpIH07XG5cdFx0XHRjb25zdCBodG1sID0gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywge30sICQkc2xvdHMsIGNvbnRleHQpO1xuXHRcdFx0cnVuX2FsbChvbl9kZXN0cm95KTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGh0bWwsXG5cdFx0XHRcdGNzczoge1xuXHRcdFx0XHRcdGNvZGU6IEFycmF5LmZyb20ocmVzdWx0LmNzcylcblx0XHRcdFx0XHRcdC5tYXAoKGNzcykgPT4gY3NzLmNvZGUpXG5cdFx0XHRcdFx0XHQuam9pbignXFxuJyksXG5cdFx0XHRcdFx0bWFwOiBudWxsIC8vIFRPRE9cblx0XHRcdFx0fSxcblx0XHRcdFx0aGVhZDogcmVzdWx0LnRpdGxlICsgcmVzdWx0LmhlYWRcblx0XHRcdH07XG5cdFx0fSxcblx0XHQkJHJlbmRlclxuXHR9O1xufVxuXG4vKiogQHJldHVybnMge3N0cmluZ30gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfYXR0cmlidXRlKG5hbWUsIHZhbHVlLCBib29sZWFuKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsIHx8IChib29sZWFuICYmICF2YWx1ZSkpIHJldHVybiAnJztcblx0Y29uc3QgYXNzaWdubWVudCA9IGJvb2xlYW4gJiYgdmFsdWUgPT09IHRydWUgPyAnJyA6IGA9XCIke2VzY2FwZSh2YWx1ZSwgdHJ1ZSl9XCJgO1xuXHRyZXR1cm4gYCAke25hbWV9JHthc3NpZ25tZW50fWA7XG59XG5cbi8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9jbGFzc2VzKGNsYXNzZXMpIHtcblx0cmV0dXJuIGNsYXNzZXMgPyBgIGNsYXNzPVwiJHtjbGFzc2VzfVwiYCA6ICcnO1xufVxuXG4vKiogQHJldHVybnMge3N0cmluZ30gKi9cbmZ1bmN0aW9uIHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhzdHlsZV9vYmplY3QpXG5cdFx0LmZpbHRlcigoa2V5KSA9PiBzdHlsZV9vYmplY3Rba2V5XSlcblx0XHQubWFwKChrZXkpID0+IGAke2tleX06ICR7ZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShzdHlsZV9vYmplY3Rba2V5XSl9O2ApXG5cdFx0LmpvaW4oJyAnKTtcbn1cblxuLyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX3N0eWxlcyhzdHlsZV9vYmplY3QpIHtcblx0Y29uc3Qgc3R5bGVzID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZV9vYmplY3QpO1xuXHRyZXR1cm4gc3R5bGVzID8gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYCA6ICcnO1xufVxuIiwiaW1wb3J0IHtcblx0YWRkX3JlbmRlcl9jYWxsYmFjayxcblx0Zmx1c2gsXG5cdGZsdXNoX3JlbmRlcl9jYWxsYmFja3MsXG5cdHNjaGVkdWxlX3VwZGF0ZSxcblx0ZGlydHlfY29tcG9uZW50c1xufSBmcm9tICcuL3NjaGVkdWxlci5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgYmxhbmtfb2JqZWN0LCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIHJ1biwgcnVuX2FsbCwgbm9vcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0Y2hpbGRyZW4sXG5cdGRldGFjaCxcblx0c3RhcnRfaHlkcmF0aW5nLFxuXHRlbmRfaHlkcmF0aW5nLFxuXHRnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzLFxuXHRpbnNlcnRcbn0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgdHJhbnNpdGlvbl9pbiB9IGZyb20gJy4vdHJhbnNpdGlvbnMuanMnO1xuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYmluZChjb21wb25lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG5cdGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuXHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcblx0XHRjYWxsYmFjayhjb21wb25lbnQuJCQuY3R4W2luZGV4XSk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcblx0YmxvY2sgJiYgYmxvY2suYygpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fY29tcG9uZW50KGJsb2NrLCBwYXJlbnRfbm9kZXMpIHtcblx0YmxvY2sgJiYgYmxvY2subChwYXJlbnRfbm9kZXMpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgdGFyZ2V0LCBhbmNob3IpIHtcblx0Y29uc3QgeyBmcmFnbWVudCwgYWZ0ZXJfdXBkYXRlIH0gPSBjb21wb25lbnQuJCQ7XG5cdGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuXHQvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG5cdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuXHRcdGNvbnN0IG5ld19vbl9kZXN0cm95ID0gY29tcG9uZW50LiQkLm9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG5cdFx0Ly8gaWYgdGhlIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gaXQgd2lsbCB1cGRhdGUgdGhlIGAkJC5vbl9kZXN0cm95YCByZWZlcmVuY2UgdG8gYG51bGxgLlxuXHRcdC8vIHRoZSBkZXN0cnVjdHVyZWQgb25fZGVzdHJveSBtYXkgc3RpbGwgcmVmZXJlbmNlIHRvIHRoZSBvbGQgYXJyYXlcblx0XHRpZiAoY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kpIHtcblx0XHRcdGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcblx0XHRcdC8vIG1vc3QgbGlrZWx5IGFzIGEgcmVzdWx0IG9mIGEgYmluZGluZyBpbml0aWFsaXNpbmdcblx0XHRcdHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuXHRcdH1cblx0XHRjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcblx0fSk7XG5cdGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcblx0Y29uc3QgJCQgPSBjb21wb25lbnQuJCQ7XG5cdGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuXHRcdGZsdXNoX3JlbmRlcl9jYWxsYmFja3MoJCQuYWZ0ZXJfdXBkYXRlKTtcblx0XHRydW5fYWxsKCQkLm9uX2Rlc3Ryb3kpO1xuXHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcblx0XHQvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG5cdFx0Ly8gcHJlc2VydmUgZmluYWwgc3RhdGU/KVxuXHRcdCQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG5cdFx0JCQuY3R4ID0gW107XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcblx0aWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcblx0XHRkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcblx0XHRzY2hlZHVsZV91cGRhdGUoKTtcblx0XHRjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcblx0fVxuXHRjb21wb25lbnQuJCQuZGlydHlbKGkgLyAzMSkgfCAwXSB8PSAxIDw8IGkgJSAzMTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQoXG5cdGNvbXBvbmVudCxcblx0b3B0aW9ucyxcblx0aW5zdGFuY2UsXG5cdGNyZWF0ZV9mcmFnbWVudCxcblx0bm90X2VxdWFsLFxuXHRwcm9wcyxcblx0YXBwZW5kX3N0eWxlcyxcblx0ZGlydHkgPSBbLTFdXG4pIHtcblx0Y29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuXHRzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlQkJH0gKi9cblx0Y29uc3QgJCQgPSAoY29tcG9uZW50LiQkID0ge1xuXHRcdGZyYWdtZW50OiBudWxsLFxuXHRcdGN0eDogW10sXG5cdFx0Ly8gc3RhdGVcblx0XHRwcm9wcyxcblx0XHR1cGRhdGU6IG5vb3AsXG5cdFx0bm90X2VxdWFsLFxuXHRcdGJvdW5kOiBibGFua19vYmplY3QoKSxcblx0XHQvLyBsaWZlY3ljbGVcblx0XHRvbl9tb3VudDogW10sXG5cdFx0b25fZGVzdHJveTogW10sXG5cdFx0b25fZGlzY29ubmVjdDogW10sXG5cdFx0YmVmb3JlX3VwZGF0ZTogW10sXG5cdFx0YWZ0ZXJfdXBkYXRlOiBbXSxcblx0XHRjb250ZXh0OiBuZXcgTWFwKG9wdGlvbnMuY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG5cdFx0Ly8gZXZlcnl0aGluZyBlbHNlXG5cdFx0Y2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcblx0XHRkaXJ0eSxcblx0XHRza2lwX2JvdW5kOiBmYWxzZSxcblx0XHRyb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3Rcblx0fSk7XG5cdGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcblx0bGV0IHJlYWR5ID0gZmFsc2U7XG5cdCQkLmN0eCA9IGluc3RhbmNlXG5cdFx0PyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG5cdFx0XHRcdGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgKCQkLmN0eFtpXSA9IHZhbHVlKSkpIHtcblx0XHRcdFx0XHRpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pICQkLmJvdW5kW2ldKHZhbHVlKTtcblx0XHRcdFx0XHRpZiAocmVhZHkpIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdCAgfSlcblx0XHQ6IFtdO1xuXHQkJC51cGRhdGUoKTtcblx0cmVhZHkgPSB0cnVlO1xuXHRydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuXHQvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcblx0JCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuXHRpZiAob3B0aW9ucy50YXJnZXQpIHtcblx0XHRpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG5cdFx0XHRzdGFydF9oeWRyYXRpbmcoKTtcblx0XHRcdGNvbnN0IG5vZGVzID0gY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpO1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cblx0XHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuXHRcdFx0bm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuXHRcdFx0JCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbnRybykgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuXHRcdG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMudGFyZ2V0LCBvcHRpb25zLmFuY2hvcik7XG5cdFx0ZW5kX2h5ZHJhdGluZygpO1xuXHRcdGZsdXNoKCk7XG5cdH1cblx0c2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxuXG5leHBvcnQgbGV0IFN2ZWx0ZUVsZW1lbnQ7XG5cbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcblx0U3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXHRcdCQkY29tcG9uZW50Q3Rvcjtcblx0XHQkJHNsb3RzO1xuXHRcdCQkY29tcG9uZW50O1xuXHRcdCQkY29ubmVjdGVkID0gZmFsc2U7XG5cdFx0JCRkYXRhID0ge307XG5cdFx0JCRyZWZsZWN0aW5nID0gZmFsc2U7XG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSAqL1xuXHRcdCQkcHJvcHNfZGVmaW5pdGlvbiA9IHt9O1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgRnVuY3Rpb25bXT59ICovXG5cdFx0JCRsaXN0ZW5lcnMgPSB7fTtcblx0XHQvKiogQHR5cGUge01hcDxGdW5jdGlvbiwgRnVuY3Rpb24+fSAqL1xuXHRcdCQkbGlzdGVuZXJfdW5zdWJzY3JpYmVfZm5zID0gbmV3IE1hcCgpO1xuXG5cdFx0Y29uc3RydWN0b3IoJCRjb21wb25lbnRDdG9yLCAkJHNsb3RzLCB1c2Vfc2hhZG93X2RvbSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMuJCRjb21wb25lbnRDdG9yID0gJCRjb21wb25lbnRDdG9yO1xuXHRcdFx0dGhpcy4kJHNsb3RzID0gJCRzbG90cztcblx0XHRcdGlmICh1c2Vfc2hhZG93X2RvbSkge1xuXHRcdFx0XHR0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG5cdFx0XHQvLyBXZSBjYW4ndCBkZXRlcm1pbmUgdXBmcm9udCBpZiB0aGUgZXZlbnQgaXMgYSBjdXN0b20gZXZlbnQgb3Igbm90LCBzbyB3ZSBoYXZlIHRvXG5cdFx0XHQvLyBsaXN0ZW4gdG8gYm90aC4gSWYgc29tZW9uZSB1c2VzIGEgY3VzdG9tIGV2ZW50IHdpdGggdGhlIHNhbWUgbmFtZSBhcyBhIHJlZ3VsYXJcblx0XHRcdC8vIGJyb3dzZXIgZXZlbnQsIHRoaXMgZmlyZXMgdHdpY2UgLSB3ZSBjYW4ndCBhdm9pZCB0aGF0LlxuXHRcdFx0dGhpcy4kJGxpc3RlbmVyc1t0eXBlXSA9IHRoaXMuJCRsaXN0ZW5lcnNbdHlwZV0gfHwgW107XG5cdFx0XHR0aGlzLiQkbGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXHRcdFx0aWYgKHRoaXMuJCRjb21wb25lbnQpIHtcblx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkY29tcG9uZW50LiRvbih0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRcdHRoaXMuJCRsaXN0ZW5lcl91bnN1YnNjcmliZV9mbnMuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHR9XG5cdFx0XHRzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRyZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG5cdFx0XHRzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcblx0XHRcdGlmICh0aGlzLiQkY29tcG9uZW50KSB7XG5cdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGxpc3RlbmVyX3Vuc3Vic2NyaWJlX2Zucy5nZXQobGlzdGVuZXIpO1xuXHRcdFx0XHRpZiAodW5zdWIpIHtcblx0XHRcdFx0XHR1bnN1YigpO1xuXHRcdFx0XHRcdHRoaXMuJCRsaXN0ZW5lcl91bnN1YnNjcmliZV9mbnMuZGVsZXRlKGxpc3RlbmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFzeW5jIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuXHRcdFx0dGhpcy4kJGNvbm5lY3RlZCA9IHRydWU7XG5cdFx0XHRpZiAoIXRoaXMuJCRjb21wb25lbnQpIHtcblx0XHRcdFx0Ly8gV2Ugd2FpdCBvbmUgdGljayB0byBsZXQgcG9zc2libGUgY2hpbGQgc2xvdCBlbGVtZW50cyBiZSBjcmVhdGVkL21vdW50ZWRcblx0XHRcdFx0YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRcdGlmICghdGhpcy4kJGNvbm5lY3RlZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jdGlvbiBjcmVhdGVfc2xvdChuYW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdFx0XHRcdGxldCBub2RlO1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2JqID0ge1xuXHRcdFx0XHRcdFx0XHRjOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Nsb3QnKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAobmFtZSAhPT0gJ2RlZmF1bHQnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnbmFtZScsIG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuXHRcdFx0XHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbYW5jaG9yXVxuXHRcdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdFx0bTogZnVuY3Rpb24gbW91bnQodGFyZ2V0LCBhbmNob3IpIHtcblx0XHRcdFx0XHRcdFx0XHRpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkOiBmdW5jdGlvbiBkZXN0cm95KGRldGFjaGluZykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChkZXRhY2hpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRldGFjaChub2RlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgJCRzbG90cyA9IHt9O1xuXHRcdFx0XHRjb25zdCBleGlzdGluZ19zbG90cyA9IGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHModGhpcyk7XG5cdFx0XHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLiQkc2xvdHMpIHtcblx0XHRcdFx0XHRpZiAobmFtZSBpbiBleGlzdGluZ19zbG90cykge1xuXHRcdFx0XHRcdFx0JCRzbG90c1tuYW1lXSA9IFtjcmVhdGVfc2xvdChuYW1lKV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoY29uc3QgYXR0cmlidXRlIG9mIHRoaXMuYXR0cmlidXRlcykge1xuXHRcdFx0XHRcdC8vIHRoaXMuJCRkYXRhIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzLmF0dHJpYnV0ZXNcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gdGhpcy4kJGdldF9wcm9wX25hbWUoYXR0cmlidXRlLm5hbWUpO1xuXHRcdFx0XHRcdGlmICghKG5hbWUgaW4gdGhpcy4kJGRhdGEpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiQkZGF0YVtuYW1lXSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShcblx0XHRcdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRcdFx0YXR0cmlidXRlLnZhbHVlLFxuXHRcdFx0XHRcdFx0XHR0aGlzLiQkcHJvcHNfZGVmaW5pdGlvbixcblx0XHRcdFx0XHRcdFx0J3RvUHJvcCdcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJCRjb21wb25lbnQgPSBuZXcgdGhpcy4kJGNvbXBvbmVudEN0b3Ioe1xuXHRcdFx0XHRcdHRhcmdldDogdGhpcy5zaGFkb3dSb290IHx8IHRoaXMsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdC4uLnRoaXMuJCRkYXRhLFxuXHRcdFx0XHRcdFx0JCRzbG90cyxcblx0XHRcdFx0XHRcdCQkc2NvcGU6IHtcblx0XHRcdFx0XHRcdFx0Y3R4OiBbXVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGZvciAoY29uc3QgdHlwZSBpbiB0aGlzLiQkbGlzdGVuZXJzKSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiQkbGlzdGVuZXJzW3R5cGVdKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB1bnN1YiA9IHRoaXMuJCRjb21wb25lbnQuJG9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0XHRcdHRoaXMuJCRsaXN0ZW5lcl91bnN1YnNjcmliZV9mbnMuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJCRsaXN0ZW5lcnMgPSB7fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBXZSBkb24ndCBuZWVkIHRoaXMgd2hlbiB3b3JraW5nIHdpdGhpbiBTdmVsdGUgY29kZSwgYnV0IGZvciBjb21wYXRpYmlsaXR5IG9mIHBlb3BsZSB1c2luZyB0aGlzIG91dHNpZGUgb2YgU3ZlbHRlXG5cdFx0Ly8gYW5kIHNldHRpbmcgYXR0cmlidXRlcyB0aHJvdWdoIHNldEF0dHJpYnV0ZSBldGMsIHRoaXMgaXMgaGVscGZ1bFxuXHRcdGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy4kJHJlZmxlY3RpbmcpIHJldHVybjtcblx0XHRcdGF0dHIgPSB0aGlzLiQkZ2V0X3Byb3BfbmFtZShhdHRyKTtcblx0XHRcdHRoaXMuJCRkYXRhW2F0dHJdID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKFxuXHRcdFx0XHRhdHRyLFxuXHRcdFx0XHRuZXdWYWx1ZSxcblx0XHRcdFx0dGhpcy4kJHByb3BzX2RlZmluaXRpb24sXG5cdFx0XHRcdCd0b1Byb3AnXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy4kJGNvbXBvbmVudD8uJHNldCh7IFthdHRyXTogdGhpcy4kJGRhdGFbYXR0cl0gfSk7XG5cdFx0fVxuXG5cdFx0ZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiQkY29ubmVjdGVkID0gZmFsc2U7XG5cdFx0XHQvLyBJbiBhIG1pY3JvdGFzaywgYmVjYXVzZSB0aGlzIGNvdWxkIGJlIGEgbW92ZSB3aXRoaW4gdGhlIERPTVxuXHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdGlmICghdGhpcy4kJGNvbm5lY3RlZCkge1xuXHRcdFx0XHRcdHRoaXMuJCRjb21wb25lbnQuJGRlc3Ryb3koKTtcblx0XHRcdFx0XHR0aGlzLiQkY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQkJGdldF9wcm9wX25hbWUoYXR0cmlidXRlX25hbWUpIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdE9iamVjdC5rZXlzKHRoaXMuJCRwcm9wc19kZWZpbml0aW9uKS5maW5kKFxuXHRcdFx0XHRcdChrZXkpID0+XG5cdFx0XHRcdFx0XHR0aGlzLiQkcHJvcHNfZGVmaW5pdGlvbltrZXldLmF0dHJpYnV0ZSA9PT0gYXR0cmlidXRlX25hbWUgfHxcblx0XHRcdFx0XHRcdCghdGhpcy4kJHByb3BzX2RlZmluaXRpb25ba2V5XS5hdHRyaWJ1dGUgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09IGF0dHJpYnV0ZV9uYW1lKVxuXHRcdFx0XHQpIHx8IGF0dHJpYnV0ZV9uYW1lXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IHByb3BzX2RlZmluaXRpb25cbiAqIEBwYXJhbSB7J3RvQXR0cmlidXRlJyB8ICd0b1Byb3AnfSBbdHJhbnNmb3JtXVxuICovXG5mdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUocHJvcCwgdmFsdWUsIHByb3BzX2RlZmluaXRpb24sIHRyYW5zZm9ybSkge1xuXHRjb25zdCB0eXBlID0gcHJvcHNfZGVmaW5pdGlvbltwcm9wXT8udHlwZTtcblx0dmFsdWUgPSB0eXBlID09PSAnQm9vbGVhbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicgPyB2YWx1ZSAhPSBudWxsIDogdmFsdWU7XG5cdGlmICghdHJhbnNmb3JtIHx8ICFwcm9wc19kZWZpbml0aW9uW3Byb3BdKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9IGVsc2UgaWYgKHRyYW5zZm9ybSA9PT0gJ3RvQXR0cmlidXRlJykge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnT2JqZWN0Jzpcblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBudWxsIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXHRcdFx0Y2FzZSAnQm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA/ICcnIDogbnVsbDtcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHZhbHVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAmJiBKU09OLnBhcnNlKHZhbHVlKTtcblx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7IC8vIGNvbnZlcnNpb24gYWxyZWFkeSBoYW5kbGVkIGFib3ZlXG5cdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgIT0gbnVsbCA/ICt2YWx1ZSA6IHZhbHVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIFR1cm4gYSBTdmVsdGUgY29tcG9uZW50IGludG8gYSBjdXN0b20gZWxlbWVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLkNvbXBvbmVudFR5cGV9IENvbXBvbmVudCAgQSBTdmVsdGUgY29tcG9uZW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IHByb3BzX2RlZmluaXRpb24gIFRoZSBwcm9wcyB0byBvYnNlcnZlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzbG90cyAgVGhlIHNsb3RzIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gYWNjZXNzb3JzICBPdGhlciBhY2Nlc3NvcnMgYmVzaWRlcyB0aGUgb25lcyBmb3IgcHJvcHMgdGhlIGNvbXBvbmVudCBoYXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlX3NoYWRvd19kb20gIFdoZXRoZXIgdG8gdXNlIHNoYWRvdyBET01cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9jdXN0b21fZWxlbWVudChcblx0Q29tcG9uZW50LFxuXHRwcm9wc19kZWZpbml0aW9uLFxuXHRzbG90cyxcblx0YWNjZXNzb3JzLFxuXHR1c2Vfc2hhZG93X2RvbVxuKSB7XG5cdGNvbnN0IENsYXNzID0gY2xhc3MgZXh0ZW5kcyBTdmVsdGVFbGVtZW50IHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKENvbXBvbmVudCwgc2xvdHMsIHVzZV9zaGFkb3dfZG9tKTtcblx0XHRcdHRoaXMuJCRwcm9wc19kZWZpbml0aW9uID0gcHJvcHNfZGVmaW5pdGlvbjtcblx0XHR9XG5cdFx0c3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMocHJvcHNfZGVmaW5pdGlvbikubWFwKChrZXkpID0+XG5cdFx0XHRcdChwcm9wc19kZWZpbml0aW9uW2tleV0uYXR0cmlidXRlIHx8IGtleSkudG9Mb3dlckNhc2UoKVxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG5cdE9iamVjdC5rZXlzKHByb3BzX2RlZmluaXRpb24pLmZvckVhY2goKHByb3ApID0+IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBwcm9wLCB7XG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiQkY29tcG9uZW50ICYmIHByb3AgaW4gdGhpcy4kJGNvbXBvbmVudFxuXHRcdFx0XHRcdD8gdGhpcy4kJGNvbXBvbmVudFtwcm9wXVxuXHRcdFx0XHRcdDogdGhpcy4kJGRhdGFbcHJvcF07XG5cdFx0XHR9LFxuXHRcdFx0c2V0KHZhbHVlKSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKHByb3AsIHZhbHVlLCBwcm9wc19kZWZpbml0aW9uKTtcblx0XHRcdFx0dGhpcy4kJGRhdGFbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy4kJGNvbXBvbmVudD8uJHNldCh7IFtwcm9wXTogdmFsdWUgfSk7XG5cdFx0XHRcdGlmIChwcm9wc19kZWZpbml0aW9uW3Byb3BdLnJlZmxlY3QpIHtcblx0XHRcdFx0XHR0aGlzLiQkcmVmbGVjdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlX3ZhbHVlID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKFxuXHRcdFx0XHRcdFx0cHJvcCxcblx0XHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdFx0cHJvcHNfZGVmaW5pdGlvbixcblx0XHRcdFx0XHRcdCd0b0F0dHJpYnV0ZSdcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGlmIChhdHRyaWJ1dGVfdmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKHByb3BzX2RlZmluaXRpb25bcHJvcF0uYXR0cmlidXRlIHx8IHByb3AsIGF0dHJpYnV0ZV92YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuJCRyZWZsZWN0aW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdGFjY2Vzc29ycy5mb3JFYWNoKChhY2Nlc3NvcikgPT4ge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIGFjY2Vzc29yLCB7XG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiQkY29tcG9uZW50Py5bYWNjZXNzb3JdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0Q29tcG9uZW50LmVsZW1lbnQgPSAvKiogQHR5cGUge2FueX0gKi8gKENsYXNzKTtcblx0cmV0dXJuIENsYXNzO1xufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICpcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW1Byb3BzPWFueV1cbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50cz1hbnldXG4gKi9cbmV4cG9ydCBjbGFzcyBTdmVsdGVDb21wb25lbnQge1xuXHQvKipcblx0ICogIyMjIFBSSVZBVEUgQVBJXG5cdCAqXG5cdCAqIERvIG5vdCB1c2UsIG1heSBjaGFuZ2UgYXQgYW55IHRpbWVcblx0ICpcblx0ICogQHR5cGUge2FueX1cblx0ICovXG5cdCQkID0gdW5kZWZpbmVkO1xuXHQvKipcblx0ICogIyMjIFBSSVZBVEUgQVBJXG5cdCAqXG5cdCAqIERvIG5vdCB1c2UsIG1heSBjaGFuZ2UgYXQgYW55IHRpbWVcblx0ICpcblx0ICogQHR5cGUge2FueX1cblx0ICovXG5cdCQkc2V0ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0JGRlc3Ryb3koKSB7XG5cdFx0ZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG5cdFx0dGhpcy4kZGVzdHJveSA9IG5vb3A7XG5cdH1cblxuXHQvKipcblx0ICogQHRlbXBsYXRlIHtFeHRyYWN0PGtleW9mIEV2ZW50cywgc3RyaW5nPn0gS1xuXHQgKiBAcGFyYW0ge0t9IHR5cGVcblx0ICogQHBhcmFtIHsoKGU6IEV2ZW50c1tLXSkgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkfSBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cblx0ICovXG5cdCRvbih0eXBlLCBjYWxsYmFjaykge1xuXHRcdGlmICghaXNfZnVuY3Rpb24oY2FsbGJhY2spKSB7XG5cdFx0XHRyZXR1cm4gbm9vcDtcblx0XHR9XG5cdFx0Y29uc3QgY2FsbGJhY2tzID0gdGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pO1xuXHRcdGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UGFydGlhbDxQcm9wcz59IHByb3BzXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0JHNldChwcm9wcykge1xuXHRcdGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eShwcm9wcykpIHtcblx0XHRcdHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG5cdFx0XHR0aGlzLiQkc2V0KHByb3BzKTtcblx0XHRcdHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthdHRyaWJ1dGVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWZsZWN0XVxuICogQHByb3BlcnR5IHsnU3RyaW5nJ3wnQm9vbGVhbid8J051bWJlcid8J0FycmF5J3wnT2JqZWN0J30gW3R5cGVdXG4gKi9cbiIsIi8vIGdlbmVyYXRlZCBkdXJpbmcgcmVsZWFzZSwgZG8gbm90IG1vZGlmeVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IHZlcnNpb24sIGFzIHNldCBpbiBwYWNrYWdlLmpzb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWNvbXBpbGVyI3N2ZWx0ZS12ZXJzaW9uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc0LjAuMCc7XG5leHBvcnQgY29uc3QgUFVCTElDX1ZFUlNJT04gPSAnNCc7XG4iLCJpbXBvcnQge1xuXHRjdXN0b21fZXZlbnQsXG5cdGFwcGVuZCxcblx0YXBwZW5kX2h5ZHJhdGlvbixcblx0aW5zZXJ0LFxuXHRpbnNlcnRfaHlkcmF0aW9uLFxuXHRkZXRhY2gsXG5cdGxpc3Rlbixcblx0YXR0clxufSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBTdmVsdGVDb21wb25lbnQgfSBmcm9tICcuL0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBpc192b2lkIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzL25hbWVzLmpzJztcbmltcG9ydCB7IFZFUlNJT04gfSBmcm9tICcuLi8uLi9zaGFyZWQvdmVyc2lvbi5qcyc7XG5pbXBvcnQgeyBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlX2FycmF5X2xpa2UgfSBmcm9tICcuL2VhY2guanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtUfSBbZGV0YWlsXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaF9kZXYodHlwZSwgZGV0YWlsKSB7XG5cdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KHR5cGUsIHsgdmVyc2lvbjogVkVSU0lPTiwgLi4uZGV0YWlsIH0sIHsgYnViYmxlczogdHJ1ZSB9KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfZGV2KHRhcmdldCwgbm9kZSkge1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuXHRhcHBlbmQodGFyZ2V0LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSkge1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuXHRhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBbYW5jaG9yXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRfZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcblx0aW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cblxuLyoqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gW2FuY2hvcl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuXHRpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoX2Rldihub2RlKSB7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlJywgeyBub2RlIH0pO1xuXHRkZXRhY2gobm9kZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBiZWZvcmVcbiAqIEBwYXJhbSB7Tm9kZX0gYWZ0ZXJcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoX2JldHdlZW5fZGV2KGJlZm9yZSwgYWZ0ZXIpIHtcblx0d2hpbGUgKGJlZm9yZS5uZXh0U2libGluZyAmJiBiZWZvcmUubmV4dFNpYmxpbmcgIT09IGFmdGVyKSB7XG5cdFx0ZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBhZnRlclxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRhY2hfYmVmb3JlX2RldihhZnRlcikge1xuXHR3aGlsZSAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKSB7XG5cdFx0ZGV0YWNoX2RldihhZnRlci5wcmV2aW91c1NpYmxpbmcpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBiZWZvcmVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoX2FmdGVyX2RldihiZWZvcmUpIHtcblx0d2hpbGUgKGJlZm9yZS5uZXh0U2libGluZykge1xuXHRcdGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3R9IGhhbmRsZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbaGFzX3ByZXZlbnRfZGVmYXVsdF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hhc19zdG9wX3Byb3BhZ2F0aW9uXVxuICogQHBhcmFtIHtib29sZWFufSBbaGFzX3N0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uXVxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5fZGV2KFxuXHRub2RlLFxuXHRldmVudCxcblx0aGFuZGxlcixcblx0b3B0aW9ucyxcblx0aGFzX3ByZXZlbnRfZGVmYXVsdCxcblx0aGFzX3N0b3BfcHJvcGFnYXRpb24sXG5cdGhhc19zdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvblxuKSB7XG5cdGNvbnN0IG1vZGlmaWVycyA9XG5cdFx0b3B0aW9ucyA9PT0gdHJ1ZSA/IFsnY2FwdHVyZSddIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG5cdGlmIChoYXNfcHJldmVudF9kZWZhdWx0KSBtb2RpZmllcnMucHVzaCgncHJldmVudERlZmF1bHQnKTtcblx0aWYgKGhhc19zdG9wX3Byb3BhZ2F0aW9uKSBtb2RpZmllcnMucHVzaCgnc3RvcFByb3BhZ2F0aW9uJyk7XG5cdGlmIChoYXNfc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24pIG1vZGlmaWVycy5wdXNoKCdzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24nKTtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01BZGRFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuXHRjb25zdCBkaXNwb3NlID0gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcblx0cmV0dXJuICgpID0+IHtcblx0XHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG5cdFx0ZGlzcG9zZSgpO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cl9kZXYobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuXHRpZiAodmFsdWUgPT0gbnVsbCkgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSB9KTtcblx0ZWxzZSBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldEF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlLCB2YWx1ZSB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG5cdG5vZGVbcHJvcGVydHldID0gdmFsdWU7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0UHJvcGVydHknLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7YW55fSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFzZXRfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuXHRub2RlLmRhdGFzZXRbcHJvcGVydHldID0gdmFsdWU7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YXNldCcsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX2Rldih0ZXh0LCBkYXRhKSB7XG5cdGRhdGEgPSAnJyArIGRhdGE7XG5cdGlmICh0ZXh0LmRhdGEgPT09IGRhdGEpIHJldHVybjtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhJywgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZV9kZXYodGV4dCwgZGF0YSkge1xuXHRkYXRhID0gJycgKyBkYXRhO1xuXHRpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpIHJldHVybjtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhJywgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cl92YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGVfZGV2KHRleHQsIGRhdGEsIGF0dHJfdmFsdWUpIHtcblx0aWYgKH5jb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcy5pbmRleE9mKGF0dHJfdmFsdWUpKSB7XG5cdFx0c2V0X2RhdGFfY29udGVudGVkaXRhYmxlX2Rldih0ZXh0LCBkYXRhKTtcblx0fSBlbHNlIHtcblx0XHRzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZV9hcnJheV9saWtlX2RldihhcmcpIHtcblx0aWYgKFxuXHRcdHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnICYmXG5cdFx0IShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYXJnKSAmJlxuXHRcdCEodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFyZylcblx0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCd7I2VhY2h9IG9ubHkgd29ya3Mgd2l0aCBpdGVyYWJsZSB2YWx1ZXMuJyk7XG5cdH1cblx0cmV0dXJuIGVuc3VyZV9hcnJheV9saWtlKGFyZyk7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfc2xvdHMobmFtZSwgc2xvdCwga2V5cykge1xuXHRmb3IgKGNvbnN0IHNsb3Rfa2V5IG9mIE9iamVjdC5rZXlzKHNsb3QpKSB7XG5cdFx0aWYgKCF+a2V5cy5pbmRleE9mKHNsb3Rfa2V5KSkge1xuXHRcdFx0Y29uc29sZS53YXJuKGA8JHtuYW1lfT4gcmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBzbG90IFwiJHtzbG90X2tleX1cIi5gKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IHRhZ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV9keW5hbWljX2VsZW1lbnQodGFnKSB7XG5cdGNvbnN0IGlzX3N0cmluZyA9IHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnO1xuXHRpZiAodGFnICYmICFpc19zdHJpbmcpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJzxzdmVsdGU6ZWxlbWVudD4gZXhwZWN0cyBcInRoaXNcIiBhdHRyaWJ1dGUgdG8gYmUgYSBzdHJpbmcuJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8IHN0cmluZ30gdGFnXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50KHRhZykge1xuXHRpZiAodGFnICYmIGlzX3ZvaWQodGFnKSkge1xuXHRcdGNvbnNvbGUud2FybihgPHN2ZWx0ZTplbGVtZW50IHRoaXM9XCIke3RhZ31cIj4gaXMgc2VsZi1jbG9zaW5nIGFuZCBjYW5ub3QgaGF2ZSBjb250ZW50LmApO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3Rfc3ZlbHRlX2NvbXBvbmVudF9kZXYoY29tcG9uZW50LCBwcm9wcykge1xuXHRjb25zdCBlcnJvcl9tZXNzYWdlID0gJ3RoaXM9ey4uLn0gb2YgPHN2ZWx0ZTpjb21wb25lbnQ+IHNob3VsZCBzcGVjaWZ5IGEgU3ZlbHRlIGNvbXBvbmVudC4nO1xuXHR0cnkge1xuXHRcdGNvbnN0IGluc3RhbmNlID0gbmV3IGNvbXBvbmVudChwcm9wcyk7XG5cdFx0aWYgKCFpbnN0YW5jZS4kJCB8fCAhaW5zdGFuY2UuJHNldCB8fCAhaW5zdGFuY2UuJG9uIHx8ICFpbnN0YW5jZS4kZGVzdHJveSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yX21lc3NhZ2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdGNvbnN0IHsgbWVzc2FnZSB9ID0gZXJyO1xuXHRcdGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgbWVzc2FnZS5pbmRleE9mKCdpcyBub3QgYSBjb25zdHJ1Y3RvcicpICE9PSAtMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yX21lc3NhZ2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBlcnI7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMgd2l0aCBzb21lIG1pbm9yIGRldi1lbmhhbmNlbWVudHMuIFVzZWQgd2hlbiBkZXY9dHJ1ZS5cbiAqXG4gKiBDYW4gYmUgdXNlZCB0byBjcmVhdGUgc3Ryb25nbHkgdHlwZWQgU3ZlbHRlIGNvbXBvbmVudHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqIFlvdSBoYXZlIGNvbXBvbmVudCBsaWJyYXJ5IG9uIG5wbSBjYWxsZWQgYGNvbXBvbmVudC1saWJyYXJ5YCwgZnJvbSB3aGljaFxuICogeW91IGV4cG9ydCBhIGNvbXBvbmVudCBjYWxsZWQgYE15Q29tcG9uZW50YC4gRm9yIFN2ZWx0ZStUeXBlU2NyaXB0IHVzZXJzLFxuICogeW91IHdhbnQgdG8gcHJvdmlkZSB0eXBpbmdzLiBUaGVyZWZvcmUgeW91IGNyZWF0ZSBhIGBpbmRleC5kLnRzYDpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdmVsdGVDb21wb25lbnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGBgYFxuICogVHlwaW5nIHRoaXMgbWFrZXMgaXQgcG9zc2libGUgZm9yIElERXMgbGlrZSBWUyBDb2RlIHdpdGggdGhlIFN2ZWx0ZSBleHRlbnNpb25cbiAqIHRvIHByb3ZpZGUgaW50ZWxsaXNlbnNlIGFuZCB0byB1c2UgdGhlIGNvbXBvbmVudCBsaWtlIHRoaXMgaW4gYSBTdmVsdGUgZmlsZVxuICogd2l0aCBUeXBlU2NyaXB0OlxuICogYGBgc3ZlbHRlXG4gKiA8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICogXHRpbXBvcnQgeyBNeUNvbXBvbmVudCB9IGZyb20gXCJjb21wb25lbnQtbGlicmFyeVwiO1xuICogPC9zY3JpcHQ+XG4gKiA8TXlDb21wb25lbnQgZm9vPXsnYmFyJ30gLz5cbiAqIGBgYFxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbUHJvcHM9YW55XVxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbRXZlbnRzPWFueV1cbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW1Nsb3RzPWFueV1cbiAqIEBleHRlbmRzIHtTdmVsdGVDb21wb25lbnQ8UHJvcHMsIEV2ZW50cz59XG4gKi9cbmV4cG9ydCBjbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuXHQvKipcblx0ICogRm9yIHR5cGUgY2hlY2tpbmcgY2FwYWJpbGl0aWVzIG9ubHkuXG5cdCAqIERvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWUuXG5cdCAqICMjIyBETyBOT1QgVVNFIVxuXHQgKlxuXHQgKiBAdHlwZSB7UHJvcHN9XG5cdCAqL1xuXHQkJHByb3BfZGVmO1xuXHQvKipcblx0ICogRm9yIHR5cGUgY2hlY2tpbmcgY2FwYWJpbGl0aWVzIG9ubHkuXG5cdCAqIERvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWUuXG5cdCAqICMjIyBETyBOT1QgVVNFIVxuXHQgKlxuXHQgKiBAdHlwZSB7RXZlbnRzfVxuXHQgKi9cblx0JCRldmVudHNfZGVmO1xuXHQvKipcblx0ICogRm9yIHR5cGUgY2hlY2tpbmcgY2FwYWJpbGl0aWVzIG9ubHkuXG5cdCAqIERvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWUuXG5cdCAqICMjIyBETyBOT1QgVVNFIVxuXHQgKlxuXHQgKiBAdHlwZSB7U2xvdHN9XG5cdCAqL1xuXHQkJHNsb3RfZGVmO1xuXG5cdC8qKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Db21wb25lbnRDb25zdHJ1Y3Rvck9wdGlvbnM8UHJvcHM+fSBvcHRpb25zICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMgfHwgKCFvcHRpb25zLnRhcmdldCAmJiAhb3B0aW9ucy4kJGlubGluZSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIid0YXJnZXQnIGlzIGEgcmVxdWlyZWQgb3B0aW9uXCIpO1xuXHRcdH1cblx0XHRzdXBlcigpO1xuXHR9XG5cblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHQkZGVzdHJveSgpIHtcblx0XHRzdXBlci4kZGVzdHJveSgpO1xuXHRcdHRoaXMuJGRlc3Ryb3kgPSAoKSA9PiB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0NvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdFx0fTtcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0JGNhcHR1cmVfc3RhdGUoKSB7fVxuXG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0JGluamVjdF9zdGF0ZSgpIHt9XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW1Byb3BzPWFueV1cbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50cz1hbnldXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtTbG90cz1hbnldXG4gKiBAZGVwcmVjYXRlZCBVc2UgYFN2ZWx0ZUNvbXBvbmVudGAgaW5zdGVhZC4gU2VlIFBSIGZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvODUxMlxuICogQGV4dGVuZHMge1N2ZWx0ZUNvbXBvbmVudERldjxQcm9wcywgRXZlbnRzLCBTbG90cz59XG4gKi9cbmV4cG9ydCBjbGFzcyBTdmVsdGVDb21wb25lbnRUeXBlZCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudERldiB7fVxuXG4vKiogQHJldHVybnMgeygpID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gbG9vcF9ndWFyZCh0aW1lb3V0KSB7XG5cdGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIGRldGVjdGVkJyk7XG5cdFx0fVxuXHR9O1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9hbmltYXRpb25zLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYXdhaXRfYmxvY2suanMnO1xuZXhwb3J0ICogZnJvbSAnLi9kb20uanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2dsb2JhbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lYWNoLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbG9vcC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3NjaGVkdWxlci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3NwcmVhZC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3Nzci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RyYW5zaXRpb25zLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9Db21wb25lbnQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9kZXYuanMnO1xuIiwiaW1wb3J0IHsgUFVCTElDX1ZFUlNJT04gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdmVyc2lvbi5qcyc7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcblx0Ly8gQHRzLWlnbm9yZVxuXHQod2luZG93Ll9fc3ZlbHRlIHx8ICh3aW5kb3cuX19zdmVsdGUgPSB7IHY6IG5ldyBTZXQoKSB9KSkudi5hZGQoUFVCTElDX1ZFUlNJT04pO1xuIiwiZXhwb3J0IHtcblx0U3ZlbHRlQ29tcG9uZW50RGV2IGFzIFN2ZWx0ZUNvbXBvbmVudCxcblx0b25Nb3VudCxcblx0b25EZXN0cm95LFxuXHRiZWZvcmVVcGRhdGUsXG5cdGFmdGVyVXBkYXRlLFxuXHRzZXRDb250ZXh0LFxuXHRnZXRDb250ZXh0LFxuXHRnZXRBbGxDb250ZXh0cyxcblx0aGFzQ29udGV4dCxcblx0dGljayxcblx0Y3JlYXRlRXZlbnREaXNwYXRjaGVyLFxuXHRTdmVsdGVDb21wb25lbnRUeXBlZFxufSBmcm9tICcuL2ludGVybmFsL2luZGV4LmpzJztcbiIsImltcG9ydCB7XG5cdHJ1bl9hbGwsXG5cdHN1YnNjcmliZSxcblx0bm9vcCxcblx0c2FmZV9ub3RfZXF1YWwsXG5cdGlzX2Z1bmN0aW9uLFxuXHRnZXRfc3RvcmVfdmFsdWVcbn0gZnJvbSAnLi4vaW50ZXJuYWwvaW5kZXguanMnO1xuXG5jb25zdCBzdWJzY3JpYmVyX3F1ZXVlID0gW107XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBSZWFkYWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI3JlYWRhYmxlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdmFsdWVdIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlN0YXJ0U3RvcE5vdGlmaWVyPFQ+fSBbc3RhcnRdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZGFibGUodmFsdWUsIHN0YXJ0KSB7XG5cdHJldHVybiB7XG5cdFx0c3Vic2NyaWJlOiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQpLnN1YnNjcmliZVxuXHR9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBXcml0YWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgYm90aCB1cGRhdGluZyBhbmQgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI3dyaXRhYmxlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdmFsdWVdIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlN0YXJ0U3RvcE5vdGlmaWVyPFQ+fSBbc3RhcnRdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLldyaXRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGFibGUodmFsdWUsIHN0YXJ0ID0gbm9vcCkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5VbnN1YnNjcmliZXJ9ICovXG5cdGxldCBzdG9wO1xuXHQvKiogQHR5cGUge1NldDxpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN1YnNjcmliZUludmFsaWRhdGVUdXBsZTxUPj59ICovXG5cdGNvbnN0IHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuXHQvKiogQHBhcmFtIHtUfSBuZXdfdmFsdWVcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBzZXQobmV3X3ZhbHVlKSB7XG5cdFx0aWYgKHNhZmVfbm90X2VxdWFsKHZhbHVlLCBuZXdfdmFsdWUpKSB7XG5cdFx0XHR2YWx1ZSA9IG5ld192YWx1ZTtcblx0XHRcdGlmIChzdG9wKSB7XG5cdFx0XHRcdC8vIHN0b3JlIGlzIHJlYWR5XG5cdFx0XHRcdGNvbnN0IHJ1bl9xdWV1ZSA9ICFzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7XG5cdFx0XHRcdFx0c3Vic2NyaWJlclsxXSgpO1xuXHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWUucHVzaChzdWJzY3JpYmVyLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJ1bl9xdWV1ZSkge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZVtpXVswXShzdWJzY3JpYmVyX3F1ZXVlW2kgKyAxXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWUubGVuZ3RoID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5VcGRhdGVyPFQ+fSBmblxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuXHRcdHNldChmbih2YWx1ZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlN1YnNjcmliZXI8VD59IHJ1blxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuSW52YWxpZGF0b3I8VD59IFtpbnZhbGlkYXRlXVxuXHQgKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlVuc3Vic2NyaWJlcn1cblx0ICovXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShydW4sIGludmFsaWRhdGUgPSBub29wKSB7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN1YnNjcmliZUludmFsaWRhdGVUdXBsZTxUPn0gKi9cblx0XHRjb25zdCBzdWJzY3JpYmVyID0gW3J1biwgaW52YWxpZGF0ZV07XG5cdFx0c3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpO1xuXHRcdGlmIChzdWJzY3JpYmVycy5zaXplID09PSAxKSB7XG5cdFx0XHRzdG9wID0gc3RhcnQoc2V0LCB1cGRhdGUpIHx8IG5vb3A7XG5cdFx0fVxuXHRcdHJ1bih2YWx1ZSk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcblx0XHRcdGlmIChzdWJzY3JpYmVycy5zaXplID09PSAwICYmIHN0b3ApIHtcblx0XHRcdFx0c3RvcCgpO1xuXHRcdFx0XHRzdG9wID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdHJldHVybiB7IHNldCwgdXBkYXRlLCBzdWJzY3JpYmUgfTtcbn1cblxuLyoqXG4gKiBEZXJpdmVkIHZhbHVlIHN0b3JlIGJ5IHN5bmNocm9uaXppbmcgb25lIG9yIG1vcmUgcmVhZGFibGUgc3RvcmVzIGFuZFxuICogYXBwbHlpbmcgYW4gYWdncmVnYXRpb24gZnVuY3Rpb24gb3ZlciBpdHMgaW5wdXQgdmFsdWVzLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNkZXJpdmVkXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuU3RvcmVzfSBTXG4gKiBAdGVtcGxhdGUgVFxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1N9IHN0b3JlcyAtIGlucHV0IHN0b3Jlc1xuICogQHBhcmFtIHsodmFsdWVzOiBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN0b3Jlc1ZhbHVlczxTPiwgc2V0OiAodmFsdWU6IFQpID0+IHZvaWQsIHVwZGF0ZTogKGZuOiBpbXBvcnQoJy4vcHVibGljLmpzJykuVXBkYXRlcjxUPikgPT4gdm9pZCkgPT4gaW1wb3J0KCcuL3B1YmxpYy5qcycpLlVuc3Vic2NyaWJlciB8IHZvaWR9IGZuIC0gZnVuY3Rpb24gY2FsbGJhY2sgdGhhdCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXNcbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdIC0gaW5pdGlhbCB2YWx1ZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuXG4vKipcbiAqIERlcml2ZWQgdmFsdWUgc3RvcmUgYnkgc3luY2hyb25pemluZyBvbmUgb3IgbW9yZSByZWFkYWJsZSBzdG9yZXMgYW5kXG4gKiBhcHBseWluZyBhbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBvdmVyIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI2Rlcml2ZWRcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7U30gc3RvcmVzIC0gaW5wdXQgc3RvcmVzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IGltcG9ydCgnLi9wcml2YXRlLmpzJykuU3RvcmVzVmFsdWVzPFM+KSA9PiBUfSBmbiAtIGZ1bmN0aW9uIGNhbGxiYWNrIHRoYXQgYWdncmVnYXRlcyB0aGUgdmFsdWVzXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXSAtIGluaXRpYWwgdmFsdWVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59XG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuU3RvcmVzfSBTXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTfSBzdG9yZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWQoc3RvcmVzLCBmbiwgaW5pdGlhbF92YWx1ZSkge1xuXHRjb25zdCBzaW5nbGUgPSAhQXJyYXkuaXNBcnJheShzdG9yZXMpO1xuXHQvKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxhbnk+Pn0gKi9cblx0Y29uc3Qgc3RvcmVzX2FycmF5ID0gc2luZ2xlID8gW3N0b3Jlc10gOiBzdG9yZXM7XG5cdGlmICghc3RvcmVzX2FycmF5LmV2ZXJ5KEJvb2xlYW4pKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdkZXJpdmVkKCkgZXhwZWN0cyBzdG9yZXMgYXMgaW5wdXQsIGdvdCBhIGZhbHN5IHZhbHVlJyk7XG5cdH1cblx0Y29uc3QgYXV0byA9IGZuLmxlbmd0aCA8IDI7XG5cdHJldHVybiByZWFkYWJsZShpbml0aWFsX3ZhbHVlLCAoc2V0LCB1cGRhdGUpID0+IHtcblx0XHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXHRcdGxldCBwZW5kaW5nID0gMDtcblx0XHRsZXQgY2xlYW51cCA9IG5vb3A7XG5cdFx0Y29uc3Qgc3luYyA9ICgpID0+IHtcblx0XHRcdGlmIChwZW5kaW5nKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGZuKHNpbmdsZSA/IHZhbHVlc1swXSA6IHZhbHVlcywgc2V0LCB1cGRhdGUpO1xuXHRcdFx0aWYgKGF1dG8pIHtcblx0XHRcdFx0c2V0KHJlc3VsdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbGVhbnVwID0gaXNfZnVuY3Rpb24ocmVzdWx0KSA/IHJlc3VsdCA6IG5vb3A7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCB1bnN1YnNjcmliZXJzID0gc3RvcmVzX2FycmF5Lm1hcCgoc3RvcmUsIGkpID0+XG5cdFx0XHRzdWJzY3JpYmUoXG5cdFx0XHRcdHN0b3JlLFxuXHRcdFx0XHQodmFsdWUpID0+IHtcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRwZW5kaW5nICY9IH4oMSA8PCBpKTtcblx0XHRcdFx0XHRpZiAoc3RhcnRlZCkge1xuXHRcdFx0XHRcdFx0c3luYygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0KCkgPT4ge1xuXHRcdFx0XHRcdHBlbmRpbmcgfD0gMSA8PCBpO1xuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0KTtcblx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRzeW5jKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0XHRydW5fYWxsKHVuc3Vic2NyaWJlcnMpO1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0Ly8gV2UgbmVlZCB0byBzZXQgdGhpcyB0byBmYWxzZSBiZWNhdXNlIGNhbGxiYWNrcyBjYW4gc3RpbGwgaGFwcGVuIGRlc3BpdGUgaGF2aW5nIHVuc3Vic2NyaWJlZDpcblx0XHRcdC8vIENhbGxiYWNrcyBtaWdodCBhbHJlYWR5IGJlIHBsYWNlZCBpbiB0aGUgcXVldWUgd2hpY2ggZG9lc24ndCBrbm93IGl0IHNob3VsZCBubyBsb25nZXJcblx0XHRcdC8vIGludm9rZSB0aGlzIGRlcml2ZWQgc3RvcmUuXG5cdFx0XHRzdGFydGVkID0gZmFsc2U7XG5cdFx0fTtcblx0fSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBzdG9yZSBhbmQgcmV0dXJucyBhIG5ldyBvbmUgZGVyaXZlZCBmcm9tIHRoZSBvbGQgb25lIHRoYXQgaXMgcmVhZGFibGUuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI3JlYWRvbmx5XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59IHN0b3JlICAtIHN0b3JlIHRvIG1ha2UgcmVhZG9ubHlcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkb25seShzdG9yZSkge1xuXHRyZXR1cm4ge1xuXHRcdHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLmJpbmQoc3RvcmUpXG5cdH07XG59XG5cbmV4cG9ydCB7IGdldF9zdG9yZV92YWx1ZSBhcyBnZXQgfTtcbiIsImltcG9ydCB7dHlwZSBXcml0YWJsZSwgd3JpdGFibGV9IGZyb20gJ3N2ZWx0ZS9zdG9yZSdcbi8vIGltcG9ydCB0eXBlICogYXMgTW9uYWNvIGZyb20gJ21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9lZGl0b3IuYXBpJ1xuXG5leHBvcnQgbGV0IGdhbGxlcnlfb3BlbjogV3JpdGFibGU8Ym9vbGVhbj4gPSB3cml0YWJsZSh0cnVlKVxuZXhwb3J0IGxldCBmbG9hdGluZ19tb2RhbF9tZXNzYWdlOiBXcml0YWJsZTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0gd3JpdGFibGUodW5kZWZpbmVkKVxuLy8gQHRzLWlnbm9yZVxuLy8gZXhwb3J0IGxldCBfbW9uYWNvOiB0eXBlb2Ygd3JpdGFibGU8dHlwZW9mIE1vbmFjbz4gPSB3cml0YWJsZSgwKTtcbiIsIi8vIHlvaW5rZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzQ0NTAwL2VmZmljaWVudC13YXktdG8taW5zZXJ0LWEtbnVtYmVyLWludG8tYS1zb3J0ZWQtYXJyYXktb2YtbnVtYmVyc1xuXG4vKipcbiAqIExvb2sgZm9yIGFuIGluZGV4IGZyb20gYSBzb3J0ZWQgbGlzdCB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICpcbiAqIElmIHlvdSBkb24ndCBwcm92aWRlIGEgY29tcGFyZSBmdW5jdGlvbiwgaXQgd2lsbCBsb29rIGZvciAqKnRoZSBmaXJzdCBzYW1lIHZhbHVlKiogaXQgY2FuIGZpbmQuXG4gKiBJZiBpdCBjYW5ub3QgZmluZCBhbiBleGFjdGx5IG1hdGNoaW5nIHZhbHVlLCBpdCBjYW4gcmV0dXJuIE4gd2hlcmUgdGhlIGxlbmd0aCBvZiBnaXZlbiBhcnJheSBpcyBOLlxuICpcbiAqIEBwYXJhbSBhcnJheSBBIHNvcnRlZCBhcnJheVxuICogQHBhcmFtIGNvbXBhcmUgTWFrZSB0aGlzIGZ1bmN0aW9uIHJldHVybiBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIHBvaW50IHJpZ2h0IHNpZGUgb2YgZ2l2ZW4gZWxlbWVudCwgYHRydWVgIGlmIHlvdSB3YW50IHRvIHBvaW50IGxlZnQgc2lkZSBvZiBnaXZlbiBlbGVtZW50LlxuICogQHJldHVybnMgQW4gaW5kZXggZm91bmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaDxUPiggYXJyYXk6IEFycmF5TGlrZTxUPiwgZWxlbWVudDogVCApOiBudW1iZXI7XG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoPFQ+KCBhcnJheTogQXJyYXlMaWtlPFQ+LCBjb21wYXJlOiAoIGVsZW1lbnQ6IFQgKSA9PiBib29sZWFuICk6IG51bWJlcjtcbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2g8VD4oXG4gIGFycmF5OiBBcnJheUxpa2U8VD4sXG4gIGVsZW1lbnRPckNvbXBhcmU6IFQgfCAoICggZWxlbWVudDogVCApID0+IGJvb2xlYW4gKSxcbik6IG51bWJlciB7XG4gIGlmICggdHlwZW9mIGVsZW1lbnRPckNvbXBhcmUgIT09ICdmdW5jdGlvbicgKSB7XG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaCggYXJyYXksICggZWxlbWVudCApID0+ICggZWxlbWVudCA8IGVsZW1lbnRPckNvbXBhcmUgKSApO1xuICB9XG4gIGNvbnN0IGNvbXBhcmUgPSBlbGVtZW50T3JDb21wYXJlIGFzICggZWxlbWVudDogVCApID0+IGJvb2xlYW47XG5cbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoIHN0YXJ0IDwgZW5kICkge1xuICAgIGNvbnN0IGNlbnRlciA9ICggc3RhcnQgKyBlbmQgKSA+PiAxO1xuICAgIGNvbnN0IGNlbnRlckVsZW1lbnQgPSBhcnJheVsgY2VudGVyIF07XG5cbiAgICBjb25zdCBjb21wYXJlUmVzdWx0ID0gY29tcGFyZSggY2VudGVyRWxlbWVudCApO1xuXG4gICAgaWYgKCBjb21wYXJlUmVzdWx0ICkge1xuICAgICAgc3RhcnQgPSBjZW50ZXIgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBjZW50ZXI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXJ0O1xufVxuIiwiLyoqXG4gKiBHZW5lcmljIHRyYXZlcnNlIGZ1bmN0aW9uLlxuICpcbiAqIEl0IHBlcmZvcm1zIERlcHRoLUZpcnN0IFNlYXJjaC5cbiAqXG4gKiBUaGUgYHRyYXZlcnNlcmAgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaCBkZXNjZW5kYW50cy5cbiAqIFlvdSBuZWVkIHRvIHJldHVybiB0aGVpciBcImNoaWxkcmVuXCIgaW4gYW4gYXJyYXkuXG4gKiBJZiB5b3Ugd2FudCB0byBzdG9wIHRoZSB0cmF2ZXJzYWwsIHJldHVybiBgZmFsc2VgIGluc3RlYWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyByZXBsaWNhdGUgVGhyZWUuanMgdHJhdmVyc2UgZm9yIG5vIHJlYXNvblxuICogY29uc3QgbWVzaGVzID0gW107XG4gKiB0cmF2ZXJzZSggb2JqZWN0M0RSb290LCAoIG9iamVjdCApID0+IHtcbiAqICAgaWYgKCBvYmplY3QuaXNNZXNoICkge1xuICogICAgIG1lc2hlcy5wdXNoKCBvYmplY3QgKTtcbiAqICAgfVxuICogICByZXR1cm4gb2JqZWN0M0RSb290LmNoaWxkcmVuO1xuICogfSApO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHJvb3QgVGhlIFwicm9vdFwiIG5vZGVcbiAqIEBwYXJhbSB0cmF2ZXJzZXIgVGhlIHRyYXZlcnNlIGZ1bmN0aW9uLiBJZiB0aGUgbm9kZSBoYXMgXCJjaGlsZHJlblwiIHJldHVybiB0aGVtIGluIGFuIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhdmVyc2U8VE5vZGU+KFxuICByb290OiBUTm9kZSxcbiAgdHJhdmVyc2VyOiAoIG5vZGU6IFROb2RlICkgPT4gVE5vZGVbXSB8IGZhbHNlLFxuKTogdm9pZCB7XG4gIGNvbnN0IG5vZGVzTmVlZFByb2Nlc3M6IFROb2RlW10gPSBbIHJvb3QgXTtcbiAgY29uc3Qgbm9kZXNTZWVuID0gbmV3IFNldDxUTm9kZT4oIG5vZGVzTmVlZFByb2Nlc3MgKTtcblxuICB3aGlsZSAoIG5vZGVzTmVlZFByb2Nlc3MubGVuZ3RoID4gMCApIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IG5vZGVzTmVlZFByb2Nlc3Muc2hpZnQoKSE7XG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IHRyYXZlcnNlciggY3VycmVudE5vZGUgKTtcblxuICAgIGlmICggIWNoaWxkcmVuICkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZXNGb3VuZCA9IGNoaWxkcmVuLmZpbHRlciggKCBub2RlICkgPT4gIW5vZGVzU2Vlbi5oYXMoIG5vZGUgKSApO1xuICAgIG5vZGVzTmVlZFByb2Nlc3MudW5zaGlmdCggLi4ubm9kZXNGb3VuZCApO1xuICAgIG5vZGVzRm91bmQubWFwKCAoIG5vZGUgKSA9PiBub2Rlc1NlZW4uYWRkKCBub2RlICkgKTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFycmF5UmFuZ2UoIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzdGVwPzogbnVtYmVyICk6IG51bWJlcltdIHtcbiAgbGV0IGN1cnJlbnQgPSBzdGFydDtcbiAgY29uc3QgcmV0OiBudW1iZXJbXSA9IFtdO1xuXG4gIGlmICggc3RhcnQgPCBlbmQgKSB7XG4gICAgc3RlcCA9IHN0ZXAgPz8gMTtcbiAgICB3aGlsZSAoIGN1cnJlbnQgPCBlbmQgKSB7XG4gICAgICByZXQucHVzaCggY3VycmVudCApO1xuICAgICAgY3VycmVudCArPSBzdGVwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGVwID0gc3RlcCA/PyAtMTtcbiAgICB3aGlsZSAoIGN1cnJlbnQgPiBlbmQgKSB7XG4gICAgICByZXQucHVzaCggY3VycmVudCApO1xuICAgICAgY3VycmVudCArPSBzdGVwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbiIsImV4cG9ydCBjb25zdCBhcnJheVNlcmlhbCA9ICggY291bnQ6IG51bWJlciApOiBudW1iZXJbXSA9PiAoXG4gIFsgLi4uQXJyYXkoIGNvdW50ICkgXS5tYXAoICggXywgaSApID0+IGkgKVxuKTtcbiIsImV4cG9ydCBmdW5jdGlvbiBhcnJheVNldERlbGV0ZTxUPiggYXJyYXk6IEFycmF5PFQ+LCB2YWx1ZTogVCApOiBib29sZWFuIHtcbiAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKCB2YWx1ZSApO1xuICBpZiAoIGluZGV4ID09PSAtMSApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgYXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5U2V0SGFzPFQ+KCBhcnJheTogQXJyYXk8VD4sIHZhbHVlOiBUICk6IGJvb2xlYW4ge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZiggdmFsdWUgKSAhPT0gLTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVNldEFkZDxUPiggYXJyYXk6IEFycmF5PFQ+LCB2YWx1ZTogVCApOiBib29sZWFuIHtcbiAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKCB2YWx1ZSApO1xuICBpZiAoIGluZGV4ICE9PSAtMSApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgYXJyYXkucHVzaCggdmFsdWUgKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVNldFVuaW9uPFQ+KCBhOiBBcnJheTxUPiwgYjogQXJyYXk8VD4gKTogQXJyYXk8VD4ge1xuICBjb25zdCBvdXQgPSBbIC4uLmEgXTtcbiAgYi5mb3JFYWNoKCAoIHYgKSA9PiB7XG4gICAgaWYgKCAhYXJyYXlTZXRIYXMoIG91dCwgdiApICkge1xuICAgICAgb3V0LnB1c2goIHYgKTtcbiAgICB9XG4gIH0gKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5U2V0RGlmZjxUPiggZnJvbTogQXJyYXk8VD4sIGRpZmY6IEFycmF5PFQ+ICk6IEFycmF5PFQ+IHtcbiAgY29uc3Qgb3V0ID0gWyAuLi5mcm9tIF07XG4gIGRpZmYuZm9yRWFjaCggKCB2ICkgPT4ge1xuICAgIGFycmF5U2V0RGVsZXRlKCBvdXQsIHYgKTtcbiAgfSApO1xuICByZXR1cm4gb3V0O1xufVxuIiwiLyoqXG4gKiBgWyAtMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgMSBdYFxuICovXG5leHBvcnQgY29uc3QgVFJJQU5HTEVfU1RSSVBfUVVBRCA9IFsgLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDEgXTtcblxuLyoqXG4gKiBgWyAtMSwgLTEsIDAsIDEsIC0xLCAwLCAtMSwgMSwgMCwgMSwgMSwgMCBdYFxuICovXG5leHBvcnQgY29uc3QgVFJJQU5HTEVfU1RSSVBfUVVBRF8zRCA9IFsgLTEsIC0xLCAwLCAxLCAtMSwgMCwgLTEsIDEsIDAsIDEsIDEsIDAgXTtcblxuLyoqXG4gKiBgWyAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxIF1gXG4gKi9cbmV4cG9ydCBjb25zdCBUUklBTkdMRV9TVFJJUF9RVUFEX05PUk1BTCA9IFsgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSBdO1xuXG4vKipcbiAqIGBbIDAsIDAsIDEsIDAsIDAsIDEsIDEsIDEgXWBcbiAqL1xuZXhwb3J0IGNvbnN0IFRSSUFOR0xFX1NUUklQX1FVQURfVVYgPSBbIDAsIDAsIDEsIDAsIDAsIDEsIDEsIDEgXTtcbiIsIi8qKlxuICogU2h1ZmZsZSBnaXZlbiBgYXJyYXlgIHVzaW5nIGdpdmVuIGBkaWNlYCBSTkcuICoqRGVzdHJ1Y3RpdmUqKi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNodWZmbGVBcnJheTxUPiggYXJyYXk6IFRbXSwgZGljZT86ICgpID0+IG51bWJlciApOiBUW10ge1xuICBjb25zdCBmID0gZGljZSA/IGRpY2UgOiAoKSA9PiBNYXRoLnJhbmRvbSgpO1xuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGggLSAxOyBpICsrICkge1xuICAgIGNvbnN0IGlyID0gaSArIE1hdGguZmxvb3IoIGYoKSAqICggYXJyYXkubGVuZ3RoIC0gaSApICk7XG4gICAgY29uc3QgdGVtcCA9IGFycmF5WyBpciBdO1xuICAgIGFycmF5WyBpciBdID0gYXJyYXlbIGkgXTtcbiAgICBhcnJheVsgaSBdID0gdGVtcDtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogSSBsaWtlIHdpcmVmcmFtZVxuICpcbiAqIGB0cmlJbmRleFRvTGluZUluZGV4KCBbIDAsIDEsIDIsIDUsIDYsIDcgXSApYCAtPiBgWyAwLCAxLCAxLCAyLCAyLCAwLCA1LCA2LCA2LCA3LCA3LCA1IF1gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmlJbmRleFRvTGluZUluZGV4PFQ+KCBhcnJheTogVFtdICk6IFRbXSB7XG4gIGNvbnN0IHJldDogVFtdID0gW107XG4gIGZvciAoIGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aCAvIDM7IGkgKysgKSB7XG4gICAgY29uc3QgaGVhZCA9IGkgKiAzO1xuICAgIHJldC5wdXNoKFxuICAgICAgYXJyYXlbIGhlYWQgICAgIF0sIGFycmF5WyBoZWFkICsgMSBdLFxuICAgICAgYXJyYXlbIGhlYWQgKyAxIF0sIGFycmF5WyBoZWFkICsgMiBdLFxuICAgICAgYXJyYXlbIGhlYWQgKyAyIF0sIGFycmF5WyBoZWFkICAgICBdXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIGBtYXRyaXgyZCggMywgMiApYCAtPiBgWyAwLCAwLCAwLCAxLCAwLCAyLCAxLCAwLCAxLCAxLCAxLCAyIF1gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRyaXgyZCggdzogbnVtYmVyLCBoOiBudW1iZXIgKTogbnVtYmVyW10ge1xuICBjb25zdCBhcnI6IG51bWJlcltdID0gW107XG4gIGZvciAoIGxldCBpeSA9IDA7IGl5IDwgaDsgaXkgKysgKSB7XG4gICAgZm9yICggbGV0IGl4ID0gMDsgaXggPCB3OyBpeCArKyApIHtcbiAgICAgIGFyci5wdXNoKCBpeCwgaXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBTZWUgYWxzbzoge0BsaW5rIG1hdHJpeDJkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0cml4M2QoIHc6IG51bWJlciwgaDogbnVtYmVyLCBkOiBudW1iZXIgKTogbnVtYmVyW10ge1xuICBjb25zdCBhcnI6IG51bWJlcltdID0gW107XG4gIGZvciAoIGxldCBpeiA9IDA7IGl6IDwgZDsgaXogKysgKSB7XG4gICAgZm9yICggbGV0IGl5ID0gMDsgaXkgPCBoOyBpeSArKyApIHtcbiAgICAgIGZvciAoIGxldCBpeCA9IDA7IGl4IDwgdzsgaXggKysgKSB7XG4gICAgICAgIGFyci5wdXNoKCBpeCwgaXksIGl6ICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59XG4iLCIvKipcbiAqIENyaXRpY2FsbHkgRGFtcGVkIFNwcmluZ1xuICpcbiAqIFNob3V0b3V0cyB0byBLZWlqaXJvIFRha2FoYXNoaVxuICovXG5leHBvcnQgY2xhc3MgQ0RTIHtcbiAgcHVibGljIGZhY3RvciA9IDEwMC4wO1xuICBwdWJsaWMgcmF0aW8gPSAxLjA7XG4gIHB1YmxpYyB2ZWxvY2l0eSA9IDAuMDtcbiAgcHVibGljIHZhbHVlID0gMC4wO1xuICBwdWJsaWMgdGFyZ2V0ID0gMC4wO1xuXG4gIHB1YmxpYyB1cGRhdGUoIGRlbHRhVGltZTogbnVtYmVyICk6IG51bWJlciB7XG4gICAgdGhpcy52ZWxvY2l0eSArPSAoXG4gICAgICAtdGhpcy5mYWN0b3IgKiAoIHRoaXMudmFsdWUgLSB0aGlzLnRhcmdldCApXG4gICAgICAtIDIuMCAqIHRoaXMudmVsb2NpdHkgKiBNYXRoLnNxcnQoIHRoaXMuZmFjdG9yICkgKiB0aGlzLnJhdGlvXG4gICAgKSAqIGRlbHRhVGltZTtcbiAgICB0aGlzLnZhbHVlICs9IHRoaXMudmVsb2NpdHkgKiBkZWx0YVRpbWU7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn1cbiIsIi8qKlxuICogQ2xhc3MgdGhhdCBkZWFscyB3aXRoIHRpbWUuXG4gKiBJbiB0aGlzIGJhc2UgY2xhc3MsIHlvdSBuZWVkIHRvIHNldCB0aW1lIG1hbnVhbGx5IGZyb20gYEF1dG9tYXRvbi51cGRhdGUoKWAuXG4gKiBCZXN0IGZvciBzeW5jIHdpdGggZXh0ZXJuYWwgY2xvY2sgc3R1ZmYuXG4gKi9cbmV4cG9ydCBjbGFzcyBDbG9jayB7XG4gIC8qKlxuICAgKiBJdHMgY3VycmVudCB0aW1lLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9fdGltZSA9IDAuMDtcblxuICAvKipcbiAgICogSXRzIGRlbHRhVGltZSBvZiBsYXN0IHVwZGF0ZS5cbiAgICovXG4gIHByb3RlY3RlZCBfX2RlbHRhVGltZSA9IDAuMDtcblxuICAvKipcbiAgICogV2hldGhlciBpdHMgY3VycmVudGx5IHBsYXlpbmcgb3Igbm90LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9faXNQbGF5aW5nID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEl0cyBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRpbWUoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX190aW1lOyB9XG5cbiAgLyoqXG4gICAqIEl0cyBkZWx0YVRpbWUgb2YgbGFzdCB1cGRhdGUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGRlbHRhVGltZSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fX2RlbHRhVGltZTsgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGl0cyBjdXJyZW50bHkgcGxheWluZyBvciBub3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzUGxheWluZygpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX19pc1BsYXlpbmc7IH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjbG9jay5cbiAgICogQHBhcmFtIHRpbWUgVGltZS4gWW91IG5lZWQgdG8gc2V0IG1hbnVhbGx5IHdoZW4geW91IGFyZSB1c2luZyBtYW51YWwgQ2xvY2tcbiAgICovXG4gIHB1YmxpYyB1cGRhdGUoIHRpbWU/OiBudW1iZXIgKTogdm9pZCB7XG4gICAgY29uc3QgcHJldlRpbWUgPSB0aGlzLl9fdGltZTtcbiAgICB0aGlzLl9fdGltZSA9IHRpbWUgfHwgMC4wO1xuICAgIHRoaXMuX19kZWx0YVRpbWUgPSB0aGlzLl9fdGltZSAtIHByZXZUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBjbG9jay5cbiAgICovXG4gIHB1YmxpYyBwbGF5KCk6IHZvaWQge1xuICAgIHRoaXMuX19pc1BsYXlpbmcgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIGNsb2NrLlxuICAgKi9cbiAgcHVibGljIHBhdXNlKCk6IHZvaWQge1xuICAgIHRoaXMuX19pc1BsYXlpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRpbWUgbWFudWFsbHkuXG4gICAqIEBwYXJhbSB0aW1lIFRpbWVcbiAgICovXG4gIHB1YmxpYyBzZXRUaW1lKCB0aW1lOiBudW1iZXIgKTogdm9pZCB7XG4gICAgdGhpcy5fX3RpbWUgPSB0aW1lO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDbG9jayB9IGZyb20gJy4vQ2xvY2snO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgZGVhbHMgd2l0aCB0aW1lLlxuICogVGhpcyBpcyBcImZyYW1lXCIgdHlwZSBjbG9jaywgdGhlIGZyYW1lIGluY3JlYXNlcyBldmVyeSB7QGxpbmsgQ2xvY2tGcmFtZSN1cGRhdGV9IGNhbGwuXG4gKiBAcGFyYW0gZnBzIEZyYW1lcyBwZXIgc2Vjb25kXG4gKi9cbmV4cG9ydCBjbGFzcyBDbG9ja0ZyYW1lIGV4dGVuZHMgQ2xvY2sge1xuICAvKipcbiAgICogSXRzIGN1cnJlbnQgZnJhbWUuXG4gICAqL1xuICBwcml2YXRlIF9fZnJhbWUgPSAwO1xuXG4gIC8qKlxuICAgKiBJdHMgZnBzLlxuICAgKi9cbiAgcHJpdmF0ZSBfX2ZwczogbnVtYmVyO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggZnBzID0gNjAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fZnBzID0gZnBzO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0cyBjdXJyZW50IGZyYW1lLlxuICAgKi9cbiAgcHVibGljIGdldCBmcmFtZSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fX2ZyYW1lOyB9XG5cbiAgLyoqXG4gICAqIEl0cyBmcHMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGZwcygpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fX2ZwczsgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNsb2NrLiBJdCB3aWxsIGluY3JlYXNlIHRoZSBmcmFtZSBieSAxLlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIHRoaXMuX19pc1BsYXlpbmcgKSB7XG4gICAgICB0aGlzLl9fdGltZSA9IHRoaXMuX19mcmFtZSAvIHRoaXMuX19mcHM7XG4gICAgICB0aGlzLl9fZGVsdGFUaW1lID0gMS4wIC8gdGhpcy5fX2ZwcztcbiAgICAgIHRoaXMuX19mcmFtZSArKztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fX2RlbHRhVGltZSA9IDAuMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0aW1lIG1hbnVhbGx5LlxuICAgKiBUaGUgc2V0IHRpbWUgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byBpbnRlcm5hbCBmcmFtZSBjb3VudCwgc28gdGhlIHRpbWUgd2lsbCBub3QgYmUgZXhhY3RseSBzYW1lIGFzIHNldCBvbmUuXG4gICAqIEBwYXJhbSB0aW1lIFRpbWVcbiAgICovXG4gIHB1YmxpYyBzZXRUaW1lKCB0aW1lOiBudW1iZXIgKTogdm9pZCB7XG4gICAgdGhpcy5fX2ZyYW1lID0gTWF0aC5mbG9vciggdGhpcy5fX2ZwcyAqIHRpbWUgKTtcbiAgICB0aGlzLl9fdGltZSA9IHRoaXMuX19mcmFtZSAvIHRoaXMuX19mcHM7XG4gIH1cbn1cbiIsImltcG9ydCB7IENsb2NrIH0gZnJvbSAnLi9DbG9jayc7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCBkZWFscyB3aXRoIHRpbWUuXG4gKiBUaGlzIGlzIFwicmVhbHRpbWVcIiB0eXBlIGNsb2NrLCB0aGUgdGltZSBnb2VzIG9uIGFzIHJlYWwgd29ybGQuXG4gKi9cbmV4cG9ydCBjbGFzcyBDbG9ja1JlYWx0aW1lIGV4dGVuZHMgQ2xvY2sge1xuICAvKipcbiAgICogXCJZb3Ugc2V0IHRoZSB0aW1lIG1hbnVhbGx5IHRvIGBfX3J0VGltZWAgd2hlbiBpdCdzIGBfX3J0RGF0ZWAuXCJcbiAgICovXG4gIHByaXZhdGUgX19ydFRpbWUgPSAwLjA7XG5cbiAgLyoqXG4gICAqIFwiWW91IHNldCB0aGUgdGltZSBtYW51YWxseSB0byBgX19ydFRpbWVgIHdoZW4gaXQncyBgX19ydERhdGVgLlwiXG4gICAqL1xuICBwcml2YXRlIF9fcnREYXRlOiBudW1iZXIgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAvKipcbiAgICogVGhlIGNsb2NrIGlzIHJlYWx0aW1lLiB5ZWFoLlxuICAgKi9cbiAgcHVibGljIGdldCBpc1JlYWx0aW1lKCk6IGJvb2xlYW4geyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNsb2NrLiBUaW1lIGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGltZSBpbiByZWFsIHdvcmxkLlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIGlmICggdGhpcy5fX2lzUGxheWluZyApIHtcbiAgICAgIGNvbnN0IHByZXZUaW1lID0gdGhpcy5fX3RpbWU7XG4gICAgICBjb25zdCBkZWx0YURhdGUgPSAoIG5vdyAtIHRoaXMuX19ydERhdGUgKTtcbiAgICAgIHRoaXMuX190aW1lID0gdGhpcy5fX3J0VGltZSArIGRlbHRhRGF0ZSAvIDEwMDAuMDtcbiAgICAgIHRoaXMuX19kZWx0YVRpbWUgPSB0aGlzLnRpbWUgLSBwcmV2VGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fX3J0VGltZSA9IHRoaXMudGltZTtcbiAgICAgIHRoaXMuX19ydERhdGUgPSBub3c7XG4gICAgICB0aGlzLl9fZGVsdGFUaW1lID0gMC4wO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRpbWUgbWFudWFsbHkuXG4gICAqIEBwYXJhbSB0aW1lIFRpbWVcbiAgICovXG4gIHB1YmxpYyBzZXRUaW1lKCB0aW1lOiBudW1iZXIgKTogdm9pZCB7XG4gICAgdGhpcy5fX3RpbWUgPSB0aW1lO1xuICAgIHRoaXMuX19ydFRpbWUgPSB0aGlzLnRpbWU7XG4gICAgdGhpcy5fX3J0RGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd1JHQiB9IGZyb20gJy4vUmF3UkdCJztcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgaW5wdXQgY29sb3IgaW4gQXRhcmktU1QgY29sb3IgcGFsZXR0ZSBmb3JtYXQgdG8gYSB7QGxpbmsgUmF3UkdCfS5cbiAqXG4gKiBAcGFyYW0gc3RDb2xvciBBIGNvbG9yIGluIEF0YXJpLVNUIGZvcm1hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29sb3JGcm9tQXRhcmlTVCggc3RDb2xvcjogbnVtYmVyICk6IFJhd1JHQiB7XG4gIHJldHVybiBbXG4gICAgKCBzdENvbG9yID4+IDggJiA3ICkgLyA3LjAsXG4gICAgKCBzdENvbG9yID4+IDQgJiA3ICkgLyA3LjAsXG4gICAgKCBzdENvbG9yICYgNyApIC8gNy4wLFxuICBdO1xufVxuIiwiLyoqXG4gKiBgbGVycGAsIG9yIGBtaXhgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKCBhOiBudW1iZXIsIGI6IG51bWJlciwgeDogbnVtYmVyICk6IG51bWJlciB7XG4gIHJldHVybiBhICsgKCBiIC0gYSApICogeDtcbn1cblxuLyoqXG4gKiBgY2xhbXBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCggeDogbnVtYmVyLCBsOiBudW1iZXIsIGg6IG51bWJlciApOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5taW4oIE1hdGgubWF4KCB4LCBsICksIGggKTtcbn1cblxuLyoqXG4gKiBgY2xhbXAoIHgsIDAuMCwgMS4wIClgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYXR1cmF0ZSggeDogbnVtYmVyICk6IG51bWJlciB7XG4gIHJldHVybiBjbGFtcCggeCwgMC4wLCAxLjAgKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSB2YWx1ZSBmcm9tIGlucHV0IHJhbmdlIHRvIG91dHB1dCByYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKCB4OiBudW1iZXIsIHgwOiBudW1iZXIsIHgxOiBudW1iZXIsIHkwOiBudW1iZXIsIHkxOiBudW1iZXIgKTogbnVtYmVyIHtcbiAgcmV0dXJuICggKCB4IC0geDAgKSAqICggeTEgLSB5MCApIC8gKCB4MSAtIHgwICkgKyB5MCApO1xufVxuXG4vKipcbiAqIGBzbW9vdGhzdGVwYCBidXQgbm90IHNtb290aFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyc3RlcCggYTogbnVtYmVyLCBiOiBudW1iZXIsIHg6IG51bWJlciApOiBudW1iZXIge1xuICByZXR1cm4gc2F0dXJhdGUoICggeCAtIGEgKSAvICggYiAtIGEgKSApO1xufVxuXG4vKipcbiAqIHdvcmxkIGZhbW91cyBgc21vb3Roc3RlcGAgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNtb290aHN0ZXAoIGE6IG51bWJlciwgYjogbnVtYmVyLCB4OiBudW1iZXIgKTogbnVtYmVyIHtcbiAgY29uc3QgdCA9IGxpbmVhcnN0ZXAoIGEsIGIsIHggKTtcbiAgcmV0dXJuIHQgKiB0ICogKCAzLjAgLSAyLjAgKiB0ICk7XG59XG5cbi8qKlxuICogYHNtb290aHN0ZXBgIGJ1dCBtb3JlIHNtb290aFxuICovXG5leHBvcnQgZnVuY3Rpb24gc21vb3RoZXJzdGVwKCBhOiBudW1iZXIsIGI6IG51bWJlciwgeDogbnVtYmVyICk6IG51bWJlciB7XG4gIGNvbnN0IHQgPSBsaW5lYXJzdGVwKCBhLCBiLCB4ICk7XG4gIHJldHVybiB0ICogdCAqIHQgKiAoIHQgKiAoIHQgKiA2LjAgLSAxNS4wICkgKyAxMC4wICk7XG59XG5cbi8qKlxuICogYHNtb290aHN0ZXBgIGJ1dCBXQVkgbW9yZSBzbW9vdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNtb290aGVzdHN0ZXAoIGE6IG51bWJlciwgYjogbnVtYmVyLCB4OiBudW1iZXIgKTogbnVtYmVyIHtcbiAgY29uc3QgdCA9IGxpbmVhcnN0ZXAoIGEsIGIsIHggKTtcbiAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiAoIHQgKiAoIHQgKiAoIC0yMC4wICogdCArIDcwLjAgKSAtIDg0LjAgKSArIDM1LjAgKTtcbn1cbiIsImltcG9ydCB7IFJhd1JHQiB9IGZyb20gJy4vUmF3UkdCJztcbmltcG9ydCB7IGxlcnAgfSBmcm9tICcuLi9tYXRoL3V0aWxzJztcblxuLyoqXG4gKiBDb252ZXJ0IGEgY29sb3IgZnJvbSBIU1YgdG8gUkdCLlxuICogRWFjaCBjb21wb25lbnQgb2YgdGhlIEhTViBtdXN0IGJlIGdpdmVuIGluIFswIC0gMV0gcmFuZ2UuXG4gKlxuICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU1ZfY29sb3Jfc3BhY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9ySFNWMlJHQiggWyBoLCBzLCB2IF06IFsgbnVtYmVyLCBudW1iZXIsIG51bWJlciBdICk6IFJhd1JHQiB7XG4gIGNvbnN0IGh0ID0gaCAlIDEuMCAqIDYuMDtcblxuICByZXR1cm4gWyAwLjAsIDQuMCwgMi4wIF0ubWFwKCAoIHAgKSA9PiB7XG4gICAgY29uc3QgY29sSCA9IE1hdGgubWluKCBNYXRoLm1heCggKFxuICAgICAgTWF0aC5hYnMoICggaHQgKyBwICkgJSA2LjAgLSAzLjAgKSAtIDEuMFxuICAgICksIDAuMCApLCAxLjAgKTtcbiAgICBjb25zdCBjb2xTID0gbGVycCggMS4wLCBjb2xILCBzICk7XG4gICAgcmV0dXJuIHYgKiBjb2xTO1xuICB9ICkgYXMgUmF3UkdCO1xufVxuIiwiaW1wb3J0IHsgc2F0dXJhdGUgfSBmcm9tICcuLi9tYXRoL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgUmF3UkdCIH0gZnJvbSAnLi9SYXdSR0InO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBpbnB1dCBjb2xvciB0byBoZXggcmVwcmVzZW50YXRpb24gKGUuZy4gIzdmN2Y3ZilcbiAqIEBwYXJhbSBjb2xvciBjb2xvciBpbiB7QGxpbmsgUmF3UkdCfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29sb3JUb0hleCggY29sb3I6IFJhd1JHQiApOiBzdHJpbmcge1xuICByZXR1cm4gJyMnICsgY29sb3IubWFwKCAoIHYgKSA9PiAoXG4gICAgKCAnMCcgKyAoIE1hdGgucm91bmQoIHNhdHVyYXRlKCB2ICkgKiAyNTUuMCApICkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLTIgKVxuICApICkuam9pbiggJycgKTtcbn1cbiIsIi8qKlxuICogUmV0dXJuIGEgZG90IHByb2R1Y3Qgb2YgZ2l2ZW4gdHdvIHZlY3RvcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWNEb3Q8VCBleHRlbmRzIG51bWJlcltdPiggdmVjQTogVCwgdmVjQjogVCApOiBudW1iZXIge1xuICByZXR1cm4gdmVjQS5yZWR1Y2UoICggc3VtLCB2LCBpICkgPT4gc3VtICsgdiAqIHZlY0JbIGkgXSwgMC4wICk7XG59XG4iLCIvKiFcbiAqIFR1cmJvIGNvbG9ybWFwXG4gKlxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gKEFwYWNoZS0yLjApXG4gKlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWlraGFpbG92LXdvcmsvMGQxNzc0NjVhODE1MWViNmVkZTE3NjhkNTFkNDc2YzdcbiAqL1xuXG5pbXBvcnQgeyBSYXdSR0IgfSBmcm9tICcuL1Jhd1JHQic7XG5pbXBvcnQgeyBzYXR1cmF0ZSB9IGZyb20gJy4uL21hdGgvdXRpbHMnO1xuaW1wb3J0IHsgdmVjRG90IH0gZnJvbSAnLi4vbWF0aC92ZWMvdmVjRG90JztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHR1cmJvIGdyYWRpZW50LlxuICpcbiAqIFJlZjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWlraGFpbG92LXdvcmsvMGQxNzc0NjVhODE1MWViNmVkZTE3NjhkNTFkNDc2YzdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yVHVyYm8oIHg6IG51bWJlciApOiBSYXdSR0Ige1xuICBjb25zdCBrciA9IFtcbiAgICAwLjEzNTcyMTM4LCA0LjYxNTM5MjYwLCAtNDIuNjYwMzIyNTgsXG4gICAgMTMyLjEzMTA4MjM0LCAtMTUyLjk0MjM5Mzk2LCA1OS4yODYzNzk0MyxcbiAgXTtcbiAgY29uc3Qga2cgPSBbXG4gICAgMC4wOTE0MDI2MSwgMi4xOTQxODgzOSwgNC44NDI5NjY1OCxcbiAgICAtMTQuMTg1MDMzMzMsIDQuMjc3Mjk4NTcsIDIuODI5NTY2MDQsXG4gIF07XG4gIGNvbnN0IGtiID0gW1xuICAgIDAuMTA2NjczMzAsIDEyLjY0MTk0NjA4LCAtNjAuNTgyMDQ4MzYsXG4gICAgMTEwLjM2Mjc2NzcxLCAtODkuOTAzMTA5MTIsIDI3LjM0ODI0OTczLFxuICBdO1xuXG4gIGNvbnN0IHh0ID0gc2F0dXJhdGUoIHggKTtcbiAgY29uc3QgeHYgPSBbXG4gICAgMS4wLFxuICAgIHh0LFxuICAgIHh0ICogeHQsXG4gICAgeHQgKiB4dCAqIHh0LFxuICAgIHh0ICogeHQgKiB4dCAqIHh0LFxuICAgIHh0ICogeHQgKiB4dCAqIHh0ICogeHQsXG4gIF07XG5cbiAgY29uc3QgY29sID0gW1xuICAgIHNhdHVyYXRlKCB2ZWNEb3QoIGtyLCB4diApICksXG4gICAgc2F0dXJhdGUoIHZlY0RvdCgga2csIHh2ICkgKSxcbiAgICBzYXR1cmF0ZSggdmVjRG90KCBrYiwgeHYgKSApLFxuICBdO1xuXG4gIHJldHVybiBjb2wgYXMgUmF3UkdCO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdSR0IgfSBmcm9tICcuL1Jhd1JHQic7XG5cbi8qKlxuICogRU9URiBvZiBSZWMuNzA5IGEuay5hLiBzUkdCLXRvLUxpbmVhclxuICovXG5leHBvcnQgZnVuY3Rpb24gZW90ZlJlYzcwOSggdmFsdWU6IFJhd1JHQiApOiBSYXdSR0Ige1xuICByZXR1cm4gdmFsdWUubWFwKCAoIHYgKSA9PiAoXG4gICAgdiA8IDAuMDgxXG4gICAgICA/IHYgLyA0LjVcbiAgICAgIDogTWF0aC5wb3coICggdiArIDAuMDk5ICkgLyAxLjA5OSwgMS4wIC8gMC40NSApXG4gICkgKSBhcyBSYXdSR0I7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd1JHQiB9IGZyb20gJy4vUmF3UkdCJztcblxuLyoqXG4gKiBPRVRGIG9mIFJlYy43MDkgYS5rLmEuIExpbmVhci10by1zUkdCXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZXRmUmVjNzA5KCBsdW1pbmFuY2U6IFJhd1JHQiApOiBSYXdSR0Ige1xuICByZXR1cm4gbHVtaW5hbmNlLm1hcCggKCBsICkgPT4gKFxuICAgIGwgPCAwLjAxOFxuICAgICAgPyA0LjUgKiBsXG4gICAgICA6IDEuMDk5ICogTWF0aC5wb3coIGwsIDAuNDUgKSAtIDAuMDk5XG4gICkgKSBhcyBSYXdSR0I7XG59XG4iLCJpbXBvcnQgeyBSYXdEYWdFZGdlIH0gZnJvbSAnLi9SYXdEYWdFZGdlJztcblxuLyoqXG4gKiBSZXR1cm4gYWxsIHBhcmVudCBzb3VyY2VzIHRoZSBzcGVjaWZpZWQgZGVzdGluYXRpb24gaGFzLlxuICogQHBhcmFtIGVkZ2VzIEFuIGFycmF5IG9mIGRhZyBlZGdlXG4gKiBAcGFyYW0gZGVzdGluYXRpb24gVGhlIHRhcmdldCBkZXN0aW5hdGlvblxuICpcbiAqIFNlZSBhbHNvOiB7QGxpbmsgZGFnRWRnZXNDaGlsZHJlbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhZ0VkZ2VzUGFyZW50czxUPiggZWRnZXM6IFJhd0RhZ0VkZ2U8VD5bXSwgZGVzdGluYXRpb246IFQgKTogVFtdIHtcbiAgcmV0dXJuIGVkZ2VzXG4gICAgLmZpbHRlciggKCBlZGdlICkgPT4gZWRnZVsgMSBdID09PSBkZXN0aW5hdGlvbiApXG4gICAgLm1hcCggKCBlZGdlICkgPT4gZWRnZVsgMCBdICk7XG59XG4iLCJpbXBvcnQgeyBkYWdFZGdlc1BhcmVudHMgfSBmcm9tICcuL2RhZ0VkZ2VzUGFyZW50cyc7XG5pbXBvcnQgeyB0cmF2ZXJzZSB9IGZyb20gJy4uL2FsZ29yaXRobS90cmF2ZXJzZSc7XG5pbXBvcnQgdHlwZSB7IFJhd0RhZ0VkZ2UgfSBmcm9tICcuL1Jhd0RhZ0VkZ2UnO1xuXG4vKipcbiAqIFJldHVybiBhbGwgYW5jZXN0b3Igc291cmNlcyB0aGUgc3BlY2lmaWVkIGRlc3RpbmF0aW9uIGhhcy5cbiAqIEBwYXJhbSBlZGdlcyBBbiBhcnJheSBvZiBkYWcgZWRnZVxuICogQHBhcmFtIGRlc3RpbmF0aW9uIFRoZSB0YXJnZXQgZGVzdGluYXRpb25cbiAqXG4gKiBTZWUgYWxzbzoge0BsaW5rIGRhZ0VkZ2VzQ2hpbGRyZW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYWdFZGdlc0FuY2VzdG9yczxUPiggZWRnZXM6IFJhd0RhZ0VkZ2U8VD5bXSwgZGVzdGluYXRpb246IFQgKTogVFtdIHtcbiAgY29uc3QgYW5jZXN0b3JzID0gbmV3IFNldDxUPigpO1xuXG4gIHRyYXZlcnNlKCBkZXN0aW5hdGlvbiwgKCBub2RlICkgPT4ge1xuICAgIGNvbnN0IHBhcmVudHMgPSBkYWdFZGdlc1BhcmVudHMoIGVkZ2VzLCBub2RlICk7XG4gICAgcGFyZW50cy5tYXAoICggcGFyZW50ICkgPT4gYW5jZXN0b3JzLmFkZCggcGFyZW50ICkgKTtcbiAgICByZXR1cm4gcGFyZW50cztcbiAgfSApO1xuXG4gIHJldHVybiBBcnJheS5mcm9tKCBhbmNlc3RvcnMgKTtcbn1cbiIsImltcG9ydCB7IFJhd0RhZ0VkZ2UgfSBmcm9tICcuL1Jhd0RhZ0VkZ2UnO1xuXG4vKipcbiAqIFJldHVybiBhbGwgY2hpbGRyZW4gZGVzdGluYXRpb25zIHRoZSBzcGVjaWZpZWQgc291cmNlIGhhcy5cbiAqIEBwYXJhbSBlZGdlcyBBbiBhcnJheSBvZiBkYWcgZWRnZVxuICogQHBhcmFtIHNvdXJjZSBUaGUgdGFyZ2V0IHNvdXJjZVxuICpcbiAqIFNlZSBhbHNvOiB7QGxpbmsgZGFnRWRnZXNEZXNjZW5kYW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGFnRWRnZXNDaGlsZHJlbjxUPiggZWRnZXM6IFJhd0RhZ0VkZ2U8VD5bXSwgc291cmNlOiBUICk6IFRbXSB7XG4gIHJldHVybiBlZGdlc1xuICAgIC5maWx0ZXIoICggZWRnZSApID0+IGVkZ2VbIDAgXSA9PT0gc291cmNlIClcbiAgICAubWFwKCAoIGVkZ2UgKSA9PiBlZGdlWyAxIF0gKTtcbn1cbiIsImltcG9ydCB7IGRhZ0VkZ2VzQ2hpbGRyZW4gfSBmcm9tICcuL2RhZ0VkZ2VzQ2hpbGRyZW4nO1xuaW1wb3J0IHsgdHJhdmVyc2UgfSBmcm9tICcuLi9hbGdvcml0aG0vdHJhdmVyc2UnO1xuaW1wb3J0IHR5cGUgeyBSYXdEYWdFZGdlIH0gZnJvbSAnLi9SYXdEYWdFZGdlJztcblxuLyoqXG4gKiBSZXR1cm4gYWxsIGRlc2NlbmRhbnQgZGVzdGluYXRpb25zIHRoZSBzcGVjaWZpZWQgc291cmNlIGhhcy5cbiAqIEBwYXJhbSBlZGdlcyBBbiBhcnJheSBvZiBkYWcgZWRnZVxuICogQHBhcmFtIHNvdXJjZSBUaGUgdGFyZ2V0IHNvdXJjZVxuICpcbiAqIFNlZSBhbHNvOiB7QGxpbmsgZGFnRWRnZXNDaGlsZHJlbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhZ0VkZ2VzRGVzY2VuZGFudHM8VD4oIGVkZ2VzOiBSYXdEYWdFZGdlPFQ+W10sIHNvdXJjZTogVCApOiBUW10ge1xuICBjb25zdCBkZXNjZW5kYW50cyA9IG5ldyBTZXQ8VD4oKTtcblxuICB0cmF2ZXJzZSggc291cmNlLCAoIG5vZGUgKSA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBkYWdFZGdlc0NoaWxkcmVuKCBlZGdlcywgbm9kZSApO1xuICAgIGNoaWxkcmVuLm1hcCggKCBjaGlsZCApID0+IGRlc2NlbmRhbnRzLmFkZCggY2hpbGQgKSApO1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSApO1xuXG4gIHJldHVybiBBcnJheS5mcm9tKCBkZXNjZW5kYW50cyApO1xufVxuIiwiaW1wb3J0IHsgUmF3RGFnRWRnZSB9IGZyb20gJy4vUmF3RGFnRWRnZSc7XG5cbi8qKlxuICogUmV0dXJuIGZpcnN0IHBhcmVudCBzb3VyY2UgdGhlIHNwZWNpZmllZCBkZXN0aW5hdGlvbiBoYXMuXG4gKiBJZiBpdCBjYW4ndCBmaW5kIGEgcGFyZW50LCBpdCB3aWxsIHJldHVybiBgbnVsbGAgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0gZWRnZXMgQW4gYXJyYXkgb2YgZGFnIGVkZ2VcbiAqIEBwYXJhbSBkZXN0aW5hdGlvbiBUaGUgdGFyZ2V0IGRlc3RpbmF0aW9uXG4gKlxuICogU2VlIGFsc286IHtAbGluayBkYWdFZGdlc1BhcmVudHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYWdFZGdlc1BhcmVudDxUPiggZWRnZXM6IFJhd0RhZ0VkZ2U8VD5bXSwgZGVzdGluYXRpb246IFQgKTogVCB8IG51bGwge1xuICByZXR1cm4gZWRnZXMuZmluZCggKCBlZGdlICkgPT4gZWRnZVsgMSBdID09PSBkZXN0aW5hdGlvbiApPy5bIDAgXSA/PyBudWxsO1xufVxuIiwiaW1wb3J0IHsgUmF3RGFnRWRnZSB9IGZyb20gJy4vUmF3RGFnRWRnZSc7XG5pbXBvcnQgeyBkYWdFZGdlc1BhcmVudCB9IGZyb20gJy4vZGFnRWRnZXNQYXJlbnQnO1xuXG4vKipcbiAqIFJlc29sdmUgZGFnIGRlcGVuZGVuY3kgcmVsYXRpb25zaGlwIGFuZCBnaXZlIHlvdSBhIGNvcnJlY3Qgb3JkZXIuXG4gKlxuICogQHBhcmFtIGVkZ2VzIEFuIGFycmF5IG9mIGRhZyBlZGdlc1xuICogQHBhcmFtIG5vZGVzIEFuIGFycmF5IG9mIGRhZyBub2Rlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGFnRWRnZXNSZXNvbHZlPFQ+KCBlZGdlczogUmF3RGFnRWRnZTxUPltdLCBub2RlczogVFtdICk6IFRbXSB7XG4gIGNvbnN0IG9yZGVyOiBUW10gPSBbXTtcblxuICBjb25zdCBub2RlU2V0ID0gbmV3IFNldCggbm9kZXMgKTtcbiAgbGV0IHRlbXBFZGdlcyA9IGVkZ2VzLmNvbmNhdCgpO1xuXG4gIHdoaWxlICggdGVtcEVkZ2VzLmxlbmd0aCA+IDAgKSB7XG4gICAgbm9kZVNldC5mb3JFYWNoKCAoIG5vZGUgKSA9PiB7XG4gICAgICAvLyBpcyB0aGlzIGFuIGVudHJ5cG9pbnQ/XG4gICAgICBjb25zdCBoYXNQYXJlbnRzID0gZGFnRWRnZXNQYXJlbnQoIHRlbXBFZGdlcywgbm9kZSApICE9IG51bGw7XG5cbiAgICAgIGlmICggIWhhc1BhcmVudHMgKSB7XG4gICAgICAgIG5vZGVTZXQuZGVsZXRlKCBub2RlICk7XG4gICAgICAgIG9yZGVyLnB1c2goIG5vZGUgKTtcblxuICAgICAgICAvLyBkZWxldGUgdGhlIHN0cnVjdHVyZSBvZiB0ZW1wRWRnZXMgZnJvbSBlbnRyeXBvaW50IHNpZGVcbiAgICAgICAgdGVtcEVkZ2VzID0gdGVtcEVkZ2VzLmZpbHRlciggKCBbIHNyYyBdICkgPT4gKCBzcmMgIT09IG5vZGUgKSApO1xuICAgICAgfVxuICAgIH0gKTtcbiAgfVxuXG4gIHJldHVybiBvcmRlci5jb25jYXQoIEFycmF5LmZyb20oIG5vZGVTZXQgKSApO1xuICAvLyAgICAgICAgICAgICAgICAgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl4gdGVybWluYXRvciBub2Rlc1xufVxuIiwiLy8geW9pbmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvdGlueS1zZGYgKEJTRCAyLUNsYXVzZSlcbi8vIGltcGxlbWVudHMgaHR0cDovL3Blb3BsZS5jcy51Y2hpY2Fnby5lZHUvfnBmZi9wYXBlcnMvZHQucGRmXG5cbi8qKlxuICogQ29tcHV0ZSBhIG9uZSBkaW1lbnNpb25hbCBlZHQgZnJvbSB0aGUgc291cmNlIGRhdGEuXG4gKiBSZXR1cm5pbmcgZGlzdGFuY2Ugd2lsbCBiZSBzcXVhcmVkLlxuICogSW50ZW5kZWQgdG8gYmUgdXNlZCBpbnRlcm5hbGx5IGluIHtAbGluayBlZHQyZH0uXG4gKlxuICogQHBhcmFtIGRhdGEgRGF0YSBvZiB0aGUgc291cmNlXG4gKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiB0aGUgc291cmNlIGZyb20gYmVnaW5uaW5nXG4gKiBAcGFyYW0gc3RyaWRlIFN0cmlkZSBvZiB0aGUgc291cmNlXG4gKiBAcGFyYW0gbGVuZ3RoIExlbmd0aCBvZiB0aGUgc291cmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZHQxZChcbiAgZGF0YTogRmxvYXQzMkFycmF5LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3RyaWRlOiBudW1iZXIsXG4gIGxlbmd0aDogbnVtYmVyXG4pOiB2b2lkIHtcbiAgLy8gaW5kZXggb2YgcmlnaHRtb3N0IHBhcmFib2xhIGluIGxvd2VyIGVudmVsb3BlXG4gIGxldCBrID0gMDtcblxuICAvLyBsb2NhdGlvbnMgb2YgcGFyYWJvbGFzIGluIGxvd2VyIGVudmVsb3BlXG4gIGNvbnN0IHYgPSBuZXcgRmxvYXQzMkFycmF5KCBsZW5ndGggKTtcbiAgdlsgMCBdID0gMC4wO1xuXG4gIC8vIGxvY2F0aW9ucyBvZiBib3VuZGFyaWVzIGJldHdlZW4gcGFyYWJvbGFzXG4gIGNvbnN0IHogPSBuZXcgRmxvYXQzMkFycmF5KCBsZW5ndGggKyAxICk7XG4gIHpbIDAgXSA9IC1JbmZpbml0eTtcbiAgelsgMSBdID0gSW5maW5pdHk7XG5cbiAgLy8gY3JlYXRlIGEgc3RyYWlnaHQgYXJyYXkgb2YgaW5wdXQgZGF0YVxuICBjb25zdCBmID0gbmV3IEZsb2F0MzJBcnJheSggbGVuZ3RoICk7XG4gIGZvciAoIGxldCBxID0gMDsgcSA8IGxlbmd0aDsgcSArKyApIHtcbiAgICBmWyBxIF0gPSBkYXRhWyBvZmZzZXQgKyBxICogc3RyaWRlIF07XG4gIH1cblxuICAvLyBjb21wdXRlIGxvd2VyIGVudmVsb3BlXG4gIGZvciAoIGxldCBxID0gMTsgcSA8IGxlbmd0aDsgcSArKyApIHtcbiAgICBsZXQgcyA9IDAuMDtcblxuICAgIHdoaWxlICggMCA8PSBrICkge1xuICAgICAgcyA9ICggZlsgcSBdICsgcSAqIHEgLSBmWyB2WyBrIF0gXSAtIHZbIGsgXSAqIHZbIGsgXSApIC8gKCAyLjAgKiBxIC0gMi4wICogdlsgayBdICk7XG4gICAgICBpZiAoIHMgPD0gelsgayBdICkge1xuICAgICAgICBrIC0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgayArKztcbiAgICB2WyBrIF0gPSBxO1xuICAgIHpbIGsgXSA9IHM7XG4gICAgelsgayArIDEgXSA9IEluZmluaXR5O1xuICB9XG5cbiAgayA9IDA7XG5cbiAgLy8gZmlsbCBpbiB2YWx1ZXMgb2YgZGlzdGFuY2UgdHJhbnNmb3JtXG4gIGZvciAoIGxldCBxID0gMDsgcSA8IGxlbmd0aDsgcSArKyApIHtcbiAgICB3aGlsZSAoIHpbIGsgKyAxIF0gPCBxICkgeyBrICsrOyB9XG4gICAgY29uc3QgcVN1YlZLID0gcSAtIHZbIGsgXTtcbiAgICBkYXRhWyBvZmZzZXQgKyBxICogc3RyaWRlIF0gPSBmWyB2WyBrIF0gXSArIHFTdWJWSyAqIHFTdWJWSztcbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGUgYSB0d28gZGltZW5zaW9uYWwgZWR0IGZyb20gdGhlIHNvdXJjZSBkYXRhLlxuICogUmV0dXJuaW5nIGRpc3RhbmNlIHdpbGwgYmUgc3F1YXJlZC5cbiAqXG4gKiBAcGFyYW0gZGF0YSBEYXRhIG9mIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0gd2lkdGggV2lkdGggb2YgdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSBzb3VyY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZHQyZChcbiAgZGF0YTogRmxvYXQzMkFycmF5LFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlclxuKTogdm9pZCB7XG4gIGZvciAoIGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4ICsrICkge1xuICAgIGVkdDFkKCBkYXRhLCB4LCB3aWR0aCwgaGVpZ2h0ICk7XG4gIH1cblxuICBmb3IgKCBsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKysgKSB7XG4gICAgZWR0MWQoIGRhdGEsIHkgKiB3aWR0aCwgMSwgd2lkdGggKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgbGVycCB9IGZyb20gJy4uL21hdGgvdXRpbHMnO1xuXG4vKipcbiAqIERvIGV4cCBzbW9vdGhpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIEV4cFNtb290aCB7XG4gIHB1YmxpYyBmYWN0b3IgPSAxMC4wO1xuICBwdWJsaWMgdGFyZ2V0ID0gMC4wO1xuICBwdWJsaWMgdmFsdWUgPSAwLjA7XG5cbiAgcHVibGljIHVwZGF0ZSggZGVsdGFUaW1lOiBudW1iZXIgKTogbnVtYmVyIHtcbiAgICB0aGlzLnZhbHVlID0gbGVycCggdGhpcy50YXJnZXQsIHRoaXMudmFsdWUsIE1hdGguZXhwKCAtdGhpcy5mYWN0b3IgKiBkZWx0YVRpbWUgKSApO1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG59XG4iLCJleHBvcnQgY2xhc3MgUG9vbDxUPiB7XG4gIHB1YmxpYyBhcnJheTogVFtdO1xuXG4gIHB1YmxpYyBpbmRleCA9IDA7XG5cbiAgcHVibGljIGdldCBjdXJyZW50KCk6IFQge1xuICAgIHJldHVybiB0aGlzLmFycmF5WyB0aGlzLmluZGV4IF07XG4gIH1cblxuICBwdWJsaWMgY29uc3RydWN0b3IoIGFycmF5OiBUW10gKSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgcHVibGljIG5leHQoKTogVCB7XG4gICAgdGhpcy5pbmRleCA9ICggdGhpcy5pbmRleCArIDEgKSAlIHRoaXMuYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IFBvb2wgfSBmcm9tICcuLi9Qb29sL1Bvb2wnO1xuXG5leHBvcnQgY2xhc3MgR1BVVGltZXIge1xuICBwdWJsaWMgcXVlcmllczogUG9vbDxXZWJHTFF1ZXJ5PjtcbiAgcHVibGljIHN0YWNrOiBQcm9taXNlPG51bWJlcj5bXTtcbiAgcHVibGljIGV4dDogYW55O1xuICBwdWJsaWMgcmVhZG9ubHkgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG5cbiAgcHJpdmF0ZSBfX2xvb3BUYXNrczogU2V0PCgpID0+IHZvaWQ+O1xuXG4gIHB1YmxpYyBzdGF0aWMgaXNTdXBwb3J0ZWQoIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBuZXcgU2V0KCBnbC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCkgKS5oYXMoICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJyApO1xuICB9XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCApIHtcbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICBjb25zdCBxdWVyaWVzID0gbmV3IEFycmF5KCAxMDI0ICkuZmlsbCggMSApLm1hcCggKCkgPT4gZ2wuY3JlYXRlUXVlcnkoKSEgKTtcbiAgICB0aGlzLnF1ZXJpZXMgPSBuZXcgUG9vbCggcXVlcmllcyApO1xuXG4gICAgdGhpcy5zdGFjayA9IFtdO1xuXG4gICAgdGhpcy5leHQgPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJyApO1xuXG4gICAgdGhpcy5fX2xvb3BUYXNrcyA9IG5ldyBTZXQoKTtcblxuICAgIC8vIGxvb3BcbiAgICBjb25zdCB1cGRhdGUgPSAoKTogdm9pZCA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB1cGRhdGUgKTtcbiAgICB9O1xuICAgIHVwZGF0ZSgpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICBBcnJheS5mcm9tKCB0aGlzLl9fbG9vcFRhc2tzICkuZm9yRWFjaCggKCB0YXNrICkgPT4gdGFzaygpICk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgbWVhc3VyZSggZnVuYzogKCkgPT4gdm9pZCApOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG5cbiAgICBpZiAoIHRoaXMuc3RhY2subGVuZ3RoICE9PSAwICkge1xuICAgICAgZ2wuZW5kUXVlcnkoIHRoaXMuZXh0LlRJTUVfRUxBUFNFRF9FWFQgKTtcbiAgICAgIGNvbnN0IHByb21pc2VGaW5pc2hpbmdQcmV2ID0gdGhpcy5jaGVjayggdGhpcy5xdWVyaWVzLmN1cnJlbnQgKTtcblxuICAgICAgdGhpcy5zdGFjayA9IHRoaXMuc3RhY2subWFwKCBhc3luYyAoIHByb21pc2VBY2N1bSApID0+IHtcbiAgICAgICAgcmV0dXJuICggYXdhaXQgcHJvbWlzZUFjY3VtICkgKyAoIGF3YWl0IHByb21pc2VGaW5pc2hpbmdQcmV2ICk7XG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5wdXNoKCBQcm9taXNlLnJlc29sdmUoIDAuMCApICk7XG5cbiAgICBnbC5iZWdpblF1ZXJ5KCB0aGlzLmV4dC5USU1FX0VMQVBTRURfRVhULCB0aGlzLnF1ZXJpZXMubmV4dCgpICk7XG5cbiAgICBmdW5jKCk7XG5cbiAgICBnbC5lbmRRdWVyeSggdGhpcy5leHQuVElNRV9FTEFQU0VEX0VYVCApO1xuXG4gICAgY29uc3QgcHJvbWlzZUFjY3VtID0gdGhpcy5zdGFjay5wb3AoKSE7XG4gICAgY29uc3QgcHJvbWlzZVRoaXMgPSB0aGlzLmNoZWNrKCB0aGlzLnF1ZXJpZXMuY3VycmVudCApO1xuXG4gICAgaWYgKCB0aGlzLnN0YWNrLmxlbmd0aCAhPT0gMCApIHtcbiAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLm1hcCggYXN5bmMgKCBwcm9taXNlQWNjdW0gKSA9PiB7XG4gICAgICAgIHJldHVybiAoIGF3YWl0IHByb21pc2VBY2N1bSApICsgKCBhd2FpdCBwcm9taXNlVGhpcyApO1xuICAgICAgfSApO1xuXG4gICAgICBnbC5iZWdpblF1ZXJ5KCB0aGlzLmV4dC5USU1FX0VMQVBTRURfRVhULCB0aGlzLnF1ZXJpZXMubmV4dCgpICk7XG4gICAgfVxuXG4gICAgcmV0dXJuICggYXdhaXQgcHJvbWlzZUFjY3VtICkgKyAoIGF3YWl0IHByb21pc2VUaGlzICk7XG4gIH1cblxuICBwdWJsaWMgY2hlY2soIHF1ZXJ5OiBXZWJHTFF1ZXJ5ICk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSggKCByZXNvbHZlICkgPT4ge1xuICAgICAgY29uc3QgdGFzayA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgaXNBdmFpbGFibGUgPSBnbC5nZXRRdWVyeVBhcmFtZXRlciggcXVlcnksIGdsLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUgKTtcblxuICAgICAgICBpZiAoIGlzQXZhaWxhYmxlICkge1xuICAgICAgICAgIHRoaXMuX19sb29wVGFza3MuZGVsZXRlKCB0YXNrICk7XG4gICAgICAgICAgcmVzb2x2ZSggZ2wuZ2V0UXVlcnlQYXJhbWV0ZXIoIHF1ZXJ5LCBnbC5RVUVSWV9SRVNVTFQgKSAqIDAuMDAxICogMC4wMDEgKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fX2xvb3BUYXNrcy5hZGQoIHRhc2sgKTtcbiAgICB9ICk7XG4gIH1cbn1cbiIsIi8qKlxuICogVXNlZnVsIGZvciB0YXAgdGVtcG9cbiAqIFNlZSBhbHNvOiB7QGxpbmsgSGlzdG9yeU1lYW5DYWxjdWxhdG9yfVxuICovXG5leHBvcnQgY2xhc3MgSGlzdG9yeU1lYW5DYWxjdWxhdG9yIHtcbiAgcHJpdmF0ZSBfX3JlY2FsY0ZvckVhY2ggPSAwO1xuICBwcml2YXRlIF9fY291bnRVbnRpbFJlY2FsYyA9IDA7XG4gIHByaXZhdGUgX19oaXN0b3J5OiBudW1iZXJbXSA9IFtdO1xuICBwcml2YXRlIF9faW5kZXggPSAwO1xuICBwcml2YXRlIF9fbGVuZ3RoOiBudW1iZXI7XG4gIHByaXZhdGUgX19jb3VudCA9IDA7XG4gIHByaXZhdGUgX19jYWNoZSA9IDA7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBsZW5ndGg6IG51bWJlciApIHtcbiAgICB0aGlzLl9fbGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX19yZWNhbGNGb3JFYWNoID0gbGVuZ3RoO1xuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcbiAgICAgIHRoaXMuX19oaXN0b3J5WyBpIF0gPSAwO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgbWVhbigpOiBudW1iZXIge1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4oIHRoaXMuX19jb3VudCwgdGhpcy5fX2xlbmd0aCApO1xuICAgIHJldHVybiBjb3VudCA9PT0gMCA/IDAuMCA6IHRoaXMuX19jYWNoZSAvIGNvdW50O1xuICB9XG5cbiAgcHVibGljIGdldCByZWNhbGNGb3JFYWNoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX19yZWNhbGNGb3JFYWNoO1xuICB9XG5cbiAgcHVibGljIHNldCByZWNhbGNGb3JFYWNoKCB2YWx1ZTogbnVtYmVyICkge1xuICAgIGNvbnN0IGRlbHRhID0gdmFsdWUgLSB0aGlzLl9fcmVjYWxjRm9yRWFjaDtcbiAgICB0aGlzLl9fcmVjYWxjRm9yRWFjaCA9IHZhbHVlO1xuICAgIHRoaXMuX19jb3VudFVudGlsUmVjYWxjID0gTWF0aC5tYXgoIDAsIHRoaXMuX19jb3VudFVudGlsUmVjYWxjICsgZGVsdGEgKTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLl9faW5kZXggPSAwO1xuICAgIHRoaXMuX19jb3VudCA9IDA7XG4gICAgdGhpcy5fX2NhY2hlID0gMDtcbiAgICB0aGlzLl9fY291bnRVbnRpbFJlY2FsYyA9IDA7XG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5fX2xlbmd0aDsgaSArKyApIHtcbiAgICAgIHRoaXMuX19oaXN0b3J5WyBpIF0gPSAwO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBwdXNoKCB2YWx1ZTogbnVtYmVyICk6IHZvaWQge1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLl9faGlzdG9yeVsgdGhpcy5fX2luZGV4IF07XG4gICAgdGhpcy5fX2hpc3RvcnlbIHRoaXMuX19pbmRleCBdID0gdmFsdWU7XG4gICAgdGhpcy5fX2NvdW50ICsrO1xuICAgIHRoaXMuX19pbmRleCA9ICggdGhpcy5fX2luZGV4ICsgMSApICUgdGhpcy5fX2xlbmd0aDtcblxuICAgIGlmICggdGhpcy5fX2NvdW50VW50aWxSZWNhbGMgPT09IDAgKSB7XG4gICAgICB0aGlzLnJlY2FsYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fY291bnRVbnRpbFJlY2FsYyAtLTtcbiAgICAgIHRoaXMuX19jYWNoZSAtPSBwcmV2O1xuICAgICAgdGhpcy5fX2NhY2hlICs9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZWNhbGMoKTogdm9pZCB7XG4gICAgdGhpcy5fX2NvdW50VW50aWxSZWNhbGMgPSB0aGlzLl9fcmVjYWxjRm9yRWFjaDtcbiAgICBjb25zdCBzdW0gPSB0aGlzLl9faGlzdG9yeVxuICAgICAgLnNsaWNlKCAwLCBNYXRoLm1pbiggdGhpcy5fX2NvdW50LCB0aGlzLl9fbGVuZ3RoICkgKVxuICAgICAgLnJlZHVjZSggKCBzdW0sIHYgKSA9PiBzdW0gKyB2LCAwICk7XG4gICAgdGhpcy5fX2NhY2hlID0gc3VtO1xuICB9XG59XG4iLCJpbXBvcnQgeyBiaW5hcnlTZWFyY2ggfSBmcm9tICcuLi9hbGdvcml0aG0vYmluYXJ5U2VhcmNoJztcblxuLyoqXG4gKiBVc2VmdWwgZm9yIGZwcyBjYWxjXG4gKiBTZWUgYWxzbzoge0BsaW5rIEhpc3RvcnlNZWFuQ2FsY3VsYXRvcn1cbiAqL1xuZXhwb3J0IGNsYXNzIEhpc3RvcnlQZXJjZW50aWxlQ2FsY3VsYXRvciB7XG4gIHByaXZhdGUgX19oaXN0b3J5OiBudW1iZXJbXSA9IFtdO1xuICBwcml2YXRlIF9fc29ydGVkOiBudW1iZXJbXSA9IFtdO1xuICBwcml2YXRlIF9faW5kZXggPSAwO1xuICBwcml2YXRlIHJlYWRvbmx5IF9fbGVuZ3RoOiBudW1iZXI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBsZW5ndGg6IG51bWJlciApIHtcbiAgICB0aGlzLl9fbGVuZ3RoID0gbGVuZ3RoO1xuICB9XG5cbiAgcHVibGljIGdldCBtZWRpYW4oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wZXJjZW50aWxlKCA1MC4wICk7XG4gIH1cblxuICBwdWJsaWMgcGVyY2VudGlsZSggcGVyY2VudGlsZTogbnVtYmVyICk6IG51bWJlciB7XG4gICAgaWYgKCB0aGlzLl9faGlzdG9yeS5sZW5ndGggPT09IDAgKSB7IHJldHVybiAwLjA7IH1cbiAgICByZXR1cm4gdGhpcy5fX3NvcnRlZFsgTWF0aC5yb3VuZCggcGVyY2VudGlsZSAqIDAuMDEgKiAoIHRoaXMuX19oaXN0b3J5Lmxlbmd0aCAtIDEgKSApIF07XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5fX2luZGV4ID0gMDtcbiAgICB0aGlzLl9faGlzdG9yeSA9IFtdO1xuICAgIHRoaXMuX19zb3J0ZWQgPSBbXTtcbiAgfVxuXG4gIHB1YmxpYyBwdXNoKCB2YWx1ZTogbnVtYmVyICk6IHZvaWQge1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLl9faGlzdG9yeVsgdGhpcy5fX2luZGV4IF07XG4gICAgdGhpcy5fX2hpc3RvcnlbIHRoaXMuX19pbmRleCBdID0gdmFsdWU7XG4gICAgdGhpcy5fX2luZGV4ID0gKCB0aGlzLl9faW5kZXggKyAxICkgJSB0aGlzLl9fbGVuZ3RoO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBwcmV2IGZyb20gc29ydGVkIGFycmF5XG4gICAgaWYgKCB0aGlzLl9fc29ydGVkLmxlbmd0aCA9PT0gdGhpcy5fX2xlbmd0aCApIHtcbiAgICAgIGNvbnN0IHByZXZJbmRleCA9IGJpbmFyeVNlYXJjaCggdGhpcy5fX3NvcnRlZCwgcHJldiApO1xuICAgICAgdGhpcy5fX3NvcnRlZC5zcGxpY2UoIHByZXZJbmRleCwgMSApO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gYmluYXJ5U2VhcmNoKCB0aGlzLl9fc29ydGVkLCB2YWx1ZSApO1xuICAgIHRoaXMuX19zb3J0ZWQuc3BsaWNlKCBpbmRleCwgMCwgdmFsdWUgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSGlzdG9yeVBlcmNlbnRpbGVDYWxjdWxhdG9yIH0gZnJvbSAnLi9IaXN0b3J5UGVyY2VudGlsZUNhbGN1bGF0b3InO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIEl0J3MgYWN0dWFsbHkganVzdCBhIHNwZWNpYWwgY2FzZSBvZiB7QGxpbmsgSGlzdG9yeVBlcmNlbnRpbGVDYWxjdWxhdG9yfVxuICovXG5leHBvcnQgY2xhc3MgSGlzdG9yeU1lZGlhbkNhbGN1bGF0b3IgZXh0ZW5kcyBIaXN0b3J5UGVyY2VudGlsZUNhbGN1bGF0b3Ige1xuICBwdWJsaWMgY29uc3RydWN0b3IoIGxlbmd0aDogbnVtYmVyICkge1xuICAgIHN1cGVyKCBsZW5ndGggKTtcbiAgICBjb25zb2xlLndhcm4oICdIaXN0b3J5TWVkaWFuQ2FsY3VsYXRvcjogRGVwcmVjYXRlZC4gVXNlIEhpc3RvcnlQZXJjZW50aWxlQ2FsY3VsYXRvciBpbnN0ZWFkJyApO1xuICB9XG59XG4iLCJleHBvcnQgY2xhc3MgTWFwT2ZTZXQ8SywgVj4ge1xuICBwdWJsaWMgcmVhZG9ubHkgbWFwOiBNYXA8SywgU2V0PFY+PjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0KCBrZXk6IEsgKTogU2V0PFY+IHtcbiAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KCBrZXkgKSA/PyBuZXcgU2V0KCk7XG4gIH1cblxuICBwdWJsaWMgYWRkKCBrZXk6IEssIHZhbHVlOiBWICk6IHZvaWQge1xuICAgIGxldCBzZXQgPSB0aGlzLm1hcC5nZXQoIGtleSApO1xuICAgIGlmICggc2V0ID09IG51bGwgKSB7XG4gICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLm1hcC5zZXQoIGtleSwgc2V0ICk7XG4gICAgfVxuICAgIHNldC5hZGQoIHZhbHVlICk7XG4gIH1cbn1cbiIsIi8qKlxuICogUmV0dXJuIGEgdmVjdG9yIHdpdGggdGhlIGFic29sdXRlIG9mIGVhY2ggY29tcG9uZW50IG9mIHRoZSBnaXZlbiB2ZWN0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWNBYnM8VCBleHRlbmRzIG51bWJlcltdPiggdmVjOiBUICk6IFQge1xuICByZXR1cm4gdmVjLm1hcCggKCB2ICkgPT4gTWF0aC5hYnMoIHYgKSApIGFzIFQ7XG59XG4iLCIvKipcbiAqIFJldHVybiBhIHN1bSBvZiB2ZWN0b3JzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVjQWRkPFQgZXh0ZW5kcyBudW1iZXJbXT4oIC4uLnZlY3M6IFRbXSApOiBUIHtcbiAgaWYgKCB2ZWNzLmxlbmd0aCA8IDIgKSB7XG4gICAgcmV0dXJuIHZlY3NbIDAgXTtcbiAgfVxuXG4gIGNvbnN0IGEgPSB2ZWNzLnNoaWZ0KCkhO1xuICBjb25zdCBiID0gdmVjQWRkKCAuLi52ZWNzICk7XG5cbiAgcmV0dXJuIGEubWFwKCAoIHYsIGkgKSA9PiB2ICsgYlsgaSBdICkgYXMgVDtcbn1cbiIsIi8qKlxuICogRGl2aWRlIGEgdmVjdG9yIGJ5IGEgdmVjdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVjRGl2aWRlPFQgZXh0ZW5kcyBudW1iZXJbXT4oIHZlY0E6IFQsIHZlY0I6IFQgKTogVCB7XG4gIHJldHVybiB2ZWNBLm1hcCggKCB2LCBpICkgPT4gdiAvIHZlY0JbIGkgXSApIGFzIFQ7XG59XG4iLCIvKipcbiAqIFJldHVybiBhbiBldWNsaWRlYW4gbGVuZ3RoIG9mIGdpdmVuIHZlY3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlY0xlbmd0aDxUIGV4dGVuZHMgbnVtYmVyW10+KCB2ZWM6IFQgKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguc3FydCggdmVjLnJlZHVjZSggKCBzdW0sIHYgKSA9PiBzdW0gKyB2ICogdiwgMC4wICkgKTtcbn1cbiIsIi8qKlxuICogUmV0dXJuIGFuIHNxdWFyZWQgZXVjbGlkZWFuIGxlbmd0aCBvZiBnaXZlbiB2ZWN0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWNMZW5ndGhTcTxUIGV4dGVuZHMgbnVtYmVyW10+KCB2ZWM6IFQgKTogbnVtYmVyIHtcbiAgcmV0dXJuIHZlYy5yZWR1Y2UoICggc3VtLCB2ICkgPT4gc3VtICsgdiAqIHYsIDAuMCApO1xufVxuIiwiLyoqXG4gKiBSZXR1cm4gYSBtYW5oYXR0YW4gbGVuZ3RoIG9mIGdpdmVuIHZlY3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlY01hbmhhdHRhbkxlbmd0aDxUIGV4dGVuZHMgbnVtYmVyW10+KCB2ZWM6IFQgKTogbnVtYmVyIHtcbiAgcmV0dXJuIHZlYy5yZWR1Y2UoICggc3VtLCB2ICkgPT4gc3VtICsgTWF0aC5hYnMoIHYgKSwgMC4wICk7XG59XG4iLCIvKipcbiAqIFJldHVybiBhIHByb2R1Y3Qgb2YgdmVjdG9ycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlY011bHRpcGx5PFQgZXh0ZW5kcyBudW1iZXJbXT4oIC4uLnZlY3M6IFRbXSApOiBUIHtcbiAgaWYgKCB2ZWNzLmxlbmd0aCA8IDIgKSB7XG4gICAgcmV0dXJuIHZlY3NbIDAgXTtcbiAgfVxuXG4gIGNvbnN0IGEgPSB2ZWNzLnNoaWZ0KCkhO1xuICBjb25zdCBiID0gdmVjTXVsdGlwbHkoIC4uLnZlY3MgKTtcblxuICByZXR1cm4gYS5tYXAoICggdiwgaSApID0+IHYgKiBiWyBpIF0gKSBhcyBUO1xufVxuIiwiLyoqXG4gKiBOZWdhdGUgYSB2ZWN0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWNOZWc8VCBleHRlbmRzIG51bWJlcltdPiggdmVjOiBUICk6IFQge1xuICByZXR1cm4gdmVjLm1hcCggKCB2ICkgPT4gLXYgKSBhcyBUO1xufVxuIiwiLyoqXG4gKiBTY2FsZSB0aGUgZ2l2ZW4gdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVjU2NhbGU8VCBleHRlbmRzIG51bWJlcltdPiggdmVjOiBULCBzY2FsYXI6IG51bWJlciApOiBUIHtcbiAgcmV0dXJuIHZlYy5tYXAoICggdiApID0+IHYgKiBzY2FsYXIgKSBhcyBUO1xufVxuIiwiaW1wb3J0IHsgdmVjTGVuZ3RoIH0gZnJvbSAnLi92ZWNMZW5ndGgnO1xuaW1wb3J0IHsgdmVjU2NhbGUgfSBmcm9tICcuL3ZlY1NjYWxlJztcblxuLyoqXG4gKiBOb3JtYWxpemUgZ2l2ZW4gdmVjdG9yLlxuICogSWYgdGhlIGxlbmd0aCBvZiBnaXZlbiB2ZWN0b3IgaXMgMC4wLCBpdCB3aWxsIHJldHVybiBhIHplcm8gdmVjdG9yIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWNOb3JtYWxpemU8VCBleHRlbmRzIG51bWJlcltdPiggdmVjOiBUICk6IFQge1xuICBjb25zdCBsZW4gPSB2ZWNMZW5ndGgoIHZlYyApO1xuICBjb25zdCBpbnZMZW4gPSBsZW4gPT09IDAuMCA/IDAuMCA6IDEuMCAvIGxlbjtcbiAgcmV0dXJuIHZlY1NjYWxlKCB2ZWMsIGludkxlbiApO1xufVxuIiwiLyoqXG4gKiBTdWJ0cmFjdCBhIHZlY3RvciBmcm9tIGEgdmVjdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVjU3ViPFQgZXh0ZW5kcyBudW1iZXJbXT4oIHZlY0E6IFQsIHZlY0I6IFQgKTogVCB7XG4gIHJldHVybiB2ZWNBLm1hcCggKCB2LCBpICkgPT4gdiAtIHZlY0JbIGkgXSApIGFzIFQ7XG59XG4iLCJpbXBvcnQgeyB2ZWNBYnMgfSBmcm9tICcuL3ZlY0Ficyc7XG5pbXBvcnQgeyB2ZWNBZGQgfSBmcm9tICcuL3ZlY0FkZCc7XG5pbXBvcnQgeyB2ZWNEaXZpZGUgfSBmcm9tICcuL3ZlY0RpdmlkZSc7XG5pbXBvcnQgeyB2ZWNEb3QgfSBmcm9tICcuL3ZlY0RvdCc7XG5pbXBvcnQgeyB2ZWNMZW5ndGggfSBmcm9tICcuL3ZlY0xlbmd0aCc7XG5pbXBvcnQgeyB2ZWNMZW5ndGhTcSB9IGZyb20gJy4vdmVjTGVuZ3RoU3EnO1xuaW1wb3J0IHsgdmVjTWFuaGF0dGFuTGVuZ3RoIH0gZnJvbSAnLi92ZWNNYW5oYXR0YW5MZW5ndGgnO1xuaW1wb3J0IHsgdmVjTXVsdGlwbHkgfSBmcm9tICcuL3ZlY011bHRpcGx5JztcbmltcG9ydCB7IHZlY05lZyB9IGZyb20gJy4vdmVjTmVnJztcbmltcG9ydCB7IHZlY05vcm1hbGl6ZSB9IGZyb20gJy4vdmVjTm9ybWFsaXplJztcbmltcG9ydCB7IHZlY1NjYWxlIH0gZnJvbSAnLi92ZWNTY2FsZSc7XG5pbXBvcnQgeyB2ZWNTdWIgfSBmcm9tICcuL3ZlY1N1Yic7XG5cbi8qKlxuICogQSBWZWN0b3IuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBWZWN0b3I8VCBleHRlbmRzIFZlY3RvcjxUPj4ge1xuICBwdWJsaWMgYWJzdHJhY3QgZWxlbWVudHM6IG51bWJlcltdO1xuXG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoaXMuXG4gICAqIGEuay5hLiBgbWFnbml0dWRlYFxuICAgKi9cbiAgcHVibGljIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdmVjTGVuZ3RoKCB0aGlzLmVsZW1lbnRzICk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGxlbmd0aFNxKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHZlY0xlbmd0aFNxKCB0aGlzLmVsZW1lbnRzICk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1hbmhhdHRhbiBsZW5ndGggb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgbWFuaGF0dGFuTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHZlY01hbmhhdHRhbkxlbmd0aCggdGhpcy5lbGVtZW50cyApO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbm9ybWFsaXplZCBWZWN0b3IzIG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IG5vcm1hbGl6ZWQoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuX19uZXcoIHZlY05vcm1hbGl6ZSggdGhpcy5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBidXQgbmVnYXRlZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgbmVnYXRlZCgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fX25ldyggdmVjTmVnKCB0aGlzLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGJ1dCBlYWNoIGNvbXBvbmVudCBpcyB0aGUgYWJzb2x1dGUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFicygpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fX25ldyggdmVjQWJzKCB0aGlzLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZSB0aGlzLlxuICAgKi9cbiAgcHVibGljIGNsb25lKCk6IFQge1xuICAgIHJldHVybiB0aGlzLl9fbmV3KCB0aGlzLmVsZW1lbnRzLmNvbmNhdCgpICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIG9uZSBvciBtb3JlIFZlY3RvciBpbnRvIHRoaXMuXG4gICAqIEBwYXJhbSB2ZWN0b3JzIE90aGVyIFZlY3RvcnNcbiAgICovXG4gIHB1YmxpYyBhZGQoIC4uLnZlY3RvcnM6IFRbXSApOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fX25ldyggdmVjQWRkKCB0aGlzLmVsZW1lbnRzLCAuLi52ZWN0b3JzLm1hcCggKCB2ICkgPT4gdi5lbGVtZW50cyApICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzdHJhY3QgdGhpcyBmcm9tIGFub3RoZXIgVmVjdG9yLlxuICAgKiBAcGFyYW0gdiBBbm90aGVyIHZlY3RvclxuICAgKi9cbiAgcHVibGljIHN1YiggdmVjdG9yOiBUICk6IFQge1xuICAgIHJldHVybiB0aGlzLl9fbmV3KCB2ZWNTdWIoIHRoaXMuZWxlbWVudHMsIHZlY3Rvci5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgb25lIG9yIG1vcmUgVmVjdG9yIHdpdGggdGhpcy5cbiAgICogQHBhcmFtIHZlY3RvcnMgT3RoZXIgVmVjdG9yc1xuICAgKi9cbiAgcHVibGljIG11bHRpcGx5KCAuLi52ZWN0b3JzOiBUW10gKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuX19uZXcoIHZlY011bHRpcGx5KCB0aGlzLmVsZW1lbnRzLCAuLi52ZWN0b3JzLm1hcCggKCB2ICkgPT4gdi5lbGVtZW50cyApICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGUgdGhpcyBmcm9tIGFub3RoZXIgVmVjdG9yLlxuICAgKiBAcGFyYW0gdmVjdG9yIEFub3RoZXIgVmVjdG9yXG4gICAqL1xuICBwdWJsaWMgZGl2aWRlKCB2ZWN0b3I6IFQgKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuX19uZXcoIHZlY0RpdmlkZSggdGhpcy5lbGVtZW50cywgdmVjdG9yLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGlzIGJ5IHNjYWxhci5cbiAgICogYS5rLmEuIGBtdWx0aXBseVNjYWxhcmBcbiAgICogQHBhcmFtIHNjYWxhciBBIHNjYWxhclxuICAgKi9cbiAgcHVibGljIHNjYWxlKCBzY2FsYXI6IG51bWJlciApOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fX25ldyggdmVjU2NhbGUoIHRoaXMuZWxlbWVudHMsIHNjYWxhciApICk7XG4gIH1cblxuICAvKipcbiAgICogRG90IHR3byBWZWN0b3JzLlxuICAgKiBAcGFyYW0gdmVjdG9yIEFub3RoZXIgdmVjdG9yXG4gICAqL1xuICBwdWJsaWMgZG90KCB2ZWN0b3I6IFQgKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdmVjRG90KCB0aGlzLmVsZW1lbnRzLCB2ZWN0b3IuZWxlbWVudHMgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfX25ldyggdjogbnVtYmVyW10gKTogVDtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4uL21hdDQnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3I0IH0gZnJvbSAnLi9SYXdWZWN0b3I0JztcblxuLyoqXG4gKiBNdWx0aXBseSBhIHZlYzQgYnkgYSBtYXQ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVjNEFwcGx5TWF0cml4NCggdjogUmF3VmVjdG9yNCwgbTogUmF3TWF0cml4NCApOiBSYXdWZWN0b3I0IHtcbiAgcmV0dXJuIFtcbiAgICBtWyAwIF0gKiB2WyAwIF0gKyBtWyA0IF0gKiB2WyAxIF0gKyBtWyA4IF0gKiB2WyAyIF0gKyBtWyAxMiBdICogdlsgMyBdLFxuICAgIG1bIDEgXSAqIHZbIDAgXSArIG1bIDUgXSAqIHZbIDEgXSArIG1bIDkgXSAqIHZbIDIgXSArIG1bIDEzIF0gKiB2WyAzIF0sXG4gICAgbVsgMiBdICogdlsgMCBdICsgbVsgNiBdICogdlsgMSBdICsgbVsgMTAgXSAqIHZbIDIgXSArIG1bIDE0IF0gKiB2WyAzIF0sXG4gICAgbVsgMyBdICogdlsgMCBdICsgbVsgNyBdICogdlsgMSBdICsgbVsgMTEgXSAqIHZbIDIgXSArIG1bIDE1IF0gKiB2WyAzIF0sXG4gIF07XG59XG4iLCJpbXBvcnQgeyB2ZWM0QXBwbHlNYXRyaXg0IH0gZnJvbSAnLi4vdmVjNC92ZWM0QXBwbHlNYXRyaXg0JztcbmltcG9ydCB7IHZlY1NjYWxlIH0gZnJvbSAnLi4vdmVjL3ZlY1NjYWxlJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4uL21hdDQvUmF3TWF0cml4NCc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIEFwcGx5IGEgdmVjMyAod2l0aCBhbiBpbXBsaWNpdCAxIGluIHRoZSA0dGggZGltZW5zaW9uKSBhIG1hdDQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWMzQXBwbHlNYXRyaXg0KCB2OiBSYXdWZWN0b3IzLCBtOiBSYXdNYXRyaXg0ICk6IFJhd1ZlY3RvcjMge1xuICBjb25zdCB2ZWM0ID0gdmVjNEFwcGx5TWF0cml4NCggWyAuLi52LCAxIF0sIG0gKTtcbiAgY29uc3QgeHl6OiBSYXdWZWN0b3IzID0gWyB2ZWM0WyAwIF0sIHZlYzRbIDEgXSwgdmVjNFsgMiBdIF07XG4gIGNvbnN0IHcgPSB2ZWM0WyAzIF07XG4gIHJldHVybiB2ZWNTY2FsZSggeHl6LCAxLjAgLyB3ICk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd1F1YXRlcm5pb24gfSBmcm9tICcuL1Jhd1F1YXRlcm5pb24nO1xuXG4vKipcbiAqIFJldHVybiBhbiBpbnZlcnNlIG9mIGEgcXVhdGVybmlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXRJbnZlcnNlKCBxdWF0OiBSYXdRdWF0ZXJuaW9uICk6IFJhd1F1YXRlcm5pb24ge1xuICByZXR1cm4gWyAtcXVhdFsgMCBdLCAtcXVhdFsgMSBdLCAtcXVhdFsgMiBdLCBxdWF0WyAzIF0gXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4vUmF3UXVhdGVybmlvbic7XG5cbi8qKlxuICogUmV0dXJuIGEgbXVsdGlwbGljYXRpb24gcmVzdWx0IG9mIHF1YXRlcm5pb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhdE11bHRpcGx5KCAuLi5xdWF0czogUmF3UXVhdGVybmlvbltdICk6IFJhd1F1YXRlcm5pb24ge1xuICBpZiAoIHF1YXRzLmxlbmd0aCA8IDIgKSB7XG4gICAgcmV0dXJuIHF1YXRzWyAwIF07XG4gIH1cblxuICBjb25zdCBhID0gcXVhdHMuc2hpZnQoKSE7XG4gIGNvbnN0IGIgPSBxdWF0TXVsdGlwbHkoIC4uLnF1YXRzICk7XG5cbiAgcmV0dXJuIFtcbiAgICBhWyAzIF0gKiBiWyAwIF0gKyBhWyAwIF0gKiBiWyAzIF0gKyBhWyAxIF0gKiBiWyAyIF0gLSBhWyAyIF0gKiBiWyAxIF0sXG4gICAgYVsgMyBdICogYlsgMSBdIC0gYVsgMCBdICogYlsgMiBdICsgYVsgMSBdICogYlsgMyBdICsgYVsgMiBdICogYlsgMCBdLFxuICAgIGFbIDMgXSAqIGJbIDIgXSArIGFbIDAgXSAqIGJbIDEgXSAtIGFbIDEgXSAqIGJbIDAgXSArIGFbIDIgXSAqIGJbIDMgXSxcbiAgICBhWyAzIF0gKiBiWyAzIF0gLSBhWyAwIF0gKiBiWyAwIF0gLSBhWyAxIF0gKiBiWyAxIF0gLSBhWyAyIF0gKiBiWyAyIF0sXG4gIF07XG59XG4iLCJpbXBvcnQgeyBxdWF0SW52ZXJzZSB9IGZyb20gJy4uL3F1YXQvcXVhdEludmVyc2UnO1xuaW1wb3J0IHsgcXVhdE11bHRpcGx5IH0gZnJvbSAnLi4vcXVhdC9xdWF0TXVsdGlwbHknO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vcXVhdC9SYXdRdWF0ZXJuaW9uJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4vUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogQXBwbHkgYSB2ZWMzICh3aXRoIGFuIGltcGxpY2l0IDEgaW4gdGhlIDR0aCBkaW1lbnNpb24pIGEgcXVhdGVybmlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlYzNBcHBseVF1YXRlcm5pb24oIHZlYzogUmF3VmVjdG9yMywgcXVhdDogUmF3UXVhdGVybmlvbiApOiBSYXdWZWN0b3IzIHtcbiAgY29uc3QgcDogUmF3UXVhdGVybmlvbiA9IFsgLi4udmVjLCAwLjAgXTtcbiAgY29uc3QgciA9IHF1YXRJbnZlcnNlKCBxdWF0ICk7XG4gIGNvbnN0IHJlcyA9IHF1YXRNdWx0aXBseSggcXVhdCwgcCwgciApO1xuICByZXMucG9wKCk7XG4gIHJldHVybiByZXMgYXMgdW5rbm93biBhcyBSYXdWZWN0b3IzO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBSZXR1cm4gYSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlYzNDcm9zcyggdmVjQTogUmF3VmVjdG9yMywgdmVjQjogUmF3VmVjdG9yMyApOiBSYXdWZWN0b3IzIHtcbiAgcmV0dXJuIFtcbiAgICB2ZWNBWyAxIF0gKiB2ZWNCWyAyIF0gLSB2ZWNBWyAyIF0gKiB2ZWNCWyAxIF0sXG4gICAgdmVjQVsgMiBdICogdmVjQlsgMCBdIC0gdmVjQVsgMCBdICogdmVjQlsgMiBdLFxuICAgIHZlY0FbIDAgXSAqIHZlY0JbIDEgXSAtIHZlY0FbIDEgXSAqIHZlY0JbIDAgXSxcbiAgXTtcbn1cbiIsImltcG9ydCB7IHZlYzNDcm9zcyB9IGZyb20gJy4vdmVjM0Nyb3NzJztcbmltcG9ydCB7IHZlY0RvdCB9IGZyb20gJy4uL3ZlYy92ZWNEb3QnO1xuaW1wb3J0IHsgdmVjTmVnIH0gZnJvbSAnLi4vdmVjL3ZlY05lZyc7XG5pbXBvcnQgeyB2ZWNOb3JtYWxpemUgfSBmcm9tICcuLi92ZWMvdmVjTm9ybWFsaXplJztcbmltcG9ydCB7IHZlY1NjYWxlIH0gZnJvbSAnLi4vdmVjL3ZlY1NjYWxlJztcbmltcG9ydCB7IHZlY1N1YiB9IGZyb20gJy4uL3ZlYy92ZWNTdWInO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBSZXR1cm4gYSB0YW5nZW50IHdoaWNoIGlzIG9ydGhvZ29uYWwgdG8gbm9ybWFsLlxuICogSWYgYmlub3JtYWwgaXMgc3BlY2lmaWVkLCBpdCBpcyBhbHNvIHJldHVybmVkIGFuZCBpdCdzIG9ydGhvZ29uYWwgdG8gYm90aCBub3JtYWwgYW5kIHRhbmdlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWMzT3J0aG9Ob3JtYWxpemUoXG4gIG5vcm1hbDogUmF3VmVjdG9yMyxcbiAgdGFuZ2VudDogUmF3VmVjdG9yMyA9IFsgMC4wLCAxLjAsIDAuMCBdLFxuICBiaW5vcm1hbD86IFJhd1ZlY3RvcjMsXG4pOiB7XG4gICAgbm9ybWFsOiBSYXdWZWN0b3IzLFxuICAgIHRhbmdlbnQ6IFJhd1ZlY3RvcjMsXG4gICAgYmlub3JtYWw6IFJhd1ZlY3RvcjMsXG4gIH0ge1xuICBjb25zdCBuID0gdmVjTm9ybWFsaXplKCBub3JtYWwgKTtcbiAgbGV0IHQgPSB2ZWNOb3JtYWxpemUoIHRhbmdlbnQgKTtcblxuICBsZXQgZG90TlQgPSB2ZWNEb3QoIG4sIHQgKTtcblxuICBpZiAoIGRvdE5UID09PSAxLjAgKSB7XG4gICAgaWYgKCBNYXRoLmFicyggblsgMSBdICkgPiBNYXRoLmFicyggblsgMiBdICkgKSB7XG4gICAgICB0ID0gWyAwLjAsIDAuMCwgMS4wIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHQgPSBbIDAuMCwgMS4wLCAwLjAgXTtcbiAgICB9XG4gICAgZG90TlQgPSB2ZWNEb3QoIG4sIHQgKTtcbiAgfVxuXG4gIHQgPSB2ZWNOb3JtYWxpemUoIHZlY1N1YiggdCwgdmVjU2NhbGUoIG4sIGRvdE5UICkgKSApO1xuXG4gIGxldCBiID0gdmVjM0Nyb3NzKCB0LCBuICk7XG4gIGlmICggYmlub3JtYWwgJiYgdmVjRG90KCBiLCBiaW5vcm1hbCApIDwgMC4wICkge1xuICAgIGIgPSB2ZWNOZWcoIGIgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9ybWFsOiBuLFxuICAgIHRhbmdlbnQ6IHQsXG4gICAgYmlub3JtYWw6IGIsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NC9NYXRyaXg0JztcbmltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuLi9xdWF0L1F1YXRlcm5pb24nO1xuaW1wb3J0IHsgVmVjdG9yIH0gZnJvbSAnLi4vdmVjL1ZlY3Rvcic7XG5pbXBvcnQgeyB2ZWMzQXBwbHlNYXRyaXg0IH0gZnJvbSAnLi92ZWMzQXBwbHlNYXRyaXg0JztcbmltcG9ydCB7IHZlYzNBcHBseVF1YXRlcm5pb24gfSBmcm9tICcuL3ZlYzNBcHBseVF1YXRlcm5pb24nO1xuaW1wb3J0IHsgdmVjM0Nyb3NzIH0gZnJvbSAnLi92ZWMzQ3Jvc3MnO1xuaW1wb3J0IHsgdmVjM09ydGhvTm9ybWFsaXplIH0gZnJvbSAnLi92ZWMzT3J0aG9Ob3JtYWxpemUnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBBIFZlY3RvcjMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWZWN0b3IzIGV4dGVuZHMgVmVjdG9yPFZlY3RvcjM+IHtcbiAgcHVibGljIGVsZW1lbnRzOiBSYXdWZWN0b3IzO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdjogUmF3VmVjdG9yMyA9IFsgMC4wLCAwLjAsIDAuMCBdICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IHY7XG4gIH1cblxuICAvKipcbiAgICogQW4geCBjb21wb25lbnQgb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgeCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzWyAwIF07XG4gIH1cblxuICBwdWJsaWMgc2V0IHgoIHg6IG51bWJlciApIHtcbiAgICB0aGlzLmVsZW1lbnRzWyAwIF0gPSB4O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIHkgY29tcG9uZW50IG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHkoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c1sgMSBdO1xuICB9XG5cbiAgcHVibGljIHNldCB5KCB5OiBudW1iZXIgKSB7XG4gICAgdGhpcy5lbGVtZW50c1sgMSBdID0geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiB6IGNvbXBvbmVudCBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCB6KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbIDIgXTtcbiAgfVxuXG4gIHB1YmxpYyBzZXQgeiggejogbnVtYmVyICkge1xuICAgIHRoaXMuZWxlbWVudHNbIDIgXSA9IHo7XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYFZlY3RvcjMoICR7IHRoaXMueC50b0ZpeGVkKCAzICkgfSwgJHsgdGhpcy55LnRvRml4ZWQoIDMgKSB9LCAkeyB0aGlzLnoudG9GaXhlZCggMyApIH0gKWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgY3Jvc3Mgb2YgdGhpcyBhbmQgYW5vdGhlciBWZWN0b3IzLlxuICAgKiBAcGFyYW0gdmVjdG9yIEFub3RoZXIgdmVjdG9yXG4gICAqL1xuICBwdWJsaWMgY3Jvc3MoIHZlY3RvcjogVmVjdG9yMyApOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoIHZlYzNDcm9zcyggdGhpcy5lbGVtZW50cywgdmVjdG9yLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGUgdGhpcyB2ZWN0b3IgdXNpbmcgYSBRdWF0ZXJuaW9uLlxuICAgKiBAcGFyYW0gcXVhdGVybmlvbiBBIHF1YXRlcm5pb25cbiAgICovXG4gIHB1YmxpYyBhcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb246IFF1YXRlcm5pb24gKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCB2ZWMzQXBwbHlRdWF0ZXJuaW9uKCB0aGlzLmVsZW1lbnRzLCBxdWF0ZXJuaW9uLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGlzIHZlY3RvciAod2l0aCBhbiBpbXBsaWNpdCAxIGluIHRoZSA0dGggZGltZW5zaW9uKSBieSBtLlxuICAgKi9cbiAgcHVibGljIGFwcGx5TWF0cml4NCggbWF0cml4OiBNYXRyaXg0ICk6IFZlY3RvcjMge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyggdmVjM0FwcGx5TWF0cml4NCggdGhpcy5lbGVtZW50cywgbWF0cml4LmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfX25ldyggdjogUmF3VmVjdG9yMyApOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoIHYgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZWN0b3IzKCAwLjAsIDAuMCwgMC4wIClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IHplcm8oKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCBbIDAuMCwgMC4wLCAwLjAgXSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlY3RvcjMoIDEuMCwgMC4wLCAwLjAgKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgcHgoKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCBbIDEuMCwgMC4wLCAwLjAgXSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlY3RvcjMoIC0xLjAsIDAuMCwgMC4wIClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IG54KCk6IFZlY3RvcjMge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyggWyAtMS4wLCAwLjAsIDAuMCBdICk7XG4gIH1cblxuICAvKipcbiAgICogVmVjdG9yMyggMC4wLCAxLjAsIDAuMCApXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCBweSgpOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoIFsgMC4wLCAxLjAsIDAuMCBdICk7XG4gIH1cblxuICAvKipcbiAgICogVmVjdG9yMyggMC4wLCAtMS4wLCAwLjAgKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgbnkoKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCBbIDAuMCwgLTEuMCwgMC4wIF0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZWN0b3IzKCAwLjAsIDAuMCwgMS4wIClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IHB6KCk6IFZlY3RvcjMge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyggWyAwLjAsIDAuMCwgMS4wIF0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZWN0b3IzKCAwLjAsIDAuMCwgLTEuMCApXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCBueigpOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoIFsgMC4wLCAwLjAsIC0xLjAgXSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlY3RvcjMoIDEuMCwgMS4wLCAxLjAgKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgb25lKCk6IFZlY3RvcjMge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyggWyAxLjAsIDEuMCwgMS4wIF0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSB0YW5nZW50IHdoaWNoIGlzIG9ydGhvZ29uYWwgdG8gbm9ybWFsLlxuICAgKiBJZiBiaW5vcm1hbCBpcyBzcGVjaWZpZWQsIGl0IGlzIGFsc28gcmV0dXJuZWQgYW5kIGl0J3Mgb3J0aG9nb25hbCB0byBib3RoIG5vcm1hbCBhbmQgdGFuZ2VudC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgb3J0aG9Ob3JtYWxpemUoIG5vcm1hbDogVmVjdG9yMywgdGFuZ2VudDogVmVjdG9yMywgYmlub3JtYWw6IFZlY3RvcjMgKToge1xuICAgIG5vcm1hbDogVmVjdG9yMyxcbiAgICB0YW5nZW50OiBWZWN0b3IzLFxuICAgIGJpbm9ybWFsOiBWZWN0b3IzLFxuICB9IHtcbiAgICBjb25zdCByZXN1bHQgPSB2ZWMzT3J0aG9Ob3JtYWxpemUoIG5vcm1hbC5lbGVtZW50cywgdGFuZ2VudC5lbGVtZW50cywgYmlub3JtYWwuZWxlbWVudHMgKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9ybWFsOiBuZXcgVmVjdG9yMyggcmVzdWx0Lm5vcm1hbCApLFxuICAgICAgdGFuZ2VudDogbmV3IFZlY3RvcjMoIHJlc3VsdC50YW5nZW50ICksXG4gICAgICBiaW5vcm1hbDogbmV3IFZlY3RvcjMoIHJlc3VsdC5iaW5vcm1hbCApLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3Qm94MyB9IGZyb20gJy4vUmF3Qm94Myc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gcG9pbnQgaXMgY29udGFpbmVkIGluIGdpdmVuIGJveCBvciBub3QuXG4gKiBAcGFyYW0gYm94IEEgYm94XG4gKiBAcGFyYW0gcG9pbnQgQSBwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gYm94M0NvbnRhaW5zUG9pbnQoIGJveDogUmF3Qm94MywgcG9pbnQ6IFJhd1ZlY3RvcjMgKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgYm94WyAwIF1bIDAgXSA8PSBwb2ludFsgMCBdICYmXG4gICAgYm94WyAxIF1bIDAgXSA+PSBwb2ludFsgMCBdICYmXG4gICAgYm94WyAwIF1bIDEgXSA8PSBwb2ludFsgMSBdICYmXG4gICAgYm94WyAxIF1bIDEgXSA+PSBwb2ludFsgMSBdICYmXG4gICAgYm94WyAwIF1bIDIgXSA8PSBwb2ludFsgMiBdICYmXG4gICAgYm94WyAxIF1bIDIgXSA+PSBwb2ludFsgMiBdXG4gICk7XG59XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9WZWN0b3IzJztcbmltcG9ydCB7IGJveDNDb250YWluc1BvaW50IH0gZnJvbSAnLi9ib3gzQ29udGFpbnNQb2ludCc7XG5pbXBvcnQgdHlwZSB7IFJhd0JveDMgfSBmcm9tICcuL1Jhd0JveDMnO1xuXG4vKipcbiAqIEEgM0QgYm94LlxuICovXG5leHBvcnQgY2xhc3MgQm94MyB7XG4gIHB1YmxpYyBtaW46IFZlY3RvcjM7XG4gIHB1YmxpYyBtYXg6IFZlY3RvcjM7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBtaW46IFZlY3RvcjMgPSBWZWN0b3IzLnplcm8sIG1heDogVmVjdG9yMyA9IFZlY3RvcjMuemVybyApIHtcbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IHtAbGluayBSYXdCb3gzfSBmb3JtLlxuICAgKi9cbiAgcHVibGljIGdldCByYXcoKTogUmF3Qm94MyB7XG4gICAgcmV0dXJuIFsgdGhpcy5taW4uZWxlbWVudHMsIHRoaXMubWF4LmVsZW1lbnRzIF07XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiBnaXZlbiBwb2ludCBpcyBjb250YWluZWQgaW4gdGhlIGJveCBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSBwb2ludCBBIHBvaW50XG4gICAqL1xuICBwdWJsaWMgY29udGFpbnNQb2ludCggcG9pbnQ6IFZlY3RvcjMgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGJveDNDb250YWluc1BvaW50KCB0aGlzLnJhdywgcG9pbnQuZWxlbWVudHMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHtAbGluayBSYXdCb3gzfSB0byBjbGFzcyBmb3JtLlxuICAgKiBAcGFyYW0gYm94IEEge0BsaW5rIFJhd0JveDN9XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21SYXcoIGJveDogUmF3Qm94MyApOiBCb3gzIHtcbiAgICByZXR1cm4gbmV3IEJveDMoIG5ldyBWZWN0b3IzKCBib3hbIDAgXSApLCBuZXcgVmVjdG9yMyggYm94WyAxIF0gKSApO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDMgfSBmcm9tICcuL1Jhd01hdHJpeDMnO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NC9SYXdNYXRyaXg0JztcblxuLyoqXG4gKiBXaG8gbmVlZHMgdGhpcz9cbiAqXG4gKiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IHtAbGluayBtYXQzQ3JlYXRlTm9ybWFsTWF0cml4fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDNGcm9tTWF0NFRyYW5zcG9zZShcbiAgc291cmNlOiBSYXdNYXRyaXg0LFxuKTogUmF3TWF0cml4MyB7XG4gIHJldHVybiBbXG4gICAgc291cmNlWyAwIF0sIHNvdXJjZVsgNCBdLCBzb3VyY2VbIDggXSxcbiAgICBzb3VyY2VbIDEgXSwgc291cmNlWyA1IF0sIHNvdXJjZVsgOSBdLFxuICAgIHNvdXJjZVsgMiBdLCBzb3VyY2VbIDYgXSwgc291cmNlWyAxMCBdLFxuICBdO1xufVxuIiwiaW1wb3J0IHsgdmVjU2NhbGUgfSBmcm9tICcuLi92ZWMvdmVjU2NhbGUnO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXgzIH0gZnJvbSAnLi9SYXdNYXRyaXgzJztcblxuLyoqXG4gKiBSZXR1cm4gYW4gaW52ZXJzZSBvZiBnaXZlbiBtYXQzLlxuICpcbiAqIFlvaW5rZWQgZnJvbSBUaHJlZS5qc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0M0ludmVyc2UoIG06IFJhd01hdHJpeDMgKTogUmF3TWF0cml4MyB7XG4gIGNvbnN0XG4gICAgbjExID0gbVsgMCBdLCBuMjEgPSBtWyAxIF0sIG4zMSA9IG1bIDIgXSxcbiAgICBuMTIgPSBtWyAzIF0sIG4yMiA9IG1bIDQgXSwgbjMyID0gbVsgNSBdLFxuICAgIG4xMyA9IG1bIDYgXSwgbjIzID0gbVsgNyBdLCBuMzMgPSBtWyA4IF0sXG4gICAgdDExID0gbjMzICogbjIyIC0gbjMyICogbjIzLFxuICAgIHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcbiAgICB0MTMgPSBuMjMgKiBuMTIgLSBuMjIgKiBuMTMsXG4gICAgZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzO1xuXG4gIGlmICggZGV0ID09PSAwLjAgKSB7IHJldHVybiB2ZWNTY2FsZSggbSwgMC4wICk7IH1cblxuICByZXR1cm4gdmVjU2NhbGUoIFtcbiAgICB0MTEsXG4gICAgbjMxICogbjIzIC0gbjMzICogbjIxLFxuICAgIG4zMiAqIG4yMSAtIG4zMSAqIG4yMixcbiAgICB0MTIsXG4gICAgbjMzICogbjExIC0gbjMxICogbjEzLFxuICAgIG4zMSAqIG4xMiAtIG4zMiAqIG4xMSxcbiAgICB0MTMsXG4gICAgbjIxICogbjEzIC0gbjIzICogbjExLFxuICAgIG4yMiAqIG4xMSAtIG4yMSAqIG4xMixcbiAgXSwgMS4wIC8gZGV0ICk7XG59XG4iLCJpbXBvcnQgeyBtYXQzRnJvbU1hdDRUcmFuc3Bvc2UgfSBmcm9tICcuL21hdDNGcm9tTWF0NFRyYW5zcG9zZSc7XG5pbXBvcnQgeyBtYXQzSW52ZXJzZSB9IGZyb20gJy4vbWF0M0ludmVyc2UnO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXgzIH0gZnJvbSAnLi9SYXdNYXRyaXgzJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4uL21hdDQvUmF3TWF0cml4NCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgbm9ybWFsIG1hdHJpeCBvdXQgb2YgYSBtYXRyaXg0LlxuICpcbiAqIEBwYXJhbSBtYXRyaXggQSBtYXRyaXg0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQzQ3JlYXRlTm9ybWFsTWF0cml4KCBtOiBSYXdNYXRyaXg0ICk6IFJhd01hdHJpeDMge1xuICByZXR1cm4gbWF0M0ludmVyc2UoIG1hdDNGcm9tTWF0NFRyYW5zcG9zZSggbSApICk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDMgfSBmcm9tICcuL1Jhd01hdHJpeDMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbWF0M0RldGVybWluYW50KCBtOiBSYXdNYXRyaXgzICk6IG51bWJlciB7XG4gIGNvbnN0XG4gICAgbjExID0gbVsgMCBdLCBuMjEgPSBtWyAxIF0sIG4zMSA9IG1bIDIgXSxcbiAgICBuMTIgPSBtWyAzIF0sIG4yMiA9IG1bIDQgXSwgbjMyID0gbVsgNSBdLFxuICAgIG4xMyA9IG1bIDYgXSwgbjIzID0gbVsgNyBdLCBuMzMgPSBtWyA4IF0sXG4gICAgdDExID0gbjMzICogbjIyIC0gbjMyICogbjIzLFxuICAgIHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcbiAgICB0MTMgPSBuMjMgKiBuMTIgLSBuMjIgKiBuMTM7XG5cbiAgcmV0dXJuIG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMztcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4vUmF3TWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L1Jhd01hdHJpeDQnO1xuXG4vKipcbiAqIENyZWF0ZSBhIG1hdHJpeDMgZnJvbSBtYXRyaXg0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0M0Zyb21NYXQ0KFxuICBzb3VyY2U6IFJhd01hdHJpeDQsXG4pOiBSYXdNYXRyaXgzIHtcbiAgcmV0dXJuIFtcbiAgICBzb3VyY2VbIDAgXSwgc291cmNlWyAxIF0sIHNvdXJjZVsgMiBdLFxuICAgIHNvdXJjZVsgNCBdLCBzb3VyY2VbIDUgXSwgc291cmNlWyA2IF0sXG4gICAgc291cmNlWyA4IF0sIHNvdXJjZVsgOSBdLCBzb3VyY2VbIDEwIF0sXG4gIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDMgfSBmcm9tICcuL1Jhd01hdHJpeDMnO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vcXVhdC9SYXdRdWF0ZXJuaW9uJztcblxuLyoqXG4gKiBDb252ZXJ0IGEgcXVhdGVybmlvbiBpbnRvIGEgbWF0cml4My5cbiAqXG4gKiBZb2lua2VkIGZyb20gVGhyZWUuanMuXG4gKlxuICogU2VlOiBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9lbi9tYXRoL01hdHJpeDQubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDNGcm9tUXVhdGVybmlvbiggcXVhdDogUmF3UXVhdGVybmlvbiApOiBSYXdNYXRyaXgzIHtcbiAgY29uc3QgeCA9IHF1YXRbIDAgXTtcbiAgY29uc3QgeSA9IHF1YXRbIDEgXTtcbiAgY29uc3QgeiA9IHF1YXRbIDIgXTtcbiAgY29uc3QgdyA9IHF1YXRbIDMgXTtcblxuICByZXR1cm4gW1xuICAgIDEuMCAtIDIuMCAqIHkgKiB5IC0gMi4wICogeiAqIHosIDIuMCAqIHggKiB5ICsgMi4wICogeiAqIHcsIDIuMCAqIHggKiB6IC0gMi4wICogeSAqIHcsXG4gICAgMi4wICogeCAqIHkgLSAyLjAgKiB6ICogdywgMS4wIC0gMi4wICogeCAqIHggLSAyLjAgKiB6ICogeiwgMi4wICogeSAqIHogKyAyLjAgKiB4ICogdyxcbiAgICAyLjAgKiB4ICogeiArIDIuMCAqIHkgKiB3LCAyLjAgKiB5ICogeiAtIDIuMCAqIHggKiB3LCAxLjAgLSAyLjAgKiB4ICogeCAtIDIuMCAqIHkgKiB5LFxuICBdO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXgzIH0gZnJvbSAnLi9SYXdNYXRyaXgzJztcblxuLyoqXG4gKiBSZXR1cm4gYSBtdWx0aXBsaWNhdGlvbiByZXN1bHQgb2YgbWF0cmljZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQzTXVsdGlwbHkoIC4uLm1hdHM6IFJhd01hdHJpeDNbXSApOiBSYXdNYXRyaXgzIHtcbiAgaWYgKCBtYXRzLmxlbmd0aCA8IDIgKSB7XG4gICAgcmV0dXJuIG1hdHNbIDAgXTtcbiAgfVxuXG4gIGNvbnN0IGEgPSBtYXRzLnNoaWZ0KCkhO1xuICBjb25zdCBiID0gbWF0M011bHRpcGx5KCAuLi5tYXRzICk7XG4gIGNvbnN0XG4gICAgYTAwID0gYVsgMCBdLCBhMDEgPSBhWyAxIF0sIGEwMiA9IGFbIDIgXSxcbiAgICBhMTAgPSBhWyAzIF0sIGExMSA9IGFbIDQgXSwgYTEyID0gYVsgNSBdLFxuICAgIGEyMCA9IGFbIDYgXSwgYTIxID0gYVsgNyBdLCBhMjIgPSBhWyA4IF0sXG4gICAgYjAwID0gYlsgMCBdLCBiMDEgPSBiWyAxIF0sIGIwMiA9IGJbIDIgXSxcbiAgICBiMTAgPSBiWyAzIF0sIGIxMSA9IGJbIDQgXSwgYjEyID0gYlsgNSBdLFxuICAgIGIyMCA9IGJbIDYgXSwgYjIxID0gYlsgNyBdLCBiMjIgPSBiWyA4IF07XG5cbiAgcmV0dXJuIFtcbiAgICBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDIsXG4gICAgYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyLFxuICAgIGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMixcblxuICAgIGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMixcbiAgICBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTIsXG4gICAgYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyLFxuXG4gICAgYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyLFxuICAgIGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMixcbiAgICBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjIsXG4gIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDMgfSBmcm9tICcuL1Jhd01hdHJpeDMnO1xuXG4vKipcbiAqIFRyYW5zcG9zZSBhIG1hdDMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQzVHJhbnNwb3NlKFxuICBzb3VyY2U6IFJhd01hdHJpeDMsXG4pOiBSYXdNYXRyaXgzIHtcbiAgcmV0dXJuIFtcbiAgICBzb3VyY2VbIDAgXSwgc291cmNlWyAzIF0sIHNvdXJjZVsgNiBdLFxuICAgIHNvdXJjZVsgMSBdLCBzb3VyY2VbIDQgXSwgc291cmNlWyA3IF0sXG4gICAgc291cmNlWyAyIF0sIHNvdXJjZVsgNSBdLCBzb3VyY2VbIDggXSxcbiAgXTtcbn1cbiIsImltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L01hdHJpeDQnO1xuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4uL3F1YXQvUXVhdGVybmlvbic7XG5pbXBvcnQgeyBtYXQzQ3JlYXRlTm9ybWFsTWF0cml4IH0gZnJvbSAnLi9tYXQzQ3JlYXRlTm9ybWFsTWF0cml4JztcbmltcG9ydCB7IG1hdDNEZXRlcm1pbmFudCB9IGZyb20gJy4vbWF0M0RldGVybWluYW50JztcbmltcG9ydCB7IG1hdDNGcm9tTWF0NCB9IGZyb20gJy4vbWF0M0Zyb21NYXQ0JztcbmltcG9ydCB7IG1hdDNGcm9tUXVhdGVybmlvbiB9IGZyb20gJy4vbWF0M0Zyb21RdWF0ZXJuaW9uJztcbmltcG9ydCB7IG1hdDNJbnZlcnNlIH0gZnJvbSAnLi9tYXQzSW52ZXJzZSc7XG5pbXBvcnQgeyBtYXQzTXVsdGlwbHkgfSBmcm9tICcuL21hdDNNdWx0aXBseSc7XG5pbXBvcnQgeyBtYXQzVHJhbnNwb3NlIH0gZnJvbSAnLi9tYXQzVHJhbnNwb3NlJztcbmltcG9ydCB7IHZlY1NjYWxlIH0gZnJvbSAnLi4vdmVjL3ZlY1NjYWxlJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4vUmF3TWF0cml4Myc7XG5cbmNvbnN0IHJhd0lkZW50aXR5TWF0cml4MzogUmF3TWF0cml4MyA9IFtcbiAgMS4wLCAwLjAsIDAuMCxcbiAgMC4wLCAxLjAsIDAuMCxcbiAgMC4wLCAwLjAsIDEuMCxcbl07XG5cbi8qKlxuICogQSBNYXRyaXgzLlxuICovXG5leHBvcnQgY2xhc3MgTWF0cml4MyB7XG4gIHB1YmxpYyBlbGVtZW50czogUmF3TWF0cml4MztcblxuICBwdWJsaWMgY29uc3RydWN0b3IoIHY6IFJhd01hdHJpeDMgPSByYXdJZGVudGl0eU1hdHJpeDMgKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IHY7XG4gIH1cblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCB0cmFuc3Bvc2VkLlxuICAgKi9cbiAgcHVibGljIGdldCB0cmFuc3Bvc2UoKTogTWF0cml4MyB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgzKCBtYXQzVHJhbnNwb3NlKCB0aGlzLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHMgZGV0ZXJtaW5hbnQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGRldGVybWluYW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIG1hdDNEZXRlcm1pbmFudCggdGhpcy5lbGVtZW50cyApO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0c2VsZiBidXQgaW52ZXJ0ZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGludmVyc2UoKTogTWF0cml4MyB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgzKCBtYXQzSW52ZXJzZSggdGhpcy5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCBtYXRyaXg0LlxuICAgKi9cbiAgcHVibGljIGdldCBtYXRyaXg0KCk6IE1hdHJpeDQge1xuICAgIHJldHVybiBNYXRyaXg0LmZyb21NYXRyaXgzKCB0aGlzICk7XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBjb25zdCBtID0gdGhpcy5lbGVtZW50cy5tYXAoICggdiApID0+IHYudG9GaXhlZCggMyApICk7XG4gICAgcmV0dXJuIGBNYXRyaXgzKCAkeyBtWyAwIF0gfSwgJHsgbVsgMyBdIH0sICR7IG1bIDYgXSB9OyAkeyBtWyAxIF0gfSwgJHsgbVsgNCBdIH0sICR7IG1bIDcgXSB9OyAkeyBtWyAyIF0gfSwgJHsgbVsgNSBdIH0sICR7IG1bIDggXSB9IClgO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgY2xvbmUoKTogTWF0cml4MyB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgzKCB0aGlzLmVsZW1lbnRzLmNvbmNhdCgpIGFzIFJhd01hdHJpeDMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGlzIE1hdHJpeDMgYnkgb25lIG9yIG1vcmUgTWF0cml4M3MuXG4gICAqL1xuICBwdWJsaWMgbXVsdGlwbHkoIC4uLm1hdHJpY2VzOiBNYXRyaXgzW10gKTogTWF0cml4MyB7XG4gICAgcmV0dXJuIE1hdHJpeDMubXVsdGlwbHkoIHRoaXMsIC4uLm1hdHJpY2VzICk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgdGhpcyBNYXRyaXgzIGJ5IGEgc2NhbGFyLlxuICAgKi9cbiAgcHVibGljIHNjYWxlU2NhbGFyKCBzY2FsYXI6IG51bWJlciApOiBNYXRyaXgzIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDMoIHZlY1NjYWxlKCB0aGlzLmVsZW1lbnRzLCBzY2FsYXIgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGlkZW50aXR5IE1hdHJpeDQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCBpZGVudGl0eSgpOiBNYXRyaXgzIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDMoIHJhd0lkZW50aXR5TWF0cml4MyApO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHR3byBvciBtb3JlIG1hdHJpY2VzLlxuICAgKiBAcGFyYW0gbWF0cmljZXMgTWF0cmljZXNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbXVsdGlwbHkoIC4uLm1hdHJpY2VzOiBNYXRyaXgzW10gKTogTWF0cml4MyB7XG4gICAgaWYgKCBtYXRyaWNlcy5sZW5ndGggPT09IDAgKSB7XG4gICAgICByZXR1cm4gTWF0cml4My5pZGVudGl0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgzKCBtYXQzTXVsdGlwbHkoIC4uLm1hdHJpY2VzLm1hcCggKCBtICkgPT4gbS5lbGVtZW50cyApICkgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbm9ybWFsIG1hdHJpeCBvdXQgb2YgbWF0cml4NC5cbiAgICogQHBhcmFtIG1hdHJpeDQgQSBtYXRyaXg0XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZU5vcm1hbE1hdHJpeCggbWF0cml4NDogTWF0cml4NCApOiBNYXRyaXgzIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDMoIG1hdDNDcmVhdGVOb3JtYWxNYXRyaXgoIG1hdHJpeDQuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIENhc3QgYSB7QGxpbmsgTWF0cml4NH0gaW50byBhIE1hdHJpeDMuXG4gICAqIEBwYXJhbSBtYXRyaXg0IEEgbWF0cml4NFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tTWF0cml4NCggbWF0cml4NDogTWF0cml4NCApOiBNYXRyaXgzIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDMoIG1hdDNGcm9tTWF0NCggbWF0cml4NC5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWF0cml4IG91dCBvZiBhIHtAbGluayBRdWF0ZXJuaW9ufS5cbiAgICogQHBhcmFtIHF1YXRlcm5pb24gQSBxdWF0ZXJuaW9uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uOiBRdWF0ZXJuaW9uICk6IE1hdHJpeDMge1xuICAgIHJldHVybiBuZXcgTWF0cml4MyggbWF0M0Zyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLmVsZW1lbnRzICkgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLic7XG5pbXBvcnQgdHlwZSB7IFJhd1F1YXRlcm5pb24gfSBmcm9tICcuLi9xdWF0L1Jhd1F1YXRlcm5pb24nO1xuXG4vKipcbiAqIENvbnZlcnQgYSBxdWF0ZXJuaW9uIGludG8gYSBtYXRyaXg0LlxuICpcbiAqIFlvaW5rZWQgZnJvbSBUaHJlZS5qcy5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL21hdGgvTWF0cml4NC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NEZyb21RdWF0ZXJuaW9uKCBxdWF0OiBSYXdRdWF0ZXJuaW9uICk6IFJhd01hdHJpeDQge1xuICBjb25zdCB4ID0gcXVhdFsgMCBdO1xuICBjb25zdCB5ID0gcXVhdFsgMSBdO1xuICBjb25zdCB6ID0gcXVhdFsgMiBdO1xuICBjb25zdCB3ID0gcXVhdFsgMyBdO1xuXG4gIHJldHVybiBbXG4gICAgMS4wIC0gMi4wICogeSAqIHkgLSAyLjAgKiB6ICogeiwgMi4wICogeCAqIHkgKyAyLjAgKiB6ICogdywgMi4wICogeCAqIHogLSAyLjAgKiB5ICogdywgMC4wLFxuICAgIDIuMCAqIHggKiB5IC0gMi4wICogeiAqIHcsIDEuMCAtIDIuMCAqIHggKiB4IC0gMi4wICogeiAqIHosIDIuMCAqIHkgKiB6ICsgMi4wICogeCAqIHcsIDAuMCxcbiAgICAyLjAgKiB4ICogeiArIDIuMCAqIHkgKiB3LCAyLjAgKiB5ICogeiAtIDIuMCAqIHggKiB3LCAxLjAgLSAyLjAgKiB4ICogeCAtIDIuMCAqIHkgKiB5LCAwLjAsXG4gICAgMC4wLCAwLjAsIDAuMCwgMS4wLFxuICBdO1xufVxuIiwiaW1wb3J0IHsgbWF0NEZyb21RdWF0ZXJuaW9uIH0gZnJvbSAnLi9tYXQ0RnJvbVF1YXRlcm5pb24nO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi9SYXdNYXRyaXg0JztcbmltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4uL3F1YXQvUmF3UXVhdGVybmlvbic7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIENvbXBvc2UgYSBtYXRyaXggb3V0IG9mIHBvc2l0aW9uLCBzY2FsZSwgYW5kIHJvdGF0aW9uLlxuICogWW9pbmtlZCBmcm9tIFRocmVlLmpzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NENvbXBvc2UoXG4gIHBvc2l0aW9uOiBSYXdWZWN0b3IzLFxuICByb3RhdGlvbjogUmF3UXVhdGVybmlvbixcbiAgc2NhbGU6IFJhd1ZlY3RvcjMsXG4pOiBSYXdNYXRyaXg0IHtcbiAgY29uc3QgbWF0Um90ID0gbWF0NEZyb21RdWF0ZXJuaW9uKCByb3RhdGlvbiApO1xuXG4gIGNvbnN0IHN4ID0gc2NhbGVbIDAgXSwgc3kgPSBzY2FsZVsgMSBdLCBzeiA9IHNjYWxlWyAyIF07XG5cbiAgcmV0dXJuIFtcbiAgICBtYXRSb3RbIDAgXSAqIHN4LFxuICAgIG1hdFJvdFsgMSBdICogc3gsXG4gICAgbWF0Um90WyAyIF0gKiBzeCxcbiAgICAwLjAsXG5cbiAgICBtYXRSb3RbIDQgXSAqIHN5LFxuICAgIG1hdFJvdFsgNSBdICogc3ksXG4gICAgbWF0Um90WyA2IF0gKiBzeSxcbiAgICAwLjAsXG5cbiAgICBtYXRSb3RbIDggXSAqIHN6LFxuICAgIG1hdFJvdFsgOSBdICogc3osXG4gICAgbWF0Um90WyAxMCBdICogc3osXG4gICAgMC4wLFxuXG4gICAgcG9zaXRpb25bIDAgXSxcbiAgICBwb3NpdGlvblsgMSBdLFxuICAgIHBvc2l0aW9uWyAyIF0sXG4gICAgMS4wXG4gIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuXG4vKipcbiAqIFJldHVybiBhIGRldGVybWluYW50IG9mIGdpdmVuIG1hdDQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQ0RGV0ZXJtaW5hbnQoIG06IFJhd01hdHJpeDQgKTogbnVtYmVyIHtcbiAgY29uc3RcbiAgICBhMDAgPSBtWyAgMCBdLCBhMDEgPSBtWyAgMSBdLCBhMDIgPSBtWyAgMiBdLCBhMDMgPSBtWyAgMyBdLFxuICAgIGExMCA9IG1bICA0IF0sIGExMSA9IG1bICA1IF0sIGExMiA9IG1bICA2IF0sIGExMyA9IG1bICA3IF0sXG4gICAgYTIwID0gbVsgIDggXSwgYTIxID0gbVsgIDkgXSwgYTIyID0gbVsgMTAgXSwgYTIzID0gbVsgMTEgXSxcbiAgICBhMzAgPSBtWyAxMiBdLCBhMzEgPSBtWyAxMyBdLCBhMzIgPSBtWyAxNCBdLCBhMzMgPSBtWyAxNSBdLFxuICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCwgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLCAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCwgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLCAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDMgfSBmcm9tICcuLi9tYXQzL1Jhd01hdHJpeDMnO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi9SYXdRdWF0ZXJuaW9uJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIFF1YXRlcm5pb24gb3V0IG9mIGEgcm90YXRpb24gbWF0cml4LlxuICogWW9pbmtlZCBmcm9tIFRocmVlLmpzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhdEZyb21NYXRyaXgzKCBtOiBSYXdNYXRyaXgzICk6IFJhd1F1YXRlcm5pb24ge1xuICBjb25zdCBtMTEgPSBtWyAwIF0sIG0xMiA9IG1bIDMgXSwgbTEzID0gbVsgNiBdLFxuICAgIG0yMSA9IG1bIDEgXSwgbTIyID0gbVsgNCBdLCBtMjMgPSBtWyA3IF0sXG4gICAgbTMxID0gbVsgMiBdLCBtMzIgPSBtWyA1IF0sIG0zMyA9IG1bIDggXSxcbiAgICB0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcblxuICBpZiAoIHRyYWNlID4gMCApIHtcbiAgICBjb25zdCBzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuICAgIHJldHVybiBbXG4gICAgICAoIG0zMiAtIG0yMyApICogcyxcbiAgICAgICggbTEzIC0gbTMxICkgKiBzLFxuICAgICAgKCBtMjEgLSBtMTIgKSAqIHMsXG4gICAgICAwLjI1IC8gc1xuICAgIF07XG4gIH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG4gICAgY29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XG4gICAgcmV0dXJuIFtcbiAgICAgIDAuMjUgKiBzLFxuICAgICAgKCBtMTIgKyBtMjEgKSAvIHMsXG4gICAgICAoIG0xMyArIG0zMSApIC8gcyxcbiAgICAgICggbTMyIC0gbTIzICkgLyBzXG4gICAgXTtcbiAgfSBlbHNlIGlmICggbTIyID4gbTMzICkge1xuICAgIGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xuICAgIHJldHVybiBbXG4gICAgICAoIG0xMiArIG0yMSApIC8gcyxcbiAgICAgIDAuMjUgKiBzLFxuICAgICAgKCBtMjMgKyBtMzIgKSAvIHMsXG4gICAgICAoIG0xMyAtIG0zMSApIC8gc1xuICAgIF07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG4gICAgcmV0dXJuIFtcbiAgICAgICggbTEzICsgbTMxICkgLyBzLFxuICAgICAgKCBtMjMgKyBtMzIgKSAvIHMsXG4gICAgICAwLjI1ICogcyxcbiAgICAgICggbTIxIC0gbTEyICkgLyBzXG4gICAgXTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgbWF0M0Zyb21NYXQ0IH0gZnJvbSAnLi4vbWF0My9tYXQzRnJvbU1hdDQnO1xuaW1wb3J0IHsgcXVhdEZyb21NYXRyaXgzIH0gZnJvbSAnLi9xdWF0RnJvbU1hdHJpeDMnO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NC9SYXdNYXRyaXg0JztcbmltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4vUmF3UXVhdGVybmlvbic7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBRdWF0ZXJuaW9uIG91dCBvZiBhIHJvdGF0aW9uIG1hdHJpeC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXRGcm9tTWF0cml4NCggbTogUmF3TWF0cml4NCApOiBSYXdRdWF0ZXJuaW9uIHtcbiAgcmV0dXJuIHF1YXRGcm9tTWF0cml4MyggbWF0M0Zyb21NYXQ0KCBtICkgKTtcbn1cbiIsImltcG9ydCB7IG1hdDREZXRlcm1pbmFudCB9IGZyb20gJy4vbWF0NERldGVybWluYW50JztcbmltcG9ydCB7IHF1YXRGcm9tTWF0cml4NCB9IGZyb20gJy4uL3F1YXQvcXVhdEZyb21NYXRyaXg0JztcbmltcG9ydCB7IHZlY0xlbmd0aCB9IGZyb20gJy4uL3ZlYy92ZWNMZW5ndGgnO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi9SYXdNYXRyaXg0JztcbmltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4uL3F1YXQvUmF3UXVhdGVybmlvbic7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIERlY29tcG9zZSBhIG1hdHJpeCBpbnRvIGEgcG9zaXRpb24sIGEgc2NhbGUsIGFuZCBhIHJvdGF0aW9uLlxuICogWW9pbmtlZCBmcm9tIFRocmVlLmpzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NERlY29tcG9zZSggbTogUmF3TWF0cml4NCApOiB7XG4gIHBvc2l0aW9uOiBSYXdWZWN0b3IzO1xuICBzY2FsZTogUmF3VmVjdG9yMztcbiAgcm90YXRpb246IFJhd1F1YXRlcm5pb247XG59IHtcbiAgbGV0IHN4ID0gdmVjTGVuZ3RoKCBbIG1bIDAgXSwgbVsgMSBdLCBtWyAyIF0gXSApO1xuICBjb25zdCBzeSA9IHZlY0xlbmd0aCggWyBtWyA0IF0sIG1bIDUgXSwgbVsgNiBdIF0gKTtcbiAgY29uc3Qgc3ogPSB2ZWNMZW5ndGgoIFsgbVsgOCBdLCBtWyA5IF0sIG1bIDEwIF0gXSApO1xuXG4gIC8vIGlmIGRldGVybWluYW50IGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcbiAgY29uc3QgZGV0ID0gbWF0NERldGVybWluYW50KCBtICk7XG4gIGlmICggZGV0IDwgMCApIHsgc3ggPSAtc3g7IH1cblxuICBjb25zdCBpbnZTeCA9IDEuMCAvIHN4O1xuICBjb25zdCBpbnZTeSA9IDEuMCAvIHN5O1xuICBjb25zdCBpbnZTeiA9IDEuMCAvIHN6O1xuXG4gIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbS5jb25jYXQoKSBhcyBSYXdNYXRyaXg0O1xuXG4gIHJvdGF0aW9uTWF0cml4WyAwIF0gKj0gaW52U3g7XG4gIHJvdGF0aW9uTWF0cml4WyAxIF0gKj0gaW52U3g7XG4gIHJvdGF0aW9uTWF0cml4WyAyIF0gKj0gaW52U3g7XG5cbiAgcm90YXRpb25NYXRyaXhbIDQgXSAqPSBpbnZTeTtcbiAgcm90YXRpb25NYXRyaXhbIDUgXSAqPSBpbnZTeTtcbiAgcm90YXRpb25NYXRyaXhbIDYgXSAqPSBpbnZTeTtcblxuICByb3RhdGlvbk1hdHJpeFsgOCBdICo9IGludlN6O1xuICByb3RhdGlvbk1hdHJpeFsgOSBdICo9IGludlN6O1xuICByb3RhdGlvbk1hdHJpeFsgMTAgXSAqPSBpbnZTejtcblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBbIG1bIDEyIF0sIG1bIDEzIF0sIG1bIDE0IF0gXSxcbiAgICBzY2FsZTogWyBzeCwgc3ksIHN6IF0sXG4gICAgcm90YXRpb246IHF1YXRGcm9tTWF0cml4NCggcm90YXRpb25NYXRyaXggKSxcbiAgfTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4uL21hdDMvUmF3TWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuXG4vKipcbiAqIENyZWF0ZSBhIG1hdHJpeDQgZnJvbSBtYXRyaXgzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NEZyb21NYXQzKFxuICBzb3VyY2U6IFJhd01hdHJpeDMsXG4pOiBSYXdNYXRyaXg0IHtcbiAgcmV0dXJuIFtcbiAgICBzb3VyY2VbIDAgXSwgc291cmNlWyAxIF0sIHNvdXJjZVsgMiBdLCAwLjAsXG4gICAgc291cmNlWyAzIF0sIHNvdXJjZVsgNCBdLCBzb3VyY2VbIDUgXSwgMC4wLFxuICAgIHNvdXJjZVsgNiBdLCBzb3VyY2VbIDcgXSwgc291cmNlWyA4IF0sIDAuMCxcbiAgICAwLjAsIDAuMCwgMC4wLCAxLjAsXG4gIF07XG59XG4iLCJpbXBvcnQgeyB2ZWNTY2FsZSB9IGZyb20gJy4uL3ZlYy92ZWNTY2FsZSc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuXG4vKipcbiAqICBhbiBpbnZlcnNlIG9mIGdpdmVuIG1hdDQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQ0SW52ZXJzZSggbTogUmF3TWF0cml4NCApOiBSYXdNYXRyaXg0IHtcbiAgY29uc3RcbiAgICBhMDAgPSBtWyAgMCBdLCBhMDEgPSBtWyAgMSBdLCBhMDIgPSBtWyAgMiBdLCBhMDMgPSBtWyAgMyBdLFxuICAgIGExMCA9IG1bICA0IF0sIGExMSA9IG1bICA1IF0sIGExMiA9IG1bICA2IF0sIGExMyA9IG1bICA3IF0sXG4gICAgYTIwID0gbVsgIDggXSwgYTIxID0gbVsgIDkgXSwgYTIyID0gbVsgMTAgXSwgYTIzID0gbVsgMTEgXSxcbiAgICBhMzAgPSBtWyAxMiBdLCBhMzEgPSBtWyAxMyBdLCBhMzIgPSBtWyAxNCBdLCBhMzMgPSBtWyAxNSBdLFxuICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCwgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLCAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCwgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLCAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gIGNvbnN0IGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIGRldCA9PT0gMC4wICkgeyByZXR1cm4gdmVjU2NhbGUoIG0sIDAuMCApOyB9XG5cbiAgcmV0dXJuIHZlY1NjYWxlKCBbXG4gICAgYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5LFxuICAgIGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSxcbiAgICBhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMsXG4gICAgYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzLFxuICAgIGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNyxcbiAgICBhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcsXG4gICAgYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxLFxuICAgIGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSxcbiAgICBhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYsXG4gICAgYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2LFxuICAgIGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCxcbiAgICBhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDAsXG4gICAgYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2LFxuICAgIGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNixcbiAgICBhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDAsXG4gICAgYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwLFxuICBdLCAxLjAgLyBkZXQgKTtcbn1cbiIsImltcG9ydCB7IHZlYzNDcm9zcyB9IGZyb20gJy4uL3ZlYzMvdmVjM0Nyb3NzJztcbmltcG9ydCB7IHZlY0FkZCB9IGZyb20gJy4uL3ZlYy92ZWNBZGQnO1xuaW1wb3J0IHsgdmVjTm9ybWFsaXplIH0gZnJvbSAnLi4vdmVjL3ZlY05vcm1hbGl6ZSc7XG5pbXBvcnQgeyB2ZWNTY2FsZSB9IGZyb20gJy4uL3ZlYy92ZWNTY2FsZSc7XG5pbXBvcnQgeyB2ZWNTdWIgfSBmcm9tICcuLi92ZWMvdmVjU3ViJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgXCJMb29rQXRcIiBtYXRyaXguXG4gKlxuICogU2VlIGFsc286IHtAbGluayBtYXQ0TG9va0F0SW52ZXJzZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDRMb29rQXQoXG4gIHBvc2l0aW9uOiBSYXdWZWN0b3IzLFxuICB0YXJnZXQ6IFJhd1ZlY3RvcjMgPSBbIDAuMCwgMC4wLCAwLjAgXSxcbiAgdXA6IFJhd1ZlY3RvcjMgPSBbIDAuMCwgMS4wLCAwLjAgXSxcbiAgcm9sbCA9IDAuMCxcbik6IFJhd01hdHJpeDQge1xuICBjb25zdCBkaXIgPSB2ZWNOb3JtYWxpemUoIHZlY1N1YiggcG9zaXRpb24sIHRhcmdldCApICk7XG5cbiAgbGV0IHNpZCA9IHZlY05vcm1hbGl6ZSggdmVjM0Nyb3NzKCB1cCwgZGlyICkgKTtcblxuICBpZiAoIHJvbGwgIT09IDAuMCApIHtcbiAgICBzaWQgPSB2ZWNBZGQoXG4gICAgICB2ZWNTY2FsZSggc2lkLCBNYXRoLmNvcyggcm9sbCApICksXG4gICAgICB2ZWNTY2FsZSggdmVjM0Nyb3NzKCBkaXIsIHNpZCApLCBNYXRoLnNpbiggcm9sbCApICksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHRvcCA9IHZlYzNDcm9zcyggZGlyLCBzaWQgKTtcblxuICByZXR1cm4gW1xuICAgIHNpZFsgMCBdLCBzaWRbIDEgXSwgc2lkWyAyIF0sIDAuMCxcbiAgICB0b3BbIDAgXSwgdG9wWyAxIF0sIHRvcFsgMiBdLCAwLjAsXG4gICAgZGlyWyAwIF0sIGRpclsgMSBdLCBkaXJbIDIgXSwgMC4wLFxuICAgIHBvc2l0aW9uWyAwIF0sIHBvc2l0aW9uWyAxIF0sIHBvc2l0aW9uWyAyIF0sIDEuMFxuICBdO1xufVxuIiwiaW1wb3J0IHsgdmVjM0Nyb3NzIH0gZnJvbSAnLi4vdmVjMy92ZWMzQ3Jvc3MnO1xuaW1wb3J0IHsgdmVjQWRkIH0gZnJvbSAnLi4vdmVjL3ZlY0FkZCc7XG5pbXBvcnQgeyB2ZWNEb3QgfSBmcm9tICcuLi92ZWMvdmVjRG90JztcbmltcG9ydCB7IHZlY05vcm1hbGl6ZSB9IGZyb20gJy4uL3ZlYy92ZWNOb3JtYWxpemUnO1xuaW1wb3J0IHsgdmVjU2NhbGUgfSBmcm9tICcuLi92ZWMvdmVjU2NhbGUnO1xuaW1wb3J0IHsgdmVjU3ViIH0gZnJvbSAnLi4vdmVjL3ZlY1N1Yic7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBpbnZlcnNlIG9mIFwiTG9va0F0XCIgbWF0cml4LiBHb29kIGZvciBjcmVhdGluZyBhIHZpZXcgbWF0cml4LlxuICpcbiAqIFNlZSBhbHNvOiB7QGxpbmsgbWF0NExvb2tBdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDRMb29rQXRJbnZlcnNlKFxuICBwb3NpdGlvbjogUmF3VmVjdG9yMyxcbiAgdGFyZ2V0OiBSYXdWZWN0b3IzID0gWyAwLjAsIDAuMCwgMC4wIF0sXG4gIHVwOiBSYXdWZWN0b3IzID0gWyAwLjAsIDEuMCwgMC4wIF0sXG4gIHJvbGwgPSAwLjAsXG4pOiBSYXdNYXRyaXg0IHtcbiAgY29uc3QgZGlyID0gdmVjTm9ybWFsaXplKCB2ZWNTdWIoIHBvc2l0aW9uLCB0YXJnZXQgKSApO1xuXG4gIGxldCBzaWQgPSB2ZWNOb3JtYWxpemUoIHZlYzNDcm9zcyggdXAsIGRpciApICk7XG5cbiAgaWYgKCByb2xsICE9PSAwLjAgKSB7XG4gICAgc2lkID0gdmVjQWRkKFxuICAgICAgdmVjU2NhbGUoIHNpZCwgTWF0aC5jb3MoIHJvbGwgKSApLFxuICAgICAgdmVjU2NhbGUoIHZlYzNDcm9zcyggZGlyLCBzaWQgKSwgTWF0aC5zaW4oIHJvbGwgKSApLFxuICAgICk7XG4gIH1cblxuICBjb25zdCB0b3AgPSB2ZWMzQ3Jvc3MoIGRpciwgc2lkICk7XG5cbiAgcmV0dXJuIFtcbiAgICBzaWRbIDAgXSwgdG9wWyAwIF0sIGRpclsgMCBdLCAwLjAsXG4gICAgc2lkWyAxIF0sIHRvcFsgMSBdLCBkaXJbIDEgXSwgMC4wLFxuICAgIHNpZFsgMiBdLCB0b3BbIDIgXSwgZGlyWyAyIF0sIDAuMCxcbiAgICAtdmVjRG90KCBzaWQsIHBvc2l0aW9uICksXG4gICAgLXZlY0RvdCggdG9wLCBwb3NpdGlvbiApLFxuICAgIC12ZWNEb3QoIGRpciwgcG9zaXRpb24gKSxcbiAgICAxLjAsXG4gIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuXG4vKipcbiAqIFJldHVybiBhIG11bHRpcGxpY2F0aW9uIHJlc3VsdCBvZiBtYXRyaWNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDRNdWx0aXBseSggLi4ubWF0czogUmF3TWF0cml4NFtdICk6IFJhd01hdHJpeDQge1xuICBpZiAoIG1hdHMubGVuZ3RoIDwgMiApIHtcbiAgICByZXR1cm4gbWF0c1sgMCBdO1xuICB9XG5cbiAgY29uc3QgYSA9IG1hdHMuc2hpZnQoKSE7XG4gIGNvbnN0IGIgPSBtYXQ0TXVsdGlwbHkoIC4uLm1hdHMgKTtcbiAgY29uc3RcbiAgICBhMDAgPSBhWyAgMCBdLCBhMDEgPSBhWyAgMSBdLCBhMDIgPSBhWyAgMiBdLCBhMDMgPSBhWyAgMyBdLFxuICAgIGExMCA9IGFbICA0IF0sIGExMSA9IGFbICA1IF0sIGExMiA9IGFbICA2IF0sIGExMyA9IGFbICA3IF0sXG4gICAgYTIwID0gYVsgIDggXSwgYTIxID0gYVsgIDkgXSwgYTIyID0gYVsgMTAgXSwgYTIzID0gYVsgMTEgXSxcbiAgICBhMzAgPSBhWyAxMiBdLCBhMzEgPSBhWyAxMyBdLCBhMzIgPSBhWyAxNCBdLCBhMzMgPSBhWyAxNSBdLFxuICAgIGIwMCA9IGJbICAwIF0sIGIwMSA9IGJbICAxIF0sIGIwMiA9IGJbICAyIF0sIGIwMyA9IGJbICAzIF0sXG4gICAgYjEwID0gYlsgIDQgXSwgYjExID0gYlsgIDUgXSwgYjEyID0gYlsgIDYgXSwgYjEzID0gYlsgIDcgXSxcbiAgICBiMjAgPSBiWyAgOCBdLCBiMjEgPSBiWyAgOSBdLCBiMjIgPSBiWyAxMCBdLCBiMjMgPSBiWyAxMSBdLFxuICAgIGIzMCA9IGJbIDEyIF0sIGIzMSA9IGJbIDEzIF0sIGIzMiA9IGJbIDE0IF0sIGIzMyA9IGJbIDE1IF07XG5cbiAgcmV0dXJuIFtcbiAgICBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDIgKyBhMzAgKiBiMDMsXG4gICAgYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyICsgYTMxICogYjAzLFxuICAgIGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMiArIGEzMiAqIGIwMyxcbiAgICBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDIgKyBhMzMgKiBiMDMsXG5cbiAgICBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTIgKyBhMzAgKiBiMTMsXG4gICAgYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyICsgYTMxICogYjEzLFxuICAgIGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMiArIGEzMiAqIGIxMyxcbiAgICBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTIgKyBhMzMgKiBiMTMsXG5cbiAgICBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjIgKyBhMzAgKiBiMjMsXG4gICAgYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyICsgYTMxICogYjIzLFxuICAgIGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMiArIGEzMiAqIGIyMyxcbiAgICBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjIgKyBhMzMgKiBiMjMsXG5cbiAgICBhMDAgKiBiMzAgKyBhMTAgKiBiMzEgKyBhMjAgKiBiMzIgKyBhMzAgKiBiMzMsXG4gICAgYTAxICogYjMwICsgYTExICogYjMxICsgYTIxICogYjMyICsgYTMxICogYjMzLFxuICAgIGEwMiAqIGIzMCArIGExMiAqIGIzMSArIGEyMiAqIGIzMiArIGEzMiAqIGIzMyxcbiAgICBhMDMgKiBiMzAgKyBhMTMgKiBiMzEgKyBhMjMgKiBiMzIgKyBhMzMgKiBiMzMsXG4gIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgXCJQZXJzcGVjdGl2ZVwiIHByb2plY3Rpb24gbWF0cml4LlxuICpcbiAqIEBwYXJhbSBmb3YgRmllbGQgb2YgVmlldyBZLCAqKklOIERFR1JFRVMqKlxuICogQHBhcmFtIG5lYXIgTmVhciBjbGlwIHBsYW5lXG4gKiBAcGFyYW0gZmFyIEZhciBjbGlwIHBsYW5lXG4gKiBAcGFyYW0gYXNwZWN0IEFzcGVjdCByYXRpby4gKipgMS4wYCBCWSBERUZBVUxUKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDRQZXJzcGVjdGl2ZShcbiAgZm92ID0gNDUuMCxcbiAgbmVhciA9IDAuMDEsXG4gIGZhciA9IDEwMC4wLFxuICBhc3BlY3QgPSAxLjAsXG4pOiBSYXdNYXRyaXg0IHtcbiAgY29uc3QgcCA9IDEuMCAvIE1hdGgudGFuKCBmb3YgKiBNYXRoLlBJIC8gMzYwLjAgKTtcbiAgY29uc3QgZCA9ICggZmFyIC0gbmVhciApO1xuICByZXR1cm4gW1xuICAgIHAgLyBhc3BlY3QsIDAuMCwgMC4wLCAwLjAsXG4gICAgMC4wLCBwLCAwLjAsIDAuMCxcbiAgICAwLjAsIDAuMCwgLSggZmFyICsgbmVhciApIC8gZCwgLTEuMCxcbiAgICAwLjAsIDAuMCwgLTIgKiBmYXIgKiBuZWFyIC8gZCwgMC4wXG4gIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgM2Qgcm90YXRpb24gbWF0cml4LCByb3RhdGVzIGFyb3VuZCB4IGF4aXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQ0Um90YXRpb25YKCB0aGV0YTogbnVtYmVyICk6IFJhd01hdHJpeDQge1xuICBjb25zdCBjID0gTWF0aC5jb3MoIHRoZXRhICk7XG4gIGNvbnN0IHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICByZXR1cm4gW1xuICAgIDEsIDAsIDAsIDAsXG4gICAgMCwgYywgLXMsIDAsXG4gICAgMCwgcywgYywgMCxcbiAgICAwLCAwLCAwLCAxLFxuICBdO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi9SYXdNYXRyaXg0JztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIDNkIHJvdGF0aW9uIG1hdHJpeCwgcm90YXRlcyBhcm91bmQgeSBheGlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NFJvdGF0aW9uWSggdGhldGE6IG51bWJlciApOiBSYXdNYXRyaXg0IHtcbiAgY29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApO1xuICBjb25zdCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgcmV0dXJuIFtcbiAgICBjLCAwLCBzLCAwLFxuICAgIDAsIDEsIDAsIDAsXG4gICAgLXMsIDAsIGMsIDAsXG4gICAgMCwgMCwgMCwgMSxcbiAgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSAzZCByb3RhdGlvbiBtYXRyaXgsIHJvdGF0ZXMgYXJvdW5kIHogYXhpcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDRSb3RhdGlvblooIHRoZXRhOiBudW1iZXIgKTogUmF3TWF0cml4NCB7XG4gIGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKTtcbiAgY29uc3QgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gIHJldHVybiBbXG4gICAgYywgLXMsIDAsIDAsXG4gICAgcywgYywgMCwgMCxcbiAgICAwLCAwLCAxLCAwLFxuICAgIDAsIDAsIDAsIDEsXG4gIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIDNkIHNjYWxpbmcgbWF0cml4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NFNjYWxlKCB2ZWM6IFJhd1ZlY3RvcjMgKTogUmF3TWF0cml4NCB7XG4gIHJldHVybiBbXG4gICAgdmVjWyAwIF0sIDAsIDAsIDAsXG4gICAgMCwgdmVjWyAxIF0sIDAsIDAsXG4gICAgMCwgMCwgdmVjWyAyIF0sIDAsXG4gICAgMCwgMCwgMCwgMSxcbiAgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSAzZCBzY2FsaW5nIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDRTY2FsZVNjYWxhciggc2NhbGFyOiBudW1iZXIgKTogUmF3TWF0cml4NCB7XG4gIHJldHVybiBbXG4gICAgc2NhbGFyLCAwLCAwLCAwLFxuICAgIDAsIHNjYWxhciwgMCwgMCxcbiAgICAwLCAwLCBzY2FsYXIsIDAsXG4gICAgMCwgMCwgMCwgMSxcbiAgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgdHJhbnNsYXRpb24gbWF0cml4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NFRyYW5zbGF0ZSggdmVjOiBSYXdWZWN0b3IzICk6IFJhd01hdHJpeDQge1xuICByZXR1cm4gW1xuICAgIDEsIDAsIDAsIDAsXG4gICAgMCwgMSwgMCwgMCxcbiAgICAwLCAwLCAxLCAwLFxuICAgIHZlY1sgMCBdLCB2ZWNbIDEgXSwgdmVjWyAyIF0sIDFcbiAgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5cbi8qKlxuICogVHJhbnNwb3NlIGEgbWF0NC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDRUcmFuc3Bvc2UoIG06IFJhd01hdHJpeDQgKTogUmF3TWF0cml4NCB7XG4gIHJldHVybiBbXG4gICAgbVsgMCBdLCBtWyA0IF0sIG1bIDggXSwgbVsgMTIgXSxcbiAgICBtWyAxIF0sIG1bIDUgXSwgbVsgOSBdLCBtWyAxMyBdLFxuICAgIG1bIDIgXSwgbVsgNiBdLCBtWyAxMCBdLCBtWyAxNCBdLFxuICAgIG1bIDMgXSwgbVsgNyBdLCBtWyAxMSBdLCBtWyAxNSBdLFxuICBdO1xufVxuIiwiaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uL21hdDMvTWF0cml4Myc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vcXVhdC9RdWF0ZXJuaW9uJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1ZlY3RvcjMnO1xuaW1wb3J0IHsgbWF0NENvbXBvc2UgfSBmcm9tICcuL21hdDRDb21wb3NlJztcbmltcG9ydCB7IG1hdDREZWNvbXBvc2UgfSBmcm9tICcuL21hdDREZWNvbXBvc2UnO1xuaW1wb3J0IHsgbWF0NERldGVybWluYW50IH0gZnJvbSAnLi9tYXQ0RGV0ZXJtaW5hbnQnO1xuaW1wb3J0IHsgbWF0NEZyb21NYXQzIH0gZnJvbSAnLi9tYXQ0RnJvbU1hdDMnO1xuaW1wb3J0IHsgbWF0NEZyb21RdWF0ZXJuaW9uIH0gZnJvbSAnLi9tYXQ0RnJvbVF1YXRlcm5pb24nO1xuaW1wb3J0IHsgbWF0NEludmVyc2UgfSBmcm9tICcuL21hdDRJbnZlcnNlJztcbmltcG9ydCB7IG1hdDRMb29rQXQgfSBmcm9tICcuL21hdDRMb29rQXQnO1xuaW1wb3J0IHsgbWF0NExvb2tBdEludmVyc2UgfSBmcm9tICcuL21hdDRMb29rQXRJbnZlcnNlJztcbmltcG9ydCB7IG1hdDRNdWx0aXBseSB9IGZyb20gJy4vbWF0NE11bHRpcGx5JztcbmltcG9ydCB7IG1hdDRQZXJzcGVjdGl2ZSB9IGZyb20gJy4vbWF0NFBlcnNwZWN0aXZlJztcbmltcG9ydCB7IG1hdDRSb3RhdGlvblggfSBmcm9tICcuL21hdDRSb3RhdGlvblgnO1xuaW1wb3J0IHsgbWF0NFJvdGF0aW9uWSB9IGZyb20gJy4vbWF0NFJvdGF0aW9uWSc7XG5pbXBvcnQgeyBtYXQ0Um90YXRpb25aIH0gZnJvbSAnLi9tYXQ0Um90YXRpb25aJztcbmltcG9ydCB7IG1hdDRTY2FsZSB9IGZyb20gJy4vbWF0NFNjYWxlJztcbmltcG9ydCB7IG1hdDRTY2FsZVNjYWxhciB9IGZyb20gJy4vbWF0NFNjYWxlU2NhbGFyJztcbmltcG9ydCB7IG1hdDRUcmFuc2xhdGUgfSBmcm9tICcuL21hdDRUcmFuc2xhdGUnO1xuaW1wb3J0IHsgbWF0NFRyYW5zcG9zZSB9IGZyb20gJy4vbWF0NFRyYW5zcG9zZSc7XG5pbXBvcnQgeyB2ZWNTY2FsZSB9IGZyb20gJy4uL3ZlYy92ZWNTY2FsZSc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuXG5jb25zdCByYXdJZGVudGl0eU1hdHJpeDQ6IFJhd01hdHJpeDQgPSBbXG4gIDEuMCwgMC4wLCAwLjAsIDAuMCxcbiAgMC4wLCAxLjAsIDAuMCwgMC4wLFxuICAwLjAsIDAuMCwgMS4wLCAwLjAsXG4gIDAuMCwgMC4wLCAwLjAsIDEuMFxuXTtcblxuLyoqXG4gKiBBIE1hdHJpeDQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRyaXg0IHtcbiAgcHVibGljIGVsZW1lbnRzOiBSYXdNYXRyaXg0O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdjogUmF3TWF0cml4NCA9IHJhd0lkZW50aXR5TWF0cml4NCApIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gdjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IHRyYW5zcG9zZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRyYW5zcG9zZSgpOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRUcmFuc3Bvc2UoIHRoaXMuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0cyBkZXRlcm1pbmFudC5cbiAgICovXG4gIHB1YmxpYyBnZXQgZGV0ZXJtaW5hbnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gbWF0NERldGVybWluYW50KCB0aGlzLmVsZW1lbnRzICk7XG4gIH1cblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCBpbnZlcnRlZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaW52ZXJzZSgpOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRJbnZlcnNlKCB0aGlzLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IG1hdHJpeDMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IG1hdHJpeDMoKTogTWF0cml4MyB7XG4gICAgcmV0dXJuIE1hdHJpeDMuZnJvbU1hdHJpeDQoIHRoaXMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IG5vcm1hbCBtYXRyaXguXG4gICAqL1xuICBwdWJsaWMgZ2V0IG5vcm1hbE1hdHJpeCgpOiBNYXRyaXgzIHtcbiAgICByZXR1cm4gTWF0cml4My5jcmVhdGVOb3JtYWxNYXRyaXgoIHRoaXMgKTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzLm1hcCggKCB2ICkgPT4gdi50b0ZpeGVkKCAzICkgKTtcbiAgICByZXR1cm4gYE1hdHJpeDQoICR7IG1bIDAgXSB9LCAkeyBtWyA0IF0gfSwgJHsgbVsgOCBdIH0sICR7IG1bIDEyIF0gfTsgJHsgbVsgMSBdIH0sICR7IG1bIDUgXSB9LCAkeyBtWyA5IF0gfSwgJHsgbVsgMTMgXSB9OyAkeyBtWyAyIF0gfSwgJHsgbVsgNiBdIH0sICR7IG1bIDEwIF0gfSwgJHsgbVsgMTQgXSB9OyAkeyBtWyAzIF0gfSwgJHsgbVsgNyBdIH0sICR7IG1bIDExIF0gfSwgJHsgbVsgMTUgXSB9IClgO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgY2xvbmUoKTogTWF0cml4NCB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0KCB0aGlzLmVsZW1lbnRzLmNvbmNhdCgpIGFzIFJhd01hdHJpeDQgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGlzIE1hdHJpeDQgYnkgb25lIG9yIG1vcmUgTWF0cml4NHMuXG4gICAqL1xuICBwdWJsaWMgbXVsdGlwbHkoIC4uLm1hdHJpY2VzOiBNYXRyaXg0W10gKTogTWF0cml4NCB7XG4gICAgcmV0dXJuIE1hdHJpeDQubXVsdGlwbHkoIHRoaXMsIC4uLm1hdHJpY2VzICk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgdGhpcyBNYXRyaXg0IGJ5IGEgc2NhbGFyLlxuICAgKi9cbiAgcHVibGljIHNjYWxlU2NhbGFyKCBzY2FsYXI6IG51bWJlciApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIHZlY1NjYWxlKCB0aGlzLmVsZW1lbnRzLCBzY2FsYXIgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcG9zZSB0aGlzIG1hdHJpeCBpbnRvIGEgcG9zaXRpb24sIGEgc2NhbGUsIGFuZCBhIHJvdGF0aW9uLlxuICAgKi9cbiAgcHVibGljIGRlY29tcG9zZSgpOiB7IHBvc2l0aW9uOiBWZWN0b3IzOyBzY2FsZTogVmVjdG9yMzsgcm90YXRpb246IFF1YXRlcm5pb24gfSB7XG4gICAgY29uc3QgeyBwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uIH0gPSBtYXQ0RGVjb21wb3NlKCB0aGlzLmVsZW1lbnRzICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IG5ldyBWZWN0b3IzKCBwb3NpdGlvbiApLFxuICAgICAgc2NhbGU6IG5ldyBWZWN0b3IzKCBzY2FsZSApLFxuICAgICAgcm90YXRpb246IG5ldyBRdWF0ZXJuaW9uKCByb3RhdGlvbiApLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQW4gaWRlbnRpdHkgTWF0cml4NC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IGlkZW50aXR5KCk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggcmF3SWRlbnRpdHlNYXRyaXg0ICk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgdHdvIG9yIG1vcmUgbWF0cmljZXMuXG4gICAqIEBwYXJhbSBtYXRyaWNlcyBNYXRyaWNlc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtdWx0aXBseSggLi4ubWF0cmljZXM6IE1hdHJpeDRbXSApOiBNYXRyaXg0IHtcbiAgICBpZiAoIG1hdHJpY2VzLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgIHJldHVybiBNYXRyaXg0LmlkZW50aXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRNdWx0aXBseSggLi4ubWF0cmljZXMubWFwKCAoIG0gKSA9PiBtLmVsZW1lbnRzICkgKSApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtYXRyaXggb3V0IG9mIGEge0BsaW5rIFF1YXRlcm5pb259LlxuICAgKiBAcGFyYW0gcXVhdGVybmlvbiBBIHF1YXRlcm5pb25cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb246IFF1YXRlcm5pb24gKTogTWF0cml4NCB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0KCBtYXQ0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24uZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIENhc3QgYSB7QGxpbmsgTWF0cml4M30gaW50byBhIE1hdHJpeDQuXG4gICAqIEBwYXJhbSBtYXRyaXgzIEEgbWF0cml4M1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tTWF0cml4MyggbWF0cml4MzogTWF0cml4MyApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRGcm9tTWF0MyggbWF0cml4My5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2xhdGlvbiBtYXRyaXguXG4gICAqIEBwYXJhbSB2ZWN0b3IgVHJhbnNsYXRpb25cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgdHJhbnNsYXRlKCB2ZWN0b3I6IFZlY3RvcjMgKTogTWF0cml4NCB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0KCBtYXQ0VHJhbnNsYXRlKCB2ZWN0b3IuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgM2Qgc2NhbGluZyBtYXRyaXguXG4gICAqIEBwYXJhbSB2ZWN0b3IgU2NhbGVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc2NhbGUoIHZlY3RvcjogVmVjdG9yMyApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRTY2FsZSggdmVjdG9yLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIDNkIHNjYWxpbmcgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICAgKiBAcGFyYW0gdmVjdG9yIFNjYWxlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNjYWxlU2NhbGFyKCBzY2FsYXI6IG51bWJlciApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRTY2FsZVNjYWxhciggc2NhbGFyICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIDNkIHJvdGF0aW9uIG1hdHJpeCwgcm90YXRlcyBhcm91bmQgeCBheGlzLlxuICAgKiBAcGFyYW0gdmVjdG9yIFNjYWxlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJvdGF0aW9uWCggdGhldGE6IG51bWJlciApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRSb3RhdGlvblgoIHRoZXRhICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIDNkIHJvdGF0aW9uIG1hdHJpeCwgcm90YXRlcyBhcm91bmQgeSBheGlzLlxuICAgKiBAcGFyYW0gdmVjdG9yIFNjYWxlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJvdGF0aW9uWSggdGhldGE6IG51bWJlciApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRSb3RhdGlvblkoIHRoZXRhICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIDNkIHJvdGF0aW9uIG1hdHJpeCwgcm90YXRlcyBhcm91bmQgeiBheGlzLlxuICAgKiBAcGFyYW0gdmVjdG9yIFNjYWxlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJvdGF0aW9uWiggdGhldGE6IG51bWJlciApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRSb3RhdGlvblooIHRoZXRhICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFwiTG9va0F0XCIgbWF0cml4LlxuICAgKlxuICAgKiBTZWUgYWxzbzoge0BsaW5rIGxvb2tBdEludmVyc2V9XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGxvb2tBdChcbiAgICBwb3NpdGlvbjogVmVjdG9yMyxcbiAgICB0YXJnZXQgPSBuZXcgVmVjdG9yMyggWyAwLjAsIDAuMCwgMC4wIF0gKSxcbiAgICB1cCA9IG5ldyBWZWN0b3IzKCBbIDAuMCwgMS4wLCAwLjAgXSApLFxuICAgIHJvbGwgPSAwLjBcbiAgKTogTWF0cml4NCB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0KCBtYXQ0TG9va0F0KFxuICAgICAgcG9zaXRpb24uZWxlbWVudHMsXG4gICAgICB0YXJnZXQuZWxlbWVudHMsXG4gICAgICB1cC5lbGVtZW50cyxcbiAgICAgIHJvbGwsXG4gICAgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGludmVyc2Ugb2YgXCJMb29rQXRcIiBtYXRyaXguIEdvb2QgZm9yIGNyZWF0aW5nIGEgdmlldyBtYXRyaXguXG4gICAqXG4gICAqIFNlZSBhbHNvOiB7QGxpbmsgbG9va0F0fVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBsb29rQXRJbnZlcnNlKFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIHRhcmdldCA9IG5ldyBWZWN0b3IzKCBbIDAuMCwgMC4wLCAwLjAgXSApLFxuICAgIHVwID0gbmV3IFZlY3RvcjMoIFsgMC4wLCAxLjAsIDAuMCBdICksXG4gICAgcm9sbCA9IDAuMFxuICApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRMb29rQXRJbnZlcnNlKFxuICAgICAgcG9zaXRpb24uZWxlbWVudHMsXG4gICAgICB0YXJnZXQuZWxlbWVudHMsXG4gICAgICB1cC5lbGVtZW50cyxcbiAgICAgIHJvbGwsXG4gICAgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgXCJQZXJzcGVjdGl2ZVwiIHByb2plY3Rpb24gbWF0cml4LlxuICAgKiBJdCB3b24ndCBpbmNsdWRlIGFzcGVjdCFcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcGVyc3BlY3RpdmUoIGZvdiA9IDQ1LjAsIG5lYXIgPSAwLjAxLCBmYXIgPSAxMDAuMCApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRQZXJzcGVjdGl2ZSggZm92LCBuZWFyLCBmYXIgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBvc2UgYSBtYXRyaXggb3V0IG9mIHBvc2l0aW9uLCBzY2FsZSwgYW5kIHJvdGF0aW9uLlxuICAgKiBZb2lua2VkIGZyb20gVGhyZWUuanMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNvbXBvc2UoIHBvc2l0aW9uOiBWZWN0b3IzLCByb3RhdGlvbjogUXVhdGVybmlvbiwgc2NhbGU6IFZlY3RvcjMgKTogTWF0cml4NCB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0KCBtYXQ0Q29tcG9zZSggcG9zaXRpb24uZWxlbWVudHMsIHJvdGF0aW9uLmVsZW1lbnRzLCBzY2FsZS5lbGVtZW50cyApICk7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4vUmF3UXVhdGVybmlvbic7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgUXVhdGVybmlvbiBvdXQgb2YgYXhpcyBhbmQgYW5nbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWF0RnJvbUF4aXNBbmdsZSggYXhpczogUmF3VmVjdG9yMywgYW5nbGU6IG51bWJlciApOiBSYXdRdWF0ZXJuaW9uIHtcbiAgY29uc3QgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLjA7XG4gIGNvbnN0IHNpbkhhbGZBbmdsZSA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcbiAgcmV0dXJuIFtcbiAgICBheGlzWyAwIF0gKiBzaW5IYWxmQW5nbGUsXG4gICAgYXhpc1sgMSBdICogc2luSGFsZkFuZ2xlLFxuICAgIGF4aXNbIDIgXSAqIHNpbkhhbGZBbmdsZSxcbiAgICBNYXRoLmNvcyggaGFsZkFuZ2xlIClcbiAgXTtcbn1cbiIsImltcG9ydCB7IHZlYzNPcnRob05vcm1hbGl6ZSB9IGZyb20gJy4uL3ZlYzMvdmVjM09ydGhvTm9ybWFsaXplJztcbmltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4vUmF3UXVhdGVybmlvbic7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFJldHVybiBhIHF1YXRlcm5pb24gd2hpY2ggbG9va3MgYXQgdGhlIGRpcmVjdGlvbiBvZiBgbG9va2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWF0TG9va1JvdGF0aW9uKCBsb29rOiBSYXdWZWN0b3IzLCB1cD86IFJhd1ZlY3RvcjMgKTogUmF3UXVhdGVybmlvbiB7XG4gIGNvbnN0IHsgbm9ybWFsLCB0YW5nZW50LCBiaW5vcm1hbCB9ID0gdmVjM09ydGhvTm9ybWFsaXplKCBsb29rLCB1cCA/PyBbIDAuMCwgMS4wLCAwLjAgXSApO1xuXG4gIGNvbnN0IHcgPSBNYXRoLnNxcnQoIDEuMCArIGJpbm9ybWFsWyAwIF0gKyB0YW5nZW50WyAxIF0gKyBub3JtYWxbIDIgXSApICogMC41O1xuICBjb25zdCBpbnZXNCA9IDAuMjUgLyB3O1xuXG4gIHJldHVybiBbXG4gICAgKCB0YW5nZW50WyAyIF0gLSBub3JtYWxbIDEgXSApICogaW52VzQsXG4gICAgKCBub3JtYWxbIDAgXSAtIGJpbm9ybWFsWyAyIF0gKSAqIGludlc0LFxuICAgICggYmlub3JtYWxbIDEgXSAtIHRhbmdlbnRbIDAgXSApICogaW52VzQsXG4gICAgdyxcbiAgXTtcbn1cbiIsImltcG9ydCB7IHZlY0xlbmd0aCB9IGZyb20gJy4uL3ZlYy92ZWNMZW5ndGgnO1xuaW1wb3J0IHsgdmVjU2NhbGUgfSBmcm9tICcuLi92ZWMvdmVjU2NhbGUnO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi9SYXdRdWF0ZXJuaW9uJztcblxuLyoqXG4gKiBOb3JtYWxpemUgZ2l2ZW4gcXVhdGVybmlvbi5cbiAqXG4gKiBJdCdzIGFsbW9zdCBpZGVudGljYWwgYXMge0BsaW5rIHZlY05vcm1hbGl6ZX0sXG4gKiBidXQgaXQgd2lsbCByZXR1cm4gYW4gaWRlbnRpdHkgcXVhdGVybmlvbiBpbnN0ZWFkXG4gKiB3aGVuIGl0IHJlY2lldmVzIGEgcXVhdGVybmlvbiB3aGljaCBsZW5ndGggaXMgemVyby5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXROb3JtYWxpemUoIHZlYzogUmF3UXVhdGVybmlvbiApOiBSYXdRdWF0ZXJuaW9uIHtcbiAgY29uc3QgbGVuID0gdmVjTGVuZ3RoKCB2ZWMgKTtcbiAgaWYgKCBsZW4gPT09IDAuMCApIHtcbiAgICByZXR1cm4gWyAwLjAsIDAuMCwgMC4wLCAxLjAgXTtcbiAgfVxuICByZXR1cm4gdmVjU2NhbGUoIHZlYywgMS4wIC8gbGVuICk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd1F1YXRlcm5pb24gfSBmcm9tICcuL1Jhd1F1YXRlcm5pb24nO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcXVhdGVybmlvbiByb3RhdGVzIGFyb3VuZCB4IGF4aXMuXG4gKiBAcGFyYW0gdGhldGEgQW4gYW5nbGUgYXJvdW5kIHggYXhpcywgaW4gZGVncmVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWF0Um90YXRpb25YKCB0aGV0YTogbnVtYmVyICk6IFJhd1F1YXRlcm5pb24ge1xuICByZXR1cm4gWyBNYXRoLnNpbiggdGhldGEgLyAyLjAgKSwgMC4wLCAwLjAsIE1hdGguY29zKCB0aGV0YSAvIDIuMCApIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd1F1YXRlcm5pb24gfSBmcm9tICcuL1Jhd1F1YXRlcm5pb24nO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcXVhdGVybmlvbiByb3RhdGVzIGFyb3VuZCB5IGF4aXMuXG4gKiBAcGFyYW0gdGhldGEgQW4gYW5nbGUgYXJvdW5kIHkgYXhpcywgaW4gZGVncmVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWF0Um90YXRpb25ZKCB0aGV0YTogbnVtYmVyICk6IFJhd1F1YXRlcm5pb24ge1xuICByZXR1cm4gWyAwLjAsIE1hdGguc2luKCB0aGV0YSAvIDIuMCApLCAwLjAsIE1hdGguY29zKCB0aGV0YSAvIDIuMCApIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd1F1YXRlcm5pb24gfSBmcm9tICcuL1Jhd1F1YXRlcm5pb24nO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcXVhdGVybmlvbiByb3RhdGVzIGFyb3VuZCB6IGF4aXMuXG4gKiBAcGFyYW0gdGhldGEgQW4gYW5nbGUgYXJvdW5kIHogYXhpcywgaW4gZGVncmVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWF0Um90YXRpb25aKCB0aGV0YTogbnVtYmVyICk6IFJhd1F1YXRlcm5pb24ge1xuICByZXR1cm4gWyAwLjAsIDAuMCwgTWF0aC5zaW4oIHRoZXRhIC8gMi4wICksIE1hdGguY29zKCB0aGV0YSAvIDIuMCApIF07XG59XG4iLCJpbXBvcnQgeyB2ZWNEb3QsIHZlY05lZywgdmVjTm9ybWFsaXplIH0gZnJvbSAnLi4nO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi9SYXdRdWF0ZXJuaW9uJztcblxuLyoqXG4gKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHR3byBxdWF0ZXJuaW9ucy5cbiAqIEBwYXJhbSBhIFwiZnJvbVwiIHF1YXRlcm5pb25cbiAqIEBwYXJhbSBiIFwidG9cIiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0gdCBIb3cgbXVjaCBkbyB3ZSB3YW50IHRvIHJvdGF0ZSB0aGUgYSB0byBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWF0U2xlcnAoIGE6IFJhd1F1YXRlcm5pb24sIGI6IFJhd1F1YXRlcm5pb24sIHQ6IG51bWJlciApOiBSYXdRdWF0ZXJuaW9uIHtcbiAgaWYgKCB0ID09PSAwLjAgKSB7IHJldHVybiBhLmNvbmNhdCgpIGFzIFJhd1F1YXRlcm5pb247IH1cbiAgaWYgKCB0ID09PSAxLjAgKSB7IHJldHVybiBiLmNvbmNhdCgpIGFzIFJhd1F1YXRlcm5pb247IH1cblxuICAvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9tYXN0ZXIvc3JjL21hdGgvUXVhdGVybmlvbi5qc1xuICAvLyBSZWY6IGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cbiAgbGV0IGNvc0hhbGZUaGV0YSA9IHZlY0RvdCggYSwgYiApO1xuXG4gIGlmICggY29zSGFsZlRoZXRhIDwgMC4wICkge1xuICAgIGIgPSB2ZWNOZWcoIGIgKTtcbiAgICBjb3NIYWxmVGhldGEgPSAtY29zSGFsZlRoZXRhO1xuICB9XG5cbiAgLy8gSSB0aGluayB5b3UgdHdvIGFyZSBzYW1lXG4gIGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcbiAgICByZXR1cm4gYS5jb25jYXQoKSBhcyBSYXdRdWF0ZXJuaW9uO1xuICB9XG5cbiAgY29uc3Qgc3FyU2luSGFsZlRoZXRhID0gMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhO1xuXG4gIC8vIGZhbGxiYWNrIHRvIHNpbXBsZSBsZXJwXG4gIGlmICggc3FyU2luSGFsZlRoZXRhIDw9IE51bWJlci5FUFNJTE9OICkge1xuICAgIGNvbnN0IHMgPSAxLjAgLSB0O1xuXG4gICAgcmV0dXJuIHZlY05vcm1hbGl6ZSggW1xuICAgICAgcyAqIGFbIDAgXSArIHQgKiBiWyAwIF0sXG4gICAgICBzICogYVsgMSBdICsgdCAqIGJbIDEgXSxcbiAgICAgIHMgKiBhWyAyIF0gKyB0ICogYlsgMiBdLFxuICAgICAgcyAqIGFbIDMgXSArIHQgKiBiWyAzIF0sXG4gICAgXSApO1xuICB9XG5cbiAgLy8gd2VsY29tZVxuICBjb25zdCBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIHNxclNpbkhhbGZUaGV0YSApO1xuICBjb25zdCBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKCBzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSApO1xuICBjb25zdCByYXRpb0EgPSBNYXRoLnNpbiggKCAxLjAgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcbiAgY29uc3QgcmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuICByZXR1cm4gW1xuICAgIGFbIDAgXSAqIHJhdGlvQSArIGJbIDAgXSAqIHJhdGlvQixcbiAgICBhWyAxIF0gKiByYXRpb0EgKyBiWyAxIF0gKiByYXRpb0IsXG4gICAgYVsgMiBdICogcmF0aW9BICsgYlsgMiBdICogcmF0aW9CLFxuICAgIGFbIDMgXSAqIHJhdGlvQSArIGJbIDMgXSAqIHJhdGlvQixcbiAgXTtcbn1cbiIsImltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L01hdHJpeDQnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvVmVjdG9yMyc7XG5pbXBvcnQgeyBtYXQ0RnJvbVF1YXRlcm5pb24gfSBmcm9tICcuLi9tYXQ0L21hdDRGcm9tUXVhdGVybmlvbic7XG5pbXBvcnQgeyBxdWF0RnJvbUF4aXNBbmdsZSB9IGZyb20gJy4vcXVhdEZyb21BeGlzQW5nbGUnO1xuaW1wb3J0IHsgcXVhdEZyb21NYXRyaXg0IH0gZnJvbSAnLi9xdWF0RnJvbU1hdHJpeDQnO1xuaW1wb3J0IHsgcXVhdEludmVyc2UgfSBmcm9tICcuL3F1YXRJbnZlcnNlJztcbmltcG9ydCB7IHF1YXRMb29rUm90YXRpb24gfSBmcm9tICcuL3F1YXRMb29rUm90YXRpb24nO1xuaW1wb3J0IHsgcXVhdE11bHRpcGx5IH0gZnJvbSAnLi9xdWF0TXVsdGlwbHknO1xuaW1wb3J0IHsgcXVhdE5vcm1hbGl6ZSB9IGZyb20gJy4vcXVhdE5vcm1hbGl6ZSc7XG5pbXBvcnQgeyBxdWF0Um90YXRpb25YIH0gZnJvbSAnLi9xdWF0Um90YXRpb25YJztcbmltcG9ydCB7IHF1YXRSb3RhdGlvblkgfSBmcm9tICcuL3F1YXRSb3RhdGlvblknO1xuaW1wb3J0IHsgcXVhdFJvdGF0aW9uWiB9IGZyb20gJy4vcXVhdFJvdGF0aW9uWic7XG5pbXBvcnQgeyBxdWF0U2xlcnAgfSBmcm9tICcuL3F1YXRTbGVycCc7XG5pbXBvcnQgeyB2ZWNMZW5ndGggfSBmcm9tICcuLi92ZWMvdmVjTGVuZ3RoJztcbmltcG9ydCB7IHZlY0xlbmd0aFNxIH0gZnJvbSAnLi4vdmVjL3ZlY0xlbmd0aFNxJztcbmltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4vUmF3UXVhdGVybmlvbic7XG5cbmNvbnN0IHJhd0lkZW50aXR5UXVhdGVybmlvbjogUmF3UXVhdGVybmlvbiA9IFsgMC4wLCAwLjAsIDAuMCwgMS4wIF07XG5cbi8qKlxuICogQSBRdWF0ZXJuaW9uLlxuICovXG5leHBvcnQgY2xhc3MgUXVhdGVybmlvbiB7XG4gIHB1YmxpYyBlbGVtZW50czogUmF3UXVhdGVybmlvbjsgLy8gWyB4LCB5LCB6OyB3IF1cblxuICBwdWJsaWMgY29uc3RydWN0b3IoIGVsZW1lbnRzOiBSYXdRdWF0ZXJuaW9uID0gcmF3SWRlbnRpdHlRdWF0ZXJuaW9uICkge1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiB4IGNvbXBvbmVudCBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCB4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbIDAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiB5IGNvbXBvbmVudCBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCB5KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbIDEgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiB6IGNvbXBvbmVudCBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCB6KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbIDIgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiB3IGNvbXBvbmVudCBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCB3KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbIDMgXTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgUXVhdGVybmlvbiggJHsgdGhpcy54LnRvRml4ZWQoIDMgKSB9LCAkeyB0aGlzLnkudG9GaXhlZCggMyApIH0sICR7IHRoaXMuei50b0ZpeGVkKCAzICkgfSwgJHsgdGhpcy53LnRvRml4ZWQoIDMgKSB9IClgO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgY2xvbmUoKTogUXVhdGVybmlvbiB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKCB0aGlzLmVsZW1lbnRzLmNvbmNhdCgpIGFzIFJhd1F1YXRlcm5pb24gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IGNvbnZlcnRlZCBpbnRvIGEgTWF0cml4NC5cbiAgICovXG4gIHB1YmxpYyBnZXQgbWF0cml4NCgpOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRGcm9tUXVhdGVybmlvbiggdGhpcy5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogQW4gaW52ZXJzZSBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCBpbnZlcnNlZCgpOiBRdWF0ZXJuaW9uIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oIHF1YXRJbnZlcnNlKCB0aGlzLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGxlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB2ZWNMZW5ndGgoIHRoaXMuZWxlbWVudHMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3F1YXJlZCBsZW5ndGggb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgbGVuZ3RoU3EoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdmVjTGVuZ3RoU3EoIHRoaXMuZWxlbWVudHMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG5vcm1hbGl6ZWQgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgbm9ybWFsaXplZCgpOiBRdWF0ZXJuaW9uIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oIHF1YXROb3JtYWxpemUoIHRoaXMuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IG9uZSBvciBtb3JlIFF1YXRlcm5pb25zIHdpdGggdGhpcy5cbiAgICogQHBhcmFtIHF1YXRlcm5pb25zIE90aGVyIFF1YXRlcm5pb25zXG4gICAqL1xuICBwdWJsaWMgbXVsdGlwbHkoIC4uLnF1YXRlcm5pb25zOiBRdWF0ZXJuaW9uW10gKTogUXVhdGVybmlvbiB7XG4gICAgcmV0dXJuIFF1YXRlcm5pb24ubXVsdGlwbHkoIHRoaXMsIC4uLnF1YXRlcm5pb25zICk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJwb2xhdGUgYmV0d2VlbiB0aGlzIGFuZCBnaXZlbiBxdWF0ZXJuaW9uLlxuICAgKiBAcGFyYW0gYiBBbm90aGVyIFF1YXRlcm5pb25cbiAgICogQHBhcmFtIHQgSG93IG11Y2ggZG8gd2Ugd2FudCB0byByb3RhdGUgdGhpcyB0byBiXG4gICAqL1xuICBwdWJsaWMgc2xlcnAoIGI6IFF1YXRlcm5pb24sIHQ6IG51bWJlciApOiBRdWF0ZXJuaW9uIHtcbiAgICByZXR1cm4gUXVhdGVybmlvbi5zbGVycCggdGhpcywgYiwgdCApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGlkZW50aXR5IFF1YXRlcm5pb24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCBpZGVudGl0eSgpOiBRdWF0ZXJuaW9uIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oIHJhd0lkZW50aXR5UXVhdGVybmlvbiApO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHR3byBvciBtb3JlIG1hdHJpY2VzLlxuICAgKiBAcGFyYW0gcXVhdGVybmlvbiBRdWF0ZXJuaW9uc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtdWx0aXBseSggLi4ucXVhdGVybmlvbnM6IFF1YXRlcm5pb25bXSApOiBRdWF0ZXJuaW9uIHtcbiAgICBpZiAoIHF1YXRlcm5pb25zLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgIHJldHVybiBRdWF0ZXJuaW9uLmlkZW50aXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oIHF1YXRNdWx0aXBseSggLi4ucXVhdGVybmlvbnMubWFwKCAoIHEgKSA9PiBxLmVsZW1lbnRzICkgKSApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHR3byBxdWF0ZXJuaW9ucy5cbiAgICogQHBhcmFtIGEgXCJmcm9tXCIgcXVhdGVybmlvblxuICAgKiBAcGFyYW0gYiBcInRvXCIgcXVhdGVybmlvblxuICAgKiBAcGFyYW0gdCBIb3cgbXVjaCBkbyB3ZSB3YW50IHRvIHJvdGF0ZSB0aGUgYSB0byBiXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNsZXJwKCBhOiBRdWF0ZXJuaW9uLCBiOiBRdWF0ZXJuaW9uLCB0OiBudW1iZXIgKTogUXVhdGVybmlvbiB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKCBxdWF0U2xlcnAoIGEuZWxlbWVudHMsIGIuZWxlbWVudHMsIHQgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHF1YXRlcm5pb24gd2hpY2ggcm90YXRlcyBhcm91bmQgeCBheGlzLlxuICAgKiBAcGFyYW0gdGhldGEgQW4gYW5nbGUgYXJvdW5kIHggYXhpcywgaW4gZGVncmVlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJvdGF0aW9uWCggdGhldGE6IG51bWJlciApOiBRdWF0ZXJuaW9uIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oIHF1YXRSb3RhdGlvblgoIHRoZXRhICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBxdWF0ZXJuaW9uIHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHkgYXhpcy5cbiAgICogQHBhcmFtIHRoZXRhIEFuIGFuZ2xlIGFyb3VuZCB5IGF4aXMsIGluIGRlZ3JlZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByb3RhdGlvblkoIHRoZXRhOiBudW1iZXIgKTogUXVhdGVybmlvbiB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKCBxdWF0Um90YXRpb25ZKCB0aGV0YSApICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgcXVhdGVybmlvbiB3aGljaCByb3RhdGVzIGFyb3VuZCB6IGF4aXMuXG4gICAqIEBwYXJhbSB0aGV0YSBBbiBhbmdsZSBhcm91bmQgeiBheGlzLCBpbiBkZWdyZWVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcm90YXRpb25aKCB0aGV0YTogbnVtYmVyICk6IFF1YXRlcm5pb24ge1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbiggcXVhdFJvdGF0aW9uWiggdGhldGEgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHF1YXRlcm5pb24gd2hpY2ggbG9va3MgYXQgdGhlIGRpcmVjdGlvbiBvZiBgbG9va2AuXG4gICAqIEBwYXJhbSBsb29rIFBvc2l0aW9uIHdoZXJlIHRoZSBxdWF0ZXJuaW9uIHdpbGwgbG9vayBhdFxuICAgKiBAcGFyYW0gdXAgVGhlIFwidXAgdmVjdG9yXCJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbG9va1JvdGF0aW9uKCBsb29rOiBWZWN0b3IzLCB1cDogVmVjdG9yMyApOiBRdWF0ZXJuaW9uIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oIHF1YXRMb29rUm90YXRpb24oIGxvb2suZWxlbWVudHMsIHVwLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFF1YXRlcm5pb24gb3V0IG9mIGFuZ2xlIGFuZCBheGlzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tQXhpc0FuZ2xlKCBheGlzOiBWZWN0b3IzLCBhbmdsZTogbnVtYmVyICk6IFF1YXRlcm5pb24ge1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbiggcXVhdEZyb21BeGlzQW5nbGUoIGF4aXMuZWxlbWVudHMsIGFuZ2xlICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFF1YXRlcm5pb24gb3V0IG9mIGEgcm90YXRpb24gbWF0cml4LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tTWF0cml4NCggbWF0cml4OiBNYXRyaXg0ICk6IFF1YXRlcm5pb24ge1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbiggcXVhdEZyb21NYXRyaXg0KCBtYXRyaXguZWxlbWVudHMgKSApO1xuICB9XG59XG4iLCIvKipcbiAqIEdMU0wgU3R5bGUgYG1vZGAgZnVuY3Rpb24uXG4gKiBcImNvbXB1dGUgdmFsdWUgb2Ygb25lIHBhcmFtZXRlciBtb2R1bG8gYW5vdGhlclwiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2QoIHZhbHVlOiBudW1iZXIsIGRpdmlzb3I6IG51bWJlciApOiBudW1iZXIge1xuICByZXR1cm4gdmFsdWUgLSBNYXRoLmZsb29yKCB2YWx1ZSAvIGRpdmlzb3IgKSAqIGRpdmlzb3I7XG59XG4iLCJpbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZCc7XG5cbi8qKlxuICogRW5jbG9zZSBhcmJpdHJhcnkgYW5nbGUgKGluIHJhZGlhbikgaW50byBbLc+ALCDPgClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplQW5nbGUoIGFuZ2xlOiBudW1iZXIgKTogbnVtYmVyIHtcbiAgcmV0dXJuIG1vZCggYW5nbGUgKyBNYXRoLlBJLCAyLjAgKiBNYXRoLlBJICkgLSBNYXRoLlBJO1xufVxuIiwiaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBzYW5pdGl6ZUFuZ2xlIH0gZnJvbSAnLi4vc2FuaXRpemVBbmdsZSc7XG5pbXBvcnQgeyB2ZWNNYW5oYXR0YW5MZW5ndGggfSBmcm9tICcuLi92ZWMvdmVjTWFuaGF0dGFuTGVuZ3RoJztcbmltcG9ydCB0eXBlIHsgRXVsZXJPcmRlciB9IGZyb20gJy4vRXVsZXJPcmRlcic7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDMgfSBmcm9tICcuLi9tYXQzL1Jhd01hdHJpeDMnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBSZXR1cm4gYSBldWxlciBhbmdsZXMgb3V0IG9mIGEgbWF0cml4My5cbiAqIE1ha2Ugc3VyZSB0aGUgaW5wdXQgbWF0cml4IGlzIG5vcm1hbGl6ZWQuXG4gKlxuICogQHBhcmFtIG0gQW4gaW5wdXQgcm90YXRpb24gbWF0cml4XG4gKiBAcGFyYW0gb3JkZXIgQW4gb3JkZXIgb2Ygb3V0cHV0IGV1bGVyIGFuZ2xlcy4gQXNzdW1lIGFzIGBYWVpgIGlmIG5vdCBzcGVjaWZpZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV1bGVyRnJvbU1hdDMoIG06IFJhd01hdHJpeDMsIG9yZGVyPzogRXVsZXJPcmRlciApOiBSYXdWZWN0b3IzIHtcbiAgY29uc3QgWyBpLCBqLCBrLCBzaWduIF0gPVxuICAgICFvcmRlciB8fCBvcmRlciA9PT0gJ1hZWicgPyBbIDAsIDEsIDIsIDEgXSA6XG4gICAgb3JkZXIgPT09ICdYWlknID8gWyAwLCAyLCAxLCAtMSBdIDpcbiAgICBvcmRlciA9PT0gJ1lYWicgPyBbIDEsIDAsIDIsIC0xIF0gOlxuICAgIG9yZGVyID09PSAnWVpYJyA/IFsgMSwgMiwgMCwgMSBdIDpcbiAgICBvcmRlciA9PT0gJ1pYWScgPyBbIDIsIDAsIDEsIDEgXSA6XG4gICAgWyAyLCAxLCAwLCAtMSBdO1xuXG4gIGNvbnN0IHJlc3VsdDogUmF3VmVjdG9yMyA9IFsgMC4wLCAwLjAsIDAuMCBdO1xuXG4gIGNvbnN0IGMgPSBtWyBrICsgaSAqIDMgXTtcbiAgcmVzdWx0WyBqIF0gPSAtc2lnbiAqIE1hdGguYXNpbiggY2xhbXAoIGMsIC0xLjAsIDEuMCApICk7XG5cbiAgaWYgKCBNYXRoLmFicyggYyApIDwgMC45OTk5OTkgKSB7XG4gICAgcmVzdWx0WyBpIF0gPSBzaWduICogTWF0aC5hdGFuMiggbVsgayArIGogKiAzIF0sIG1bIGsgKiA0IF0gKTtcbiAgICByZXN1bHRbIGsgXSA9IHNpZ24gKiBNYXRoLmF0YW4yKCBtWyBqICsgaSAqIDMgXSwgbVsgaSAqIDQgXSApO1xuICB9IGVsc2Uge1xuICAgIC8vIFwieSBpcyA5MGRlZ1wiIGNhc2VzXG4gICAgcmVzdWx0WyBpIF0gPSBzaWduICogTWF0aC5hdGFuMiggLW1bIGogKyBrICogMyBdLCBtWyBqICogNCBdICk7XG4gIH1cblxuICBpZiAoIHZlY01hbmhhdHRhbkxlbmd0aCggcmVzdWx0ICkgPiAxLjUgKiBNYXRoLlBJICkge1xuICAgIC8vIFwidHdvIGJpZyByZXZvbHV0aW9uc1wiIGNhc2VzXG4gICAgcmVzdWx0WyBpIF0gPSBzYW5pdGl6ZUFuZ2xlKCByZXN1bHRbIGkgXSArIE1hdGguUEkgKTtcbiAgICByZXN1bHRbIGogXSA9IHNhbml0aXplQW5nbGUoIE1hdGguUEkgLSByZXN1bHRbIGogXSApO1xuICAgIHJlc3VsdFsgayBdID0gc2FuaXRpemVBbmdsZSggcmVzdWx0WyBrIF0gKyBNYXRoLlBJICk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHsgZXVsZXJGcm9tTWF0MyB9IGZyb20gJy4vZXVsZXJGcm9tTWF0Myc7XG5pbXBvcnQgeyBtYXQzRnJvbU1hdDQgfSBmcm9tICcuLi9tYXQzL21hdDNGcm9tTWF0NCc7XG5pbXBvcnQgdHlwZSB7IEV1bGVyT3JkZXIgfSBmcm9tICcuL0V1bGVyT3JkZXInO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NC9SYXdNYXRyaXg0JztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogUmV0dXJuIGEgZXVsZXIgYW5nbGVzIG91dCBvZiBhIG1hdHJpeDQuXG4gKiBNYWtlIHN1cmUgdGhlIGlucHV0IG1hdHJpeCBpcyBub3JtYWxpemVkLlxuICpcbiAqIEBwYXJhbSBtIEFuIGlucHV0IHJvdGF0aW9uIG1hdHJpeFxuICogQHBhcmFtIG9yZGVyIEFuIG9yZGVyIG9mIG91dHB1dCBldWxlciBhbmdsZXMuIEFzc3VtZSBhcyBgWFlaYCBpZiBub3Qgc3BlY2lmaWVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldWxlckZyb21NYXQ0KCBtOiBSYXdNYXRyaXg0LCBvcmRlcj86IEV1bGVyT3JkZXIgKTogUmF3VmVjdG9yMyB7XG4gIHJldHVybiBldWxlckZyb21NYXQzKCBtYXQzRnJvbU1hdDQoIG0gKSwgb3JkZXIgKTtcbn1cbiIsImltcG9ydCB7IGV1bGVyRnJvbU1hdDMgfSBmcm9tICcuL2V1bGVyRnJvbU1hdDMnO1xuaW1wb3J0IHsgbWF0M0Zyb21RdWF0ZXJuaW9uIH0gZnJvbSAnLi4vbWF0My9tYXQzRnJvbVF1YXRlcm5pb24nO1xuaW1wb3J0IHR5cGUgeyBFdWxlck9yZGVyIH0gZnJvbSAnLi9FdWxlck9yZGVyJztcbmltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4uL3F1YXQvUmF3UXVhdGVybmlvbic7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFJldHVybiBhIGV1bGVyIGFuZ2xlcyBvdXQgb2YgYSBxdWF0ZXJuaW9uLlxuICpcbiAqIEBwYXJhbSBtIEFuIGlucHV0IHF1YXRlcm5pb25cbiAqIEBwYXJhbSBvcmRlciBBbiBvcmRlciBvZiBvdXRwdXQgZXVsZXIgYW5nbGVzLiBBc3N1bWUgYXMgYFhZWmAgaWYgbm90IHNwZWNpZmllZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXVsZXJGcm9tUXVhdGVybmlvbiggbTogUmF3UXVhdGVybmlvbiwgb3JkZXI/OiBFdWxlck9yZGVyICk6IFJhd1ZlY3RvcjMge1xuICByZXR1cm4gZXVsZXJGcm9tTWF0MyggbWF0M0Zyb21RdWF0ZXJuaW9uKCBtICksIG9yZGVyICk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IEV1bGVyT3JkZXIgfSBmcm9tICcuLi9ldWxlci9FdWxlck9yZGVyJztcbmltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4vUmF3UXVhdGVybmlvbic7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgUXVhdGVybmlvbiBvdXQgb2YgZXVsZXIgYW5nbGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhdEZyb21FdWxlciggZXVsZXI6IFJhd1ZlY3RvcjMsIG9yZGVyPzogRXVsZXJPcmRlciApOiBSYXdRdWF0ZXJuaW9uIHtcbiAgY29uc3QgWyBpLCBqLCBrLCBzaWduIF0gPVxuICAgICFvcmRlciB8fCBvcmRlciA9PT0gJ1hZWicgPyBbIDAsIDEsIDIsIDEgXSA6XG4gICAgb3JkZXIgPT09ICdYWlknID8gWyAwLCAyLCAxLCAtMSBdIDpcbiAgICBvcmRlciA9PT0gJ1lYWicgPyBbIDEsIDAsIDIsIC0xIF0gOlxuICAgIG9yZGVyID09PSAnWVpYJyA/IFsgMSwgMiwgMCwgMSBdIDpcbiAgICBvcmRlciA9PT0gJ1pYWScgPyBbIDIsIDAsIDEsIDEgXSA6XG4gICAgWyAyLCAxLCAwLCAtMSBdO1xuXG4gIGNvbnN0IHRpID0gMC41ICogZXVsZXJbIGkgXTtcbiAgY29uc3QgdGogPSAwLjUgKiBzaWduICogZXVsZXJbIGogXTtcbiAgY29uc3QgdGsgPSAwLjUgKiBldWxlclsgayBdO1xuXG4gIGNvbnN0IGNpID0gTWF0aC5jb3MoIHRpICk7XG4gIGNvbnN0IGNqID0gTWF0aC5jb3MoIHRqICk7XG4gIGNvbnN0IGNrID0gTWF0aC5jb3MoIHRrICk7XG4gIGNvbnN0IHNpID0gTWF0aC5zaW4oIHRpICk7XG4gIGNvbnN0IHNqID0gTWF0aC5zaW4oIHRqICk7XG4gIGNvbnN0IHNrID0gTWF0aC5zaW4oIHRrICk7XG5cbiAgY29uc3QgcmVzdWx0OiBSYXdRdWF0ZXJuaW9uID0gW1xuICAgIDAuMCxcbiAgICAwLjAsXG4gICAgMC4wLFxuICAgIGNrICogY2ogKiBjaSArIHNrICogc2ogKiBzaSxcbiAgXTtcbiAgcmVzdWx0WyBpIF0gPSBjayAqIGNqICogc2kgLSBzayAqIHNqICogY2k7XG4gIHJlc3VsdFsgaiBdID0gc2lnbiAqICggY2sgKiBzaiAqIGNpICsgc2sgKiBjaiAqIHNpICk7XG4gIHJlc3VsdFsgayBdID0gc2sgKiBjaiAqIGNpIC0gY2sgKiBzaiAqIHNpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0My9NYXRyaXgzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L01hdHJpeDQnO1xuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4uL3F1YXQvUXVhdGVybmlvbic7XG5pbXBvcnQgeyBldWxlckZyb21NYXQzIH0gZnJvbSAnLi9ldWxlckZyb21NYXQzJztcbmltcG9ydCB7IGV1bGVyRnJvbU1hdDQgfSBmcm9tICcuL2V1bGVyRnJvbU1hdDQnO1xuaW1wb3J0IHsgZXVsZXJGcm9tUXVhdGVybmlvbiB9IGZyb20gJy4vZXVsZXJGcm9tUXVhdGVybmlvbic7XG5pbXBvcnQgeyBxdWF0RnJvbUV1bGVyIH0gZnJvbSAnLi4vcXVhdC9xdWF0RnJvbUV1bGVyJztcbmltcG9ydCB0eXBlIHsgRXVsZXJPcmRlciB9IGZyb20gJy4vRXVsZXJPcmRlcic7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIEFuIEV1bGVyIHJvdGF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEV1bGVyIHtcbiAgcHVibGljIGVsZW1lbnRzOiBSYXdWZWN0b3IzOyAvLyBbIHgsIHksIHogXVxuXG4gIC8qKlxuICAgKiBBbiBvcmRlciBvZiB0aGlzIGV1bGVyLlxuICAgKiAnWFlaJyBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBpcyAqKmV4dHJpbnNpYyoqIHJvdGF0aW9ucyAod2hpY2ggaXMgc2FtZSBhcyBCbGVuZGVyLCBNYXlhLCBhbmQgVW5pdHkpLlxuICAgKiBUaHJlZS5qcyB1c2VzIGludHJpbnNpYyByb3RhdGlvbnMgc28geW91IGhhdmUgdG8gcmV2ZXJzZSB0aGUgb3JkZXIgaWYgeW91IHdhbnQgdG8gbWF0Y2ggdGhlIGJlaGF2aW9yIHdpdGggVGhyZWUuanMuXG4gICAqL1xuICBwdWJsaWMgb3JkZXI6IEV1bGVyT3JkZXI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBlbGVtZW50czogUmF3VmVjdG9yMyA9IFsgMC4wLCAwLjAsIDAuMCBdLCBvcmRlcjogRXVsZXJPcmRlciA9ICdYWVonICkge1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG4gIH1cblxuICAvKipcbiAgICogQW4geCBjb21wb25lbnQgb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgeCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzWyAwIF07XG4gIH1cblxuICAvKipcbiAgICogQW4geSBjb21wb25lbnQgb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgeSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzWyAxIF07XG4gIH1cblxuICAvKipcbiAgICogQW4geiBjb21wb25lbnQgb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgeigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzWyAyIF07XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYEV1bGVyKCAkeyB0aGlzLngudG9GaXhlZCggMyApIH0sICR7IHRoaXMueS50b0ZpeGVkKCAzICkgfSwgJHsgdGhpcy56LnRvRml4ZWQoIDMgKSB9ICgkeyB0aGlzLm9yZGVyIH0pIClgO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgY2xvbmUoKTogRXVsZXIge1xuICAgIHJldHVybiBuZXcgRXVsZXIoIHRoaXMuZWxlbWVudHMuY29uY2F0KCkgYXMgUmF3VmVjdG9yMywgdGhpcy5vcmRlciApO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0c2VsZiBidXQgY29udmVydGVkIGludG8gYSBRdWF0ZXJuaW9uLlxuICAgKi9cbiAgcHVibGljIGdldCBxdWF0ZXJuaW9uKCk6IFF1YXRlcm5pb24ge1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbiggcXVhdEZyb21FdWxlciggdGhpcy5lbGVtZW50cywgdGhpcy5vcmRlciApICk7XG4gIH1cblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCBjb252ZXJ0ZWQgaW50byBhIE1hdHJpeDQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IG1hdHJpeDQoKTogTWF0cml4NCB7XG4gICAgcmV0dXJuIHRoaXMucXVhdGVybmlvbi5tYXRyaXg0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIEV1bGVyIG91dCBvZiBhIG1hdHJpeDMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21NYXRyaXgzKCBtYXRyaXg6IE1hdHJpeDMsIG9yZGVyOiBFdWxlck9yZGVyICk6IEV1bGVyIHtcbiAgICByZXR1cm4gbmV3IEV1bGVyKCBldWxlckZyb21NYXQzKCBtYXRyaXguZWxlbWVudHMsIG9yZGVyICksIG9yZGVyICk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gRXVsZXIgb3V0IG9mIGEgbWF0cml4NC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbU1hdHJpeDQoIG1hdHJpeDogTWF0cml4NCwgb3JkZXI6IEV1bGVyT3JkZXIgKTogRXVsZXIge1xuICAgIHJldHVybiBuZXcgRXVsZXIoIGV1bGVyRnJvbU1hdDQoIG1hdHJpeC5lbGVtZW50cywgb3JkZXIgKSwgb3JkZXIgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBFdWxlciBvdXQgb2YgYSBxdWF0ZXJuaW9uLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbjogUXVhdGVybmlvbiwgb3JkZXI6IEV1bGVyT3JkZXIgKTogRXVsZXIge1xuICAgIHJldHVybiBuZXcgRXVsZXIoIGV1bGVyRnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24uZWxlbWVudHMsIG9yZGVyICksIG9yZGVyICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHZlY0RvdCB9IGZyb20gJy4uL3ZlYy92ZWNEb3QnO1xuaW1wb3J0IHsgdmVjU3ViIH0gZnJvbSAnLi4vdmVjL3ZlY1N1Yic7XG5pbXBvcnQgdHlwZSB7IFJhd1JheTMgfSBmcm9tICcuL1Jhd1JheTMnO1xuaW1wb3J0IHR5cGUgeyBSYXdTcGhlcmUzIH0gZnJvbSAnLi4vc3BoZXJlMy9SYXdTcGhlcmUzJztcblxuLyoqXG4gKiBSZXR1cm4gZGlzdGFuY2VzIGZyb20gZ2l2ZW4gcmF5IHRvIHNwaGVyZS5cbiAqXG4gKiBUaGUgcmV0dXJuaW5nIGRpc3RhbmNlIGNhbiBiZSBuZWdhdGl2ZS5cbiAqXG4gKiBUaGUgZmlyc3QgcmV0dXJuaW5nIHZhbHVlIHdpbGwgYmUgdGhlIGRpc3RhbmNlIG9mIHRoZSBpbmNpZGVudCBwb2ludC5cbiAqIElmIHRoZSByYXkgZG9lcyBub3QgaW50ZXJzZWN0IHdpdGggc3BoZXJlLCBpdCB3aWxsIHJldHVybiBgbnVsbGAuXG4gKlxuICogQHBhcmFtIHJheSBBIHJheVxuICogQHBhcmFtIHNwaGVyZSBBIHRhcmdldCBzcGhlcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJheTNEaXN0YW5jZVRvU3BoZXJlKFxuICBbIHJvLCByZCBdOiBSYXdSYXkzLFxuICBzcGhlcmU6IFJhd1NwaGVyZTMsXG4pOiBbIG51bWJlciwgbnVtYmVyIF0gfCBudWxsIHtcbiAgY29uc3QgdiA9IHZlY1N1Yiggcm8sIHNwaGVyZVsgMCBdICk7XG4gIGNvbnN0IGIgPSB2ZWNEb3QoIHYsIHJkICk7XG4gIGNvbnN0IGMgPSB2ZWNEb3QoIHYsIHYgKSAtIHNwaGVyZVsgMSBdO1xuICBjb25zdCBkID0gYiAqIGIgLSBjO1xuXG4gIGlmICggZCA8IDAuMCApIHsgcmV0dXJuIG51bGw7IH1cblxuICBjb25zdCBzcXJ0RCA9IE1hdGguc3FydCggZCApO1xuXG4gIHJldHVybiBbIC1iIC0gc3FydEQsIC1iICsgc3FydEQgXTtcbn1cbiIsImltcG9ydCB7IHZlY1N1YiB9IGZyb20gJy4uL3ZlYy92ZWNTdWInO1xuaW1wb3J0IHR5cGUgeyBSYXdMaW5lMyB9IGZyb20gJy4vUmF3TGluZTMnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBSZXR1cm4gYSB2ZWN0b3IgdGhhdCByZXByZXNlbnRzIGRlbHRhIG9mIGdpdmVuIGxpbmUuXG4gKlxuICogQHBhcmFtIGxpbmUgQSBsaW5lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lM0RlbHRhKCBsaW5lOiBSYXdMaW5lMyApOiBSYXdWZWN0b3IzIHtcbiAgcmV0dXJuIHZlY1N1YiggbGluZVsgMSBdLCBsaW5lWyAwIF0gKTtcbn1cbiIsImltcG9ydCB7IGxpbmUzRGVsdGEgfSBmcm9tICcuLi9saW5lMy9saW5lM0RlbHRhJztcbmltcG9ydCB7IHZlY05vcm1hbGl6ZSB9IGZyb20gJy4uL3ZlYy92ZWNOb3JtYWxpemUnO1xuaW1wb3J0IHR5cGUgeyBSYXdMaW5lMyB9IGZyb20gJy4uL2xpbmUzL1Jhd0xpbmUzJztcbmltcG9ydCB0eXBlIHsgUmF3UmF5MyB9IGZyb20gJy4vUmF3UmF5Myc7XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gbGluZSB0byBhIHJheS5cbiAqXG4gKiBAcGFyYW0gbGluZSBBIGxpbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJheTNGcm9tTGluZTMoIGxpbmU6IFJhd0xpbmUzICk6IFJhd1JheTMge1xuICByZXR1cm4gW1xuICAgIGxpbmVbIDAgXSxcbiAgICB2ZWNOb3JtYWxpemUoIGxpbmUzRGVsdGEoIGxpbmUgKSApLFxuICBdO1xufVxuIiwiaW1wb3J0IHsgTGluZTMgfSBmcm9tICcuLi9saW5lMy9MaW5lMyc7XG5pbXBvcnQgeyBTcGhlcmUzIH0gZnJvbSAnLi4vc3BoZXJlMy9TcGhlcmUzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1ZlY3RvcjMnO1xuaW1wb3J0IHsgcmF5M0Rpc3RhbmNlVG9TcGhlcmUgfSBmcm9tICcuL3JheTNEaXN0YW5jZVRvU3BoZXJlJztcbmltcG9ydCB7IHJheTNGcm9tTGluZTMgfSBmcm9tICcuL3JheTNGcm9tTGluZTMnO1xuaW1wb3J0IHR5cGUgeyBSYXdSYXkzIH0gZnJvbSAnLi9SYXdSYXkzJztcblxuLyoqXG4gKiBBIDNEIHJheS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJheTMge1xuICAvKipcbiAgICogVGhlIG9yaWdpbiBvZiB0aGUgcmF5LlxuICAgKi9cbiAgcHVibGljIG9yaWdpbjogVmVjdG9yMztcblxuICAvKipcbiAgICogVGhlIGRpcmVjdGlvbiBvZiB0aGUgcmF5LlxuICAgKiBNYWtlIHN1cmUgdGhlIGRpcmVjdGlvbiBpcyBub3JtYWxpemVkLlxuICAgKi9cbiAgcHVibGljIGRpcmVjdGlvbjogVmVjdG9yMztcblxuICBwdWJsaWMgY29uc3RydWN0b3IoIHN0YXJ0OiBWZWN0b3IzID0gVmVjdG9yMy56ZXJvLCBlbmQ6IFZlY3RvcjMgPSBWZWN0b3IzLnB6ICkge1xuICAgIHRoaXMub3JpZ2luID0gc3RhcnQ7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBlbmQ7XG4gIH1cblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCB7QGxpbmsgUmF3UmF5M30gZm9ybS5cbiAgICovXG4gIHB1YmxpYyBnZXQgcmF3KCk6IFJhd1JheTMge1xuICAgIHJldHVybiBbIHRoaXMub3JpZ2luLmVsZW1lbnRzLCB0aGlzLmRpcmVjdGlvbi5lbGVtZW50cyBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBkaXN0YW5jZXMgZnJvbSBnaXZlbiByYXkgdG8gc3BoZXJlLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuaW5nIGRpc3RhbmNlIGNhbiBiZSBuZWdhdGl2ZS5cbiAgICpcbiAgICogVGhlIGZpcnN0IHJldHVybmluZyB2YWx1ZSB3aWxsIGJlIHRoZSBkaXN0YW5jZSBvZiB0aGUgaW5jaWRlbnQgcG9pbnQuXG4gICAqIElmIHRoZSByYXkgZG9lcyBub3QgaW50ZXJzZWN0IHdpdGggc3BoZXJlLCBpdCB3aWxsIHJldHVybiBgbnVsbGAuXG4gICAqXG4gICAqIEBwYXJhbSBzcGhlcmUgQSB0YXJnZXQgc3BoZXJlXG4gICAqL1xuICBwdWJsaWMgZGlzdGFuY2VUb1NwaGVyZSggc3BoZXJlOiBTcGhlcmUzICk6IFsgbnVtYmVyLCBudW1iZXIgXSB8IG51bGwge1xuICAgIHJldHVybiByYXkzRGlzdGFuY2VUb1NwaGVyZSggdGhpcy5yYXcsIHNwaGVyZS5yYXcgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHtAbGluayBSYXdSYXkzfSB0byBjbGFzcyBmb3JtLlxuICAgKiBAcGFyYW0gcmF5IEEge0BsaW5rIFJhd1JheTN9XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21SYXcoIHJheTogUmF3UmF5MyApOiBSYXkzIHtcbiAgICByZXR1cm4gbmV3IFJheTMoIG5ldyBWZWN0b3IzKCByYXlbIDAgXSApLCBuZXcgVmVjdG9yMyggcmF5WyAxIF0gKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJheSBvdXQgb2YgYSBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0gbGluZSBBIHtAbGluayBMaW5lM31cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUxpbmUzKCBsaW5lOiBMaW5lMyApOiBSYXkzIHtcbiAgICByZXR1cm4gUmF5My5mcm9tUmF3KCByYXkzRnJvbUxpbmUzKCBsaW5lLnJhdyApICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHZlYzNBcHBseU1hdHJpeDQgfSBmcm9tICcuLi92ZWMzL3ZlYzNBcHBseU1hdHJpeDQnO1xuaW1wb3J0IHR5cGUgeyBSYXdMaW5lMyB9IGZyb20gJy4vUmF3TGluZTMnO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NC9SYXdNYXRyaXg0JztcblxuLyoqXG4gKiBBcHBseSBnaXZlbiBtYXRyaXg0IHRvIGdpdmVuIGxpbmUuXG4gKlxuICogQHBhcmFtIGxpbmUgQSBsaW5lXG4gKiBAcGFyYW0gbWF0cml4IEEgbWF0cml4NCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGxpbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmUzQXBwbHlNYXRyaXg0KFxuICBbIHN0YXJ0LCBlbmQgXTogUmF3TGluZTMsXG4gIG1hdHJpeDogUmF3TWF0cml4NCxcbik6IFJhd0xpbmUzIHtcbiAgcmV0dXJuIFtcbiAgICB2ZWMzQXBwbHlNYXRyaXg0KCBzdGFydCwgbWF0cml4ICksXG4gICAgdmVjM0FwcGx5TWF0cml4NCggZW5kLCBtYXRyaXggKSxcbiAgXTtcbn1cbiIsImltcG9ydCB7IHZlY0FkZCB9IGZyb20gJy4uL3ZlYy92ZWNBZGQnO1xuaW1wb3J0IHsgdmVjU2NhbGUgfSBmcm9tICcuLi92ZWMvdmVjU2NhbGUnO1xuaW1wb3J0IHR5cGUgeyBSYXdMaW5lMyB9IGZyb20gJy4vUmF3TGluZTMnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBSZXR1cm4gYSB2ZWN0b3IgdGhhdCByZXByZXNlbnRzIGEgY2VydGFpbiBwb2ludCBvZiBnaXZlbiBsaW5lLlxuICogU2FtZSBhcyBzdGFydCBhdCB0ID0gMCwgc2FtZSBhcyBlbmQgYXQgdCA9IDEuXG4gKlxuICogQHBhcmFtIGxpbmUgQSBsaW5lXG4gKiBAcGFyYW0gdCBBIHBhcmFtZXRlciB0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lM0F0KCBsaW5lOiBSYXdMaW5lMywgdDogbnVtYmVyICk6IFJhd1ZlY3RvcjMge1xuICByZXR1cm4gdmVjQWRkKFxuICAgIHZlY1NjYWxlKCBsaW5lWyAwIF0sIDEuMCAtIHQgKSxcbiAgICB2ZWNTY2FsZSggbGluZVsgMSBdLCB0ICksXG4gICk7XG59XG4iLCJpbXBvcnQgeyBsaW5lM0F0IH0gZnJvbSAnLi9saW5lM0F0JztcbmltcG9ydCB7IHNhdHVyYXRlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgdmVjRG90IH0gZnJvbSAnLi4vdmVjL3ZlY0RvdCc7XG5pbXBvcnQgeyB2ZWNTdWIgfSBmcm9tICcuLi92ZWMvdmVjU3ViJztcbmltcG9ydCB0eXBlIHsgUmF3TGluZTMgfSBmcm9tICcuL1Jhd0xpbmUzJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogUmV0dXJuIGEgcG9pbnQgdGhhdCBpcyBvbiB0aGUgZ2l2ZW4gbGluZSB3aGljaCBpcyBjbG9zZXN0IHRvIHRoZSBnaXZlbiBwb2ludC5cbiAqXG4gKiBJZiBgc2VnbWVudGAgaXMgdHJ1ZSwgaXQgd2lsbCB0cmVhdCB0aGUgbGluZSBhcyBhIHNlZ21lbnQgd2hpY2ggaGFzIHN0YXJ0IGFuZCBlbmQuXG4gKiBPdGhlcndpc2UgaXQgd2lsbCB0cmVhdCB0aGUgbGluZSBpcyBpbmZpbml0ZS5cbiAqXG4gKiBAcGFyYW0gbGluZSBBIGxpbmVcbiAqIEBwYXJhbSBwb2ludCBBIHBvaW50XG4gKiBAcGFyYW0gc2VnbWVudCBJcyB0aGUgbGluZSBhIHNlZ21lbnQ/XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lM0Nsb3Nlc3RQb2ludFRvUG9pbnQoXG4gIGxpbmU6IFJhd0xpbmUzLFxuICBwb2ludDogUmF3VmVjdG9yMyxcbiAgc2VnbWVudD86IGJvb2xlYW4sXG4pOiBSYXdWZWN0b3IzIHtcbiAgY29uc3QgYXAgPSB2ZWNTdWIoIHBvaW50LCBsaW5lWyAwIF0gKTtcbiAgY29uc3QgYWIgPSB2ZWNTdWIoIGxpbmVbIDEgXSwgbGluZVsgMCBdICk7XG5cbiAgbGV0IHQgPSB2ZWNEb3QoIGFwLCBhYiApIC8gdmVjRG90KCBhYiwgYWIgKTtcbiAgc2VnbWVudCAmJiAoIHQgPSBzYXR1cmF0ZSggdCApICk7XG5cbiAgcmV0dXJuIGxpbmUzQXQoIGxpbmUsIHQgKTtcbn1cbiIsImltcG9ydCB7IGxpbmUzQ2xvc2VzdFBvaW50VG9Qb2ludCB9IGZyb20gJy4vbGluZTNDbG9zZXN0UG9pbnRUb1BvaW50JztcbmltcG9ydCB7IHZlY0xlbmd0aCB9IGZyb20gJy4uL3ZlYy92ZWNMZW5ndGgnO1xuaW1wb3J0IHsgdmVjU3ViIH0gZnJvbSAnLi4vdmVjL3ZlY1N1Yic7XG5pbXBvcnQgdHlwZSB7IFJhd0xpbmUzIH0gZnJvbSAnLi9SYXdMaW5lMyc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFJldHVybiBhIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIGxpbmUgdG8gdGhlIGdpdmVuIHBvaW50LlxuICpcbiAqIElmIGBzZWdtZW50YCBpcyB0cnVlLCBpdCB3aWxsIHRyZWF0IHRoZSBsaW5lIGFzIGEgc2VnbWVudCB3aGljaCBoYXMgc3RhcnQgYW5kIGVuZC5cbiAqIE90aGVyd2lzZSBpdCB3aWxsIHRyZWF0IHRoZSBsaW5lIGlzIGluZmluaXRlLlxuICpcbiAqIEBwYXJhbSBsaW5lIEEgbGluZVxuICogQHBhcmFtIHBvaW50IEEgcG9pbnRcbiAqIEBwYXJhbSBzZWdtZW50IElzIHRoZSBsaW5lIGEgc2VnbWVudD9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmUzRGlzdGFuY2VUb1BvaW50KFxuICBsaW5lOiBSYXdMaW5lMyxcbiAgcG9pbnQ6IFJhd1ZlY3RvcjMsXG4gIHNlZ21lbnQ/OiBib29sZWFuLFxuKTogbnVtYmVyIHtcbiAgcmV0dXJuIHZlY0xlbmd0aCggdmVjU3ViKFxuICAgIGxpbmUzQ2xvc2VzdFBvaW50VG9Qb2ludCggbGluZSwgcG9pbnQsIHNlZ21lbnQgKSxcbiAgICBwb2ludCxcbiAgKSApO1xufVxuIiwiaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdDQvTWF0cml4NCc7XG5pbXBvcnQgeyBSYXkzIH0gZnJvbSAnLi4vcmF5My9SYXkzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1ZlY3RvcjMnO1xuaW1wb3J0IHsgbGluZTNBcHBseU1hdHJpeDQgfSBmcm9tICcuL2xpbmUzQXBwbHlNYXRyaXg0JztcbmltcG9ydCB7IGxpbmUzQXQgfSBmcm9tICcuL2xpbmUzQXQnO1xuaW1wb3J0IHsgbGluZTNDbG9zZXN0UG9pbnRUb1BvaW50IH0gZnJvbSAnLi9saW5lM0Nsb3Nlc3RQb2ludFRvUG9pbnQnO1xuaW1wb3J0IHsgbGluZTNEZWx0YSB9IGZyb20gJy4vbGluZTNEZWx0YSc7XG5pbXBvcnQgeyBsaW5lM0Rpc3RhbmNlVG9Qb2ludCB9IGZyb20gJy4vbGluZTNEaXN0YW5jZVRvUG9pbnQnO1xuaW1wb3J0IHR5cGUgeyBSYXdMaW5lMyB9IGZyb20gJy4vUmF3TGluZTMnO1xuXG4vKipcbiAqIEEgM0QgbGluZS5cbiAqL1xuZXhwb3J0IGNsYXNzIExpbmUzIHtcbiAgcHVibGljIHN0YXJ0OiBWZWN0b3IzO1xuICBwdWJsaWMgZW5kOiBWZWN0b3IzO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvciggc3RhcnQ6IFZlY3RvcjMgPSBWZWN0b3IzLnplcm8sIGVuZDogVmVjdG9yMyA9IFZlY3RvcjMuemVybyApIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gIH1cblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCB7QGxpbmsgUmF3TGluZTN9IGZvcm0uXG4gICAqL1xuICBwdWJsaWMgZ2V0IHJhdygpOiBSYXdMaW5lMyB7XG4gICAgcmV0dXJuIFsgdGhpcy5zdGFydC5lbGVtZW50cywgdGhpcy5lbmQuZWxlbWVudHMgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IGEgcmF5LlxuICAgKi9cbiAgcHVibGljIGdldCByYXkoKTogUmF5MyB7XG4gICAgcmV0dXJuIFJheTMuZnJvbUxpbmUzKCB0aGlzICk7XG4gIH1cblxuICAvKipcbiAgICogQSB2ZWN0b3IgdGhhdCByZXByZXNlbnRzIGRlbHRhIG9mIHRoZSBsaW5lLlxuICAgKi9cbiAgcHVibGljIGRlbHRhKCk6IFZlY3RvcjMge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyggbGluZTNEZWx0YSggdGhpcy5yYXcgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0cyBsZW5ndGguXG4gICAqL1xuICBwdWJsaWMgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZGVsdGEubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHZlY3RvciB0aGF0IHJlcHJlc2VudHMgYSBjZXJ0YWluIHBvaW50IG9mIHRoZSBsaW5lLlxuICAgKiBTYW1lIGFzIHN0YXJ0IGF0IHQgPSAwLCBzYW1lIGFzIGVuZCBhdCB0ID0gMS5cbiAgICpcbiAgICogQHBhcmFtIHQgQSBwYXJhbWV0ZXIgdFxuICAgKi9cbiAgcHVibGljIGF0KCB0OiBudW1iZXIgKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCBsaW5lM0F0KCB0aGlzLnJhdywgdCApICk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgZ2l2ZW4gbWF0cml4NCB0byB0aGUgbGluZS5cbiAgICpcbiAgICogQHBhcmFtIG1hdHJpeCBBIG1hdHJpeDQgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBsaW5lXG4gICAqL1xuICBwdWJsaWMgYXBwbHlNYXRyaXg0KCBtYXRyaXg6IE1hdHJpeDQgKTogTGluZTMge1xuICAgIHJldHVybiBMaW5lMy5mcm9tUmF3KFxuICAgICAgbGluZTNBcHBseU1hdHJpeDQoXG4gICAgICAgIHRoaXMucmF3LFxuICAgICAgICBtYXRyaXguZWxlbWVudHMsXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwb2ludCB0aGF0IGlzIG9uIHRoZSBsaW5lIHdoaWNoIGlzIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIHBvaW50LlxuICAgKlxuICAgKiBJZiBgc2VnbWVudGAgaXMgdHJ1ZSwgaXQgd2lsbCB0cmVhdCB0aGUgbGluZSBhcyBhIHNlZ21lbnQgd2hpY2ggaGFzIHN0YXJ0IGFuZCBlbmQuXG4gICAqIE90aGVyd2lzZSBpdCB3aWxsIHRyZWF0IHRoZSBsaW5lIGlzIGluZmluaXRlLlxuICAgKlxuICAgKiBAcGFyYW0gcG9pbnQgQSBwb2ludFxuICAgKiBAcGFyYW0gc2VnbWVudCBJcyB0aGUgbGluZSBhIHNlZ21lbnQ/XG4gICAqL1xuICBwdWJsaWMgY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQ6IFZlY3RvcjMsIHNlZ21lbnQ6IGJvb2xlYW4gKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCBsaW5lM0Nsb3Nlc3RQb2ludFRvUG9pbnQoIHRoaXMucmF3LCBwb2ludC5lbGVtZW50cywgc2VnbWVudCApICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZGlzdGFuY2UgZnJvbSB0aGUgbGluZSB0byB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAqXG4gICAqIElmIGBzZWdtZW50YCBpcyB0cnVlLCBpdCB3aWxsIHRyZWF0IHRoZSBsaW5lIGFzIGEgc2VnbWVudCB3aGljaCBoYXMgc3RhcnQgYW5kIGVuZC5cbiAgICogT3RoZXJ3aXNlIGl0IHdpbGwgdHJlYXQgdGhlIGxpbmUgaXMgaW5maW5pdGUuXG4gICAqXG4gICAqIEBwYXJhbSBwb2ludCBBIHBvaW50XG4gICAqIEBwYXJhbSBzZWdtZW50IElzIHRoZSBsaW5lIGEgc2VnbWVudD9cbiAgICovXG4gIHB1YmxpYyBkaXN0YW5jZVRvUG9pbnQoIHBvaW50OiBWZWN0b3IzLCBzZWdtZW50OiBib29sZWFuICk6IG51bWJlciB7XG4gICAgcmV0dXJuIGxpbmUzRGlzdGFuY2VUb1BvaW50KCB0aGlzLnJhdywgcG9pbnQuZWxlbWVudHMsIHNlZ21lbnQgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHtAbGluayBSYXdMaW5lM30gdG8gY2xhc3MgZm9ybS5cbiAgICogQHBhcmFtIGxpbmUgQSB7QGxpbmsgUmF3TGluZTN9XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21SYXcoIGxpbmU6IFJhd0xpbmUzICk6IExpbmUzIHtcbiAgICByZXR1cm4gbmV3IExpbmUzKCBuZXcgVmVjdG9yMyggbGluZVsgMCBdICksIG5ldyBWZWN0b3IzKCBsaW5lWyAxIF0gKSApO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDIgfSBmcm9tICcuL1Jhd01hdHJpeDInO1xuXG5leHBvcnQgZnVuY3Rpb24gbWF0MkRldGVybWluYW50KCBtOiBSYXdNYXRyaXgyICk6IG51bWJlciB7XG4gIHJldHVybiBtWyAwIF0gKiBtWyAzIF0gLSBtWyAyIF0gKiBtWyAxIF07XG59XG4iLCJpbXBvcnQgeyB2ZWNTY2FsZSB9IGZyb20gJy4uL3ZlYy92ZWNTY2FsZSc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDIgfSBmcm9tICcuL1Jhd01hdHJpeDInO1xuXG4vKipcbiAqIFJldHVybiBhbiBpbnZlcnNlIG9mIGdpdmVuIG1hdHJpeC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDJJbnZlcnNlKCBtOiBSYXdNYXRyaXgyICk6IFJhd01hdHJpeDIge1xuICBjb25zdFxuICAgIG4xMSA9IG1bIDAgXSwgbjIxID0gbVsgMSBdLFxuICAgIG4xMiA9IG1bIDIgXSwgbjIyID0gbVsgMyBdLFxuICAgIGRldCA9IG4xMSAqIG4yMiAtIG4xMiAqIG4yMTtcblxuICBpZiAoIGRldCA9PT0gMC4wICkgeyByZXR1cm4gdmVjU2NhbGUoIG0sIDAuMCApOyB9XG5cbiAgcmV0dXJuIHZlY1NjYWxlKCBbXG4gICAgbjIyLCAtbjIxLFxuICAgIC1uMTIsIG4xMSxcbiAgXSwgMS4wIC8gZGV0ICk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDIgfSBmcm9tICcuL1Jhd01hdHJpeDInO1xuXG4vKipcbiAqIFJldHVybiBhIG11bHRpcGxpY2F0aW9uIHJlc3VsdCBvZiBtYXRyaWNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDJNdWx0aXBseSggLi4ubWF0czogUmF3TWF0cml4MltdICk6IFJhd01hdHJpeDIge1xuICBpZiAoIG1hdHMubGVuZ3RoIDwgMiApIHtcbiAgICByZXR1cm4gbWF0c1sgMCBdO1xuICB9XG5cbiAgY29uc3QgYSA9IG1hdHMuc2hpZnQoKSE7XG4gIGNvbnN0IGIgPSBtYXQyTXVsdGlwbHkoIC4uLm1hdHMgKTtcbiAgY29uc3RcbiAgICBhMDAgPSBhWyAwIF0sIGEwMSA9IGFbIDEgXSxcbiAgICBhMTAgPSBhWyAyIF0sIGExMSA9IGFbIDMgXSxcbiAgICBiMDAgPSBiWyAwIF0sIGIwMSA9IGJbIDEgXSxcbiAgICBiMTAgPSBiWyAyIF0sIGIxMSA9IGJbIDMgXTtcblxuICByZXR1cm4gW1xuICAgIGEwMCAqIGIwMCArIGExMCAqIGIwMSxcbiAgICBhMDEgKiBiMDAgKyBhMTEgKiBiMDEsXG5cbiAgICBhMDAgKiBiMTAgKyBhMTAgKiBiMTEsXG4gICAgYTAxICogYjEwICsgYTExICogYjExLFxuICBdO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXgyIH0gZnJvbSAnLi9SYXdNYXRyaXgyJztcblxuLyoqXG4gKiBUcmFuc3Bvc2UgYSBtYXQyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0MlRyYW5zcG9zZShcbiAgc291cmNlOiBSYXdNYXRyaXgyLFxuKTogUmF3TWF0cml4MiB7XG4gIHJldHVybiBbXG4gICAgc291cmNlWyAwIF0sIHNvdXJjZVsgMiBdLFxuICAgIHNvdXJjZVsgMSBdLCBzb3VyY2VbIDMgXSxcbiAgXTtcbn1cbiIsImltcG9ydCB7IG1hdDJEZXRlcm1pbmFudCB9IGZyb20gJy4vbWF0MkRldGVybWluYW50JztcbmltcG9ydCB7IG1hdDJJbnZlcnNlIH0gZnJvbSAnLi9tYXQySW52ZXJzZSc7XG5pbXBvcnQgeyBtYXQyTXVsdGlwbHkgfSBmcm9tICcuL21hdDJNdWx0aXBseSc7XG5pbXBvcnQgeyBtYXQyVHJhbnNwb3NlIH0gZnJvbSAnLi9tYXQyVHJhbnNwb3NlJztcbmltcG9ydCB7IHZlY1NjYWxlIH0gZnJvbSAnLi4vdmVjL3ZlY1NjYWxlJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4MiB9IGZyb20gJy4vUmF3TWF0cml4Mic7XG5cbmNvbnN0IHJhd0lkZW50aXR5TWF0cml4MjogUmF3TWF0cml4MiA9IFtcbiAgMS4wLCAwLjAsXG4gIDAuMCwgMS4wLFxuXTtcblxuLyoqXG4gKiBBIE1hdHJpeDIuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRyaXgyIHtcbiAgcHVibGljIGVsZW1lbnRzOiBSYXdNYXRyaXgyO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdjogUmF3TWF0cml4MiA9IHJhd0lkZW50aXR5TWF0cml4MiApIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gdjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IHRyYW5zcG9zZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRyYW5zcG9zZSgpOiBNYXRyaXgyIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDIoIG1hdDJUcmFuc3Bvc2UoIHRoaXMuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0cyBkZXRlcm1pbmFudC5cbiAgICovXG4gIHB1YmxpYyBnZXQgZGV0ZXJtaW5hbnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gbWF0MkRldGVybWluYW50KCB0aGlzLmVsZW1lbnRzICk7XG4gIH1cblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCBpbnZlcnRlZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaW52ZXJzZSgpOiBNYXRyaXgyIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDIoIG1hdDJJbnZlcnNlKCB0aGlzLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzLm1hcCggKCB2ICkgPT4gdi50b0ZpeGVkKCAzICkgKTtcbiAgICByZXR1cm4gYE1hdHJpeDIoICR7IG1bIDAgXSB9LCAkeyBtWyAyIF0gfTsgJHsgbVsgMSBdIH0sICR7IG1bIDMgXSB9IClgO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgY2xvbmUoKTogTWF0cml4MiB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgyKCB0aGlzLmVsZW1lbnRzLmNvbmNhdCgpIGFzIFJhd01hdHJpeDIgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGlzIE1hdHJpeDIgYnkgb25lIG9yIG1vcmUgTWF0cml4MnMuXG4gICAqL1xuICBwdWJsaWMgbXVsdGlwbHkoIC4uLm1hdHJpY2VzOiBNYXRyaXgyW10gKTogTWF0cml4MiB7XG4gICAgcmV0dXJuIE1hdHJpeDIubXVsdGlwbHkoIHRoaXMsIC4uLm1hdHJpY2VzICk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgdGhpcyBNYXRyaXgzIGJ5IGEgc2NhbGFyLlxuICAgKi9cbiAgcHVibGljIHNjYWxlU2NhbGFyKCBzY2FsYXI6IG51bWJlciApOiBNYXRyaXgyIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDIoIHZlY1NjYWxlKCB0aGlzLmVsZW1lbnRzLCBzY2FsYXIgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGlkZW50aXR5IE1hdHJpeDQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCBpZGVudGl0eSgpOiBNYXRyaXgyIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDIoIHJhd0lkZW50aXR5TWF0cml4MiApO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHR3byBvciBtb3JlIG1hdHJpY2VzLlxuICAgKiBAcGFyYW0gbWF0cmljZXMgTWF0cmljZXNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbXVsdGlwbHkoIC4uLm1hdHJpY2VzOiBNYXRyaXgyW10gKTogTWF0cml4MiB7XG4gICAgaWYgKCBtYXRyaWNlcy5sZW5ndGggPT09IDAgKSB7XG4gICAgICByZXR1cm4gTWF0cml4Mi5pZGVudGl0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgyKCBtYXQyTXVsdGlwbHkoIC4uLm1hdHJpY2VzLm1hcCggKCBtICkgPT4gbS5lbGVtZW50cyApICkgKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4uL21hdDMvUmF3TWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIEFwcGx5IGEgdmVjMyBhIG1hdDMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWMzQXBwbHlNYXRyaXgzKCB2OiBSYXdWZWN0b3IzLCBtOiBSYXdNYXRyaXgzICk6IFJhd1ZlY3RvcjMge1xuICByZXR1cm4gW1xuICAgIG1bIDAgXSAqIHZbIDAgXSArIG1bIDMgXSAqIHZbIDEgXSArIG1bIDYgXSAqIHZbIDIgXSxcbiAgICBtWyAxIF0gKiB2WyAwIF0gKyBtWyA0IF0gKiB2WyAxIF0gKyBtWyA3IF0gKiB2WyAyIF0sXG4gICAgbVsgMiBdICogdlsgMCBdICsgbVsgNSBdICogdlsgMSBdICsgbVsgOCBdICogdlsgMiBdLFxuICBdO1xufVxuIiwiaW1wb3J0IHsgdmVjM0FwcGx5TWF0cml4MyB9IGZyb20gJy4uL3ZlYzMvdmVjM0FwcGx5TWF0cml4Myc7XG5pbXBvcnQgeyB2ZWMzQXBwbHlNYXRyaXg0IH0gZnJvbSAnLi4vdmVjMy92ZWMzQXBwbHlNYXRyaXg0JztcbmltcG9ydCB7IHZlY0RvdCB9IGZyb20gJy4uL3ZlYy92ZWNEb3QnO1xuaW1wb3J0IHsgdmVjTm9ybWFsaXplIH0gZnJvbSAnLi4vdmVjL3ZlY05vcm1hbGl6ZSc7XG5pbXBvcnQgeyB2ZWNTY2FsZSB9IGZyb20gJy4uL3ZlYy92ZWNTY2FsZSc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDMgfSBmcm9tICcuLi9tYXQzL1Jhd01hdHJpeDMnO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NC9SYXdNYXRyaXg0JztcbmltcG9ydCB0eXBlIHsgUmF3UGxhbmUzIH0gZnJvbSAnLi9SYXdQbGFuZTMnO1xuXG4vKipcbiAqIEFwcGx5IGdpdmVuIG1hdHJpeDQgdG8gZ2l2ZW4gcGxhbmUuXG4gKlxuICogQHBhcmFtIHBsYW5lIEEgcGxhbmVcbiAqIEBwYXJhbSBtYXRyaXggQSBtYXRyaXg0IHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcGxhbmVcbiAqIEBwYXJhbSBub3JtYWxNYXRyaXggQSBub3JtYWxNYXRyaXggbWFkZSBvdXQgb2Yge0BsaW5rIG1hdHJpeH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsYW5lM0FwcGx5TWF0cml4NChcbiAgWyBub3JtYWwsIGRpc3RhbmNlIF06IFJhd1BsYW5lMyxcbiAgbWF0cml4OiBSYXdNYXRyaXg0LFxuICBub3JtYWxNYXRyaXg6IFJhd01hdHJpeDMsXG4pOiBSYXdQbGFuZTMge1xuICAvLyBub3JtYWzjgarjgpPjgaDjgYvjgolub3JtYWxNYXRyaXjlvZPjgabjgozjgbDjg6jjgrfvvIFcbiAgY29uc3QgbmV3Tm9ybWFsID0gdmVjTm9ybWFsaXplKCB2ZWMzQXBwbHlNYXRyaXgzKCBub3JtYWwsIG5vcm1hbE1hdHJpeCApICk7XG5cbiAgLy8g44Go44KK44GC44GI44Ga5LiA54K56Kaz5ris44GX44Gm44GC44Go44GnZG905Y+W44KK55u044GX44Gh44KD44GK44GG44Gc77yBXG4gIGNvbnN0IGNvcGxhbmFyID0gdmVjU2NhbGUoIG5vcm1hbCwgLWRpc3RhbmNlICk7XG4gIGNvbnN0IHJlZlBvaW50ID0gdmVjM0FwcGx5TWF0cml4NCggY29wbGFuYXIsIG1hdHJpeCApO1xuICBjb25zdCBuZXdEaXN0YW5jZSA9IC12ZWNEb3QoIHJlZlBvaW50LCBub3JtYWwgKTtcblxuICByZXR1cm4gWyBuZXdOb3JtYWwsIG5ld0Rpc3RhbmNlIF07XG59XG4iLCJpbXBvcnQgeyB2ZWNEb3QgfSBmcm9tICcuLi92ZWMvdmVjRG90JztcbmltcG9ydCB0eXBlIHsgUmF3UGxhbmUzIH0gZnJvbSAnLi9SYXdQbGFuZTMnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBSZXR1cm4gYSBzaWduZWQgZGlzdGFuY2UgZnJvbSBnaXZlbiBwbGFuZSB0byB0aGUgZ2l2ZW4gcG9pbnQuXG4gKiBNYWtlIHN1cmUgdGhlIGBub3JtYWxgIGlzIG5vcm1hbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwbGFuZTNEaXN0YW5jZVRvUG9pbnQoXG4gIFsgbm9ybWFsLCBkaXN0YW5jZSBdOiBSYXdQbGFuZTMsXG4gIHBvaW50OiBSYXdWZWN0b3IzLFxuKTogbnVtYmVyIHtcbiAgcmV0dXJuIHZlY0RvdCggbm9ybWFsLCBwb2ludCApICsgZGlzdGFuY2U7XG59XG4iLCJpbXBvcnQgeyB2ZWNMZW5ndGggfSBmcm9tICcuLi92ZWMvdmVjTGVuZ3RoJztcbmltcG9ydCB7IHZlY1NjYWxlIH0gZnJvbSAnLi4vdmVjL3ZlY1NjYWxlJztcbmltcG9ydCB0eXBlIHsgUmF3UGxhbmUzIH0gZnJvbSAnLi9SYXdQbGFuZTMnO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIGdpdmVuIHBsYW5lP1xuICogVGhpcyBub3JtYWxpemVzIHRoZSBub3JtYWwgYW5kIGFsc28gZGl2aWRlIGRpc3RhbmNlIGJ5IGl0cyBvcmlnaW5hbCBub3JtYWwgbGVuZ3RoLlxuICpcbiAqIEkgZG9uJ3QgY29tZSB1cCB3aXRoIGFueSB1c2UgY2FzZXMgb3RoZXIgdGhhbiB7QGxpbmsgcGxhbmVzRnJvbVByb2plY3Rpb25NYXRyaXh9LlxuICpcbiAqIEBwYXJhbSBwbGFuZSBUaGUgcGxhbmUgeW91IHdhbnQgdG8gbm9ybWFsaXplXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwbGFuZTNOb3JtYWxpemUoIFsgbm9ybWFsLCBkaXN0YW5jZSBdOiBSYXdQbGFuZTMgKTogUmF3UGxhbmUzIHtcbiAgY29uc3QgaW52TCA9IDEuMCAvIHZlY0xlbmd0aCggbm9ybWFsICk7XG4gIHJldHVybiBbIHZlY1NjYWxlKCBub3JtYWwsIGludkwgKSwgZGlzdGFuY2UgKiBpbnZMIF07XG59XG4iLCJpbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0My9NYXRyaXgzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L01hdHJpeDQnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvVmVjdG9yMyc7XG5pbXBvcnQgeyBwbGFuZTNBcHBseU1hdHJpeDQgfSBmcm9tICcuL3BsYW5lM0FwcGx5TWF0cml4NCc7XG5pbXBvcnQgeyBwbGFuZTNEaXN0YW5jZVRvUG9pbnQgfSBmcm9tICcuL3BsYW5lM0Rpc3RhbmNlVG9Qb2ludCc7XG5pbXBvcnQgeyBwbGFuZTNOb3JtYWxpemUgfSBmcm9tICcuL3BsYW5lM05vcm1hbGl6ZSc7XG5pbXBvcnQgdHlwZSB7IFJhd1BsYW5lMyB9IGZyb20gJy4vUmF3UGxhbmUzJztcblxuLyoqXG4gKiBBIDNEIHBsYW5lLlxuICovXG5leHBvcnQgY2xhc3MgUGxhbmUzIHtcbiAgcHVibGljIG5vcm1hbDogVmVjdG9yMztcbiAgcHVibGljIGRpc3RhbmNlOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEl0c2VsZiBidXQge0BsaW5rIFJhd1BsYW5lM30gZm9ybS5cbiAgICovXG4gIHB1YmxpYyBnZXQgcmF3KCk6IFJhd1BsYW5lMyB7XG4gICAgcmV0dXJuIFsgdGhpcy5ub3JtYWwuZWxlbWVudHMsIHRoaXMuZGlzdGFuY2UgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVkIHBsYW5lP1xuICAgKiBUaGlzIG5vcm1hbGl6ZXMgdGhlIG5vcm1hbCBhbmQgYWxzbyBkaXZpZGUgZGlzdGFuY2UgYnkgaXRzIG9yaWdpbmFsIG5vcm1hbCBsZW5ndGguXG4gICAqL1xuICBwdWJsaWMgZ2V0IG5vcm1hbGl6ZWQoKTogUGxhbmUzIHtcbiAgICByZXR1cm4gUGxhbmUzLmZyb21SYXcoIHBsYW5lM05vcm1hbGl6ZSggdGhpcy5yYXcgKSApO1xuICB9XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBub3JtYWw6IFZlY3RvcjMgPSBWZWN0b3IzLnB6LCBkaXN0YW5jZSA9IDAuMCApIHtcbiAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgZ2l2ZW4gbWF0cml4NCB0byB0aGUgcGxhbmUuXG4gICAqXG4gICAqIEBwYXJhbSBtYXRyaXggQSBtYXRyaXg0IHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcGxhbmVcbiAgICogQHBhcmFtIG5vcm1hbE1hdHJpeCBBIG5vcm1hbE1hdHJpeCBtYWRlIG91dCBvZiB7QGxpbmsgbWF0cml4fS4gT3B0aW9uYWxcbiAgICovXG4gIHB1YmxpYyBhcHBseU1hdHJpeDQoIG1hdHJpeDogTWF0cml4NCwgbm9ybWFsTWF0cml4PzogTWF0cml4MyApOiBQbGFuZTMge1xuICAgIHJldHVybiBQbGFuZTMuZnJvbVJhdyhcbiAgICAgIHBsYW5lM0FwcGx5TWF0cml4NChcbiAgICAgICAgdGhpcy5yYXcsXG4gICAgICAgIG1hdHJpeC5lbGVtZW50cyxcbiAgICAgICAgbm9ybWFsTWF0cml4Py5lbGVtZW50cyA/PyBtYXRyaXgubm9ybWFsTWF0cml4LmVsZW1lbnRzLFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgc2lnbmVkIGRpc3RhbmNlIGZyb20gZ2l2ZW4gcGxhbmUgdG8gdGhlIGdpdmVuIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gcG9pbnQgQSBwb2ludFxuICAgKi9cbiAgcHVibGljIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQ6IFZlY3RvcjMgKTogbnVtYmVyIHtcbiAgICByZXR1cm4gcGxhbmUzRGlzdGFuY2VUb1BvaW50KCB0aGlzLnJhdywgcG9pbnQuZWxlbWVudHMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHtAbGluayBSYXdQbGFuZTN9IHRvIGNsYXNzIGZvcm0uXG4gICAqIEBwYXJhbSBwbGFuZSBBIHtAbGluayBSYXdQbGFuZTN9XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21SYXcoIHBsYW5lOiBSYXdQbGFuZTMgKTogUGxhbmUzIHtcbiAgICByZXR1cm4gbmV3IFBsYW5lMyggbmV3IFZlY3RvcjMoIHBsYW5lWyAwIF0gKSwgcGxhbmVbIDEgXSApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBwbGFuZTNEaXN0YW5jZVRvUG9pbnQgfSBmcm9tICcuL3BsYW5lM0Rpc3RhbmNlVG9Qb2ludCc7XG5pbXBvcnQgdHlwZSB7IFJhd1BsYW5lMyB9IGZyb20gJy4vUmF3UGxhbmUzJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogVGVzdCBpZiBnaXZlbiBwb2ludCBpcyBjb250YWluZWQgaW4gZ2l2ZW4gcGxhbmVzIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gcGxhbmVzIEEgbGlzdCBvZiBwbGFuZXNcbiAqIEBwYXJhbSBwb2ludCBBIHBvaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwbGFuZXMzQ29udGFpblBvaW50KCBwbGFuZXM6IFJhd1BsYW5lM1tdLCBwb2ludDogUmF3VmVjdG9yMyApOiBib29sZWFuIHtcbiAgcmV0dXJuIHBsYW5lcy5ldmVyeSggKCBwbGFuZSApID0+IHBsYW5lM0Rpc3RhbmNlVG9Qb2ludCggcGxhbmUsIHBvaW50ICkgPj0gMC4wICk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd0JveDMgfSBmcm9tICcuLi9ib3gzL1Jhd0JveDMnO1xuaW1wb3J0IHR5cGUgeyBSYXdQbGFuZTMgfSBmcm9tICcuL1Jhd1BsYW5lMyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgcGxhbmUzIG91dCBvZiBhIHtAbGluayBSYXdCb3gzfS5cbiAqXG4gKiBAcGFyYW0gYm94IEEgYm94XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwbGFuZXMzRnJvbUJveDMoIGJveDogUmF3Qm94MyApOiBSYXdQbGFuZTNbXSB7XG4gIHJldHVybiBbXG4gICAgWyBbIDEuMCwgMC4wLCAwLjAgXSwgLWJveFsgMCBdWyAwIF0gXSwgLy8geG5cbiAgICBbIFsgLTEuMCwgMC4wLCAwLjAgXSwgYm94WyAxIF1bIDAgXSBdLCAvLyB4cFxuICAgIFsgWyAwLjAsIDEuMCwgMC4wIF0sIC1ib3hbIDAgXVsgMSBdIF0sIC8vIHluXG4gICAgWyBbIDAuMCwgLTEuMCwgMC4wIF0sIGJveFsgMSBdWyAxIF0gXSwgLy8geXBcbiAgICBbIFsgMC4wLCAwLjAsIDEuMCBdLCAtYm94WyAwIF1bIDIgXSBdLCAvLyB5blxuICAgIFsgWyAwLjAsIDAuMCwgLTEuMCBdLCBib3hbIDEgXVsgMiBdIF0sIC8vIHlwXG4gIF07XG59XG4iLCJpbXBvcnQgeyBwbGFuZTNOb3JtYWxpemUgfSBmcm9tICcuL3BsYW5lM05vcm1hbGl6ZSc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L1Jhd01hdHJpeDQnO1xuaW1wb3J0IHR5cGUgeyBSYXdQbGFuZTMgfSBmcm9tICcuL1Jhd1BsYW5lMyc7XG5cbi8qKlxuICogQ3JlYXRlIGZydXN0dW0gcGxhbmVzIG91dCBvZiBnaXZlbiBwcm9qZWN0aW9uIG1hdHJpeC5cbiAqXG4gKiBAcGFyYW0gbSBBIHByb2plY3Rpb24gbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwbGFuZXMzRnJvbVByb2plY3Rpb25NYXRyaXgoIG06IFJhd01hdHJpeDQgKTogUmF3UGxhbmUzW10ge1xuICBjb25zdFxuICAgIG0xMSA9IG1bIDAgXSwgbTEyID0gbVsgNCBdLCBtMTMgPSBtWyA4IF0sIG0xNCA9IG1bIDEyIF0sXG4gICAgbTIxID0gbVsgMSBdLCBtMjIgPSBtWyA1IF0sIG0yMyA9IG1bIDkgXSwgbTI0ID0gbVsgMTMgXSxcbiAgICBtMzEgPSBtWyAyIF0sIG0zMiA9IG1bIDYgXSwgbTMzID0gbVsgMTAgXSwgbTM0ID0gbVsgMTQgXSxcbiAgICBtNDEgPSBtWyAzIF0sIG00MiA9IG1bIDcgXSwgbTQzID0gbVsgMTEgXSwgbTQ0ID0gbVsgMTUgXTtcblxuICByZXR1cm4gW1xuICAgIHBsYW5lM05vcm1hbGl6ZSggWyBbIG00MSAtIG0xMSwgbTQyIC0gbTEyLCBtNDMgLSBtMTMgXSwgbTQ0IC0gbTE0IF0gKSwgLy8geHBcbiAgICBwbGFuZTNOb3JtYWxpemUoIFsgWyBtNDEgKyBtMTEsIG00MiArIG0xMiwgbTQzICsgbTEzIF0sIG00NCArIG0xNCBdICksIC8vIHhuXG4gICAgcGxhbmUzTm9ybWFsaXplKCBbIFsgbTQxIC0gbTIxLCBtNDIgLSBtMjIsIG00MyAtIG0yMyBdLCBtNDQgLSBtMjQgXSApLCAvLyB5cFxuICAgIHBsYW5lM05vcm1hbGl6ZSggWyBbIG00MSArIG0yMSwgbTQyICsgbTIyLCBtNDMgKyBtMjMgXSwgbTQ0ICsgbTI0IF0gKSwgLy8geW5cbiAgICBwbGFuZTNOb3JtYWxpemUoIFsgWyBtNDEgLSBtMzEsIG00MiAtIG0zMiwgbTQzIC0gbTMzIF0sIG00NCAtIG0zNCBdICksIC8vIHpuXG4gICAgcGxhbmUzTm9ybWFsaXplKCBbIFsgbTQxICsgbTMxLCBtNDIgKyBtMzIsIG00MyArIG0zMyBdLCBtNDQgKyBtMzQgXSApLCAvLyB6cFxuICBdO1xufVxuIiwiaW1wb3J0IHsgcGxhbmUzRGlzdGFuY2VUb1BvaW50IH0gZnJvbSAnLi9wbGFuZTNEaXN0YW5jZVRvUG9pbnQnO1xuaW1wb3J0IHR5cGUgeyBSYXdCb3gzIH0gZnJvbSAnLi4vYm94My9SYXdCb3gzJztcbmltcG9ydCB0eXBlIHsgUmF3UGxhbmUzIH0gZnJvbSAnLi9SYXdQbGFuZTMnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIGJveCBpbnRlcnNlY3RzIHdpdGggcGxhbmVzIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gcGxhbmVzIEEgbGlzdCBvZiBwbGFuZXNcbiAqIEBwYXJhbSBib3ggQSBib3gzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwbGFuZXMzSW50ZXJzZWN0Qm94MyggcGxhbmVzOiBSYXdQbGFuZTNbXSwgYm94OiBSYXdCb3gzICk6IGJvb2xlYW4ge1xuICByZXR1cm4gcGxhbmVzLmV2ZXJ5KCAoIHBsYW5lICkgPT4ge1xuICAgIGNvbnN0IHYgPSBwbGFuZVsgMCBdLm1hcCggKCBuYywgaSApID0+IGJveFsgbmMgPiAwLjAgPyAxIDogMCBdWyBpIF0gKSBhcyBSYXdWZWN0b3IzO1xuICAgIHJldHVybiBwbGFuZTNEaXN0YW5jZVRvUG9pbnQoIHBsYW5lLCB2ICkgPj0gMC4wO1xuICB9ICk7XG59XG4iLCJpbXBvcnQgeyBSYXdTcGhlcmUzIH0gZnJvbSAnLi4vc3BoZXJlMy9SYXdTcGhlcmUzJztcbmltcG9ydCB7IHBsYW5lM0Rpc3RhbmNlVG9Qb2ludCB9IGZyb20gJy4vcGxhbmUzRGlzdGFuY2VUb1BvaW50JztcbmltcG9ydCB0eXBlIHsgUmF3UGxhbmUzIH0gZnJvbSAnLi9SYXdQbGFuZTMnO1xuXG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gc3BoZXJlIGludGVyc2VjdHMgd2l0aCBwbGFuZXMgb3Igbm90LlxuICpcbiAqIEl0IGRvZXMgbm90IGRvIHN0cmljdCBpbnRlcnNlY3Rpb24gdGVzdCBidXQgc3RpbGwgc2hvdWxkIHdvcmsgd2VsbCB3aXRoIGZydXN0dW0gY3VsbCB1c2UgY2FzZXMuXG4gKiBTZWUgdGhlIHRlc3QgY2FzZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSBwbGFuZXMgQSBsaXN0IG9mIHBsYW5lc1xuICogQHBhcmFtIHNwaGVyZSBBIHNwaGVyZTNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsYW5lczNJbnRlcnNlY3RTcGhlcmUzKCBwbGFuZXM6IFJhd1BsYW5lM1tdLCBzcGhlcmU6IFJhd1NwaGVyZTMgKTogYm9vbGVhbiB7XG4gIHJldHVybiBwbGFuZXMuZXZlcnkoICggcGxhbmUgKSA9PiAoXG4gICAgcGxhbmUzRGlzdGFuY2VUb1BvaW50KCBwbGFuZSwgc3BoZXJlWyAwIF0gKSA+PSAtc3BoZXJlWyAxIF1cbiAgKSApO1xufVxuIiwiaW1wb3J0IHsgQm94MyB9IGZyb20gJy4uL2JveDMvQm94Myc7XG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NC9NYXRyaXg0JztcbmltcG9ydCB7IFBsYW5lMyB9IGZyb20gJy4vUGxhbmUzJztcbmltcG9ydCB7IFNwaGVyZTMgfSBmcm9tICcuLi9zcGhlcmUzL1NwaGVyZTMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvVmVjdG9yMyc7XG5pbXBvcnQgeyBwbGFuZXMzQ29udGFpblBvaW50IH0gZnJvbSAnLi9wbGFuZXMzQ29udGFpblBvaW50JztcbmltcG9ydCB7IHBsYW5lczNGcm9tQm94MyB9IGZyb20gJy4vcGxhbmVzM0Zyb21Cb3gzJztcbmltcG9ydCB7IHBsYW5lczNGcm9tUHJvamVjdGlvbk1hdHJpeCB9IGZyb20gJy4vcGxhbmVzM0Zyb21Qcm9qZWN0aW9uTWF0cml4JztcbmltcG9ydCB7IHBsYW5lczNJbnRlcnNlY3RCb3gzIH0gZnJvbSAnLi9wbGFuZXMzSW50ZXJzZWN0Qm94Myc7XG5pbXBvcnQgeyBwbGFuZXMzSW50ZXJzZWN0U3BoZXJlMyB9IGZyb20gJy4vcGxhbmVzM0ludGVyc2VjdFNwaGVyZTMnO1xuaW1wb3J0IHR5cGUgeyBSYXdQbGFuZTMgfSBmcm9tICcuL1Jhd1BsYW5lMyc7XG5cbi8qKlxuICogQSBzZXQgb2Yge0BsaW5rIFBsYW5lM30uXG4gKi9cbmV4cG9ydCBjbGFzcyBQbGFuZXMzIHtcbiAgcHVibGljIHBsYW5lczogUGxhbmUzW107XG5cbiAgLyoqXG4gICAqIEl0c2VsZiBidXQge0BsaW5rIFJhd1BsYW5lM31bXSBmb3JtLlxuICAgKi9cbiAgcHVibGljIGdldCByYXcoKTogUmF3UGxhbmUzW10ge1xuICAgIHJldHVybiB0aGlzLnBsYW5lcy5tYXAoICggcGxhbmUgKSA9PiBwbGFuZS5yYXcgKTtcbiAgfVxuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcGxhbmVzOiBQbGFuZTNbXSApIHtcbiAgICB0aGlzLnBsYW5lcyA9IHBsYW5lcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIGdpdmVuIHBvaW50IGlzIGNvbnRhaW5lZCBpbiB0aGUgcGxhbmVzIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHBvaW50IEEgcG9pbnRcbiAgICovXG4gIHB1YmxpYyBjb250YWluUG9pbnQoIHBvaW50OiBWZWN0b3IzICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwbGFuZXMzQ29udGFpblBvaW50KCB0aGlzLnJhdywgcG9pbnQuZWxlbWVudHMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIGdpdmVuIGJveCBpbnRlcnNlY3RzIHdpdGggdGhlIHBsYW5lcyBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSBib3ggQSBib3gzXG4gICAqL1xuICBwdWJsaWMgaW50ZXJzZWN0Qm94MyggYm94OiBCb3gzICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwbGFuZXMzSW50ZXJzZWN0Qm94MyggdGhpcy5yYXcsIGJveC5yYXcgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIGdpdmVuIHNwaGVyZSBpbnRlcnNlY3RzIHdpdGggdGhlIHBsYW5lcyBvciBub3QuXG4gICAqXG4gICAqIEl0IGRvZXMgbm90IGRvIHN0cmljdCBpbnRlcnNlY3Rpb24gdGVzdCBidXQgc3RpbGwgc2hvdWxkIHdvcmsgd2VsbCB3aXRoIGZydXN0dW0gY3VsbCB1c2UgY2FzZXMuXG4gICAqIFNlZSB0aGUgdGVzdCBjYXNlIGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIEBwYXJhbSBzcGhlcmUgQSBzcGhlcmUzXG4gICAqL1xuICBwdWJsaWMgaW50ZXJzZWN0U3BoZXJlMyggc3BoZXJlOiBTcGhlcmUzICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwbGFuZXMzSW50ZXJzZWN0U3BoZXJlMyggdGhpcy5yYXcsIHNwaGVyZS5yYXcgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHtAbGluayBSYXdQbGFuZTN9W10gdG8gY2xhc3MgZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHBsYW5lcyBBIHtAbGluayBSYXdQbGFuZTN9W11cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVJhdyggcGxhbmVzOiBSYXdQbGFuZTNbXSApOiBQbGFuZXMzIHtcbiAgICByZXR1cm4gbmV3IFBsYW5lczMoIHBsYW5lcy5tYXAoICggcGxhbmUgKSA9PiBQbGFuZTMuZnJvbVJhdyggcGxhbmUgKSApICk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBzZXQgb2YgcGxhbmUzIG91dCBvZiBhIHtAbGluayBSYXdCb3gzfS5cbiAgICpcbiAgICogQHBhcmFtIGJveCBBIGJveFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tQm94MyggYm94OiBCb3gzICk6IFBsYW5lczMge1xuICAgIHJldHVybiBQbGFuZXMzLmZyb21SYXcoIHBsYW5lczNGcm9tQm94MyggYm94LnJhdyApICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGZydXN0dW0gcGxhbmVzIG91dCBvZiBnaXZlbiBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgICpcbiAgICogQHBhcmFtIG1hdHJpeCBBIHByb2plY3Rpb24gbWF0cml4XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21Qcm9qZWN0aW9uTWF0cml4KCBtYXRyaXg6IE1hdHJpeDQgKTogUGxhbmVzMyB7XG4gICAgcmV0dXJuIFBsYW5lczMuZnJvbVJhdyggcGxhbmVzM0Zyb21Qcm9qZWN0aW9uTWF0cml4KCBtYXRyaXguZWxlbWVudHMgKSApO1xuICB9XG59XG4iLCJpbXBvcnQgeyB2ZWNMZW5ndGhTcSB9IGZyb20gJy4uL3ZlYy92ZWNMZW5ndGhTcSc7XG5pbXBvcnQgeyB2ZWNTdWIgfSBmcm9tICcuLi92ZWMvdmVjU3ViJztcbmltcG9ydCB0eXBlIHsgUmF3U3BoZXJlMyB9IGZyb20gJy4vUmF3U3BoZXJlMyc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gcG9pbnQgaXMgY29udGFpbmVkIGluIGdpdmVuIHNwaGVyZSBvciBub3QuXG4gKiBAcGFyYW0gc3BoZXJlIEEgc3BoZXJlXG4gKiBAcGFyYW0gcG9pbnQgQSBwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BoZXJlM0NvbnRhaW5zUG9pbnQoIHNwaGVyZTogUmF3U3BoZXJlMywgcG9pbnQ6IFJhd1ZlY3RvcjMgKTogYm9vbGVhbiB7XG4gIHJldHVybiB2ZWNMZW5ndGhTcSggdmVjU3ViKCBzcGhlcmVbIDAgXSwgcG9pbnQgKSApIDw9IHNwaGVyZVsgMSBdICogc3BoZXJlWyAxIF07XG59XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9WZWN0b3IzJztcbmltcG9ydCB7IHNwaGVyZTNDb250YWluc1BvaW50IH0gZnJvbSAnLi9zcGhlcmUzQ29udGFpbnNQb2ludCc7XG5pbXBvcnQgdHlwZSB7IFJhd1NwaGVyZTMgfSBmcm9tICcuL1Jhd1NwaGVyZTMnO1xuXG4vKipcbiAqIEEgM0Qgc3BoZXJlLlxuICovXG5leHBvcnQgY2xhc3MgU3BoZXJlMyB7XG4gIHB1YmxpYyBvcmlnaW46IFZlY3RvcjM7XG4gIHB1YmxpYyByYWRpdXM6IG51bWJlcjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoIG9yaWdpbjogVmVjdG9yMyA9IFZlY3RvcjMuemVybywgcmFkaXVzOiBudW1iZXIgPSAwLjAgKSB7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gIH1cblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCB7QGxpbmsgUmF3U3BoZXJlM30gZm9ybS5cbiAgICovXG4gIHB1YmxpYyBnZXQgcmF3KCk6IFJhd1NwaGVyZTMge1xuICAgIHJldHVybiBbIHRoaXMub3JpZ2luLmVsZW1lbnRzLCB0aGlzLnJhZGl1cyBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgZ2l2ZW4gcG9pbnQgaXMgY29udGFpbmVkIGluIHRoZSBzcGhlcmUgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0gcG9pbnQgQSBwb2ludFxuICAgKi9cbiAgcHVibGljIGNvbnRhaW5zUG9pbnQoIHBvaW50OiBWZWN0b3IzICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzcGhlcmUzQ29udGFpbnNQb2ludCggdGhpcy5yYXcsIHBvaW50LmVsZW1lbnRzICk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB7QGxpbmsgUmF3U3BoZXJlM30gdG8gY2xhc3MgZm9ybS5cbiAgICogQHBhcmFtIHNwaGVyZSBBIHtAbGluayBSYXdTcGhlcmUzfVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tUmF3KCBzcGhlcmU6IFJhd1NwaGVyZTMgKTogU3BoZXJlMyB7XG4gICAgcmV0dXJuIG5ldyBTcGhlcmUzKCBuZXcgVmVjdG9yMyggc3BoZXJlWyAwIF0gKSwgc3BoZXJlWyAxIF0gKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdmVjM0FwcGx5TWF0cml4MyB9IGZyb20gJy4uL3ZlYzMvdmVjM0FwcGx5TWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDMgfSBmcm9tICcuLi9tYXQzL1Jhd01hdHJpeDMnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9SYXdWZWN0b3IzJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yNCB9IGZyb20gJy4vUmF3VmVjdG9yNCc7XG5cbi8qKlxuICogQXBwbHkgYSB2ZWM0IGEgbWF0MyAod2l0aCBhbiBpbXBsaWNpdCAxIG9uIG00NCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWM0QXBwbHlNYXRyaXgzKCB2OiBSYXdWZWN0b3I0LCBtOiBSYXdNYXRyaXgzICk6IFJhd1ZlY3RvcjQge1xuICBjb25zdCB2MzogUmF3VmVjdG9yMyA9IFsgdlsgMCBdLCB2WyAxIF0sIHZbIDIgXSBdO1xuICBjb25zdCB4eXogPSB2ZWMzQXBwbHlNYXRyaXgzKCB2MywgbSApO1xuICBjb25zdCB3ID0gdlsgMyBdO1xuICByZXR1cm4gWyB4eXpbIDAgXSwgeHl6WyAxIF0sIHh5elsgMiBdLCB3IF07XG59XG4iLCJpbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NC9NYXRyaXg0JztcbmltcG9ydCB7IFZlY3RvciB9IGZyb20gJy4uL3ZlYy9WZWN0b3InO1xuaW1wb3J0IHsgdmVjNEFwcGx5TWF0cml4MyB9IGZyb20gJy4vdmVjNEFwcGx5TWF0cml4Myc7XG5pbXBvcnQgeyB2ZWM0QXBwbHlNYXRyaXg0IH0gZnJvbSAnLi92ZWM0QXBwbHlNYXRyaXg0JztcbmltcG9ydCB0eXBlIHsgTWF0cml4MyB9IGZyb20gJy4uL21hdDMvTWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjQgfSBmcm9tICcuL1Jhd1ZlY3RvcjQnO1xuXG4vKipcbiAqIEEgVmVjdG9yMy5cbiAqL1xuZXhwb3J0IGNsYXNzIFZlY3RvcjQgZXh0ZW5kcyBWZWN0b3I8VmVjdG9yND4ge1xuICBwdWJsaWMgZWxlbWVudHM6IFJhd1ZlY3RvcjQ7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCB2OiBSYXdWZWN0b3I0ID0gWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB2O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIHggY29tcG9uZW50IG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c1sgMCBdO1xuICB9XG5cbiAgcHVibGljIHNldCB4KCB4OiBudW1iZXIgKSB7XG4gICAgdGhpcy5lbGVtZW50c1sgMCBdID0geDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHkgY29tcG9uZW50IG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHkoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c1sgMSBdO1xuICB9XG5cbiAgcHVibGljIHNldCB5KCB5OiBudW1iZXIgKSB7XG4gICAgdGhpcy5lbGVtZW50c1sgMSBdID0geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHogY29tcG9uZW50IG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHooKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c1sgMiBdO1xuICB9XG5cbiAgcHVibGljIHNldCB6KCB6OiBudW1iZXIgKSB7XG4gICAgdGhpcy5lbGVtZW50c1sgMiBdID0gejtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHcgY29tcG9uZW50IG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHcoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c1sgMyBdO1xuICB9XG5cbiAgcHVibGljIHNldCB3KCB6OiBudW1iZXIgKSB7XG4gICAgdGhpcy5lbGVtZW50c1sgMyBdID0gejtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgVmVjdG9yNCggJHsgdGhpcy54LnRvRml4ZWQoIDMgKSB9LCAkeyB0aGlzLnkudG9GaXhlZCggMyApIH0sICR7IHRoaXMuei50b0ZpeGVkKCAzICkgfSwgJHsgdGhpcy53LnRvRml4ZWQoIDMgKSB9IClgO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IHRoaXMgdmVjdG9yIGEgbWF0MyAod2l0aCBhbiBpbXBsaWNpdCAxIG9uIG00NCkuXG4gICAqL1xuICBwdWJsaWMgYXBwbHlNYXRyaXgzKCBtYXRyaXg6IE1hdHJpeDMgKTogVmVjdG9yNCB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3I0KCB2ZWM0QXBwbHlNYXRyaXgzKCB0aGlzLmVsZW1lbnRzLCBtYXRyaXguZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoaXMgdmVjdG9yIGJ5IGEgbWF0NC5cbiAgICovXG4gIHB1YmxpYyBhcHBseU1hdHJpeDQoIG1hdHJpeDogTWF0cml4NCApOiBWZWN0b3I0IHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjQoIHZlYzRBcHBseU1hdHJpeDQoIHRoaXMuZWxlbWVudHMsIG1hdHJpeC5lbGVtZW50cyApICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX19uZXcoIHY6IFJhd1ZlY3RvcjQgKTogVmVjdG9yNCB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3I0KCB2ICk7XG4gIH1cblxuICAvKipcbiAgICogVmVjdG9yNCggMC4wLCAwLjAsIDAuMCwgMC4wIClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IHplcm8oKTogVmVjdG9yNCB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3I0KCBbIDAuMCwgMC4wLCAwLjAsIDAuMCBdICk7XG4gIH1cblxuICAvKipcbiAgICogVmVjdG9yNCggMS4wLCAxLjAsIDEuMCwgMS4wIClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IG9uZSgpOiBWZWN0b3I0IHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjQoIFsgMS4wLCAxLjAsIDEuMCwgMS4wIF0gKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTWlkaVBhcnNlUmVzdWx0LCBNaWRpUGFyc2VSZXN1bHRIZWFkZXIsIE1pZGlQYXJzZVJlc3VsdFRyYWNrIH0gZnJvbSAnLi9NaWRpUGFyc2VSZXN1bHQnO1xuaW1wb3J0IHsgYXJyYXlTZXJpYWwgfSBmcm9tICcuLi9hcnJheS9hcnJheVNlcmlhbCc7XG5cbmZ1bmN0aW9uIHJlYWRVOCggYXJyYXk6IFVpbnQ4QXJyYXksIGhlYWRCb3g6IFsgbnVtYmVyIF0gKTogbnVtYmVyIHtcbiAgcmV0dXJuIGFycmF5WyBoZWFkQm94WyAwIF0gKysgXTtcbn1cblxuLyoqXG4gKiBCaWcgZW5kaWFuXG4gKi9cbmZ1bmN0aW9uIHJlYWRVMTYoIGFycmF5OiBVaW50OEFycmF5LCBoZWFkQm94OiBbIG51bWJlciBdICk6IG51bWJlciB7XG4gIHJldHVybiByZWFkVTgoIGFycmF5LCBoZWFkQm94ICkgKiAyNTYgKyByZWFkVTgoIGFycmF5LCBoZWFkQm94ICk7XG59XG5cbi8qKlxuICogQmlnIGVuZGlhblxuICovXG5mdW5jdGlvbiByZWFkVTMyKCBhcnJheTogVWludDhBcnJheSwgaGVhZEJveDogWyBudW1iZXIgXSApOiBudW1iZXIge1xuICByZXR1cm4gcmVhZFUxNiggYXJyYXksIGhlYWRCb3ggKSAqIDY1NTM2ICsgcmVhZFUxNiggYXJyYXksIGhlYWRCb3ggKTtcbn1cblxuZnVuY3Rpb24gcmVhZFVWYXIoIGFycmF5OiBVaW50OEFycmF5LCBoZWFkQm94OiBbIG51bWJlciBdICk6IG51bWJlciB7XG4gIGxldCB2ID0gMDtcbiAgZm9yICggOzsgKSB7XG4gICAgY29uc3QgdnYgPSByZWFkVTgoIGFycmF5LCBoZWFkQm94ICk7XG4gICAgdiA9IHYgKiAxMjggKyAoIHZ2ICYgMTI3ICk7XG5cbiAgICBpZiAoIHZ2IDwgMTI4ICkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKCBhcnJheTogVWludDhBcnJheSwgaGVhZEJveDogWyBudW1iZXIgXSApOiBNaWRpUGFyc2VSZXN1bHRIZWFkZXIge1xuICAvLyBza2lwIHR5cGUgYW5kIGxlbmd0aCAoNCs0KVxuICAvLyBsZW5ndGggaGFzIHRvIGJlIDYsIHRoZXJlJ3Mgbm8gbmVlZCB0byBwYXJzZVxuICBoZWFkQm94WyAwIF0gKz0gODtcblxuICByZXR1cm4gW1xuICAgIHJlYWRVMTYoIGFycmF5LCBoZWFkQm94ICksXG4gICAgcmVhZFUxNiggYXJyYXksIGhlYWRCb3ggKSxcbiAgICByZWFkVTE2KCBhcnJheSwgaGVhZEJveCApLFxuICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRyYWNrKCBhcnJheTogVWludDhBcnJheSwgaGVhZEJveDogWyBudW1iZXIgXSApOiBNaWRpUGFyc2VSZXN1bHRUcmFjayB7XG4gIC8vIHNraXAgdHlwZSAoNClcbiAgaGVhZEJveFsgMCBdICs9IDQ7XG5cbiAgY29uc3QgZW5kT2ZUcmFjayA9IGhlYWRCb3hbIDAgXSArIHJlYWRVMzIoIGFycmF5LCBoZWFkQm94ICkgKyA0O1xuXG4gIGNvbnN0IHRyYWNrOiBNaWRpUGFyc2VSZXN1bHRUcmFjayA9IFtdO1xuICBsZXQgdHlwZSA9IDA7XG5cbiAgd2hpbGUgKCBoZWFkQm94WyAwIF0gPCBlbmRPZlRyYWNrICkge1xuICAgIGNvbnN0IGRlbHRhID0gcmVhZFVWYXIoIGFycmF5LCBoZWFkQm94ICk7XG4gICAgY29uc3Qgc3RhdHVzID0gcmVhZFU4KCBhcnJheSwgaGVhZEJveCApO1xuICAgIHR5cGUgPSBzdGF0dXMgPCAxMjggPyB0eXBlIDogc3RhdHVzO1xuICAgIGNvbnN0IGRhdGEwID0gc3RhdHVzIDwgMTI4ID8gc3RhdHVzIDogcmVhZFU4KCBhcnJheSwgaGVhZEJveCApO1xuXG4gICAgaWYgKCB0eXBlIDwgMHhjMCApIHtcbiAgICAgIC8vIG5vdGUgb24gKDl4KSwgbm90ZSBvZmYgKDh4KSwgcG9seXBob25pYyBrZXkgcHJlc3N1cmUgKEF4KSwgY29udHJvbCBjaGFuZ2UgKEJ4KVxuXG4gICAgICB0cmFjay5wdXNoKCBbXG4gICAgICAgIGRlbHRhLFxuICAgICAgICB0eXBlLFxuICAgICAgICBkYXRhMCwgLy8gbm90ZSBvciBjYyBudW1iZXJcbiAgICAgICAgcmVhZFU4KCBhcnJheSwgaGVhZEJveCApLCAvLyB2ZWxvY2l0eSwgcHJlc3N1cmUsIG9yIGRhdGFcbiAgICAgIF0gKTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlID09PSAweGZmICkge1xuICAgICAgLy8gbWV0YSBldmVudHNcblxuICAgICAgY29uc3QgZXZlbnRMZW5ndGggPSByZWFkVTgoIGFycmF5LCBoZWFkQm94ICk7XG5cbiAgICAgIHRyYWNrLnB1c2goIFtcbiAgICAgICAgZGVsdGEsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRhdGEwLFxuICAgICAgICBhcnJheVNlcmlhbCggZXZlbnRMZW5ndGggKS5tYXAoICgpID0+IHJlYWRVOCggYXJyYXksIGhlYWRCb3ggKSApLFxuICAgICAgXSApO1xuXG4gICAgICBpZiAoIGRhdGEwID09PSAweDJmICkgeyAvLyBlbmQgb2YgdHJhY2tcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvciggYCR7IHR5cGUgfWAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJhY2s7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaWRpUGFyc2UoIGJ1ZmZlcjogQXJyYXlCdWZmZXIgKTogTWlkaVBhcnNlUmVzdWx0IHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSggYnVmZmVyICk7XG4gIGNvbnN0IGhlYWRCb3g6IFsgbnVtYmVyIF0gPSBbIDAgXTtcblxuICBjb25zdCBoZWFkZXIgPSBwYXJzZUhlYWRlciggYXJyYXksIGhlYWRCb3ggKTtcbiAgY29uc3QgdHJhY2tzOiBNaWRpUGFyc2VSZXN1bHRUcmFja1tdID0gW107XG5cbiAgd2hpbGUgKCBoZWFkQm94WyAwIF0gPCBhcnJheS5sZW5ndGggKSB7XG4gICAgdHJhY2tzLnB1c2goIHBhcnNlVHJhY2soIGFycmF5LCBoZWFkQm94ICkgKTtcbiAgfVxuXG4gIHJldHVybiBbIGhlYWRlciwgdHJhY2tzIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFBva2VyUmFuayB9IGZyb20gJy4vUG9rZXJSYW5rJztcblxuZXhwb3J0IGNvbnN0IHBva2VyUmFua3NCeVN0cmVuZ3RoOiBQb2tlclJhbmtbXSA9IFtcbiAgJzInLFxuICAnMycsXG4gICc0JyxcbiAgJzUnLFxuICAnNicsXG4gICc3JyxcbiAgJzgnLFxuICAnOScsXG4gICdUJyxcbiAgJ0onLFxuICAnUScsXG4gICdLJyxcbiAgJ0EnLFxuXTtcbiIsImltcG9ydCB0eXBlIHsgUG9rZXJTdWl0IH0gZnJvbSAnLi9Qb2tlclN1aXQnO1xuXG5leHBvcnQgY29uc3QgcG9rZXJTdWl0c0J5SW5kZXg6IFBva2VyU3VpdFtdID0gW1xuICAnYycsXG4gICdkJyxcbiAgJ2gnLFxuICAncycsXG5dO1xuIiwiaW1wb3J0IHsgcG9rZXJSYW5rc0J5U3RyZW5ndGggfSBmcm9tICcuL3Bva2VyUmFua3NCeVN0cmVuZ3RoJztcbmltcG9ydCB7IHBva2VyU3VpdHNCeUluZGV4IH0gZnJvbSAnLi9wb2tlclN1aXRzQnlJbmRleCc7XG5pbXBvcnQgdHlwZSB7IFBva2VyQ2FyZCB9IGZyb20gJy4vUG9rZXJDYXJkJztcblxuLyoqXG4gKiBDcmVhdGUgYSA1Mi1jYXJkIGRlY2suXG4gKiBZb3UgbWlnaHQgd2FudCB0byB1c2Uge0BsaW5rIHNodWZmbGVBcnJheX0gdG8gc2h1ZmZsZSB0aGUgZGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBva2VyRGVjaygpOiBQb2tlckNhcmRbXSB7XG4gIGNvbnN0IGFycmF5OiBQb2tlckNhcmRbXSA9IFtdO1xuXG4gIHBva2VyU3VpdHNCeUluZGV4Lm1hcCggKCBzdWl0ICkgPT4gKFxuICAgIHBva2VyUmFua3NCeVN0cmVuZ3RoLm1hcCggKCByYW5rICkgPT4gKFxuICAgICAgYXJyYXkucHVzaCggcmFuayArIHN1aXQgYXMgUG9rZXJDYXJkIClcbiAgICApIClcbiAgKSApO1xuXG4gIHJldHVybiBhcnJheTtcbn1cbiIsImltcG9ydCB7IFBva2VySGFuZCB9IGZyb20gJy4vUG9rZXJIYW5kJztcblxuZXhwb3J0IGNvbnN0IHBva2VySGFuZFN0cmVuZ3RoTWFwOiB7IFsgaGFuZCBpbiBQb2tlckhhbmQgXTogbnVtYmVyIH0gPSB7XG4gICdIaWdoQ2FyZCc6IDAsXG4gICdPbmVQYWlyJzogMSxcbiAgJ1R3b1BhaXInOiAyLFxuICAnVGhyZWVPZkFLaW5kJzogMyxcbiAgJ1N0cmFpZ2h0JzogNCxcbiAgJ0ZsdXNoJzogNSxcbiAgJ0Z1bGxIb3VzZSc6IDYsXG4gICdGb3VyT2ZBS2luZCc6IDcsXG4gICdTdHJhaWdodEZsdXNoJzogOCxcbn07XG4iLCJpbXBvcnQgdHlwZSB7IFBva2VyUmFuayB9IGZyb20gJy4vUG9rZXJSYW5rJztcblxuZXhwb3J0IGNvbnN0IHBva2VyUmFua1N0cmVuZ3RoTWFwOiB7IFsgcmFuayBpbiBQb2tlclJhbmsgXTogbnVtYmVyIH0gPSB7XG4gICcyJzogMCxcbiAgJzMnOiAxLFxuICAnNCc6IDIsXG4gICc1JzogMyxcbiAgJzYnOiA0LFxuICAnNyc6IDUsXG4gICc4JzogNixcbiAgJzknOiA3LFxuICAnVCc6IDgsXG4gICdKJzogOSxcbiAgJ1EnOiAxMCxcbiAgJ0snOiAxMSxcbiAgJ0EnOiAxMlxufTtcbiIsImltcG9ydCB0eXBlIHsgUG9rZXJTdWl0IH0gZnJvbSAnLi9Qb2tlclN1aXQnO1xuXG5leHBvcnQgY29uc3QgcG9rZXJTdWl0SW5kZXhNYXA6IHsgWyBzdWl0IGluIFBva2VyU3VpdCBdOiBudW1iZXIgfSA9IHtcbiAgJ2MnOiAwLFxuICAnZCc6IDEsXG4gICdoJzogMixcbiAgJ3MnOiAzLFxufTtcbiIsImltcG9ydCB7IHBva2VyUmFua1N0cmVuZ3RoTWFwIH0gZnJvbSAnLi9wb2tlclJhbmtTdHJlbmd0aE1hcCc7XG5pbXBvcnQgeyBwb2tlclN1aXRJbmRleE1hcCB9IGZyb20gJy4vcG9rZXJTdWl0SW5kZXhNYXAnO1xuaW1wb3J0IHR5cGUgeyBQb2tlckNhcmQgfSBmcm9tICcuL1Bva2VyQ2FyZCc7XG5pbXBvcnQgdHlwZSB7IFBva2VyUmFuayB9IGZyb20gJy4vUG9rZXJSYW5rJztcbmltcG9ydCB0eXBlIHsgUG9rZXJTdWl0IH0gZnJvbSAnLi9Qb2tlclN1aXQnO1xuXG4vKipcbiAqIFNvcnQgZ2l2ZW4gYXJyYXkgb2YgY2FyZHMgaW4gcGxhY2UgYnkgcmFuayAoYW5kIHN1aXQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc29ydFBva2VyQ2FyZHNCeVJhbmsoIGNhcmRzOiBQb2tlckNhcmRbXSApOiBQb2tlckNhcmRbXSB7XG4gIHJldHVybiBjYXJkc1xuICAgIC5zb3J0KCAoIGEsIGIgKSA9PiAoXG4gICAgICBwb2tlclN1aXRJbmRleE1hcFsgYVsgMSBdIGFzIFBva2VyU3VpdCBdIC0gcG9rZXJTdWl0SW5kZXhNYXBbIGJbIDEgXSBhcyBQb2tlclN1aXQgXVxuICAgICkgKVxuICAgIC5zb3J0KCAoIGEsIGIgKSA9PiAoXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgYVsgMCBdIGFzIFBva2VyUmFuayBdIC0gcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGJbIDAgXSBhcyBQb2tlclJhbmsgXVxuICAgICkgKTtcbn1cbiIsImltcG9ydCB7IE1hcE9mU2V0IH0gZnJvbSAnLi4vTWFwT2ZTZXQvTWFwT2ZTZXQnO1xuaW1wb3J0IHsgcG9rZXJIYW5kU3RyZW5ndGhNYXAgfSBmcm9tICcuL3Bva2VySGFuZFN0cmVuZ3RoTWFwJztcbmltcG9ydCB7IHBva2VyUmFua1N0cmVuZ3RoTWFwIH0gZnJvbSAnLi9wb2tlclJhbmtTdHJlbmd0aE1hcCc7XG5pbXBvcnQgeyBwb2tlclJhbmtzQnlTdHJlbmd0aCB9IGZyb20gJy4vcG9rZXJSYW5rc0J5U3RyZW5ndGgnO1xuaW1wb3J0IHsgc29ydFBva2VyQ2FyZHNCeVJhbmsgfSBmcm9tICcuL3NvcnRQb2tlckNhcmRzQnlSYW5rJztcbmltcG9ydCB0eXBlIHsgUG9rZXJDYXJkIH0gZnJvbSAnLi9Qb2tlckNhcmQnO1xuaW1wb3J0IHR5cGUgeyBQb2tlckhhbmQgfSBmcm9tICcuL1Bva2VySGFuZCc7XG5pbXBvcnQgdHlwZSB7IFBva2VyUmFuayB9IGZyb20gJy4vUG9rZXJSYW5rJztcbmltcG9ydCB0eXBlIHsgUG9rZXJTdWl0IH0gZnJvbSAnLi9Qb2tlclN1aXQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2YWx1YXRlUG9rZXJIYW5kUmVzdWx0IHtcbiAgaGFuZDogUG9rZXJIYW5kO1xuICBzdHJlbmd0aDogbnVtYmVyW107XG4gIGNhcmRzOiBbIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkIF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsdWF0ZVBva2VySGFuZCggY2FyZHM6IFBva2VyQ2FyZFtdICk6IEV2YWx1YXRlUG9rZXJIYW5kUmVzdWx0IHtcbiAgLy8gY2FyZHMgbXV0YWJsZSBlZGl0aW9uXG4gIGNvbnN0IGNhcmRzXyA9IGNhcmRzLmNvbmNhdCgpO1xuXG4gIGNvbnN0IGNhcmRzQnlSYW5rID0gbmV3IE1hcE9mU2V0PFBva2VyUmFuaywgUG9rZXJDYXJkPigpO1xuICBjb25zdCBjYXJkc0J5U3VpdCA9IG5ldyBNYXBPZlNldDxQb2tlclN1aXQsIFBva2VyQ2FyZD4oKTtcblxuICBjYXJkc18ubWFwKCAoIGNhcmQgKSA9PiB7XG4gICAgY29uc3QgcmFuayA9IGNhcmRbIDAgXSBhcyBQb2tlclJhbms7XG4gICAgY29uc3Qgc3VpdCA9IGNhcmRbIDEgXSBhcyBQb2tlclN1aXQ7XG4gICAgY2FyZHNCeVJhbmsuYWRkKCByYW5rLCBjYXJkICk7XG4gICAgY2FyZHNCeVN1aXQuYWRkKCBzdWl0LCBjYXJkICk7XG4gIH0gKTtcblxuICAvLyBwYWlyc1xuICBjb25zdCBmb3VyczogUG9rZXJSYW5rW10gPSBbXTtcbiAgY29uc3QgdGhyZWVzOiBQb2tlclJhbmtbXSA9IFtdO1xuICBjb25zdCB0d29zOiBQb2tlclJhbmtbXSA9IFtdO1xuXG4gIHBva2VyUmFua3NCeVN0cmVuZ3RoLm1hcCggKCByYW5rICkgPT4ge1xuICAgIGNvbnN0IGNhcmRzID0gY2FyZHNCeVJhbmsuZ2V0KCByYW5rICk7XG4gICAgaWYgKCBjYXJkcy5zaXplID4gMyApIHtcbiAgICAgIGZvdXJzLnB1c2goIHJhbmsgKTtcbiAgICB9IGVsc2UgaWYgKCBjYXJkcy5zaXplID4gMiApIHtcbiAgICAgIHRocmVlcy5wdXNoKCByYW5rICk7XG4gICAgfSBlbHNlIGlmICggY2FyZHMuc2l6ZSA+IDEgKSB7XG4gICAgICB0d29zLnB1c2goIHJhbmsgKTtcbiAgICB9XG4gIH0gKTtcblxuICAvLyBzdHJhaWdodFxuICBsZXQgc3RyYWlnaHRDYXJkczogUG9rZXJDYXJkW10gfCB1bmRlZmluZWQ7XG4gIHtcbiAgICBsZXQgY3VycmVudDogUG9rZXJDYXJkW10gPSBbXTtcblxuICAgIC8vIGhhbmRsZSBzdGVlbCB3aGVlbFxuICAgIGNvbnN0IGEgPSBBcnJheS5mcm9tKCBjYXJkc0J5UmFuay5nZXQoICdBJyApIClbIDAgXTtcbiAgICBpZiAoIGEgKSB7XG4gICAgICBjdXJyZW50LnB1c2goIGEgKTtcbiAgICB9XG5cbiAgICBwb2tlclJhbmtzQnlTdHJlbmd0aC5tYXAoICggcmFuayApID0+IHtcbiAgICAgIGNvbnN0IGNhcmQgPSBBcnJheS5mcm9tKCBjYXJkc0J5UmFuay5nZXQoIHJhbmsgKSApWyAwIF07XG4gICAgICBpZiAoIGNhcmQgKSB7XG4gICAgICAgIGN1cnJlbnQucHVzaCggY2FyZCApO1xuXG4gICAgICAgIGlmICggY3VycmVudC5sZW5ndGggPiA0ICkge1xuICAgICAgICAgIHN0cmFpZ2h0Q2FyZHMgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ID0gW107XG4gICAgICB9XG4gICAgfSApO1xuICB9XG5cbiAgLy8gc3RyYWlnaHQgZmx1c2hcbiAgaWYgKCBzdHJhaWdodENhcmRzICkge1xuICAgIGZvciAoIGNvbnN0IFsgc3VpdCwgY2FyZHNTZXQgXSBvZiBjYXJkc0J5U3VpdC5tYXAgKSB7XG4gICAgICBpZiAoIGNhcmRzU2V0LnNpemUgPiAwICkge1xuICAgICAgICBsZXQgc3RyYWlnaHRGbHVzaENhcmRzOiBQb2tlckNhcmRbXSB8IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGN1cnJlbnQ6IFBva2VyQ2FyZFtdID0gW107XG5cbiAgICAgICAgLy8gaGFuZGxlIHN0ZWVsIHdoZWVsXG4gICAgICAgIGNvbnN0IHRhcmdldCA9ICdBJyArIHN1aXQgYXMgUG9rZXJDYXJkO1xuICAgICAgICBjb25zdCBhID0gY2FyZHNTZXQuaGFzKCB0YXJnZXQgKTtcbiAgICAgICAgaWYgKCBhICkge1xuICAgICAgICAgIGN1cnJlbnQucHVzaCggdGFyZ2V0ICk7XG4gICAgICAgIH1cblxuICAgICAgICBwb2tlclJhbmtzQnlTdHJlbmd0aC5tYXAoICggcmFuayApID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSByYW5rICsgc3VpdCBhcyBQb2tlckNhcmQ7XG4gICAgICAgICAgaWYgKCBjYXJkc1NldC5oYXMoIHRhcmdldCApICkge1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKCB0YXJnZXQgKTtcblxuICAgICAgICAgICAgaWYgKCBjdXJyZW50Lmxlbmd0aCA+IDQgKSB7XG4gICAgICAgICAgICAgIHN0cmFpZ2h0Rmx1c2hDYXJkcyA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICBpZiAoIHN0cmFpZ2h0Rmx1c2hDYXJkcyApIHtcbiAgICAgICAgICBzdHJhaWdodEZsdXNoQ2FyZHMuc3BsaWNlKCAwLCBzdHJhaWdodEZsdXNoQ2FyZHMubGVuZ3RoIC0gNSApO1xuXG4gICAgICAgICAgY29uc3QgaGFuZCA9ICdTdHJhaWdodEZsdXNoJztcbiAgICAgICAgICBjb25zdCBzdHJlbmd0aCA9IFtcbiAgICAgICAgICAgIHBva2VySGFuZFN0cmVuZ3RoTWFwWyBoYW5kIF0sXG4gICAgICAgICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgc3RyYWlnaHRGbHVzaENhcmRzWyA0IF1bIDAgXSBhcyBQb2tlclJhbmsgXSxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhbmQsXG4gICAgICAgICAgICBjYXJkczogc3RyYWlnaHRGbHVzaENhcmRzIGFzIFsgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQgXSxcbiAgICAgICAgICAgIHN0cmVuZ3RoLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBmb3VyIG9mIGEga2luZFxuICBpZiAoIGZvdXJzLmxlbmd0aCA+IDAgKSB7XG4gICAgZm91cnMuc29ydCggKCBhLCBiICkgPT4gcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGEgXSAtIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBiIF0gKTtcbiAgICBmb3Vycy5zcGxpY2UoIDAsIGZvdXJzLmxlbmd0aCAtIDEgKTtcblxuICAgIC8vIDVzLCA1YywgS2QsIDZkLCA5YywgNWQsIDVoXG5cbiAgICBjb25zdCBzYW1lQ2FyZHMgPSBBcnJheS5mcm9tKCBjYXJkc0J5UmFuay5nZXQoIGZvdXJzWyAwIF0gKSApO1xuICAgIHNhbWVDYXJkcy5tYXAoICggY2FyZCApID0+IChcbiAgICAgIGNhcmRzXy5zcGxpY2UoIGNhcmRzXy5pbmRleE9mKCBjYXJkICksIDEgKVxuICAgICkgKTtcbiAgICAvLyBLZCwgNmQsIDljXG5cbiAgICBzb3J0UG9rZXJDYXJkc0J5UmFuayggY2FyZHNfICkuc3BsaWNlKCAwLCBjYXJkc18ubGVuZ3RoIC0gMSApO1xuICAgIC8vIEtkXG5cbiAgICBjb25zdCBoYW5kID0gJ0ZvdXJPZkFLaW5kJztcbiAgICBjb25zdCBzdHJlbmd0aCA9IFtcbiAgICAgIHBva2VySGFuZFN0cmVuZ3RoTWFwWyBoYW5kIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgZm91cnNbIDAgXSBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGNhcmRzX1sgMCBdWyAwIF0gYXMgUG9rZXJSYW5rIF0sXG4gICAgXTtcblxuICAgIGNhcmRzXy5wdXNoKCAuLi5zYW1lQ2FyZHMgKTtcbiAgICBzb3J0UG9rZXJDYXJkc0J5UmFuayggY2FyZHNfICk7XG4gICAgLy8gNWMsIDVkLCA1aCwgNXMsIEtkXG5cbiAgICByZXR1cm4ge1xuICAgICAgaGFuZCxcbiAgICAgIGNhcmRzOiBjYXJkc18gYXMgWyBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCBdLFxuICAgICAgc3RyZW5ndGgsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGZ1bGwgaG91c2VcbiAgaWYgKCB0aHJlZXMubGVuZ3RoID4gMCAmJiB0aHJlZXMubGVuZ3RoICsgdHdvcy5sZW5ndGggPiAxICkge1xuICAgIHRocmVlcy5zb3J0KCAoIGEsIGIgKSA9PiBwb2tlclJhbmtTdHJlbmd0aE1hcFsgYSBdIC0gcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGIgXSApO1xuXG4gICAgLy8gdHJpY2t5IHBhcnQ6IGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgdHdvIG9yIG1vcmUgdGhyZWVzIGF0IG9uY2VcbiAgICAvLyBqdXN0IHRyYW5zZmVyIHRocmVlcyB3aGljaCBpcyBub3QgaGlnaGVzdFxuICAgIC8vIGFuZCB3aXNoIHdlJ2xsIGRvIHRoaXMgcmlnaHQgaW4gdGhlIHJlc3Qgb2YgdGhlIGNvZGVcbiAgICB0d29zLnB1c2goIC4uLnRocmVlcy5zcGxpY2UoIDAsIHRocmVlcy5sZW5ndGggLSAxICkgKTtcblxuICAgIHR3b3Muc29ydCggKCBhLCBiICkgPT4gcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGEgXSAtIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBiIF0gKTtcbiAgICB0d29zLnNwbGljZSggMCwgdHdvcy5sZW5ndGggLSAxICk7XG5cbiAgICAvLyA3ZCwgN3MsIFRjLCBUZCwgN2gsIDlkLCBUaFxuXG4gICAgY29uc3Qgc2FtZUNhcmRzID0gQXJyYXkuZnJvbSggY2FyZHNCeVJhbmsuZ2V0KCB0aHJlZXNbIDAgXSApICk7XG4gICAgc2FtZUNhcmRzLnB1c2goIC4uLkFycmF5LmZyb20oIGNhcmRzQnlSYW5rLmdldCggdHdvc1sgMCBdICkgKSApO1xuICAgIC8vIHNhbWVDYXJkczogVGMsIFRkLCBUaCwgN2QsIDdzLCA3aFxuXG4gICAgc29ydFBva2VyQ2FyZHNCeVJhbmsoIHNhbWVDYXJkcyApLnNwbGljZSggMCwgc2FtZUNhcmRzLmxlbmd0aCAtIDUgKTtcbiAgICAvLyBzYW1lQ2FyZHM6IDdoLCA3cywgVGMsIFRkLCBUaFxuXG4gICAgY29uc3QgaGFuZCA9ICdGdWxsSG91c2UnO1xuICAgIGNvbnN0IHN0cmVuZ3RoID0gW1xuICAgICAgcG9rZXJIYW5kU3RyZW5ndGhNYXBbIGhhbmQgXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyB0aHJlZXNbIDAgXSBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIHR3b3NbIDAgXSBdLFxuICAgIF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgaGFuZCxcbiAgICAgIGNhcmRzOiBzYW1lQ2FyZHMgYXMgWyBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCBdLFxuICAgICAgc3RyZW5ndGgsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGZsdXNoXG4gIGZvciAoIGNvbnN0IFsgX3N1aXQsIGNhcmRzU2V0IF0gb2YgY2FyZHNCeVN1aXQubWFwICkge1xuICAgIGlmICggY2FyZHNTZXQuc2l6ZSA+IDQgKSB7XG4gICAgICBjb25zdCBjYXJkcyA9IHNvcnRQb2tlckNhcmRzQnlSYW5rKCBBcnJheS5mcm9tKCBjYXJkc1NldCApICk7XG4gICAgICBjYXJkcy5zcGxpY2UoIDAsIGNhcmRzLmxlbmd0aCAtIDUgKTtcblxuICAgICAgY29uc3QgaGFuZCA9ICdGbHVzaCc7XG4gICAgICBjb25zdCBzdHJlbmd0aCA9IFtcbiAgICAgICAgcG9rZXJIYW5kU3RyZW5ndGhNYXBbIGhhbmQgXSxcbiAgICAgICAgLi4uY2FyZHNcbiAgICAgICAgICAuY29uY2F0KClcbiAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgLm1hcCggKCBjYXJkICkgPT4gKFxuICAgICAgICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGNhcmRbIDAgXSBhcyBQb2tlclJhbmsgXVxuICAgICAgICAgICkgKSxcbiAgICAgIF07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhbmQsXG4gICAgICAgIGNhcmRzOiBjYXJkcyBhcyBbIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkIF0sXG4gICAgICAgIHN0cmVuZ3RoLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBzdHJhaWdodFxuICBpZiAoIHN0cmFpZ2h0Q2FyZHMgKSB7XG4gICAgc3RyYWlnaHRDYXJkcy5zcGxpY2UoIDAsIHN0cmFpZ2h0Q2FyZHMubGVuZ3RoIC0gNSApO1xuXG4gICAgY29uc3QgaGFuZCA9ICdTdHJhaWdodCc7XG4gICAgY29uc3Qgc3RyZW5ndGggPSBbXG4gICAgICBwb2tlckhhbmRTdHJlbmd0aE1hcFsgaGFuZCBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIHN0cmFpZ2h0Q2FyZHNbIDQgXVsgMCBdIGFzIFBva2VyUmFuayBdLFxuICAgIF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgaGFuZCxcbiAgICAgIGNhcmRzOiBzdHJhaWdodENhcmRzIGFzIFsgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQgXSxcbiAgICAgIHN0cmVuZ3RoLFxuICAgIH07XG4gIH1cblxuICAvLyB0aHJlZSBvZiBhIGtpbmRcbiAgaWYgKCB0aHJlZXMubGVuZ3RoID4gMCApIHtcbiAgICB0aHJlZXMuc29ydCggKCBhLCBiICkgPT4gcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGEgXSAtIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBiIF0gKTtcbiAgICB0aHJlZXMuc3BsaWNlKCAwLCB0aHJlZXMubGVuZ3RoIC0gMSApO1xuXG4gICAgLy8gQWgsIEFkLCBLYywgN3MsIDRzLCBRYywgQXNcblxuICAgIGNvbnN0IHNhbWVDYXJkcyA9IEFycmF5LmZyb20oIGNhcmRzQnlSYW5rLmdldCggdGhyZWVzWyAwIF0gKSApO1xuICAgIHNhbWVDYXJkcy5tYXAoICggY2FyZCApID0+IChcbiAgICAgIGNhcmRzXy5zcGxpY2UoIGNhcmRzXy5pbmRleE9mKCBjYXJkICksIDEgKVxuICAgICkgKTtcbiAgICAvLyBLYywgN3MsIDRzLCBRY1xuXG4gICAgc29ydFBva2VyQ2FyZHNCeVJhbmsoIGNhcmRzXyApLnNwbGljZSggMCwgY2FyZHNfLmxlbmd0aCAtIDIgKTtcbiAgICAvLyBRYywgS2NcblxuICAgIGNvbnN0IGhhbmQgPSAnVGhyZWVPZkFLaW5kJztcbiAgICBjb25zdCBzdHJlbmd0aCA9IFtcbiAgICAgIHBva2VySGFuZFN0cmVuZ3RoTWFwWyBoYW5kIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgdGhyZWVzWyAwIF0gXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBjYXJkc19bIDEgXVsgMCBdIGFzIFBva2VyUmFuayBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGNhcmRzX1sgMCBdWyAwIF0gYXMgUG9rZXJSYW5rIF0sXG4gICAgXTtcblxuICAgIGNhcmRzXy5wdXNoKCAuLi5zYW1lQ2FyZHMgKTtcbiAgICBzb3J0UG9rZXJDYXJkc0J5UmFuayggY2FyZHNfICk7XG4gICAgLy8gUWMsIEtjLCBBZCwgQWgsIEFzXG5cbiAgICByZXR1cm4ge1xuICAgICAgaGFuZCxcbiAgICAgIGNhcmRzOiBjYXJkc18gYXMgWyBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCBdLFxuICAgICAgc3RyZW5ndGgsXG4gICAgfTtcbiAgfVxuXG4gIC8vIHR3byBwYWlyXG4gIGlmICggdHdvcy5sZW5ndGggPiAxICkge1xuICAgIHR3b3Muc29ydCggKCBhLCBiICkgPT4gcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGEgXSAtIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBiIF0gKTtcbiAgICB0d29zLnNwbGljZSggMCwgdHdvcy5sZW5ndGggLSAyICk7XG5cbiAgICAvLyA0YywgOGQsIDdoLCA0aCwgOGgsIEpjLCAyc1xuXG4gICAgY29uc3QgcGFpcnMgPSBBcnJheS5mcm9tKCBjYXJkc0J5UmFuay5nZXQoIHR3b3NbIDAgXSApICk7XG4gICAgcGFpcnMucHVzaCggLi4uQXJyYXkuZnJvbSggY2FyZHNCeVJhbmsuZ2V0KCB0d29zWyAxIF0gKSApICk7XG4gICAgcGFpcnMubWFwKCAoIGNhcmQgKSA9PiAoXG4gICAgICBjYXJkc18uc3BsaWNlKCBjYXJkc18uaW5kZXhPZiggY2FyZCApLCAxIClcbiAgICApICk7XG4gICAgLy8gN2gsIEpjLCAyc1xuXG4gICAgc29ydFBva2VyQ2FyZHNCeVJhbmsoIGNhcmRzXyApLnNwbGljZSggMCwgY2FyZHNfLmxlbmd0aCAtIDEgKTtcbiAgICAvLyBKY1xuXG4gICAgY29uc3QgaGFuZCA9ICdUd29QYWlyJztcbiAgICBjb25zdCBzdHJlbmd0aCA9IFtcbiAgICAgIHBva2VySGFuZFN0cmVuZ3RoTWFwWyBoYW5kIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgdHdvc1sgMSBdIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgdHdvc1sgMCBdIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgY2FyZHNfWyAwIF1bIDAgXSBhcyBQb2tlclJhbmsgXSxcbiAgICBdO1xuXG4gICAgY2FyZHNfLnB1c2goIC4uLnBhaXJzICk7XG4gICAgc29ydFBva2VyQ2FyZHNCeVJhbmsoIGNhcmRzXyApO1xuICAgIC8vIDRjLCA0aCwgOGQsIDhoLCBKY1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmQsXG4gICAgICBjYXJkczogY2FyZHNfIGFzIFsgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQgXSxcbiAgICAgIHN0cmVuZ3RoLFxuICAgIH07XG4gIH1cblxuICAvLyBvbmUgcGFpclxuICBpZiAoIHR3b3MubGVuZ3RoID4gMCApIHtcbiAgICAvLyAzYywgNWQsIDhjLCA4cywgQWMsIFFkLCA3aFxuXG4gICAgY29uc3QgcGFpciA9IEFycmF5LmZyb20oIGNhcmRzQnlSYW5rLmdldCggdHdvc1sgMCBdICkgKTtcbiAgICBwYWlyLm1hcCggKCBjYXJkICkgPT4gKFxuICAgICAgY2FyZHNfLnNwbGljZSggY2FyZHNfLmluZGV4T2YoIGNhcmQgKSwgMSApXG4gICAgKSApO1xuICAgIC8vIDNjLCA1ZCwgQWMsIFFkLCA3aFxuXG4gICAgc29ydFBva2VyQ2FyZHNCeVJhbmsoIGNhcmRzXyApLnNwbGljZSggMCwgY2FyZHNfLmxlbmd0aCAtIDMgKTtcbiAgICAvLyA3aCwgUWQsIEFjXG5cbiAgICBjb25zdCBoYW5kID0gJ09uZVBhaXInO1xuICAgIGNvbnN0IHN0cmVuZ3RoID0gW1xuICAgICAgcG9rZXJIYW5kU3RyZW5ndGhNYXBbIGhhbmQgXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyB0d29zWyAwIF0gXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBjYXJkc19bIDIgXVsgMCBdIGFzIFBva2VyUmFuayBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGNhcmRzX1sgMSBdWyAwIF0gYXMgUG9rZXJSYW5rIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgY2FyZHNfWyAwIF1bIDAgXSBhcyBQb2tlclJhbmsgXSxcbiAgICBdO1xuXG4gICAgY2FyZHNfLnB1c2goIC4uLnBhaXIgKTtcbiAgICBzb3J0UG9rZXJDYXJkc0J5UmFuayggY2FyZHNfICk7XG4gICAgLy8gN2gsIDhjLCA4cywgUWQsIEFjXG5cbiAgICByZXR1cm4ge1xuICAgICAgaGFuZCxcbiAgICAgIGNhcmRzOiBjYXJkc18gYXMgWyBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCBdLFxuICAgICAgc3RyZW5ndGgsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGhpZ2ggY2FyZFxuICB7XG4gICAgY29uc3QgaGFuZCA9ICdIaWdoQ2FyZCc7XG5cbiAgICAvLyAyaCwgNWMsIDZjLCA3cywgVGQsIEFkLCBLZFxuXG4gICAgc29ydFBva2VyQ2FyZHNCeVJhbmsoIGNhcmRzXyApO1xuICAgIC8vIDJoLCA1YywgNmMsIDdzLCBUZCwgS2QsIEFkXG5cbiAgICBjYXJkc18uc3BsaWNlKCAwLCBjYXJkc18ubGVuZ3RoIC0gNSApO1xuICAgIC8vIDZjLCA3cywgVGQsIEtkLCBBZFxuXG4gICAgY29uc3Qgc3RyZW5ndGggPSBbXG4gICAgICBwb2tlckhhbmRTdHJlbmd0aE1hcFsgaGFuZCBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGNhcmRzX1sgNCBdWyAwIF0gYXMgUG9rZXJSYW5rIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgY2FyZHNfWyAzIF1bIDAgXSBhcyBQb2tlclJhbmsgXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBjYXJkc19bIDIgXVsgMCBdIGFzIFBva2VyUmFuayBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGNhcmRzX1sgMSBdWyAwIF0gYXMgUG9rZXJSYW5rIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgY2FyZHNfWyAwIF1bIDAgXSBhcyBQb2tlclJhbmsgXSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmQsXG4gICAgICBjYXJkczogY2FyZHNfIGFzIFsgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQgXSxcbiAgICAgIHN0cmVuZ3RoLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUG9rZXJIYW5kIH0gZnJvbSAnLi9Qb2tlckhhbmQnO1xuXG5leHBvcnQgY29uc3QgcG9rZXJIYW5kc0J5U3RyZW5ndGg6IFBva2VySGFuZFtdID0gW1xuICAnSGlnaENhcmQnLFxuICAnT25lUGFpcicsXG4gICdUd29QYWlyJyxcbiAgJ1RocmVlT2ZBS2luZCcsXG4gICdTdHJhaWdodCcsXG4gICdGbHVzaCcsXG4gICdGdWxsSG91c2UnLFxuICAnRm91ck9mQUtpbmQnLFxuICAnU3RyYWlnaHRGbHVzaCcsXG5dO1xuIiwiLyoqXG4gKiBSZXRyeSBnaXZlbiBmdW5jdGlvbiBmb3IgbiB0aW1lcy5cbiAqXG4gKiBTZWUgYWxzbzoge0BsaW5rIHJldHJ5fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNSZXRyeTxUPiggZnVuYzogKCkgPT4gUHJvbWlzZTxUPiwgbjogbnVtYmVyICk6IFByb21pc2U8VD4ge1xuICByZXR1cm4gYXdhaXQgZnVuYygpLmNhdGNoKCAoIGVycm9yICkgPT4ge1xuICAgIGlmICggbiA8PSAxICkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzeW5jUmV0cnkoIGZ1bmMsIG4gLSAxICk7XG4gIH0gKTtcbn1cbiIsIi8qKlxuICogUmV0cnkgZ2l2ZW4gZnVuY3Rpb24gZm9yIG4gdGltZXMuXG4gKlxuICogU2VlIGFsc286IHtAbGluayBhc3luY1JldHJ5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0cnk8VD4oIGZ1bmM6ICgpID0+IFQsIG46IG51bWJlciApOiBUIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnVuYygpO1xuICB9IGNhdGNoICggZXJyb3IgKSB7XG4gICAgaWYgKCBuIDw9IDEgKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0cnkoIGZ1bmMsIG4gLSAxICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IFNUTklDQ0NGcmFtZSB9IGZyb20gJy4vU1ROSUNDQ0ZyYW1lJztcblxuLyoqXG4gKiBSZWY6IGh0dHA6Ly9hcnNhbnRpY2Etb25saW5lLmNvbS9zdC1uaWNjYy1jb21wZXRpdGlvbi9cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIFRoZSBpbnB1dCBTVC1OSUNDQyBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNUTklDQ0MoIGJ1ZmZlcjogQXJyYXlCdWZmZXIgKTogU1ROSUNDQ0ZyYW1lW10ge1xuICBjb25zdCBmcmFtZXM6IFNUTklDQ0NGcmFtZVtdID0gW107XG5cbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSggYnVmZmVyICk7XG5cbiAgY29uc3QgcGFsZXR0ZSA9IG5ldyBVaW50MTZBcnJheSggMTYgKTtcblxuICBsZXQgaGVhZCA9IDA7XG5cbiAgLy8gd2hlbiBwb2x5LWRlc2NyaXB0b3Igc2F5cyAweGZlXG4gIGxldCBzaG91bGRTa2lwID0gZmFsc2U7XG5cbiAgLy8gd2hlbiBwb2x5LWRlc2NyaXB0b3Igc2F5cyAweGZkXG4gIGxldCBzaG91bGRFbmQgPSBmYWxzZTtcblxuICAvLyA+IEV2ZXJ5IGZyYW1lIHN0b3JlcyB0aGUgZm9sbG93aW5nIGRhdGE6XG4gIGZvciAoIDs7ICkge1xuICAgIC8vID4gMSBieXRlIEZsYWdzIEJpdCAwOiBGcmFtZSBuZWVkcyB0byBjbGVhciB0aGUgc2NyZWVuLlxuICAgIC8vID4gQml0IDE6IEZyYW1lIGNvbnRhaW5zIHBhbGV0dGUgZGF0YS5cbiAgICAvLyA+IEJpdCAyOiBGcmFtZSBpcyBzdG9yZWQgaW4gaW5kZXhlZCBtb2RlLlxuICAgIGNvbnN0IGZsYWdzID0gYXJyYXlbIGhlYWQgKysgXTtcbiAgICBjb25zdCBuZWVkc0NsZWFyID0gKCBmbGFncyAmIDEgKSA9PT0gMTtcbiAgICBjb25zdCBoYXNQYWxldHRlID0gKCBmbGFncyA+PiAxICYgMSApID09PSAxO1xuICAgIGNvbnN0IGluZGV4ZWRNb2RlID0gKCBmbGFncyA+PiAyICYgMSApID09PSAxO1xuXG4gICAgLy8gPiBJZiBmcmFtZSBjb250YWlucyBwYWxldHRlIGRhdGFcbiAgICBpZiAoIGhhc1BhbGV0dGUgKSB7XG4gICAgICAvLyA+IDEgd29yZCBCaXRtYXNrXG4gICAgICBjb25zdCBiaXRtYXNrID0gYXJyYXlbIGhlYWQgKysgXSA8PCA4IHwgYXJyYXlbIGhlYWQgKysgXTtcblxuICAgICAgLy8gPiBGb3IgZXZlcnkgc2V0IGJpdCBpbiB0aGUgQml0bWFzayAoMC0xNSlcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuICAgICAgICBpZiAoIGJpdG1hc2sgPj4gKCAxNSAtIGkgKSAmIDEgKSB7XG4gICAgICAgICAgLy8gPiAxIHdvcmQgQ29sb3IgVGhlIGNvbG9yIGhhcyB0byBiZSBjb3BpZWQgaW50byB0aGUgcGFsZXR0ZSBhdCB0aGUgcmV2ZXJzZSBpbmRleCBvZiB0aGUgYWN0dWFsIGJpdCxcbiAgICAgICAgICAvLyA+IGJlY2F1c2UgdGhlIGJpdG1hc2sgaXMgc3RvcmVkIGluIHJldmVyc2Ugb3JkZXIuXG4gICAgICAgICAgLy8gPiBJbiBvdGhlciB3b3JkczogSWYgYml0IDE1IG9mIG1hc2sgaXMgc2V0IC0+IHVwZGF0ZSBjb2xvciAwIG9mIHBhbGV0dGUsXG4gICAgICAgICAgLy8gPiDigKZcbiAgICAgICAgICAvLyA+IGlmIGJpdCAwIG9mIG1hc2sgaXMgc2V0IC0+IHVwZGF0ZSBjb2xvciAxNSBvZiBwYWxldHRlLlxuXG4gICAgICAgICAgcGFsZXR0ZVsgaSBdID0gYXJyYXlbIGhlYWQgKysgXSA8PCA4IHwgYXJyYXlbIGhlYWQgKysgXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vID4gSWYgZnJhbWUgaXMgc3RvcmVkIGluIGluZGV4ZWQgbW9kZVxuICAgIGlmICggaW5kZXhlZE1vZGUgKSB7XG4gICAgICAvLyA+IDEgYnl0ZSBOdW1iZXIgb2YgdmVydGljZXMgKDAtMjU1KVxuICAgICAgY29uc3QgblZlcnRpY2VzID0gYXJyYXlbIGhlYWQgKysgXTtcblxuICAgICAgLy8gPiBGb3IgZXZlcnkgVmVydGV4XG4gICAgICAvLyA+IHtcbiAgICAgIC8vID4gMSBieXRlIFgtcG9zaXRpb25cbiAgICAgIC8vID4gMSBieXRlIFktcG9zaXRpb25cbiAgICAgIC8vID4gfVxuICAgICAgY29uc3QgdmVydGljZXMgPSBhcnJheS5zdWJhcnJheSggaGVhZCwgaGVhZCArIDIgKiBuVmVydGljZXMgKTtcbiAgICAgIGhlYWQgKz0gMiAqIG5WZXJ0aWNlcztcblxuICAgICAgY29uc3QgcG9seWdvbnM6IHsgY29sb3JJbmRleDogbnVtYmVyOyBpbmRpY2VzOiBudW1iZXJbXSB9W10gPSBbXTtcblxuICAgICAgLy8gPiBXaGlsZSAo4oCmKVxuICAgICAgZm9yICggOzsgKSB7XG4gICAgICAgIC8vID4gMSBieXRlIFBvbHktZGVzY3JpcHRvciBDb250YWluczogaGktbmliYmxlIC0gNCBiaXRzIGNvbG9yLWluZGV4XG4gICAgICAgIC8vID4gbG8tbmliYmxlIC0gNCBiaXRzIG51bWJlciBvZiBwb2x5Z29uIHZlcnRpY2VzXG4gICAgICAgIC8vID5cbiAgICAgICAgLy8gPiBTb21lIHNwZWNpYWwgY2FzZXMgYXJlIGVuY29kZWQgaW4gdGhlIGRlc2NyaXB0b3IgYnl0ZTpcbiAgICAgICAgLy8gPiAkZmYgPSBFbmQgb2YgZnJhbWVcbiAgICAgICAgLy8gPiAkZmUgPSBFbmQgb2YgZnJhbWUgYW5kIHRoZSBzdHJlYW0gc2tpcHMgdG8gdGhlIG5leHQgNjRLQiBibG9ja1xuICAgICAgICAvLyA+ICRmZCA9IEVuZCBvZiBzdHJlYW0gKHdlIGFyZSBkb25lIFxcby8pXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBhcnJheVsgaGVhZCArKyBdO1xuXG4gICAgICAgIGlmICggZGVzY3JpcHRvciA9PT0gMHhmZiApIHsgLy8gZW5kIG9mIGZyYW1lXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfSBlbHNlIGlmICggZGVzY3JpcHRvciA9PT0gMHhmZSApIHsgLy8gZW5kIG9mIGZyYW1lICsgc2tpcCB0byB0aGUgbmV4dCA2NEtCXG4gICAgICAgICAgc2hvdWxkU2tpcCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfSBlbHNlIGlmICggZGVzY3JpcHRvciA9PT0gMHhmZCApIHsgLy8gZW5kIG9mIHN0cmVhbVxuICAgICAgICAgIHNob3VsZEVuZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbG9ySW5kZXggPSBkZXNjcmlwdG9yID4+IDQgJiAxNTtcbiAgICAgICAgY29uc3QgbkluZGljZXMgPSBkZXNjcmlwdG9yICYgMTU7XG5cbiAgICAgICAgLy8gPiBGb3IgZXZlcnkgdmVydGV4IG9mIHRoZSBwb2x5Z29uXG4gICAgICAgIC8vID4ge1xuICAgICAgICAvLyA+IDEgYnl0ZSBWZXJ0ZXgtaWQgKDAtMjU1KVxuICAgICAgICAvLyA+IH1cbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IGFycmF5LnN1YmFycmF5KCBoZWFkLCBoZWFkICsgbkluZGljZXMgKTtcbiAgICAgICAgaGVhZCArPSBuSW5kaWNlcztcblxuICAgICAgICBwb2x5Z29ucy5wdXNoKCB7XG4gICAgICAgICAgY29sb3JJbmRleCxcbiAgICAgICAgICBpbmRpY2VzOiBBcnJheS5mcm9tKCBpbmRpY2VzICksXG4gICAgICAgIH0gKTtcbiAgICAgIH1cblxuICAgICAgZnJhbWVzLnB1c2goIHtcbiAgICAgICAgbmVlZHNDbGVhcixcbiAgICAgICAgaW5kZXhlZE1vZGUsXG4gICAgICAgIHBhbGV0dGU6IEFycmF5LmZyb20oIHBhbGV0dGUgKSxcbiAgICAgICAgdmVydGljZXM6IEFycmF5LmZyb20oIHZlcnRpY2VzICksXG4gICAgICAgIHBvbHlnb25zLFxuICAgICAgfSApO1xuXG4gICAgLy8gPiBFbHNlIGlmIGZyYW1lIGlzIHN0b3JlZCBpbiBub24taW5kZXhlZCBtb2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvbHlnb25zOiB7IGNvbG9ySW5kZXg6IG51bWJlcjsgdmVydGljZXM6IG51bWJlcltdIH1bXSA9IFtdO1xuXG4gICAgICAvLyA+IFdoaWxlICjigKYpXG4gICAgICBmb3IgKCA7OyApIHtcbiAgICAgICAgLy8gPiAxIGJ5dGUgUG9seS1kZXNjcmlwdG9yIChTZWUgaW5kZXhlZCBtb2RlKVxuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gYXJyYXlbIGhlYWQgKysgXTtcblxuICAgICAgICBpZiAoIGRlc2NyaXB0b3IgPT09IDB4ZmYgKSB7IC8vIGVuZCBvZiBmcmFtZVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIGRlc2NyaXB0b3IgPT09IDB4ZmUgKSB7IC8vIGVuZCBvZiBmcmFtZSArIHNraXAgdG8gdGhlIG5leHQgNjRLQlxuICAgICAgICAgIHNob3VsZFNraXAgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIGRlc2NyaXB0b3IgPT09IDB4ZmQgKSB7IC8vIGVuZCBvZiBzdHJlYW1cbiAgICAgICAgICBzaG91bGRFbmQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2xvckluZGV4ID0gZGVzY3JpcHRvciA+PiA0ICYgMTU7XG4gICAgICAgIGNvbnN0IG5WZXJ0aWNlcyA9IGRlc2NyaXB0b3IgJiAxNTtcblxuICAgICAgICAvLyA+IEZvciBldmVyeSB2ZXJ0ZXggb2YgdGhlIHBvbHlnb25cbiAgICAgICAgLy8gPiB7XG4gICAgICAgIC8vID4gMSBieXRlIFZlcnRleC1pZCAoMC0yNTUpXG4gICAgICAgIC8vID4gfVxuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IGFycmF5LnN1YmFycmF5KCBoZWFkLCBoZWFkICsgMiAqIG5WZXJ0aWNlcyApO1xuICAgICAgICBoZWFkICs9IDIgKiBuVmVydGljZXM7XG5cbiAgICAgICAgcG9seWdvbnMucHVzaCgge1xuICAgICAgICAgIGNvbG9ySW5kZXgsXG4gICAgICAgICAgdmVydGljZXM6IEFycmF5LmZyb20oIHZlcnRpY2VzICksXG4gICAgICAgIH0gKTtcbiAgICAgIH1cblxuICAgICAgZnJhbWVzLnB1c2goIHtcbiAgICAgICAgbmVlZHNDbGVhcixcbiAgICAgICAgaW5kZXhlZE1vZGUsXG4gICAgICAgIHBhbGV0dGU6IEFycmF5LmZyb20oIHBhbGV0dGUgKSxcbiAgICAgICAgcG9seWdvbnMsXG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgaWYgKCBzaG91bGRTa2lwICkge1xuICAgICAgaGVhZCA9ICggTWF0aC5mbG9vciggaGVhZCAvIDB4MTAwMDAgKSArIDEgKSAqIDB4MTAwMDA7XG4gICAgICBzaG91bGRTa2lwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCBzaG91bGRFbmQgKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnJhbWVzO1xufVxuIiwiaW1wb3J0IHsgU1ROSUNDQ0ZyYW1lIH0gZnJvbSAnLi9TVE5JQ0NDRnJhbWUnO1xuaW1wb3J0IHsgY29sb3JGcm9tQXRhcmlTVCB9IGZyb20gJy4uL2NvbG9yL2NvbG9yRnJvbUF0YXJpU1QnO1xuaW1wb3J0IHsgY29sb3JUb0hleCB9IGZyb20gJy4uL2NvbG9yL2NvbG9yVG9IZXgnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RuaWNjY1RvU1ZHKCBmcmFtZXM6IFNUTklDQ0NGcmFtZVtdLCBvcHRpb25zOiB7XG4gIGZwcz86IG51bWJlcjtcbn0gPSB7fSApOiBzdHJpbmcge1xuICBjb25zdCBkZWx0YSA9IDEuMCAvICggb3B0aW9ucz8uZnBzID8/IDMwLjAgKTtcblxuICBsZXQgc3ZnID0gJzxzdmcgd2lkdGg9XCIyNTZcIiBoZWlnaHQ9XCIyMDBcIiB2aWV3Qm94PVwiMCAwIDI1NiAyMDBcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JztcblxuICBsZXQgc3R5bGUgPSBgZ3t2aXNpYmlsaXR5OmhpZGRlbjthbmltYXRpb24tZHVyYXRpb246JHsgKCBkZWx0YSAqIGZyYW1lcy5sZW5ndGggKS50b0ZpeGVkKCAzICkgfXM7YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZTthbmltYXRpb24tbmFtZTpmcmFtZX1Aa2V5ZnJhbWVzIGZyYW1lezAle3Zpc2liaWxpdHk6dmlzaWJsZX0keyAyMDAuMCAvIGZyYW1lcy5sZW5ndGggfSV7dmlzaWJpbGl0eTpoaWRkZW59fWA7XG5cbiAgZnJhbWVzLm1hcCggKCBmcmFtZSwgaUZyYW1lICkgPT4ge1xuICAgIGNvbnN0IHsgaW5kZXhlZE1vZGUsIHBhbGV0dGUsIHBvbHlnb25zIH0gPSBmcmFtZTtcblxuICAgIHN0eWxlICs9IGAjZiR7IGlGcmFtZSB9e2FuaW1hdGlvbi1kZWxheTokeyAoIGRlbHRhICogaUZyYW1lICkudG9GaXhlZCggMyApIH1zfWA7XG5cbiAgICBjb25zdCBwYWxldHRlSW5IZXggPSBwYWxldHRlLm1hcCggKCBzdENvbG9yICkgPT4ge1xuICAgICAgY29uc3QgY29sb3IgPSBjb2xvckZyb21BdGFyaVNUKCBzdENvbG9yICk7XG4gICAgICByZXR1cm4gY29sb3JUb0hleCggY29sb3IgKTtcbiAgICB9ICk7XG5cbiAgICBsZXQgY2hpbGRyZW5TdHIgPSAnPHJlY3Qgd2lkdGg9XCIyNTZcIiBoZWlnaHQ9XCIyMDBcIiBmaWxsPVwiIzAwMFwiIC8+JztcblxuICAgIGxldCBjdXJyZW50Q29sb3JJbmRleCA9IC0xO1xuICAgIGxldCBkID0gJyc7XG5cbiAgICBpZiAoIGluZGV4ZWRNb2RlICkge1xuICAgICAgY29uc3QgeyB2ZXJ0aWNlcyB9ID0gZnJhbWU7XG5cbiAgICAgIHBvbHlnb25zLm1hcCggKCB7IGNvbG9ySW5kZXgsIGluZGljZXMgfSApID0+IHtcbiAgICAgICAgaWYgKCBjdXJyZW50Q29sb3JJbmRleCAhPT0gY29sb3JJbmRleCApIHtcbiAgICAgICAgICBpZiAoIGN1cnJlbnRDb2xvckluZGV4ICE9PSAtMSApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9ySGV4ID0gcGFsZXR0ZUluSGV4WyBjdXJyZW50Q29sb3JJbmRleCBdO1xuICAgICAgICAgICAgY2hpbGRyZW5TdHIgKz0gYDxwYXRoIGQ9XCIkeyBkIH1cIiBmaWxsPVwiJHsgY29sb3JIZXggfVwiIC8+YDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50Q29sb3JJbmRleCA9IGNvbG9ySW5kZXg7XG4gICAgICAgICAgZCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKysgKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBpbmRpY2VzWyBpIF07XG4gICAgICAgICAgY29uc3QgeCA9IHZlcnRpY2VzWyAyICogaW5kZXggXTtcbiAgICAgICAgICBjb25zdCB5ID0gdmVydGljZXNbIDIgKiBpbmRleCArIDEgXTtcblxuICAgICAgICAgIGQgKz0gaSA9PT0gMFxuICAgICAgICAgICAgPyBgTSR7IHggfSwkeyB5IH1gXG4gICAgICAgICAgICA6IGBMJHsgeCB9LCR7IHkgfWA7XG4gICAgICAgIH1cbiAgICAgIH0gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9seWdvbnMubWFwKCAoIHsgY29sb3JJbmRleCwgdmVydGljZXMgfSApID0+IHtcbiAgICAgICAgaWYgKCBjdXJyZW50Q29sb3JJbmRleCAhPT0gY29sb3JJbmRleCApIHtcbiAgICAgICAgICBpZiAoIGN1cnJlbnRDb2xvckluZGV4ICE9PSAtMSApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9ySGV4ID0gcGFsZXR0ZUluSGV4WyBjdXJyZW50Q29sb3JJbmRleCBdO1xuICAgICAgICAgICAgY2hpbGRyZW5TdHIgKz0gYDxwYXRoIGQ9XCIkeyBkIH1cIiBmaWxsPVwiJHsgY29sb3JIZXggfVwiIC8+YDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50Q29sb3JJbmRleCA9IGNvbG9ySW5kZXg7XG4gICAgICAgICAgZCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IDIgKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHZlcnRpY2VzWyBpIF07XG4gICAgICAgICAgY29uc3QgeSA9IHZlcnRpY2VzWyBpICsgMSBdO1xuXG4gICAgICAgICAgZCArPSBpID09PSAwXG4gICAgICAgICAgICA/IGBNJHsgeCB9LCR7IHkgfWBcbiAgICAgICAgICAgIDogYEwkeyB4IH0sJHsgeSB9YDtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9ySGV4ID0gcGFsZXR0ZUluSGV4WyBjdXJyZW50Q29sb3JJbmRleCBdO1xuICAgIGNoaWxkcmVuU3RyICs9IGA8cGF0aCBkPVwiJHsgZCB9XCIgZmlsbD1cIiR7IGNvbG9ySGV4IH1cIiAvPmA7XG5cbiAgICBzdmcgKz0gYDxnIGlkPVwiZiR7IGlGcmFtZSB9XCI+JHsgY2hpbGRyZW5TdHIgfTwvZz5gO1xuICB9ICk7XG5cbiAgc3ZnICs9IGA8c3R5bGU+JHtzdHlsZX08L3N0eWxlPjwvc3ZnPmA7XG5cbiAgcmV0dXJuIHN2Zztcbn1cbiIsIi8qKlxuICogVGhlIG5haXZlIGltcGxlbWVudGF0aW9uIG9mIHNvLWNhbGxlZCBTbW9vdGhEYW1wLlxuICogUHJldHR5IG11Y2ggdGhlIHNhbWUgYXMge0BsaW5rIENEU30sIGJ1dCBpdCBoYXMgYSB3YXkgZWFzaWVyIHBhcmFtZXRlciB0byB0d2Vhaywge0BsaW5rIHNtb290aFRpbWV9LlxuICpcbiAqIFJlZjogR2FtZSBQcm9ncmFtbWluZyBHZW1zIDQsIENoYXB0ZXIgMS4xMFxuICpcbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL1VuaXR5LVRlY2hub2xvZ2llcy9Vbml0eUNzUmVmZXJlbmNlL2Jsb2IvYTJiZGZlOWIzYzRjZDQ0NzZmNDRiZjUyZjg0ODA2M2JmYWY3YjZiOS9SdW50aW1lL0V4cG9ydC9NYXRoL01hdGhmLmNzI0wzMDhcbiAqL1xuZXhwb3J0IGNsYXNzIFNtb290aERhbXAge1xuICBwdWJsaWMgc21vb3RoVGltZSA9IDEuMDtcbiAgcHVibGljIHZlbG9jaXR5ID0gMC4wO1xuICBwdWJsaWMgdmFsdWUgPSAwLjA7XG4gIHB1YmxpYyB0YXJnZXQgPSAwLjA7XG5cbiAgcHVibGljIHVwZGF0ZSggZGVsdGFUaW1lOiBudW1iZXIgKTogbnVtYmVyIHtcbiAgICBjb25zdCBvbWVnYSA9IDIuMCAvIHRoaXMuc21vb3RoVGltZTtcbiAgICBjb25zdCB4ID0gb21lZ2EgKiBkZWx0YVRpbWU7XG4gICAgY29uc3QgZXhwID0gMS4wIC8gKCAxLjAgKyB4ICsgMC40OCAqIHggKiB4ICsgMC4yMzUgKiB4ICogeCAqIHggKTtcbiAgICBjb25zdCBkZWx0YSA9IHRoaXMudmFsdWUgLSB0aGlzLnRhcmdldDtcbiAgICBjb25zdCB0ZW1wID0gKCB0aGlzLnZlbG9jaXR5ICsgb21lZ2EgKiBkZWx0YSApICogZGVsdGFUaW1lO1xuICAgIHRoaXMudmVsb2NpdHkgPSAoIHRoaXMudmVsb2NpdHkgLSBvbWVnYSAqIHRlbXAgKSAqIGV4cDtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy50YXJnZXQgKyAoIGRlbHRhICsgdGVtcCApICogZXhwO1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG59XG4iLCIvKipcbiAqIFVzZWZ1bCBmb3Igc3dhcCBidWZmZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFN3YXA8VD4ge1xuICBwdWJsaWMgaTogVDtcbiAgcHVibGljIG86IFQ7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBhOiBULCBiOiBUICkge1xuICAgIHRoaXMuaSA9IGE7XG4gICAgdGhpcy5vID0gYjtcbiAgfVxuXG4gIHB1YmxpYyBzd2FwKCk6IHZvaWQge1xuICAgIGNvbnN0IGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gdGhpcy5vO1xuICAgIHRoaXMubyA9IGk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEhpc3RvcnlNZWFuQ2FsY3VsYXRvciB9IGZyb20gJy4uL0hpc3RvcnlNZWFuQ2FsY3VsYXRvci9IaXN0b3J5TWVhbkNhbGN1bGF0b3InO1xuXG5leHBvcnQgY2xhc3MgVGFwVGVtcG8ge1xuICBwcml2YXRlIF9fYnBtID0gMC4wO1xuICBwcml2YXRlIF9fbGFzdFRhcCA9IDAuMDtcbiAgcHJpdmF0ZSBfX2xhc3RCZWF0ID0gMC4wO1xuICBwcml2YXRlIF9fbGFzdFRpbWUgPSAwLjA7XG4gIHByaXZhdGUgX19jYWxjOiBIaXN0b3J5TWVhbkNhbGN1bGF0b3IgPSBuZXcgSGlzdG9yeU1lYW5DYWxjdWxhdG9yKCAxNiApO1xuXG4gIHB1YmxpYyBnZXQgYmVhdER1cmF0aW9uKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIDYwLjAgLyB0aGlzLl9fYnBtO1xuICB9XG5cbiAgcHVibGljIGdldCBicG0oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fX2JwbTtcbiAgfVxuXG4gIHB1YmxpYyBzZXQgYnBtKCBicG06IG51bWJlciApIHtcbiAgICB0aGlzLl9fbGFzdEJlYXQgPSB0aGlzLmJlYXQ7XG4gICAgdGhpcy5fX2xhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5fX2JwbSA9IGJwbTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYmVhdCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9fbGFzdEJlYXQgKyAoIHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5fX2xhc3RUaW1lICkgKiAwLjAwMSAvIHRoaXMuYmVhdER1cmF0aW9uO1xuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuX19jYWxjLnJlc2V0KCk7XG4gIH1cblxuICBwdWJsaWMgbnVkZ2UoIGFtb3VudDogbnVtYmVyICk6IHZvaWQge1xuICAgIHRoaXMuX19sYXN0QmVhdCA9IHRoaXMuYmVhdCArIGFtb3VudDtcbiAgICB0aGlzLl9fbGFzdFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfVxuXG4gIHB1YmxpYyB0YXAoKTogdm9pZCB7XG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZGVsdGEgPSAoIG5vdyAtIHRoaXMuX19sYXN0VGFwICkgKiAwLjAwMTtcblxuICAgIGlmICggMi4wIDwgZGVsdGEgKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX19jYWxjLnB1c2goIGRlbHRhICk7XG4gICAgICB0aGlzLl9fYnBtID0gNjAuMCAvICggdGhpcy5fX2NhbGMubWVhbiApO1xuICAgIH1cblxuICAgIHRoaXMuX19sYXN0VGFwID0gbm93O1xuICAgIHRoaXMuX19sYXN0VGltZSA9IG5vdztcbiAgICB0aGlzLl9fbGFzdEJlYXQgPSAwLjA7XG4gIH1cbn1cbiIsImltcG9ydCB7IGFycmF5U2VyaWFsIH0gZnJvbSAnLi4vYXJyYXknO1xuXG4vKipcbiAqIFBhcnNlIGEgcG9seXBob25pYyB0aW55c2VxIGJ1ZmZlci5cbiAqXG4gKiBSZXR1cm5zIFsgdGltZSwgb2ZmVGltZSwgbm90ZSwgcmVzZXJ2ZWQsIHRpbWUsIG9mZlRpbWUsIG5vdGUsIHJlc2VydmVkLCAuLi4gXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGlueXNlcVBvbHlSZWFkZXIoXG4gIGJ1ZmZlcjogVWludDhBcnJheSxcbiAgb3B0aW9uczoge1xuICAgIHBvbHk/OiBudW1iZXIsXG4gICAgYmxvY2tTaXplPzogbnVtYmVyLFxuICAgIHNhbXBsZVJhdGU/OiBudW1iZXIsXG4gICAgc3RlcHNQZXJTZWNvbmQ/OiBudW1iZXIsXG4gIH0gPSB7fSxcbik6ICgpID0+IEZsb2F0MzJBcnJheVtdIHtcbiAgY29uc3QgcG9seSA9IG9wdGlvbnMucG9seSA/PyA4O1xuICBjb25zdCBibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSA/PyAxMjg7XG4gIGNvbnN0IHNhbXBsZVJhdGUgPSBvcHRpb25zLnNhbXBsZVJhdGUgPz8gNDgwMDA7XG4gIGNvbnN0IHN0ZXBzUGVyU2Vjb25kID0gb3B0aW9ucy5zdGVwc1BlclNlY29uZCA/PyAxLjA7XG5cbiAgbGV0IHNhbXBsZXMgPSAwO1xuICBsZXQgcG9zID0gMDtcbiAgbGV0IG5vdGU6IG51bWJlcjtcbiAgY29uc3Qgbm90ZXMgPSBhcnJheVNlcmlhbCggcG9seSApLmZpbGwoIC0xICk7XG4gIGNvbnN0IG5vdGVzVGltZSA9IGFycmF5U2VyaWFsKCBwb2x5ICkuZmlsbCggLUluZmluaXR5ICk7XG4gIGNvbnN0IG5vdGVzT2ZmVGltZSA9IGFycmF5U2VyaWFsKCBwb2x5ICkuZmlsbCggLUluZmluaXR5ICk7XG4gIGxldCBuZXh0U3RlcCA9IDA7XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCByZXQgPSBhcnJheVNlcmlhbCggcG9seSApLm1hcCggKCkgPT4gbmV3IEZsb2F0MzJBcnJheSggNCAqIGJsb2NrU2l6ZSApICk7XG5cbiAgICBhcnJheVNlcmlhbCggYmxvY2tTaXplICkubWFwKCAoIGlTYW1wbGUgKSA9PiB7XG4gICAgICBjb25zdCB0ID0gc2FtcGxlcyAvIHNhbXBsZVJhdGU7XG4gICAgICBjb25zdCBzID0gdCAqIHN0ZXBzUGVyU2Vjb25kO1xuXG4gICAgICBpZiAoIHMgPj0gbmV4dFN0ZXAgKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50Tm90ZSA9IGJ1ZmZlclsgcG9zIF07XG4gICAgICAgIGNvbnN0IGV2ZW50RGVsdGFTdGVwID0gYnVmZmVyWyBwb3MgKyAxIF07XG5cbiAgICAgICAgbm90ZSA9ICggKCBwb3MgPT09IDAgPyA2MCA6IG5vdGUgKSArIGV2ZW50Tm90ZSApICYgMTI3O1xuXG4gICAgICAgIC8vIGZpbmQgc2FtZSBub3RlXG4gICAgICAgIGxldCBpUG9seSA9IG5vdGVzLmluZGV4T2YoIG5vdGUgKTtcblxuICAgICAgICAvLyBmaW5kIGVhcmxpZXN0IG5vdGUgb2ZmXG4gICAgICAgIGxldCB0RWFybGllc3QgPSBJbmZpbml0eTtcblxuICAgICAgICBpZiAoIGlQb2x5ID09PSAtMSApIHtcbiAgICAgICAgICBub3Rlc1RpbWUubWFwKCAoIHRPbiwgalBvbHkgKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0T2ZmID0gbm90ZXNPZmZUaW1lWyBqUG9seSBdO1xuICAgICAgICAgICAgaWYgKCB0T24gPD0gdE9mZiApIHtcbiAgICAgICAgICAgICAgaWYgKCB0T2ZmIDwgdEVhcmxpZXN0ICkge1xuICAgICAgICAgICAgICAgIGlQb2x5ID0galBvbHk7XG4gICAgICAgICAgICAgICAgdEVhcmxpZXN0ID0gdE9mZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgZWFybGllc3Qgbm90ZSBvblxuICAgICAgICBpZiAoIGlQb2x5ID09PSAtMSApIHtcbiAgICAgICAgICBub3Rlc1RpbWUubWFwKCAoIHRPbiwgalBvbHkgKSA9PiB7XG4gICAgICAgICAgICBpZiAoIHRPbiA8IHRFYXJsaWVzdCApIHtcbiAgICAgICAgICAgICAgaVBvbHkgPSBqUG9seTtcbiAgICAgICAgICAgICAgdEVhcmxpZXN0ID0gdE9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vdGVzWyBpUG9seSBdID0gbm90ZTtcblxuICAgICAgICBpZiAoIGV2ZW50Tm90ZSAmIDEyOCApIHtcbiAgICAgICAgICBpZiAoIG5vdGVzT2ZmVGltZVsgaVBvbHkgXSA8IG5vdGVzVGltZVsgaVBvbHkgXSApIHtcbiAgICAgICAgICAgIG5vdGVzT2ZmVGltZVsgaVBvbHkgXSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICggbm90ZXNPZmZUaW1lWyBpUG9seSBdID49IG5vdGVzVGltZVsgaVBvbHkgXSApIHtcbiAgICAgICAgICAgIG5vdGVzVGltZVsgaVBvbHkgXSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV4dFN0ZXAgKz0gZXZlbnREZWx0YVN0ZXA7XG5cbiAgICAgICAgcG9zID0gKCBwb3MgKyAyICkgJSBidWZmZXIubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBzYW1wbGVzICsrO1xuXG4gICAgICBhcnJheVNlcmlhbCggcG9seSApLm1hcCggKCBpUG9seSApID0+IHtcbiAgICAgICAgY29uc3Qgbm90ZVRpbWUgPSBub3Rlc1RpbWVbIGlQb2x5IF07XG4gICAgICAgIGNvbnN0IG5vdGVPZmZUaW1lID0gbm90ZXNPZmZUaW1lWyBpUG9seSBdO1xuXG4gICAgICAgIHJldFsgaVBvbHkgXVsgNCAqIGlTYW1wbGUgKyAwIF0gPSB0IC0gbm90ZVRpbWU7IC8vIHRpbWVcbiAgICAgICAgcmV0WyBpUG9seSBdWyA0ICogaVNhbXBsZSArIDEgXSA9IG5vdGVPZmZUaW1lIDwgbm90ZVRpbWUgPyAwLjAgOiB0IC0gbm90ZU9mZlRpbWU7IC8vIG9mZlRpbWVcbiAgICAgICAgcmV0WyBpUG9seSBdWyA0ICogaVNhbXBsZSArIDIgXSA9IG5vdGVzWyBpUG9seSBdOyAvLyBub3RlXG4gICAgICAgIHJldFsgaVBvbHkgXVsgNCAqIGlTYW1wbGUgKyAzIF0gPSAwLjA7IC8vIHJlc2VydmVkXG4gICAgICB9ICk7XG4gICAgfSApO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn1cbiIsImltcG9ydCB7IGFycmF5U2VyaWFsIH0gZnJvbSAnLi4vYXJyYXknO1xuXG4vKipcbiAqIFBhcnNlIGEgdGlueXNlcSBidWZmZXIuXG4gKlxuICogUmV0dXJucyBbIHRpbWUsIG9mZlRpbWUsIG5vdGUsIHJlc2VydmVkLCB0aW1lLCBvZmZUaW1lLCBub3RlLCByZXNlcnZlZCwgLi4uIF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRpbnlzZXFSZWFkZXIoXG4gIGJ1ZmZlcjogVWludDhBcnJheSxcbiAgb3B0aW9uczoge1xuICAgIGJsb2NrU2l6ZT86IG51bWJlcixcbiAgICBzYW1wbGVSYXRlPzogbnVtYmVyLFxuICAgIHN0ZXBzUGVyU2Vjb25kPzogbnVtYmVyLFxuICB9ID0ge30sXG4pOiAoKSA9PiBGbG9hdDMyQXJyYXkge1xuICBjb25zdCBibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSA/PyAxMjg7XG4gIGNvbnN0IHNhbXBsZVJhdGUgPSBvcHRpb25zLnNhbXBsZVJhdGUgPz8gNDgwMDA7XG4gIGNvbnN0IHN0ZXBzUGVyU2Vjb25kID0gb3B0aW9ucy5zdGVwc1BlclNlY29uZCA/PyA5NjAuMDtcblxuICBsZXQgc2FtcGxlcyA9IDA7XG4gIGxldCBwb3MgPSAwO1xuICBsZXQgbm90ZTogbnVtYmVyO1xuICBsZXQgbm90ZVRpbWUgPSAtSW5maW5pdHk7XG4gIGxldCBub3RlT2ZmVGltZSA9IC1JbmZpbml0eTtcbiAgbGV0IG5leHRTdGVwID0gMDtcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KCBhcnJheVNlcmlhbCggYmxvY2tTaXplICkubWFwKCAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gc2FtcGxlcyAvIHNhbXBsZVJhdGU7XG4gICAgICBjb25zdCBzID0gdCAqIHN0ZXBzUGVyU2Vjb25kO1xuXG4gICAgICBpZiAoIHMgPj0gbmV4dFN0ZXAgKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50Tm90ZSA9IGJ1ZmZlclsgcG9zIF07XG4gICAgICAgIGNvbnN0IGV2ZW50RGVsdGFTdGVwID0gYnVmZmVyWyBwb3MgKyAxIF07XG5cbiAgICAgICAgbm90ZSA9ICggKCBwb3MgPT09IDAgPyA2MCA6IG5vdGUgKSArIGV2ZW50Tm90ZSApICYgMTI3O1xuICAgICAgICBpZiAoIGV2ZW50Tm90ZSAmIDEyOCApIHtcbiAgICAgICAgICBpZiAoIG5vdGVPZmZUaW1lIDwgbm90ZVRpbWUgKSB7XG4gICAgICAgICAgICBub3RlT2ZmVGltZSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICggbm90ZU9mZlRpbWUgPj0gbm90ZVRpbWUgKSB7XG4gICAgICAgICAgICBub3RlVGltZSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV4dFN0ZXAgKz0gZXZlbnREZWx0YVN0ZXA7XG5cbiAgICAgICAgcG9zID0gKCBwb3MgKyAyICkgJSBidWZmZXIubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBzYW1wbGVzICsrO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICB0IC0gbm90ZVRpbWUsIC8vIHRpbWVcbiAgICAgICAgbm90ZU9mZlRpbWUgPCBub3RlVGltZSA/IDAuMCA6IHQgLSBub3RlT2ZmVGltZSwgLy8gb2ZmVGltZVxuICAgICAgICBub3RlLCAvLyBub3RlXG4gICAgICAgIDAuMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIF07XG4gICAgfSApLmZsYXQoKSApO1xuICB9O1xufVxuIiwiaW1wb3J0IHsgTWlkaVBhcnNlUmVzdWx0IH0gZnJvbSAnLi4vbWlkaSc7XG5pbXBvcnQgeyBhcnJheVNlcmlhbCB9IGZyb20gJy4uL2FycmF5JztcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwYXJzZWQgbWlkaSByZXN1bHQgdG8gYSB0aW55c2VxIGJpbmFyeS5cbiAqXG4gKiBTZWU6IHtAbGluayBtaWRpUGFyc2V9XG4gKlxuICogQHBhcmFtIG1pZGkgVGhlIHBhcnNlZCBtaWRpIHJlc3VsdFxuICogQHBhcmFtIHRyYWNrIFRoZSBpbmRleCBvZiB0aGUgbWlkaSB0cmFjayB5b3Ugd2FudCB0byBjb252ZXJ0XG4gKiBAcGFyYW0gdGlja011bHRpcGxpZXIgTXVsdGlwbHkgdGhpcyB2YWx1ZSB0byB0aWNrXG4gKiBAcmV0dXJucyBBIHRpbnlzZXEgYmluYXJ5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW55c2VxRnJvbU1pZGlQYXJzZVJlc3VsdChcbiAgbWlkaTogTWlkaVBhcnNlUmVzdWx0LFxuICB7IHRyYWNrLCB0aWNrTXVsdGlwbGllciB9OiB7XG4gICAgdHJhY2s/OiBudW1iZXIsXG4gICAgdGlja011bHRpcGxpZXI/OiBudW1iZXIsXG4gIH0gPSB7fSxcbik6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBkYXRhOiBudW1iZXJbXSA9IFtdO1xuICBsZXQgbGFzdE5vdGUgPSA2MDtcbiAgbGV0IGRlbHRhID0gMDtcblxuICBjb25zdCB0cmFja0V2ZW50cyA9IG1pZGlbIDEgXVsgdHJhY2sgPz8gMC4wIF07XG5cbiAgLy8gWyBkZWx0YSwgbWlkaSBldmVudCwgbm90ZSwgdmVsIF1bXSAtPiBbIG9ub2ZmICgwIG9yIDEyOCkgKyBkZWx0YU5vdGUsIGRlbHRhLCAuLi4gXVxuICAvLyBbIFsgNCwgMTQ0LCA2MCwgMTAwIF0sIFsgNCwgMTI4LCA2MCwgMTAwIF0gXSAtPiBbIDEyOCwgNCwgMCwgNCwgMTI4LCAwIF1cblxuICBhcnJheVNlcmlhbCggdHJhY2tFdmVudHMubGVuZ3RoICsgMSApLm1hcCggKCBpICkgPT4ge1xuICAgIGRlbHRhICs9ICggdHJhY2tFdmVudHNbIGkgXT8uWyAwIF0gPz8gMCApICogKCB0aWNrTXVsdGlwbGllciA/PyAxLjAgKTtcblxuICAgIGlmICggZGVsdGEgPT09IDAgJiYgaSA9PT0gMCApIHsgcmV0dXJuOyB9IC8vIGlnbm9yZSBpZiBpdCdzIHRoZSBmaXJzdCBldmVudCBhbmQgZGVsdGEgaXMgMFxuXG4gICAgY29uc3QgZXZNc2cgPSB0cmFja0V2ZW50c1sgaSAtIDEgXT8uWyAxIF0gPz8gMTI4O1xuICAgIGNvbnN0IGV2Tm90ZSA9IHRyYWNrRXZlbnRzWyBpIC0gMSBdPy5bIDIgXSA/PyA2MDtcblxuICAgIGlmICggZXZNc2cgPj0gMTYwICkgeyByZXR1cm47IH0gLy8gaWdub3JlIGlmIHRoZSBtc2cgaXMgbm90IGEgbm90ZSBldmVudFxuXG4gICAgY29uc3Qgbm90ZURlbHRhID0gKCBldk5vdGUgLSBsYXN0Tm90ZSArIDEyOCApICYgMTI3O1xuICAgIGxhc3ROb3RlID0gZXZOb3RlO1xuICAgIGNvbnN0IG9ub2ZmID0gZXZNc2cgPCAxNDQgPyAxMjggOiAwOyAvLyAwIGlmIG9uICgxNDQgLSAxNTkpLCAxMjggaWYgb2ZmICgxMjggLSAxNDMpXG5cbiAgICAvLyBwcm9iYWJseSAyNDAgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiAyNTYgc2luY2UgdGhlIGRpdmlzaW9uIGluIG1vc3Qgb2YgbWlkaSBmaWxlcyBhcmUgNDgwIG9yIDk2MFxuICAgIGxldCBkZWx0YUNvbnN1bWUgPSBNYXRoLmZsb29yKCBNYXRoLm1pbiggZGVsdGEsIDI0MCApICk7XG4gICAgZGF0YS5wdXNoKCBub3RlRGVsdGEgKyBvbm9mZiwgZGVsdGFDb25zdW1lICk7XG4gICAgZGVsdGEgLT0gZGVsdGFDb25zdW1lO1xuXG4gICAgd2hpbGUgKCBkZWx0YSA+PSAxICkge1xuICAgICAgZGVsdGFDb25zdW1lID0gTWF0aC5mbG9vciggTWF0aC5taW4oIGRlbHRhLCAyNDAgKSApO1xuICAgICAgZGF0YS5wdXNoKCBvbm9mZiwgZGVsdGFDb25zdW1lICk7XG4gICAgICBkZWx0YSAtPSBkZWx0YUNvbnN1bWU7XG4gICAgfVxuICB9ICk7XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCBkYXRhICk7XG59XG4iLCJleHBvcnQgY2xhc3MgWG9yc2hpZnQge1xuICBwdWJsaWMgc2VlZDogbnVtYmVyO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvciggc2VlZD86IG51bWJlciApIHtcbiAgICB0aGlzLnNlZWQgPSBzZWVkIHx8IDE7XG4gIH1cblxuICBwdWJsaWMgZ2VuKCBzZWVkPzogbnVtYmVyICk6IG51bWJlciB7XG4gICAgaWYgKCBzZWVkICkge1xuICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG5cbiAgICB0aGlzLnNlZWQgPSB0aGlzLnNlZWQgXiAoIHRoaXMuc2VlZCA8PCAxMyApO1xuICAgIHRoaXMuc2VlZCA9IHRoaXMuc2VlZCBeICggdGhpcy5zZWVkID4+PiAxNyApO1xuICAgIHRoaXMuc2VlZCA9IHRoaXMuc2VlZCBeICggdGhpcy5zZWVkIDw8IDUgKTtcbiAgICByZXR1cm4gdGhpcy5zZWVkIC8gTWF0aC5wb3coIDIsIDMyICkgKyAwLjU7XG4gIH1cblxuICBwdWJsaWMgc2V0KCBzZWVkPzogbnVtYmVyICk6IHZvaWQge1xuICAgIHRoaXMuc2VlZCA9IHNlZWQgfHwgdGhpcy5zZWVkIHx8IDE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWG9yc2hpZnQ7XG4iLCJpbXBvcnQgeyBsaW5lYXJzdGVwIH0gZnJvbSAnLi4vbWF0aC91dGlscyc7XG5cbi8qKlxuICogaHR0cHM6Ly90d2l0dGVyLmNvbS95dWdvcFxuICpcbiAqIEBwYXJhbSB0ZXh0IFRoZSBpbnB1dCB0ZXh0XG4gKiBAcGFyYW0gcGhhc2UgVGhlIHZhbHVlIGJldHdlZW4gMC4wIGFuZCAxLjBcbiAqIEBwYXJhbSByYW5kb21SYXRpbyBUaGUgbmVyZCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0WXVnb3BUZXh0KCB0ZXh0OiBzdHJpbmcsIHBoYXNlOiBudW1iZXIsIHJhbmRvbVJhdGlvID0gMC41ICk6IHN0cmluZyB7XG4gIGlmICggcGhhc2UgPj0gMS4wICkgeyByZXR1cm4gdGV4dDsgfVxuICBpZiAoIHBoYXNlIDwgMC4wICkgeyByZXR1cm4gJyc7IH1cblxuICAvKlxuICAgKiAtLS0tLS09PT09PVxuICAgKiAuLS0tLS0tPT09PVxuICAgKiAuLi0tLS0tLT09PVxuICAgKiAuLi4tLS0tLS09PVxuICAgKiAuLi4uLS0tLS0tPVxuICAgKiBeICAgICBeICAgXlxuICAgKiB8ICAgICB8ICAgfFxuICAgKiB8ICAgICB8ICAgcGhhc2UgaXMgMS4wXG4gICAqIHwgICAgIHBoYXNlIGlzIHJhbmRvbVJhdGlvXG4gICAqIHBoYXNlIGlzIDAuMFxuICAgKi9cblxuICBjb25zdCBkaXNwbGF5VHdlZW4gPSBsaW5lYXJzdGVwKCAwLjAsIDEuMCAtIHJhbmRvbVJhdGlvLCBwaGFzZSApO1xuICBjb25zdCBmaXhUd2VlbiA9IGxpbmVhcnN0ZXAoIHJhbmRvbVJhdGlvLCAxLjAsIHBoYXNlICk7XG5cbiAgY29uc3QgZGlzcGxheUxlbmd0aCA9IDEuMCArIE1hdGguZmxvb3IoIGRpc3BsYXlUd2VlbiAqICggdGV4dC5sZW5ndGggLSAxICkgKTtcbiAgY29uc3QgZml4TGVuZ3RoID0gcGhhc2UgPCByYW5kb21SYXRpbyA/IDAgOiAxLjAgKyBNYXRoLmZsb29yKCBmaXhUd2VlbiAqICggdGV4dC5sZW5ndGggLSAxICkgKTtcbiAgY29uc3QgcmFuZG9tTGVuZ3RoID0gZGlzcGxheUxlbmd0aCAtIGZpeExlbmd0aDtcblxuICBjb25zdCByYW5kb21TdHIgPSBbIC4uLkFycmF5KCByYW5kb21MZW5ndGggKSBdXG4gICAgLm1hcCggKCkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSggMzMgKyBNYXRoLmZsb29yKCA5MyAqIE1hdGgucmFuZG9tKCkgKSApIClcbiAgICAuam9pbiggJycgKTtcblxuICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoIDAsIGZpeExlbmd0aCApICsgcmFuZG9tU3RyO1xufVxuIiwiZXhwb3J0IGNsYXNzIEJpbmFyeUhlYXA8VD4ge1xuICBwdWJsaWMgcmVhZG9ubHkgYXJyYXk6IFRbXTtcbiAgcHVibGljIHJlYWRvbmx5IGVsZW1lbnRJbmRleE1hcDogTWFwPFQsIG51bWJlcj47XG4gIHB1YmxpYyBjb21wYXJhdG9yOiAoIGE6IFQsIGI6IFQgKSA9PiBudW1iZXI7XG5cbiAgcHVibGljIHN0YXRpYyBkZWZhdWx0Q29tcGFyYXRvciggYTogYW55LCBiOiBhbnkgKTogbnVtYmVyIHtcbiAgICBjb25zdCBhU3RyID0gYCR7IGEgfWA7XG4gICAgY29uc3QgYlN0ciA9IGAkeyBiIH1gO1xuXG4gICAgaWYgKCBhU3RyID4gYlN0ciApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoIGFTdHIgPCBiU3RyICkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGxlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggPT09IDA7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHJvb3QoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbIDAgXTtcbiAgfVxuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggaW5pdD86IFRbXSwgY29tcGFyYXRvcj86ICggYTogVCwgYjogVCApID0+IG51bWJlciApIHtcbiAgICB0aGlzLmFycmF5ID0gW107XG4gICAgdGhpcy5lbGVtZW50SW5kZXhNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvciA/PyBCaW5hcnlIZWFwLmRlZmF1bHRDb21wYXJhdG9yO1xuXG4gICAgaWYgKCBpbml0ICE9IG51bGwgKSB7XG4gICAgICBmb3IgKCBjb25zdCBlbCBvZiBpbml0ICkge1xuICAgICAgICB0aGlzLnB1c2goIGVsICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHB1c2goIC4uLmVsZW1lbnRzOiBUW10gKTogdm9pZCB7XG4gICAgZWxlbWVudHMubWFwKCAoIGVsICkgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMubGVuZ3RoO1xuICAgICAgdGhpcy5hcnJheS5wdXNoKCBlbCApO1xuICAgICAgdGhpcy5lbGVtZW50SW5kZXhNYXAuc2V0KCBlbCwgaSApO1xuICAgICAgdGhpcy5fX3VwKCBpLCBlbCApO1xuICAgIH0gKTtcbiAgfVxuXG4gIHB1YmxpYyBwb3AoKTogVCB8IG51bGwge1xuICAgIGlmICggdGhpcy5pc0VtcHR5ICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZWwgPSB0aGlzLmFycmF5WyAwIF07XG4gICAgdGhpcy5lbGVtZW50SW5kZXhNYXAuZGVsZXRlKCBlbCApO1xuXG4gICAgaWYgKCB0aGlzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgIHRoaXMuYXJyYXkuc3BsaWNlKCAwICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlcCA9IHRoaXMuYXJyYXkucG9wKCk7XG4gICAgICB0aGlzLl9fZG93biggMCwgcmVwISApO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIHB1YmxpYyBkZWxldGUoIGk6IG51bWJlciApOiBib29sZWFuIHtcbiAgICB0aGlzLmVsZW1lbnRJbmRleE1hcC5kZWxldGUoIHRoaXMuYXJyYXlbIGkgXSApO1xuXG4gICAgY29uc3QgcmVwID0gdGhpcy5hcnJheS5wb3AoKTtcbiAgICBpZiAoIHJlcCAhPSBudWxsICkge1xuICAgICAgaSA9IHRoaXMuX191cCggaSwgcmVwICk7XG4gICAgICBpID0gdGhpcy5fX2Rvd24oIGksIHJlcCApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHJlcGxhY2UoIGk6IG51bWJlciwgcmVwOiBUICk6IG51bWJlciB8IG51bGwge1xuICAgIGlmICggaSAhPSBudWxsICkge1xuICAgICAgdGhpcy5lbGVtZW50SW5kZXhNYXAuZGVsZXRlKCB0aGlzLmFycmF5WyBpIF0gKTtcblxuICAgICAgaSA9IHRoaXMuX191cCggaSwgcmVwICk7XG4gICAgICBpID0gdGhpcy5fX2Rvd24oIGksIHJlcCApO1xuICAgIH1cblxuICAgIHJldHVybiBpID8/IG51bGw7XG4gIH1cblxuICBwcml2YXRlIF9fdXAoIGk6IG51bWJlciwgZWw6IFQgKTogbnVtYmVyIHtcbiAgICBsZXQgaWMgPSBpO1xuXG4gICAgd2hpbGUgKCBpYyAhPT0gMCApIHtcbiAgICAgIGNvbnN0IGlwID0gKCBpYyAtIDEgKSA+PiAxO1xuXG4gICAgICBjb25zdCBwID0gdGhpcy5hcnJheVsgaXAgXTtcbiAgICAgIGlmICggdGhpcy5jb21wYXJhdG9yKCBlbCwgcCApIDwgMCApIHtcbiAgICAgICAgdGhpcy5hcnJheVsgaWMgXSA9IHA7XG4gICAgICAgIHRoaXMuZWxlbWVudEluZGV4TWFwLnNldCggcCwgaWMgKTtcbiAgICAgICAgaWMgPSBpcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYXJyYXlbIGljIF0gPSBlbDtcbiAgICB0aGlzLmVsZW1lbnRJbmRleE1hcC5zZXQoIGVsLCBpYyApO1xuICAgIHJldHVybiBpYztcbiAgfVxuXG4gIHByaXZhdGUgX19kb3duKCBpOiBudW1iZXIsIGVsOiBUICk6IG51bWJlciB7XG4gICAgbGV0IGlwID0gaTtcblxuICAgIHdoaWxlICggKCBpcCA8PCAxICkgKyAxIDwgdGhpcy5sZW5ndGggKSB7XG4gICAgICBjb25zdCBpYzEgPSAoIGlwIDw8IDEgKSArIDE7XG4gICAgICBjb25zdCBpYzIgPSAoIGlwIDw8IDEgKSArIDI7XG5cbiAgICAgIGlmICggaWMyIDwgdGhpcy5sZW5ndGggKSB7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5hcnJheVsgaWMxIF07XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5hcnJheVsgaWMyIF07XG5cbiAgICAgICAgY29uc3QgcGlja0xlZnQgPSB0aGlzLmNvbXBhcmF0b3IoIGMxLCBjMiApIDwgMDtcbiAgICAgICAgY29uc3QgYyA9IHBpY2tMZWZ0ID8gYzEgOiBjMjtcbiAgICAgICAgY29uc3QgaWMgPSBwaWNrTGVmdCA/IGljMSA6IGljMjtcblxuICAgICAgICBpZiAoIHRoaXMuY29tcGFyYXRvciggYywgZWwgKSA8IDAgKSB7XG4gICAgICAgICAgdGhpcy5hcnJheVsgaXAgXSA9IGM7XG4gICAgICAgICAgdGhpcy5lbGVtZW50SW5kZXhNYXAuc2V0KCBjLCBpcCApO1xuICAgICAgICAgIGlwID0gaWM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIHRoaXMuY29tcGFyYXRvciggdGhpcy5hcnJheVsgaWMxIF0sIGVsICkgPCAwICkge1xuICAgICAgICB0aGlzLmFycmF5WyBpcCBdID0gdGhpcy5hcnJheVsgaWMxIF07XG4gICAgICAgIHRoaXMuZWxlbWVudEluZGV4TWFwLnNldCggdGhpcy5hcnJheVsgaXAgXSwgaXAgKTtcbiAgICAgICAgaXAgPSBpYzE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFycmF5WyBpcCBdID0gZWw7XG4gICAgdGhpcy5lbGVtZW50SW5kZXhNYXAuc2V0KCBlbCwgaXAgKTtcbiAgICByZXR1cm4gaXA7XG4gIH1cbn1cbiIsIi8qKlxuICogQSBiYXJlIGZ1bmN0aW9uIHRvIG5vdGlmeSBvYnNlcnZlcnMuXG4gKiBUaGUgaW5jcmVkaWJseSBjaGVhcCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgb2JzZXJ2ZXIgcGF0dGVybi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IG9ic2VydmVycyA9IG5ldyBTZXQ8KCB0ZXh0OiBzdHJpbmcgKSA9PiB2b2lkPigpO1xuICpcbiAqIG9ic2VydmVycy5hZGQoICggdGV4dCApID0+IGNvbnNvbGUubG9nKCB0ZXh0ICkgKTtcbiAqIG9ic2VydmVycy5hZGQoICggdGV4dCApID0+IGFsZXJ0KCB0ZXh0ICkgKTtcbiAqXG4gKiBub3RpZnlPYnNlcnZlcnMoIG9ic2VydmVycywgJ3dlbmlzJyApO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG9ic2VydmVycyBUaGUgaXRlcmF0b3Igb2Ygb2JzZXJ2ZXJzXG4gKiBAcGFyYW0gcGFyYW0gVGhlIHBhcmFtIHlvdSB3YW50IHRvIGdpdmUgdG8gb2JzZXJ2ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RpZnlPYnNlcnZlcnMoIG9ic2VydmVyczogSXRlcmFibGU8KCkgPT4gdm9pZD4gKTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBub3RpZnlPYnNlcnZlcnM8VD4oIG9ic2VydmVyczogSXRlcmFibGU8KCBhcmc6IFQgKSA9PiB2b2lkPiwgcGFyYW06IFQgKTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBub3RpZnlPYnNlcnZlcnMoIG9ic2VydmVyczogSXRlcmFibGU8KCBhcmc6IGFueSApID0+IHZvaWQ+LCBwYXJhbT86IGFueSApOiB2b2lkIHtcbiAgZm9yICggY29uc3Qgb2JzZXJ2ZXIgb2Ygb2JzZXJ2ZXJzICkge1xuICAgIG9ic2VydmVyKCBwYXJhbSApO1xuICB9XG59XG4iLCIvLyBAdHMtbm9jaGVja1xuXG5pbXBvcnQge21vZH0gZnJvbSAnQDBiNXZyL2V4cGVyaW1lbnRhbCdcbi8vIGltcG9ydCB7bm9pfSBmcm9tIFwiQDBiNXZyL2V4cGVyaW1lbnRhbFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBmcmFjdChhOiBudW1iZXIpIHtcblx0cmV0dXJuIG1vZChhLCAxKVxufVxuXG5leHBvcnQgY29uc3QgdGF1OiBudW1iZXIgPSBNYXRoLlBJICogMi4wXG5leHBvcnQgY29uc3QgcGk6IG51bWJlciA9IE1hdGguUElcbmV4cG9ydCBjb25zdCBoYWxmUGk6IG51bWJlciA9IE1hdGguUEkgLyAyXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXgoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuXHRyZXR1cm4gTWF0aC5tYXgoYSwgYilcbn1cbmV4cG9ydCBmdW5jdGlvbiBtaW4oYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuXHRyZXR1cm4gTWF0aC5taW4oYSwgYilcbn1cbmV4cG9ydCBmdW5jdGlvbiBtaXgoYTogbnVtYmVyLCBiOiBudW1iZXIsIGY6IG51bWJlcik6IG51bWJlciB7XG5cdHJldHVybiBhICogKDEuMCAtIGYpICsgYiAqIGZcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZyhhOiBudW1iZXIpOiBudW1iZXIge1xuXHRyZXR1cm4gTWF0aC5sb2coYSlcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb2cyKGE6IG51bWJlcik6IG51bWJlciB7XG5cdHJldHVybiBNYXRoLmxvZzIoYSlcbn1cblxuZXhwb3J0IGNsYXNzIEhhc2gge1xuXHRzZWVkID0gMFxuXHRjb25zdHJ1Y3RvcihzZWVkID0gMTI1MTI1NCkge1xuXHRcdEhhc2guc2VlZCA9IHNlZWRcblx0fVxuXHRzdGF0aWMgaDExKHA6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cCA9IGZyYWN0KHAgKiAwLjEwMzEpXG5cdFx0cCAqPSBwICsgMzMuMzNcblx0XHRwICo9IHAgKyBwXG5cdFx0cmV0dXJuIGZyYWN0KHApXG5cdH1cblx0aDExKHA6IG51bWJlcikge1xuXHRcdHJldHVybiB0aGlzLnNlZWRlZCgxMjUxMjQgKyBwICogMTI1MClcblx0fVxuXHRzZWVkZWQoYSkge1xuXHRcdHZhciB0ID0gKGEgKz0gMHg2ZDJiNzlmNSlcblx0XHR0ID0gTWF0aC5pbXVsKHQgXiAodCA+Pj4gMTUpLCB0IHwgMSlcblx0XHR0IF49IHQgKyBNYXRoLmltdWwodCBeICh0ID4+PiA3KSwgdCB8IDYxKVxuXHRcdHJldHVybiAoKHQgXiAodCA+Pj4gMTQpKSA+Pj4gMCkgLyA0Mjk0OTY3Mjk2XG5cdH1cblxuXHR2YWx1ZU5vaXNlKGE6IG51bWJlcik6IG51bWJlciB7XG5cdFx0Y29uc3QgZmxhID0gZmxvb3IoYSlcblx0XHRjb25zdCBjZWlsYSA9IGZsYSArIDFcblx0XHRjb25zdCByY3VyciA9IEhhc2guaDExKGZsYSlcblx0XHRjb25zdCBybmV4dCA9IEhhc2guaDExKGNlaWxhKVxuXHRcdGxldCBmciA9IGZyYWN0KGEpXG5cdFx0ZnIgPSBzbW9vdGhzdGVwKDAsIDEsIGZyKVxuXHRcdHJldHVybiBsZXJwKHJjdXJyLCBybmV4dCwgZnIpXG5cdH1cblxuXHR2YWx1ZU5vaXNlU21vb3RoKGE6IG51bWJlciwgc21vb3RobmVzczogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRjb25zdCBmbGEgPSBmbG9vcihhKVxuXHRcdGNvbnN0IGNlaWxhID0gZmxhICsgMVxuXHRcdGNvbnN0IHJjdXJyID0gdGhpcy5oMTEoZmxhKVxuXHRcdGNvbnN0IHJuZXh0ID0gdGhpcy5oMTEoY2VpbGEpXG5cdFx0bGV0IGZyID0gZnJhY3QoYSlcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNtb290aG5lc3M7IGkrKykge1xuXHRcdFx0aWYgKGZsb29yKGkpID09PSBmbG9vcihzbW9vdGhuZXNzKSkge1xuXHRcdFx0XHRmciA9IGxlcnAoZnIsIHNtb290aHN0ZXAoMCwgMSwgZnIpLCBzbW9vdGhuZXNzIC0gaSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZyID0gc21vb3Roc3RlcCgwLCAxLCBmcilcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGxlcnAocmN1cnIsIHJuZXh0LCBmcilcblx0fVxufVxuXG4vLyBleHBvcnQgY29uc3QgbmtpbmdTaW4gPSAoeDogbnVtYmVyKSA9PiB7XG4vLyAgIGNvbnN0IHNxID0gKHg6IG51bWJlcikgPT4geCAqIHg7XG4vLyAgIGNvbnN0IHN0ZXAgPSAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IHtcbi8vICAgICBpZiAoYSA8IGIpIHJldHVybiAwO1xuLy8gICAgIGVsc2UgcmV0dXJuIDE7XG4vLyAgIH07XG4vLyAgICB2YWwgLSBNYXRoLmZsb29yKHZhbClcbi8vICAgcmV0dXJuIChzcSgoKHggJSBwaSkgKiAyKSAvIHBpIC0gMSkgLSAxKSAqICgxIC0gMiAqIHN0ZXAoeCAlICgyICogcGkpLCBwaSkpO1xuLy8gfTtcblxuY29uc3QgcjJwaSA9IDAuNjM2NjE5NzcyMzZcblxuZXhwb3J0IGNvbnN0IG5raW5nU2luID0gKHg6IG51bWJlcikgPT4ge1xuXHRjb25zdCB4dGF1ID0geCAqIHRhdVxuXHRpZiAoeHRhdSAtIE1hdGguZmxvb3IoeHRhdSkgPiBwaSkge1xuXHRcdGNvbnN0IG1vZCA9ICh4IC0gcGkpICogcjJwaSAtIDFcblx0XHRyZXR1cm4gbW9kICogbW9kIC0gMVxuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IG1vZCA9IHggKiByMnBpIC0gMVxuXHRcdHJldHVybiAxIC0gbW9kICogbW9kXG5cdH1cbn1cblxuY29uc3Qgc21vb3Roc2luID0gKHg6IG51bWJlcikgPT4ge1xuXHRjb25zdCBiID0geCAqIHggKiAoMy4wIC0gMi4wICogeClcblx0Y29uc3QgYSA9IHggKiAoMyAtIDEuMCAqIHgpXG5cdHJldHVybiBhICsgKGIgLSBhKSAqIGJcbn1cbmNvbnN0IG9uZU92ZXJIYWxmUGkgPSAxIC8gKHBpIC8gMilcbmV4cG9ydCBjb25zdCBmYXN0U2luID0gKHg6IG51bWJlcikgPT4ge1xuXHR4ICo9IG9uZU92ZXJIYWxmUGlcblxuXHRjb25zdCBpZCA9IE1hdGguZmxvb3IoeClcblx0eCA9IHggJSAxXG5cblx0bGV0IHNpZGUgPSAxXG5cdGlmICgoaWQgLSAyKSAlIDQgPCAyKSB7XG5cdFx0c2lkZSA9IC0xXG5cdH1cblx0aWYgKGlkICUgMiA9PT0gMSkge1xuXHRcdHggPSAxIC0geFxuXHR9XG5cdGxldCBhcHByb3ggPSBzbW9vdGhzaW4oeClcblx0YXBwcm94ICo9IHNpZGVcblx0cmV0dXJuIGFwcHJveFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpemUoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuXHRyZXR1cm4gTWF0aC5mbG9vcihhIC8gYikgKiBiXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkbW9kKGE6IG51bWJlciwgYjogbnVtYmVyLCBjOiBudW1iZXI/ID0gMikge1xuXHRyZXR1cm4gbWF4KG1vZChhLCBiKSAtIGIgKyAyLCAwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWJzKGE6IG51bWJlcik6IG51bWJlciB7XG5cdHJldHVybiBNYXRoLmFicyhhKVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNpZ24oYTogbnVtYmVyKTogbnVtYmVyIHtcblx0cmV0dXJuIGEgPCAwID8gLTEgOiAxXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmkoYTogbnVtYmVyKTogbnVtYmVyIHtcblx0Y29uc3QgZnIgPSBhIC0gTWF0aC5mbG9vcihhKVxuXHRyZXR1cm4gYWJzKGZyIC0gMC41KSAqIDIgLSAxXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW4oYTogbnVtYmVyKTogbnVtYmVyIHtcblx0Ly8gcmV0dXJuIGZhc3RTaW4oYSlcblx0Ly8gIHJldHVybiBua2luZ1NpbihhKVxuXHRyZXR1cm4gTWF0aC5zaW4oYSlcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb3MoYTogbnVtYmVyKTogbnVtYmVyIHtcblx0Ly8gcmV0dXJuIG5raW5nU2luKGEgKyBoYWxmUGkpXG5cdHJldHVybiBNYXRoLmNvcyhhKVxufVxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKGE6IG51bWJlcik6IG51bWJlciB7XG5cdHJldHVybiBNYXRoLmZsb29yKGEpXG59XG5leHBvcnQgZnVuY3Rpb24gcG93KGE6IG51bWJlciwgYjogbnVtYmVyKSB7XG5cdHJldHVybiBNYXRoLnBvdyhhLCBiKVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNxcnQoYTogbnVtYmVyKSB7XG5cdHJldHVybiBNYXRoLnNxcnQoYSlcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwKGE6IG51bWJlciwgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKSB7XG5cdGNvbnN0IHJhbmdlID0gdG8gLSBmcm9tXG5cdGEgLT0gZnJvbVxuXHRhID0gbW9kKGEsIHJhbmdlKVxuXHRyZXR1cm4gZnJvbSArIGFcbn1cblxuZXhwb3J0IGNvbnN0IGxlcnAgPSAoYSwgYiwgeCkgPT4gYSArIChiIC0gYSkgKiB4XG5leHBvcnQgY29uc3QgY2xhbXAgPSAoeCwgbCwgaCkgPT4gTWF0aC5taW4oTWF0aC5tYXgoeCwgbCksIGgpXG5leHBvcnQgY29uc3Qgc2F0dXJhdGUgPSAoeCkgPT4gTWF0aC5taW4oTWF0aC5tYXgoeCwgMC4wKSwgMS4wKVxuZXhwb3J0IGNvbnN0IGxpbmVhcnN0ZXAgPSAoYSwgYiwgeCkgPT4gc2F0dXJhdGUoKHggLSBhKSAvIChiIC0gYSkpXG5leHBvcnQgY29uc3Qgc21vb3Roc3RlcCA9IChhLCBiLCB4KSA9PiB7XG5cdGNvbnN0IHQgPSBsaW5lYXJzdGVwKGEsIGIsIHgpXG5cdHJldHVybiB0ICogdCAqICgzLjAgLSAyLjAgKiB0KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZCgpIHtcblx0cmV0dXJuIE1hdGgucmFuZG9tKClcbn1cblxuLy8gU29tZSBlYXNpbmcgZnVuY3Rpb25zXG5jbGFzcyBFYXNlIHtcblx0Ly8gbm8gZWFzaW5nLCBubyBhY2NlbGVyYXRpb25cblx0c3RhdGljIGxpbmVhcih0OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdDsodCkgPT4gdFxuXHR9XG5cdC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcblx0c3RhdGljIGVhc2VJblF1YWQodDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdCAqIHRcblx0fVxuXHQvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuXHRzdGF0aWMgZWFzZU91dFF1YWQodDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdCAqICgyIC0gdClcblx0fVxuXHQvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cblx0c3RhdGljIGVhc2VJbk91dFF1YWQodDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdCA8IDAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0XG5cdH1cblx0Ly8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuXHRzdGF0aWMgZWFzZUluQ3ViaWModDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0XG5cdH1cblx0Ly8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcblx0c3RhdGljIGVhc2VPdXRDdWJpYyh0OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiAtLXQgKiB0ICogdCArIDFcblx0fVxuXHQvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cblx0c3RhdGljIGVhc2VJbk91dEN1YmljKHQ6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHQgPCAwLjUgPyA0ICogdCAqIHQgKiB0IDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxXG5cdH1cblx0Ly8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuXHRzdGF0aWMgZWFzZUluUXVhcnQodDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdFxuXHR9XG5cdC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG5cdHN0YXRpYyBlYXNlT3V0UXVhcnQodDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gMSAtIC0tdCAqIHQgKiB0ICogdFxuXHR9XG5cdC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuXHRzdGF0aWMgZWFzZUluT3V0UXVhcnQodDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdCA8IDAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAtLXQgKiB0ICogdCAqIHRcblx0fVxuXHQvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG5cdHN0YXRpYyBlYXNlSW5RdWludCh0OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0ICogdFxuXHR9XG5cdC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG5cdHN0YXRpYyBlYXNlT3V0UXVpbnQodDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gMSArIC0tdCAqIHQgKiB0ICogdCAqIHRcblx0fVxuXHQvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cblx0c3RhdGljIGVhc2VJbk91dFF1aW50KHQ6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHQgPCAwLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICogLS10ICogdCAqIHQgKiB0ICogdFxuXHR9XG5cdHN0YXRpYyBlYXNlSW5FbGFzdGljKHQ6IG51bWJlcik6IG51bWJlciB7XG5cdFx0Y29uc3QgYzQgPSAoMiAqIE1hdGguUEkpIC8gM1xuXG5cdFx0cmV0dXJuIHQgPT09IDAgPyAwIDogdCA9PT0gMSA/IDEgOiAtTWF0aC5wb3coMiwgMTAgKiB0IC0gMTApICogTWF0aC5zaW4oKHQgKiAxMCAtIDEwLjc1KSAqIGM0KVxuXHR9XG5cdHN0YXRpYyBlYXNlT3V0RWxhc3RpYyh0OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdGNvbnN0IGM0ID0gKDIgKiBNYXRoLlBJKSAvIDNcblx0XHRyZXR1cm4gdCA9PT0gMCA/IDAgOiB0ID09PSAxID8gMSA6IE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgKiAxMCAtIDAuNzUpICogYzQpICsgMVxuXHR9XG5cdC8vIGVhc2VJbk91dEVsYXN0aWM6IHQgPT4ge1xuXHQvLyAgIHZhciBzID0gMiAqIHQgLSAxIC8vIHJlbWFwOiBbMCwwLjVdIC0+IFstMSwwXVxuXHQvLyAgIHZhciBrID0gKCg4MCAqIHMgLSA5KSAqIE1hdGguUEkpIC8gMTggLy8gYW5kICAgIFswLjUsMV0gLT4gWzAsKzFdXG5cdC8vICAgaWYgKHMgPCAwKSByZXR1cm4gLTAuNSAqIE1hdGgucG93KDIsIDEwICogcykgKiBNYXRoLnNpbihrKVxuXHQvLyAgIGVsc2UgcmV0dXJuIDEgKyAwLjUgKiBNYXRoLnBvdygyLCAtMTAgKiBzKSAqIE1hdGguc2luKGspXG5cdC8vIH0sXG59XG5cbmV4cG9ydCBjbGFzcyBXTWF0aCB7XG5cdHN0YXRpYyBtYWNvcyh4OiBudW1iZXIpIHtcblx0XHRyZXR1cm4gTWF0aC5hY29zKHgpXG5cdH1cblx0c3RhdGljIG1hc2luKHg6IG51bWJlcikge1xuXHRcdHJldHVybiBNYXRoLmFzaW4oeClcblx0fVxuXHRzdGF0aWMgbWF0YW4oeSwgeCkge1xuXHRcdHJldHVybiBNYXRoLmF0YW4yKHksIHgpXG5cdH1cblx0c3RhdGljIG1jb3MoeCkge1xuXHRcdHJldHVybiBNYXRoLmNvcyh4KVxuXHR9XG5cdHN0YXRpYyBtc2luKHgpIHtcblx0XHRyZXR1cm4gTWF0aC5zaW4oeClcblx0fVxuXHRzdGF0aWMgY29zMih4KSB7XG5cdFx0cmV0dXJuIFtNYXRoLmNvcyh4WzBdKSwgTWF0aC5jb3MoeFsxXSldXG5cdH1cblx0c3RhdGljIGNvczMoeCkge1xuXHRcdHJldHVybiBbTWF0aC5jb3MoeFswXSksIE1hdGguY29zKHhbMV0pLCBNYXRoLmNvcyh4WzJdKV1cblx0fVxuXHRzdGF0aWMgc2luMih4KSB7XG5cdFx0cmV0dXJuIFtNYXRoLnNpbih4WzBdKSwgTWF0aC5zaW4oeFsxXSldXG5cdH1cblx0c3RhdGljIHNpbjMoeCkge1xuXHRcdHJldHVybiBbTWF0aC5zaW4oeFswXSksIE1hdGguc2luKHhbMV0pLCBNYXRoLnNpbih4WzJdKV1cblx0fVxuXHRzdGF0aWMgc2luNCh4KSB7XG5cdFx0cmV0dXJuIFtNYXRoLnNpbih4WzBdKSwgTWF0aC5zaW4oeFsxXSksIE1hdGguc2luKHhbMl0pLCBNYXRoLnNpbih4WzNdKV1cblx0fVxuXHRzdGF0aWMgU0MoeCkge1xuXHRcdHJldHVybiBbTWF0aC5zaW4oeCksIE1hdGguY29zKHgpXVxuXHR9XG5cdHN0YXRpYyBhZGQyKGEsIGIpIHtcblx0XHRyZXR1cm4gW2FbMF0gKyBiWzBdLCBhWzFdICsgYlsxXV1cblx0fVxuXHRzdGF0aWMgYWRkMyhhLCBiKSB7XG5cdFx0cmV0dXJuIFthWzBdICsgYlswXSwgYVsxXSArIGJbMV0sIGFbMl0gKyBiWzJdXVxuXHR9XG5cdHN0YXRpYyBhZGQzMShhLCBiKSB7XG5cdFx0cmV0dXJuIFthWzBdICsgYiwgYVsxXSArIGIsIGFbMl0gKyBiXVxuXHR9XG5cdHN0YXRpYyBhZGQ0KGEsIGIpIHtcblx0XHRyZXR1cm4gW2FbMF0gKyBiWzBdLCBhWzFdICsgYlsxXSwgYVsyXSArIGJbMl0sIGFbM10gKyBiWzNdXVxuXHR9XG5cdHN0YXRpYyBzdWIzKGEsIGIpIHtcblx0XHRyZXR1cm4gW2FbMF0gLSBiWzBdLCBhWzFdIC0gYlsxXSwgYVsyXSAtIGJbMl1dXG5cdH1cblx0c3RhdGljIHN1YjIoYSwgYikge1xuXHRcdHJldHVybiBbYVswXSAtIGJbMF0sIGFbMV0gLSBiWzFdXVxuXHR9XG5cdHN0YXRpYyBkb3QzKGEsIGIpIHtcblx0XHRyZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdXG5cdH1cblx0c3RhdGljIGFiczMoYSkge1xuXHRcdHJldHVybiBbYVswXSA+IDAgPyBhWzBdIDogLWFbMF0sIGFbMV0gPiAwID8gYVsxXSA6IC1hWzFdLCBhWzJdID4gMCA/IGFbMl0gOiAtYVsyXV1cblx0fVxuXHRzdGF0aWMgc2NhbGUyKGEsIGIpIHtcblx0XHRyZXR1cm4gW2FbMF0gKiBiLCBhWzFdICogYl1cblx0fVxuXHRzdGF0aWMgc2NhbGUzKGEsIGIpIHtcblx0XHRyZXR1cm4gW2FbMF0gKiBiLCBhWzFdICogYiwgYVsyXSAqIGJdXG5cdH1cblx0c3RhdGljIHNjYWxlNChhLCBiKSB7XG5cdFx0cmV0dXJuIFthWzBdICogYiwgYVsxXSAqIGIsIGFbMl0gKiBiLCBhWzNdICogYl1cblx0fVxuXHRzdGF0aWMgbXVsMyhhLCBiKSB7XG5cdFx0cmV0dXJuIFthWzBdICogYlswXSwgYVsxXSAqIGJbMV0sIGFbMl0gKiBiWzJdXVxuXHR9XG5cdHN0YXRpYyBtdWw0KGEsIGIpIHtcblx0XHRyZXR1cm4gW2FbMF0gKiBiWzBdLCBhWzFdICogYlsxXSwgYVsyXSAqIGJbMl0sIGFbM10gKiBiWzNdXVxuXHR9XG5cdHN0YXRpYyBteW1peChhLCBiLCBmKSB7XG5cdFx0cmV0dXJuIGEgKiAoMS4wIC0gZikgKyBiICogZlxuXHR9XG5cdHN0YXRpYyBteW1peDIyKGEsIGIsIGYpIHtcblx0XHRyZXR1cm4gW2FbMF0gKiAoMS4wIC0gZlswXSkgKyBiWzBdICogZlswXSwgYVsxXSAqICgxLjAgLSBmWzFdKSArIGJbMV0gKiBmWzFdXVxuXHR9XG5cdHN0YXRpYyBtaXgxKGEsIGIsIGYpIHtcblx0XHRyZXR1cm4gYSAqICgxLjAgLSBmKSArIGIgKiBmXG5cdH1cblx0c3RhdGljIG1peDMoYSwgYiwgZikge1xuXHRcdHJldHVybiBhZGQzKHNjYWxlMyhhLCAxLjAgLSBmKSwgc2NhbGUzKGIsIGYpKVxuXHR9XG5cdHN0YXRpYyBsZW5ndGgyKGEpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGFbMF0gKiBhWzBdICsgYVsxXSAqIGFbMV0pXG5cdH1cblx0c3RhdGljIGxlbmd0aDMoYSkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXSArIGFbMl0gKiBhWzJdKVxuXHR9XG5cdHN0YXRpYyBsZW5ndGg0KGEpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGFbMF0gKiBhWzBdICsgYVsxXSAqIGFbMV0gKyBhWzJdICogYVsyXSArIGFbM10gKiBhWzNdKVxuXHR9XG5cdHN0YXRpYyBub3JtYWxpemUzKGEpIHtcblx0XHRyZXR1cm4gc2NhbGUzKGEsIDEuMCAvIGxlbmd0aDMoYSkpXG5cdH1cblx0c3RhdGljIG5vcm1hbGl6ZTQoYSkge1xuXHRcdHJldHVybiBzY2FsZTQoYSwgMS4wIC8gbGVuZ3RoNChhKSlcblx0fVxuXHRzdGF0aWMgY3Jvc3MoYSwgYikge1xuXHRcdHJldHVybiBbYVsxXSAqIGJbMl0gLSBiWzFdICogYVsyXSwgYVsyXSAqIGJbMF0gLSBiWzJdICogYVswXSwgYVswXSAqIGJbMV0gLSBiWzBdICogYVsxXV1cblx0fVxuXHRHID0gMC41ICsgTWF0aC5zcXJ0KDUgLyA0KVxuXHRzdGF0aWMgZnJhY3QxKGEpIHtcblx0XHRyZXR1cm4gYSAtIE1hdGguZmxvb3IoYSlcblx0fVxuXHRzdGF0aWMgZmxvb3IyKGEpIHtcblx0XHRyZXR1cm4gW01hdGguZmxvb3IoYVswXSksIE1hdGguZmxvb3IoYVsxXSldXG5cdH1cblx0c3RhdGljIGZyYWN0MihhKSB7XG5cdFx0cmV0dXJuIFtmcmFjdDEoYVswXSksIGZyYWN0MShhWzFdKV1cblx0fVxuXHRzdGF0aWMgZnJhY3QzKGEpIHtcblx0XHRyZXR1cm4gW2ZyYWN0MShhWzBdKSwgZnJhY3QxKGFbMV0pLCBmcmFjdDEoYVsyXSldXG5cdH1cblx0c3RhdGljIGZyYWN0NChhKSB7XG5cdFx0cmV0dXJuIFtmcmFjdDEoYVswXSksIGZyYWN0MShhWzFdKSwgZnJhY3QxKGFbMl0pLCBmcmFjdDEoYVszXSldXG5cdH1cblx0c3RhdGljIGNsYW1wMShhLCBhMSwgYTIpIHtcblx0XHRyZXR1cm4gYSA8IGExID8gYTEgOiBhID4gYTIgPyBhMiA6IGFcblx0fVxuXHRzdGF0aWMgY2xhbXAzMShhLCBhMSwgYTIpIHtcblx0XHRyZXR1cm4gW2NsYW1wMShhWzBdLCBhMSwgYTIpLCBjbGFtcDEoYVsxXSwgYTEsIGEyKSwgY2xhbXAxKGFbMl0sIGExLCBhMildXG5cdH1cblx0c3RhdGljIHJvdFgocGgsIHYpIHtcblx0XHRyZXR1cm4gW3ZbMF0sIHZbMV0gKiBtY29zKHBoKSArIHZbMl0gKiBtc2luKHBoKSwgdlsyXSAqIG1jb3MocGgpIC0gdlsxXSAqIG1zaW4ocGgpXVxuXHR9XG5cdHN0YXRpYyByb3RZKHBoLCB2KSB7XG5cdFx0cmV0dXJuIFt2WzBdICogbWNvcyhwaCkgKyB2WzJdICogbXNpbihwaCksIHZbMV0sIHZbMl0gKiBtY29zKHBoKSAtIHZbMF0gKiBtc2luKHBoKV1cblx0fVxuXHRzdGF0aWMgcm90WihwaCwgdikge1xuXHRcdHJldHVybiBbdlswXSAqIG1jb3MocGgpICsgdlsxXSAqIG1zaW4ocGgpLCB2WzFdICogbWNvcyhwaCkgLSB2WzBdICogbXNpbihwaCksIHZbMl1dXG5cdH1cblx0c3RhdGljIGhzdjJyZ2IoYykge1xuXHRcdHZhciBLID0gWzEuMCwgMi4wIC8gMy4wLCAxLjAgLyAzLjAsIDMuMF1cblx0XHR2YXIgcCA9IGFiczMoc3ViMyhzY2FsZTMoZnJhY3QzKGFkZDMoW2NbMF0sIGNbMF0sIGNbMF1dLCBLKSksIDYuMCksIFszLCAzLCAzXSkpXG5cdFx0cmV0dXJuIHNjYWxlMyhtaXgzKFsxLCAxLCAxXSwgY2xhbXAzMShzdWIzKHAsIFsxLCAxLCAxXSksIDAuMCwgMS4wKSwgY1sxXSksIGNbMl0pXG5cdH1cbn1cbiIsImltcG9ydCB7cGF1c2Vfb25fZ2xfZXJyb3J9IGZyb20gJ2dsX3V0aWxzJ1xuaW1wb3J0IHtsb2cyLCBtaW4sIHBvd30gZnJvbSAnd21hdGgnXG5pbXBvcnQge0ZyYW1lYnVmZmVyfSBmcm9tICcuL0ZyYW1lYnVmZmVyJ1xuXG5leHBvcnQgY2xhc3MgVGV4dHVyZSB7XG5cdC8vIEB0cy1pZ25vcmVcblx0dGV4OiBXZWJHTFRleHR1cmVcblx0aW50ZXJuYWxfZm9ybWF0OiBudW1iZXJcblx0Zm9ybWF0OiBudW1iZXJcblx0dHlwZTogbnVtYmVyXG5cdHJlczogQXJyYXk8bnVtYmVyPlxuXG5cdHByaXZhdGUgaXNfZmxvYXQ6IGJvb2xlYW5cblx0bWlwbWFwcGVkOiBib29sZWFuXG5cdHByaXZhdGUgbWlwX2xldmVsczogbnVtYmVyXG5cblx0Y29uc3RydWN0b3IocmVzOiBudW1iZXJbXSwgaW50ZXJuYWxfZm9ybWF0OiBudW1iZXIgPSBnbC5SR0JBLCBtaXBtYXBwZWQgPSBmYWxzZSwgbWlwX2xldmVsczogbnVtYmVyID0gMCkge1xuXHRcdGNvbnN0IGVxX2FueSA9IChhOiBhbnksIGI6IGFueVtdKTogYm9vbGVhbiA9PiB7XG5cdFx0XHRsZXQgZXEgPSBmYWxzZVxuXHRcdFx0Yi5mb3JFYWNoKChiKSA9PiB7XG5cdFx0XHRcdGlmIChiID09PSBhKSB7XG5cdFx0XHRcdFx0ZXEgPSB0cnVlXG5cdFx0XHRcdFx0Ly8gcmV0dXJuIGVxXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHRyZXR1cm4gZXFcblx0XHR9XG5cdFx0dGhpcy5yZXMgPSBbLi4ucmVzXVxuXHRcdHRoaXMuaW50ZXJuYWxfZm9ybWF0ID0gaW50ZXJuYWxfZm9ybWF0XG5cblx0XHR0aGlzLm1pcG1hcHBlZCA9IG1pcG1hcHBlZFxuXHRcdHRoaXMubWlwX2xldmVscyA9IG1pcF9sZXZlbHNcblxuXHRcdHRoaXMuaXNfZmxvYXQgPSBlcV9hbnkoaW50ZXJuYWxfZm9ybWF0LCBbZ2wuUkdCQTMyRiwgZ2wuUkdCQTE2RiwgZ2wuUkdCMTZGLCBnbC5SR0IzMkZdKVxuXG5cdFx0bGV0IGNvbXBfY250ID0gNFxuXHRcdGlmIChlcV9hbnkoaW50ZXJuYWxfZm9ybWF0LCBbZ2wuUkdCQTMyRiwgZ2wuUkdCQTE2RiwgZ2wuUkdCQSwgZ2wuUkdCQTE2SSwgZ2wuUkdCQTE2VUksIGdsLlJHQkEzMkksIGdsLlJHQkE4SSwgZ2wuUkdCQThVSV0pKSB7XG5cdFx0XHRjb21wX2NudCA9IDRcblx0XHR9XG5cdFx0aWYgKGVxX2FueShpbnRlcm5hbF9mb3JtYXQsIFtnbC5SR0IzMkYsIGdsLlJHQjE2RiwgZ2wuUkdCLCBnbC5SR0IxNkksIGdsLlJHQjE2VUksIGdsLlJHQjMySSwgZ2wuUkdCOEksIGdsLlJHQjhVSV0pKSB7XG5cdFx0XHRjb21wX2NudCA9IDNcblx0XHR9XG5cblx0XHR0aGlzLmZvcm1hdCA9IGNvbXBfY250ID09PSA0ID8gZ2wuUkdCQSA6IGdsLlJHQlxuXHRcdHRoaXMudHlwZSA9IHRoaXMuaXNfZmxvYXQgPyBnbC5GTE9BVCA6IGdsLlVOU0lHTkVEX0JZVEVcblxuXHRcdGlmIChlcV9hbnkoaW50ZXJuYWxfZm9ybWF0LCBbZ2wuUkdCQThVSSwgZ2wuUkdCQTE2VUksIGdsLlJHQkEzMlVJLCBnbC5SR0I4VUksIGdsLlJHQjE2VUksIGdsLlJHQjMyVUldKSkge1xuXHRcdFx0dGhpcy50eXBlID0gZ2wuVU5TSUdORURfSU5UXG5cdFx0fVxuXHRcdGlmIChlcV9hbnkoaW50ZXJuYWxfZm9ybWF0LCBbZ2wuUkdCQThJLCBnbC5SR0JBMTZJLCBnbC5SR0JBMzJJLCBnbC5SR0I4SSwgZ2wuUkdCMTZJLCBnbC5SR0IzMkldKSkge1xuXHRcdFx0dGhpcy50eXBlID0gZ2wuSU5UXG5cdFx0fVxuXHRcdHRoaXMucmVjcmVhdGUoKVxuXHR9XG5cdHJlY3JlYXRlKCkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHR0aGlzLnRleCA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXgpXG5cblx0XHRpZiAodGhpcy5pc19mbG9hdCkge1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpXG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVClcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUilcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG5cdFx0fVxuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpXG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSlcblxuXHRcdGlmICh0aGlzLm1pcG1hcHBlZCkge1xuXHRcdFx0aWYgKHRoaXMubWlwX2xldmVscyA9PT0gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5yZXNbMF0gPiA0ICYmIHRoaXMucmVzWzFdID4gNCkge1xuXHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUilcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKVxuXHRcdFx0XHRcdGdsLnRleFN0b3JhZ2UyRChnbC5URVhUVVJFXzJELCBsb2cyKG1pbih0aGlzLnJlc1swXSwgdGhpcy5yZXNbMV0pKSwgdGhpcy5pbnRlcm5hbF9mb3JtYXQsIHRoaXMucmVzWzBdLCB0aGlzLnJlc1sxXSlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuaW50ZXJuYWxfZm9ybWF0LCB0aGlzLnJlc1swXSwgdGhpcy5yZXNbMV0sIDAsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIG51bGwpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBhdXNlX29uX2dsX2Vycm9yKClcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmludGVybmFsX2Zvcm1hdCwgdGhpcy5yZXNbMF0sIHRoaXMucmVzWzFdLCAwLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBudWxsKVxuXHRcdH1cblx0XHQvLyBjb25zb2xlLmxvZyhnbC5pc1RleHR1cmUodGhpcy50ZXgpKVxuXG5cdFx0aWYgKCFnbC5pc1RleHR1cmUodGhpcy50ZXgpKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdURVhUVVJFIElOQ09NUExFVEUnKVxuXHRcdH1cblx0fVxuXG5cdHJlc2l6ZShuZXdfcmVzOiBudW1iZXJbXSkge1xuXHRcdHRoaXMucmVzID0gWy4uLm5ld19yZXNdXG5cdFx0aWYgKHRoaXMubWlwbWFwcGVkKSB7XG5cdFx0XHRnbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4KVxuXHRcdFx0dGhpcy5yZWNyZWF0ZSgpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTE1KVxuXHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXgpXG5cdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuaW50ZXJuYWxfZm9ybWF0LCB0aGlzLnJlc1swXSwgdGhpcy5yZXNbMV0sIDAsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIG51bGwpXG5cdFx0fVxuXHR9XG5cdHN0YXRpYyBhc3luYyBmcm9tX2ltYWdlX3BhdGgoaW1nX3BhdGg6IHN0cmluZyk6IFByb21pc2U8VGV4dHVyZT4ge1xuXHRcdGZ1bmN0aW9uIGxvYWRJbWFnZSh1cmw6IHN0cmluZyk6IFByb21pc2U8SFRNTEltYWdlRWxlbWVudD4ge1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGltYWdlID0gbmV3IEltYWdlKClcblx0XHRcdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcblx0XHRcdFx0XHRyZXNvbHZlKGltYWdlKVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRpbWFnZS5zcmMgPSB1cmxcblx0XHRcdH0pXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW1nID0gYXdhaXQgbG9hZEltYWdlKGltZ19wYXRoKVxuXHRcdGNvbnN0IHRleCA9IG5ldyBUZXh0dXJlKFtpbWcubmF0dXJhbFdpZHRoLCBpbWcubmF0dXJhbEhlaWdodF0sIGdsLlJHQkE4LCB0cnVlLCAwKVxuXHRcdC8vIHRleC51cGxvYWRfZnJvbV9jcHUoaW1nKVxuXHRcdC8vIGdsLmdldFRleFBhcmFtZXRlcihnbC5URVhUVVJFXzJELCBnbC5UWVBFKVxuXHRcdGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgdGV4LnJlc1swXSwgdGV4LnJlc1sxXSwgdGV4LmZvcm1hdCwgdGV4LnR5cGUsIGltZylcblx0XHRnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKVxuXHRcdHBhdXNlX29uX2dsX2Vycm9yKClcblx0XHQvLyBOb3QgbmVlZGVkP1xuXHRcdGdsLmZpbmlzaCgpXG5cdFx0aW1nLnJlbW92ZSgpXG5cdFx0cmV0dXJuIHRleFxuXHR9XG5cblx0dXBsb2FkX2Zyb21fY3B1KGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50IHwgbnVtYmVyW10gfCBGbG9hdDMyQXJyYXkpIHtcblx0XHRpZiAoaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG5cdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuaW50ZXJuYWxfZm9ybWF0LCB0aGlzLnJlc1swXSwgdGhpcy5yZXNbMV0sIDAsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIGltYWdlKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWJ1Z2dlclxuXHRcdH1cblx0fVxuXG5cdGNsb25lKCk6IFRleHR1cmUge1xuXHRcdHJldHVybiBuZXcgVGV4dHVyZSh0aGlzLnJlcywgdGhpcy5pbnRlcm5hbF9mb3JtYXQsIHRoaXMubWlwbWFwcGVkLCB0aGlzLm1pcF9sZXZlbHMpXG5cdH1cblx0YmluZF90b191bml0KHVuaXQ6IG51bWJlcikge1xuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB1bml0KVxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4KVxuXHR9XG5cblx0cmVhZF9iYWNrX2FycmF5KG9mZnM6IG51bWJlcltdID0gWzAsIDBdLCByZWFkX2JhY2tfcmVzOiBudW1iZXJbXSA9IFsuLi50aGlzLnJlc10pOiBVaW50OEFycmF5IHwgRmxvYXQzMkFycmF5IHtcblx0XHRsZXQgdGVtcF9mYiA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCkgYXMgV2ViR0xGcmFtZWJ1ZmZlclxuXHRcdGxldCBwcmV2X2JvdW5kX2ZiID0gRnJhbWVidWZmZXIuY3VycmVudGx5X2JvdW5kXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0ZW1wX2ZiKVxuXHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXgsIDApXG5cblx0XHQvLyBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5yZXNbMF0gKiB0aGlzLnJlc1sxXSAqIDQpXG5cblx0XHRjb25zdCBkYXRhID0gdGhpcy5pc19mbG9hdFxuXHRcdFx0PyBuZXcgRmxvYXQzMkFycmF5KHJlYWRfYmFja19yZXNbMF0gKiByZWFkX2JhY2tfcmVzWzFdICogNClcblx0XHRcdDogbmV3IFVpbnQ4QXJyYXkocmVhZF9iYWNrX3Jlc1swXSAqIHJlYWRfYmFja19yZXNbMV0gKiA0KVxuXHRcdGdsLnJlYWRQaXhlbHMob2Zmc1swXSwgb2Zmc1sxXSwgcmVhZF9iYWNrX3Jlc1swXSwgcmVhZF9iYWNrX3Jlc1sxXSwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgZGF0YSlcblx0XHQvLyBjb25zb2xlLmxvZyhkYXRhKVxuXHRcdGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRlbXBfZmIpXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBwcmV2X2JvdW5kX2ZiLmZiKVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmVhZF9iYWNrX3BpeGVsKG9mZnM6IG51bWJlcltdKTogQXJyYXk8bnVtYmVyPiB7XG5cdFx0bGV0IGRhdGEgPSB0aGlzLnJlYWRfYmFja19hcnJheShvZmZzLCBbMSwgMV0pXG5cdFx0aWYgKHRoaXMuaXNfZmxvYXQpIHtcblx0XHRcdGRhdGEuZm9yRWFjaCgoZSwgaSwgYSkgPT4ge1xuXHRcdFx0XHRhW2ldICo9IDI1NVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0ZGF0YVszXSA9IDI1NVxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gQXJyYXkuZnJvbShkYXRhKVxuXHR9XG5cdGFzeW5jIHJlYWRfYmFja19pbWFnZShcblx0XHRnYW1tYV9jb3JyZWN0OiBib29sZWFuID0gZmFsc2UsXG5cdFx0b2ZmczogbnVtYmVyW10gPSBbMCwgMF0sXG5cdFx0cmVhZF9iYWNrX3JlczogbnVtYmVyW10gPSBbLi4udGhpcy5yZXNdLFxuXHQpOiBQcm9taXNlPFtIVE1MSW1hZ2VFbGVtZW50LCBCbG9iXT4ge1xuXHRcdGxldCBkYXRhID0gdGhpcy5yZWFkX2JhY2tfYXJyYXkob2ZmcywgcmVhZF9iYWNrX3JlcylcblxuXHRcdGxldCBpID0gMFxuXHRcdGxldCBpZHggPSAwXG5cdFx0Zm9yIChsZXQgcGl4ZWwgb2YgZGF0YSkge1xuXHRcdFx0aWYgKGkgPT09IDMpIHtcblx0XHRcdFx0aWYgKHRoaXMuaXNfZmxvYXQpIHtcblx0XHRcdFx0XHRkYXRhW2lkeF0gPSAyNTVcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhW2lkeF0gPSAyNTVcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gLTFcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChnYW1tYV9jb3JyZWN0KSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuaXNfZmxvYXQpIHtcblx0XHRcdFx0XHRcdGRhdGFbaWR4XSA9IDI1NSAqIHBvdyhkYXRhW2lkeF0sIDAuNDU0NTQ1NDU0NSlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGF0YVtpZHhdID0gMjU1ICogcG93KGRhdGFbaWR4XSAvIDI1NSwgMC40NTQ1NDU0NTQ1KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBkYXRhW2lkeF0gKj0gMjQwXG5cdFx0XHR9XG5cdFx0XHRpZHgrK1xuXHRcdFx0aSsrXG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGEgMkQgY2FudmFzIHRvIHN0b3JlIHRoZSByZXN1bHRcblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuXHRcdGNhbnZhcy53aWR0aCA9IHRoaXMucmVzWzBdXG5cdFx0Y2FudmFzLmhlaWdodCA9IHRoaXMucmVzWzFdXG5cdFx0Y29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuXG5cdFx0bGV0IGJsb2I6IEJsb2JcblxuXHRcdGNvbnN0IGdldENhbnZhc0Jsb2IgPSAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IFByb21pc2U8QmxvYj4gPT4ge1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0Y2FudmFzLnRvQmxvYihmdW5jdGlvbiAoYmxvYikge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRyZXNvbHZlKGJsb2IpXG5cdFx0XHRcdH0sICdpbWFnZS9wbmcnKVxuXHRcdFx0fSlcblx0XHR9XG5cblx0XHRibG9iID0gYXdhaXQgZ2V0Q2FudmFzQmxvYihjYW52YXMpXG5cdFx0Y29uc29sZS5sb2coJ0JMT1JHVUJTJylcblx0XHRjb25zb2xlLmxvZyhibG9iKVxuXG5cdFx0Ly8gY2FudmFzLnRvQmxvYigoYikgPT4ge1xuXHRcdC8vIFx0YmxvYiA9IGIgYXMgQmxvYlxuXHRcdC8vIFx0Y29uc29sZS5sb2coJ0JMT0IgQScpXG5cdFx0Ly8gXHRjb25zb2xlLmxvZyhibG9iKVxuXHRcdC8vIH0sICdpbWFnZS9wbmcnKVxuXG5cdFx0Ly8gY29uc29sZS5sb2coJ0JMT0IgQicpXG5cdFx0Ly8gY29uc29sZS5sb2coYmxvYilcblxuXHRcdGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblx0XHRpbWFnZURhdGEuZGF0YS5zZXQoZGF0YSlcblx0XHRjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG5cdFx0Y29uc3QgaW1nID0gbmV3IEltYWdlKClcblx0XHRpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpXG5cblx0XHRjYW52YXMucmVtb3ZlKClcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIFtpbWcsIGJsb2JdXG5cdH1cbn1cbiIsImltcG9ydCB7VGV4dHVyZX0gZnJvbSAnLi9UZXh0dXJlJ1xuXG5leHBvcnQgY2xhc3MgRnJhbWVidWZmZXIge1xuXHRzdGF0aWMgY3VycmVudGx5X2JvdW5kOiBGcmFtZWJ1ZmZlclxuXHRzdGF0aWMgZnJhbWVidWZmZXJzOiBGcmFtZWJ1ZmZlcltdID0gW11cblx0X3RleHR1cmVzOiBBcnJheTxUZXh0dXJlPlxuXHRfYmFja190ZXh0dXJlczogQXJyYXk8VGV4dHVyZT5cblx0cHJpdmF0ZSBfZmI6IFdlYkdMRnJhbWVidWZmZXJcblx0Ly8gQHRzLWlnbm9yZVxuXHRwcml2YXRlIF9mYl9iYWNrOiBXZWJHTEZyYW1lYnVmZmVyID0gdW5kZWZpbmVkXG5cdGRlZmF1bHQ6IGJvb2xlYW4gPSBmYWxzZVxuXHRwb25nYWJsZTogYm9vbGVhbiA9IGZhbHNlXG5cdG5lZWRzX3Bvbmc6IGJvb2xlYW4gPSBmYWxzZVxuXHRwb25nX2lkeDogbnVtYmVyID0gMFxuXG5cdHB1YmxpYyBnZXQgdGV4dHVyZXMoKTogQXJyYXk8VGV4dHVyZT4ge1xuXHRcdGlmICh0aGlzLnBvbmdfaWR4ID09PSAwKSByZXR1cm4gdGhpcy5fdGV4dHVyZXNcblx0XHRlbHNlIHJldHVybiB0aGlzLl9iYWNrX3RleHR1cmVzXG5cdH1cblx0cHVibGljIGdldCBiYWNrX3RleHR1cmVzKCk6IEFycmF5PFRleHR1cmU+IHtcblx0XHRpZiAodGhpcy5wb25nX2lkeCA9PT0gMCkgcmV0dXJuIHRoaXMuX2JhY2tfdGV4dHVyZXNcblx0XHRlbHNlIHJldHVybiB0aGlzLl90ZXh0dXJlc1xuXHR9XG5cblx0cHVibGljIGdldCBmYigpOiBXZWJHTEZyYW1lYnVmZmVyIHtcblx0XHRpZiAodGhpcy5wb25nX2lkeCA9PT0gMCkgcmV0dXJuIHRoaXMuX2ZiXG5cdFx0ZWxzZSByZXR1cm4gdGhpcy5fZmJfYmFja1xuXHR9XG5cdHB1YmxpYyBnZXQgZmJfYmFjaygpOiBXZWJHTEZyYW1lYnVmZmVyIHtcblx0XHRpZiAodGhpcy5wb25nX2lkeCA9PT0gMCkgcmV0dXJuIHRoaXMuX2ZiX2JhY2tcblx0XHRlbHNlIHJldHVybiB0aGlzLl9mYlxuXHR9XG5cblx0cHVibGljIHBvbmcoKSB7XG5cdFx0dGhpcy5wb25nX2lkeCA9IDEgLSB0aGlzLnBvbmdfaWR4XG5cdFx0dGhpcy5uZWVkc19wb25nID0gZmFsc2Vcblx0fVxuXG5cdHB1YmxpYyByZWNyZWF0ZSgpIHtcblx0XHRpZiAodGhpcy5wb25nYWJsZSkge1xuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLl9mYl9iYWNrKVxuXG5cdFx0XHRsZXQgaSA9IDBcblx0XHRcdGZvciAobGV0IHRleCBvZiB0aGlzLl9iYWNrX3RleHR1cmVzKSB7XG5cdFx0XHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuXHRcdFx0XHRcdGdsLkZSQU1FQlVGRkVSLFxuXHRcdFx0XHRcdGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSxcblx0XHRcdFx0XHRnbC5URVhUVVJFXzJELFxuXHRcdFx0XHRcdHRleC50ZXgsXG5cdFx0XHRcdFx0MCwgLy8gbGV2ZWwsIHRoaXMgaXMgdGhlIG1pcG1hcCBsZXZlbFxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cblx0XHRcdGlmIChnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRlJBTUVCVUZGRVIgSU5DT01QTEVURScpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLl9mYilcblxuXHRcdGxldCBpID0gMFxuXHRcdGZvciAobGV0IHRleCBvZiB0aGlzLl90ZXh0dXJlcykge1xuXHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG5cdFx0XHRcdGdsLkZSQU1FQlVGRkVSLFxuXHRcdFx0XHRnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksXG5cdFx0XHRcdGdsLlRFWFRVUkVfMkQsXG5cdFx0XHRcdHRleC50ZXgsXG5cdFx0XHRcdDAsIC8vIGxldmVsLCB0aGlzIGlzIHRoZSBtaXBtYXAgbGV2ZWxcblx0XHRcdClcblx0XHRcdGkrK1xuXHRcdH1cblxuXHRcdGlmIChnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZSQU1FQlVGRkVSIElOQ09NUExFVEUnKVxuXHRcdH1cblx0fVxuXHRjb25zdHJ1Y3Rvcih0ZXh0dXJlczogQXJyYXk8VGV4dHVyZT4sIHBvbmdhYmxlOiBib29sZWFuID0gZmFsc2UpIHtcblx0XHR0aGlzLl9mYiA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCkgYXMgV2ViR0xGcmFtZWJ1ZmZlclxuXHRcdHRoaXMuX3RleHR1cmVzID0gWy4uLnRleHR1cmVzXVxuXHRcdHRoaXMucG9uZ2FibGUgPSBwb25nYWJsZVxuXHRcdHRoaXMuX2JhY2tfdGV4dHVyZXMgPSBbXVxuXG5cdFx0aWYgKHRoaXMucG9uZ2FibGUpIHtcblx0XHRcdHRoaXMuX2ZiX2JhY2sgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpIGFzIFdlYkdMRnJhbWVidWZmZXJcblx0XHRcdGZvciAobGV0IHRleCBvZiB0aGlzLnRleHR1cmVzKSB7XG5cdFx0XHRcdHRoaXMuX2JhY2tfdGV4dHVyZXMucHVzaCh0ZXguY2xvbmUoKSlcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnJlY3JlYXRlKClcblxuXHRcdC8vIGlmICh0aGlzICE9PSBGcmFtZWJ1ZmZlci5jdXJyZW50bHlfYm91bmQpIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgRnJhbWVidWZmZXIuY3VycmVudGx5X2JvdW5kLl9mYilcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIEZyYW1lYnVmZmVyLmN1cnJlbnRseV9ib3VuZC5fZmIpXG5cdFx0RnJhbWVidWZmZXIuZnJhbWVidWZmZXJzLnB1c2godGhpcylcblx0fVxuXHRiaW5kKCkge1xuXHRcdGlmICh0aGlzLnBvbmdhYmxlKSB0aGlzLm5lZWRzX3BvbmcgPSB0cnVlXG5cdFx0bGV0IGRyYXdfYnVmZnM6IG51bWJlcltdID0gW11cblxuXHRcdGlmICh0aGlzLmRlZmF1bHQpIHtcblx0XHRcdGRyYXdfYnVmZnMgPSBbZ2wuQkFDS11cblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGkgPSAwXG5cdFx0XHRmb3IgKGxldCB0ZXggb2YgdGhpcy50ZXh0dXJlcykge1xuXHRcdFx0XHRkcmF3X2J1ZmZzLnB1c2goZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpKVxuXHRcdFx0XHRpKytcblx0XHRcdH1cblx0XHR9XG5cblx0XHRnbC52aWV3cG9ydCgwLCAwLCB0aGlzLnRleHR1cmVzWzBdLnJlc1swXSwgdGhpcy50ZXh0dXJlc1swXS5yZXNbMV0pXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZiKVxuXHRcdEZyYW1lYnVmZmVyLmN1cnJlbnRseV9ib3VuZCA9IHRoaXNcblx0XHQvLyBnbC5kcmF3QnVmZmVycyhkcmF3X2J1ZmZzKVxuXHR9XG5cdGNsZWFyKGNvbG91cjogbnVtYmVyW10gPSBbMCwgMCwgMCwgMF0pIHtcblx0XHQvLyBpZiAodGhpcy5mYiAhPT0gRnJhbWVidWZmZXIuY3VycmVudGx5X2JvdW5kLmZiKSBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZmIpXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZiKVxuXHRcdGdsLmNsZWFyQ29sb3IoY29sb3VyWzBdLCBjb2xvdXJbMV0sIGNvbG91clsyXSwgY29sb3VyWzNdKVxuXHRcdGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXG5cdFx0Ly8gaWYgKHRoaXMuZmIgIT09IEZyYW1lYnVmZmVyLmN1cnJlbnRseV9ib3VuZC5mYikgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBGcmFtZWJ1ZmZlci5jdXJyZW50bHlfYm91bmQuZmIpXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBGcmFtZWJ1ZmZlci5jdXJyZW50bHlfYm91bmQuZmIpXG5cdH1cbn1cbiIsImltcG9ydCB7RnJhbWVidWZmZXJ9IGZyb20gJ2dsL0ZyYW1lYnVmZmVyJ1xuaW1wb3J0IHtUZXh0dXJlfSBmcm9tICdnbC9UZXh0dXJlJ1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9nbF9lcnJvcl9oYW5kbGluZygpIHtcblx0aWYgKCFnbC5kZWJ1Z0VuYWJsZWQpIHJldHVyblxuXHRnbC5nbEVudW1zID0ge31cblx0Z2wuZW51bVN0cmluZ1RvVmFsdWUgPSB7fVxuXHRmb3IgKGxldCBwcm9wZXJ0eU5hbWUgaW4gZ2wpIHtcblx0XHRpZiAodHlwZW9mIGdsW3Byb3BlcnR5TmFtZV0gPT09ICdudW1iZXInKSB7XG5cdFx0XHRnbC5nbEVudW1zW2dsW3Byb3BlcnR5TmFtZV1dID0gcHJvcGVydHlOYW1lXG5cdFx0XHRnbC5lbnVtU3RyaW5nVG9WYWx1ZVtwcm9wZXJ0eU5hbWVdID0gZ2xbcHJvcGVydHlOYW1lXVxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2xfZW51bV90b19zdHJpbmcodmFsdWUpOiBzdHJpbmcge1xuXHQvLyBjaGVja0luaXQoKTtcblx0Y29uc3QgbmFtZSA9IHdpbmRvdy5nbC5nbEVudW1zW3ZhbHVlXVxuXHRyZXR1cm4gbmFtZSAhPT0gdW5kZWZpbmVkID8gJ2dsLicgKyBuYW1lIDogJy8qVU5LTk9XTiBXZWJHTCBFTlVNKi8gMHgnICsgdmFsdWUudG9TdHJpbmcoMTYpICsgJydcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcmludF9vbl9nbF9lcnJvcigpIHtcblx0aWYgKCFnbC5kZWJ1Z0VuYWJsZWQpIHJldHVyblxuXHRsZXQgZXJyID0gd2luZG93LmdsLmdldEVycm9yKClcblx0aWYgKGVyciAhPT0gMCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoZXJyKVxuXHRcdGNvbnNvbGUuZXJyb3IoZ2xfZW51bV90b19zdHJpbmcoZXJyKSlcblx0fVxufVxuZXhwb3J0IGZ1bmN0aW9uIHBhdXNlX29uX2dsX2Vycm9yKCkge1xuXHRpZiAoIWdsLmRlYnVnRW5hYmxlZCkgcmV0dXJuXG5cdGxldCBlcnIgPSB3aW5kb3cuZ2wuZ2V0RXJyb3IoKVxuXHRpZiAoZXJyICE9PSAwKSB7XG5cdFx0Y29uc29sZS5lcnJvcihlcnIpXG5cdFx0Y29uc29sZS5lcnJvcihnbF9lbnVtX3RvX3N0cmluZyhlcnIpKVxuXHRcdGRlYnVnZ2VyXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlfZmJfdG9fdGV4dHVyZShpbl9mcmFtZWJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlciwgb3V0X3RleHR1cmU6IFRleHR1cmUpIHtcblx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBpbl9mcmFtZWJ1ZmZlcilcblx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgb3V0X3RleHR1cmUudGV4KVxuXHRnbC5jb3B5VGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBvdXRfdGV4dHVyZS5pbnRlcm5hbF9mb3JtYXQsIDAsIDAsIG91dF90ZXh0dXJlLnJlc1swXSwgb3V0X3RleHR1cmUucmVzWzFdLCAwKVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlfZmJfdG9fZmIoaW5fZnJhbWVidWZmZXI6IFdlYkdMRnJhbWVidWZmZXIsIG91dF9mcmFtZWJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlciwgcmVzOiBudW1iZXJbXSkge1xuXHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuUkVBRF9GUkFNRUJVRkZFUiwgaW5fZnJhbWVidWZmZXIpXG5cdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5EUkFXX0ZSQU1FQlVGRkVSLCBvdXRfZnJhbWVidWZmZXIpXG5cdGdsLmJsaXRGcmFtZWJ1ZmZlcigwLCAwLCByZXNbMF0sIHJlc1sxXSwgMCwgMCwgcmVzWzBdLCByZXNbMV0sIGdsLkNPTE9SX0JVRkZFUl9CSVQsIGdsLk5FQVJFU1QpXG5cdC8vIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgaW5fZnJhbWVidWZmZXIpXG5cdC8vIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG91dF90ZXh0dXJlLnRleClcblx0Ly8gZ2wuY29weVRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgb3V0X3RleHR1cmUuaW50ZXJuYWxfZm9ybWF0LCAwLCAwLCBvdXRfdGV4dHVyZS5yZXNbMF0sIG91dF90ZXh0dXJlLnJlc1sxXSwgMClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZUlmTmVlZGVkKFxuXHRjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuXHRkZWZhdWx0X2ZyYW1lYnVmZmVyOiBGcmFtZWJ1ZmZlcixcblx0Y2xpZW50X3JlczogbnVtYmVyW10sXG5cdHNldF9yZWRyYXdfbmVlZGVkOiAodjogYm9vbGVhbikgPT4gdm9pZCxcblx0c2V0X3NoYXJlZF91bmlmb3JtczogRnVuY3Rpb24sXG4pIHtcblx0Y29uc3QgZGlzcGxheVdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoXG5cdGNvbnN0IGRpc3BsYXlIZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0XG5cblx0Y29uc3QgbmVlZFJlc2l6ZSA9IGNhbnZhcy53aWR0aCAhPT0gZGlzcGxheVdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGRpc3BsYXlIZWlnaHRcblxuXHRpZiAobmVlZFJlc2l6ZSkge1xuXHRcdGNsaWVudF9yZXNbMF0gPSBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGhcblx0XHRjbGllbnRfcmVzWzFdID0gY2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHRcblx0XHQvLyBjb25zb2xlLmxvZygnUkVTSVpFRCcpXG5cdFx0Ly8gY29uc29sZS5sb2coY2xpZW50X3Jlcylcblx0XHQvLyBjb25zb2xlLmxvZyhjYW52YXMpXG5cdFx0c2V0X3JlZHJhd19uZWVkZWQodHJ1ZSlcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci5fdGV4dHVyZXNbMF0ucmVzID0gWy4uLmNsaWVudF9yZXNdXG5cdFx0c2V0X3NoYXJlZF91bmlmb3JtcygpXG5cdH1cblxuXHRyZXR1cm4gbmVlZFJlc2l6ZVxufVxuIiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgS25vYiBmcm9tIFwiLi9Lbm9iLnN2ZWx0ZVwiXG5cblx0Ly8gZXhwb3J0IGxldCBjaGlsZFxuICBleHBvcnQgbGV0IGhpZGRlbjogYm9vbGVhbiA9IHRydWVcbiAgZXhwb3J0IGxldCBrbm9iOiBLbm9iXG48L3NjcmlwdD5cblxuXG48ZGl2IGlkPSdiYXInIHN0eWxlPSd7aGlkZGVuID8gXCJkaXNwbGF5OiBub25lO1wiIDogXCJcIn0nPlxuICA8c2xvdD48L3Nsb3Q+XG48L2Rpdj5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4gICNiYXIge1xuICAgIGJhY2tncm91bmQ6IGJsYWNrO1xuICAgIC8vIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgcGFkZGluZzogMHJlbSAxcmVtO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICA+KjpsYXN0LW9mLXR5cGUge1xuICAgICAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gICAgICBtYXJnaW4tcmlnaHQ6IDBweDtcbiAgICB9XG4gIH1cbjwvc3R5bGU+IiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBtaW4gfSBmcm9tICd3bWF0aCdcblx0aW1wb3J0IFNlbWlNb2RhbCBmcm9tICcuL1NlbWlNb2RhbC5zdmVsdGUnXG5cdGltcG9ydCB7b25Nb3VudH0gZnJvbSAnc3ZlbHRlJ1xuXG5cdGV4cG9ydCBsZXQgdmFsdWVcbiAgXG4gIGV4cG9ydCBsZXQgdHJpZ2dlck1vZGFsOiB1bmRlZmluZWQgfCAoKG1vZGFsOiBTZW1pTW9kYWwpPT52b2lkKSA9IHVuZGVmaW5lZFxuICBleHBvcnQgbGV0IG1vZGFsOiBTZW1pTW9kYWwgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgbGV0IGtub2JFbGVtZW50OiBIVE1MRWxlbWVudFxuICBcbiAgZXhwb3J0IGxldCBtb2RhbEhpZGRlbiA9IHRydWVcbiAgZXhwb3J0IGxldCB0aXRsZSA9IFwiXCJcblxuXHRjb25zdCByb3RSYW5nZSA9IDIgKiBNYXRoLlBJICogMC44MztcblxuXHRsZXQgc3RhcnRZID0gMFxuICBsZXQgc3RhcnRYID0gMDtcbiAgbGV0IHN0YXJ0VmFsdWUgPSAwXG5cdCQ6IHJvdGF0aW9uID0gLU1hdGguUEkgKiAwLjgzICsgKHZhbHVlKSAqIHJvdFJhbmdlO1xuICBcbiAgXG5cdFxuXHRmdW5jdGlvbiBjbGFtcChudW0sIG1pbiwgbWF4KSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obnVtLCBtYXgpKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gcG9pbnRlck1vdmUoeyBjbGllbnRYLCBjbGllbnRZIH0pIHtcblx0XHRsZXQgc2NhbGUgPSAzLi9taW4oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSBcblxuXHRcdGxldCB2YWx1ZURpZmYgPSAoc3RhcnRZIC0gY2xpZW50WSkgKiBzY2FsZTtcblx0XHR2YWx1ZURpZmYgLT0gKHN0YXJ0WCAtIGNsaWVudFgpICpzY2FsZTtcblx0XHR2YWx1ZSA9IGNsYW1wKHN0YXJ0VmFsdWUgKyB2YWx1ZURpZmYsIDAsIDEpXG5cdH1cblx0XG5cdGZ1bmN0aW9uIHBvaW50ZXJEb3duKGU6IFBvaW50ZXJFdmVudCkge1xuICAgIGxldCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGVcblx0XHRzdGFydFkgPSBjbGllbnRZO1xuXHRcdHN0YXJ0WCA9IGNsaWVudFg7XG5cdFx0c3RhcnRWYWx1ZSA9IHZhbHVlO1xuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgcG9pbnRlck1vdmUpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBwb2ludGVyVXApO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCkgXG5cdH1cblx0XG5cdGZ1bmN0aW9uIHBvaW50ZXJVcCgpIHtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBwb2ludGVyTW92ZSk7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHBvaW50ZXJVcCk7XG5cdH1cbiAgXG4gIGxldCB0aXRsZUVsZW1lbnRcblxuICBvbk1vdW50KCgpPT57XG4gICAgbGV0IHBvaW50ZXJEb3duXG4gICAgbGV0IHBvaW50ZXJVcCA9ICgpPT57XG4gICAgICBpZihtb2RhbCl7XG4gICAgICAgIHRyaWdnZXJNb2RhbD8uKG1vZGFsKVxuICAgICAgICBtb2RhbEhpZGRlbiA9IG1vZGFsLmhpZGRlbiBhcyBib29sZWFuXG4gICAgICB9XG5cbiAgICAgIHRpdGxlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcInBvaW50ZXJkb3duXCIsIHBvaW50ZXJEb3duKVxuICAgIH1cbiAgICBwb2ludGVyRG93biA9ICgpPT57XG4gICAgICB0aXRsZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXApXG4gICAgICB0aXRsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXApXG4gICAgfVxuICAgIHRpdGxlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgcG9pbnRlckRvd24pXG4gIH0pXG5cbjwvc2NyaXB0PlxuXG5cbjxkaXYgZHJhZ2dhYmxlPVwiZmFsc2VcIiBjbGFzcz0na25vYi1jb250YWluZXItY29udGFpbmVyJz5cbiAgPGRpdiBjbGFzcz0na25vYi1jb250YWluZXInPlxuICAgIDxkaXYgY2xhc3M9XCJrbm9iXCIgc3R5bGU9XCJ0cmFuc2Zvcm06cm90YXRlKGNhbGMoe3JvdGF0aW9ufSAqIDFyYWQpKVwiIG9uOnBvaW50ZXJkb3duPXtwb2ludGVyRG93bn0gPlxuICAgICAgPHN2ZyB3aWR0aD0nMTAwJScgaGVpZ2h0PScxMDAlJyB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICA8cGF0aCBzdHJva2Utd2lkdGg9XCIxMFwiIGQ9XCJNNTAgNDAgbDAgLTUwXCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICA8ZGl2IFxuICAgIGNsYXNzPVwidGl0bGUge3RyaWdnZXJNb2RhbCA/IFwibWVudS10b2dnbGVcIiA6IFwiXCJ9XCIgXG4gICAgYmluZDp0aGlzPXt0aXRsZUVsZW1lbnR9XG4gICAgc3R5bGU9J3shbW9kYWxIaWRkZW4gJiYgXCJvdXRsaW5lOiAxcHggc29saWQgd2hpdGU7IG91dGxpbmUtb2Zmc2V0OiAwLjFyZW07XCJ9IHttb2RhbCAmJiBcImN1cnNvcjogcG9pbnRlcjtcIn0nXG4gICAgPnt0aXRsZX08L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGU+XG4gICp7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O1xuICB9XG4gIC5rbm9iLWNvbnRhaW5lci1jb250YWluZXJ7XG4gICAgYXNwZWN0LXJhdGlvOiAxLzE7XG4gICAgbWF4LWhlaWdodDogNTAlO1xuICAgIG1hcmdpbi10b3A6IDAuNXJlbTtcbiAgICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICB9XG4gIC5rbm9iLWNvbnRhaW5lcntcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAmOmhvdmVye1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbiAgICBhc3BlY3QtcmF0aW86IDEvMTtcbiAgICAvKiB3aWR0aDogNDBweDtcbiAgICBoZWlnaHQ6IDQwcHg7ICovXG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IGNvbmljLWdyYWRpZW50KGZyb20gNDVkZWcsXG4gICAgICB2YXIoLS1zZWNvbmRhcnktY29sb3IpIDBkZWcgMTVkZWcsXG4gICAgICB2YXIoLS10ZXJ0aWFyeS1jb2xvcikgNjBkZWcgNjBkZWcsXG4gICAgICB2YXIoLS1kYXJrZW4tY29sb3IpIDEyMGRlZyAyNDBkZWcsXG4gICAgICB2YXIoLS10ZXJ0aWFyeS1jb2xvcikgMzAwZGVnIDMwMGRlZyxcbiAgICAgIHZhcigtLXNlY29uZGFyeS1jb2xvcikgMzQ1ZGVnIDM2MGRlZ1xuICAgICk7XG4gICAgYm94LXNoYWRvdzogLS4xNWVtIC4xNWVtIC4wNWVtIC4wMmVtIHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgYm9yZGVyOiAwLjJyZW0gc29saWQgd2hpdGU7XG4gIH1cbiAgLmtub2ItY29udGFpbmVyLWNvbnRhaW5lcj4udGl0bGUubWVudS10b2dnbGV7XG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgY29sb3I6IGJsYWNrO1xuICB9XG4gIC5rbm9iLWNvbnRhaW5lci1jb250YWluZXI+LnRpdGxlIHtcbiAgICBcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgLyogcG9zaXRpb246IGFic29sdXRlOyAqL1xuICAgIGZvbnQtc2l6ZTogMC44cmVtICFpbXBvcnRhbnQ7XG4gICAgLyogcG9zaXRpb246IGFic29sdXRlOyAqL1xuICAgIG1hcmdpbi10b3A6IDAuNXJlbTtcbiAgICBjb2xvcjogd2hpdGU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XG4gICAgdG9wOiA1LjVyZW07XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIH1cblxuICAua25vYiB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgYXNwZWN0LXJhdGlvOiAxLzE7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIC8qIGhlaWdodDogODAlOyAqL1xuICAgIHBhZGRpbmc6IDA7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIGNvbG9yOiB2YXIoLS10ZXh0LWNvbG9yKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10ZXJ0aWFyeS1jb2xvcik7XG4gICAgYm94LXNoYWRvdzogMCAwIC4zZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpIGluc2V0O1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XG4gIH1cblxuICAua25vYiBzdmd7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICB9XG48L3N0eWxlPiIsIjxzdmVsdGU6b3B0aW9ucyBhY2Nlc3NvcnMgLz5cblxuPGRpdiBjbGFzcz1cImtub2ItY29udGFpbmVyLWNvbnRhaW5lclwiIGNsYXNzOmtub2Itc2VsZWN0ZWQ9e2RyYWdnaW5nfSBvbjpwb2ludGVyZG93bj17cG9pbnRlckRvd259PlxuXHQ8ZGl2IGNsYXNzPVwia25vYi1jb250YWluZXJcIj5cblx0XHQ8ZGl2IGNsYXNzPVwia25vYlwiPlxuXHRcdFx0PCEtLSB7IGlmIChwYXVzZWQpIEBodG1sIHBhdXNlfSAtLT5cblx0XHRcdDwhLS0geyNpZiBwYXVzZWR9XG5cdFx0XHR7QGh0bWwgcGxheWluZ0ljb259XG5cdFx0XHR7L2lmfSAtLT5cblxuXHRcdFx0e0BodG1sIGJydXNoU2l6ZUljb259XG5cblx0XHRcdDwhLS0gPHN2ZyB3aWR0aD0nMTAwJScgaGVpZ2h0PScxMDAlJyB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIj5cblx0XHRcdFx0PGcgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cblx0XHRcdFx0XHQ8cGF0aCBzdHJva2Utd2lkdGg9XCIxMFwiIGQ9XCJNNTAgNDAgbDAgLTUwXCIgLz5cblx0XHRcdFx0PC9nPlxuXHRcdFx0PC9zdmc+IC0tPlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cbjwvZGl2PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHQvLyBAdHMtaWdub3JlXG5cdGltcG9ydCBicnVzaFNpemVJY29uIGZyb20gJy8uLi9wdWJsaWMvY29weS5zdmcnXG5cblx0ZXhwb3J0IGxldCBicnVzaF9zejogbnVtYmVyW10gPSBbMC4yLCAwLjJdXG5cdC8vIGV4cG9ydCBsZXQgY2FudmFzX3JlczogbnVtYmVyW11cblxuXHRleHBvcnQgbGV0IHBpeGVsUmFuZ2UgPSAyMDBcblx0bGV0IHZhbHVlID0gWzAsIDBdXG5cdGxldCBtaW4gPSAwXG5cdGxldCBtYXggPSA0XG5cblx0ZXhwb3J0IGxldCBkcmFnZ2luZzogYm9vbGVhbiA9IGZhbHNlXG5cdGV4cG9ydCBsZXQgc3RvcHBlZF9kcmFnZ2luZzogYm9vbGVhbiA9IGZhbHNlXG5cblx0bGV0IHN0YXJ0WSA9IDAsXG5cdFx0c3RhcnRWYWx1ZSA9IFswLCAwXSxcblx0XHRzdGFydFggPSAwXG5cblx0JDogdmFsdWVSYW5nZSA9IG1heCAtIG1pblxuXHQvLyAkOiByb3RhdGlvbiA9IHN0YXJ0Um90YXRpb24gKyAodmFsdWUgLSBtaW4pIC8gdmFsdWVSYW5nZSAqIHJvdFJhbmdlO1xuXG5cdGZ1bmN0aW9uIGNsYW1wKG51bSwgbWluLCBtYXgpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihudW0sIG1heCkpXG5cdH1cblxuXHRmdW5jdGlvbiBwb2ludGVyTW92ZSh7Y2xpZW50WCwgY2xpZW50WX0pIHtcblx0XHRsZXQgdmFsdWVEaWZmWSA9ICh2YWx1ZVJhbmdlICogKHN0YXJ0WSAtIGNsaWVudFkpKSAvIHBpeGVsUmFuZ2Vcblx0XHRsZXQgdmFsdWVEaWZmWCA9ICh2YWx1ZVJhbmdlICogKHN0YXJ0WCAtIGNsaWVudFgpKSAvIHBpeGVsUmFuZ2Vcblx0XHRicnVzaF9zelswXSA9IGNsYW1wKHN0YXJ0VmFsdWVbMF0gLSB2YWx1ZURpZmZYLCBtaW4sIG1heClcblx0XHRicnVzaF9zelsxXSA9IGNsYW1wKHN0YXJ0VmFsdWVbMV0gKyB2YWx1ZURpZmZZLCBtaW4sIG1heClcblx0fVxuXG5cdGZ1bmN0aW9uIHBvaW50ZXJEb3duKGU6IFBvaW50ZXJFdmVudCkge1xuXHRcdGRyYWdnaW5nID0gdHJ1ZVxuXHRcdGxldCB7Y2xpZW50WCwgY2xpZW50WX0gPSBlXG5cdFx0Ly8gY29uc29sZS5sb2coeyBjbGllbnRZIH0pO1xuXHRcdGNvbnNvbGUubG9nKCdkb3duJylcblx0XHRzdGFydFkgPSBjbGllbnRZXG5cdFx0c3RhcnRYID0gY2xpZW50WFxuXHRcdHN0YXJ0VmFsdWUgPSBbLi4uYnJ1c2hfc3pdXG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBwb2ludGVyTW92ZSlcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcG9pbnRlclVwKVxuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKClcblx0fVxuXG5cdGZ1bmN0aW9uIHBvaW50ZXJVcCgpIHtcblx0XHRkcmFnZ2luZyA9IGZhbHNlXG5cdFx0c3RvcHBlZF9kcmFnZ2luZyA9IHRydWVcblx0XHRjb25zb2xlLmxvZygndXAnKVxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHBvaW50ZXJNb3ZlKVxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBwb2ludGVyVXApXG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cblx0KiB7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cdFx0LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcblx0fVxuICBAaW1wb3J0IFwiLy4uL3N0eWxlcy9pY29uLnNjc3NcIiBzY29wZWQ7IFxuXG5cdC8vIC5rbm9iLXNlbGVjdGVkIHtcblx0XHQvLyBmaWx0ZXI6IGludmVydCgxKTtcblx0XHQvLyA6Z2xvYmFsKHN2Zykge1xuXHRcdC8vIFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdFx0Ly8gfVxuXHQvLyB9XG5cdC5rbm9iLWNvbnRhaW5lci1jb250YWluZXIge1xuXHRcdFxuICAgIG1heC1oZWlnaHQ6IHVuc2V0ICFpbXBvcnRhbnQ7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdCY6aG92ZXIge1xuXHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdH1cblx0XHRoZWlnaHQ6IDEwMCU7XG5cdH1cblxuXHQua25vYi1jb250YWluZXJ7XG5cdFx0cGFkZGluZzogMC4zcmVtO1xuXHR9XG48L3N0eWxlPlxuIiwiaW1wb3J0IHtCcnVzaFN0cm9rZX0gZnJvbSAnYnJ1c2hfc3Ryb2tlJ1xuaW1wb3J0IHtUZXh0dXJlfSBmcm9tICdnbC9UZXh0dXJlJ1xuaW1wb3J0IHtwb3d9IGZyb20gJ3dtYXRoJ1xuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHY6IGJvb2xlYW4pIHtcblx0aWYgKCF2KSBkZWJ1Z2dlclxufVxuXG5leHBvcnQgY2xhc3MgQnJ1c2hUZXh0dXJlIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRncHVfdGV4OiBUZXh0dXJlID0gdW5kZWZpbmVkXG5cdC8vIEB0cy1pZ25vcmVcblx0cGF0aDogc3RyaW5nID0gdW5kZWZpbmVkXG5cdC8vIEB0cy1pZ25vcmVcblx0aWR4OiBudW1iZXJcblxuXHRzdGF0aWMgYXN5bmMgY3JlYXRlKHBhdGgsIGlkeDogbnVtYmVyKTogUHJvbWlzZTxCcnVzaFRleHR1cmU+IHtcblx0XHRsZXQgZ3B1X3RleCA9IGF3YWl0IFRleHR1cmUuZnJvbV9pbWFnZV9wYXRoKHBhdGgpXG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z3B1X3RleCxcblx0XHRcdHBhdGgsXG5cdFx0XHRpZHgsXG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9qZWN0IHtcblx0aWQ6IG51bWJlciA9IERhdGUubm93KClcblx0c2F2ZWQ6IGJvb2xlYW4gPSBmYWxzZVxuXHRicnVzaF9zdHJva2VzOiBCcnVzaFN0cm9rZVtdID0gW11cblx0Y2FudmFzUmVzOiBudW1iZXJbXSA9IFsxMDI0LCAyMDQ4XVxuXHQvLyBjYW52YXNSZXM6IG51bWJlcltdID0gWzIwNDgsIDEwMjRdXG5cdGNvbnN0cnVjdG9yKCkge31cblx0cHVzaF9zdHJva2Uoc3Ryb2tlOiBCcnVzaFN0cm9rZSkge1xuXHRcdHRoaXMuYnJ1c2hfc3Ryb2tlcy5wdXNoKHN0cm9rZSlcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgVXRpbHMge1xuXHRzdGF0aWMgaXNPbk1vYmlsZSA9ICgpOiBib29sZWFuID0+IHtcblx0XHRsZXQgY2hlY2sgPSBmYWxzZVxuXHRcdDsoZnVuY3Rpb24gKGEpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0LyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWlub3xhbmRyb2lkfGlwYWR8cGxheWJvb2t8c2lsay9pLnRlc3QoXG5cdFx0XHRcdFx0YSxcblx0XHRcdFx0KSB8fFxuXHRcdFx0XHQvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KFxuXHRcdFx0XHRcdGEuc3Vic3RyKDAsIDQpLFxuXHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0XHRcdGNoZWNrID0gdHJ1ZVxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdH0pKG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmEpXG5cdFx0cmV0dXJuIGNoZWNrXG5cdH1cblx0c3RhdGljIGdhbW1hX2NvcnJlY3QodTogbnVtYmVyW10sIGludmVyc2U6IGJvb2xlYW4gPSBmYWxzZSwgbW9kaWZ5OiBib29sZWFuID0gZmFsc2UpIHtcblx0XHRjb25zdCBleHBvbmVudCA9IGludmVyc2UgPyAxIC8gMC40NTQ1NDU0NTQ1NDU0NSA6IDAuNDU0NTQ1NDU0NTQ1NDVcblx0XHRpZiAoIW1vZGlmeSkgdSA9IFsuLi51XVxuXHRcdHUuZm9yRWFjaCgodiwgaSwgYSkgPT4ge1xuXHRcdFx0YVtpXSA9IHBvdyh2LCBleHBvbmVudClcblx0XHR9KVxuXHRcdHJldHVybiB1XG5cdH1cblx0c3RhdGljIGNzc19jb250YWluKHU6IG51bWJlcltdLCBpbnB1dF9yZXM6IG51bWJlcltdLCB0ZXhfcmVzOiBudW1iZXJbXSk6IG51bWJlcltdIHtcblx0XHRsZXQgdXNlcl9yZXMgPSBpbnB1dF9yZXNcblx0XHRsZXQgY2FudmFzX3JlcyA9IHRleF9yZXNcblxuXHRcdGxldCBpbnB1dF9yYXRpbyA9IHVzZXJfcmVzWzBdIC8gdXNlcl9yZXNbMV1cblx0XHRsZXQgdGV4X3JhdGlvID0gY2FudmFzX3Jlc1swXSAvIGNhbnZhc19yZXNbMV1cblx0XHRsZXQgcmF0aW8gPSBpbnB1dF9yYXRpbyAvIHRleF9yYXRpb1xuXG5cdFx0aWYgKHJhdGlvID4gMSkge1xuXHRcdFx0cmV0dXJuIFt1WzBdICogcmF0aW8sIHVbMV1dXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBbdVswXSwgdVsxXSAvIHJhdGlvXVxuXHRcdH1cblx0fVxuXHRzdGF0aWMgc2NyZWVuX05EQ190b19jYW52YXNfTkRDKHU6IG51bWJlcltdLCB1c2VyX3RleDogVGV4dHVyZSwgY2FudmFzX3RleDogVGV4dHVyZSwgem9vbTogbnVtYmVyLCBwYW46IG51bWJlcltdKTogbnVtYmVyW10ge1xuXHRcdGxldCB1c2VyX3JlcyA9IHVzZXJfdGV4LnJlc1xuXHRcdGxldCBjYW52YXNfcmVzID0gY2FudmFzX3RleC5yZXNcblxuXHRcdHUgPSBbLi4udV1cblxuXHRcdGxldCBpbnB1dF9yYXRpbyA9IHVzZXJfcmVzWzBdIC8gdXNlcl9yZXNbMV1cblx0XHRsZXQgdGV4X3JhdGlvID0gY2FudmFzX3Jlc1swXSAvIGNhbnZhc19yZXNbMV1cblx0XHRsZXQgcmF0aW8gPSBpbnB1dF9yYXRpbyAvIHRleF9yYXRpb1xuXG5cdFx0aWYgKHJhdGlvID4gMSkge1xuXHRcdFx0dVswXSAqPSByYXRpbyAvIHpvb21cblx0XHRcdHVbMV0gLz0gem9vbVxuXG5cdFx0XHRsZXQgY29udCA9IFV0aWxzLmNzc19jb250YWluKFsxLCAxXSwgdXNlcl9yZXMsIGNhbnZhc19yZXMpXG5cblx0XHRcdHVbMF0gLT0gcGFuWzBdICogY29udFswXVxuXHRcdFx0dVsxXSAtPSBwYW5bMV0gKiBjb250WzFdXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHVbMV0gLT0gKDEgLSByYXRpbykgKiAwLjVcblx0XHRcdHVbMF0gLz0gem9vbVxuXHRcdFx0dVsxXSAvPSByYXRpbyAqIHpvb21cblxuXHRcdFx0bGV0IGNvbnQgPSBVdGlscy5jc3NfY29udGFpbihbMSwgMV0sIHVzZXJfcmVzLCBjYW52YXNfcmVzKVxuXG5cdFx0XHR1WzBdIC09IHBhblswXSAqIGNvbnRbMF1cblx0XHRcdHVbMV0gLT0gcGFuWzFdICogY29udFsxXVxuXHRcdH1cblx0XHRyZXR1cm4gdVxuXHR9XG5cdHN0YXRpYyB0ZXh0dXJlX05EQ190b190ZXh0dXJlX3BpeGVsX2Nvb3Jkcyh1OiBudW1iZXJbXSwgdGV4OiBUZXh0dXJlKTogbnVtYmVyW10ge1xuXHRcdHJldHVybiBbKHVbMF0gKiAwLjUgKyAwLjUpICogdGV4LnJlc1swXSwgKHVbMV0gKiAwLjUgKyAwLjUpICogdGV4LnJlc1sxXV1cblx0fVxufVxuIiwiaW1wb3J0IHtCcnVzaFRleHR1cmV9IGZyb20gJ3N0dWZmJ1xuXG5leHBvcnQgZW51bSBCbGVuZGluZ0NvbG91clNwYWNlIHtcblx0UkdCLFxuXHRPa0xDSCxcblx0UGlnbWVudHMsXG59XG5cbmV4cG9ydCBjbGFzcyBEcmF3UGFyYW1zIHtcblx0dGV4X2R5bmFtaWNzOiBudW1iZXIgPSAwLjNcblx0dGV4X2xjaF9keW5hbWljczogbnVtYmVyW10gPSBbMCwgMCwgMC4yXVxuXHR0ZXhfc3RyZXRjaDogbnVtYmVyW10gPSBbMSwgMC4yXVxuXHRibGVuZGluZ19jb2xvdXJfc3BhY2UgPSBCbGVuZGluZ0NvbG91clNwYWNlLlBpZ21lbnRzXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHRleF9keW5hbWljczogbnVtYmVyLFxuXHRcdHRleF9sY2hfZHluYW1pY3M6IG51bWJlcltdLFxuXHRcdHRleF9zdHJldGNoOiBudW1iZXJbXSxcblx0XHRibGVuZGluZ19jb2xvdXJfc3BhY2U6IEJsZW5kaW5nQ29sb3VyU3BhY2UsXG5cdCkge1xuXHRcdHRoaXMudGV4X2R5bmFtaWNzID0gdGV4X2R5bmFtaWNzXG5cdFx0dGhpcy50ZXhfbGNoX2R5bmFtaWNzID0gWy4uLnRleF9sY2hfZHluYW1pY3NdXG5cdFx0dGhpcy50ZXhfc3RyZXRjaCA9IFsuLi50ZXhfc3RyZXRjaF1cblx0XHR0aGlzLmJsZW5kaW5nX2NvbG91cl9zcGFjZSA9IGJsZW5kaW5nX2NvbG91cl9zcGFjZVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBCcnVzaFByZXNldCB7XG5cdHNlbGVjdGVkX2JydXNoX3R5cGU6IEJydXNoVHlwZSA9IEJydXNoVHlwZS5CbG9ic1xuXG5cdGNoYW9zX2xjaDogQXJyYXk8bnVtYmVyPiA9IFswLCAwLCAxXVxuXHRjaGFvc19zcGVlZDogbnVtYmVyID0gMC4zXG5cdGNoYW9zOiBudW1iZXIgPSAwLjdcblxuXHRkeW5hbWljczogbnVtYmVyID0gMC4zXG5cdHN0cm9rZV9vcGFjaXR5X2R5bmFtaWNzOiBudW1iZXJbXSA9IFswLCAxXVxuXHRzdHJva2Vfc2l6ZV9keW5hbWljczogbnVtYmVyW10gPSBbMC43LCAxXVxuXHRyb3Rfaml0dGVyOiBudW1iZXIgPSAwXG5cdHBvc19qaXR0ZXI6IG51bWJlciA9IDBcblxuXHQvLyBAdHMtaWdub3JlXG5cdHNlbGVjdGVkX2JydXNoX3RleHR1cmU6IEJydXNoVGV4dHVyZSA9IHVuZGVmaW5lZFxuXG5cdHRleF9keW5hbWljczogbnVtYmVyID0gMC4zXG5cdHRleF9sY2hfZHluYW1pY3M6IG51bWJlcltdID0gWzAsIDAsIDAuMDJdXG5cdHRleF9zdHJldGNoOiBudW1iZXJbXSA9IFsxLCAwLjJdXG5cblx0Y29uc3RydWN0b3IoKSB7fVxufVxuXG5leHBvcnQgZW51bSBCcnVzaFR5cGUge1xuXHRCbG9icyxcblx0TG9uZyxcblx0VHJpLFxufVxuZXhwb3J0IGNsYXNzIEJydXNoU3Ryb2tlIHtcblx0YnJ1c2hfdHlwZTogQnJ1c2hUeXBlXG5cdGJydXNoX3RleHR1cmU6IEJydXNoVGV4dHVyZVxuXHRkcmF3X3BhcmFtczogRHJhd1BhcmFtc1xuXHRwb3NpdGlvbnM6IG51bWJlcltdID0gW11cblx0cm90YXRpb25zOiBudW1iZXJbXSA9IFtdXG5cdHNpemVzOiBudW1iZXJbXSA9IFtdXG5cdG9wYWNpdGllczogbnVtYmVyW10gPSBbXVxuXHRjb2xvdXJzOiBudW1iZXJbXSA9IFtdXG5cblx0aWR4OiBudW1iZXIgPSAwXG5cdGNvbnN0cnVjdG9yKGJydXNoX3R5cGU6IEJydXNoVHlwZSwgZHJhd19wYXJhbXM6IERyYXdQYXJhbXMsIGJydXNoX3RleHR1cmU6IEJydXNoVGV4dHVyZSkge1xuXHRcdHRoaXMuZHJhd19wYXJhbXMgPSBkcmF3X3BhcmFtc1xuXHRcdHRoaXMuYnJ1c2hfdHlwZSA9IGJydXNoX3R5cGVcblx0XHR0aGlzLmJydXNoX3RleHR1cmUgPSBicnVzaF90ZXh0dXJlXG5cdH1cblx0cHVzaF9zdHJva2UocG9zaXRpb246IG51bWJlcltdLCByb3RhdGlvbjogbnVtYmVyW10sIHNpemU6IG51bWJlcltdLCBvcGFjaXR5OiBudW1iZXIsIGNvbG91cjogbnVtYmVyW10pIHtcblx0XHQvLyBhc3NlcnQocG9zaXRpb24ubGVuZ3RoID09PSAyKVxuXHRcdC8vIGFzc2VydChyb3RhdGlvbi5sZW5ndGggPT09IDIpXG5cdFx0Ly8gYXNzZXJ0KGNvbG91ci5sZW5ndGggPT09IDMpXG5cdFx0Y29uc3QgY3Vycl9pZHggPSB0aGlzLmlkeFxuXHRcdHRoaXMucG9zaXRpb25zLmxlbmd0aCArPSAyXG5cdFx0dGhpcy5yb3RhdGlvbnMubGVuZ3RoICs9IDJcblx0XHR0aGlzLnNpemVzLmxlbmd0aCArPSAyXG5cdFx0dGhpcy5vcGFjaXRpZXMubGVuZ3RoICs9IDFcblx0XHR0aGlzLmNvbG91cnMubGVuZ3RoICs9IDNcblx0XHR0aGlzLnBvc2l0aW9uc1tjdXJyX2lkeCAqIDJdID0gcG9zaXRpb25bMF1cblx0XHR0aGlzLnBvc2l0aW9uc1tjdXJyX2lkeCAqIDIgKyAxXSA9IHBvc2l0aW9uWzFdXG5cdFx0dGhpcy5zaXplc1tjdXJyX2lkeCAqIDJdID0gc2l6ZVswXVxuXHRcdHRoaXMuc2l6ZXNbY3Vycl9pZHggKiAyICsgMV0gPSBzaXplWzFdXG5cdFx0dGhpcy5yb3RhdGlvbnNbY3Vycl9pZHggKiAyXSA9IHJvdGF0aW9uWzBdXG5cdFx0dGhpcy5yb3RhdGlvbnNbY3Vycl9pZHggKiAyICsgMV0gPSByb3RhdGlvblsxXVxuXHRcdHRoaXMub3BhY2l0aWVzW2N1cnJfaWR4XSA9IG9wYWNpdHlcblx0XHR0aGlzLmNvbG91cnNbY3Vycl9pZHggKiAzXSA9IGNvbG91clswXVxuXHRcdHRoaXMuY29sb3Vyc1tjdXJyX2lkeCAqIDMgKyAxXSA9IGNvbG91clsxXVxuXHRcdHRoaXMuY29sb3Vyc1tjdXJyX2lkeCAqIDMgKyAyXSA9IGNvbG91clsyXVxuXHRcdHRoaXMuaWR4Kytcblx0fVxufVxuIiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBCcnVzaFByZXNldCwgQnJ1c2hUeXBlIH0gZnJvbSAnYnJ1c2hfc3Ryb2tlJ1xuXHRpbXBvcnQge29uTW91bnR9IGZyb20gJ3N2ZWx0ZSdcbiAgXG5cblx0Ly8gQHRzLWlnbm9yZVxuXHRpbXBvcnQgYnJ1c2hfYmxvYnNfaWNvbiBmcm9tICcvLi4vcHVibGljL2JydXNoLWJsb2JzLnN2Zydcblx0Ly8gQHRzLWlnbm9yZVxuXHRpbXBvcnQgYnJ1c2hfbG9uZ19pY29uIGZyb20gJy8uLi9wdWJsaWMvYnJ1c2gtbG9uZy5zdmcnXG5cdC8vIEB0cy1pZ25vcmVcblx0aW1wb3J0IGJydXNoX3RyaWFuZ2xlc19pY29uIGZyb20gJy8uLi9wdWJsaWMvYnJ1c2gtdHJpYW5nbGVzLnN2ZydcblxuXG4gIGV4cG9ydCBsZXQgY3Vycl9icnVzaDogQnJ1c2hQcmVzZXQ7XG4gIGxldCBzZWxlY3RlZF9icnVzaF90eXBlOiBCcnVzaFR5cGU7XG5cblxuICBsZXQgZWxlbWVudHM6IEhUTUxEaXZFbGVtZW50W10gPSBbXVxuICBsZXQgYnJ1c2hfdHlwZXM6IHN0cmluZ1tdID0gWyBdXG4gIGZvcihsZXQgdHlwZSBvZiBPYmplY3Qua2V5cyhCcnVzaFR5cGUpLmZpbHRlcigodikgPT4gaXNOYU4oTnVtYmVyKHYpKSkpe1xuICAgIGJydXNoX3R5cGVzLnB1c2godHlwZSlcbiAgICBlbGVtZW50cy5sZW5ndGgrK1xuICB9XG5cbiAgY29uc3QgdXBkYXRlX3N0eWxlcyA9ICgpPT57XG4gICAgbGV0IGsgPSAwIFxuICAgIHRyeXtcbiAgICAgIGZvcihsZXQgZWxlbWVudCBvZiBlbGVtZW50cyl7XG4gICAgICAgIGxldCBicnVzaF90eXBlID0gYnJ1c2hfdHlwZXNba11cbiAgICAgICAgbGV0IGJydXNoX3R5cGVfaW50ID0gQnJ1c2hUeXBlW2JydXNoX3R5cGVzW2tdXVxuICAgICAgICBpZihicnVzaF90eXBlX2ludCA9PT0gc2VsZWN0ZWRfYnJ1c2hfdHlwZSl7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJzFweCBzb2xpZCB3aGl0ZSdcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm91dGxpbmVPZmZzZXQgPSAnMC4xcmVtJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICcwcHggc29saWQgd2hpdGUnXG4gICAgICAgIH1cbiAgICAgICAgaysrXG4gICAgICB9XG4gICAgfSBjYXRjaChfKXtcblxuICAgIH1cbiAgfVxuICBcbiAgJDoge1xuICAgIHNlbGVjdGVkX2JydXNoX3R5cGUgPSBjdXJyX2JydXNoLnNlbGVjdGVkX2JydXNoX3R5cGVcbiAgICB1cGRhdGVfc3R5bGVzKClcbiAgfVxuICBcblxuICBvbk1vdW50KCgpPT57XG4gICAgdXBkYXRlX3N0eWxlcygpXG4gIH0pXG48L3NjcmlwdD5cblxuXG48ZGl2IGNsYXNzPSdrbm9iLWNvbnRhaW5lci1jb250YWluZXInPlxuICB7I2VhY2ggYnJ1c2hfdHlwZXMgYXMgYnJ1c2hfdHlwZSwgaX1cbiAgICA8ZGl2IFxuICAgICAgY2xhc3M9XCJ0aXRsZSBtZW51LXRvZ2dsZVwiIFxuICAgICAgYmluZDp0aGlzPXtlbGVtZW50c1tpXX1cbiAgICAgIHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBcbiAgICAgIG9uOmNsaWNrPXsoKT0+e1xuICAgICAgICBjdXJyX2JydXNoLnNlbGVjdGVkX2JydXNoX3R5cGUgPSBCcnVzaFR5cGVbYnJ1c2hfdHlwZV1cbiAgICAgICAgbGV0IGsgPSAwXG4gICAgICAgIGZvcihsZXQgZWxlbWVudCBvZiBlbGVtZW50cyl7XG4gICAgICAgICAgaWYoayA9PT0gaSl7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnMXB4IHNvbGlkIHdoaXRlJ1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5vdXRsaW5lT2Zmc2V0ID0gJzAuMXJlbSdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJzBweCBzb2xpZCB3aGl0ZSdcbiAgICAgICAgICB9XG4gICAgICAgICAgaysrXG4gICAgICAgIH1cbiAgICAgIH19XG4gICAgICBzdHlsZT0nY3Vyc29yOiBwb2ludGVyOydcbiAgICAgID5cbiAgICAgIFxuICAgICAge0BodG1sIGkgPT09IDAgPyBicnVzaF9ibG9ic19pY29uIDogaSA9PT0gMSA/IGJydXNoX2xvbmdfaWNvbiA6IGJydXNoX3RyaWFuZ2xlc19pY29ufVxuXG4gICAgPC9kaXY+XG4gIHsvZWFjaH1cbjwvZGl2PlxuICBcbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAqe1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjp0cmFuc3BhcmVudDtcbiAgfVxuICAua25vYi1jb250YWluZXItY29udGFpbmVye1xuICAgIGFzcGVjdC1yYXRpbzogMS8xO1xuICAgIG1heC1oZWlnaHQ6IDUwJTtcbiAgICBtYXJnaW4tdG9wOiAwLjVyZW07XG4gICAgbWFyZ2luLWJvdHRvbTogYXV0bztcbiAgICBtYXJnaW4tcmlnaHQ6IDEuNXJlbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBtaW4td2lkdGg6IDdyZW07XG4gICAgXG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgbWFyZ2luOiAwO1xuICAgIG1hcmdpbi1yaWdodDogMC41cmVtO1xuICAgIG1pbi1oZWlnaHQ6IHVuc2V0O1xuICAgIG1pbi13aWR0aDogdW5zZXQ7XG4gICAgbWF4LWhlaWdodDogMS42cmVtICFpbXBvcnRhbnQ7XG4gIH1cbiAgLmtub2ItY29udGFpbmVyLWNvbnRhaW5lcj4udGl0bGUubWVudS10b2dnbGV7XG4gICAgOmdsb2JhbChzdmcpe1xuICAgICAgZmlsbDogd2hpdGU7XG4gICAgICAmOmFjdGl2ZXtcbiAgICAgICAgZmlsdGVyOiBpbnZlcnQoMSk7XG4gICAgICAgIGJhY2tncm91bmQ6IGJsYWNrO1xuICAgICAgfVxuICAgIH1cblxuLyogYmFja2dyb3VuZDogd2hpdGU7ICovXG4gICAgLyogY29sb3I6IGJsYWNrOyAqL1xuICB9XG4gIC5rbm9iLWNvbnRhaW5lci1jb250YWluZXI+LnRpdGxlIHtcbiAgICBcbiAgICAvKiBwb3NpdGlvbjogYWJzb2x1dGU7ICovXG4gICAgZm9udC1zaXplOiAwLjhyZW0gIWltcG9ydGFudDtcbiAgICAvKiBwb3NpdGlvbjogYWJzb2x1dGU7ICovXG4gICAgbWFyZ2luLXRvcDogMC41cmVtO1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcbiAgICB0b3A6IDUuNXJlbTtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgfVxuPC9zdHlsZT4iLCI8c3ZlbHRlOm9wdGlvbnMgYWNjZXNzb3JzIC8+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IEJydXNoUHJlc2V0LCBCcnVzaFR5cGUgfSBmcm9tICdicnVzaF9zdHJva2UnXG5cdGltcG9ydCB7b25Nb3VudH0gZnJvbSAnc3ZlbHRlJ1xuXG4gIC8vIGV4cG9ydCBsZXQgc2VsZWN0ZWRfYnJ1c2hfdHlwZTogQnJ1c2hUeXBlO1xuICBleHBvcnQgbGV0IGJydXNoX3ByZXNldHM6IEJydXNoUHJlc2V0W11cbiAgZXhwb3J0IGxldCBzZWxlY3RlZF9icnVzaF9wcmVzZXQ6IEJydXNoUHJlc2V0XG5cbiAgbGV0IGVsZW1lbnRzOiBIVE1MRGl2RWxlbWVudFtdID0gW11cbiAgZm9yKGxldCBwcmVzZXQgb2YgYnJ1c2hfcHJlc2V0cyl7XG4gICAgZWxlbWVudHMubGVuZ3RoKytcbiAgfVxuXG4gIG9uTW91bnQoKCk9PntcbiAgICBsZXQgayA9IDAgXG4gICAgZm9yKGxldCBlbGVtZW50IG9mIGVsZW1lbnRzKXtcbiAgICAgIGlmKHNlbGVjdGVkX2JydXNoX3ByZXNldCA9PT0gYnJ1c2hfcHJlc2V0c1trXSl7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICcxcHggc29saWQgd2hpdGUnXG4gICAgICAgIGVsZW1lbnQuc3R5bGUub3V0bGluZU9mZnNldCA9ICcwLjFyZW0nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnMHB4IHNvbGlkIHdoaXRlJ1xuICAgICAgfVxuICAgICAgaysrXG4gICAgfVxuICB9KVxuPC9zY3JpcHQ+XG5cblxuPGRpdiBjbGFzcz0na25vYi1jb250YWluZXItY29udGFpbmVyJz5cbiAgeyNlYWNoIGJydXNoX3ByZXNldHMgYXMgcHJlc2V0LCBpfVxuICAgIDxkaXYgXG4gICAgICBjbGFzcz1cInRpdGxlIG1lbnUtdG9nZ2xlXCIgXG4gICAgICBiaW5kOnRoaXM9e2VsZW1lbnRzW2ldfVxuICAgICAgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIFxuICAgICAgb246Y2xpY2s9eygpPT57XG4gICAgICAgIHNlbGVjdGVkX2JydXNoX3ByZXNldCA9IHByZXNldFxuICAgICAgICBsZXQgayA9IDBcbiAgICAgICAgZm9yKGxldCBlbGVtZW50IG9mIGVsZW1lbnRzKXtcbiAgICAgICAgICBpZihrID09PSBpKXtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICcxcHggc29saWQgd2hpdGUnXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLm91dGxpbmVPZmZzZXQgPSAnMC4xcmVtJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnMHB4IHNvbGlkIHdoaXRlJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBrKytcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAgIHN0eWxlPSdjdXJzb3I6IHBvaW50ZXI7J1xuICAgICAgPntpLnRvU3RyaW5nKCl9PC9kaXY+XG4gIHsvZWFjaH1cbjwvZGl2PlxuICBcbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAqe1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjp0cmFuc3BhcmVudDtcbiAgfVxuICAua25vYi1jb250YWluZXItY29udGFpbmVye1xuICAgIGFzcGVjdC1yYXRpbzogMS8xO1xuICAgIG1heC1oZWlnaHQ6IDc1JTtcbiAgICBtYXJnaW4tdG9wOiAwLjdyZW07XG4gICAgbWFyZ2luLWJvdHRvbTogYXV0bztcbiAgICBtYXJnaW4tcmlnaHQ6IDJyZW07XG5cbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIC8vIGhlaWdodDogMTAwJTtcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IGZpdC1jb250ZW50KDhjaCkgZml0LWNvbnRlbnQoOGNoKSAxZnI7XG4gICAgLy8gZ3JpZC1hdXRvLXJvd3M6IG1pbm1heCg2N3B4LCBhdXRvKTtcblxuICAgIC8qIGp1c3RpZnktY29udGVudDogY2VudGVyOyAqL1xuICAgIC8qIGFsaWduLWl0ZW1zOiBjZW50ZXI7ICovXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgd2lkdGg6IGZpdC1jb250ZW50O1xuICAgIC8qIG1pbi13aWR0aDogN3JlbTsgKi9cbiAgfVxuICAua25vYi1jb250YWluZXItY29udGFpbmVyPi50aXRsZS5tZW51LXRvZ2dsZXtcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICBjb2xvcjogYmxhY2s7XG4gICAgd2lkdGg6IDQ5JTtcbiAgICBoZWlnaHQ6IDcwJTtcbiAgICAvLyBtYXJnaW46IDAuNnJlbTtcbiAgfVxuICAua25vYi1jb250YWluZXItY29udGFpbmVyPi50aXRsZSB7XG4gICAgXG4gICAgcGFkZGluZzogMC4ycmVtO1xuICAgIC8qIHBvc2l0aW9uOiBhYnNvbHV0ZTsgKi9cbiAgICBmb250LXNpemU6IDAuOHJlbSAhaW1wb3J0YW50O1xuICAgIC8qIHBvc2l0aW9uOiBhYnNvbHV0ZTsgKi9cbiAgICBtYXJnaW46IDAuM3JlbTtcbiAgICBjb2xvcjogd2hpdGU7XG4gICAgLy8gd2lkdGg6IDEwMCU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XG4gICAgLy8gdG9wOiA1LjVyZW07XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIH1cbjwvc3R5bGU+IiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAvLyBAdHMtaWdub3JlXG4gIGltcG9ydCB1bmRvSWNvbiBmcm9tIFwiLy4uL3B1YmxpYy91bmRvLnN2Z1wiXG4gIC8vIEB0cy1pZ25vcmVcbiAgaW1wb3J0IHJlZG9JY29uIGZyb20gXCIvLi4vcHVibGljL3JlZG8uc3ZnXCIgXG4gIFxuICBcbiAgZXhwb3J0IGxldCByZWRvOiAoKT0+dm9pZFxuICBleHBvcnQgbGV0IHVuZG86ICgpPT52b2lkXG4gIFxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9J2tub2ItY29udGFpbmVyJz5cbiAgPGRpdiBjbGFzcz1cImtub2JcIiBvbjpjbGljaz17KCk9PnVuZG8oKX0+XG4gICAge0BodG1sIHVuZG9JY29ufVxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cImtub2JcIiBvbjpjbGljaz17KCk9PnJlZG8oKX0+XG4gICAge0BodG1sIHJlZG9JY29ufVxuICA8L2Rpdj5cbjwvZGl2PlxuXG5cbjwhLS0gPHN0eWxlIHNyYz0nLy4uL3N0eWxlcy9pY29uLnNjc3MnPiA8L3N0eWxlPiAtLT5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAqe1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjp0cmFuc3BhcmVudDtcbiAgfSBcblxuICBAaW1wb3J0IFwiLy4uL3N0eWxlcy9pY29uLnNjc3NcIiBzY29wZWQ7IFxuXG48L3N0eWxlPiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBGaXJlYmFzZSBjb25zdGFudHMuICBTb21lIG9mIHRoZXNlIChAZGVmaW5lcykgY2FuIGJlIG92ZXJyaWRkZW4gYXQgY29tcGlsZS10aW1lLlxuICovXG5cbmV4cG9ydCBjb25zdCBDT05TVEFOVFMgPSB7XG4gIC8qKlxuICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cbiAgICovXG4gIE5PREVfQ0xJRU5UOiBmYWxzZSxcbiAgLyoqXG4gICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgQWRtaW4gTm9kZS5qcyBTREsuXG4gICAqL1xuICBOT0RFX0FETUlOOiBmYWxzZSxcblxuICAvKipcbiAgICogRmlyZWJhc2UgU0RLIFZlcnNpb25cbiAgICovXG4gIFNES19WRVJTSU9OOiAnJHtKU0NPUkVfVkVSU0lPTn0nXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgYXNzZXJ0aW9uIGlzIGZhbHN5XG4gKi9cbmV4cG9ydCBjb25zdCBhc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uOiB1bmtub3duLCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICB0aHJvdyBhc3NlcnRpb25FcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIEVycm9yIG9iamVjdCBzdWl0YWJsZSBmb3IgdGhyb3dpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBhc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlOiBzdHJpbmcpOiBFcnJvciB7XG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgJ0ZpcmViYXNlIERhdGFiYXNlICgnICtcbiAgICAgIENPTlNUQU5UUy5TREtfVkVSU0lPTiArXG4gICAgICAnKSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOiAnICtcbiAgICAgIG1lc3NhZ2VcbiAgKTtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZyk6IG51bWJlcltdIHtcbiAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcbiAgY29uc3Qgb3V0OiBudW1iZXJbXSA9IFtdO1xuICBsZXQgcCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgb3V0W3ArK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuICAgICAgaSArIDEgPCBzdHIubGVuZ3RoICYmXG4gICAgICAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmYzAwKSA9PT0gMHhkYzAwXG4gICAgKSB7XG4gICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgwM2ZmKTtcbiAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xuICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgbnVtYmVycyBpbnRvIHRoZSBzdHJpbmcgZ2l2ZW4gYnkgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXG4gKiBjaGFyYWN0ZXJzIHRvIHdoaWNoIHRoZSBudW1iZXJzIGNvcnJlc3BvbmQuXG4gKiBAcGFyYW0gYnl0ZXMgQXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgY2hhcmFjdGVycy5cbiAqIEByZXR1cm4gU3RyaW5naWZpY2F0aW9uIG9mIHRoZSBhcnJheS5cbiAqL1xuY29uc3QgYnl0ZUFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAoYnl0ZXM6IG51bWJlcltdKTogc3RyaW5nIHtcbiAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcbiAgY29uc3Qgb3V0OiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgcG9zID0gMCxcbiAgICBjID0gMDtcbiAgd2hpbGUgKHBvcyA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIGNvbnN0IGMxID0gYnl0ZXNbcG9zKytdO1xuICAgIGlmIChjMSA8IDEyOCkge1xuICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxKTtcbiAgICB9IGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XG4gICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcbiAgICB9IGVsc2UgaWYgKGMxID4gMjM5ICYmIGMxIDwgMzY1KSB7XG4gICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XG4gICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcbiAgICAgIGNvbnN0IGM0ID0gYnl0ZXNbcG9zKytdO1xuICAgICAgY29uc3QgdSA9XG4gICAgICAgICgoKGMxICYgNykgPDwgMTgpIHwgKChjMiAmIDYzKSA8PCAxMikgfCAoKGMzICYgNjMpIDw8IDYpIHwgKGM0ICYgNjMpKSAtXG4gICAgICAgIDB4MTAwMDA7XG4gICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKHUgPj4gMTApKTtcbiAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAodSAmIDEwMjMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XG4gICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcbiAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgKChjMSAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0LmpvaW4oJycpO1xufTtcblxuaW50ZXJmYWNlIEJhc2U2NCB7XG4gIGJ5dGVUb0NoYXJNYXBfOiB7IFtrZXk6IG51bWJlcl06IHN0cmluZyB9IHwgbnVsbDtcbiAgY2hhclRvQnl0ZU1hcF86IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gfCBudWxsO1xuICBieXRlVG9DaGFyTWFwV2ViU2FmZV86IHsgW2tleTogbnVtYmVyXTogc3RyaW5nIH0gfCBudWxsO1xuICBjaGFyVG9CeXRlTWFwV2ViU2FmZV86IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gfCBudWxsO1xuICBFTkNPREVEX1ZBTFNfQkFTRTogc3RyaW5nO1xuICByZWFkb25seSBFTkNPREVEX1ZBTFM6IHN0cmluZztcbiAgcmVhZG9ubHkgRU5DT0RFRF9WQUxTX1dFQlNBRkU6IHN0cmluZztcbiAgSEFTX05BVElWRV9TVVBQT1JUOiBib29sZWFuO1xuICBlbmNvZGVCeXRlQXJyYXkoaW5wdXQ6IG51bWJlcltdIHwgVWludDhBcnJheSwgd2ViU2FmZT86IGJvb2xlYW4pOiBzdHJpbmc7XG4gIGVuY29kZVN0cmluZyhpbnB1dDogc3RyaW5nLCB3ZWJTYWZlPzogYm9vbGVhbik6IHN0cmluZztcbiAgZGVjb2RlU3RyaW5nKGlucHV0OiBzdHJpbmcsIHdlYlNhZmU6IGJvb2xlYW4pOiBzdHJpbmc7XG4gIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0OiBzdHJpbmcsIHdlYlNhZmU6IGJvb2xlYW4pOiBudW1iZXJbXTtcbiAgaW5pdF8oKTogdm9pZDtcbn1cblxuLy8gV2UgZGVmaW5lIGl0IGFzIGFuIG9iamVjdCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjbGFzcyBiZWNhdXNlIGEgY2xhc3MgY29tcGlsZWQgZG93biB0byBlczUgY2FuJ3Rcbi8vIGJlIHRyZWVzaGFrZWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xNjkxXG4vLyBTdGF0aWMgbG9va3VwIG1hcHMsIGxhemlseSBwb3B1bGF0ZWQgYnkgaW5pdF8oKVxuZXhwb3J0IGNvbnN0IGJhc2U2NDogQmFzZTY0ID0ge1xuICAvKipcbiAgICogTWFwcyBieXRlcyB0byBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgYnl0ZVRvQ2hhck1hcF86IG51bGwsXG5cbiAgLyoqXG4gICAqIE1hcHMgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICovXG4gIGNoYXJUb0J5dGVNYXBfOiBudWxsLFxuXG4gIC8qKlxuICAgKiBNYXBzIGJ5dGVzIHRvIHdlYnNhZmUgY2hhcmFjdGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogbnVsbCxcblxuICAvKipcbiAgICogTWFwcyB3ZWJzYWZlIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjaGFyVG9CeXRlTWFwV2ViU2FmZV86IG51bGwsXG5cbiAgLyoqXG4gICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LCBzaGFyZWQgYmV0d2VlblxuICAgKiBFTkNPREVEX1ZBTFMgYW5kIEVOQ09ERURfVkFMU19XRUJTQUZFXG4gICAqL1xuICBFTkNPREVEX1ZBTFNfQkFTRTpcbiAgICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICsgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArICcwMTIzNDU2Nzg5JyxcblxuICAvKipcbiAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQuIFZhbHVlIDY0ICg9KSBpcyBzcGVjaWFsOyBpdCBtZWFucyBcIm5vdGhpbmcuXCJcbiAgICovXG4gIGdldCBFTkNPREVEX1ZBTFMoKSB7XG4gICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnKy89JztcbiAgfSxcblxuICAvKipcbiAgICogT3VyIHdlYnNhZmUgYWxwaGFiZXQuXG4gICAqL1xuICBnZXQgRU5DT0RFRF9WQUxTX1dFQlNBRkUoKSB7XG4gICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcbiAgfSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGF0b2IgYW5kIGJ0b2EgZnVuY3Rpb25zLiBUaGlzIGV4dGVuc2lvblxuICAgKiBzdGFydGVkIGF0IE1vemlsbGEgYnV0IGlzIG5vdyBpbXBsZW1lbnRlZCBieSBtYW55IGJyb3dzZXJzLiBXZSB1c2UgdGhlXG4gICAqIEFTU1VNRV8qIHZhcmlhYmxlcyB0byBhdm9pZCBwdWxsaW5nIGluIHRoZSBmdWxsIHVzZXJhZ2VudCBkZXRlY3Rpb24gbGlicmFyeVxuICAgKiBidXQgc3RpbGwgYWxsb3dpbmcgdGhlIHN0YW5kYXJkIHBlci1icm93c2VyIGNvbXBpbGF0aW9ucy5cbiAgICpcbiAgICovXG4gIEhBU19OQVRJVkVfU1VQUE9SVDogdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicsXG5cbiAgLyoqXG4gICAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dCBBbiBhcnJheSBvZiBieXRlcyAobnVtYmVycyB3aXRoXG4gICAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxuICAgKiBAcGFyYW0gd2ViU2FmZSBCb29sZWFuIGluZGljYXRpbmcgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAqL1xuICBlbmNvZGVCeXRlQXJyYXkoaW5wdXQ6IG51bWJlcltdIHwgVWludDhBcnJheSwgd2ViU2FmZT86IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRfKCk7XG5cbiAgICBjb25zdCBieXRlVG9DaGFyTWFwID0gd2ViU2FmZVxuICAgICAgPyB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlXyFcbiAgICAgIDogdGhpcy5ieXRlVG9DaGFyTWFwXyE7XG5cbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIGNvbnN0IGJ5dGUxID0gaW5wdXRbaV07XG4gICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpICsgMSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gaW5wdXRbaSArIDFdIDogMDtcbiAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgKyAyIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBpbnB1dFtpICsgMl0gOiAwO1xuXG4gICAgICBjb25zdCBvdXRCeXRlMSA9IGJ5dGUxID4+IDI7XG4gICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTEgJiAweDAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcbiAgICAgIGxldCBvdXRCeXRlMyA9ICgoYnl0ZTIgJiAweDBmKSA8PCAyKSB8IChieXRlMyA+PiA2KTtcbiAgICAgIGxldCBvdXRCeXRlNCA9IGJ5dGUzICYgMHgzZjtcblxuICAgICAgaWYgKCFoYXZlQnl0ZTMpIHtcbiAgICAgICAgb3V0Qnl0ZTQgPSA2NDtcblxuICAgICAgICBpZiAoIWhhdmVCeXRlMikge1xuICAgICAgICAgIG91dEJ5dGUzID0gNjQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3V0cHV0LnB1c2goXG4gICAgICAgIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTFdLFxuICAgICAgICBieXRlVG9DaGFyTWFwW291dEJ5dGUyXSxcbiAgICAgICAgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlM10sXG4gICAgICAgIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTRdXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhc2U2NC1lbmNvZGUgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dCBBIHN0cmluZyB0byBlbmNvZGUuXG4gICAqIEBwYXJhbSB3ZWJTYWZlIElmIHRydWUsIHdlIHNob3VsZCB1c2UgdGhlXG4gICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICogQHJldHVybiBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICAgKi9cbiAgZW5jb2RlU3RyaW5nKGlucHV0OiBzdHJpbmcsIHdlYlNhZmU/OiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxuICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIXdlYlNhZmUpIHtcbiAgICAgIHJldHVybiBidG9hKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlQnl0ZUFycmF5KHN0cmluZ1RvQnl0ZUFycmF5KGlucHV0KSwgd2ViU2FmZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dCB0byBkZWNvZGUuXG4gICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXG4gICAqL1xuICBkZWNvZGVTdHJpbmcoaW5wdXQ6IHN0cmluZywgd2ViU2FmZTogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcbiAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXG4gICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XG4gICAgICByZXR1cm4gYXRvYihpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gICAqXG4gICAqIEluIGJhc2UtNjQgZGVjb2RpbmcsIGdyb3VwcyBvZiBmb3VyIGNoYXJhY3RlcnMgYXJlIGNvbnZlcnRlZCBpbnRvIHRocmVlXG4gICAqIGJ5dGVzLiAgSWYgdGhlIGVuY29kZXIgZGlkIG5vdCBhcHBseSBwYWRkaW5nLCB0aGUgaW5wdXQgbGVuZ3RoIG1heSBub3RcbiAgICogYmUgYSBtdWx0aXBsZSBvZiA0LlxuICAgKlxuICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBsYXN0IGdyb3VwIHdpbGwgaGF2ZSBmZXdlciB0aGFuIDQgY2hhcmFjdGVycywgYW5kXG4gICAqIHBhZGRpbmcgd2lsbCBiZSBpbmZlcnJlZC4gIElmIHRoZSBncm91cCBoYXMgb25lIG9yIHR3byBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzXG4gICAqIHRvIG9uZSBieXRlLiAgSWYgdGhlIGdyb3VwIGhhcyB0aHJlZSBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzIHRvIHR3byBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IElucHV0IHRvIGRlY29kZS5cbiAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZSB3ZWItc2FmZSBhbHBoYWJldC5cbiAgICogQHJldHVybiBieXRlcyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXG4gICAqL1xuICBkZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dDogc3RyaW5nLCB3ZWJTYWZlOiBib29sZWFuKTogbnVtYmVyW10ge1xuICAgIHRoaXMuaW5pdF8oKTtcblxuICAgIGNvbnN0IGNoYXJUb0J5dGVNYXAgPSB3ZWJTYWZlXG4gICAgICA/IHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfIVxuICAgICAgOiB0aGlzLmNoYXJUb0J5dGVNYXBfITtcblxuICAgIGNvbnN0IG91dHB1dDogbnVtYmVyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyApIHtcbiAgICAgIGNvbnN0IGJ5dGUxID0gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSsrKV07XG5cbiAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDA7XG4gICAgICArK2k7XG5cbiAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICBjb25zdCBieXRlMyA9IGhhdmVCeXRlMyA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICAgKytpO1xuXG4gICAgICBjb25zdCBoYXZlQnl0ZTQgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgY29uc3QgYnl0ZTQgPSBoYXZlQnl0ZTQgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcbiAgICAgICsraTtcblxuICAgICAgaWYgKGJ5dGUxID09IG51bGwgfHwgYnl0ZTIgPT0gbnVsbCB8fCBieXRlMyA9PSBudWxsIHx8IGJ5dGU0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IERlY29kZUJhc2U2NFN0cmluZ0Vycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG91dEJ5dGUxID0gKGJ5dGUxIDw8IDIpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTEpO1xuXG4gICAgICBpZiAoYnl0ZTMgIT09IDY0KSB7XG4gICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMiA8PCA0KSAmIDB4ZjApIHwgKGJ5dGUzID4+IDIpO1xuICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMik7XG5cbiAgICAgICAgaWYgKGJ5dGU0ICE9PSA2NCkge1xuICAgICAgICAgIGNvbnN0IG91dEJ5dGUzID0gKChieXRlMyA8PCA2KSAmIDB4YzApIHwgYnl0ZTQ7XG4gICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6eSBzdGF0aWMgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24uIENhbGxlZCBiZWZvcmVcbiAgICogYWNjZXNzaW5nIGFueSBvZiB0aGUgc3RhdGljIG1hcCB2YXJpYWJsZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0XygpIHtcbiAgICBpZiAoIXRoaXMuYnl0ZVRvQ2hhck1hcF8pIHtcbiAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF8gPSB7fTtcbiAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF8gPSB7fTtcbiAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfID0ge307XG4gICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlXyA9IHt9O1xuXG4gICAgICAvLyBXZSB3YW50IHF1aWNrIG1hcHBpbmdzIGJhY2sgYW5kIGZvcnRoLCBzbyB3ZSBwcmVjb21wdXRlIHR3byBtYXBzLlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVOQ09ERURfVkFMUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpO1xuICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuYnl0ZVRvQ2hhck1hcF9baV1dID0gaTtcbiAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV0gPSB0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKTtcbiAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV1dID0gaTtcblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcgd2hlbiBkZWNvZGluZyBhbmQgY29ycmVjdGx5IGRlY29kZSBib3RoIGVuY29kaW5ncy5cbiAgICAgICAgaWYgKGkgPj0gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQW4gZXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZGVjb2RpbmcgYmFzZTY0IHN0cmluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIERlY29kZUJhc2U2NFN0cmluZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSBuYW1lID0gJ0RlY29kZUJhc2U2NFN0cmluZ0Vycm9yJztcbn1cblxuLyoqXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5KHN0cik7XG4gIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyAod2l0aG91dCBcIi5cIiBwYWRkaW5nIGluIHRoZSBlbmQpLlxuICogZS5nLiBVc2VkIGluIEpTT04gV2ViIFRva2VuIChKV1QpIHBhcnRzLlxuICovXG5leHBvcnQgY29uc3QgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgPSBmdW5jdGlvbiAoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBVc2UgYmFzZTY0dXJsIGVuY29kaW5nIGFuZCByZW1vdmUgcGFkZGluZyBpbiB0aGUgZW5kIChkb3QgY2hhcmFjdGVycykuXG4gIHJldHVybiBiYXNlNjRFbmNvZGUoc3RyKS5yZXBsYWNlKC9cXC4vZywgJycpO1xufTtcblxuLyoqXG4gKiBVUkwtc2FmZSBiYXNlNjQgZGVjb2RpbmdcbiAqXG4gKiBOT1RFOiBETyBOT1QgdXNlIHRoZSBnbG9iYWwgYXRvYigpIGZ1bmN0aW9uIC0gaXQgZG9lcyBOT1Qgc3VwcG9ydCB0aGVcbiAqIGJhc2U2NFVybCB2YXJpYW50IGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgVG8gYmUgZGVjb2RlZFxuICogQHJldHVybiBEZWNvZGVkIHJlc3VsdCwgaWYgcG9zc2libGVcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U2NERlY29kZSA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICB0cnkge1xuICAgIHJldHVybiBiYXNlNjQuZGVjb2RlU3RyaW5nKHN0ciwgdHJ1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKCdiYXNlNjREZWNvZGUgZmFpbGVkOiAnLCBlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIERvIGEgZGVlcC1jb3B5IG9mIGJhc2ljIEphdmFTY3JpcHQgT2JqZWN0cyBvciBBcnJheXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ29weTxUPih2YWx1ZTogVCk6IFQge1xuICByZXR1cm4gZGVlcEV4dGVuZCh1bmRlZmluZWQsIHZhbHVlKSBhcyBUO1xufVxuXG4vKipcbiAqIENvcHkgcHJvcGVydGllcyBmcm9tIHNvdXJjZSB0byB0YXJnZXQgKHJlY3Vyc2l2ZWx5IGFsbG93cyBleHRlbnNpb25cbiAqIG9mIE9iamVjdHMgYW5kIEFycmF5cykuICBTY2FsYXIgdmFsdWVzIGluIHRoZSB0YXJnZXQgYXJlIG92ZXItd3JpdHRlbi5cbiAqIElmIHRhcmdldCBpcyB1bmRlZmluZWQsIGFuIG9iamVjdCBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZSB3aWxsIGJlIGNyZWF0ZWRcbiAqIChhbmQgcmV0dXJuZWQpLlxuICpcbiAqIFdlIHJlY3Vyc2l2ZWx5IGNvcHkgYWxsIGNoaWxkIHByb3BlcnRpZXMgb2YgcGxhaW4gT2JqZWN0cyBpbiB0aGUgc291cmNlLSBzb1xuICogdGhhdCBuYW1lc3BhY2UtIGxpa2UgZGljdGlvbmFyaWVzIGFyZSBtZXJnZWQuXG4gKlxuICogTm90ZSB0aGF0IHRoZSB0YXJnZXQgY2FuIGJlIGEgZnVuY3Rpb24sIGluIHdoaWNoIGNhc2UgdGhlIHByb3BlcnRpZXMgaW5cbiAqIHRoZSBzb3VyY2UgT2JqZWN0IGFyZSBjb3BpZWQgb250byBpdCBhcyBzdGF0aWMgcHJvcGVydGllcyBvZiB0aGUgRnVuY3Rpb24uXG4gKlxuICogTm90ZTogd2UgZG9uJ3QgbWVyZ2UgX19wcm90b19fIHRvIHByZXZlbnQgcHJvdG90eXBlIHBvbGx1dGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQ6IHVua25vd24sIHNvdXJjZTogdW5rbm93bik6IHVua25vd24ge1xuICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHN3aXRjaCAoc291cmNlLmNvbnN0cnVjdG9yKSB7XG4gICAgY2FzZSBEYXRlOlxuICAgICAgLy8gVHJlYXQgRGF0ZXMgbGlrZSBzY2FsYXJzOyBpZiB0aGUgdGFyZ2V0IGRhdGUgb2JqZWN0IGhhZCBhbnkgY2hpbGRcbiAgICAgIC8vIHByb3BlcnRpZXMgLSB0aGV5IHdpbGwgYmUgbG9zdCFcbiAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHNvdXJjZSBhcyBEYXRlO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVWYWx1ZS5nZXRUaW1lKCkpO1xuXG4gICAgY2FzZSBPYmplY3Q6XG4gICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIEFycmF5OlxuICAgICAgLy8gQWx3YXlzIGNvcHkgdGhlIGFycmF5IHNvdXJjZSBhbmQgb3ZlcndyaXRlIHRoZSB0YXJnZXQuXG4gICAgICB0YXJnZXQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIE5vdCBhIHBsYWluIE9iamVjdCAtIHRyZWF0IGl0IGFzIGEgc2NhbGFyLlxuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAvLyB1c2UgaXNWYWxpZEtleSB0byBndWFyZCBhZ2FpbnN0IHByb3RvdHlwZSBwb2xsdXRpb24uIFNlZSBodHRwczovL3NueWsuaW8vdnVsbi9TTllLLUpTLUxPREFTSC00NTAyMDJcbiAgICBpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCAhaXNWYWxpZEtleShwcm9wKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICh0YXJnZXQgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW3Byb3BdID0gZGVlcEV4dGVuZChcbiAgICAgICh0YXJnZXQgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW3Byb3BdLFxuICAgICAgKHNvdXJjZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbcHJvcF1cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4ga2V5ICE9PSAnX19wcm90b19fJztcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogUG9seWZpbGwgZm9yIGBnbG9iYWxUaGlzYCBvYmplY3QuXG4gKiBAcmV0dXJucyB0aGUgYGdsb2JhbFRoaXNgIG9iamVjdCBmb3IgdGhlIGdpdmVuIGVudmlyb25tZW50LlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsKCk6IHR5cGVvZiBnbG9iYWxUaGlzIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdC4nKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGJhc2U2NERlY29kZSB9IGZyb20gJy4vY3J5cHQnO1xuaW1wb3J0IHsgZ2V0R2xvYmFsIH0gZnJvbSAnLi9nbG9iYWwnO1xuXG4vKipcbiAqIEtleXMgZm9yIGV4cGVyaW1lbnRhbCBwcm9wZXJ0aWVzIG9uIHRoZSBgRmlyZWJhc2VEZWZhdWx0c2Agb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBFeHBlcmltZW50YWxLZXkgPSAnYXV0aFRva2VuU3luY1VSTCcgfCAnYXV0aElkVG9rZW5NYXhBZ2UnO1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBiZSBpbmplY3RlZCBpbnRvIHRoZSBlbnZpcm9ubWVudCBhcyBfX0ZJUkVCQVNFX0RFRkFVTFRTX18sXG4gKiBlaXRoZXIgYXMgYSBwcm9wZXJ0eSBvZiBnbG9iYWxUaGlzLCBhIHNoZWxsIGVudmlyb25tZW50IHZhcmlhYmxlLCBvciBhXG4gKiBjb29raWUuXG4gKlxuICogVGhpcyBvYmplY3QgY2FuIGJlIHVzZWQgdG8gYXV0b21hdGljYWxseSBjb25maWd1cmUgYW5kIGluaXRpYWxpemVcbiAqIGEgRmlyZWJhc2UgYXBwIGFzIHdlbGwgYXMgYW55IGVtdWxhdG9ycy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlyZWJhc2VEZWZhdWx0cyB7XG4gIGNvbmZpZz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIGVtdWxhdG9ySG9zdHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBfYXV0aFRva2VuU3luY1VSTD86IHN0cmluZztcbiAgX2F1dGhJZFRva2VuTWF4QWdlPzogbnVtYmVyO1xuICAvKipcbiAgICogT3ZlcnJpZGUgRmlyZWJhc2UncyBydW50aW1lIGVudmlyb25tZW50IGRldGVjdGlvbiBhbmRcbiAgICogZm9yY2UgdGhlIFNESyB0byBhY3QgYXMgaWYgaXQgd2VyZSBpbiB0aGUgc3BlY2lmaWVkIGVudmlyb25tZW50LlxuICAgKi9cbiAgZm9yY2VFbnZpcm9ubWVudD86ICdicm93c2VyJyB8ICdub2RlJztcbiAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICAvLyBOZWVkIGB2YXJgIGZvciB0aGlzIHRvIHdvcmsuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXJcbiAgdmFyIF9fRklSRUJBU0VfREVGQVVMVFNfXzogRmlyZWJhc2VEZWZhdWx0cyB8IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgZ2V0RGVmYXVsdHNGcm9tR2xvYmFsID0gKCk6IEZpcmViYXNlRGVmYXVsdHMgfCB1bmRlZmluZWQgPT5cbiAgZ2V0R2xvYmFsKCkuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gcmVhZCBkZWZhdWx0cyBmcm9tIGEgSlNPTiBzdHJpbmcgcHJvdmlkZWQgdG9cbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb3IgYSBKU09OIGZpbGUgd2hvc2UgcGF0aCBpcyBpblxuICogcHJvY2VzcyguKWVudiguKV9fRklSRUJBU0VfREVGQVVMVFNfUEFUSF9fXG4gKiBUaGUgZG90cyBhcmUgaW4gcGFyZW5zIGJlY2F1c2UgY2VydGFpbiBjb21waWxlcnMgKFZpdGU/KSBjYW5ub3RcbiAqIGhhbmRsZSBzZWVpbmcgdGhhdCB2YXJpYWJsZSBpbiBjb21tZW50cy5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2lzc3Vlcy82ODM4XG4gKi9cbmNvbnN0IGdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlID0gKCk6IEZpcmViYXNlRGVmYXVsdHMgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGVmYXVsdHNKc29uU3RyaW5nID0gcHJvY2Vzcy5lbnYuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xuICBpZiAoZGVmYXVsdHNKc29uU3RyaW5nKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVmYXVsdHNKc29uU3RyaW5nKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0RGVmYXVsdHNGcm9tQ29va2llID0gKCk6IEZpcmViYXNlRGVmYXVsdHMgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbWF0Y2g7XG4gIHRyeSB7XG4gICAgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2goL19fRklSRUJBU0VfREVGQVVMVFNfXz0oW147XSspLyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBTb21lIGVudmlyb25tZW50cyBzdWNoIGFzIEFuZ3VsYXIgVW5pdmVyc2FsIFNTUiBoYXZlIGFcbiAgICAvLyBgZG9jdW1lbnRgIG9iamVjdCBidXQgZXJyb3Igb24gYWNjZXNzaW5nIGBkb2N1bWVudC5jb29raWVgLlxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZWNvZGVkID0gbWF0Y2ggJiYgYmFzZTY0RGVjb2RlKG1hdGNoWzFdKTtcbiAgcmV0dXJuIGRlY29kZWQgJiYgSlNPTi5wYXJzZShkZWNvZGVkKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0LiBJdCBjaGVja3MgaW4gb3JkZXI6XG4gKiAoMSkgaWYgc3VjaCBhbiBvYmplY3QgZXhpc3RzIGFzIGEgcHJvcGVydHkgb2YgYGdsb2JhbFRoaXNgXG4gKiAoMikgaWYgc3VjaCBhbiBvYmplY3Qgd2FzIHByb3ZpZGVkIG9uIGEgc2hlbGwgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqICgzKSBpZiBzdWNoIGFuIG9iamVjdCBleGlzdHMgaW4gYSBjb29raWVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldERlZmF1bHRzID0gKCk6IEZpcmViYXNlRGVmYXVsdHMgfCB1bmRlZmluZWQgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiAoXG4gICAgICBnZXREZWZhdWx0c0Zyb21HbG9iYWwoKSB8fFxuICAgICAgZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUoKSB8fFxuICAgICAgZ2V0RGVmYXVsdHNGcm9tQ29va2llKClcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLyoqXG4gICAgICogQ2F0Y2gtYWxsIGZvciBiZWluZyB1bmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWVcbiAgICAgKiB0byBhbnkgZW52aXJvbm1lbnQgY2FzZSB3ZSBoYXZlIG5vdCBhY2NvdW50ZWQgZm9yLiBMb2cgdG9cbiAgICAgKiBpbmZvIGluc3RlYWQgb2Ygc3dhbGxvd2luZyBzbyB3ZSBjYW4gZmluZCB0aGVzZSB1bmtub3duIGNhc2VzXG4gICAgICogYW5kIGFkZCBwYXRocyBmb3IgdGhlbSBpZiBuZWVkZWQuXG4gICAgICovXG4gICAgY29uc29sZS5pbmZvKGBVbmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWUgdG86ICR7ZX1gKTtcbiAgICByZXR1cm47XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBlbXVsYXRvciBob3N0IHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdFxuICogZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxuICogQHJldHVybnMgYSBVUkwgaG9zdCBmb3JtYXR0ZWQgbGlrZSBgMTI3LjAuMC4xOjk5OTlgIG9yIGBbOjoxXTo0MDAwYCBpZiBhdmFpbGFibGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldERlZmF1bHRFbXVsYXRvckhvc3QgPSAoXG4gIHByb2R1Y3ROYW1lOiBzdHJpbmdcbik6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiBnZXREZWZhdWx0cygpPy5lbXVsYXRvckhvc3RzPy5bcHJvZHVjdE5hbWVdO1xuXG4vKipcbiAqIFJldHVybnMgZW11bGF0b3IgaG9zdG5hbWUgYW5kIHBvcnQgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXG4gKiBAcmV0dXJucyBhIHBhaXIgb2YgaG9zdG5hbWUgYW5kIHBvcnQgbGlrZSBgW1wiOjoxXCIsIDQwMDBdYCBpZiBhdmFpbGFibGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCA9IChcbiAgcHJvZHVjdE5hbWU6IHN0cmluZ1xuKTogW2hvc3RuYW1lOiBzdHJpbmcsIHBvcnQ6IG51bWJlcl0gfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCBob3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdChwcm9kdWN0TmFtZSk7XG4gIGlmICghaG9zdCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSBob3N0Lmxhc3RJbmRleE9mKCc6Jyk7IC8vIEZpbmRpbmcgdGhlIGxhc3Qgc2luY2UgSVB2NiBhZGRyIGFsc28gaGFzIGNvbG9ucy5cbiAgaWYgKHNlcGFyYXRvckluZGV4IDw9IDAgfHwgc2VwYXJhdG9ySW5kZXggKyAxID09PSBob3N0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3N0ICR7aG9zdH0gd2l0aCBubyBzZXBhcmF0ZSBob3N0bmFtZSBhbmQgcG9ydCFgKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gIGNvbnN0IHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhzZXBhcmF0b3JJbmRleCArIDEpLCAxMCk7XG4gIGlmIChob3N0WzBdID09PSAnWycpIHtcbiAgICAvLyBCcmFja2V0LXF1b3RlZCBgW2lwdjZhZGRyXTpwb3J0YCA9PiByZXR1cm4gXCJpcHY2YWRkclwiICh3aXRob3V0IGJyYWNrZXRzKS5cbiAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDEsIHNlcGFyYXRvckluZGV4IC0gMSksIHBvcnRdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMCwgc2VwYXJhdG9ySW5kZXgpLCBwb3J0XTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZpcmViYXNlIGFwcCBjb25maWcgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdEFwcENvbmZpZyA9ICgpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkID0+XG4gIGdldERlZmF1bHRzKCk/LmNvbmZpZztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV4cGVyaW1lbnRhbCBzZXR0aW5nIG9uIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0IChwcm9wZXJ0aWVzXG4gKiBwcmVmaXhlZCBieSBcIl9cIilcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEV4cGVyaW1lbnRhbFNldHRpbmcgPSA8VCBleHRlbmRzIEV4cGVyaW1lbnRhbEtleT4oXG4gIG5hbWU6IFRcbik6IEZpcmViYXNlRGVmYXVsdHNbYF8ke1R9YF0gPT5cbiAgZ2V0RGVmYXVsdHMoKT8uW2BfJHtuYW1lfWBdIGFzIEZpcmViYXNlRGVmYXVsdHNbYF8ke1R9YF07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY2xhc3MgRGVmZXJyZWQ8Uj4ge1xuICBwcm9taXNlOiBQcm9taXNlPFI+O1xuICByZWplY3Q6ICh2YWx1ZT86IHVua25vd24pID0+IHZvaWQgPSAoKSA9PiB7fTtcbiAgcmVzb2x2ZTogKHZhbHVlPzogdW5rbm93bikgPT4gdm9pZCA9ICgpID0+IHt9O1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlIGFzICh2YWx1ZT86IHVua25vd24pID0+IHZvaWQ7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdCBhcyAodmFsdWU/OiB1bmtub3duKSA9PiB2b2lkO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE91ciBBUEkgaW50ZXJuYWxzIGFyZSBub3QgcHJvbWlzZWlmaWVkIGFuZCBjYW5ub3QgYmVjYXVzZSBvdXIgY2FsbGJhY2sgQVBJcyBoYXZlIHN1YnRsZSBleHBlY3RhdGlvbnMgYXJvdW5kXG4gICAqIGludm9raW5nIHByb21pc2VzIGlubGluZSwgd2hpY2ggUHJvbWlzZXMgYXJlIGZvcmJpZGRlbiB0byBkby4gVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25hbCBub2RlLXN0eWxlIGNhbGxiYWNrXG4gICAqIGFuZCByZXR1cm5zIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB3aGljaCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBEZWZlcnJlZCdzIHByb21pc2UuXG4gICAqL1xuICB3cmFwQ2FsbGJhY2soXG4gICAgY2FsbGJhY2s/OiAoZXJyb3I/OiB1bmtub3duLCB2YWx1ZT86IHVua25vd24pID0+IHZvaWRcbiAgKTogKGVycm9yOiB1bmtub3duLCB2YWx1ZT86IHVua25vd24pID0+IHZvaWQge1xuICAgIHJldHVybiAoZXJyb3IsIHZhbHVlPykgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEF0dGFjaGluZyBub29wIGhhbmRsZXIganVzdCBpbiBjYXNlIGRldmVsb3BlciB3YXNuJ3QgZXhwZWN0aW5nXG4gICAgICAgIC8vIHByb21pc2VzXG4gICAgICAgIHRoaXMucHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG5cbiAgICAgICAgLy8gU29tZSBvZiBvdXIgY2FsbGJhY2tzIGRvbid0IGV4cGVjdCBhIHZhbHVlIGFuZCBvdXIgb3duIHRlc3RzXG4gICAgICAgIC8vIGFzc2VydCB0aGF0IHRoZSBwYXJhbWV0ZXIgbGVuZ3RoIGlzIDFcbiAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgfSBmcm9tICcuL2NyeXB0JztcblxuLy8gRmlyZWJhc2UgQXV0aCB0b2tlbnMgY29udGFpbiBzbmFrZV9jYXNlIGNsYWltcyBmb2xsb3dpbmcgdGhlIEpXVCBzdGFuZGFyZCAvIGNvbnZlbnRpb24uXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cblxuZXhwb3J0IHR5cGUgRmlyZWJhc2VTaWduSW5Qcm92aWRlciA9XG4gIHwgJ2N1c3RvbSdcbiAgfCAnZW1haWwnXG4gIHwgJ3Bhc3N3b3JkJ1xuICB8ICdwaG9uZSdcbiAgfCAnYW5vbnltb3VzJ1xuICB8ICdnb29nbGUuY29tJ1xuICB8ICdmYWNlYm9vay5jb20nXG4gIHwgJ2dpdGh1Yi5jb20nXG4gIHwgJ3R3aXR0ZXIuY29tJ1xuICB8ICdtaWNyb3NvZnQuY29tJ1xuICB8ICdhcHBsZS5jb20nO1xuXG5pbnRlcmZhY2UgRmlyZWJhc2VJZFRva2VuIHtcbiAgLy8gQWx3YXlzIHNldCB0byBodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vUFJPSkVDVF9JRFxuICBpc3M6IHN0cmluZztcblxuICAvLyBBbHdheXMgc2V0IHRvIFBST0pFQ1RfSURcbiAgYXVkOiBzdHJpbmc7XG5cbiAgLy8gVGhlIHVzZXIncyB1bmlxdWUgSURcbiAgc3ViOiBzdHJpbmc7XG5cbiAgLy8gVGhlIHRva2VuIGlzc3VlIHRpbWUsIGluIHNlY29uZHMgc2luY2UgZXBvY2hcbiAgaWF0OiBudW1iZXI7XG5cbiAgLy8gVGhlIHRva2VuIGV4cGlyeSB0aW1lLCBub3JtYWxseSAnaWF0JyArIDM2MDBcbiAgZXhwOiBudW1iZXI7XG5cbiAgLy8gVGhlIHVzZXIncyB1bmlxdWUgSUQuIE11c3QgYmUgZXF1YWwgdG8gJ3N1YidcbiAgdXNlcl9pZDogc3RyaW5nO1xuXG4gIC8vIFRoZSB0aW1lIHRoZSB1c2VyIGF1dGhlbnRpY2F0ZWQsIG5vcm1hbGx5ICdpYXQnXG4gIGF1dGhfdGltZTogbnVtYmVyO1xuXG4gIC8vIFRoZSBzaWduIGluIHByb3ZpZGVyLCBvbmx5IHNldCB3aGVuIHRoZSBwcm92aWRlciBpcyAnYW5vbnltb3VzJ1xuICBwcm92aWRlcl9pZD86ICdhbm9ueW1vdXMnO1xuXG4gIC8vIFRoZSB1c2VyJ3MgcHJpbWFyeSBlbWFpbFxuICBlbWFpbD86IHN0cmluZztcblxuICAvLyBUaGUgdXNlcidzIGVtYWlsIHZlcmlmaWNhdGlvbiBzdGF0dXNcbiAgZW1haWxfdmVyaWZpZWQ/OiBib29sZWFuO1xuXG4gIC8vIFRoZSB1c2VyJ3MgcHJpbWFyeSBwaG9uZSBudW1iZXJcbiAgcGhvbmVfbnVtYmVyPzogc3RyaW5nO1xuXG4gIC8vIFRoZSB1c2VyJ3MgZGlzcGxheSBuYW1lXG4gIG5hbWU/OiBzdHJpbmc7XG5cbiAgLy8gVGhlIHVzZXIncyBwcm9maWxlIHBob3RvIFVSTFxuICBwaWN0dXJlPzogc3RyaW5nO1xuXG4gIC8vIEluZm9ybWF0aW9uIG9uIGFsbCBpZGVudGl0aWVzIGxpbmtlZCB0byB0aGlzIHVzZXJcbiAgZmlyZWJhc2U6IHtcbiAgICAvLyBUaGUgcHJpbWFyeSBzaWduLWluIHByb3ZpZGVyXG4gICAgc2lnbl9pbl9wcm92aWRlcjogRmlyZWJhc2VTaWduSW5Qcm92aWRlcjtcblxuICAgIC8vIEEgbWFwIG9mIHByb3ZpZGVycyB0byB0aGUgdXNlcidzIGxpc3Qgb2YgdW5pcXVlIGlkZW50aWZpZXJzIGZyb21cbiAgICAvLyBlYWNoIHByb3ZpZGVyXG4gICAgaWRlbnRpdGllcz86IHsgW3Byb3ZpZGVyIGluIEZpcmViYXNlU2lnbkluUHJvdmlkZXJdPzogc3RyaW5nW10gfTtcbiAgfTtcblxuICAvLyBDdXN0b20gY2xhaW1zIHNldCBieSB0aGUgZGV2ZWxvcGVyXG4gIFtjbGFpbTogc3RyaW5nXTogdW5rbm93bjtcblxuICB1aWQ/OiBuZXZlcjsgLy8gVHJ5IHRvIGNhdGNoIGEgY29tbW9uIG1pc3Rha2Ugb2YgXCJ1aWRcIiAoc2hvdWxkIGJlIFwic3ViXCIgaW5zdGVhZCkuXG59XG5cbmV4cG9ydCB0eXBlIEVtdWxhdG9yTW9ja1Rva2VuT3B0aW9ucyA9ICh7IHVzZXJfaWQ6IHN0cmluZyB9IHwgeyBzdWI6IHN0cmluZyB9KSAmXG4gIFBhcnRpYWw8RmlyZWJhc2VJZFRva2VuPjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vY2tVc2VyVG9rZW4oXG4gIHRva2VuOiBFbXVsYXRvck1vY2tUb2tlbk9wdGlvbnMsXG4gIHByb2plY3RJZD86IHN0cmluZ1xuKTogc3RyaW5nIHtcbiAgaWYgKHRva2VuLnVpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdUaGUgXCJ1aWRcIiBmaWVsZCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGJ5IG1vY2tVc2VyVG9rZW4uIFBsZWFzZSB1c2UgXCJzdWJcIiBpbnN0ZWFkIGZvciBGaXJlYmFzZSBBdXRoIFVzZXIgSUQuJ1xuICAgICk7XG4gIH1cbiAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIFwibm9uZVwiIGFzIHRoZSBhbGdvcml0aG0uXG4gIGNvbnN0IGhlYWRlciA9IHtcbiAgICBhbGc6ICdub25lJyxcbiAgICB0eXBlOiAnSldUJ1xuICB9O1xuXG4gIGNvbnN0IHByb2plY3QgPSBwcm9qZWN0SWQgfHwgJ2RlbW8tcHJvamVjdCc7XG4gIGNvbnN0IGlhdCA9IHRva2VuLmlhdCB8fCAwO1xuICBjb25zdCBzdWIgPSB0b2tlbi5zdWIgfHwgdG9rZW4udXNlcl9pZDtcbiAgaWYgKCFzdWIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xuICB9XG5cbiAgY29uc3QgcGF5bG9hZDogRmlyZWJhc2VJZFRva2VuID0ge1xuICAgIC8vIFNldCBhbGwgcmVxdWlyZWQgZmllbGRzIHRvIGRlY2VudCBkZWZhdWx0c1xuICAgIGlzczogYGh0dHBzOi8vc2VjdXJldG9rZW4uZ29vZ2xlLmNvbS8ke3Byb2plY3R9YCxcbiAgICBhdWQ6IHByb2plY3QsXG4gICAgaWF0LFxuICAgIGV4cDogaWF0ICsgMzYwMCxcbiAgICBhdXRoX3RpbWU6IGlhdCxcbiAgICBzdWIsXG4gICAgdXNlcl9pZDogc3ViLFxuICAgIGZpcmViYXNlOiB7XG4gICAgICBzaWduX2luX3Byb3ZpZGVyOiAnY3VzdG9tJyxcbiAgICAgIGlkZW50aXRpZXM6IHt9XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlIHdpdGggdXNlciBvcHRpb25zXG4gICAgLi4udG9rZW5cbiAgfTtcblxuICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgdGhlIGVtcHR5IHN0cmluZyBhcyBhIHNpZ25hdHVyZS5cbiAgY29uc3Qgc2lnbmF0dXJlID0gJyc7XG4gIHJldHVybiBbXG4gICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksXG4gICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpLFxuICAgIHNpZ25hdHVyZVxuICBdLmpvaW4oJy4nKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldERlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cyc7XG5cbi8qKlxuICogUmV0dXJucyBuYXZpZ2F0b3IudXNlckFnZW50IHN0cmluZyBvciAnJyBpZiBpdCdzIG5vdCBkZWZpbmVkLlxuICogQHJldHVybiB1c2VyIGFnZW50IHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VUEoKTogc3RyaW5nIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvclsndXNlckFnZW50J10gPT09ICdzdHJpbmcnXG4gICkge1xuICAgIHJldHVybiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vKipcbiAqIERldGVjdCBDb3Jkb3ZhIC8gUGhvbmVHYXAgLyBJb25pYyBmcmFtZXdvcmtzIG9uIGEgbW9iaWxlIGRldmljZS5cbiAqXG4gKiBEZWxpYmVyYXRlbHkgZG9lcyBub3QgcmVseSBvbiBjaGVja2luZyBgZmlsZTovL2AgVVJMcyAoYXMgdGhpcyBmYWlscyBQaG9uZUdhcFxuICogaW4gdGhlIFJpcHBsZSBlbXVsYXRvcikgbm9yIENvcmRvdmEgYG9uRGV2aWNlUmVhZHlgLCB3aGljaCB3b3VsZCBub3JtYWxseVxuICogd2FpdCBmb3IgYSBjYWxsYmFjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTW9iaWxlQ29yZG92YSgpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC8vIEB0cy1pZ25vcmUgU2V0dGluZyB1cCBhbiBicm9hZGx5IGFwcGxpY2FibGUgaW5kZXggc2lnbmF0dXJlIGZvciBXaW5kb3dcbiAgICAvLyBqdXN0IHRvIGRlYWwgd2l0aCB0aGlzIGNhc2Ugd291bGQgcHJvYmFibHkgYmUgYSBiYWQgaWRlYS5cbiAgICAhISh3aW5kb3dbJ2NvcmRvdmEnXSB8fCB3aW5kb3dbJ3Bob25lZ2FwJ10gfHwgd2luZG93WydQaG9uZUdhcCddKSAmJlxuICAgIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGUvaS50ZXN0KGdldFVBKCkpXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZWN0IE5vZGUuanMuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQgb3Igc3BlY2lmaWVkLlxuICovXG4vLyBOb2RlIGRldGVjdGlvbiBsb2dpYyBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaWxpYWthbi9kZXRlY3Qtbm9kZS9cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGUoKTogYm9vbGVhbiB7XG4gIGNvbnN0IGZvcmNlRW52aXJvbm1lbnQgPSBnZXREZWZhdWx0cygpPy5mb3JjZUVudmlyb25tZW50O1xuICBpZiAoZm9yY2VFbnZpcm9ubWVudCA9PT0gJ25vZGUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZm9yY2VFbnZpcm9ubWVudCA9PT0gJ2Jyb3dzZXInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gKFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVjdCBCcm93c2VyIEVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jyb3dzZXIoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmO1xufVxuXG4vKipcbiAqIERldGVjdCBicm93c2VyIGV4dGVuc2lvbnMgKENocm9tZSBhbmQgRmlyZWZveCBhdCBsZWFzdCkuXG4gKi9cbmludGVyZmFjZSBCcm93c2VyUnVudGltZSB7XG4gIGlkPzogdW5rbm93bjtcbn1cbmRlY2xhcmUgY29uc3QgY2hyb21lOiB7IHJ1bnRpbWU/OiBCcm93c2VyUnVudGltZSB9O1xuZGVjbGFyZSBjb25zdCBicm93c2VyOiB7IHJ1bnRpbWU/OiBCcm93c2VyUnVudGltZSB9O1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnJvd3NlckV4dGVuc2lvbigpOiBib29sZWFuIHtcbiAgY29uc3QgcnVudGltZSA9XG4gICAgdHlwZW9mIGNocm9tZSA9PT0gJ29iamVjdCdcbiAgICAgID8gY2hyb21lLnJ1bnRpbWVcbiAgICAgIDogdHlwZW9mIGJyb3dzZXIgPT09ICdvYmplY3QnXG4gICAgICA/IGJyb3dzZXIucnVudGltZVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIHJldHVybiB0eXBlb2YgcnVudGltZSA9PT0gJ29iamVjdCcgJiYgcnVudGltZS5pZCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIERldGVjdCBSZWFjdCBOYXRpdmUuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3JbJ3Byb2R1Y3QnXSA9PT0gJ1JlYWN0TmF0aXZlJ1xuICApO1xufVxuXG4vKiogRGV0ZWN0cyBFbGVjdHJvbiBhcHBzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlY3Ryb24oKTogYm9vbGVhbiB7XG4gIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ0VsZWN0cm9uLycpID49IDA7XG59XG5cbi8qKiBEZXRlY3RzIEludGVybmV0IEV4cGxvcmVyLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSUUoKTogYm9vbGVhbiB7XG4gIGNvbnN0IHVhID0gZ2V0VUEoKTtcbiAgcmV0dXJuIHVhLmluZGV4T2YoJ01TSUUgJykgPj0gMCB8fCB1YS5pbmRleE9mKCdUcmlkZW50LycpID49IDA7XG59XG5cbi8qKiBEZXRlY3RzIFVuaXZlcnNhbCBXaW5kb3dzIFBsYXRmb3JtIGFwcHMuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVV1AoKTogYm9vbGVhbiB7XG4gIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ01TQXBwSG9zdC8nKSA+PSAwO1xufVxuXG4vKipcbiAqIERldGVjdCB3aGV0aGVyIHRoZSBjdXJyZW50IFNESyBidWlsZCBpcyB0aGUgTm9kZSB2ZXJzaW9uLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpdCdzIHRoZSBOb2RlIFNESyBidWlsZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVNkaygpOiBib29sZWFuIHtcbiAgcmV0dXJuIENPTlNUQU5UUy5OT0RFX0NMSUVOVCA9PT0gdHJ1ZSB8fCBDT05TVEFOVFMuTk9ERV9BRE1JTiA9PT0gdHJ1ZTtcbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcnVubmluZyBpbiBTYWZhcmkuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgIWlzTm9kZSgpICYmXG4gICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnU2FmYXJpJykgJiZcbiAgICAhbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnQ2hyb21lJylcbiAgKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3MgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxuICogQHJldHVybiB0cnVlIGlmIGluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBicm93c2VyL3NlcnZpY2Ugd29ya2VyIGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW5kZXhlZERCQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgaW5kZXhlZERCID09PSAnb2JqZWN0JztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHZhbGlkYXRlcyBicm93c2VyL3N3IGNvbnRleHQgZm9yIGluZGV4ZWREQiBieSBvcGVuaW5nIGEgZHVtbXkgaW5kZXhlZERCIGRhdGFiYXNlIGFuZCByZWplY3RcbiAqIGlmIGVycm9ycyBvY2N1ciBkdXJpbmcgdGhlIGRhdGFiYXNlIG9wZW4gb3BlcmF0aW9uLlxuICpcbiAqIEB0aHJvd3MgZXhjZXB0aW9uIGlmIGN1cnJlbnQgYnJvd3Nlci9zdyBjb250ZXh0IGNhbid0IHJ1biBpZGIub3BlbiAoZXg6IFNhZmFyaSBpZnJhbWUsIEZpcmVmb3hcbiAqIHByaXZhdGUgYnJvd3NpbmcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcHJlRXhpc3Q6IGJvb2xlYW4gPSB0cnVlO1xuICAgICAgY29uc3QgREJfQ0hFQ0tfTkFNRSA9XG4gICAgICAgICd2YWxpZGF0ZS1icm93c2VyLWNvbnRleHQtZm9yLWluZGV4ZWRkYi1hbmFseXRpY3MtbW9kdWxlJztcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZWxmLmluZGV4ZWREQi5vcGVuKERCX0NIRUNLX05BTUUpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgIHJlcXVlc3QucmVzdWx0LmNsb3NlKCk7XG4gICAgICAgIC8vIGRlbGV0ZSBkYXRhYmFzZSBvbmx5IHdoZW4gaXQgZG9lc24ndCBwcmUtZXhpc3RcbiAgICAgICAgaWYgKCFwcmVFeGlzdCkge1xuICAgICAgICAgIHNlbGYuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKERCX0NIRUNLX05BTUUpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICB9O1xuICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB7XG4gICAgICAgIHByZUV4aXN0ID0gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yPy5tZXNzYWdlIHx8ICcnKTtcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxuICogQHJldHVybiB0cnVlIGlmIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyZUNvb2tpZXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5jb29raWVFbmFibGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBTdGFuZGFyZGl6ZWQgRmlyZWJhc2UgRXJyb3IuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAvLyBUeXBlc2NyaXB0IHN0cmluZyBsaXRlcmFscyBmb3IgdHlwZS1zYWZlIGNvZGVzXG4gKiAgIHR5cGUgRXJyID1cbiAqICAgICAndW5rbm93bicgfFxuICogICAgICdvYmplY3Qtbm90LWZvdW5kJ1xuICogICAgIDtcbiAqXG4gKiAgIC8vIENsb3N1cmUgZW51bSBmb3IgdHlwZS1zYWZlIGVycm9yIGNvZGVzXG4gKiAgIC8vIGF0LWVudW0ge3N0cmluZ31cbiAqICAgdmFyIEVyciA9IHtcbiAqICAgICBVTktOT1dOOiAndW5rbm93bicsXG4gKiAgICAgT0JKRUNUX05PVF9GT1VORDogJ29iamVjdC1ub3QtZm91bmQnLFxuICogICB9XG4gKlxuICogICBsZXQgZXJyb3JzOiBNYXA8RXJyLCBzdHJpbmc+ID0ge1xuICogICAgICdnZW5lcmljLWVycm9yJzogXCJVbmtub3duIGVycm9yXCIsXG4gKiAgICAgJ2ZpbGUtbm90LWZvdW5kJzogXCJDb3VsZCBub3QgZmluZCBmaWxlOiB7JGZpbGV9XCIsXG4gKiAgIH07XG4gKlxuICogICAvLyBUeXBlLXNhZmUgZnVuY3Rpb24gLSBtdXN0IHBhc3MgYSB2YWxpZCBlcnJvciBjb2RlIGFzIHBhcmFtLlxuICogICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JGYWN0b3J5PEVycj4oJ3NlcnZpY2UnLCAnU2VydmljZScsIGVycm9ycyk7XG4gKlxuICogICAuLi5cbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5HRU5FUklDKTtcbiAqICAgLi4uXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuRklMRV9OT1RfRk9VTkQsIHsnZmlsZSc6IGZpbGVOYW1lfSk7XG4gKiAgIC4uLlxuICogICAvLyBTZXJ2aWNlOiBDb3VsZCBub3QgZmlsZSBmaWxlOiBmb28udHh0IChzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kKS5cbiAqXG4gKiAgIGNhdGNoIChlKSB7XG4gKiAgICAgYXNzZXJ0KGUubWVzc2FnZSA9PT0gXCJDb3VsZCBub3QgZmluZCBmaWxlOiBmb28udHh0LlwiKTtcbiAqICAgICBpZiAoKGUgYXMgRmlyZWJhc2VFcnJvcik/LmNvZGUgPT09ICdzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kJykge1xuICogICAgICAgY29uc29sZS5sb2coXCJDb3VsZCBub3QgcmVhZCBmaWxlOiBcIiArIGVbJ2ZpbGUnXSk7XG4gKiAgICAgfVxuICogICB9XG4gKi9cblxuZXhwb3J0IHR5cGUgRXJyb3JNYXA8RXJyb3JDb2RlIGV4dGVuZHMgc3RyaW5nPiA9IHtcbiAgcmVhZG9ubHkgW0sgaW4gRXJyb3JDb2RlXTogc3RyaW5nO1xufTtcblxuY29uc3QgRVJST1JfTkFNRSA9ICdGaXJlYmFzZUVycm9yJztcblxuZXhwb3J0IGludGVyZmFjZSBTdHJpbmdMaWtlIHtcbiAgdG9TdHJpbmcoKTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yRGF0YSB7XG4gIFtrZXk6IHN0cmluZ106IHVua25vd247XG59XG5cbi8vIEJhc2VkIG9uIGNvZGUgZnJvbTpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0N1c3RvbV9FcnJvcl9UeXBlc1xuZXhwb3J0IGNsYXNzIEZpcmViYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKiBUaGUgY3VzdG9tIG5hbWUgZm9yIGFsbCBGaXJlYmFzZUVycm9ycy4gKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nID0gRVJST1JfTkFNRTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIGVycm9yIGNvZGUgZm9yIHRoaXMgZXJyb3IuICovXG4gICAgcmVhZG9ubHkgY29kZTogc3RyaW5nLFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICAvKiogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgZXJyb3IuICovXG4gICAgcHVibGljIGN1c3RvbURhdGE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcblxuICAgIC8vIEZpeCBGb3IgRVM1XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYXN0ZXIvQnJlYWtpbmctQ2hhbmdlcy5tZCNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRmlyZWJhc2VFcnJvci5wcm90b3R5cGUpO1xuXG4gICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24uXG4gICAgLy8gT25seSBhdmFpbGFibGUgb24gVjguXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFcnJvckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFcnJvckZhY3Rvcnk8XG4gIEVycm9yQ29kZSBleHRlbmRzIHN0cmluZyxcbiAgRXJyb3JQYXJhbXMgZXh0ZW5kcyB7IHJlYWRvbmx5IFtLIGluIEVycm9yQ29kZV0/OiBFcnJvckRhdGEgfSA9IHt9XG4+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZXJ2aWNlOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZXJ2aWNlTmFtZTogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXJyb3JzOiBFcnJvck1hcDxFcnJvckNvZGU+XG4gICkge31cblxuICBjcmVhdGU8SyBleHRlbmRzIEVycm9yQ29kZT4oXG4gICAgY29kZTogSyxcbiAgICAuLi5kYXRhOiBLIGV4dGVuZHMga2V5b2YgRXJyb3JQYXJhbXMgPyBbRXJyb3JQYXJhbXNbS11dIDogW11cbiAgKTogRmlyZWJhc2VFcnJvciB7XG4gICAgY29uc3QgY3VzdG9tRGF0YSA9IChkYXRhWzBdIGFzIEVycm9yRGF0YSkgfHwge307XG4gICAgY29uc3QgZnVsbENvZGUgPSBgJHt0aGlzLnNlcnZpY2V9LyR7Y29kZX1gO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5lcnJvcnNbY29kZV07XG5cbiAgICBjb25zdCBtZXNzYWdlID0gdGVtcGxhdGUgPyByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGN1c3RvbURhdGEpIDogJ0Vycm9yJztcbiAgICAvLyBTZXJ2aWNlIE5hbWU6IEVycm9yIG1lc3NhZ2UgKHNlcnZpY2UvY29kZSkuXG4gICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBgJHt0aGlzLnNlcnZpY2VOYW1lfTogJHttZXNzYWdlfSAoJHtmdWxsQ29kZX0pLmA7XG5cbiAgICBjb25zdCBlcnJvciA9IG5ldyBGaXJlYmFzZUVycm9yKGZ1bGxDb2RlLCBmdWxsTWVzc2FnZSwgY3VzdG9tRGF0YSk7XG5cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlOiBzdHJpbmcsIGRhdGE6IEVycm9yRGF0YSk6IHN0cmluZyB7XG4gIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKFBBVFRFUk4sIChfLCBrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiBgPCR7a2V5fT8+YDtcbiAgfSk7XG59XG5cbmNvbnN0IFBBVFRFUk4gPSAvXFx7XFwkKFtefV0rKX0vZztcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogRXZhbHVhdGVzIGEgSlNPTiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgY29udGFpbmluZyBKU09OLlxuICogQHJldHVybiB7Kn0gVGhlIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIEpTT04uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uRXZhbChzdHI6IHN0cmluZyk6IHVua25vd24ge1xuICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgSlNPTiByZXByZXNlbnRpbmcgYSBqYXZhc2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gZGF0YSBKYXZhc2NyaXB0IG9iamVjdCB0byBiZSBzdHJpbmdpZmllZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEpTT04gY29udGVudHMgb2YgdGhlIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhOiB1bmtub3duKTogc3RyaW5nIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYmFzZTY0RGVjb2RlIH0gZnJvbSAnLi9jcnlwdCc7XG5pbXBvcnQgeyBqc29uRXZhbCB9IGZyb20gJy4vanNvbic7XG5cbmludGVyZmFjZSBDbGFpbXMge1xuICBba2V5OiBzdHJpbmddOiB7fTtcbn1cblxuaW50ZXJmYWNlIERlY29kZWRUb2tlbiB7XG4gIGhlYWRlcjogb2JqZWN0O1xuICBjbGFpbXM6IENsYWltcztcbiAgZGF0YTogb2JqZWN0O1xuICBzaWduYXR1cmU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gaW50byBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiB3aXRoIGludmFsaWQgLyBpbmNvbXBsZXRlIGNsYWltcyBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGUgPSBmdW5jdGlvbiAodG9rZW46IHN0cmluZyk6IERlY29kZWRUb2tlbiB7XG4gIGxldCBoZWFkZXIgPSB7fSxcbiAgICBjbGFpbXM6IENsYWltcyA9IHt9LFxuICAgIGRhdGEgPSB7fSxcbiAgICBzaWduYXR1cmUgPSAnJztcblxuICB0cnkge1xuICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICBoZWFkZXIgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMF0pIHx8ICcnKSBhcyBvYmplY3Q7XG4gICAgY2xhaW1zID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzFdKSB8fCAnJykgYXMgQ2xhaW1zO1xuICAgIHNpZ25hdHVyZSA9IHBhcnRzWzJdO1xuICAgIGRhdGEgPSBjbGFpbXNbJ2QnXSB8fCB7fTtcbiAgICBkZWxldGUgY2xhaW1zWydkJ107XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgcmV0dXJuIHtcbiAgICBoZWFkZXIsXG4gICAgY2xhaW1zLFxuICAgIGRhdGEsXG4gICAgc2lnbmF0dXJlXG4gIH07XG59O1xuXG5pbnRlcmZhY2UgRGVjb2RlZFRva2VuIHtcbiAgaGVhZGVyOiBvYmplY3Q7XG4gIGNsYWltczogQ2xhaW1zO1xuICBkYXRhOiBvYmplY3Q7XG4gIHNpZ25hdHVyZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgdGltZS1iYXNlZCBjbGFpbXMuIFdpbGwgcmV0dXJuIHRydWUgaWYgdGhlXG4gKiB0b2tlbiBpcyB3aXRoaW4gdGhlIHRpbWUgd2luZG93IGF1dGhvcml6ZWQgYnkgdGhlICduYmYnIChub3QtYmVmb3JlKSBhbmQgJ2lhdCcgKGlzc3VlZC1hdCkgY2xhaW1zLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZFRpbWVzdGFtcCA9IGZ1bmN0aW9uICh0b2tlbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGNsYWltczogQ2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gIGNvbnN0IG5vdzogbnVtYmVyID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuICBsZXQgdmFsaWRTaW5jZTogbnVtYmVyID0gMCxcbiAgICB2YWxpZFVudGlsOiBudW1iZXIgPSAwO1xuXG4gIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ25iZicpKSB7XG4gICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWyduYmYnXSBhcyBudW1iZXI7XG4gICAgfSBlbHNlIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XG4gICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWydpYXQnXSBhcyBudW1iZXI7XG4gICAgfVxuXG4gICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnZXhwJykpIHtcbiAgICAgIHZhbGlkVW50aWwgPSBjbGFpbXNbJ2V4cCddIGFzIG51bWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG9rZW4gd2lsbCBleHBpcmUgYWZ0ZXIgMjRoIGJ5IGRlZmF1bHRcbiAgICAgIHZhbGlkVW50aWwgPSB2YWxpZFNpbmNlICsgODY0MDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICAhIW5vdyAmJlxuICAgICEhdmFsaWRTaW5jZSAmJlxuICAgICEhdmFsaWRVbnRpbCAmJlxuICAgIG5vdyA+PSB2YWxpZFNpbmNlICYmXG4gICAgbm93IDw9IHZhbGlkVW50aWxcbiAgKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCByZXR1cm5zIGl0cyBpc3N1ZWQgYXQgdGltZSBpZiB2YWxpZCwgbnVsbCBvdGhlcndpc2UuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gbnVsbCBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmV4cG9ydCBjb25zdCBpc3N1ZWRBdFRpbWUgPSBmdW5jdGlvbiAodG9rZW46IHN0cmluZyk6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBjbGFpbXM6IENsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xuICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xuICAgIHJldHVybiBjbGFpbXNbJ2lhdCddIGFzIG51bWJlcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyBmb3JtYXQuIEV4cGVjdHMgYSB2YWxpZCBpc3N1ZWQtYXQgdGltZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRGb3JtYXQgPSBmdW5jdGlvbiAodG9rZW46IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBkZWNvZGVkID0gZGVjb2RlKHRva2VuKSxcbiAgICBjbGFpbXMgPSBkZWNvZGVkLmNsYWltcztcblxuICByZXR1cm4gISFjbGFpbXMgJiYgdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKTtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcGVlciBpbnRvIGFuIGF1dGggdG9rZW4gYW5kIGRldGVybWluZSBpZiBpdCdzIGFuIGFkbWluIGF1dGggdG9rZW4gYnkgbG9va2luZyBhdCB0aGUgY2xhaW1zIHBvcnRpb24uXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmV4cG9ydCBjb25zdCBpc0FkbWluID0gZnVuY3Rpb24gKHRva2VuOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgY2xhaW1zOiBDbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcbiAgcmV0dXJuIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltc1snYWRtaW4nXSA9PT0gdHJ1ZTtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnM8VCBleHRlbmRzIG9iamVjdD4ob2JqOiBULCBrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVHZXQ8VCBleHRlbmRzIG9iamVjdCwgSyBleHRlbmRzIGtleW9mIFQ+KFxuICBvYmo6IFQsXG4gIGtleTogS1xuKTogVFtLXSB8IHVuZGVmaW5lZCB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkob2JqOiBvYmplY3QpOiBvYmogaXMge30ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcDxLIGV4dGVuZHMgc3RyaW5nLCBWLCBVPihcbiAgb2JqOiB7IFtrZXkgaW4gS106IFYgfSxcbiAgZm46ICh2YWx1ZTogViwga2V5OiBLLCBvYmo6IHsgW2tleSBpbiBLXTogViB9KSA9PiBVLFxuICBjb250ZXh0T2JqPzogdW5rbm93blxuKTogeyBba2V5IGluIEtdOiBVIH0ge1xuICBjb25zdCByZXM6IFBhcnRpYWw8eyBba2V5IGluIEtdOiBVIH0+ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGZuLmNhbGwoY29udGV4dE9iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcyBhcyB7IFtrZXkgaW4gS106IFUgfTtcbn1cblxuLyoqXG4gKiBEZWVwIGVxdWFsIHR3byBvYmplY3RzLiBTdXBwb3J0IEFycmF5cyBhbmQgT2JqZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBFcXVhbChhOiBvYmplY3QsIGI6IG9iamVjdCk6IGJvb2xlYW4ge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgZm9yIChjb25zdCBrIG9mIGFLZXlzKSB7XG4gICAgaWYgKCFiS2V5cy5pbmNsdWRlcyhrKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGFQcm9wID0gKGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW2tdO1xuICAgIGNvbnN0IGJQcm9wID0gKGIgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW2tdO1xuICAgIGlmIChpc09iamVjdChhUHJvcCkgJiYgaXNPYmplY3QoYlByb3ApKSB7XG4gICAgICBpZiAoIWRlZXBFcXVhbChhUHJvcCwgYlByb3ApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFQcm9wICE9PSBiUHJvcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgayBvZiBiS2V5cykge1xuICAgIGlmICghYUtleXMuaW5jbHVkZXMoaykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nOiB1bmtub3duKTogdGhpbmcgaXMgb2JqZWN0IHtcbiAgcmV0dXJuIHRoaW5nICE9PSBudWxsICYmIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCc7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJy4vZGVmZXJyZWQnO1xuXG4vKipcbiAqIFJlamVjdHMgaWYgdGhlIGdpdmVuIHByb21pc2UgZG9lc24ndCByZXNvbHZlIGluIHRpbWVJbk1TIG1pbGxpc2Vjb25kcy5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZVdpdGhUaW1lb3V0PFQ+KFxuICBwcm9taXNlOiBQcm9taXNlPFQ+LFxuICB0aW1lSW5NUyA9IDIwMDBcbik6IFByb21pc2U8VD4ge1xuICBjb25zdCBkZWZlcnJlZFByb21pc2UgPSBuZXcgRGVmZXJyZWQ8VD4oKTtcbiAgc2V0VGltZW91dCgoKSA9PiBkZWZlcnJlZFByb21pc2UucmVqZWN0KCd0aW1lb3V0IScpLCB0aW1lSW5NUyk7XG4gIHByb21pc2UudGhlbihkZWZlcnJlZFByb21pc2UucmVzb2x2ZSwgZGVmZXJyZWRQcm9taXNlLnJlamVjdCk7XG4gIHJldHVybiBkZWZlcnJlZFByb21pc2UucHJvbWlzZTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHF1ZXJ5c3RyaW5nLWZvcm1hdHRlZCBzdHJpbmcgKGUuZy4gJmFyZz12YWwmYXJnMj12YWwyKSBmcm9tIGFcbiAqIHBhcmFtcyBvYmplY3QgKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXG4gKiBOb3RlOiBZb3UgbXVzdCBwcmVwZW5kIGl0IHdpdGggPyB3aGVuIGFkZGluZyBpdCB0byBhIFVSTC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5c3RyaW5nUGFyYW1zOiB7XG4gIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlcjtcbn0pOiBzdHJpbmcge1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnlzdHJpbmdQYXJhbXMpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGFycmF5VmFsID0+IHtcbiAgICAgICAgcGFyYW1zLnB1c2goXG4gICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJyYXlWYWwpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtcy5sZW5ndGggPyAnJicgKyBwYXJhbXMuam9pbignJicpIDogJyc7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIHF1ZXJ5c3RyaW5nIChlLmcuID9hcmc9dmFsJmFyZzI9dmFsMikgaW50byBhIHBhcmFtcyBvYmplY3RcbiAqIChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlzdHJpbmdEZWNvZGUocXVlcnlzdHJpbmc6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICBjb25zdCBvYmo6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgY29uc3QgdG9rZW5zID0gcXVlcnlzdHJpbmcucmVwbGFjZSgvXlxcPy8sICcnKS5zcGxpdCgnJicpO1xuXG4gIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHRva2VuLnNwbGl0KCc9Jyk7XG4gICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KGtleSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIHF1ZXJ5IHN0cmluZyBwYXJ0IG9mIGEgVVJMLCBpbmNsdWRpbmcgdGhlIGxlYWRpbmcgcXVlc3Rpb24gbWFyayAoaWYgcHJlc2VudCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UXVlcnlzdHJpbmcodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBxdWVyeVN0YXJ0ID0gdXJsLmluZGV4T2YoJz8nKTtcbiAgaWYgKCFxdWVyeVN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IGZyYWdtZW50U3RhcnQgPSB1cmwuaW5kZXhPZignIycsIHF1ZXJ5U3RhcnQpO1xuICByZXR1cm4gdXJsLnN1YnN0cmluZyhcbiAgICBxdWVyeVN0YXJ0LFxuICAgIGZyYWdtZW50U3RhcnQgPiAwID8gZnJhZ21lbnRTdGFydCA6IHVuZGVmaW5lZFxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaC5cbiAqIFZhcmlhYmxlIG5hbWVzIGZvbGxvdyB0aGUgbm90YXRpb24gaW4gRklQUyBQVUIgMTgwLTM6XG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTMvZmlwczE4MC0zX2ZpbmFsLnBkZi5cbiAqXG4gKiBVc2FnZTpcbiAqICAgdmFyIHNoYTEgPSBuZXcgc2hhMSgpO1xuICogICBzaGExLnVwZGF0ZShieXRlcyk7XG4gKiAgIHZhciBoYXNoID0gc2hhMS5kaWdlc3QoKTtcbiAqXG4gKiBQZXJmb3JtYW5jZTpcbiAqICAgQ2hyb21lIDIzOiAgIH40MDAgTWJpdC9zXG4gKiAgIEZpcmVmb3ggMTY6ICB+MjUwIE1iaXQvc1xuICpcbiAqL1xuXG4vKipcbiAqIFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBUaGUgcHJvcGVydGllcyBkZWNsYXJlZCBoZXJlIGFyZSBkaXNjdXNzZWQgaW4gdGhlIGFib3ZlIGFsZ29yaXRobSBkb2N1bWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGZpbmFsXG4gKiBAc3RydWN0XG4gKi9cbmV4cG9ydCBjbGFzcyBTaGExIHtcbiAgLyoqXG4gICAqIEhvbGRzIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGEtZSBpbiB0aGUgY29tcHJlc3NfXG4gICAqIGZ1bmN0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjaGFpbl86IG51bWJlcltdID0gW107XG5cbiAgLyoqXG4gICAqIEEgYnVmZmVyIGhvbGRpbmcgdGhlIHBhcnRpYWxseSBjb21wdXRlZCBoYXNoIHJlc3VsdC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYnVmXzogbnVtYmVyW10gPSBbXTtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgODAgYnl0ZXMsIGVhY2ggYSBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIGhhc2hlZC4gIFJlZmVycmVkIHRvXG4gICAqIGFzIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGluIHRoZSBkb2NzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBXXzogbnVtYmVyW10gPSBbXTtcblxuICAvKipcbiAgICogQ29udGFpbnMgZGF0YSBuZWVkZWQgdG8gcGFkIG1lc3NhZ2VzIGxlc3MgdGhhbiA2NCBieXRlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcGFkXzogbnVtYmVyW10gPSBbXTtcblxuICAvKipcbiAgICogQHByaXZhdGUge251bWJlcn1cbiAgICovXG4gIHByaXZhdGUgaW5idWZfOiBudW1iZXIgPSAwO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgKi9cbiAgcHJpdmF0ZSB0b3RhbF86IG51bWJlciA9IDA7XG5cbiAgYmxvY2tTaXplOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ibG9ja1NpemUgPSA1MTIgLyA4O1xuXG4gICAgdGhpcy5wYWRfWzBdID0gMTI4O1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5ibG9ja1NpemU7ICsraSkge1xuICAgICAgdGhpcy5wYWRfW2ldID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmNoYWluX1swXSA9IDB4Njc0NTIzMDE7XG4gICAgdGhpcy5jaGFpbl9bMV0gPSAweGVmY2RhYjg5O1xuICAgIHRoaXMuY2hhaW5fWzJdID0gMHg5OGJhZGNmZTtcbiAgICB0aGlzLmNoYWluX1szXSA9IDB4MTAzMjU0NzY7XG4gICAgdGhpcy5jaGFpbl9bNF0gPSAweGMzZDJlMWYwO1xuXG4gICAgdGhpcy5pbmJ1Zl8gPSAwO1xuICAgIHRoaXMudG90YWxfID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBjb21wcmVzcyBoZWxwZXIgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBidWYgQmxvY2sgdG8gY29tcHJlc3MuXG4gICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IG9mIHRoZSBibG9jayBpbiB0aGUgYnVmZmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcHJlc3NfKGJ1ZjogbnVtYmVyW10gfCBVaW50OEFycmF5IHwgc3RyaW5nLCBvZmZzZXQ/OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBjb25zdCBXID0gdGhpcy5XXztcblxuICAgIC8vIGdldCAxNiBiaWcgZW5kaWFuIHdvcmRzXG4gICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgLy8gVE9ETyh1c2VyKTogW2J1ZyA4MTQwMTIyXSBSZWNlbnQgdmVyc2lvbnMgb2YgU2FmYXJpIGZvciBNYWMgT1MgYW5kIGlPU1xuICAgICAgICAvLyBoYXZlIGEgYnVnIHRoYXQgdHVybnMgdGhlIHBvc3QtaW5jcmVtZW50ICsrIG9wZXJhdG9yIGludG8gcHJlLWluY3JlbWVudFxuICAgICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uLiAgV2UgaGF2ZSBjb2RlIHRoYXQgZGVwZW5kcyBoZWF2aWx5IG9uIFNIQS0xIGZvclxuICAgICAgICAvLyBjb3JyZWN0bmVzcyBhbmQgd2hpY2ggaXMgYWZmZWN0ZWQgYnkgdGhpcyBidWcsIHNvIEkndmUgcmVtb3ZlZCBhbGwgdXNlc1xuICAgICAgICAvLyBvZiBwb3N0LWluY3JlbWVudCArKyBpbiB3aGljaCB0aGUgcmVzdWx0IHZhbHVlIGlzIHVzZWQuICBXZSBjYW4gcmV2ZXJ0XG4gICAgICAgIC8vIHRoaXMgY2hhbmdlIG9uY2UgdGhlIFNhZmFyaSBidWdcbiAgICAgICAgLy8gKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDkwMzYpIGhhcyBiZWVuIGZpeGVkIGFuZFxuICAgICAgICAvLyBtb3N0IGNsaWVudHMgaGF2ZSBiZWVuIHVwZGF0ZWQuXG4gICAgICAgIFdbaV0gPVxuICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0KSB8XG4gICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2KSB8XG4gICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDgpIHxcbiAgICAgICAgICBidWYuY2hhckNvZGVBdChvZmZzZXQgKyAzKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICBXW2ldID1cbiAgICAgICAgICAoYnVmW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICAgICAoYnVmW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAgICAgKGJ1ZltvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAgICAgYnVmW29mZnNldCArIDNdO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBleHBhbmQgdG8gODAgd29yZHNcbiAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICBjb25zdCB0ID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcbiAgICAgIFdbaV0gPSAoKHQgPDwgMSkgfCAodCA+Pj4gMzEpKSAmIDB4ZmZmZmZmZmY7XG4gICAgfVxuXG4gICAgbGV0IGEgPSB0aGlzLmNoYWluX1swXTtcbiAgICBsZXQgYiA9IHRoaXMuY2hhaW5fWzFdO1xuICAgIGxldCBjID0gdGhpcy5jaGFpbl9bMl07XG4gICAgbGV0IGQgPSB0aGlzLmNoYWluX1szXTtcbiAgICBsZXQgZSA9IHRoaXMuY2hhaW5fWzRdO1xuICAgIGxldCBmLCBrO1xuXG4gICAgLy8gVE9ETyh1c2VyKTogVHJ5IHRvIHVucm9sbCB0aGlzIGxvb3AgdG8gc3BlZWQgdXAgdGhlIGNvbXB1dGF0aW9uLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgaWYgKGkgPCA0MCkge1xuICAgICAgICBpZiAoaSA8IDIwKSB7XG4gICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgICAgIGsgPSAweDVhODI3OTk5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgayA9IDB4NmVkOWViYTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpIDwgNjApIHtcbiAgICAgICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgfCBjKSk7XG4gICAgICAgICAgayA9IDB4OGYxYmJjZGM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgICBrID0gMHhjYTYyYzFkNjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0ID0gKCgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyBrICsgV1tpXSkgJiAweGZmZmZmZmZmO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIHRoaXMuY2hhaW5fWzBdID0gKHRoaXMuY2hhaW5fWzBdICsgYSkgJiAweGZmZmZmZmZmO1xuICAgIHRoaXMuY2hhaW5fWzFdID0gKHRoaXMuY2hhaW5fWzFdICsgYikgJiAweGZmZmZmZmZmO1xuICAgIHRoaXMuY2hhaW5fWzJdID0gKHRoaXMuY2hhaW5fWzJdICsgYykgJiAweGZmZmZmZmZmO1xuICAgIHRoaXMuY2hhaW5fWzNdID0gKHRoaXMuY2hhaW5fWzNdICsgZCkgJiAweGZmZmZmZmZmO1xuICAgIHRoaXMuY2hhaW5fWzRdID0gKHRoaXMuY2hhaW5fWzRdICsgZSkgJiAweGZmZmZmZmZmO1xuICB9XG5cbiAgdXBkYXRlKGJ5dGVzPzogbnVtYmVyW10gfCBVaW50OEFycmF5IHwgc3RyaW5nLCBsZW5ndGg/OiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBUT0RPKGpvaG5sZW56KTogdGlnaHRlbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIGFuZCByZW1vdmUgdGhpcyBjaGVja1xuICAgIGlmIChieXRlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgbGVuZ3RoTWludXNCbG9jayA9IGxlbmd0aCAtIHRoaXMuYmxvY2tTaXplO1xuICAgIGxldCBuID0gMDtcbiAgICAvLyBVc2luZyBsb2NhbCBpbnN0ZWFkIG9mIG1lbWJlciB2YXJpYWJsZXMgZ2l2ZXMgfjUlIHNwZWVkdXAgb24gRmlyZWZveCAxNi5cbiAgICBjb25zdCBidWYgPSB0aGlzLmJ1Zl87XG4gICAgbGV0IGluYnVmID0gdGhpcy5pbmJ1Zl87XG5cbiAgICAvLyBUaGUgb3V0ZXIgd2hpbGUgbG9vcCBzaG91bGQgZXhlY3V0ZSBhdCBtb3N0IHR3aWNlLlxuICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XG4gICAgICAvLyBXaGVuIHdlIGhhdmUgbm8gZGF0YSBpbiB0aGUgYmxvY2sgdG8gdG9wIHVwLCB3ZSBjYW4gZGlyZWN0bHkgcHJvY2VzcyB0aGVcbiAgICAgIC8vIGlucHV0IGJ1ZmZlciAoYXNzdW1pbmcgaXQgY29udGFpbnMgc3VmZmljaWVudCBkYXRhKS4gVGhpcyBnaXZlcyB+MjUlXG4gICAgICAvLyBzcGVlZHVwIG9uIENocm9tZSAyMyBhbmQgfjE1JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYsIGJ1dCByZXF1aXJlcyB0aGF0XG4gICAgICAvLyB0aGUgZGF0YSBpcyBwcm92aWRlZCBpbiBsYXJnZSBjaHVua3MgKG9yIGluIG11bHRpcGxlcyBvZiA2NCBieXRlcykuXG4gICAgICBpZiAoaW5idWYgPT09IDApIHtcbiAgICAgICAgd2hpbGUgKG4gPD0gbGVuZ3RoTWludXNCbG9jaykge1xuICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ5dGVzLCBuKTtcbiAgICAgICAgICBuICs9IHRoaXMuYmxvY2tTaXplO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzLmNoYXJDb2RlQXQobik7XG4gICAgICAgICAgKytpbmJ1ZjtcbiAgICAgICAgICArK247XG4gICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcbiAgICAgICAgICAgIGluYnVmID0gMDtcbiAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXNbbl07XG4gICAgICAgICAgKytpbmJ1ZjtcbiAgICAgICAgICArK247XG4gICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcbiAgICAgICAgICAgIGluYnVmID0gMDtcbiAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5idWZfID0gaW5idWY7XG4gICAgdGhpcy50b3RhbF8gKz0gbGVuZ3RoO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkaWdlc3QoKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGRpZ2VzdDogbnVtYmVyW10gPSBbXTtcbiAgICBsZXQgdG90YWxCaXRzID0gdGhpcy50b3RhbF8gKiA4O1xuXG4gICAgLy8gQWRkIHBhZCAweDgwIDB4MDAqLlxuICAgIGlmICh0aGlzLmluYnVmXyA8IDU2KSB7XG4gICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIDU2IC0gdGhpcy5pbmJ1Zl8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIHRoaXMuYmxvY2tTaXplIC0gKHRoaXMuaW5idWZfIC0gNTYpKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgIyBiaXRzLlxuICAgIGZvciAobGV0IGkgPSB0aGlzLmJsb2NrU2l6ZSAtIDE7IGkgPj0gNTY7IGktLSkge1xuICAgICAgdGhpcy5idWZfW2ldID0gdG90YWxCaXRzICYgMjU1O1xuICAgICAgdG90YWxCaXRzIC89IDI1NjsgLy8gRG9uJ3QgdXNlIGJpdC1zaGlmdGluZyBoZXJlIVxuICAgIH1cblxuICAgIHRoaXMuY29tcHJlc3NfKHRoaXMuYnVmXyk7XG5cbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcbiAgICAgICAgZGlnZXN0W25dID0gKHRoaXMuY2hhaW5fW2ldID4+IGopICYgMjU1O1xuICAgICAgICArK247XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWdlc3Q7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgdHlwZSBOZXh0Rm48VD4gPSAodmFsdWU6IFQpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBFcnJvckZuID0gKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIENvbXBsZXRlRm4gPSAoKSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9ic2VydmVyPFQ+IHtcbiAgLy8gQ2FsbGVkIG9uY2UgZm9yIGVhY2ggdmFsdWUgaW4gYSBzdHJlYW0gb2YgdmFsdWVzLlxuICBuZXh0OiBOZXh0Rm48VD47XG5cbiAgLy8gQSBzdHJlYW0gdGVybWluYXRlcyBieSBhIHNpbmdsZSBjYWxsIHRvIEVJVEhFUiBlcnJvcigpIG9yIGNvbXBsZXRlKCkuXG4gIGVycm9yOiBFcnJvckZuO1xuXG4gIC8vIE5vIGV2ZW50cyB3aWxsIGJlIHNlbnQgdG8gbmV4dCgpIG9uY2UgY29tcGxldGUoKSBpcyBjYWxsZWQuXG4gIGNvbXBsZXRlOiBDb21wbGV0ZUZuO1xufVxuXG5leHBvcnQgdHlwZSBQYXJ0aWFsT2JzZXJ2ZXI8VD4gPSBQYXJ0aWFsPE9ic2VydmVyPFQ+PjtcblxuLy8gVE9ETzogU3VwcG9ydCBhbHNvIFVuc3Vic2NyaWJlLnVuc3Vic2NyaWJlP1xuZXhwb3J0IHR5cGUgVW5zdWJzY3JpYmUgPSAoKSA9PiB2b2lkO1xuXG4vKipcbiAqIFRoZSBTdWJzY3JpYmUgaW50ZXJmYWNlIGhhcyB0d28gZm9ybXMgLSBwYXNzaW5nIHRoZSBpbmxpbmUgZnVuY3Rpb25cbiAqIGNhbGxiYWNrcywgb3IgYSBvYmplY3QgaW50ZXJmYWNlIHdpdGggY2FsbGJhY2sgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpYmU8VD4ge1xuICAobmV4dD86IE5leHRGbjxUPiwgZXJyb3I/OiBFcnJvckZuLCBjb21wbGV0ZT86IENvbXBsZXRlRm4pOiBVbnN1YnNjcmliZTtcbiAgKG9ic2VydmVyOiBQYXJ0aWFsT2JzZXJ2ZXI8VD4pOiBVbnN1YnNjcmliZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgLy8gU3Vic2NyaWJlIG1ldGhvZFxuICBzdWJzY3JpYmU6IFN1YnNjcmliZTxUPjtcbn1cblxuZXhwb3J0IHR5cGUgRXhlY3V0b3I8VD4gPSAob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB2b2lkO1xuXG4vKipcbiAqIEhlbHBlciB0byBtYWtlIGEgU3Vic2NyaWJlIGZ1bmN0aW9uIChqdXN0IGxpa2UgUHJvbWlzZSBoZWxwcyBtYWtlIGFcbiAqIFRoZW5hYmxlKS5cbiAqXG4gKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcbiAqICAgICBhcyBhIHByb3h5LlxuICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3Vic2NyaWJlPFQ+KFxuICBleGVjdXRvcjogRXhlY3V0b3I8VD4sXG4gIG9uTm9PYnNlcnZlcnM/OiBFeGVjdXRvcjxUPlxuKTogU3Vic2NyaWJlPFQ+IHtcbiAgY29uc3QgcHJveHkgPSBuZXcgT2JzZXJ2ZXJQcm94eTxUPihleGVjdXRvciwgb25Ob09ic2VydmVycyk7XG4gIHJldHVybiBwcm94eS5zdWJzY3JpYmUuYmluZChwcm94eSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50IGZhbi1vdXQgZm9yIGFueSBudW1iZXIgb2YgT2JzZXJ2ZXJzIGF0dGFjaGVkIHZpYSBhIHN1YnNjcmliZVxuICogZnVuY3Rpb24uXG4gKi9cbmNsYXNzIE9ic2VydmVyUHJveHk8VD4gaW1wbGVtZW50cyBPYnNlcnZlcjxUPiB7XG4gIHByaXZhdGUgb2JzZXJ2ZXJzOiBBcnJheTxPYnNlcnZlcjxUPj4gfCB1bmRlZmluZWQgPSBbXTtcbiAgcHJpdmF0ZSB1bnN1YnNjcmliZXM6IFVuc3Vic2NyaWJlW10gPSBbXTtcbiAgcHJpdmF0ZSBvbk5vT2JzZXJ2ZXJzOiBFeGVjdXRvcjxUPiB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBvYnNlcnZlckNvdW50ID0gMDtcbiAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXG4gIHByaXZhdGUgdGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBwcml2YXRlIGZpbmFsaXplZCA9IGZhbHNlO1xuICBwcml2YXRlIGZpbmFsRXJyb3I/OiBFcnJvcjtcblxuICAvKipcbiAgICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXG4gICAqICAgICBhcyBhIHByb3h5LlxuICAgKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcjogRXhlY3V0b3I8VD4sIG9uTm9PYnNlcnZlcnM/OiBFeGVjdXRvcjxUPikge1xuICAgIHRoaXMub25Ob09ic2VydmVycyA9IG9uTm9PYnNlcnZlcnM7XG4gICAgLy8gQ2FsbCB0aGUgZXhlY3V0b3IgYXN5bmNocm9ub3VzbHkgc28gc3Vic2NyaWJlcnMgdGhhdCBhcmUgY2FsbGVkXG4gICAgLy8gc3luY2hyb25vdXNseSBhZnRlciB0aGUgY3JlYXRpb24gb2YgdGhlIHN1YnNjcmliZSBmdW5jdGlvblxuICAgIC8vIGNhbiBzdGlsbCByZWNlaXZlIHRoZSB2ZXJ5IGZpcnN0IHZhbHVlIGdlbmVyYXRlZCBpbiB0aGUgZXhlY3V0b3IuXG4gICAgdGhpcy50YXNrXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGV4ZWN1dG9yKHRoaXMpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcbiAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZXJyb3IoZXJyb3I6IEVycm9yKTogdm9pZCB7XG4gICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xuICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICAgIHRoaXMuY2xvc2UoZXJyb3IpO1xuICB9XG5cbiAgY29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xuICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICB9KTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIGFuIE9ic2VydmVyIHRvIHRoZSBmYW4tb3V0IGxpc3QuXG4gICAqXG4gICAqIC0gV2UgcmVxdWlyZSB0aGF0IG5vIGV2ZW50IGlzIHNlbnQgdG8gYSBzdWJzY3JpYmVyIHN5Y2hyb25vdXNseSB0byB0aGVpclxuICAgKiAgIGNhbGwgdG8gc3Vic2NyaWJlKCkuXG4gICAqL1xuICBzdWJzY3JpYmUoXG4gICAgbmV4dE9yT2JzZXJ2ZXI/OiBOZXh0Rm48VD4gfCBQYXJ0aWFsT2JzZXJ2ZXI8VD4sXG4gICAgZXJyb3I/OiBFcnJvckZuLFxuICAgIGNvbXBsZXRlPzogQ29tcGxldGVGblxuICApOiBVbnN1YnNjcmliZSB7XG4gICAgbGV0IG9ic2VydmVyOiBPYnNlcnZlcjxUPjtcblxuICAgIGlmIChcbiAgICAgIG5leHRPck9ic2VydmVyID09PSB1bmRlZmluZWQgJiZcbiAgICAgIGVycm9yID09PSB1bmRlZmluZWQgJiZcbiAgICAgIGNvbXBsZXRlID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBPYnNlcnZlci4nKTtcbiAgICB9XG5cbiAgICAvLyBBc3NlbWJsZSBhbiBPYnNlcnZlciBvYmplY3Qgd2hlbiBwYXNzZWQgYXMgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgIGlmIChcbiAgICAgIGltcGxlbWVudHNBbnlNZXRob2RzKG5leHRPck9ic2VydmVyIGFzIHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9LCBbXG4gICAgICAgICduZXh0JyxcbiAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgJ2NvbXBsZXRlJ1xuICAgICAgXSlcbiAgICApIHtcbiAgICAgIG9ic2VydmVyID0gbmV4dE9yT2JzZXJ2ZXIgYXMgT2JzZXJ2ZXI8VD47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmVyID0ge1xuICAgICAgICBuZXh0OiBuZXh0T3JPYnNlcnZlciBhcyBOZXh0Rm48VD4sXG4gICAgICAgIGVycm9yLFxuICAgICAgICBjb21wbGV0ZVxuICAgICAgfSBhcyBPYnNlcnZlcjxUPjtcbiAgICB9XG5cbiAgICBpZiAob2JzZXJ2ZXIubmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYnNlcnZlci5uZXh0ID0gbm9vcCBhcyBOZXh0Rm48VD47XG4gICAgfVxuICAgIGlmIChvYnNlcnZlci5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYnNlcnZlci5lcnJvciA9IG5vb3AgYXMgRXJyb3JGbjtcbiAgICB9XG4gICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9ic2VydmVyLmNvbXBsZXRlID0gbm9vcCBhcyBDb21wbGV0ZUZuO1xuICAgIH1cblxuICAgIGNvbnN0IHVuc3ViID0gdGhpcy51bnN1YnNjcmliZU9uZS5iaW5kKHRoaXMsIHRoaXMub2JzZXJ2ZXJzIS5sZW5ndGgpO1xuXG4gICAgLy8gQXR0ZW1wdCB0byBzdWJzY3JpYmUgdG8gYSB0ZXJtaW5hdGVkIE9ic2VydmFibGUgLSB3ZVxuICAgIC8vIGp1c3QgcmVzcG9uZCB0byB0aGUgT2JzZXJ2ZXIgd2l0aCB0aGUgZmluYWwgZXJyb3Igb3IgY29tcGxldGVcbiAgICAvLyBldmVudC5cbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodGhpcy5maW5hbEVycm9yKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcih0aGlzLmZpbmFsRXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm9ic2VydmVycyEucHVzaChvYnNlcnZlciBhcyBPYnNlcnZlcjxUPik7XG5cbiAgICByZXR1cm4gdW5zdWI7XG4gIH1cblxuICAvLyBVbnN1YnNjcmliZSBpcyBzeW5jaHJvbm91cyAtIHdlIGd1YXJhbnRlZSB0aGF0IG5vIGV2ZW50cyBhcmUgc2VudCB0b1xuICAvLyBhbnkgdW5zdWJzY3JpYmVkIE9ic2VydmVyLlxuICBwcml2YXRlIHVuc3Vic2NyaWJlT25lKGk6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLm9ic2VydmVycyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub2JzZXJ2ZXJzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5vYnNlcnZlcnNbaV07XG5cbiAgICB0aGlzLm9ic2VydmVyQ291bnQgLT0gMTtcbiAgICBpZiAodGhpcy5vYnNlcnZlckNvdW50ID09PSAwICYmIHRoaXMub25Ob09ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9uTm9PYnNlcnZlcnModGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmb3JFYWNoT2JzZXJ2ZXIoZm46IChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIC8vIEFscmVhZHkgY2xvc2VkIGJ5IHByZXZpb3VzIGV2ZW50Li4uLmp1c3QgZWF0IHRoZSBhZGRpdGlvbmFsIHZhbHVlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSBzZW5kT25lIGNhbGxzIGFzeW5jaHJvbm91c2x5IC0gdGhlcmUgaXMgbm8gY2hhbmNlIHRoYXRcbiAgICAvLyB0aGlzLm9ic2VydmVycyB3aWxsIGJlY29tZSB1bmRlZmluZWQuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVycyEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc2VuZE9uZShpLCBmbik7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbCB0aGUgT2JzZXJ2ZXIgdmlhIG9uZSBvZiBpdCdzIGNhbGxiYWNrIGZ1bmN0aW9uLiBXZSBhcmUgY2FyZWZ1bCB0b1xuICAvLyBjb25maXJtIHRoYXQgdGhlIG9ic2VydmUgaGFzIG5vdCBiZWVuIHVuc3Vic2NyaWJlZCBzaW5jZSB0aGlzIGFzeW5jaHJvbm91c1xuICAvLyBmdW5jdGlvbiBoYWQgYmVlbiBxdWV1ZWQuXG4gIHByaXZhdGUgc2VuZE9uZShpOiBudW1iZXIsIGZuOiAob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgLy8gRXhlY3V0ZSB0aGUgY2FsbGJhY2sgYXN5bmNocm9ub3VzbHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vYnNlcnZlcnNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZuKHRoaXMub2JzZXJ2ZXJzW2ldKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIHJhaXNlZCBpbiBPYnNlcnZlcnMgb3IgbWlzc2luZyBtZXRob2RzIG9mIGFuXG4gICAgICAgICAgLy8gT2JzZXJ2ZXIuXG4gICAgICAgICAgLy8gTG9nIGVycm9yIHRvIGNvbnNvbGUuIGIvMzE0MDQ4MDZcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNsb3NlKGVycj86IEVycm9yKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZmluYWxFcnJvciA9IGVycjtcbiAgICB9XG4gICAgLy8gUHJveHkgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIGdhcmJhZ2UgY29sbGVjdCByZWZlcmVuY2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKiBUdXJuIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gb25lIGNhbGxlZCBhc3luY2hyb25vdXNseS4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5leHBvcnQgZnVuY3Rpb24gYXN5bmMoZm46IEZ1bmN0aW9uLCBvbkVycm9yPzogRXJyb3JGbik6IEZ1bmN0aW9uIHtcbiAgcmV0dXJuICguLi5hcmdzOiB1bmtub3duW10pID0+IHtcbiAgICBQcm9taXNlLnJlc29sdmUodHJ1ZSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaW4gaW1wbGVtZW50cyBhbnkgb2YgdGhlIG5hbWVkIG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKFxuICBvYmo6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9LFxuICBtZXRob2RzOiBzdHJpbmdbXVxuKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKTogdm9pZCB7XG4gIC8vIGRvIG5vdGhpbmdcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXJndW1lbnRzIGFyZSBwcm92aWRlZCBmb3IgYSBwdWJsaWMgZnVuY3Rpb24uXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXG4gKlxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXG4gKiBAcGFyYW0gbWF4Q291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50IHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxuICogQHBhcmFtIGFyZ0NvdW50IFRoZSBhY3R1YWwgbnVtYmVyIG9mIGFyZ3VtZW50cyBwcm92aWRlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQXJnQ291bnQgPSBmdW5jdGlvbiAoXG4gIGZuTmFtZTogc3RyaW5nLFxuICBtaW5Db3VudDogbnVtYmVyLFxuICBtYXhDb3VudDogbnVtYmVyLFxuICBhcmdDb3VudDogbnVtYmVyXG4pOiB2b2lkIHtcbiAgbGV0IGFyZ0Vycm9yO1xuICBpZiAoYXJnQ291bnQgPCBtaW5Db3VudCkge1xuICAgIGFyZ0Vycm9yID0gJ2F0IGxlYXN0ICcgKyBtaW5Db3VudDtcbiAgfSBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XG4gICAgYXJnRXJyb3IgPSBtYXhDb3VudCA9PT0gMCA/ICdub25lJyA6ICdubyBtb3JlIHRoYW4gJyArIG1heENvdW50O1xuICB9XG4gIGlmIChhcmdFcnJvcikge1xuICAgIGNvbnN0IGVycm9yID1cbiAgICAgIGZuTmFtZSArXG4gICAgICAnIGZhaWxlZDogV2FzIGNhbGxlZCB3aXRoICcgK1xuICAgICAgYXJnQ291bnQgK1xuICAgICAgKGFyZ0NvdW50ID09PSAxID8gJyBhcmd1bWVudC4nIDogJyBhcmd1bWVudHMuJykgK1xuICAgICAgJyBFeHBlY3RzICcgK1xuICAgICAgYXJnRXJyb3IgK1xuICAgICAgJy4nO1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHRvIHByZWZpeCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IGZhaWxlZCBhcmd1bWVudCB2YWxpZGF0aW9uXG4gKlxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIGFyZ05hbWUgVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcmV0dXJuIFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciB0aHJvd24gZm9yIHZhbGlkYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvclByZWZpeChmbk5hbWU6IHN0cmluZywgYXJnTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2ZuTmFtZX0gZmFpbGVkOiAke2FyZ05hbWV9IGFyZ3VtZW50IGA7XG59XG5cbi8qKlxuICogQHBhcmFtIGZuTmFtZVxuICogQHBhcmFtIGFyZ3VtZW50TnVtYmVyXG4gKiBAcGFyYW0gbmFtZXNwYWNlXG4gKiBAcGFyYW0gb3B0aW9uYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTmFtZXNwYWNlKFxuICBmbk5hbWU6IHN0cmluZyxcbiAgbmFtZXNwYWNlOiBzdHJpbmcsXG4gIG9wdGlvbmFsOiBib29sZWFuXG4pOiB2b2lkIHtcbiAgaWYgKG9wdGlvbmFsICYmICFuYW1lc3BhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgLy9UT0RPOiBJIHNob3VsZCBkbyBtb3JlIHZhbGlkYXRpb24gaGVyZS4gV2Ugb25seSBhbGxvdyBjZXJ0YWluIGNoYXJzIGluIG5hbWVzcGFjZXMuXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyb3JQcmVmaXgoZm5OYW1lLCAnbmFtZXNwYWNlJykgKyAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIG5hbWVzcGFjZS4nXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDYWxsYmFjayhcbiAgZm5OYW1lOiBzdHJpbmcsXG4gIGFyZ3VtZW50TmFtZTogc3RyaW5nLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICBjYWxsYmFjazogRnVuY3Rpb24sXG4gIG9wdGlvbmFsOiBib29sZWFuXG4pOiB2b2lkIHtcbiAgaWYgKG9wdGlvbmFsICYmICFjYWxsYmFjaykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBmdW5jdGlvbi4nXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0T2JqZWN0KFxuICBmbk5hbWU6IHN0cmluZyxcbiAgYXJndW1lbnROYW1lOiBzdHJpbmcsXG4gIGNvbnRleHQ6IHVua25vd24sXG4gIG9wdGlvbmFsOiBib29sZWFuXG4pOiB2b2lkIHtcbiAgaWYgKG9wdGlvbmFsICYmICFjb250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuJ1xuICAgICk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vYXNzZXJ0JztcblxuLy8gQ29kZSBvcmlnaW5hbGx5IGNhbWUgZnJvbSBnb29nLmNyeXB0LnN0cmluZ1RvVXRmOEJ5dGVBcnJheSwgYnV0IGZvciBzb21lIHJlYXNvbiB0aGV5XG4vLyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkICdcXHJcXG4nIHdpdGggJ1xcbicsIGFuZCB0aGV5IGRpZG4ndCBoYW5kbGUgc3Vycm9nYXRlIHBhaXJzLFxuLy8gc28gaXQncyBiZWVuIG1vZGlmaWVkLlxuXG4vLyBOb3RlIHRoYXQgbm90IGFsbCBVbmljb2RlIGNoYXJhY3RlcnMgYXBwZWFyIGFzIHNpbmdsZSBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cbi8vIGZyb21DaGFyQ29kZSByZXR1cm5zIHRoZSBVVEYtMTYgZW5jb2Rpbmcgb2YgYSBjaGFyYWN0ZXIgLSBzbyBzb21lIFVuaWNvZGUgY2hhcmFjdGVyc1xuLy8gdXNlIDIgY2hhcmFjdGVycyBpbiBKYXZhc2NyaXB0LiAgQWxsIDQtYnl0ZSBVVEYtOCBjaGFyYWN0ZXJzIGJlZ2luIHdpdGggYSBmaXJzdFxuLy8gY2hhcmFjdGVyIGluIHRoZSByYW5nZSAweEQ4MDAgLSAweERCRkYgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzby1jYWxsZWQgc3Vycm9nYXRlXG4vLyBwYWlyKS5cbi8vIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuMS4zXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZyk6IG51bWJlcltdIHtcbiAgY29uc3Qgb3V0OiBudW1iZXJbXSA9IFtdO1xuICBsZXQgcCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIC8vIElzIHRoaXMgdGhlIGxlYWQgc3Vycm9nYXRlIGluIGEgc3Vycm9nYXRlIHBhaXI/XG4gICAgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICBjb25zdCBoaWdoID0gYyAtIDB4ZDgwMDsgLy8gdGhlIGhpZ2ggMTAgYml0cy5cbiAgICAgIGkrKztcbiAgICAgIGFzc2VydChpIDwgc3RyLmxlbmd0aCwgJ1N1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLicpO1xuICAgICAgY29uc3QgbG93ID0gc3RyLmNoYXJDb2RlQXQoaSkgLSAweGRjMDA7IC8vIHRoZSBsb3cgMTAgYml0cy5cbiAgICAgIGMgPSAweDEwMDAwICsgKGhpZ2ggPDwgMTApICsgbG93O1xuICAgIH1cblxuICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICBvdXRbcCsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgb3V0W3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcbiAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgfSBlbHNlIGlmIChjIDwgNjU1MzYpIHtcbiAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xuICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcbiAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIGxlbmd0aCB3aXRob3V0IGFjdHVhbGx5IGNvbnZlcnRpbmc7IHVzZWZ1bCBmb3IgZG9pbmcgY2hlYXBlciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3Qgc3RyaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHN0cjogc3RyaW5nKTogbnVtYmVyIHtcbiAgbGV0IHAgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgcCsrO1xuICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgIHAgKz0gMjtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxuICAgICAgcCArPSA0O1xuICAgICAgaSsrOyAvLyBza2lwIHRyYWlsIHN1cnJvZ2F0ZS5cbiAgICB9IGVsc2Uge1xuICAgICAgcCArPSAzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcDtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIENvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTE3NTIzXG4gKiBHZW5lcmF0ZXMgYSBuZXcgdXVpZC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHV1aWR2NCA9IGZ1bmN0aW9uICgpOiBzdHJpbmcge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBjID0+IHtcbiAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLFxuICAgICAgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGV4cG9uZW50aWFsbHkgaW5jcmVhc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfSU5URVJWQUxfTUlMTElTID0gMTAwMDtcblxuLyoqXG4gKiBUaGUgZmFjdG9yIHRvIGJhY2tvZmYgYnkuXG4gKiBTaG91bGQgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDEuXG4gKi9cbmNvbnN0IERFRkFVTFRfQkFDS09GRl9GQUNUT1IgPSAyO1xuXG4vKipcbiAqIFRoZSBtYXhpbXVtIG1pbGxpc2Vjb25kcyB0byBpbmNyZWFzZSB0by5cbiAqXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXG4gKi9cbmV4cG9ydCBjb25zdCBNQVhfVkFMVUVfTUlMTElTID0gNCAqIDYwICogNjAgKiAxMDAwOyAvLyBGb3VyIGhvdXJzLCBsaWtlIGlPUyBhbmQgQW5kcm9pZC5cblxuLyoqXG4gKiBUaGUgcGVyY2VudGFnZSBvZiBiYWNrb2ZmIHRpbWUgdG8gcmFuZG9taXplIGJ5LlxuICogU2VlXG4gKiBodHRwOi8vZ28vc2FmZS1jbGllbnQtYmVoYXZpb3Ijc3RlcC0xLWRldGVybWluZS10aGUtYXBwcm9wcmlhdGUtcmV0cnktaW50ZXJ2YWwtdG8taGFuZGxlLXNwaWtlLXRyYWZmaWNcbiAqIGZvciBjb250ZXh0LlxuICpcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFJBTkRPTV9GQUNUT1IgPSAwLjU7XG5cbi8qKlxuICogQmFzZWQgb24gdGhlIGJhY2tvZmYgbWV0aG9kIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9tYXRoL2V4cG9uZW50aWFsYmFja29mZi5qcy5cbiAqIEV4dHJhY3RlZCBoZXJlIHNvIHdlIGRvbid0IG5lZWQgdG8gcGFzcyBtZXRhZGF0YSBhbmQgYSBzdGF0ZWZ1bCBFeHBvbmVudGlhbEJhY2tvZmYgb2JqZWN0IGFyb3VuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMoXG4gIGJhY2tvZmZDb3VudDogbnVtYmVyLFxuICBpbnRlcnZhbE1pbGxpczogbnVtYmVyID0gREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMsXG4gIGJhY2tvZmZGYWN0b3I6IG51bWJlciA9IERFRkFVTFRfQkFDS09GRl9GQUNUT1Jcbik6IG51bWJlciB7XG4gIC8vIENhbGN1bGF0ZXMgYW4gZXhwb25lbnRpYWxseSBpbmNyZWFzaW5nIHZhbHVlLlxuICAvLyBEZXZpYXRpb246IGNhbGN1bGF0ZXMgdmFsdWUgZnJvbSBjb3VudCBhbmQgYSBjb25zdGFudCBpbnRlcnZhbCwgc28gd2Ugb25seSBuZWVkIHRvIHNhdmUgdmFsdWVcbiAgLy8gYW5kIGNvdW50IHRvIHJlc3RvcmUgc3RhdGUuXG4gIGNvbnN0IGN1cnJCYXNlVmFsdWUgPSBpbnRlcnZhbE1pbGxpcyAqIE1hdGgucG93KGJhY2tvZmZGYWN0b3IsIGJhY2tvZmZDb3VudCk7XG5cbiAgLy8gQSByYW5kb20gXCJmdXp6XCIgdG8gYXZvaWQgd2F2ZXMgb2YgcmV0cmllcy5cbiAgLy8gRGV2aWF0aW9uOiByYW5kb21GYWN0b3IgaXMgcmVxdWlyZWQuXG4gIGNvbnN0IHJhbmRvbVdhaXQgPSBNYXRoLnJvdW5kKFxuICAgIC8vIEEgZnJhY3Rpb24gb2YgdGhlIGJhY2tvZmYgdmFsdWUgdG8gYWRkL3N1YnRyYWN0LlxuICAgIC8vIERldmlhdGlvbjogY2hhbmdlcyBtdWx0aXBsaWNhdGlvbiBvcmRlciB0byBpbXByb3ZlIHJlYWRhYmlsaXR5LlxuICAgIFJBTkRPTV9GQUNUT1IgKlxuICAgICAgY3VyckJhc2VWYWx1ZSAqXG4gICAgICAvLyBBIHJhbmRvbSBmbG9hdCAocm91bmRlZCB0byBpbnQgYnkgTWF0aC5yb3VuZCBhYm92ZSkgaW4gdGhlIHJhbmdlIFstMSwgMV0uIERldGVybWluZXNcbiAgICAgIC8vIGlmIHdlIGFkZCBvciBzdWJ0cmFjdC5cbiAgICAgIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqXG4gICAgICAyXG4gICk7XG5cbiAgLy8gTGltaXRzIGJhY2tvZmYgdG8gbWF4IHRvIGF2b2lkIGVmZmVjdGl2ZWx5IHBlcm1hbmVudCBiYWNrb2ZmLlxuICByZXR1cm4gTWF0aC5taW4oTUFYX1ZBTFVFX01JTExJUywgY3VyckJhc2VWYWx1ZSArIHJhbmRvbVdhaXQpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBQcm92aWRlIEVuZ2xpc2ggb3JkaW5hbCBsZXR0ZXJzIGFmdGVyIGEgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcmRpbmFsKGk6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGkpKSB7XG4gICAgcmV0dXJuIGAke2l9YDtcbiAgfVxuICByZXR1cm4gaSArIGluZGljYXRvcihpKTtcbn1cblxuZnVuY3Rpb24gaW5kaWNhdG9yKGk6IG51bWJlcik6IHN0cmluZyB7XG4gIGkgPSBNYXRoLmFicyhpKTtcbiAgY29uc3QgY2VudCA9IGkgJSAxMDA7XG4gIGlmIChjZW50ID49IDEwICYmIGNlbnQgPD0gMjApIHtcbiAgICByZXR1cm4gJ3RoJztcbiAgfVxuICBjb25zdCBkZWMgPSBpICUgMTA7XG4gIGlmIChkZWMgPT09IDEpIHtcbiAgICByZXR1cm4gJ3N0JztcbiAgfVxuICBpZiAoZGVjID09PSAyKSB7XG4gICAgcmV0dXJuICduZCc7XG4gIH1cbiAgaWYgKGRlYyA9PT0gMykge1xuICAgIHJldHVybiAncmQnO1xuICB9XG4gIHJldHVybiAndGgnO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBDb21wYXQ8VD4ge1xuICBfZGVsZWdhdGU6IFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2R1bGFySW5zdGFuY2U8RXhwU2VydmljZT4oXG4gIHNlcnZpY2U6IENvbXBhdDxFeHBTZXJ2aWNlPiB8IEV4cFNlcnZpY2Vcbik6IEV4cFNlcnZpY2Uge1xuICBpZiAoc2VydmljZSAmJiAoc2VydmljZSBhcyBDb21wYXQ8RXhwU2VydmljZT4pLl9kZWxlZ2F0ZSkge1xuICAgIHJldHVybiAoc2VydmljZSBhcyBDb21wYXQ8RXhwU2VydmljZT4pLl9kZWxlZ2F0ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2VydmljZSBhcyBFeHBTZXJ2aWNlO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHtcbiAgSW5zdGFudGlhdGlvbk1vZGUsXG4gIEluc3RhbmNlRmFjdG9yeSxcbiAgQ29tcG9uZW50VHlwZSxcbiAgRGljdGlvbmFyeSxcbiAgTmFtZSxcbiAgb25JbnN0YW5jZUNyZWF0ZWRDYWxsYmFja1xufSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBDb21wb25lbnQgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuIGBhdXRoYCwgYGF1dGgtaW50ZXJuYWxgXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21wb25lbnQ8VCBleHRlbmRzIE5hbWUgPSBOYW1lPiB7XG4gIG11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XG4gIC8qKlxuICAgKiBQcm9wZXJ0aWVzIHRvIGJlIGFkZGVkIHRvIHRoZSBzZXJ2aWNlIG5hbWVzcGFjZVxuICAgKi9cbiAgc2VydmljZVByb3BzOiBEaWN0aW9uYXJ5ID0ge307XG5cbiAgaW5zdGFudGlhdGlvbk1vZGUgPSBJbnN0YW50aWF0aW9uTW9kZS5MQVpZO1xuXG4gIG9uSW5zdGFuY2VDcmVhdGVkOiBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrPFQ+IHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBwdWJsaWMgc2VydmljZSBuYW1lLCBlLmcuIGFwcCwgYXV0aCwgZmlyZXN0b3JlLCBkYXRhYmFzZVxuICAgKiBAcGFyYW0gaW5zdGFuY2VGYWN0b3J5IFNlcnZpY2UgZmFjdG9yeSByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhlIHB1YmxpYyBpbnRlcmZhY2VcbiAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGUgc2VydmljZSBwcm92aWRlZCBieSB0aGUgY29tcG9uZW50IGlzIHB1YmxpYyBvciBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBuYW1lOiBULFxuICAgIHJlYWRvbmx5IGluc3RhbmNlRmFjdG9yeTogSW5zdGFuY2VGYWN0b3J5PFQ+LFxuICAgIHJlYWRvbmx5IHR5cGU6IENvbXBvbmVudFR5cGVcbiAgKSB7fVxuXG4gIHNldEluc3RhbnRpYXRpb25Nb2RlKG1vZGU6IEluc3RhbnRpYXRpb25Nb2RlKTogdGhpcyB7XG4gICAgdGhpcy5pbnN0YW50aWF0aW9uTW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRNdWx0aXBsZUluc3RhbmNlcyhtdWx0aXBsZUluc3RhbmNlczogYm9vbGVhbik6IHRoaXMge1xuICAgIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgPSBtdWx0aXBsZUluc3RhbmNlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFNlcnZpY2VQcm9wcyhwcm9wczogRGljdGlvbmFyeSk6IHRoaXMge1xuICAgIHRoaXMuc2VydmljZVByb3BzID0gcHJvcHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRJbnN0YW5jZUNyZWF0ZWRDYWxsYmFjayhjYWxsYmFjazogb25JbnN0YW5jZUNyZWF0ZWRDYWxsYmFjazxUPik6IHRoaXMge1xuICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBDb21wb25lbnRDb250YWluZXIgfSBmcm9tICcuL2NvbXBvbmVudF9jb250YWluZXInO1xuaW1wb3J0IHsgREVGQVVMVF9FTlRSWV9OQU1FIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtcbiAgSW5pdGlhbGl6ZU9wdGlvbnMsXG4gIEluc3RhbnRpYXRpb25Nb2RlLFxuICBOYW1lLFxuICBOYW1lU2VydmljZU1hcHBpbmcsXG4gIE9uSW5pdENhbGxCYWNrXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnQnO1xuXG4vKipcbiAqIFByb3ZpZGVyIGZvciBpbnN0YW5jZSBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gJ2F1dGgnLCAnYXV0aC1pbnRlcm5hbCdcbiAqIE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSBpcyBhbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm92aWRlcjxUIGV4dGVuZHMgTmFtZT4ge1xuICBwcml2YXRlIGNvbXBvbmVudDogQ29tcG9uZW50PFQ+IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcmVhZG9ubHkgaW5zdGFuY2VzOiBNYXA8c3RyaW5nLCBOYW1lU2VydmljZU1hcHBpbmdbVF0+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlYWRvbmx5IGluc3RhbmNlc0RlZmVycmVkOiBNYXA8XG4gICAgc3RyaW5nLFxuICAgIERlZmVycmVkPE5hbWVTZXJ2aWNlTWFwcGluZ1tUXT5cbiAgPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBpbnN0YW5jZXNPcHRpb25zOiBNYXA8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4gPVxuICAgIG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBvbkluaXRDYWxsYmFja3M6IE1hcDxzdHJpbmcsIFNldDxPbkluaXRDYWxsQmFjazxUPj4+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmFtZTogVCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbnRhaW5lcjogQ29tcG9uZW50Q29udGFpbmVyXG4gICkge31cblxuICAvKipcbiAgICogQHBhcmFtIGlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWxpdHBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXG4gICAqIGlmIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzIGlzIHRydWUuXG4gICAqL1xuICBnZXQoaWRlbnRpZmllcj86IHN0cmluZyk6IFByb21pc2U8TmFtZVNlcnZpY2VNYXBwaW5nW1RdPiB7XG4gICAgLy8gaWYgbXVsdGlwbGVJbnN0YW5jZXMgaXMgbm90IHN1cHBvcnRlZCwgdXNlIHRoZSBkZWZhdWx0IG5hbWVcbiAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuXG4gICAgaWYgKCF0aGlzLmluc3RhbmNlc0RlZmVycmVkLmhhcyhub3JtYWxpemVkSWRlbnRpZmllcikpIHtcbiAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkPE5hbWVTZXJ2aWNlTWFwcGluZ1tUXT4oKTtcbiAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuc2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyLCBkZWZlcnJlZCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxuICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKClcbiAgICAgICkge1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzZXJ2aWNlIGlmIGl0IGNhbiBiZSBhdXRvLWluaXRpYWxpemVkXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xuICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uIGR1cmluZyBnZXQoKSwgaXQgc2hvdWxkIG5vdCBjYXVzZVxuICAgICAgICAgIC8vIGEgZmF0YWwgZXJyb3IuIFdlIGp1c3QgcmV0dXJuIHRoZSB1bnJlc29sdmVkIHByb21pc2UgaW4gdGhpcyBjYXNlLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKSEucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5pZGVudGlmaWVyIEEgcHJvdmlkZXIgY2FuIHByb3ZpZGUgbXVsaXRwbGUgaW5zdGFuY2VzIG9mIGEgc2VydmljZVxuICAgKiBpZiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyBpcyB0cnVlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5vcHRpb25hbCBJZiBvcHRpb25hbCBpcyBmYWxzZSBvciBub3QgcHJvdmlkZWQsIHRoZSBtZXRob2QgdGhyb3dzIGFuIGVycm9yIHdoZW5cbiAgICogdGhlIHNlcnZpY2UgaXMgbm90IGltbWVkaWF0ZWx5IGF2YWlsYWJsZS5cbiAgICogSWYgb3B0aW9uYWwgaXMgdHJ1ZSwgdGhlIG1ldGhvZCByZXR1cm5zIG51bGwgaWYgdGhlIHNlcnZpY2UgaXMgbm90IGltbWVkaWF0ZWx5IGF2YWlsYWJsZS5cbiAgICovXG4gIGdldEltbWVkaWF0ZShvcHRpb25zOiB7XG4gICAgaWRlbnRpZmllcj86IHN0cmluZztcbiAgICBvcHRpb25hbDogdHJ1ZTtcbiAgfSk6IE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSB8IG51bGw7XG4gIGdldEltbWVkaWF0ZShvcHRpb25zPzoge1xuICAgIGlkZW50aWZpZXI/OiBzdHJpbmc7XG4gICAgb3B0aW9uYWw/OiBmYWxzZTtcbiAgfSk6IE5hbWVTZXJ2aWNlTWFwcGluZ1tUXTtcbiAgZ2V0SW1tZWRpYXRlKG9wdGlvbnM/OiB7XG4gICAgaWRlbnRpZmllcj86IHN0cmluZztcbiAgICBvcHRpb25hbD86IGJvb2xlYW47XG4gIH0pOiBOYW1lU2VydmljZU1hcHBpbmdbVF0gfCBudWxsIHtcbiAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoXG4gICAgICBvcHRpb25zPy5pZGVudGlmaWVyXG4gICAgKTtcbiAgICBjb25zdCBvcHRpb25hbCA9IG9wdGlvbnM/Lm9wdGlvbmFsID8/IGZhbHNlO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxuICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpXG4gICAgKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIGNhc2UgYSBjb21wb25lbnQgaXMgbm90IGluaXRpYWxpemVkIGFuZCBzaG91bGQvY2FuIG5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKGBTZXJ2aWNlICR7dGhpcy5uYW1lfSBpcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0Q29tcG9uZW50KCk6IENvbXBvbmVudDxUPiB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudDtcbiAgfVxuXG4gIHNldENvbXBvbmVudChjb21wb25lbnQ6IENvbXBvbmVudDxUPik6IHZvaWQge1xuICAgIGlmIChjb21wb25lbnQubmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYE1pc21hdGNoaW5nIENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmb3IgUHJvdmlkZXIgJHt0aGlzLm5hbWV9LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XG4gICAgICB0aHJvdyBFcnJvcihgQ29tcG9uZW50IGZvciAke3RoaXMubmFtZX0gaGFzIGFscmVhZHkgYmVlbiBwcm92aWRlZGApO1xuICAgIH1cblxuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXG4gICAgLy8gcmV0dXJuIGVhcmx5IHdpdGhvdXQgYXR0ZW1wdGluZyB0byBpbml0aWFsaXplIHRoZSBjb21wb25lbnQgaWYgdGhlIGNvbXBvbmVudCByZXF1aXJlcyBleHBsaWNpdCBpbml0aWFsaXphdGlvbiAoY2FsbGluZyBgUHJvdmlkZXIuaW5pdGlhbGl6ZSgpYClcbiAgICBpZiAoIXRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBzZXJ2aWNlIGlzIGVhZ2VyLCBpbml0aWFsaXplIHRoZSBkZWZhdWx0IGluc3RhbmNlXG4gICAgaWYgKGlzQ29tcG9uZW50RWFnZXIoY29tcG9uZW50KSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHsgaW5zdGFuY2VJZGVudGlmaWVyOiBERUZBVUxUX0VOVFJZX05BTUUgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgZm9yIGFuIGVhZ2VyIENvbXBvbmVudCB0aHJvd3MgYW4gZXhjZXB0aW9uIGR1cmluZyB0aGUgZWFnZXJcbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24sIGl0IHNob3VsZCBub3QgY2F1c2UgYSBmYXRhbCBlcnJvci5cbiAgICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgd2UgbmVlZCB0byBtYWtlIGl0IGNvbmZpZ3VyYWJsZSwgYmVjYXVzZSBzb21lIGNvbXBvbmVudCBtYXkgd2FudCB0byBjYXVzZVxuICAgICAgICAvLyBhIGZhdGFsIGVycm9yIGluIHRoaXMgY2FzZT9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgc2VydmljZSBpbnN0YW5jZXMgZm9yIHRoZSBwZW5kaW5nIHByb21pc2VzIGFuZCByZXNvbHZlIHRoZW1cbiAgICAvLyBOT1RFOiBpZiB0aGlzLm11bHRpcGxlSW5zdGFuY2VzIGlzIGZhbHNlLCBvbmx5IHRoZSBkZWZhdWx0IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZFxuICAgIC8vIGFuZCBhbGwgcHJvbWlzZXMgd2l0aCByZXNvbHZlIHdpdGggaXQgcmVnYXJkbGVzcyBvZiB0aGUgaWRlbnRpZmllci5cbiAgICBmb3IgKGNvbnN0IFtcbiAgICAgIGluc3RhbmNlSWRlbnRpZmllcixcbiAgICAgIGluc3RhbmNlRGVmZXJyZWRcbiAgICBdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9XG4gICAgICAgIHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGBnZXRPckluaXRpYWxpemVTZXJ2aWNlKClgIHNob3VsZCBhbHdheXMgcmV0dXJuIGEgdmFsaWQgaW5zdGFuY2Ugc2luY2UgYSBjb21wb25lbnQgaXMgZ3VhcmFudGVlZC4gdXNlICEgdG8gbWFrZSB0eXBlc2NyaXB0IGhhcHB5LlxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxuICAgICAgICB9KSE7XG4gICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZVxuICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IGxlYXZlIHRoZSBwcm9taXNlIHVucmVzb2x2ZWQuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyOiBzdHJpbmcgPSBERUZBVUxUX0VOVFJZX05BTUUpOiB2b2lkIHtcbiAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmRlbGV0ZShpZGVudGlmaWVyKTtcbiAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgIHRoaXMuaW5zdGFuY2VzLmRlbGV0ZShpZGVudGlmaWVyKTtcbiAgfVxuXG4gIC8vIGFwcC5kZWxldGUoKSB3aWxsIGNhbGwgdGhpcyBtZXRob2Qgb24gZXZlcnkgcHJvdmlkZXIgdG8gZGVsZXRlIHRoZSBzZXJ2aWNlc1xuICAvLyBUT0RPOiBzaG91bGQgd2UgbWFyayB0aGUgcHJvdmlkZXIgYXMgZGVsZXRlZD9cbiAgYXN5bmMgZGVsZXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNlcnZpY2VzID0gQXJyYXkuZnJvbSh0aGlzLmluc3RhbmNlcy52YWx1ZXMoKSk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAuLi5zZXJ2aWNlc1xuICAgICAgICAuZmlsdGVyKHNlcnZpY2UgPT4gJ0lOVEVSTkFMJyBpbiBzZXJ2aWNlKSAvLyBsZWdhY3kgc2VydmljZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgLm1hcChzZXJ2aWNlID0+IChzZXJ2aWNlIGFzIGFueSkuSU5URVJOQUwhLmRlbGV0ZSgpKSxcbiAgICAgIC4uLnNlcnZpY2VzXG4gICAgICAgIC5maWx0ZXIoc2VydmljZSA9PiAnX2RlbGV0ZScgaW4gc2VydmljZSkgLy8gbW9kdWxhcml6ZWQgc2VydmljZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgLm1hcChzZXJ2aWNlID0+IChzZXJ2aWNlIGFzIGFueSkuX2RlbGV0ZSgpKVxuICAgIF0pO1xuICB9XG5cbiAgaXNDb21wb25lbnRTZXQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50ICE9IG51bGw7XG4gIH1cblxuICBpc0luaXRpYWxpemVkKGlkZW50aWZpZXI6IHN0cmluZyA9IERFRkFVTFRfRU5UUllfTkFNRSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlcy5oYXMoaWRlbnRpZmllcik7XG4gIH1cblxuICBnZXRPcHRpb25zKGlkZW50aWZpZXI6IHN0cmluZyA9IERFRkFVTFRfRU5UUllfTkFNRSk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNPcHRpb25zLmdldChpZGVudGlmaWVyKSB8fCB7fTtcbiAgfVxuXG4gIGluaXRpYWxpemUob3B0czogSW5pdGlhbGl6ZU9wdGlvbnMgPSB7fSk6IE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSB7XG4gICAgY29uc3QgeyBvcHRpb25zID0ge30gfSA9IG9wdHM7XG4gICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihcbiAgICAgIG9wdHMuaW5zdGFuY2VJZGVudGlmaWVyXG4gICAgKTtcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGAke3RoaXMubmFtZX0oJHtub3JtYWxpemVkSWRlbnRpZmllcn0pIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWRgXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0NvbXBvbmVudFNldCgpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgQ29tcG9uZW50ICR7dGhpcy5uYW1lfSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB5ZXRgKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyLFxuICAgICAgb3B0aW9uc1xuICAgIH0pITtcblxuICAgIC8vIHJlc29sdmUgYW55IHBlbmRpbmcgcHJvbWlzZSB3YWl0aW5nIGZvciB0aGUgc2VydmljZSBpbnN0YW5jZVxuICAgIGZvciAoY29uc3QgW1xuICAgICAgaW5zdGFuY2VJZGVudGlmaWVyLFxuICAgICAgaW5zdGFuY2VEZWZlcnJlZFxuICAgIF0gb2YgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIgPVxuICAgICAgICB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xuICAgICAgaWYgKG5vcm1hbGl6ZWRJZGVudGlmaWVyID09PSBub3JtYWxpemVkRGVmZXJyZWRJZGVudGlmaWVyKSB7XG4gICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgIGFmdGVyIHRoZSBwcm92aWRlciBoYXMgYmVlbiBpbml0aWFsaXplZCBieSBjYWxsaW5nIHByb3ZpZGVyLmluaXRpYWxpemUoKS5cbiAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXG4gICAqXG4gICAqIEBwYXJhbSBpZGVudGlmaWVyIEFuIG9wdGlvbmFsIGluc3RhbmNlIGlkZW50aWZpZXJcbiAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xuICAgKi9cbiAgb25Jbml0KGNhbGxiYWNrOiBPbkluaXRDYWxsQmFjazxUPiwgaWRlbnRpZmllcj86IHN0cmluZyk6ICgpID0+IHZvaWQge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgY29uc3QgZXhpc3RpbmdDYWxsYmFja3MgPVxuICAgICAgdGhpcy5vbkluaXRDYWxsYmFja3MuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKSA/P1xuICAgICAgbmV3IFNldDxPbkluaXRDYWxsQmFjazxUPj4oKTtcbiAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZXhpc3RpbmdDYWxsYmFja3MpO1xuXG4gICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChub3JtYWxpemVkSWRlbnRpZmllcik7XG4gICAgaWYgKGV4aXN0aW5nSW5zdGFuY2UpIHtcbiAgICAgIGNhbGxiYWNrKGV4aXN0aW5nSW5zdGFuY2UsIG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXhpc3RpbmdDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZSBvbkluaXQgY2FsbGJhY2tzIHN5bmNocm9ub3VzbHlcbiAgICogQHBhcmFtIGluc3RhbmNlIHRoZSBzZXJ2aWNlIGluc3RhbmNlYFxuICAgKi9cbiAgcHJpdmF0ZSBpbnZva2VPbkluaXRDYWxsYmFja3MoXG4gICAgaW5zdGFuY2U6IE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSxcbiAgICBpZGVudGlmaWVyOiBzdHJpbmdcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5vbkluaXRDYWxsYmFja3MuZ2V0KGlkZW50aWZpZXIpO1xuICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gaWdub3JlIGVycm9ycyBpbiB0aGUgb25Jbml0IGNhbGxiYWNrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICBpbnN0YW5jZUlkZW50aWZpZXIsXG4gICAgb3B0aW9ucyA9IHt9XG4gIH06IHtcbiAgICBpbnN0YW5jZUlkZW50aWZpZXI6IHN0cmluZztcbiAgICBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH0pOiBOYW1lU2VydmljZU1hcHBpbmdbVF0gfCBudWxsIHtcbiAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQoaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICBpZiAoIWluc3RhbmNlICYmIHRoaXMuY29tcG9uZW50KSB7XG4gICAgICBpbnN0YW5jZSA9IHRoaXMuY29tcG9uZW50Lmluc3RhbmNlRmFjdG9yeSh0aGlzLmNvbnRhaW5lciwge1xuICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGluc3RhbmNlSWRlbnRpZmllciksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xuICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEludm9rZSBvbkluaXQgbGlzdGVuZXJzLlxuICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxuICAgICAgICogd2hpbGUgb25Jbml0IGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZCBieSBjb25zdW1lcnMgb2YgdGhlIHByb3ZpZGVyLlxuICAgICAgICovXG4gICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBPcmRlciBpcyBpbXBvcnRhbnRcbiAgICAgICAqIG9uSW5zdGFuY2VDcmVhdGVkKCkgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7IHdoaWNoXG4gICAgICAgKiBtYWtlcyBgaXNJbml0aWFsaXplZCgpYCByZXR1cm4gdHJ1ZS5cbiAgICAgICAqL1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQoXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcixcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gaWdub3JlIGVycm9ycyBpbiB0aGUgb25JbnN0YW5jZUNyZWF0ZWRDYWxsYmFja1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XG4gIH1cblxuICBwcml2YXRlIG5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihcbiAgICBpZGVudGlmaWVyOiBzdHJpbmcgPSBERUZBVUxUX0VOVFJZX05BTUVcbiAgKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyA/IGlkZW50aWZpZXIgOiBERUZBVUxUX0VOVFJZX05BTUU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpZGVudGlmaWVyOyAvLyBhc3N1bWUgbXVsdGlwbGUgaW5zdGFuY2VzIGFyZSBzdXBwb3J0ZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgcHJvdmlkZWQuXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRBdXRvSW5pdGlhbGl6ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgISF0aGlzLmNvbXBvbmVudCAmJlxuICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IEluc3RhbnRpYXRpb25Nb2RlLkVYUExJQ0lUXG4gICAgKTtcbiAgfVxufVxuXG4vLyB1bmRlZmluZWQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgc2VydmljZSBmYWN0b3J5IGZvciB0aGUgZGVmYXVsdCBpbnN0YW5jZVxuZnVuY3Rpb24gbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaWRlbnRpZmllcjogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIGlkZW50aWZpZXIgPT09IERFRkFVTFRfRU5UUllfTkFNRSA/IHVuZGVmaW5lZCA6IGlkZW50aWZpZXI7XG59XG5cbmZ1bmN0aW9uIGlzQ29tcG9uZW50RWFnZXI8VCBleHRlbmRzIE5hbWU+KGNvbXBvbmVudDogQ29tcG9uZW50PFQ+KTogYm9vbGVhbiB7XG4gIHJldHVybiBjb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgPT09IEluc3RhbnRpYXRpb25Nb2RlLkVBR0VSO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVyJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50JztcbmltcG9ydCB7IE5hbWUgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBDb21wb25lbnRDb250YWluZXIgdGhhdCBwcm92aWRlcyBQcm92aWRlcnMgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuIGBhdXRoYCwgYGF1dGgtaW50ZXJuYWxgXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21wb25lbnRDb250YWluZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IHByb3ZpZGVycyA9IG5ldyBNYXA8c3RyaW5nLCBQcm92aWRlcjxOYW1lPj4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IG5hbWU6IHN0cmluZykge31cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgYmVpbmcgYWRkZWRcbiAgICogQHBhcmFtIG92ZXJ3cml0ZSBXaGVuIGEgY29tcG9uZW50IHdpdGggdGhlIHNhbWUgbmFtZSBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQsXG4gICAqIGlmIG92ZXJ3cml0ZSBpcyB0cnVlOiBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgY29tcG9uZW50IGFuZCBjcmVhdGUgYSBuZXdcbiAgICogcHJvdmlkZXIgd2l0aCB0aGUgbmV3IGNvbXBvbmVudC4gSXQgY2FuIGJlIHVzZWZ1bCBpbiB0ZXN0cyB3aGVyZSB5b3Ugd2FudCB0byB1c2UgZGlmZmVyZW50IG1vY2tzXG4gICAqIGZvciBkaWZmZXJlbnQgdGVzdHMuXG4gICAqIGlmIG92ZXJ3cml0ZSBpcyBmYWxzZTogdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAqL1xuICBhZGRDb21wb25lbnQ8VCBleHRlbmRzIE5hbWU+KGNvbXBvbmVudDogQ29tcG9uZW50PFQ+KTogdm9pZCB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcbiAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCB3aXRoICR7dGhpcy5uYW1lfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcHJvdmlkZXIuc2V0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gIH1cblxuICBhZGRPck92ZXJ3cml0ZUNvbXBvbmVudDxUIGV4dGVuZHMgTmFtZT4oY29tcG9uZW50OiBDb21wb25lbnQ8VD4pOiB2b2lkIHtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xuICAgIGlmIChwcm92aWRlci5pc0NvbXBvbmVudFNldCgpKSB7XG4gICAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIHByb3ZpZGVyIGZyb20gdGhlIGNvbnRhaW5lciwgc28gd2UgY2FuIHJlZ2lzdGVyIHRoZSBuZXcgY29tcG9uZW50XG4gICAgICB0aGlzLnByb3ZpZGVycy5kZWxldGUoY29tcG9uZW50Lm5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0UHJvdmlkZXIgcHJvdmlkZXMgYSB0eXBlIHNhZmUgaW50ZXJmYWNlIHdoZXJlIGl0IGNhbiBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgZmllbGQgbmFtZVxuICAgKiBwcmVzZW50IGluIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEZpcmViYXNlIFNES3MgcHJvdmlkaW5nIHNlcnZpY2VzIHNob3VsZCBleHRlbmQgTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZSB0byByZWdpc3RlclxuICAgKiB0aGVtc2VsdmVzLlxuICAgKi9cbiAgZ2V0UHJvdmlkZXI8VCBleHRlbmRzIE5hbWU+KG5hbWU6IFQpOiBQcm92aWRlcjxUPiB7XG4gICAgaWYgKHRoaXMucHJvdmlkZXJzLmhhcyhuYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXJzLmdldChuYW1lKSBhcyB1bmtub3duIGFzIFByb3ZpZGVyPFQ+O1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIFByb3ZpZGVyIGZvciBhIHNlcnZpY2UgdGhhdCBoYXNuJ3QgcmVnaXN0ZXJlZCB3aXRoIEZpcmViYXNlXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXI8VD4obmFtZSwgdGhpcyk7XG4gICAgdGhpcy5wcm92aWRlcnMuc2V0KG5hbWUsIHByb3ZpZGVyIGFzIHVua25vd24gYXMgUHJvdmlkZXI8TmFtZT4pO1xuXG4gICAgcmV0dXJuIHByb3ZpZGVyIGFzIFByb3ZpZGVyPFQ+O1xuICB9XG5cbiAgZ2V0UHJvdmlkZXJzKCk6IEFycmF5PFByb3ZpZGVyPE5hbWU+PiB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgdHlwZSBMb2dMZXZlbFN0cmluZyA9XG4gIHwgJ2RlYnVnJ1xuICB8ICd2ZXJib3NlJ1xuICB8ICdpbmZvJ1xuICB8ICd3YXJuJ1xuICB8ICdlcnJvcidcbiAgfCAnc2lsZW50JztcblxuZXhwb3J0IGludGVyZmFjZSBMb2dPcHRpb25zIHtcbiAgbGV2ZWw6IExvZ0xldmVsU3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBMb2dDYWxsYmFjayA9IChjYWxsYmFja1BhcmFtczogTG9nQ2FsbGJhY2tQYXJhbXMpID0+IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9nQ2FsbGJhY2tQYXJhbXMge1xuICBsZXZlbDogTG9nTGV2ZWxTdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgYXJnczogdW5rbm93bltdO1xuICB0eXBlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGFsbCBvZiB0aGUgTG9nZ2VyIGluc3RhbmNlc1xuICovXG5leHBvcnQgY29uc3QgaW5zdGFuY2VzOiBMb2dnZXJbXSA9IFtdO1xuXG4vKipcbiAqIFRoZSBKUyBTREsgc3VwcG9ydHMgNSBsb2cgbGV2ZWxzIGFuZCBhbHNvIGFsbG93cyBhIHVzZXIgdGhlIGFiaWxpdHkgdG9cbiAqIHNpbGVuY2UgdGhlIGxvZ3MgYWx0b2dldGhlci5cbiAqXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOlxuICogREVCVUcgPCBWRVJCT1NFIDwgSU5GTyA8IFdBUk4gPCBFUlJPUlxuICpcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCB3aWxsIGJlIGNhcHR1cmVkIChpLmUuIGlmXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYElORk9gLCBlcnJvcnMgd2lsbCBzdGlsbCBiZSBsb2dnZWQsIGJ1dCBgREVCVUdgIGFuZFxuICogYFZFUkJPU0VgIGxvZ3Mgd2lsbCBub3QpXG4gKi9cbmV4cG9ydCBlbnVtIExvZ0xldmVsIHtcbiAgREVCVUcsXG4gIFZFUkJPU0UsXG4gIElORk8sXG4gIFdBUk4sXG4gIEVSUk9SLFxuICBTSUxFTlRcbn1cblxuY29uc3QgbGV2ZWxTdHJpbmdUb0VudW06IHsgW2tleSBpbiBMb2dMZXZlbFN0cmluZ106IExvZ0xldmVsIH0gPSB7XG4gICdkZWJ1Zyc6IExvZ0xldmVsLkRFQlVHLFxuICAndmVyYm9zZSc6IExvZ0xldmVsLlZFUkJPU0UsXG4gICdpbmZvJzogTG9nTGV2ZWwuSU5GTyxcbiAgJ3dhcm4nOiBMb2dMZXZlbC5XQVJOLFxuICAnZXJyb3InOiBMb2dMZXZlbC5FUlJPUixcbiAgJ3NpbGVudCc6IExvZ0xldmVsLlNJTEVOVFxufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBsb2cgbGV2ZWxcbiAqL1xuY29uc3QgZGVmYXVsdExvZ0xldmVsOiBMb2dMZXZlbCA9IExvZ0xldmVsLklORk87XG5cbi8qKlxuICogV2UgYWxsb3cgdXNlcnMgdGhlIGFiaWxpdHkgdG8gcGFzcyB0aGVpciBvd24gbG9nIGhhbmRsZXIuIFdlIHdpbGwgcGFzcyB0aGVcbiAqIHR5cGUgb2YgbG9nLCB0aGUgY3VycmVudCBsb2cgbGV2ZWwsIGFuZCBhbnkgb3RoZXIgYXJndW1lbnRzIHBhc3NlZCAoaS5lLiB0aGVcbiAqIG1lc3NhZ2VzIHRoYXQgdGhlIHVzZXIgd2FudHMgdG8gbG9nKSB0byB0aGlzIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgdHlwZSBMb2dIYW5kbGVyID0gKFxuICBsb2dnZXJJbnN0YW5jZTogTG9nZ2VyLFxuICBsb2dUeXBlOiBMb2dMZXZlbCxcbiAgLi4uYXJnczogdW5rbm93bltdXG4pID0+IHZvaWQ7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxuICogY2hyb21lKS4gVG8gYXZvaWQgZm9yY2luZyB1c2VycyB0byBoYXZlIHRvIG9wdC1pbiB0byB0aGVzZSBsb2dzIHR3aWNlXG4gKiAoaS5lLiBvbmNlIGZvciBmaXJlYmFzZSwgYW5kIG9uY2UgaW4gdGhlIGNvbnNvbGUpLCB3ZSBhcmUgc2VuZGluZyBgREVCVUdgXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxuICovXG5jb25zdCBDb25zb2xlTWV0aG9kID0ge1xuICBbTG9nTGV2ZWwuREVCVUddOiAnbG9nJyxcbiAgW0xvZ0xldmVsLlZFUkJPU0VdOiAnbG9nJyxcbiAgW0xvZ0xldmVsLklORk9dOiAnaW5mbycsXG4gIFtMb2dMZXZlbC5XQVJOXTogJ3dhcm4nLFxuICBbTG9nTGV2ZWwuRVJST1JdOiAnZXJyb3InXG59O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGxvZyBoYW5kbGVyIHdpbGwgZm9yd2FyZCBERUJVRywgVkVSQk9TRSwgSU5GTywgV0FSTiwgYW5kIEVSUk9SXG4gKiBtZXNzYWdlcyBvbiB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIChpZiB0aGUgbG9nIG1ldGhvZFxuICogaXMgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGxvZyBsZXZlbClcbiAqL1xuY29uc3QgZGVmYXVsdExvZ0hhbmRsZXI6IExvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxvZ1R5cGUsIC4uLmFyZ3MpOiB2b2lkID0+IHtcbiAgaWYgKGxvZ1R5cGUgPCBpbnN0YW5jZS5sb2dMZXZlbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIGNvbnN0IG1ldGhvZCA9IENvbnNvbGVNZXRob2RbbG9nVHlwZSBhcyBrZXlvZiB0eXBlb2YgQ29uc29sZU1ldGhvZF07XG4gIGlmIChtZXRob2QpIHtcbiAgICBjb25zb2xlW21ldGhvZCBhcyAnbG9nJyB8ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvciddKFxuICAgICAgYFske25vd31dICAke2luc3RhbmNlLm5hbWV9OmAsXG4gICAgICAuLi5hcmdzXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQXR0ZW1wdGVkIHRvIGxvZyBhIG1lc3NhZ2Ugd2l0aCBhbiBpbnZhbGlkIGxvZ1R5cGUgKHZhbHVlOiAke2xvZ1R5cGV9KWBcbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgY2xhc3MgTG9nZ2VyIHtcbiAgLyoqXG4gICAqIEdpdmVzIHlvdSBhbiBpbnN0YW5jZSBvZiBhIExvZ2dlciB0byBjYXB0dXJlIG1lc3NhZ2VzIGFjY29yZGluZyB0b1xuICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSB0aGF0IHRoZSBsb2dzIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbmFtZTogc3RyaW5nKSB7XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZSB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgbGF0ZXIgdXNlXG4gICAgICovXG4gICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLlxuICAgKi9cbiAgcHJpdmF0ZSBfbG9nTGV2ZWwgPSBkZWZhdWx0TG9nTGV2ZWw7XG5cbiAgZ2V0IGxvZ0xldmVsKCk6IExvZ0xldmVsIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XG4gIH1cblxuICBzZXQgbG9nTGV2ZWwodmFsOiBMb2dMZXZlbCkge1xuICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWUgXCIke3ZhbH1cIiBhc3NpZ25lZCB0byBcXGBsb2dMZXZlbFxcYGApO1xuICAgIH1cbiAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbDtcbiAgfVxuXG4gIC8vIFdvcmthcm91bmQgZm9yIHNldHRlci9nZXR0ZXIgaGF2aW5nIHRvIGJlIHRoZSBzYW1lIHR5cGUuXG4gIHNldExvZ0xldmVsKHZhbDogTG9nTGV2ZWwgfCBMb2dMZXZlbFN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2xvZ0xldmVsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBsZXZlbFN0cmluZ1RvRW51bVt2YWxdIDogdmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIChpbnRlcm5hbCkgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXG4gICAqIENhbiBiZSBzZXQgdG8gYSBuZXcgZnVuY3Rpb24gaW4gaW50ZXJuYWwgcGFja2FnZSBjb2RlIGJ1dCBub3QgYnkgdXNlci5cbiAgICovXG4gIHByaXZhdGUgX2xvZ0hhbmRsZXI6IExvZ0hhbmRsZXIgPSBkZWZhdWx0TG9nSGFuZGxlcjtcbiAgZ2V0IGxvZ0hhbmRsZXIoKTogTG9nSGFuZGxlciB7XG4gICAgcmV0dXJuIHRoaXMuX2xvZ0hhbmRsZXI7XG4gIH1cbiAgc2V0IGxvZ0hhbmRsZXIodmFsOiBMb2dIYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGFzc2lnbmVkIHRvIGBsb2dIYW5kbGVyYCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdGhpcy5fbG9nSGFuZGxlciA9IHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgb3B0aW9uYWwsIGFkZGl0aW9uYWwsIHVzZXItZGVmaW5lZCBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICovXG4gIHByaXZhdGUgX3VzZXJMb2dIYW5kbGVyOiBMb2dIYW5kbGVyIHwgbnVsbCA9IG51bGw7XG4gIGdldCB1c2VyTG9nSGFuZGxlcigpOiBMb2dIYW5kbGVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJMb2dIYW5kbGVyO1xuICB9XG4gIHNldCB1c2VyTG9nSGFuZGxlcih2YWw6IExvZ0hhbmRsZXIgfCBudWxsKSB7XG4gICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgPSB2YWw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgYWxsIGJhc2VkIG9uIHRoZSBgY29uc29sZWAgaW50ZXJmYWNlXG4gICAqL1xuXG4gIGRlYnVnKC4uLmFyZ3M6IHVua25vd25bXSk6IHZvaWQge1xuICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcbiAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcbiAgfVxuICBsb2coLi4uYXJnczogdW5rbm93bltdKTogdm9pZCB7XG4gICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcbiAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xuICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XG4gIH1cbiAgaW5mbyguLi5hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5JTkZPLCAuLi5hcmdzKTtcbiAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xuICB9XG4gIHdhcm4oLi4uYXJnczogdW5rbm93bltdKTogdm9pZCB7XG4gICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuV0FSTiwgLi4uYXJncyk7XG4gICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcbiAgfVxuICBlcnJvciguLi5hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XG4gICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsOiBMb2dMZXZlbFN0cmluZyB8IExvZ0xldmVsKTogdm9pZCB7XG4gIGluc3RhbmNlcy5mb3JFYWNoKGluc3QgPT4ge1xuICAgIGluc3Quc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFVzZXJMb2dIYW5kbGVyKFxuICBsb2dDYWxsYmFjazogTG9nQ2FsbGJhY2sgfCBudWxsLFxuICBvcHRpb25zPzogTG9nT3B0aW9uc1xuKTogdm9pZCB7XG4gIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgbGV0IGN1c3RvbUxvZ0xldmVsOiBMb2dMZXZlbCB8IG51bGwgPSBudWxsO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGV2ZWwpIHtcbiAgICAgIGN1c3RvbUxvZ0xldmVsID0gbGV2ZWxTdHJpbmdUb0VudW1bb3B0aW9ucy5sZXZlbF07XG4gICAgfVxuICAgIGlmIChsb2dDYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS51c2VyTG9nSGFuZGxlciA9IChcbiAgICAgICAgaW5zdGFuY2U6IExvZ2dlcixcbiAgICAgICAgbGV2ZWw6IExvZ0xldmVsLFxuICAgICAgICAuLi5hcmdzOiB1bmtub3duW11cbiAgICAgICkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYXJnc1xuICAgICAgICAgIC5tYXAoYXJnID0+IHtcbiAgICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZy5tZXNzYWdlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKGFyZyA9PiBhcmcpXG4gICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgaWYgKGxldmVsID49IChjdXN0b21Mb2dMZXZlbCA/PyBpbnN0YW5jZS5sb2dMZXZlbCkpIHtcbiAgICAgICAgICBsb2dDYWxsYmFjayh7XG4gICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCkgYXMgTG9nTGV2ZWxTdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IGluc3RhbmNlT2ZBbnkgPSAob2JqZWN0LCBjb25zdHJ1Y3RvcnMpID0+IGNvbnN0cnVjdG9ycy5zb21lKChjKSA9PiBvYmplY3QgaW5zdGFuY2VvZiBjKTtcblxubGV0IGlkYlByb3h5YWJsZVR5cGVzO1xubGV0IGN1cnNvckFkdmFuY2VNZXRob2RzO1xuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG5mdW5jdGlvbiBnZXRJZGJQcm94eWFibGVUeXBlcygpIHtcbiAgICByZXR1cm4gKGlkYlByb3h5YWJsZVR5cGVzIHx8XG4gICAgICAgIChpZGJQcm94eWFibGVUeXBlcyA9IFtcbiAgICAgICAgICAgIElEQkRhdGFiYXNlLFxuICAgICAgICAgICAgSURCT2JqZWN0U3RvcmUsXG4gICAgICAgICAgICBJREJJbmRleCxcbiAgICAgICAgICAgIElEQkN1cnNvcixcbiAgICAgICAgICAgIElEQlRyYW5zYWN0aW9uLFxuICAgICAgICBdKSk7XG59XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkge1xuICAgIHJldHVybiAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgfHxcbiAgICAgICAgKGN1cnNvckFkdmFuY2VNZXRob2RzID0gW1xuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5hZHZhbmNlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZSxcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuY29udGludWVQcmltYXJ5S2V5LFxuICAgICAgICBdKSk7XG59XG5jb25zdCBjdXJzb3JSZXF1ZXN0TWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRG9uZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2FjdGlvblN0b3JlTmFtZXNNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHByb21pc2lmeVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSh3cmFwKHJlcXVlc3QucmVzdWx0KSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuICAgIHByb21pc2VcbiAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIFNpbmNlIGN1cnNvcmluZyByZXVzZXMgdGhlIElEQlJlcXVlc3QgKCpzaWdoKiksIHdlIGNhY2hlIGl0IGZvciBsYXRlciByZXRyaWV2YWxcbiAgICAgICAgLy8gKHNlZSB3cmFwRnVuY3Rpb24pLlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJREJDdXJzb3IpIHtcbiAgICAgICAgICAgIGN1cnNvclJlcXVlc3RNYXAuc2V0KHZhbHVlLCByZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYXRjaGluZyB0byBhdm9pZCBcIlVuY2F1Z2h0IFByb21pc2UgZXhjZXB0aW9uc1wiXG4gICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgLy8gVGhpcyBtYXBwaW5nIGV4aXN0cyBpbiByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgYnV0IGRvZXNuJ3QgZG9lc24ndCBleGlzdCBpbiB0cmFuc2Zvcm1DYWNoZS4gVGhpc1xuICAgIC8vIGlzIGJlY2F1c2Ugd2UgY3JlYXRlIG1hbnkgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0LlxuICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQocHJvbWlzZSwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odHgpIHtcbiAgICAvLyBFYXJseSBiYWlsIGlmIHdlJ3ZlIGFscmVhZHkgY3JlYXRlZCBhIGRvbmUgcHJvbWlzZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICBpZiAodHJhbnNhY3Rpb25Eb25lTWFwLmhhcyh0eCkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBkb25lID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdCh0eC5lcnJvciB8fCBuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydEVycm9yJywgJ0Fib3J0RXJyb3InKSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGNvbXBsZXRlKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgIH0pO1xuICAgIC8vIENhY2hlIGl0IGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAgdHJhbnNhY3Rpb25Eb25lTWFwLnNldCh0eCwgZG9uZSk7XG59XG5sZXQgaWRiUHJveHlUcmFwcyA9IHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyYW5zYWN0aW9uLmRvbmUuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2RvbmUnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkRvbmVNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICAvLyBQb2x5ZmlsbCBmb3Igb2JqZWN0U3RvcmVOYW1lcyBiZWNhdXNlIG9mIEVkZ2UuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ29iamVjdFN0b3JlTmFtZXMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5vYmplY3RTdG9yZU5hbWVzIHx8IHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2UgdHguc3RvcmUgcmV0dXJuIHRoZSBvbmx5IHN0b3JlIGluIHRoZSB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBtYW55LlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdzdG9yZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWl2ZXIub2JqZWN0U3RvcmVOYW1lc1sxXVxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IHJlY2VpdmVyLm9iamVjdFN0b3JlKHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2UgdHJhbnNmb3JtIHdoYXRldmVyIHdlIGdldCBiYWNrLlxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXRbcHJvcF0pO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24gJiZcbiAgICAgICAgICAgIChwcm9wID09PSAnZG9uZScgfHwgcHJvcCA9PT0gJ3N0b3JlJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wIGluIHRhcmdldDtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHJlcGxhY2VUcmFwcyhjYWxsYmFjaykge1xuICAgIGlkYlByb3h5VHJhcHMgPSBjYWxsYmFjayhpZGJQcm94eVRyYXBzKTtcbn1cbmZ1bmN0aW9uIHdyYXBGdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gRHVlIHRvIGV4cGVjdGVkIG9iamVjdCBlcXVhbGl0eSAod2hpY2ggaXMgZW5mb3JjZWQgYnkgdGhlIGNhY2hpbmcgaW4gYHdyYXBgKSwgd2VcbiAgICAvLyBvbmx5IGNyZWF0ZSBvbmUgbmV3IGZ1bmMgcGVyIGZ1bmMuXG4gICAgLy8gRWRnZSBkb2Vzbid0IHN1cHBvcnQgb2JqZWN0U3RvcmVOYW1lcyAoYm9vbyksIHNvIHdlIHBvbHlmaWxsIGl0IGhlcmUuXG4gICAgaWYgKGZ1bmMgPT09IElEQkRhdGFiYXNlLnByb3RvdHlwZS50cmFuc2FjdGlvbiAmJlxuICAgICAgICAhKCdvYmplY3RTdG9yZU5hbWVzJyBpbiBJREJUcmFuc2FjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RvcmVOYW1lcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgdHggPSBmdW5jLmNhbGwodW53cmFwKHRoaXMpLCBzdG9yZU5hbWVzLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcC5zZXQodHgsIHN0b3JlTmFtZXMuc29ydCA/IHN0b3JlTmFtZXMuc29ydCgpIDogW3N0b3JlTmFtZXNdKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHR4KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ3Vyc29yIG1ldGhvZHMgYXJlIHNwZWNpYWwsIGFzIHRoZSBiZWhhdmlvdXIgaXMgYSBsaXR0bGUgbW9yZSBkaWZmZXJlbnQgdG8gc3RhbmRhcmQgSURCLiBJblxuICAgIC8vIElEQiwgeW91IGFkdmFuY2UgdGhlIGN1cnNvciBhbmQgd2FpdCBmb3IgYSBuZXcgJ3N1Y2Nlc3MnIG9uIHRoZSBJREJSZXF1ZXN0IHRoYXQgZ2F2ZSB5b3UgdGhlXG4gICAgLy8gY3Vyc29yLiBJdCdzIGtpbmRhIGxpa2UgYSBwcm9taXNlIHRoYXQgY2FuIHJlc29sdmUgd2l0aCBtYW55IHZhbHVlcy4gVGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2VcbiAgICAvLyB3aXRoIHJlYWwgcHJvbWlzZXMsIHNvIGVhY2ggYWR2YW5jZSBtZXRob2RzIHJldHVybnMgYSBuZXcgcHJvbWlzZSBmb3IgdGhlIGN1cnNvciBvYmplY3QsIG9yXG4gICAgLy8gdW5kZWZpbmVkIGlmIHRoZSBlbmQgb2YgdGhlIGN1cnNvciBoYXMgYmVlbiByZWFjaGVkLlxuICAgIGlmIChnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcygpLmluY2x1ZGVzKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKGN1cnNvclJlcXVlc3RNYXAuZ2V0KHRoaXMpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIC8vIENhbGxpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3h5IGFzICd0aGlzJyBjYXVzZXMgSUxMRUdBTCBJTlZPQ0FUSU9OLCBzbyB3ZSB1c2VcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHdyYXAoZnVuYy5hcHBseSh1bndyYXAodGhpcyksIGFyZ3MpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQ2FjaGFibGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB3cmFwRnVuY3Rpb24odmFsdWUpO1xuICAgIC8vIFRoaXMgZG9lc24ndCByZXR1cm4sIGl0IGp1c3QgY3JlYXRlcyBhICdkb25lJyBwcm9taXNlIGZvciB0aGUgdHJhbnNhY3Rpb24sXG4gICAgLy8gd2hpY2ggaXMgbGF0ZXIgcmV0dXJuZWQgZm9yIHRyYW5zYWN0aW9uLmRvbmUgKHNlZSBpZGJPYmplY3RIYW5kbGVyKS5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbilcbiAgICAgICAgY2FjaGVEb25lUHJvbWlzZUZvclRyYW5zYWN0aW9uKHZhbHVlKTtcbiAgICBpZiAoaW5zdGFuY2VPZkFueSh2YWx1ZSwgZ2V0SWRiUHJveHlhYmxlVHlwZXMoKSkpXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodmFsdWUsIGlkYlByb3h5VHJhcHMpO1xuICAgIC8vIFJldHVybiB0aGUgc2FtZSB2YWx1ZSBiYWNrIGlmIHdlJ3JlIG5vdCBnb2luZyB0byB0cmFuc2Zvcm0gaXQuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gd3JhcCh2YWx1ZSkge1xuICAgIC8vIFdlIHNvbWV0aW1lcyBnZW5lcmF0ZSBtdWx0aXBsZSBwcm9taXNlcyBmcm9tIGEgc2luZ2xlIElEQlJlcXVlc3QgKGVnIHdoZW4gY3Vyc29yaW5nKSwgYmVjYXVzZVxuICAgIC8vIElEQiBpcyB3ZWlyZCBhbmQgYSBzaW5nbGUgSURCUmVxdWVzdCBjYW4geWllbGQgbWFueSByZXNwb25zZXMsIHNvIHRoZXNlIGNhbid0IGJlIGNhY2hlZC5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJREJSZXF1ZXN0KVxuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5UmVxdWVzdCh2YWx1ZSk7XG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSB0cmFuc2Zvcm1lZCB0aGlzIHZhbHVlIGJlZm9yZSwgcmV1c2UgdGhlIHRyYW5zZm9ybWVkIHZhbHVlLlxuICAgIC8vIFRoaXMgaXMgZmFzdGVyLCBidXQgaXQgYWxzbyBwcm92aWRlcyBvYmplY3QgZXF1YWxpdHkuXG4gICAgaWYgKHRyYW5zZm9ybUNhY2hlLmhhcyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1DYWNoZS5nZXQodmFsdWUpO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdHJhbnNmb3JtQ2FjaGFibGVWYWx1ZSh2YWx1ZSk7XG4gICAgLy8gTm90IGFsbCB0eXBlcyBhcmUgdHJhbnNmb3JtZWQuXG4gICAgLy8gVGhlc2UgbWF5IGJlIHByaW1pdGl2ZSB0eXBlcywgc28gdGhleSBjYW4ndCBiZSBXZWFrTWFwIGtleXMuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICB0cmFuc2Zvcm1DYWNoZS5zZXQodmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChuZXdWYWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWU7XG59XG5jb25zdCB1bndyYXAgPSAodmFsdWUpID0+IHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5nZXQodmFsdWUpO1xuXG5leHBvcnQgeyByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgYXMgYSwgaW5zdGFuY2VPZkFueSBhcyBpLCByZXBsYWNlVHJhcHMgYXMgciwgdW53cmFwIGFzIHUsIHdyYXAgYXMgdyB9O1xuIiwiaW1wb3J0IHsgdyBhcyB3cmFwLCByIGFzIHJlcGxhY2VUcmFwcyB9IGZyb20gJy4vd3JhcC1pZGItdmFsdWUuanMnO1xuZXhwb3J0IHsgdSBhcyB1bndyYXAsIHcgYXMgd3JhcCB9IGZyb20gJy4vd3JhcC1pZGItdmFsdWUuanMnO1xuXG4vKipcbiAqIE9wZW4gYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIFNjaGVtYSB2ZXJzaW9uLlxuICogQHBhcmFtIGNhbGxiYWNrcyBBZGRpdGlvbmFsIGNhbGxiYWNrcy5cbiAqL1xuZnVuY3Rpb24gb3BlbkRCKG5hbWUsIHZlcnNpb24sIHsgYmxvY2tlZCwgdXBncmFkZSwgYmxvY2tpbmcsIHRlcm1pbmF0ZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKG5hbWUsIHZlcnNpb24pO1xuICAgIGNvbnN0IG9wZW5Qcm9taXNlID0gd3JhcChyZXF1ZXN0KTtcbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3VwZ3JhZGVuZWVkZWQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHVwZ3JhZGUod3JhcChyZXF1ZXN0LnJlc3VsdCksIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIHdyYXAocmVxdWVzdC50cmFuc2FjdGlvbiksIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChibG9ja2VkKSB7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYmxvY2tlZCcsIChldmVudCkgPT4gYmxvY2tlZChcbiAgICAgICAgLy8gQ2FzdGluZyBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0LURPTS1saWItZ2VuZXJhdG9yL3B1bGwvMTQwNVxuICAgICAgICBldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCBldmVudCkpO1xuICAgIH1cbiAgICBvcGVuUHJvbWlzZVxuICAgICAgICAudGhlbigoZGIpID0+IHtcbiAgICAgICAgaWYgKHRlcm1pbmF0ZWQpXG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsICgpID0+IHRlcm1pbmF0ZWQoKSk7XG4gICAgICAgIGlmIChibG9ja2luZykge1xuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcigndmVyc2lvbmNoYW5nZScsIChldmVudCkgPT4gYmxvY2tpbmcoZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQubmV3VmVyc2lvbiwgZXZlbnQpKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIHJldHVybiBvcGVuUHJvbWlzZTtcbn1cbi8qKlxuICogRGVsZXRlIGEgZGF0YWJhc2UuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgZGF0YWJhc2UuXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZURCKG5hbWUsIHsgYmxvY2tlZCB9ID0ge30pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKG5hbWUpO1xuICAgIGlmIChibG9ja2VkKSB7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYmxvY2tlZCcsIChldmVudCkgPT4gYmxvY2tlZChcbiAgICAgICAgLy8gQ2FzdGluZyBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0LURPTS1saWItZ2VuZXJhdG9yL3B1bGwvMTQwNVxuICAgICAgICBldmVudC5vbGRWZXJzaW9uLCBldmVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcChyZXF1ZXN0KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG59XG5cbmNvbnN0IHJlYWRNZXRob2RzID0gWydnZXQnLCAnZ2V0S2V5JywgJ2dldEFsbCcsICdnZXRBbGxLZXlzJywgJ2NvdW50J107XG5jb25zdCB3cml0ZU1ldGhvZHMgPSBbJ3B1dCcsICdhZGQnLCAnZGVsZXRlJywgJ2NsZWFyJ107XG5jb25zdCBjYWNoZWRNZXRob2RzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkge1xuICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIElEQkRhdGFiYXNlICYmXG4gICAgICAgICEocHJvcCBpbiB0YXJnZXQpICYmXG4gICAgICAgIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FjaGVkTWV0aG9kcy5nZXQocHJvcCkpXG4gICAgICAgIHJldHVybiBjYWNoZWRNZXRob2RzLmdldChwcm9wKTtcbiAgICBjb25zdCB0YXJnZXRGdW5jTmFtZSA9IHByb3AucmVwbGFjZSgvRnJvbUluZGV4JC8sICcnKTtcbiAgICBjb25zdCB1c2VJbmRleCA9IHByb3AgIT09IHRhcmdldEZ1bmNOYW1lO1xuICAgIGNvbnN0IGlzV3JpdGUgPSB3cml0ZU1ldGhvZHMuaW5jbHVkZXModGFyZ2V0RnVuY05hbWUpO1xuICAgIGlmIChcbiAgICAvLyBCYWlsIGlmIHRoZSB0YXJnZXQgZG9lc24ndCBleGlzdCBvbiB0aGUgdGFyZ2V0LiBFZywgZ2V0QWxsIGlzbid0IGluIEVkZ2UuXG4gICAgISh0YXJnZXRGdW5jTmFtZSBpbiAodXNlSW5kZXggPyBJREJJbmRleCA6IElEQk9iamVjdFN0b3JlKS5wcm90b3R5cGUpIHx8XG4gICAgICAgICEoaXNXcml0ZSB8fCByZWFkTWV0aG9kcy5pbmNsdWRlcyh0YXJnZXRGdW5jTmFtZSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgZnVuY3Rpb24gKHN0b3JlTmFtZSwgLi4uYXJncykge1xuICAgICAgICAvLyBpc1dyaXRlID8gJ3JlYWR3cml0ZScgOiB1bmRlZmluZWQgZ3ppcHBzIGJldHRlciwgYnV0IGZhaWxzIGluIEVkZ2UgOihcbiAgICAgICAgY29uc3QgdHggPSB0aGlzLnRyYW5zYWN0aW9uKHN0b3JlTmFtZSwgaXNXcml0ZSA/ICdyZWFkd3JpdGUnIDogJ3JlYWRvbmx5Jyk7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0eC5zdG9yZTtcbiAgICAgICAgaWYgKHVzZUluZGV4KVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmluZGV4KGFyZ3Muc2hpZnQoKSk7XG4gICAgICAgIC8vIE11c3QgcmVqZWN0IGlmIG9wIHJlamVjdHMuXG4gICAgICAgIC8vIElmIGl0J3MgYSB3cml0ZSBvcGVyYXRpb24sIG11c3QgcmVqZWN0IGlmIHR4LmRvbmUgcmVqZWN0cy5cbiAgICAgICAgLy8gTXVzdCByZWplY3Qgd2l0aCBvcCByZWplY3Rpb24gZmlyc3QuXG4gICAgICAgIC8vIE11c3QgcmVzb2x2ZSB3aXRoIG9wIHZhbHVlLlxuICAgICAgICAvLyBNdXN0IGhhbmRsZSBib3RoIHByb21pc2VzIChubyB1bmhhbmRsZWQgcmVqZWN0aW9ucylcbiAgICAgICAgcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0YXJnZXRbdGFyZ2V0RnVuY05hbWVdKC4uLmFyZ3MpLFxuICAgICAgICAgICAgaXNXcml0ZSAmJiB0eC5kb25lLFxuICAgICAgICBdKSlbMF07XG4gICAgfTtcbiAgICBjYWNoZWRNZXRob2RzLnNldChwcm9wLCBtZXRob2QpO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5yZXBsYWNlVHJhcHMoKG9sZFRyYXBzKSA9PiAoe1xuICAgIC4uLm9sZFRyYXBzLFxuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHx8IG9sZFRyYXBzLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSxcbiAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+ICEhZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuaGFzKHRhcmdldCwgcHJvcCksXG59KSk7XG5cbmV4cG9ydCB7IGRlbGV0ZURCLCBvcGVuREIgfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIENvbXBvbmVudENvbnRhaW5lcixcbiAgQ29tcG9uZW50VHlwZSxcbiAgUHJvdmlkZXIsXG4gIE5hbWVcbn0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2UsIFZlcnNpb25TZXJ2aWNlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsIGltcGxlbWVudHMgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjb250YWluZXI6IENvbXBvbmVudENvbnRhaW5lcikge31cbiAgLy8gSW4gaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3aWxsIGJlIGNhbGxlZCBieSBpbnN0YWxsYXRpb25zIG9uXG4gIC8vIGF1dGggdG9rZW4gcmVmcmVzaCwgYW5kIGluc3RhbGxhdGlvbnMgd2lsbCBzZW5kIHRoaXMgc3RyaW5nLlxuICBnZXRQbGF0Zm9ybUluZm9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBjb25zdCBwcm92aWRlcnMgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcnMoKTtcbiAgICAvLyBMb29wIHRocm91Z2ggcHJvdmlkZXJzIGFuZCBnZXQgbGlicmFyeS92ZXJzaW9uIHBhaXJzIGZyb20gYW55IHRoYXQgYXJlXG4gICAgLy8gdmVyc2lvbiBjb21wb25lbnRzLlxuICAgIHJldHVybiBwcm92aWRlcnNcbiAgICAgIC5tYXAocHJvdmlkZXIgPT4ge1xuICAgICAgICBpZiAoaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSkge1xuICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKSBhcyBWZXJzaW9uU2VydmljZTtcbiAgICAgICAgICByZXR1cm4gYCR7c2VydmljZS5saWJyYXJ5fS8ke3NlcnZpY2UudmVyc2lvbn1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihsb2dTdHJpbmcgPT4gbG9nU3RyaW5nKVxuICAgICAgLmpvaW4oJyAnKTtcbiAgfVxufVxuLyoqXG4gKlxuICogQHBhcmFtIHByb3ZpZGVyIGNoZWNrIGlmIHRoaXMgcHJvdmlkZXIgcHJvdmlkZXMgYSBWZXJzaW9uU2VydmljZVxuICpcbiAqIE5PVEU6IFVzaW5nIFByb3ZpZGVyPCdhcHAtdmVyc2lvbic+IGlzIGEgaGFjayB0byBpbmRpY2F0ZSB0aGF0IHRoZSBwcm92aWRlclxuICogcHJvdmlkZXMgVmVyc2lvblNlcnZpY2UuIFRoZSBwcm92aWRlciBpcyBub3QgbmVjZXNzYXJpbHkgYSAnYXBwLXZlcnNpb24nXG4gKiBwcm92aWRlci5cbiAqL1xuZnVuY3Rpb24gaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyOiBQcm92aWRlcjxOYW1lPik6IGJvb2xlYW4ge1xuICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcbiAgcmV0dXJuIGNvbXBvbmVudD8udHlwZSA9PT0gQ29tcG9uZW50VHlwZS5WRVJTSU9OO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5cbmV4cG9ydCBjb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvYXBwJyk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBuYW1lIGFzIGFwcE5hbWUgfSBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBhcHBDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vYXBwLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBhbmFseXRpY3NDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvYW5hbHl0aWNzLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBhbmFseXRpY3NOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvYW5hbHl0aWNzL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGFwcENoZWNrQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2FwcC1jaGVjay1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgYXBwQ2hlY2tOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvYXBwLWNoZWNrL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGF1dGhOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvYXV0aC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBhdXRoQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2F1dGgtY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGRhdGFiYXNlTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2RhdGFiYXNlL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGRhdGFiYXNlQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2RhdGFiYXNlLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBmdW5jdGlvbnNOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvZnVuY3Rpb25zL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGZ1bmN0aW9uc0NvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9mdW5jdGlvbnMtY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGluc3RhbGxhdGlvbnNOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvaW5zdGFsbGF0aW9ucy9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBpbnN0YWxsYXRpb25zQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2luc3RhbGxhdGlvbnMtY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIG1lc3NhZ2luZ05hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9tZXNzYWdpbmcvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgbWVzc2FnaW5nQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL21lc3NhZ2luZy1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgcGVyZm9ybWFuY2VOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvcGVyZm9ybWFuY2UvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgcGVyZm9ybWFuY2VDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvcGVyZm9ybWFuY2UtY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIHJlbW90ZUNvbmZpZ05hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9yZW1vdGUtY29uZmlnL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIHJlbW90ZUNvbmZpZ0NvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9yZW1vdGUtY29uZmlnLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBzdG9yYWdlTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL3N0b3JhZ2UvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgc3RvcmFnZUNvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9zdG9yYWdlLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBmaXJlc3RvcmVOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvZmlyZXN0b3JlL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGZpcmVzdG9yZUNvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9maXJlc3RvcmUtY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIHBhY2thZ2VOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvZmlyZWJhc2UvcGFja2FnZS5qc29uJztcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBhcHAgbmFtZVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG5cbmV4cG9ydCBjb25zdCBQTEFURk9STV9MT0dfU1RSSU5HID0ge1xuICBbYXBwTmFtZV06ICdmaXJlLWNvcmUnLFxuICBbYXBwQ29tcGF0TmFtZV06ICdmaXJlLWNvcmUtY29tcGF0JyxcbiAgW2FuYWx5dGljc05hbWVdOiAnZmlyZS1hbmFseXRpY3MnLFxuICBbYW5hbHl0aWNzQ29tcGF0TmFtZV06ICdmaXJlLWFuYWx5dGljcy1jb21wYXQnLFxuICBbYXBwQ2hlY2tOYW1lXTogJ2ZpcmUtYXBwLWNoZWNrJyxcbiAgW2FwcENoZWNrQ29tcGF0TmFtZV06ICdmaXJlLWFwcC1jaGVjay1jb21wYXQnLFxuICBbYXV0aE5hbWVdOiAnZmlyZS1hdXRoJyxcbiAgW2F1dGhDb21wYXROYW1lXTogJ2ZpcmUtYXV0aC1jb21wYXQnLFxuICBbZGF0YWJhc2VOYW1lXTogJ2ZpcmUtcnRkYicsXG4gIFtkYXRhYmFzZUNvbXBhdE5hbWVdOiAnZmlyZS1ydGRiLWNvbXBhdCcsXG4gIFtmdW5jdGlvbnNOYW1lXTogJ2ZpcmUtZm4nLFxuICBbZnVuY3Rpb25zQ29tcGF0TmFtZV06ICdmaXJlLWZuLWNvbXBhdCcsXG4gIFtpbnN0YWxsYXRpb25zTmFtZV06ICdmaXJlLWlpZCcsXG4gIFtpbnN0YWxsYXRpb25zQ29tcGF0TmFtZV06ICdmaXJlLWlpZC1jb21wYXQnLFxuICBbbWVzc2FnaW5nTmFtZV06ICdmaXJlLWZjbScsXG4gIFttZXNzYWdpbmdDb21wYXROYW1lXTogJ2ZpcmUtZmNtLWNvbXBhdCcsXG4gIFtwZXJmb3JtYW5jZU5hbWVdOiAnZmlyZS1wZXJmJyxcbiAgW3BlcmZvcm1hbmNlQ29tcGF0TmFtZV06ICdmaXJlLXBlcmYtY29tcGF0JyxcbiAgW3JlbW90ZUNvbmZpZ05hbWVdOiAnZmlyZS1yYycsXG4gIFtyZW1vdGVDb25maWdDb21wYXROYW1lXTogJ2ZpcmUtcmMtY29tcGF0JyxcbiAgW3N0b3JhZ2VOYW1lXTogJ2ZpcmUtZ2NzJyxcbiAgW3N0b3JhZ2VDb21wYXROYW1lXTogJ2ZpcmUtZ2NzLWNvbXBhdCcsXG4gIFtmaXJlc3RvcmVOYW1lXTogJ2ZpcmUtZnN0JyxcbiAgW2ZpcmVzdG9yZUNvbXBhdE5hbWVdOiAnZmlyZS1mc3QtY29tcGF0JyxcbiAgJ2ZpcmUtanMnOiAnZmlyZS1qcycsIC8vIFBsYXRmb3JtIGlkZW50aWZpZXIgZm9yIEpTIFNESy5cbiAgW3BhY2thZ2VOYW1lXTogJ2ZpcmUtanMtYWxsJ1xufSBhcyBjb25zdDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZpcmViYXNlQXBwIH0gZnJvbSAnLi9wdWJsaWMtdHlwZXMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBQcm92aWRlciwgTmFtZSB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgREVGQVVMVF9FTlRSWV9OQU1FIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgRmlyZWJhc2VBcHBJbXBsIH0gZnJvbSAnLi9maXJlYmFzZUFwcCc7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBfYXBwcyA9IG5ldyBNYXA8c3RyaW5nLCBGaXJlYmFzZUFwcD4oKTtcblxuLyoqXG4gKiBSZWdpc3RlcmVkIGNvbXBvbmVudHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgY29uc3QgX2NvbXBvbmVudHMgPSBuZXcgTWFwPHN0cmluZywgQ29tcG9uZW50PGFueT4+KCk7XG5cbi8qKlxuICogQHBhcmFtIGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgYmVpbmcgYWRkZWQgdG8gdGhpcyBhcHAncyBjb250YWluZXJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hZGRDb21wb25lbnQ8VCBleHRlbmRzIE5hbWU+KFxuICBhcHA6IEZpcmViYXNlQXBwLFxuICBjb21wb25lbnQ6IENvbXBvbmVudDxUPlxuKTogdm9pZCB7XG4gIHRyeSB7XG4gICAgKGFwcCBhcyBGaXJlYmFzZUFwcEltcGwpLmNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZmFpbGVkIHRvIHJlZ2lzdGVyIHdpdGggRmlyZWJhc2VBcHAgJHthcHAubmFtZX1gLFxuICAgICAgZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoXG4gIGFwcDogRmlyZWJhc2VBcHAsXG4gIGNvbXBvbmVudDogQ29tcG9uZW50XG4pOiB2b2lkIHtcbiAgKGFwcCBhcyBGaXJlYmFzZUFwcEltcGwpLmNvbnRhaW5lci5hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChjb21wb25lbnQpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCB0byByZWdpc3RlclxuICogQHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gX3JlZ2lzdGVyQ29tcG9uZW50PFQgZXh0ZW5kcyBOYW1lPihcbiAgY29tcG9uZW50OiBDb21wb25lbnQ8VD5cbik6IGJvb2xlYW4ge1xuICBjb25zdCBjb21wb25lbnROYW1lID0gY29tcG9uZW50Lm5hbWU7XG4gIGlmIChfY29tcG9uZW50cy5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgVGhlcmUgd2VyZSBtdWx0aXBsZSBhdHRlbXB0cyB0byByZWdpc3RlciBjb21wb25lbnQgJHtjb21wb25lbnROYW1lfS5gXG4gICAgKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9jb21wb25lbnRzLnNldChjb21wb25lbnROYW1lLCBjb21wb25lbnQpO1xuXG4gIC8vIGFkZCB0aGUgY29tcG9uZW50IHRvIGV4aXN0aW5nIGFwcCBpbnN0YW5jZXNcbiAgZm9yIChjb25zdCBhcHAgb2YgX2FwcHMudmFsdWVzKCkpIHtcbiAgICBfYWRkQ29tcG9uZW50KGFwcCBhcyBGaXJlYmFzZUFwcEltcGwsIGNvbXBvbmVudCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxuICpcbiAqIEByZXR1cm5zIHRoZSBwcm92aWRlciBmb3IgdGhlIHNlcnZpY2Ugd2l0aCB0aGUgbWF0Y2hpbmcgbmFtZVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFByb3ZpZGVyPFQgZXh0ZW5kcyBOYW1lPihcbiAgYXBwOiBGaXJlYmFzZUFwcCxcbiAgbmFtZTogVFxuKTogUHJvdmlkZXI8VD4ge1xuICBjb25zdCBoZWFydGJlYXRDb250cm9sbGVyID0gKGFwcCBhcyBGaXJlYmFzZUFwcEltcGwpLmNvbnRhaW5lclxuICAgIC5nZXRQcm92aWRlcignaGVhcnRiZWF0JylcbiAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XG4gIGlmIChoZWFydGJlYXRDb250cm9sbGVyKSB7XG4gICAgdm9pZCBoZWFydGJlYXRDb250cm9sbGVyLnRyaWdnZXJIZWFydGJlYXQoKTtcbiAgfVxuICByZXR1cm4gKGFwcCBhcyBGaXJlYmFzZUFwcEltcGwpLmNvbnRhaW5lci5nZXRQcm92aWRlcihuYW1lKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxuICogQHBhcmFtIGluc3RhbmNlSWRlbnRpZmllciAtIHNlcnZpY2UgaW5zdGFuY2UgaWRlbnRpZmllciBpbiBjYXNlIHRoZSBzZXJ2aWNlIHN1cHBvcnRzIG11bHRpcGxlIGluc3RhbmNlc1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gX3JlbW92ZVNlcnZpY2VJbnN0YW5jZTxUIGV4dGVuZHMgTmFtZT4oXG4gIGFwcDogRmlyZWJhc2VBcHAsXG4gIG5hbWU6IFQsXG4gIGluc3RhbmNlSWRlbnRpZmllcjogc3RyaW5nID0gREVGQVVMVF9FTlRSWV9OQU1FXG4pOiB2b2lkIHtcbiAgX2dldFByb3ZpZGVyKGFwcCwgbmFtZSkuY2xlYXJJbnN0YW5jZShpbnN0YW5jZUlkZW50aWZpZXIpO1xufVxuXG4vKipcbiAqIFRlc3Qgb25seVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NsZWFyQ29tcG9uZW50cygpOiB2b2lkIHtcbiAgX2NvbXBvbmVudHMuY2xlYXIoKTtcbn1cblxuLyoqXG4gKiBFeHBvcnRlZCBpbiBvcmRlciB0byBiZSB1c2VkIGluIGFwcC1jb21wYXQgcGFja2FnZVxuICovXG5leHBvcnQgeyBERUZBVUxUX0VOVFJZX05BTUUgYXMgX0RFRkFVTFRfRU5UUllfTkFNRSB9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBFcnJvck1hcCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuZXhwb3J0IGNvbnN0IGVudW0gQXBwRXJyb3Ige1xuICBOT19BUFAgPSAnbm8tYXBwJyxcbiAgQkFEX0FQUF9OQU1FID0gJ2JhZC1hcHAtbmFtZScsXG4gIERVUExJQ0FURV9BUFAgPSAnZHVwbGljYXRlLWFwcCcsXG4gIEFQUF9ERUxFVEVEID0gJ2FwcC1kZWxldGVkJyxcbiAgTk9fT1BUSU9OUyA9ICduby1vcHRpb25zJyxcbiAgSU5WQUxJRF9BUFBfQVJHVU1FTlQgPSAnaW52YWxpZC1hcHAtYXJndW1lbnQnLFxuICBJTlZBTElEX0xPR19BUkdVTUVOVCA9ICdpbnZhbGlkLWxvZy1hcmd1bWVudCcsXG4gIElEQl9PUEVOID0gJ2lkYi1vcGVuJyxcbiAgSURCX0dFVCA9ICdpZGItZ2V0JyxcbiAgSURCX1dSSVRFID0gJ2lkYi1zZXQnLFxuICBJREJfREVMRVRFID0gJ2lkYi1kZWxldGUnXG59XG5cbmNvbnN0IEVSUk9SUzogRXJyb3JNYXA8QXBwRXJyb3I+ID0ge1xuICBbQXBwRXJyb3IuTk9fQVBQXTpcbiAgICBcIk5vIEZpcmViYXNlIEFwcCAneyRhcHBOYW1lfScgaGFzIGJlZW4gY3JlYXRlZCAtIFwiICtcbiAgICAnY2FsbCBpbml0aWFsaXplQXBwKCkgZmlyc3QnLFxuICBbQXBwRXJyb3IuQkFEX0FQUF9OQU1FXTogXCJJbGxlZ2FsIEFwcCBuYW1lOiAneyRhcHBOYW1lfVwiLFxuICBbQXBwRXJyb3IuRFVQTElDQVRFX0FQUF06XG4gICAgXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skYXBwTmFtZX0nIGFscmVhZHkgZXhpc3RzIHdpdGggZGlmZmVyZW50IG9wdGlvbnMgb3IgY29uZmlnXCIsXG4gIFtBcHBFcnJvci5BUFBfREVMRVRFRF06IFwiRmlyZWJhc2UgQXBwIG5hbWVkICd7JGFwcE5hbWV9JyBhbHJlYWR5IGRlbGV0ZWRcIixcbiAgW0FwcEVycm9yLk5PX09QVElPTlNdOlxuICAgICdOZWVkIHRvIHByb3ZpZGUgb3B0aW9ucywgd2hlbiBub3QgYmVpbmcgZGVwbG95ZWQgdG8gaG9zdGluZyB2aWEgc291cmNlLicsXG4gIFtBcHBFcnJvci5JTlZBTElEX0FQUF9BUkdVTUVOVF06XG4gICAgJ2ZpcmViYXNlLnskYXBwTmFtZX0oKSB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnQgb3IgYSAnICtcbiAgICAnRmlyZWJhc2UgQXBwIGluc3RhbmNlLicsXG4gIFtBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVF06XG4gICAgJ0ZpcnN0IGFyZ3VtZW50IHRvIGBvbkxvZ2AgbXVzdCBiZSBudWxsIG9yIGEgZnVuY3Rpb24uJyxcbiAgW0FwcEVycm9yLklEQl9PUEVOXTpcbiAgICAnRXJyb3IgdGhyb3duIHdoZW4gb3BlbmluZyBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICBbQXBwRXJyb3IuSURCX0dFVF06XG4gICAgJ0Vycm9yIHRocm93biB3aGVuIHJlYWRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICBbQXBwRXJyb3IuSURCX1dSSVRFXTpcbiAgICAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICBbQXBwRXJyb3IuSURCX0RFTEVURV06XG4gICAgJ0Vycm9yIHRocm93biB3aGVuIGRlbGV0aW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJ1xufTtcblxuaW50ZXJmYWNlIEVycm9yUGFyYW1zIHtcbiAgW0FwcEVycm9yLk5PX0FQUF06IHsgYXBwTmFtZTogc3RyaW5nIH07XG4gIFtBcHBFcnJvci5CQURfQVBQX05BTUVdOiB7IGFwcE5hbWU6IHN0cmluZyB9O1xuICBbQXBwRXJyb3IuRFVQTElDQVRFX0FQUF06IHsgYXBwTmFtZTogc3RyaW5nIH07XG4gIFtBcHBFcnJvci5BUFBfREVMRVRFRF06IHsgYXBwTmFtZTogc3RyaW5nIH07XG4gIFtBcHBFcnJvci5JTlZBTElEX0FQUF9BUkdVTUVOVF06IHsgYXBwTmFtZTogc3RyaW5nIH07XG4gIFtBcHBFcnJvci5JREJfT1BFTl06IHsgb3JpZ2luYWxFcnJvck1lc3NhZ2U/OiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLklEQl9HRVRdOiB7IG9yaWdpbmFsRXJyb3JNZXNzYWdlPzogc3RyaW5nIH07XG4gIFtBcHBFcnJvci5JREJfV1JJVEVdOiB7IG9yaWdpbmFsRXJyb3JNZXNzYWdlPzogc3RyaW5nIH07XG4gIFtBcHBFcnJvci5JREJfREVMRVRFXTogeyBvcmlnaW5hbEVycm9yTWVzc2FnZT86IHN0cmluZyB9O1xufVxuXG5leHBvcnQgY29uc3QgRVJST1JfRkFDVE9SWSA9IG5ldyBFcnJvckZhY3Rvcnk8QXBwRXJyb3IsIEVycm9yUGFyYW1zPihcbiAgJ2FwcCcsXG4gICdGaXJlYmFzZScsXG4gIEVSUk9SU1xuKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEZpcmViYXNlQXBwLFxuICBGaXJlYmFzZU9wdGlvbnMsXG4gIEZpcmViYXNlQXBwU2V0dGluZ3Ncbn0gZnJvbSAnLi9wdWJsaWMtdHlwZXMnO1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50Q29udGFpbmVyLFxuICBDb21wb25lbnQsXG4gIENvbXBvbmVudFR5cGVcbn0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBFUlJPUl9GQUNUT1JZLCBBcHBFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcblxuZXhwb3J0IGNsYXNzIEZpcmViYXNlQXBwSW1wbCBpbXBsZW1lbnRzIEZpcmViYXNlQXBwIHtcbiAgcHJpdmF0ZSByZWFkb25seSBfb3B0aW9uczogRmlyZWJhc2VPcHRpb25zO1xuICBwcml2YXRlIHJlYWRvbmx5IF9uYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBPcmlnaW5hbCBjb25maWcgdmFsdWVzIHBhc3NlZCBpbiBhcyBhIGNvbnN0cnVjdG9yIHBhcmFtZXRlci5cbiAgICogSXQgaXMgb25seSB1c2VkIHRvIGNvbXBhcmUgd2l0aCBhbm90aGVyIGNvbmZpZyBvYmplY3QgdG8gc3VwcG9ydCBpZGVtcG90ZW50IGluaXRpYWxpemVBcHAoKS5cbiAgICpcbiAgICogVXBkYXRpbmcgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIG9uIHRoZSBBcHAgaW5zdGFuY2Ugd2lsbCBub3QgY2hhbmdlIGl0cyB2YWx1ZSBpbiBfY29uZmlnLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfY29uZmlnOiBSZXF1aXJlZDxGaXJlYmFzZUFwcFNldHRpbmdzPjtcbiAgcHJpdmF0ZSBfYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkOiBib29sZWFuO1xuICBwcml2YXRlIF9pc0RlbGV0ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSByZWFkb25seSBfY29udGFpbmVyOiBDb21wb25lbnRDb250YWluZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgb3B0aW9uczogRmlyZWJhc2VPcHRpb25zLFxuICAgIGNvbmZpZzogUmVxdWlyZWQ8RmlyZWJhc2VBcHBTZXR0aW5ncz4sXG4gICAgY29udGFpbmVyOiBDb21wb25lbnRDb250YWluZXJcbiAgKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMuX2NvbmZpZyA9IHsgLi4uY29uZmlnIH07XG4gICAgdGhpcy5fbmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9XG4gICAgICBjb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRDb21wb25lbnQoXG4gICAgICBuZXcgQ29tcG9uZW50KCdhcHAnLCAoKSA9PiB0aGlzLCBDb21wb25lbnRUeXBlLlBVQkxJQylcbiAgICApO1xuICB9XG5cbiAgZ2V0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDtcbiAgfVxuXG4gIHNldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQodmFsOiBib29sZWFuKSB7XG4gICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xuICAgIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9IHZhbDtcbiAgfVxuXG4gIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKTogRmlyZWJhc2VPcHRpb25zIHtcbiAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cblxuICBnZXQgY29uZmlnKCk6IFJlcXVpcmVkPEZpcmViYXNlQXBwU2V0dGluZ3M+IHtcbiAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgfVxuXG4gIGdldCBjb250YWluZXIoKTogQ29tcG9uZW50Q29udGFpbmVyIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICB9XG5cbiAgZ2V0IGlzRGVsZXRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faXNEZWxldGVkO1xuICB9XG5cbiAgc2V0IGlzRGVsZXRlZCh2YWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9pc0RlbGV0ZWQgPSB2YWw7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yIGlmIHRoZSBBcHAgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkIC1cbiAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXG4gICAqL1xuICBwcml2YXRlIGNoZWNrRGVzdHJveWVkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xuICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuQVBQX0RFTEVURUQsIHsgYXBwTmFtZTogdGhpcy5fbmFtZSB9KTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEZpcmViYXNlQXBwLFxuICBGaXJlYmFzZU9wdGlvbnMsXG4gIEZpcmViYXNlQXBwU2V0dGluZ3Ncbn0gZnJvbSAnLi9wdWJsaWMtdHlwZXMnO1xuaW1wb3J0IHsgREVGQVVMVF9FTlRSWV9OQU1FLCBQTEFURk9STV9MT0dfU1RSSU5HIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgRVJST1JfRkFDVE9SWSwgQXBwRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQge1xuICBDb21wb25lbnRDb250YWluZXIsXG4gIENvbXBvbmVudCxcbiAgTmFtZSxcbiAgQ29tcG9uZW50VHlwZVxufSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi8uLi9maXJlYmFzZS9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgRmlyZWJhc2VBcHBJbXBsIH0gZnJvbSAnLi9maXJlYmFzZUFwcCc7XG5pbXBvcnQgeyBfYXBwcywgX2NvbXBvbmVudHMsIF9yZWdpc3RlckNvbXBvbmVudCB9IGZyb20gJy4vaW50ZXJuYWwnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHtcbiAgTG9nTGV2ZWxTdHJpbmcsXG4gIHNldExvZ0xldmVsIGFzIHNldExvZ0xldmVsSW1wbCxcbiAgTG9nQ2FsbGJhY2ssXG4gIExvZ09wdGlvbnMsXG4gIHNldFVzZXJMb2dIYW5kbGVyXG59IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgZGVlcEVxdWFsLCBnZXREZWZhdWx0QXBwQ29uZmlnIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5leHBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IFNESyB2ZXJzaW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IFNES19WRVJTSU9OID0gdmVyc2lvbjtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBpbnN0YW5jZS5cbiAqXG4gKiBTZWVcbiAqIHtAbGlua1xuICogICBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy93ZWIvc2V0dXAjYWRkX2ZpcmViYXNlX3RvX3lvdXJfYXBwXG4gKiAgIHwgQWRkIEZpcmViYXNlIHRvIHlvdXIgYXBwfSBhbmRcbiAqIHtAbGlua1xuICogICBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy93ZWIvc2V0dXAjbXVsdGlwbGUtcHJvamVjdHNcbiAqICAgfCBJbml0aWFsaXplIG11bHRpcGxlIHByb2plY3RzfSBmb3IgZGV0YWlsZWQgZG9jdW1lbnRhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICpcbiAqIC8vIEluaXRpYWxpemUgZGVmYXVsdCBhcHBcbiAqIC8vIFJldHJpZXZlIHlvdXIgb3duIG9wdGlvbnMgdmFsdWVzIGJ5IGFkZGluZyBhIHdlYiBhcHAgb25cbiAqIC8vIGh0dHBzOi8vY29uc29sZS5maXJlYmFzZS5nb29nbGUuY29tXG4gKiBpbml0aWFsaXplQXBwKHtcbiAqICAgYXBpS2V5OiBcIkFJemEuLi4uXCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdXRoIC8gR2VuZXJhbCBVc2VcbiAqICAgYXV0aERvbWFpbjogXCJZT1VSX0FQUC5maXJlYmFzZWFwcC5jb21cIiwgICAgICAgICAvLyBBdXRoIHdpdGggcG9wdXAvcmVkaXJlY3RcbiAqICAgZGF0YWJhc2VVUkw6IFwiaHR0cHM6Ly9ZT1VSX0FQUC5maXJlYmFzZWlvLmNvbVwiLCAvLyBSZWFsdGltZSBEYXRhYmFzZVxuICogICBzdG9yYWdlQnVja2V0OiBcIllPVVJfQVBQLmFwcHNwb3QuY29tXCIsICAgICAgICAgIC8vIFN0b3JhZ2VcbiAqICAgbWVzc2FnaW5nU2VuZGVySWQ6IFwiMTIzNDU2Nzg5XCIgICAgICAgICAgICAgICAgICAvLyBDbG91ZCBNZXNzYWdpbmdcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqXG4gKiAvLyBJbml0aWFsaXplIGFub3RoZXIgYXBwXG4gKiBjb25zdCBvdGhlckFwcCA9IGluaXRpYWxpemVBcHAoe1xuICogICBkYXRhYmFzZVVSTDogXCJodHRwczovLzxPVEhFUl9EQVRBQkFTRV9OQU1FPi5maXJlYmFzZWlvLmNvbVwiLFxuICogICBzdG9yYWdlQnVja2V0OiBcIjxPVEhFUl9TVE9SQUdFX0JVQ0tFVD4uYXBwc3BvdC5jb21cIlxuICogfSwgXCJvdGhlckFwcFwiKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIGFwcCdzIHNlcnZpY2VzLlxuICogQHBhcmFtIG5hbWUgLSBPcHRpb25hbCBuYW1lIG9mIHRoZSBhcHAgdG8gaW5pdGlhbGl6ZS4gSWYgbm8gbmFtZVxuICogICBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgaXMgYFwiW0RFRkFVTFRdXCJgLlxuICpcbiAqIEByZXR1cm5zIFRoZSBpbml0aWFsaXplZCBhcHAuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChcbiAgb3B0aW9uczogRmlyZWJhc2VPcHRpb25zLFxuICBuYW1lPzogc3RyaW5nXG4pOiBGaXJlYmFzZUFwcDtcbi8qKlxuICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgYSBGaXJlYmFzZUFwcCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSBhcHAncyBzZXJ2aWNlcy5cbiAqIEBwYXJhbSBjb25maWcgLSBGaXJlYmFzZUFwcCBDb25maWd1cmF0aW9uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChcbiAgb3B0aW9uczogRmlyZWJhc2VPcHRpb25zLFxuICBjb25maWc/OiBGaXJlYmFzZUFwcFNldHRpbmdzXG4pOiBGaXJlYmFzZUFwcDtcbi8qKlxuICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgYSBGaXJlYmFzZUFwcCBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplQXBwKCk6IEZpcmViYXNlQXBwO1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVBcHAoXG4gIF9vcHRpb25zPzogRmlyZWJhc2VPcHRpb25zLFxuICByYXdDb25maWcgPSB7fVxuKTogRmlyZWJhc2VBcHAge1xuICBsZXQgb3B0aW9ucyA9IF9vcHRpb25zO1xuXG4gIGlmICh0eXBlb2YgcmF3Q29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IG5hbWUgPSByYXdDb25maWc7XG4gICAgcmF3Q29uZmlnID0geyBuYW1lIH07XG4gIH1cblxuICBjb25zdCBjb25maWc6IFJlcXVpcmVkPEZpcmViYXNlQXBwU2V0dGluZ3M+ID0ge1xuICAgIG5hbWU6IERFRkFVTFRfRU5UUllfTkFNRSxcbiAgICBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ6IGZhbHNlLFxuICAgIC4uLnJhd0NvbmZpZ1xuICB9O1xuICBjb25zdCBuYW1lID0gY29uZmlnLm5hbWU7XG5cbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xuICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKEFwcEVycm9yLkJBRF9BUFBfTkFNRSwge1xuICAgICAgYXBwTmFtZTogU3RyaW5nKG5hbWUpXG4gICAgfSk7XG4gIH1cblxuICBvcHRpb25zIHx8PSBnZXREZWZhdWx0QXBwQ29uZmlnKCk7XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuTk9fT1BUSU9OUyk7XG4gIH1cblxuICBjb25zdCBleGlzdGluZ0FwcCA9IF9hcHBzLmdldChuYW1lKSBhcyBGaXJlYmFzZUFwcEltcGw7XG4gIGlmIChleGlzdGluZ0FwcCkge1xuICAgIC8vIHJldHVybiB0aGUgZXhpc3RpbmcgYXBwIGlmIG9wdGlvbnMgYW5kIGNvbmZpZyBkZWVwIGVxdWFsIHRoZSBvbmVzIGluIHRoZSBleGlzdGluZyBhcHAuXG4gICAgaWYgKFxuICAgICAgZGVlcEVxdWFsKG9wdGlvbnMsIGV4aXN0aW5nQXBwLm9wdGlvbnMpICYmXG4gICAgICBkZWVwRXF1YWwoY29uZmlnLCBleGlzdGluZ0FwcC5jb25maWcpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKEFwcEVycm9yLkRVUExJQ0FURV9BUFAsIHsgYXBwTmFtZTogbmFtZSB9KTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjb250YWluZXIgPSBuZXcgQ29tcG9uZW50Q29udGFpbmVyKG5hbWUpO1xuICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xuICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgfVxuXG4gIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZUFwcEltcGwob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xuXG4gIF9hcHBzLnNldChuYW1lLCBuZXdBcHApO1xuXG4gIHJldHVybiBuZXdBcHA7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCB0aGUgZGVmYXVsdCBhcHAgaXMgcmV0dXJuZWQuIFdoZW4gYW4gYXBwIG5hbWVcbiAqIGlzIHByb3ZpZGVkLCB0aGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhhdCBuYW1lIGlzIHJldHVybmVkLlxuICpcbiAqIEFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIGFwcCBiZWluZyByZXRyaWV2ZWQgaGFzIG5vdCB5ZXQgYmVlblxuICogaW5pdGlhbGl6ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFJldHVybiB0aGUgZGVmYXVsdCBhcHBcbiAqIGNvbnN0IGFwcCA9IGdldEFwcCgpO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFJldHVybiBhIG5hbWVkIGFwcFxuICogY29uc3Qgb3RoZXJBcHAgPSBnZXRBcHAoXCJvdGhlckFwcFwiKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBuYW1lIC0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgYXBwIHRvIHJldHVybi4gSWYgbm8gbmFtZSBpc1xuICogICBwcm92aWRlZCwgdGhlIGRlZmF1bHQgaXMgYFwiW0RFRkFVTFRdXCJgLlxuICpcbiAqIEByZXR1cm5zIFRoZSBhcHAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgYXBwIG5hbWUuXG4gKiAgIElmIG5vIGFwcCBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBhcHAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBwKG5hbWU6IHN0cmluZyA9IERFRkFVTFRfRU5UUllfTkFNRSk6IEZpcmViYXNlQXBwIHtcbiAgY29uc3QgYXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xuICBpZiAoIWFwcCAmJiBuYW1lID09PSBERUZBVUxUX0VOVFJZX05BTUUgJiYgZ2V0RGVmYXVsdEFwcENvbmZpZygpKSB7XG4gICAgcmV0dXJuIGluaXRpYWxpemVBcHAoKTtcbiAgfVxuICBpZiAoIWFwcCkge1xuICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKEFwcEVycm9yLk5PX0FQUCwgeyBhcHBOYW1lOiBuYW1lIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFwcDtcbn1cblxuLyoqXG4gKiBBIChyZWFkLW9ubHkpIGFycmF5IG9mIGFsbCBpbml0aWFsaXplZCBhcHBzLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBwcygpOiBGaXJlYmFzZUFwcFtdIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oX2FwcHMudmFsdWVzKCkpO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhpcyBhcHAgdW51c2FibGUgYW5kIGZyZWVzIHRoZSByZXNvdXJjZXMgb2YgYWxsIGFzc29jaWF0ZWRcbiAqIHNlcnZpY2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBkZWxldGVBcHAoYXBwKVxuICogICAudGhlbihmdW5jdGlvbigpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkFwcCBkZWxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJFcnJvciBkZWxldGluZyBhcHA6XCIsIGVycm9yKTtcbiAqICAgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVBcHAoYXBwOiBGaXJlYmFzZUFwcCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBuYW1lID0gYXBwLm5hbWU7XG4gIGlmIChfYXBwcy5oYXMobmFtZSkpIHtcbiAgICBfYXBwcy5kZWxldGUobmFtZSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAoYXBwIGFzIEZpcmViYXNlQXBwSW1wbCkuY29udGFpbmVyXG4gICAgICAgIC5nZXRQcm92aWRlcnMoKVxuICAgICAgICAubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyLmRlbGV0ZSgpKVxuICAgICk7XG4gICAgKGFwcCBhcyBGaXJlYmFzZUFwcEltcGwpLmlzRGVsZXRlZCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBsaWJyYXJ5J3MgbmFtZSBhbmQgdmVyc2lvbiBmb3IgcGxhdGZvcm0gbG9nZ2luZyBwdXJwb3Nlcy5cbiAqIEBwYXJhbSBsaWJyYXJ5IC0gTmFtZSBvZiAxcCBvciAzcCBsaWJyYXJ5IChlLmcuIGZpcmVzdG9yZSwgYW5ndWxhcmZpcmUpXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGF0IGxpYnJhcnkuXG4gKiBAcGFyYW0gdmFyaWFudCAtIEJ1bmRsZSB2YXJpYW50LCBlLmcuLCBub2RlLCBybiwgZXRjLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyVmVyc2lvbihcbiAgbGlicmFyeUtleU9yTmFtZTogc3RyaW5nLFxuICB2ZXJzaW9uOiBzdHJpbmcsXG4gIHZhcmlhbnQ/OiBzdHJpbmdcbik6IHZvaWQge1xuICAvLyBUT0RPOiBXZSBjYW4gdXNlIHRoaXMgY2hlY2sgdG8gd2hpdGVsaXN0IHN0cmluZ3Mgd2hlbi9pZiB3ZSBzZXQgdXBcbiAgLy8gYSBnb29kIHdoaXRlbGlzdCBzeXN0ZW0uXG4gIGxldCBsaWJyYXJ5ID0gUExBVEZPUk1fTE9HX1NUUklOR1tsaWJyYXJ5S2V5T3JOYW1lXSA/PyBsaWJyYXJ5S2V5T3JOYW1lO1xuICBpZiAodmFyaWFudCkge1xuICAgIGxpYnJhcnkgKz0gYC0ke3ZhcmlhbnR9YDtcbiAgfVxuICBjb25zdCBsaWJyYXJ5TWlzbWF0Y2ggPSBsaWJyYXJ5Lm1hdGNoKC9cXHN8XFwvLyk7XG4gIGNvbnN0IHZlcnNpb25NaXNtYXRjaCA9IHZlcnNpb24ubWF0Y2goL1xcc3xcXC8vKTtcbiAgaWYgKGxpYnJhcnlNaXNtYXRjaCB8fCB2ZXJzaW9uTWlzbWF0Y2gpIHtcbiAgICBjb25zdCB3YXJuaW5nID0gW1xuICAgICAgYFVuYWJsZSB0byByZWdpc3RlciBsaWJyYXJ5IFwiJHtsaWJyYXJ5fVwiIHdpdGggdmVyc2lvbiBcIiR7dmVyc2lvbn1cIjpgXG4gICAgXTtcbiAgICBpZiAobGlicmFyeU1pc21hdGNoKSB7XG4gICAgICB3YXJuaW5nLnB1c2goXG4gICAgICAgIGBsaWJyYXJ5IG5hbWUgXCIke2xpYnJhcnl9XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggJiYgdmVyc2lvbk1pc21hdGNoKSB7XG4gICAgICB3YXJuaW5nLnB1c2goJ2FuZCcpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbk1pc21hdGNoKSB7XG4gICAgICB3YXJuaW5nLnB1c2goXG4gICAgICAgIGB2ZXJzaW9uIG5hbWUgXCIke3ZlcnNpb259XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWBcbiAgICAgICk7XG4gICAgfVxuICAgIGxvZ2dlci53YXJuKHdhcm5pbmcuam9pbignICcpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgX3JlZ2lzdGVyQ29tcG9uZW50KFxuICAgIG5ldyBDb21wb25lbnQoXG4gICAgICBgJHtsaWJyYXJ5fS12ZXJzaW9uYCBhcyBOYW1lLFxuICAgICAgKCkgPT4gKHsgbGlicmFyeSwgdmVyc2lvbiB9KSxcbiAgICAgIENvbXBvbmVudFR5cGUuVkVSU0lPTlxuICAgIClcbiAgKTtcbn1cblxuLyoqXG4gKiBTZXRzIGxvZyBoYW5kbGVyIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cbiAqIEBwYXJhbSBsb2dDYWxsYmFjayAtIEFuIG9wdGlvbmFsIGN1c3RvbSBsb2cgaGFuZGxlciB0aGF0IGV4ZWN1dGVzIHVzZXIgY29kZSB3aGVuZXZlclxuICogdGhlIEZpcmViYXNlIFNESyBtYWtlcyBhIGxvZ2dpbmcgY2FsbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkxvZyhcbiAgbG9nQ2FsbGJhY2s6IExvZ0NhbGxiYWNrIHwgbnVsbCxcbiAgb3B0aW9ucz86IExvZ09wdGlvbnNcbik6IHZvaWQge1xuICBpZiAobG9nQ2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGxvZ0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQpO1xuICB9XG4gIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBTZXRzIGxvZyBsZXZlbCBmb3IgYWxsIEZpcmViYXNlIFNES3MuXG4gKlxuICogQWxsIG9mIHRoZSBsb2cgdHlwZXMgYWJvdmUgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGFyZSBjYXB0dXJlZCAoaS5lLiBpZlxuICogeW91IHNldCB0aGUgbG9nIGxldmVsIHRvIGBpbmZvYCwgZXJyb3JzIGFyZSBsb2dnZWQsIGJ1dCBgZGVidWdgIGFuZFxuICogYHZlcmJvc2VgIGxvZ3MgYXJlIG5vdCkuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nTGV2ZWwobG9nTGV2ZWw6IExvZ0xldmVsU3RyaW5nKTogdm9pZCB7XG4gIHNldExvZ0xldmVsSW1wbChsb2dMZXZlbCk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgREJTY2hlbWEsIG9wZW5EQiwgSURCUERhdGFiYXNlIH0gZnJvbSAnaWRiJztcbmltcG9ydCB7IEFwcEVycm9yLCBFUlJPUl9GQUNUT1JZIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgRmlyZWJhc2VBcHAgfSBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5pbXBvcnQgeyBIZWFydGJlYXRzSW5JbmRleGVkREIgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcblxuY29uc3QgREJfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtZGF0YWJhc2UnO1xuY29uc3QgREJfVkVSU0lPTiA9IDE7XG5jb25zdCBTVE9SRV9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1zdG9yZSc7XG5cbmludGVyZmFjZSBBcHBEQiBleHRlbmRzIERCU2NoZW1hIHtcbiAgJ2ZpcmViYXNlLWhlYXJ0YmVhdC1zdG9yZSc6IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogSGVhcnRiZWF0c0luSW5kZXhlZERCO1xuICB9O1xufVxuXG5sZXQgZGJQcm9taXNlOiBQcm9taXNlPElEQlBEYXRhYmFzZTxBcHBEQj4+IHwgbnVsbCA9IG51bGw7XG5mdW5jdGlvbiBnZXREYlByb21pc2UoKTogUHJvbWlzZTxJREJQRGF0YWJhc2U8QXBwREI+PiB7XG4gIGlmICghZGJQcm9taXNlKSB7XG4gICAgZGJQcm9taXNlID0gb3BlbkRCPEFwcERCPihEQl9OQU1FLCBEQl9WRVJTSU9OLCB7XG4gICAgICB1cGdyYWRlOiAoZGIsIG9sZFZlcnNpb24pID0+IHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgdXNlICdicmVhaycgaW4gdGhpcyBzd2l0Y2ggc3RhdGVtZW50LCB0aGUgZmFsbC10aHJvdWdoXG4gICAgICAgIC8vIGJlaGF2aW9yIGlzIHdoYXQgd2Ugd2FudCwgYmVjYXVzZSBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmVyc2lvbnMgYmV0d2VlblxuICAgICAgICAvLyB0aGUgb2xkIHZlcnNpb24gYW5kIHRoZSBjdXJyZW50IHZlcnNpb24sIHdlIHdhbnQgQUxMIHRoZSBtaWdyYXRpb25zXG4gICAgICAgIC8vIHRoYXQgY29ycmVzcG9uZCB0byB0aG9zZSB2ZXJzaW9ucyB0byBydW4sIG5vdCBvbmx5IHRoZSBsYXN0IG9uZS5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICBzd2l0Y2ggKG9sZFZlcnNpb24pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuSURCX09QRU4sIHtcbiAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUubWVzc2FnZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRiUHJvbWlzZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQihcbiAgYXBwOiBGaXJlYmFzZUFwcFxuKTogUHJvbWlzZTxIZWFydGJlYXRzSW5JbmRleGVkREIgfCB1bmRlZmluZWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRiXG4gICAgICAudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSlcbiAgICAgIC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKVxuICAgICAgLmdldChjb21wdXRlS2V5KGFwcCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlkYkdldEVycm9yID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuSURCX0dFVCwge1xuICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogKGUgYXMgRXJyb3IpPy5tZXNzYWdlXG4gICAgICB9KTtcbiAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIoXG4gIGFwcDogRmlyZWJhc2VBcHAsXG4gIGhlYXJ0YmVhdE9iamVjdDogSGVhcnRiZWF0c0luSW5kZXhlZERCXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xuICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XG4gICAgYXdhaXQgb2JqZWN0U3RvcmUucHV0KGhlYXJ0YmVhdE9iamVjdCwgY29tcHV0ZUtleShhcHApKTtcbiAgICBhd2FpdCB0eC5kb25lO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKEFwcEVycm9yLklEQl9XUklURSwge1xuICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogKGUgYXMgRXJyb3IpPy5tZXNzYWdlXG4gICAgICB9KTtcbiAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlS2V5KGFwcDogRmlyZWJhc2VBcHApOiBzdHJpbmcge1xuICByZXR1cm4gYCR7YXBwLm5hbWV9ISR7YXBwLm9wdGlvbnMuYXBwSWR9YDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudENvbnRhaW5lciB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsXG4gIGlzSW5kZXhlZERCQXZhaWxhYmxlLFxuICB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlXG59IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7XG4gIHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQixcbiAgd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREJcbn0gZnJvbSAnLi9pbmRleGVkZGInO1xuaW1wb3J0IHsgRmlyZWJhc2VBcHAgfSBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5pbXBvcnQge1xuICBIZWFydGJlYXRzQnlVc2VyQWdlbnQsXG4gIEhlYXJ0YmVhdFNlcnZpY2UsXG4gIEhlYXJ0YmVhdHNJbkluZGV4ZWREQixcbiAgSGVhcnRiZWF0U3RvcmFnZSxcbiAgU2luZ2xlRGF0ZUhlYXJ0YmVhdFxufSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgTUFYX0hFQURFUl9CWVRFUyA9IDEwMjQ7XG4vLyAzMCBkYXlzXG5jb25zdCBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTID0gMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuXG5leHBvcnQgY2xhc3MgSGVhcnRiZWF0U2VydmljZUltcGwgaW1wbGVtZW50cyBIZWFydGJlYXRTZXJ2aWNlIHtcbiAgLyoqXG4gICAqIFRoZSBwZXJzaXN0ZW5jZSBsYXllciBmb3IgaGVhcnRiZWF0c1xuICAgKiBMZWF2ZSBwdWJsaWMgZm9yIGVhc2llciB0ZXN0aW5nLlxuICAgKi9cbiAgX3N0b3JhZ2U6IEhlYXJ0YmVhdFN0b3JhZ2VJbXBsO1xuXG4gIC8qKlxuICAgKiBJbi1tZW1vcnkgY2FjaGUgZm9yIGhlYXJ0YmVhdHMsIHVzZWQgYnkgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHRvIGdlbmVyYXRlXG4gICAqIHRoZSBoZWFkZXIgc3RyaW5nLlxuICAgKiBTdG9yZXMgb25lIHJlY29yZCBwZXIgZGF0ZS4gVGhpcyB3aWxsIGJlIGNvbnNvbGlkYXRlZCBpbnRvIHRoZSBzdGFuZGFyZFxuICAgKiBmb3JtYXQgb2Ygb25lIHJlY29yZCBwZXIgdXNlciBhZ2VudCBzdHJpbmcgYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBoZWFkZXIuXG4gICAqIFBvcHVsYXRlZCBmcm9tIGluZGV4ZWREQiB3aGVuIHRoZSBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZCBhbmQgc2hvdWxkXG4gICAqIGJlIGtlcHQgaW4gc3luYyB3aXRoIGluZGV4ZWREQi5cbiAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cbiAgICovXG4gIF9oZWFydGJlYXRzQ2FjaGU6IEhlYXJ0YmVhdHNJbkluZGV4ZWREQiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiB0aGUgaW5pdGlhbGl6YXRpb24gcHJvbWlzZSBmb3IgcG9wdWxhdGluZyBoZWFydGJlYXRDYWNoZS5cbiAgICogSWYgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIGlzIGNhbGxlZCBiZWZvcmUgdGhlIHByb21pc2UgcmVzb2x2ZXNcbiAgICogKGhlYXJiZWF0c0NhY2hlID09IG51bGwpLCBpdCBzaG91bGQgd2FpdCBmb3IgdGhpcyBwcm9taXNlXG4gICAqIExlYXZlIHB1YmxpYyBmb3IgZWFzaWVyIHRlc3RpbmcuXG4gICAqL1xuICBfaGVhcnRiZWF0c0NhY2hlUHJvbWlzZTogUHJvbWlzZTxIZWFydGJlYXRzSW5JbmRleGVkREI+O1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNvbnRhaW5lcjogQ29tcG9uZW50Q29udGFpbmVyKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcy5jb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcCcpLmdldEltbWVkaWF0ZSgpO1xuICAgIHRoaXMuX3N0b3JhZ2UgPSBuZXcgSGVhcnRiZWF0U3RvcmFnZUltcGwoYXBwKTtcbiAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlID0gdGhpcy5fc3RvcmFnZS5yZWFkKCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gcmVzdWx0O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgdG8gcmVwb3J0IGEgaGVhcnRiZWF0LiBUaGUgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZVxuICAgKiBhIEhlYXJ0YmVhdHNCeVVzZXJBZ2VudCBvYmplY3QsIHVwZGF0ZSBoZWFydGJlYXRzQ2FjaGUsIGFuZCBwZXJzaXN0IGl0XG4gICAqIHRvIEluZGV4ZWREQi5cbiAgICogTm90ZSB0aGF0IHdlIG9ubHkgc3RvcmUgb25lIGhlYXJ0YmVhdCBwZXIgZGF5LiBTbyBpZiBhIGhlYXJ0YmVhdCBmb3IgdG9kYXkgaXNcbiAgICogYWxyZWFkeSBsb2dnZWQsIHN1YnNlcXVlbnQgY2FsbHMgdG8gdGhpcyBmdW5jdGlvbiBpbiB0aGUgc2FtZSBkYXkgd2lsbCBiZSBpZ25vcmVkLlxuICAgKi9cbiAgYXN5bmMgdHJpZ2dlckhlYXJ0YmVhdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBwbGF0Zm9ybUxvZ2dlciA9IHRoaXMuY29udGFpbmVyXG4gICAgICAuZ2V0UHJvdmlkZXIoJ3BsYXRmb3JtLWxvZ2dlcicpXG4gICAgICAuZ2V0SW1tZWRpYXRlKCk7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBcIkZpcmViYXNlIHVzZXIgYWdlbnRcIiBzdHJpbmcgZnJvbSB0aGUgcGxhdGZvcm0gbG9nZ2VyXG4gICAgLy8gc2VydmljZSwgbm90IHRoZSBicm93c2VyIHVzZXIgYWdlbnQuXG4gICAgY29uc3QgYWdlbnQgPSBwbGF0Zm9ybUxvZ2dlci5nZXRQbGF0Zm9ybUluZm9TdHJpbmcoKTtcbiAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xuICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XG4gICAgfVxuICAgIC8vIERvIG5vdCBzdG9yZSBhIGhlYXJ0YmVhdCBpZiBvbmUgaXMgYWxyZWFkeSBzdG9yZWQgZm9yIHRoaXMgZGF5XG4gICAgLy8gb3IgaWYgYSBoZWFkZXIgaGFzIGFscmVhZHkgYmVlbiBzZW50IHRvZGF5LlxuICAgIGlmIChcbiAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPT09IGRhdGUgfHxcbiAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLnNvbWUoXG4gICAgICAgIHNpbmdsZURhdGVIZWFydGJlYXQgPT4gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlID09PSBkYXRlXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGVudHJ5IGZvciB0aGlzIGRhdGUuIENyZWF0ZSBvbmUuXG4gICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5wdXNoKHsgZGF0ZSwgYWdlbnQgfSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBlbnRyaWVzIG9sZGVyIHRoYW4gMzAgZGF5cy5cbiAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmZpbHRlcihcbiAgICAgIHNpbmdsZURhdGVIZWFydGJlYXQgPT4ge1xuICAgICAgICBjb25zdCBoYlRpbWVzdGFtcCA9IG5ldyBEYXRlKHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSkudmFsdWVPZigpO1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gbm93IC0gaGJUaW1lc3RhbXAgPD0gU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUztcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgd2hpY2ggY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBoZWFydGJlYXQtc3BlY2lmaWMgaGVhZGVyIGRpcmVjdGx5LlxuICAgKiBJdCBhbHNvIGNsZWFycyBhbGwgaGVhcnRiZWF0cyBmcm9tIG1lbW9yeSBhcyB3ZWxsIGFzIGluIEluZGV4ZWREQi5cbiAgICpcbiAgICogTk9URTogQ29uc3VtaW5nIHByb2R1Y3QgU0RLcyBzaG91bGQgbm90IHNlbmQgdGhlIGhlYWRlciBpZiB0aGlzIG1ldGhvZFxuICAgKiByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICovXG4gIGFzeW5jIGdldEhlYXJ0YmVhdHNIZWFkZXIoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlID09PSBudWxsKSB7XG4gICAgICBhd2FpdCB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlO1xuICAgIH1cbiAgICAvLyBJZiBpdCdzIHN0aWxsIG51bGwgb3IgdGhlIGFycmF5IGlzIGVtcHR5LCB0aGVyZSBpcyBubyBkYXRhIHRvIHNlbmQuXG4gICAgaWYgKFxuICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID09PSBudWxsIHx8XG4gICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcbiAgICAvLyBFeHRyYWN0IGFzIG1hbnkgaGVhcnRiZWF0cyBmcm9tIHRoZSBjYWNoZSBhcyB3aWxsIGZpdCB1bmRlciB0aGUgc2l6ZSBsaW1pdC5cbiAgICBjb25zdCB7IGhlYXJ0YmVhdHNUb1NlbmQsIHVuc2VudEVudHJpZXMgfSA9IGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKFxuICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHNcbiAgICApO1xuICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyB2ZXJzaW9uOiAyLCBoZWFydGJlYXRzOiBoZWFydGJlYXRzVG9TZW5kIH0pXG4gICAgKTtcbiAgICAvLyBTdG9yZSBsYXN0IHNlbnQgZGF0ZSB0byBwcmV2ZW50IGFub3RoZXIgYmVpbmcgbG9nZ2VkL3NlbnQgZm9yIHRoZSBzYW1lIGRheS5cbiAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUubGFzdFNlbnRIZWFydGJlYXREYXRlID0gZGF0ZTtcbiAgICBpZiAodW5zZW50RW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBTdG9yZSBhbnkgdW5zZW50IGVudHJpZXMgaWYgdGhleSBleGlzdC5cbiAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gdW5zZW50RW50cmllcztcbiAgICAgIC8vIFRoaXMgc2VlbXMgbW9yZSBsaWtlbHkgdGhhbiBlbXB0eWluZyB0aGUgYXJyYXkgKGJlbG93KSB0byBsZWFkIHRvIHNvbWUgb2RkIHN0YXRlXG4gICAgICAvLyBzaW5jZSB0aGUgY2FjaGUgaXNuJ3QgZW1wdHkgYW5kIHRoaXMgd2lsbCBiZSBjYWxsZWQgYWdhaW4gb24gdGhlIG5leHQgcmVxdWVzdCxcbiAgICAgIC8vIGFuZCBpcyBwcm9iYWJseSBzYWZlc3QgaWYgd2UgYXdhaXQgaXQuXG4gICAgICBhd2FpdCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IFtdO1xuICAgICAgLy8gRG8gbm90IHdhaXQgZm9yIHRoaXMsIHRvIHJlZHVjZSBsYXRlbmN5LlxuICAgICAgdm9pZCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVyU3RyaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFVUQ0RhdGVTdHJpbmcoKTogc3RyaW5nIHtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAvLyBSZXR1cm5zIGRhdGUgZm9ybWF0ICdZWVlZLU1NLUREJ1xuICByZXR1cm4gdG9kYXkudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIoXG4gIGhlYXJ0YmVhdHNDYWNoZTogU2luZ2xlRGF0ZUhlYXJ0YmVhdFtdLFxuICBtYXhTaXplID0gTUFYX0hFQURFUl9CWVRFU1xuKToge1xuICBoZWFydGJlYXRzVG9TZW5kOiBIZWFydGJlYXRzQnlVc2VyQWdlbnRbXTtcbiAgdW5zZW50RW50cmllczogU2luZ2xlRGF0ZUhlYXJ0YmVhdFtdO1xufSB7XG4gIC8vIEhlYXJ0YmVhdHMgZ3JvdXBlZCBieSB1c2VyIGFnZW50IGluIHRoZSBzdGFuZGFyZCBmb3JtYXQgdG8gYmUgc2VudCBpblxuICAvLyB0aGUgaGVhZGVyLlxuICBjb25zdCBoZWFydGJlYXRzVG9TZW5kOiBIZWFydGJlYXRzQnlVc2VyQWdlbnRbXSA9IFtdO1xuICAvLyBTaW5nbGUgZGF0ZSBmb3JtYXQgaGVhcnRiZWF0cyB0aGF0IGFyZSBub3Qgc2VudC5cbiAgbGV0IHVuc2VudEVudHJpZXMgPSBoZWFydGJlYXRzQ2FjaGUuc2xpY2UoKTtcbiAgZm9yIChjb25zdCBzaW5nbGVEYXRlSGVhcnRiZWF0IG9mIGhlYXJ0YmVhdHNDYWNoZSkge1xuICAgIC8vIExvb2sgZm9yIGFuIGV4aXN0aW5nIGVudHJ5IHdpdGggdGhlIHNhbWUgdXNlciBhZ2VudC5cbiAgICBjb25zdCBoZWFydGJlYXRFbnRyeSA9IGhlYXJ0YmVhdHNUb1NlbmQuZmluZChcbiAgICAgIGhiID0+IGhiLmFnZW50ID09PSBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50XG4gICAgKTtcbiAgICBpZiAoIWhlYXJ0YmVhdEVudHJ5KSB7XG4gICAgICAvLyBJZiBubyBlbnRyeSBmb3IgdGhpcyB1c2VyIGFnZW50IGV4aXN0cywgY3JlYXRlIG9uZS5cbiAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucHVzaCh7XG4gICAgICAgIGFnZW50OiBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50LFxuICAgICAgICBkYXRlczogW3NpbmdsZURhdGVIZWFydGJlYXQuZGF0ZV1cbiAgICAgIH0pO1xuICAgICAgaWYgKGNvdW50Qnl0ZXMoaGVhcnRiZWF0c1RvU2VuZCkgPiBtYXhTaXplKSB7XG4gICAgICAgIC8vIElmIHRoZSBoZWFkZXIgd291bGQgZXhjZWVkIG1heCBzaXplLCByZW1vdmUgdGhlIGFkZGVkIGhlYXJ0YmVhdFxuICAgICAgICAvLyBlbnRyeSBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cbiAgICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnB1c2goc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKTtcbiAgICAgIC8vIElmIHRoZSBoZWFkZXIgd291bGQgZXhjZWVkIG1heCBzaXplLCByZW1vdmUgdGhlIGFkZGVkIGRhdGVcbiAgICAgIC8vIGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxuICAgICAgaWYgKGNvdW50Qnl0ZXMoaGVhcnRiZWF0c1RvU2VuZCkgPiBtYXhTaXplKSB7XG4gICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUG9wIHVuc2VudCBlbnRyeSBmcm9tIHF1ZXVlLiAoU2tpcHBlZCBpZiBhZGRpbmcgdGhlIGVudHJ5IGV4Y2VlZGVkXG4gICAgLy8gcXVvdGEgYW5kIHRoZSBsb29wIGJyZWFrcyBlYXJseS4pXG4gICAgdW5zZW50RW50cmllcyA9IHVuc2VudEVudHJpZXMuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoZWFydGJlYXRzVG9TZW5kLFxuICAgIHVuc2VudEVudHJpZXNcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIEhlYXJ0YmVhdFN0b3JhZ2VJbXBsIGltcGxlbWVudHMgSGVhcnRiZWF0U3RvcmFnZSB7XG4gIHByaXZhdGUgX2NhblVzZUluZGV4ZWREQlByb21pc2U6IFByb21pc2U8Ym9vbGVhbj47XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBhcHA6IEZpcmViYXNlQXBwKSB7XG4gICAgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZSA9IHRoaXMucnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpO1xuICB9XG4gIGFzeW5jIHJ1bkluZGV4ZWREQkVudmlyb25tZW50Q2hlY2soKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCFpc0luZGV4ZWREQkF2YWlsYWJsZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKClcbiAgICAgICAgLnRoZW4oKCkgPT4gdHJ1ZSlcbiAgICAgICAgLmNhdGNoKCgpID0+IGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYWxsIGhlYXJ0YmVhdHMuXG4gICAqL1xuICBhc3luYyByZWFkKCk6IFByb21pc2U8SGVhcnRiZWF0c0luSW5kZXhlZERCPiB7XG4gICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcbiAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xuICAgICAgcmV0dXJuIHsgaGVhcnRiZWF0czogW10gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaWRiSGVhcnRiZWF0T2JqZWN0ID0gYXdhaXQgcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKHRoaXMuYXBwKTtcbiAgICAgIHJldHVybiBpZGJIZWFydGJlYXRPYmplY3QgfHwgeyBoZWFydGJlYXRzOiBbXSB9O1xuICAgIH1cbiAgfVxuICAvLyBvdmVyd3JpdGUgdGhlIHN0b3JhZ2Ugd2l0aCB0aGUgcHJvdmlkZWQgaGVhcnRiZWF0c1xuICBhc3luYyBvdmVyd3JpdGUoaGVhcnRiZWF0c09iamVjdDogSGVhcnRiZWF0c0luSW5kZXhlZERCKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcbiAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcbiAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xuICAgICAgICBsYXN0U2VudEhlYXJ0YmVhdERhdGU6XG4gICAgICAgICAgaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPz9cbiAgICAgICAgICBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlLFxuICAgICAgICBoZWFydGJlYXRzOiBoZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvLyBhZGQgaGVhcnRiZWF0c1xuICBhc3luYyBhZGQoaGVhcnRiZWF0c09iamVjdDogSGVhcnRiZWF0c0luSW5kZXhlZERCKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcbiAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcbiAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xuICAgICAgICBsYXN0U2VudEhlYXJ0YmVhdERhdGU6XG4gICAgICAgICAgaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPz9cbiAgICAgICAgICBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlLFxuICAgICAgICBoZWFydGJlYXRzOiBbXG4gICAgICAgICAgLi4uZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHMsXG4gICAgICAgICAgLi4uaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXG4gICAgICAgIF1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBieXRlcyBvZiBhIEhlYXJ0YmVhdHNCeVVzZXJBZ2VudCBhcnJheSBhZnRlciBiZWluZyB3cmFwcGVkXG4gKiBpbiBhIHBsYXRmb3JtIGxvZ2dpbmcgaGVhZGVyIEpTT04gb2JqZWN0LCBzdHJpbmdpZmllZCwgYW5kIGNvbnZlcnRlZFxuICogdG8gYmFzZSA2NC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvdW50Qnl0ZXMoaGVhcnRiZWF0c0NhY2hlOiBIZWFydGJlYXRzQnlVc2VyQWdlbnRbXSk6IG51bWJlciB7XG4gIC8vIGJhc2U2NCBoYXMgYSByZXN0cmljdGVkIHNldCBvZiBjaGFyYWN0ZXJzLCBhbGwgb2Ygd2hpY2ggc2hvdWxkIGJlIDEgYnl0ZS5cbiAgcmV0dXJuIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKFxuICAgIC8vIGhlYXJ0YmVhdHNDYWNoZSB3cmFwcGVyIHByb3BlcnRpZXNcbiAgICBKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNDYWNoZSB9KVxuICApLmxlbmd0aDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50VHlwZSB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbCB9IGZyb20gJy4vcGxhdGZvcm1Mb2dnZXJTZXJ2aWNlJztcbmltcG9ydCB7IG5hbWUsIHZlcnNpb24gfSBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgX3JlZ2lzdGVyQ29tcG9uZW50IH0gZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgeyByZWdpc3RlclZlcnNpb24gfSBmcm9tICcuL2FwaSc7XG5pbXBvcnQgeyBIZWFydGJlYXRTZXJ2aWNlSW1wbCB9IGZyb20gJy4vaGVhcnRiZWF0U2VydmljZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvcmVDb21wb25lbnRzKHZhcmlhbnQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgX3JlZ2lzdGVyQ29tcG9uZW50KFxuICAgIG5ldyBDb21wb25lbnQoXG4gICAgICAncGxhdGZvcm0tbG9nZ2VyJyxcbiAgICAgIGNvbnRhaW5lciA9PiBuZXcgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbChjb250YWluZXIpLFxuICAgICAgQ29tcG9uZW50VHlwZS5QUklWQVRFXG4gICAgKVxuICApO1xuICBfcmVnaXN0ZXJDb21wb25lbnQoXG4gICAgbmV3IENvbXBvbmVudChcbiAgICAgICdoZWFydGJlYXQnLFxuICAgICAgY29udGFpbmVyID0+IG5ldyBIZWFydGJlYXRTZXJ2aWNlSW1wbChjb250YWluZXIpLFxuICAgICAgQ29tcG9uZW50VHlwZS5QUklWQVRFXG4gICAgKVxuICApO1xuXG4gIC8vIFJlZ2lzdGVyIGBhcHBgIHBhY2thZ2UuXG4gIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCB2YXJpYW50KTtcbiAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cbiAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdfX0JVSUxEX1RBUkdFVF9fJyk7XG4gIC8vIFJlZ2lzdGVyIHBsYXRmb3JtIFNESyBpZGVudGlmaWVyIChubyB2ZXJzaW9uKS5cbiAgcmVnaXN0ZXJWZXJzaW9uKCdmaXJlLWpzJywgJycpO1xufVxuIiwiLyoqXG4gKiBGaXJlYmFzZSBBcHBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIHBhY2thZ2UgY29vcmRpbmF0ZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgZGlmZmVyZW50IEZpcmViYXNlIGNvbXBvbmVudHNcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IHJlZ2lzdGVyQ29yZUNvbXBvbmVudHMgfSBmcm9tICcuL3JlZ2lzdGVyQ29yZUNvbXBvbmVudHMnO1xuXG5leHBvcnQgKiBmcm9tICcuL2FwaSc7XG5leHBvcnQgKiBmcm9tICcuL2ludGVybmFsJztcbmV4cG9ydCAqIGZyb20gJy4vcHVibGljLXR5cGVzJztcblxucmVnaXN0ZXJDb3JlQ29tcG9uZW50cygnX19SVU5USU1FX0VOVl9fJyk7XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICB9XG4gIH1cbiAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICBkb25lID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3J1bkluaXRpYWxpemVycyh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICB9XG4gIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIiA/IHggOiBcIlwiLmNvbmNhdCh4KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NldEZ1bmN0aW9uTmFtZShmLCBuYW1lLCBwcmVmaXgpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICB9XG59XG5cbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XG4gIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgdHJ5IHtcbiAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICB9XG4gIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICB9XG4gICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgfVxuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xuICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgIHJba10gPSBhW2pdO1xuICByZXR1cm4gcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xuICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XG4gIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcbiAgdmFyIGksIHA7XG4gIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gIHJldHVybiBjb29rZWQ7XG59O1xuXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcbiAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xuICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcbiAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2V4dGVuZHMsXG4gIF9fYXNzaWduLFxuICBfX3Jlc3QsXG4gIF9fZGVjb3JhdGUsXG4gIF9fcGFyYW0sXG4gIF9fbWV0YWRhdGEsXG4gIF9fYXdhaXRlcixcbiAgX19nZW5lcmF0b3IsXG4gIF9fY3JlYXRlQmluZGluZyxcbiAgX19leHBvcnRTdGFyLFxuICBfX3ZhbHVlcyxcbiAgX19yZWFkLFxuICBfX3NwcmVhZCxcbiAgX19zcHJlYWRBcnJheXMsXG4gIF9fc3ByZWFkQXJyYXksXG4gIF9fYXdhaXQsXG4gIF9fYXN5bmNHZW5lcmF0b3IsXG4gIF9fYXN5bmNEZWxlZ2F0b3IsXG4gIF9fYXN5bmNWYWx1ZXMsXG4gIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxuICBfX2ltcG9ydFN0YXIsXG4gIF9faW1wb3J0RGVmYXVsdCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQW4gZW51bSBvZiBmYWN0b3JzIHRoYXQgbWF5IGJlIHVzZWQgZm9yIG11bHRpZmFjdG9yIGF1dGhlbnRpY2F0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IEZhY3RvcklkID0ge1xuICAvKiogUGhvbmUgYXMgc2Vjb25kIGZhY3RvciAqL1xuICBQSE9ORTogJ3Bob25lJyxcbiAgVE9UUDogJ3RvdHAnXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHN1cHBvcnRlZCBwcm92aWRlcnMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgUHJvdmlkZXJJZCA9IHtcbiAgLyoqIEZhY2Vib29rIHByb3ZpZGVyIElEICovXG4gIEZBQ0VCT09LOiAnZmFjZWJvb2suY29tJyxcbiAgLyoqIEdpdEh1YiBwcm92aWRlciBJRCAqL1xuICBHSVRIVUI6ICdnaXRodWIuY29tJyxcbiAgLyoqIEdvb2dsZSBwcm92aWRlciBJRCAqL1xuICBHT09HTEU6ICdnb29nbGUuY29tJyxcbiAgLyoqIFBhc3N3b3JkIHByb3ZpZGVyICovXG4gIFBBU1NXT1JEOiAncGFzc3dvcmQnLFxuICAvKiogUGhvbmUgcHJvdmlkZXIgKi9cbiAgUEhPTkU6ICdwaG9uZScsXG4gIC8qKiBUd2l0dGVyIHByb3ZpZGVyIElEICovXG4gIFRXSVRURVI6ICd0d2l0dGVyLmNvbSdcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogRW51bWVyYXRpb24gb2Ygc3VwcG9ydGVkIHNpZ24taW4gbWV0aG9kcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBTaWduSW5NZXRob2QgPSB7XG4gIC8qKiBFbWFpbCBsaW5rIHNpZ24gaW4gbWV0aG9kICovXG4gIEVNQUlMX0xJTks6ICdlbWFpbExpbmsnLFxuICAvKiogRW1haWwvcGFzc3dvcmQgc2lnbiBpbiBtZXRob2QgKi9cbiAgRU1BSUxfUEFTU1dPUkQ6ICdwYXNzd29yZCcsXG4gIC8qKiBGYWNlYm9vayBzaWduIGluIG1ldGhvZCAqL1xuICBGQUNFQk9PSzogJ2ZhY2Vib29rLmNvbScsXG4gIC8qKiBHaXRIdWIgc2lnbiBpbiBtZXRob2QgKi9cbiAgR0lUSFVCOiAnZ2l0aHViLmNvbScsXG4gIC8qKiBHb29nbGUgc2lnbiBpbiBtZXRob2QgKi9cbiAgR09PR0xFOiAnZ29vZ2xlLmNvbScsXG4gIC8qKiBQaG9uZSBzaWduIGluIG1ldGhvZCAqL1xuICBQSE9ORTogJ3Bob25lJyxcbiAgLyoqIFR3aXR0ZXIgc2lnbiBpbiBtZXRob2QgKi9cbiAgVFdJVFRFUjogJ3R3aXR0ZXIuY29tJ1xufSBhcyBjb25zdDtcblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgb3BlcmF0aW9uIHR5cGVzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IE9wZXJhdGlvblR5cGUgPSB7XG4gIC8qKiBPcGVyYXRpb24gaW52b2x2aW5nIGxpbmtpbmcgYW4gYWRkaXRpb25hbCBwcm92aWRlciB0byBhbiBhbHJlYWR5IHNpZ25lZC1pbiB1c2VyLiAqL1xuICBMSU5LOiAnbGluaycsXG4gIC8qKiBPcGVyYXRpb24gaW52b2x2aW5nIHVzaW5nIGEgcHJvdmlkZXIgdG8gcmVhdXRoZW50aWNhdGUgYW4gYWxyZWFkeSBzaWduZWQtaW4gdXNlci4gKi9cbiAgUkVBVVRIRU5USUNBVEU6ICdyZWF1dGhlbnRpY2F0ZScsXG4gIC8qKiBPcGVyYXRpb24gaW52b2x2aW5nIHNpZ25pbmcgaW4gYSB1c2VyLiAqL1xuICBTSUdOX0lOOiAnc2lnbkluJ1xufSBhcyBjb25zdDtcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB0aGUgcG9zc2libGUgZW1haWwgYWN0aW9uIHR5cGVzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IEFjdGlvbkNvZGVPcGVyYXRpb24gPSB7XG4gIC8qKiBUaGUgZW1haWwgbGluayBzaWduLWluIGFjdGlvbi4gKi9cbiAgRU1BSUxfU0lHTklOOiAnRU1BSUxfU0lHTklOJyxcbiAgLyoqIFRoZSBwYXNzd29yZCByZXNldCBhY3Rpb24uICovXG4gIFBBU1NXT1JEX1JFU0VUOiAnUEFTU1dPUkRfUkVTRVQnLFxuICAvKiogVGhlIGVtYWlsIHJldm9jYXRpb24gYWN0aW9uLiAqL1xuICBSRUNPVkVSX0VNQUlMOiAnUkVDT1ZFUl9FTUFJTCcsXG4gIC8qKiBUaGUgcmV2ZXJ0IHNlY29uZCBmYWN0b3IgYWRkaXRpb24gZW1haWwgYWN0aW9uLiAqL1xuICBSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTjogJ1JFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OJyxcbiAgLyoqIFRoZSByZXZlcnQgc2Vjb25kIGZhY3RvciBhZGRpdGlvbiBlbWFpbCBhY3Rpb24uICovXG4gIFZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMOiAnVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwnLFxuICAvKiogVGhlIGVtYWlsIHZlcmlmaWNhdGlvbiBhY3Rpb24uICovXG4gIFZFUklGWV9FTUFJTDogJ1ZFUklGWV9FTUFJTCdcbn0gYXMgY29uc3Q7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoRXJyb3JNYXAsIFVzZXIgfSBmcm9tICcuLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBFcnJvck1hcCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHsgSWRUb2tlbk1mYVJlc3BvbnNlIH0gZnJvbSAnLi4vYXBpL2F1dGhlbnRpY2F0aW9uL21mYSc7XG5pbXBvcnQgeyBBcHBOYW1lIH0gZnJvbSAnLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4vY3JlZGVudGlhbHMnO1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIEZpcmViYXNlIEF1dGggZXJyb3IgY29kZXMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEF1dGhFcnJvckNvZGUge1xuICBBRE1JTl9PTkxZX09QRVJBVElPTiA9ICdhZG1pbi1yZXN0cmljdGVkLW9wZXJhdGlvbicsXG4gIEFSR1VNRU5UX0VSUk9SID0gJ2FyZ3VtZW50LWVycm9yJyxcbiAgQVBQX05PVF9BVVRIT1JJWkVEID0gJ2FwcC1ub3QtYXV0aG9yaXplZCcsXG4gIEFQUF9OT1RfSU5TVEFMTEVEID0gJ2FwcC1ub3QtaW5zdGFsbGVkJyxcbiAgQ0FQVENIQV9DSEVDS19GQUlMRUQgPSAnY2FwdGNoYS1jaGVjay1mYWlsZWQnLFxuICBDT0RFX0VYUElSRUQgPSAnY29kZS1leHBpcmVkJyxcbiAgQ09SRE9WQV9OT1RfUkVBRFkgPSAnY29yZG92YS1ub3QtcmVhZHknLFxuICBDT1JTX1VOU1VQUE9SVEVEID0gJ2NvcnMtdW5zdXBwb3J0ZWQnLFxuICBDUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFID0gJ2NyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2UnLFxuICBDUkVERU5USUFMX01JU01BVENIID0gJ2N1c3RvbS10b2tlbi1taXNtYXRjaCcsXG4gIENSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTiA9ICdyZXF1aXJlcy1yZWNlbnQtbG9naW4nLFxuICBERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEggPSAnZGVwZW5kZW50LXNkay1pbml0aWFsaXplZC1iZWZvcmUtYXV0aCcsXG4gIERZTkFNSUNfTElOS19OT1RfQUNUSVZBVEVEID0gJ2R5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkJyxcbiAgRU1BSUxfQ0hBTkdFX05FRURTX1ZFUklGSUNBVElPTiA9ICdlbWFpbC1jaGFuZ2UtbmVlZHMtdmVyaWZpY2F0aW9uJyxcbiAgRU1BSUxfRVhJU1RTID0gJ2VtYWlsLWFscmVhZHktaW4tdXNlJyxcbiAgRU1VTEFUT1JfQ09ORklHX0ZBSUxFRCA9ICdlbXVsYXRvci1jb25maWctZmFpbGVkJyxcbiAgRVhQSVJFRF9PT0JfQ09ERSA9ICdleHBpcmVkLWFjdGlvbi1jb2RlJyxcbiAgRVhQSVJFRF9QT1BVUF9SRVFVRVNUID0gJ2NhbmNlbGxlZC1wb3B1cC1yZXF1ZXN0JyxcbiAgSU5URVJOQUxfRVJST1IgPSAnaW50ZXJuYWwtZXJyb3InLFxuICBJTlZBTElEX0FQSV9LRVkgPSAnaW52YWxpZC1hcGkta2V5JyxcbiAgSU5WQUxJRF9BUFBfQ1JFREVOVElBTCA9ICdpbnZhbGlkLWFwcC1jcmVkZW50aWFsJyxcbiAgSU5WQUxJRF9BUFBfSUQgPSAnaW52YWxpZC1hcHAtaWQnLFxuICBJTlZBTElEX0FVVEggPSAnaW52YWxpZC11c2VyLXRva2VuJyxcbiAgSU5WQUxJRF9BVVRIX0VWRU5UID0gJ2ludmFsaWQtYXV0aC1ldmVudCcsXG4gIElOVkFMSURfQ0VSVF9IQVNIID0gJ2ludmFsaWQtY2VydC1oYXNoJyxcbiAgSU5WQUxJRF9DT0RFID0gJ2ludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGUnLFxuICBJTlZBTElEX0NPTlRJTlVFX1VSSSA9ICdpbnZhbGlkLWNvbnRpbnVlLXVyaScsXG4gIElOVkFMSURfQ09SRE9WQV9DT05GSUdVUkFUSU9OID0gJ2ludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uJyxcbiAgSU5WQUxJRF9DVVNUT01fVE9LRU4gPSAnaW52YWxpZC1jdXN0b20tdG9rZW4nLFxuICBJTlZBTElEX0RZTkFNSUNfTElOS19ET01BSU4gPSAnaW52YWxpZC1keW5hbWljLWxpbmstZG9tYWluJyxcbiAgSU5WQUxJRF9FTUFJTCA9ICdpbnZhbGlkLWVtYWlsJyxcbiAgSU5WQUxJRF9FTVVMQVRPUl9TQ0hFTUUgPSAnaW52YWxpZC1lbXVsYXRvci1zY2hlbWUnLFxuICBJTlZBTElEX0lEUF9SRVNQT05TRSA9ICdpbnZhbGlkLWNyZWRlbnRpYWwnLFxuICBJTlZBTElEX01FU1NBR0VfUEFZTE9BRCA9ICdpbnZhbGlkLW1lc3NhZ2UtcGF5bG9hZCcsXG4gIElOVkFMSURfTUZBX1NFU1NJT04gPSAnaW52YWxpZC1tdWx0aS1mYWN0b3Itc2Vzc2lvbicsXG4gIElOVkFMSURfT0FVVEhfQ0xJRU5UX0lEID0gJ2ludmFsaWQtb2F1dGgtY2xpZW50LWlkJyxcbiAgSU5WQUxJRF9PQVVUSF9QUk9WSURFUiA9ICdpbnZhbGlkLW9hdXRoLXByb3ZpZGVyJyxcbiAgSU5WQUxJRF9PT0JfQ09ERSA9ICdpbnZhbGlkLWFjdGlvbi1jb2RlJyxcbiAgSU5WQUxJRF9PUklHSU4gPSAndW5hdXRob3JpemVkLWRvbWFpbicsXG4gIElOVkFMSURfUEFTU1dPUkQgPSAnd3JvbmctcGFzc3dvcmQnLFxuICBJTlZBTElEX1BFUlNJU1RFTkNFID0gJ2ludmFsaWQtcGVyc2lzdGVuY2UtdHlwZScsXG4gIElOVkFMSURfUEhPTkVfTlVNQkVSID0gJ2ludmFsaWQtcGhvbmUtbnVtYmVyJyxcbiAgSU5WQUxJRF9QUk9WSURFUl9JRCA9ICdpbnZhbGlkLXByb3ZpZGVyLWlkJyxcbiAgSU5WQUxJRF9SRUNJUElFTlRfRU1BSUwgPSAnaW52YWxpZC1yZWNpcGllbnQtZW1haWwnLFxuICBJTlZBTElEX1NFTkRFUiA9ICdpbnZhbGlkLXNlbmRlcicsXG4gIElOVkFMSURfU0VTU0lPTl9JTkZPID0gJ2ludmFsaWQtdmVyaWZpY2F0aW9uLWlkJyxcbiAgSU5WQUxJRF9URU5BTlRfSUQgPSAnaW52YWxpZC10ZW5hbnQtaWQnLFxuICBMT0dJTl9CTE9DS0VEID0gJ2xvZ2luLWJsb2NrZWQnLFxuICBNRkFfSU5GT19OT1RfRk9VTkQgPSAnbXVsdGktZmFjdG9yLWluZm8tbm90LWZvdW5kJyxcbiAgTUZBX1JFUVVJUkVEID0gJ211bHRpLWZhY3Rvci1hdXRoLXJlcXVpcmVkJyxcbiAgTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSA9ICdtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWUnLFxuICBNSVNTSU5HX0FQUF9DUkVERU5USUFMID0gJ21pc3NpbmctYXBwLWNyZWRlbnRpYWwnLFxuICBNSVNTSU5HX0FVVEhfRE9NQUlOID0gJ2F1dGgtZG9tYWluLWNvbmZpZy1yZXF1aXJlZCcsXG4gIE1JU1NJTkdfQ09ERSA9ICdtaXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlJyxcbiAgTUlTU0lOR19DT05USU5VRV9VUkkgPSAnbWlzc2luZy1jb250aW51ZS11cmknLFxuICBNSVNTSU5HX0lGUkFNRV9TVEFSVCA9ICdtaXNzaW5nLWlmcmFtZS1zdGFydCcsXG4gIE1JU1NJTkdfSU9TX0JVTkRMRV9JRCA9ICdtaXNzaW5nLWlvcy1idW5kbGUtaWQnLFxuICBNSVNTSU5HX09SX0lOVkFMSURfTk9OQ0UgPSAnbWlzc2luZy1vci1pbnZhbGlkLW5vbmNlJyxcbiAgTUlTU0lOR19NRkFfSU5GTyA9ICdtaXNzaW5nLW11bHRpLWZhY3Rvci1pbmZvJyxcbiAgTUlTU0lOR19NRkFfU0VTU0lPTiA9ICdtaXNzaW5nLW11bHRpLWZhY3Rvci1zZXNzaW9uJyxcbiAgTUlTU0lOR19QSE9ORV9OVU1CRVIgPSAnbWlzc2luZy1waG9uZS1udW1iZXInLFxuICBNSVNTSU5HX1BBU1NXT1JEID0gJ21pc3NpbmctcGFzc3dvcmQnLFxuICBNSVNTSU5HX1NFU1NJT05fSU5GTyA9ICdtaXNzaW5nLXZlcmlmaWNhdGlvbi1pZCcsXG4gIE1PRFVMRV9ERVNUUk9ZRUQgPSAnYXBwLWRlbGV0ZWQnLFxuICBORUVEX0NPTkZJUk1BVElPTiA9ICdhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsJyxcbiAgTkVUV09SS19SRVFVRVNUX0ZBSUxFRCA9ICduZXR3b3JrLXJlcXVlc3QtZmFpbGVkJyxcbiAgTlVMTF9VU0VSID0gJ251bGwtdXNlcicsXG4gIE5PX0FVVEhfRVZFTlQgPSAnbm8tYXV0aC1ldmVudCcsXG4gIE5PX1NVQ0hfUFJPVklERVIgPSAnbm8tc3VjaC1wcm92aWRlcicsXG4gIE9QRVJBVElPTl9OT1RfQUxMT1dFRCA9ICdvcGVyYXRpb24tbm90LWFsbG93ZWQnLFxuICBPUEVSQVRJT05fTk9UX1NVUFBPUlRFRCA9ICdvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50JyxcbiAgUE9QVVBfQkxPQ0tFRCA9ICdwb3B1cC1ibG9ja2VkJyxcbiAgUE9QVVBfQ0xPU0VEX0JZX1VTRVIgPSAncG9wdXAtY2xvc2VkLWJ5LXVzZXInLFxuICBQUk9WSURFUl9BTFJFQURZX0xJTktFRCA9ICdwcm92aWRlci1hbHJlYWR5LWxpbmtlZCcsXG4gIFFVT1RBX0VYQ0VFREVEID0gJ3F1b3RhLWV4Y2VlZGVkJyxcbiAgUkVESVJFQ1RfQ0FOQ0VMTEVEX0JZX1VTRVIgPSAncmVkaXJlY3QtY2FuY2VsbGVkLWJ5LXVzZXInLFxuICBSRURJUkVDVF9PUEVSQVRJT05fUEVORElORyA9ICdyZWRpcmVjdC1vcGVyYXRpb24tcGVuZGluZycsXG4gIFJFSkVDVEVEX0NSRURFTlRJQUwgPSAncmVqZWN0ZWQtY3JlZGVudGlhbCcsXG4gIFNFQ09ORF9GQUNUT1JfQUxSRUFEWV9FTlJPTExFRCA9ICdzZWNvbmQtZmFjdG9yLWFscmVhZHktaW4tdXNlJyxcbiAgU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCA9ICdtYXhpbXVtLXNlY29uZC1mYWN0b3ItY291bnQtZXhjZWVkZWQnLFxuICBURU5BTlRfSURfTUlTTUFUQ0ggPSAndGVuYW50LWlkLW1pc21hdGNoJyxcbiAgVElNRU9VVCA9ICd0aW1lb3V0JyxcbiAgVE9LRU5fRVhQSVJFRCA9ICd1c2VyLXRva2VuLWV4cGlyZWQnLFxuICBUT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVIgPSAndG9vLW1hbnktcmVxdWVzdHMnLFxuICBVTkFVVEhPUklaRURfRE9NQUlOID0gJ3VuYXV0aG9yaXplZC1jb250aW51ZS11cmknLFxuICBVTlNVUFBPUlRFRF9GSVJTVF9GQUNUT1IgPSAndW5zdXBwb3J0ZWQtZmlyc3QtZmFjdG9yJyxcbiAgVU5TVVBQT1JURURfUEVSU0lTVEVOQ0UgPSAndW5zdXBwb3J0ZWQtcGVyc2lzdGVuY2UtdHlwZScsXG4gIFVOU1VQUE9SVEVEX1RFTkFOVF9PUEVSQVRJT04gPSAndW5zdXBwb3J0ZWQtdGVuYW50LW9wZXJhdGlvbicsXG4gIFVOVkVSSUZJRURfRU1BSUwgPSAndW52ZXJpZmllZC1lbWFpbCcsXG4gIFVTRVJfQ0FOQ0VMTEVEID0gJ3VzZXItY2FuY2VsbGVkJyxcbiAgVVNFUl9ERUxFVEVEID0gJ3VzZXItbm90LWZvdW5kJyxcbiAgVVNFUl9ESVNBQkxFRCA9ICd1c2VyLWRpc2FibGVkJyxcbiAgVVNFUl9NSVNNQVRDSCA9ICd1c2VyLW1pc21hdGNoJyxcbiAgVVNFUl9TSUdORURfT1VUID0gJ3VzZXItc2lnbmVkLW91dCcsXG4gIFdFQUtfUEFTU1dPUkQgPSAnd2Vhay1wYXNzd29yZCcsXG4gIFdFQl9TVE9SQUdFX1VOU1VQUE9SVEVEID0gJ3dlYi1zdG9yYWdlLXVuc3VwcG9ydGVkJyxcbiAgQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdhbHJlYWR5LWluaXRpYWxpemVkJyxcbiAgUkVDQVBUQ0hBX05PVF9FTkFCTEVEID0gJ3JlY2FwdGNoYS1ub3QtZW5hYmxlZCcsXG4gIE1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOID0gJ21pc3NpbmctcmVjYXB0Y2hhLXRva2VuJyxcbiAgSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4gPSAnaW52YWxpZC1yZWNhcHRjaGEtdG9rZW4nLFxuICBJTlZBTElEX1JFQ0FQVENIQV9BQ1RJT04gPSAnaW52YWxpZC1yZWNhcHRjaGEtYWN0aW9uJyxcbiAgTUlTU0lOR19DTElFTlRfVFlQRSA9ICdtaXNzaW5nLWNsaWVudC10eXBlJyxcbiAgTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTiA9ICdtaXNzaW5nLXJlY2FwdGNoYS12ZXJzaW9uJyxcbiAgSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTiA9ICdpbnZhbGlkLXJlY2FwdGNoYS12ZXJzaW9uJyxcbiAgSU5WQUxJRF9SRVFfVFlQRSA9ICdpbnZhbGlkLXJlcS10eXBlJ1xufVxuXG5mdW5jdGlvbiBfZGVidWdFcnJvck1hcCgpOiBFcnJvck1hcDxBdXRoRXJyb3JDb2RlPiB7XG4gIHJldHVybiB7XG4gICAgW0F1dGhFcnJvckNvZGUuQURNSU5fT05MWV9PUEVSQVRJT05dOlxuICAgICAgJ1RoaXMgb3BlcmF0aW9uIGlzIHJlc3RyaWN0ZWQgdG8gYWRtaW5pc3RyYXRvcnMgb25seS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SXTogJycsXG4gICAgW0F1dGhFcnJvckNvZGUuQVBQX05PVF9BVVRIT1JJWkVEXTpcbiAgICAgIFwiVGhpcyBhcHAsIGlkZW50aWZpZWQgYnkgdGhlIGRvbWFpbiB3aGVyZSBpdCdzIGhvc3RlZCwgaXMgbm90IFwiICtcbiAgICAgICdhdXRob3JpemVkIHRvIHVzZSBGaXJlYmFzZSBBdXRoZW50aWNhdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBBUEkga2V5LiAnICtcbiAgICAgICdSZXZpZXcgeW91ciBrZXkgY29uZmlndXJhdGlvbiBpbiB0aGUgR29vZ2xlIEFQSSBjb25zb2xlLicsXG4gICAgW0F1dGhFcnJvckNvZGUuQVBQX05PVF9JTlNUQUxMRURdOlxuICAgICAgJ1RoZSByZXF1ZXN0ZWQgbW9iaWxlIGFwcGxpY2F0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGlkZW50aWZpZXIgKCcgK1xuICAgICAgJ0FuZHJvaWQgcGFja2FnZSBuYW1lIG9yIGlPUyBidW5kbGUgSUQpIHByb3ZpZGVkIGlzIG5vdCBpbnN0YWxsZWQgb24gJyArXG4gICAgICAndGhpcyBkZXZpY2UuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5DQVBUQ0hBX0NIRUNLX0ZBSUxFRF06XG4gICAgICAnVGhlIHJlQ0FQVENIQSByZXNwb25zZSB0b2tlbiBwcm92aWRlZCBpcyBlaXRoZXIgaW52YWxpZCwgZXhwaXJlZCwgJyArXG4gICAgICAnYWxyZWFkeSB1c2VkIG9yIHRoZSBkb21haW4gYXNzb2NpYXRlZCB3aXRoIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBsaXN0ICcgK1xuICAgICAgJ29mIHdoaXRlbGlzdGVkIGRvbWFpbnMuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5DT0RFX0VYUElSRURdOlxuICAgICAgJ1RoZSBTTVMgY29kZSBoYXMgZXhwaXJlZC4gUGxlYXNlIHJlLXNlbmQgdGhlIHZlcmlmaWNhdGlvbiBjb2RlIHRvIHRyeSAnICtcbiAgICAgICdhZ2Fpbi4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkNPUkRPVkFfTk9UX1JFQURZXTogJ0NvcmRvdmEgZnJhbWV3b3JrIGlzIG5vdCByZWFkeS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkNPUlNfVU5TVVBQT1JURURdOiAnVGhpcyBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFXTpcbiAgICAgICdUaGlzIGNyZWRlbnRpYWwgaXMgYWxyZWFkeSBhc3NvY2lhdGVkIHdpdGggYSBkaWZmZXJlbnQgdXNlciBhY2NvdW50LicsXG4gICAgW0F1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9NSVNNQVRDSF06XG4gICAgICAnVGhlIGN1c3RvbSB0b2tlbiBjb3JyZXNwb25kcyB0byBhIGRpZmZlcmVudCBhdWRpZW5jZS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTl06XG4gICAgICAnVGhpcyBvcGVyYXRpb24gaXMgc2Vuc2l0aXZlIGFuZCByZXF1aXJlcyByZWNlbnQgYXV0aGVudGljYXRpb24uIExvZyBpbiAnICtcbiAgICAgICdhZ2FpbiBiZWZvcmUgcmV0cnlpbmcgdGhpcyByZXF1ZXN0LicsXG4gICAgW0F1dGhFcnJvckNvZGUuREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIXTpcbiAgICAgICdBbm90aGVyIEZpcmViYXNlIFNESyB3YXMgaW5pdGlhbGl6ZWQgYW5kIGlzIHRyeWluZyB0byB1c2UgQXV0aCBiZWZvcmUgQXV0aCBpcyAnICtcbiAgICAgICdpbml0aWFsaXplZC4gUGxlYXNlIGJlIHN1cmUgdG8gY2FsbCBgaW5pdGlhbGl6ZUF1dGhgIG9yIGBnZXRBdXRoYCBiZWZvcmUgJyArXG4gICAgICAnc3RhcnRpbmcgYW55IG90aGVyIEZpcmViYXNlIFNESy4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkRZTkFNSUNfTElOS19OT1RfQUNUSVZBVEVEXTpcbiAgICAgICdQbGVhc2UgYWN0aXZhdGUgRHluYW1pYyBMaW5rcyBpbiB0aGUgRmlyZWJhc2UgQ29uc29sZSBhbmQgYWdyZWUgdG8gdGhlIHRlcm1zIGFuZCAnICtcbiAgICAgICdjb25kaXRpb25zLicsXG4gICAgW0F1dGhFcnJvckNvZGUuRU1BSUxfQ0hBTkdFX05FRURTX1ZFUklGSUNBVElPTl06XG4gICAgICAnTXVsdGktZmFjdG9yIHVzZXJzIG11c3QgYWx3YXlzIGhhdmUgYSB2ZXJpZmllZCBlbWFpbC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkVNQUlMX0VYSVNUU106XG4gICAgICAnVGhlIGVtYWlsIGFkZHJlc3MgaXMgYWxyZWFkeSBpbiB1c2UgYnkgYW5vdGhlciBhY2NvdW50LicsXG4gICAgW0F1dGhFcnJvckNvZGUuRU1VTEFUT1JfQ09ORklHX0ZBSUxFRF06XG4gICAgICAnQXV0aCBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgdG8gbWFrZSBhIG5ldHdvcmsgY2FsbC4gQXV0aCBjYW4gJyArXG4gICAgICAnbm8gbG9uZ2VyIGJlIGNvbmZpZ3VyZWQgdG8gdXNlIHRoZSBlbXVsYXRvci4gVHJ5IGNhbGxpbmcgJyArXG4gICAgICAnXCJjb25uZWN0QXV0aEVtdWxhdG9yKClcIiBzb29uZXIuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5FWFBJUkVEX09PQl9DT0RFXTogJ1RoZSBhY3Rpb24gY29kZSBoYXMgZXhwaXJlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkVYUElSRURfUE9QVVBfUkVRVUVTVF06XG4gICAgICAnVGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gY2FuY2VsbGVkIGR1ZSB0byBhbm90aGVyIGNvbmZsaWN0aW5nIHBvcHVwIGJlaW5nIG9wZW5lZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9DUkVERU5USUFMXTpcbiAgICAgICdUaGUgcGhvbmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgY29udGFpbnMgYW4gaW52YWxpZCBhcHBsaWNhdGlvbiB2ZXJpZmllci4nICtcbiAgICAgICcgVGhlIHJlQ0FQVENIQSB0b2tlbiByZXNwb25zZSBpcyBlaXRoZXIgaW52YWxpZCBvciBleHBpcmVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9BUFBfSURdOlxuICAgICAgJ1RoZSBtb2JpbGUgYXBwIGlkZW50aWZpZXIgaXMgbm90IHJlZ2lzdGVkIGZvciB0aGUgY3VycmVudCBwcm9qZWN0LicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIXTpcbiAgICAgIFwiVGhpcyB1c2VyJ3MgY3JlZGVudGlhbCBpc24ndCB2YWxpZCBmb3IgdGhpcyBwcm9qZWN0LiBUaGlzIGNhbiBoYXBwZW4gXCIgK1xuICAgICAgXCJpZiB0aGUgdXNlcidzIHRva2VuIGhhcyBiZWVuIHRhbXBlcmVkIHdpdGgsIG9yIGlmIHRoZSB1c2VyIGlzbid0IGZvciBcIiArXG4gICAgICAndGhlIHByb2plY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVBJIGtleS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSF9FVkVOVF06ICdBbiBpbnRlcm5hbCBBdXRoRXJyb3IgaGFzIG9jY3VycmVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9DT0RFXTpcbiAgICAgICdUaGUgU01TIHZlcmlmaWNhdGlvbiBjb2RlIHVzZWQgdG8gY3JlYXRlIHRoZSBwaG9uZSBhdXRoIGNyZWRlbnRpYWwgaXMgJyArXG4gICAgICAnaW52YWxpZC4gUGxlYXNlIHJlc2VuZCB0aGUgdmVyaWZpY2F0aW9uIGNvZGUgc21zIGFuZCBiZSBzdXJlIHRvIHVzZSB0aGUgJyArXG4gICAgICAndmVyaWZpY2F0aW9uIGNvZGUgcHJvdmlkZWQgYnkgdGhlIHVzZXIuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPTlRJTlVFX1VSSV06XG4gICAgICAnVGhlIGNvbnRpbnVlIFVSTCBwcm92aWRlZCBpbiB0aGUgcmVxdWVzdCBpcyBpbnZhbGlkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT05dOlxuICAgICAgJ1RoZSBmb2xsb3dpbmcgQ29yZG92YSBwbHVnaW5zIG11c3QgYmUgaW5zdGFsbGVkIHRvIGVuYWJsZSBPQXV0aCBzaWduLWluOiAnICtcbiAgICAgICdjb3Jkb3ZhLXBsdWdpbi1idWlsZGluZm8sIGNvcmRvdmEtdW5pdmVyc2FsLWxpbmtzLXBsdWdpbiwgJyArXG4gICAgICAnY29yZG92YS1wbHVnaW4tYnJvd3NlcnRhYiwgY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyIGFuZCAnICtcbiAgICAgICdjb3Jkb3ZhLXBsdWdpbi1jdXN0b211cmxzY2hlbWUuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX0NVU1RPTV9UT0tFTl06XG4gICAgICAnVGhlIGN1c3RvbSB0b2tlbiBmb3JtYXQgaXMgaW5jb3JyZWN0LiBQbGVhc2UgY2hlY2sgdGhlIGRvY3VtZW50YXRpb24uJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX0RZTkFNSUNfTElOS19ET01BSU5dOlxuICAgICAgJ1RoZSBwcm92aWRlZCBkeW5hbWljIGxpbmsgZG9tYWluIGlzIG5vdCBjb25maWd1cmVkIG9yIGF1dGhvcml6ZWQgZm9yIHRoZSBjdXJyZW50IHByb2plY3QuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNQUlMXTogJ1RoZSBlbWFpbCBhZGRyZXNzIGlzIGJhZGx5IGZvcm1hdHRlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1VTEFUT1JfU0NIRU1FXTpcbiAgICAgICdFbXVsYXRvciBVUkwgbXVzdCBzdGFydCB3aXRoIGEgdmFsaWQgc2NoZW1lIChodHRwOi8vIG9yIGh0dHBzOi8vKS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBJX0tFWV06XG4gICAgICAnWW91ciBBUEkga2V5IGlzIGludmFsaWQsIHBsZWFzZSBjaGVjayB5b3UgaGF2ZSBjb3BpZWQgaXQgY29ycmVjdGx5LicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9DRVJUX0hBU0hdOlxuICAgICAgJ1RoZSBTSEEtMSBjZXJ0aWZpY2F0ZSBoYXNoIHByb3ZpZGVkIGlzIGludmFsaWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX0lEUF9SRVNQT05TRV06XG4gICAgICAnVGhlIHN1cHBsaWVkIGF1dGggY3JlZGVudGlhbCBpcyBtYWxmb3JtZWQgb3IgaGFzIGV4cGlyZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0VfUEFZTE9BRF06XG4gICAgICAnVGhlIGVtYWlsIHRlbXBsYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3Rpb24gY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIGluIGl0cyBtZXNzYWdlLiAnICtcbiAgICAgICdQbGVhc2UgZml4IGJ5IGdvaW5nIHRvIHRoZSBBdXRoIGVtYWlsIHRlbXBsYXRlcyBzZWN0aW9uIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9NRkFfU0VTU0lPTl06XG4gICAgICAnVGhlIHJlcXVlc3QgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIHByb29mIG9mIGZpcnN0IGZhY3RvciBzdWNjZXNzZnVsIHNpZ24taW4uJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX09BVVRIX1BST1ZJREVSXTpcbiAgICAgICdFbWFpbEF1dGhQcm92aWRlciBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIG9wZXJhdGlvbi4gVGhpcyBvcGVyYXRpb24gJyArXG4gICAgICAnb25seSBzdXBwb3J0cyBPQXV0aCBwcm92aWRlcnMuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX09BVVRIX0NMSUVOVF9JRF06XG4gICAgICAnVGhlIE9BdXRoIGNsaWVudCBJRCBwcm92aWRlZCBpcyBlaXRoZXIgaW52YWxpZCBvciBkb2VzIG5vdCBtYXRjaCB0aGUgJyArXG4gICAgICAnc3BlY2lmaWVkIEFQSSBrZXkuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX09SSUdJTl06XG4gICAgICAnVGhpcyBkb21haW4gaXMgbm90IGF1dGhvcml6ZWQgZm9yIE9BdXRoIG9wZXJhdGlvbnMgZm9yIHlvdXIgRmlyZWJhc2UgJyArXG4gICAgICAncHJvamVjdC4gRWRpdCB0aGUgbGlzdCBvZiBhdXRob3JpemVkIGRvbWFpbnMgZnJvbSB0aGUgRmlyZWJhc2UgY29uc29sZS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfT09CX0NPREVdOlxuICAgICAgJ1RoZSBhY3Rpb24gY29kZSBpcyBpbnZhbGlkLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGNvZGUgaXMgbWFsZm9ybWVkLCAnICtcbiAgICAgICdleHBpcmVkLCBvciBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX1BBU1NXT1JEXTpcbiAgICAgICdUaGUgcGFzc3dvcmQgaXMgaW52YWxpZCBvciB0aGUgdXNlciBkb2VzIG5vdCBoYXZlIGEgcGFzc3dvcmQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX1BFUlNJU1RFTkNFXTpcbiAgICAgICdUaGUgc3BlY2lmaWVkIHBlcnNpc3RlbmNlIHR5cGUgaXMgaW52YWxpZC4gSXQgY2FuIG9ubHkgYmUgbG9jYWwsIHNlc3Npb24gb3Igbm9uZS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfUEhPTkVfTlVNQkVSXTpcbiAgICAgICdUaGUgZm9ybWF0IG9mIHRoZSBwaG9uZSBudW1iZXIgcHJvdmlkZWQgaXMgaW5jb3JyZWN0LiBQbGVhc2UgZW50ZXIgdGhlICcgK1xuICAgICAgJ3Bob25lIG51bWJlciBpbiBhIGZvcm1hdCB0aGF0IGNhbiBiZSBwYXJzZWQgaW50byBFLjE2NCBmb3JtYXQuIEUuMTY0ICcgK1xuICAgICAgJ3Bob25lIG51bWJlcnMgYXJlIHdyaXR0ZW4gaW4gdGhlIGZvcm1hdCBbK11bY291bnRyeSBjb2RlXVtzdWJzY3JpYmVyICcgK1xuICAgICAgJ251bWJlciBpbmNsdWRpbmcgYXJlYSBjb2RlXS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfUFJPVklERVJfSURdOlxuICAgICAgJ1RoZSBzcGVjaWZpZWQgcHJvdmlkZXIgSUQgaXMgaW52YWxpZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDSVBJRU5UX0VNQUlMXTpcbiAgICAgICdUaGUgZW1haWwgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBmYWlsZWQgdG8gc2VuZCBhcyB0aGUgcHJvdmlkZWQgJyArXG4gICAgICAncmVjaXBpZW50IGVtYWlsIGFkZHJlc3MgaXMgaW52YWxpZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfU0VOREVSXTpcbiAgICAgICdUaGUgZW1haWwgdGVtcGxhdGUgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBjb250YWlucyBhbiBpbnZhbGlkIHNlbmRlciBlbWFpbCBvciBuYW1lLiAnICtcbiAgICAgICdQbGVhc2UgZml4IGJ5IGdvaW5nIHRvIHRoZSBBdXRoIGVtYWlsIHRlbXBsYXRlcyBzZWN0aW9uIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9TRVNTSU9OX0lORk9dOlxuICAgICAgJ1RoZSB2ZXJpZmljYXRpb24gSUQgdXNlZCB0byBjcmVhdGUgdGhlIHBob25lIGF1dGggY3JlZGVudGlhbCBpcyBpbnZhbGlkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9URU5BTlRfSURdOlxuICAgICAgXCJUaGUgQXV0aCBpbnN0YW5jZSdzIHRlbmFudCBJRCBpcyBpbnZhbGlkLlwiLFxuICAgIFtBdXRoRXJyb3JDb2RlLkxPR0lOX0JMT0NLRURdOlxuICAgICAgJ0xvZ2luIGJsb2NrZWQgYnkgdXNlci1wcm92aWRlZCBtZXRob2Q6IHskb3JpZ2luYWxNZXNzYWdlfScsXG4gICAgW0F1dGhFcnJvckNvZGUuTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRV06XG4gICAgICAnQW4gQW5kcm9pZCBQYWNrYWdlIE5hbWUgbXVzdCBiZSBwcm92aWRlZCBpZiB0aGUgQW5kcm9pZCBBcHAgaXMgcmVxdWlyZWQgdG8gYmUgaW5zdGFsbGVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTUlTU0lOR19BVVRIX0RPTUFJTl06XG4gICAgICAnQmUgc3VyZSB0byBpbmNsdWRlIGF1dGhEb21haW4gd2hlbiBjYWxsaW5nIGZpcmViYXNlLmluaXRpYWxpemVBcHAoKSwgJyArXG4gICAgICAnYnkgZm9sbG93aW5nIHRoZSBpbnN0cnVjdGlvbnMgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FQUF9DUkVERU5USUFMXTpcbiAgICAgICdUaGUgcGhvbmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgaXMgbWlzc2luZyBhbiBhcHBsaWNhdGlvbiB2ZXJpZmllciAnICtcbiAgICAgICdhc3NlcnRpb24uIEEgcmVDQVBUQ0hBIHJlc3BvbnNlIHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTUlTU0lOR19DT0RFXTpcbiAgICAgICdUaGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIHdhcyBjcmVhdGVkIHdpdGggYW4gZW1wdHkgU01TIHZlcmlmaWNhdGlvbiBjb2RlLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTUlTU0lOR19DT05USU5VRV9VUkldOlxuICAgICAgJ0EgY29udGludWUgVVJMIG11c3QgYmUgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX0lGUkFNRV9TVEFSVF06ICdBbiBpbnRlcm5hbCBBdXRoRXJyb3IgaGFzIG9jY3VycmVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTUlTU0lOR19JT1NfQlVORExFX0lEXTpcbiAgICAgICdBbiBpT1MgQnVuZGxlIElEIG11c3QgYmUgcHJvdmlkZWQgaWYgYW4gQXBwIFN0b3JlIElEIGlzIHByb3ZpZGVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTUlTU0lOR19PUl9JTlZBTElEX05PTkNFXTpcbiAgICAgICdUaGUgcmVxdWVzdCBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgbm9uY2UuIFRoaXMgY2FuIG9jY3VyIGlmIHRoZSAnICtcbiAgICAgICdTSEEtMjU2IGhhc2ggb2YgdGhlIHByb3ZpZGVkIHJhdyBub25jZSBkb2VzIG5vdCBtYXRjaCB0aGUgaGFzaGVkIG5vbmNlICcgK1xuICAgICAgJ2luIHRoZSBJRCB0b2tlbiBwYXlsb2FkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTUlTU0lOR19QQVNTV09SRF06ICdBIG5vbi1lbXB0eSBwYXNzd29yZCBtdXN0IGJlIHByb3ZpZGVkJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9JTkZPXTpcbiAgICAgICdObyBzZWNvbmQgZmFjdG9yIGlkZW50aWZpZXIgaXMgcHJvdmlkZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9TRVNTSU9OXTpcbiAgICAgICdUaGUgcmVxdWVzdCBpcyBtaXNzaW5nIHByb29mIG9mIGZpcnN0IGZhY3RvciBzdWNjZXNzZnVsIHNpZ24taW4uJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX1BIT05FX05VTUJFUl06XG4gICAgICAnVG8gc2VuZCB2ZXJpZmljYXRpb24gY29kZXMsIHByb3ZpZGUgYSBwaG9uZSBudW1iZXIgZm9yIHRoZSByZWNpcGllbnQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX1NFU1NJT05fSU5GT106XG4gICAgICAnVGhlIHBob25lIGF1dGggY3JlZGVudGlhbCB3YXMgY3JlYXRlZCB3aXRoIGFuIGVtcHR5IHZlcmlmaWNhdGlvbiBJRC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk1PRFVMRV9ERVNUUk9ZRURdOlxuICAgICAgJ1RoaXMgaW5zdGFuY2Ugb2YgRmlyZWJhc2VBcHAgaGFzIGJlZW4gZGVsZXRlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk1GQV9JTkZPX05PVF9GT1VORF06XG4gICAgICAnVGhlIHVzZXIgZG9lcyBub3QgaGF2ZSBhIHNlY29uZCBmYWN0b3IgbWF0Y2hpbmcgdGhlIGlkZW50aWZpZXIgcHJvdmlkZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRURdOlxuICAgICAgJ1Byb29mIG9mIG93bmVyc2hpcCBvZiBhIHNlY29uZCBmYWN0b3IgaXMgcmVxdWlyZWQgdG8gY29tcGxldGUgc2lnbi1pbi4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OXTpcbiAgICAgICdBbiBhY2NvdW50IGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIHNhbWUgZW1haWwgYWRkcmVzcyBidXQgZGlmZmVyZW50ICcgK1xuICAgICAgJ3NpZ24taW4gY3JlZGVudGlhbHMuIFNpZ24gaW4gdXNpbmcgYSBwcm92aWRlciBhc3NvY2lhdGVkIHdpdGggdGhpcyAnICtcbiAgICAgICdlbWFpbCBhZGRyZXNzLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRF06XG4gICAgICAnQSBuZXR3b3JrIEF1dGhFcnJvciAoc3VjaCBhcyB0aW1lb3V0LCBpbnRlcnJ1cHRlZCBjb25uZWN0aW9uIG9yIHVucmVhY2hhYmxlIGhvc3QpIGhhcyBvY2N1cnJlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk5PX0FVVEhfRVZFTlRdOiAnQW4gaW50ZXJuYWwgQXV0aEVycm9yIGhhcyBvY2N1cnJlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk5PX1NVQ0hfUFJPVklERVJdOlxuICAgICAgJ1VzZXIgd2FzIG5vdCBsaW5rZWQgdG8gYW4gYWNjb3VudCB3aXRoIHRoZSBnaXZlbiBwcm92aWRlci4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk5VTExfVVNFUl06XG4gICAgICAnQSBudWxsIHVzZXIgb2JqZWN0IHdhcyBwcm92aWRlZCBhcyB0aGUgYXJndW1lbnQgZm9yIGFuIG9wZXJhdGlvbiB3aGljaCAnICtcbiAgICAgICdyZXF1aXJlcyBhIG5vbi1udWxsIHVzZXIgb2JqZWN0LicsXG4gICAgW0F1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9BTExPV0VEXTpcbiAgICAgICdUaGUgZ2l2ZW4gc2lnbi1pbiBwcm92aWRlciBpcyBkaXNhYmxlZCBmb3IgdGhpcyBGaXJlYmFzZSBwcm9qZWN0LiAnICtcbiAgICAgICdFbmFibGUgaXQgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUsIHVuZGVyIHRoZSBzaWduLWluIG1ldGhvZCB0YWIgb2YgdGhlICcgK1xuICAgICAgJ0F1dGggc2VjdGlvbi4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEXTpcbiAgICAgICdUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBlbnZpcm9ubWVudCB0aGlzIGFwcGxpY2F0aW9uIGlzICcgK1xuICAgICAgJ3J1bm5pbmcgb24uIFwibG9jYXRpb24ucHJvdG9jb2xcIiBtdXN0IGJlIGh0dHAsIGh0dHBzIG9yIGNocm9tZS1leHRlbnNpb24nICtcbiAgICAgICcgYW5kIHdlYiBzdG9yYWdlIG11c3QgYmUgZW5hYmxlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLlBPUFVQX0JMT0NLRURdOlxuICAgICAgJ1VuYWJsZSB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHBvcHVwLiBJdCBtYXkgaGF2ZSBiZWVuIGJsb2NrZWQgYnkgdGhlIGJyb3dzZXIuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5QT1BVUF9DTE9TRURfQllfVVNFUl06XG4gICAgICAnVGhlIHBvcHVwIGhhcyBiZWVuIGNsb3NlZCBieSB0aGUgdXNlciBiZWZvcmUgZmluYWxpemluZyB0aGUgb3BlcmF0aW9uLicsXG4gICAgW0F1dGhFcnJvckNvZGUuUFJPVklERVJfQUxSRUFEWV9MSU5LRURdOlxuICAgICAgJ1VzZXIgY2FuIG9ubHkgYmUgbGlua2VkIHRvIG9uZSBpZGVudGl0eSBmb3IgdGhlIGdpdmVuIHByb3ZpZGVyLicsXG4gICAgW0F1dGhFcnJvckNvZGUuUVVPVEFfRVhDRUVERURdOlxuICAgICAgXCJUaGUgcHJvamVjdCdzIHF1b3RhIGZvciB0aGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBleGNlZWRlZC5cIixcbiAgICBbQXV0aEVycm9yQ29kZS5SRURJUkVDVF9DQU5DRUxMRURfQllfVVNFUl06XG4gICAgICAnVGhlIHJlZGlyZWN0IG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgYnkgdGhlIHVzZXIgYmVmb3JlIGZpbmFsaXppbmcuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5SRURJUkVDVF9PUEVSQVRJT05fUEVORElOR106XG4gICAgICAnQSByZWRpcmVjdCBzaWduLWluIG9wZXJhdGlvbiBpcyBhbHJlYWR5IHBlbmRpbmcuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5SRUpFQ1RFRF9DUkVERU5USUFMXTpcbiAgICAgICdUaGUgcmVxdWVzdCBjb250YWlucyBtYWxmb3JtZWQgb3IgbWlzbWF0Y2hpbmcgY3JlZGVudGlhbHMuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0FMUkVBRFlfRU5ST0xMRURdOlxuICAgICAgJ1RoZSBzZWNvbmQgZmFjdG9yIGlzIGFscmVhZHkgZW5yb2xsZWQgb24gdGhpcyBhY2NvdW50LicsXG4gICAgW0F1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRF06XG4gICAgICAnVGhlIG1heGltdW0gYWxsb3dlZCBudW1iZXIgb2Ygc2Vjb25kIGZhY3RvcnMgb24gYSB1c2VyIGhhcyBiZWVuIGV4Y2VlZGVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuVEVOQU5UX0lEX01JU01BVENIXTpcbiAgICAgIFwiVGhlIHByb3ZpZGVkIHRlbmFudCBJRCBkb2VzIG5vdCBtYXRjaCB0aGUgQXV0aCBpbnN0YW5jZSdzIHRlbmFudCBJRFwiLFxuICAgIFtBdXRoRXJyb3JDb2RlLlRJTUVPVVRdOiAnVGhlIG9wZXJhdGlvbiBoYXMgdGltZWQgb3V0LicsXG4gICAgW0F1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRF06XG4gICAgICBcIlRoZSB1c2VyJ3MgY3JlZGVudGlhbCBpcyBubyBsb25nZXIgdmFsaWQuIFRoZSB1c2VyIG11c3Qgc2lnbiBpbiBhZ2Fpbi5cIixcbiAgICBbQXV0aEVycm9yQ29kZS5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVJdOlxuICAgICAgJ1dlIGhhdmUgYmxvY2tlZCBhbGwgcmVxdWVzdHMgZnJvbSB0aGlzIGRldmljZSBkdWUgdG8gdW51c3VhbCBhY3Rpdml0eS4gJyArXG4gICAgICAnVHJ5IGFnYWluIGxhdGVyLicsXG4gICAgW0F1dGhFcnJvckNvZGUuVU5BVVRIT1JJWkVEX0RPTUFJTl06XG4gICAgICAnVGhlIGRvbWFpbiBvZiB0aGUgY29udGludWUgVVJMIGlzIG5vdCB3aGl0ZWxpc3RlZC4gIFBsZWFzZSB3aGl0ZWxpc3QgJyArXG4gICAgICAndGhlIGRvbWFpbiBpbiB0aGUgRmlyZWJhc2UgY29uc29sZS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX0ZJUlNUX0ZBQ1RPUl06XG4gICAgICAnRW5yb2xsaW5nIGEgc2Vjb25kIGZhY3RvciBvciBzaWduaW5nIGluIHdpdGggYSBtdWx0aS1mYWN0b3IgYWNjb3VudCByZXF1aXJlcyBzaWduLWluIHdpdGggYSBzdXBwb3J0ZWQgZmlyc3QgZmFjdG9yLicsXG4gICAgW0F1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfUEVSU0lTVEVOQ0VdOlxuICAgICAgJ1RoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgdGhlIHNwZWNpZmllZCBwZXJzaXN0ZW5jZSB0eXBlLicsXG4gICAgW0F1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTl06XG4gICAgICAnVGhpcyBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiBhIG11bHRpLXRlbmFudCBjb250ZXh0LicsXG4gICAgW0F1dGhFcnJvckNvZGUuVU5WRVJJRklFRF9FTUFJTF06XG4gICAgICAnVGhlIG9wZXJhdGlvbiByZXF1aXJlcyBhIHZlcmlmaWVkIGVtYWlsLicsXG4gICAgW0F1dGhFcnJvckNvZGUuVVNFUl9DQU5DRUxMRURdOlxuICAgICAgJ1RoZSB1c2VyIGRpZCBub3QgZ3JhbnQgeW91ciBhcHBsaWNhdGlvbiB0aGUgcGVybWlzc2lvbnMgaXQgcmVxdWVzdGVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuVVNFUl9ERUxFVEVEXTpcbiAgICAgICdUaGVyZSBpcyBubyB1c2VyIHJlY29yZCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgaWRlbnRpZmllci4gVGhlIHVzZXIgbWF5ICcgK1xuICAgICAgJ2hhdmUgYmVlbiBkZWxldGVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuVVNFUl9ESVNBQkxFRF06XG4gICAgICAnVGhlIHVzZXIgYWNjb3VudCBoYXMgYmVlbiBkaXNhYmxlZCBieSBhbiBhZG1pbmlzdHJhdG9yLicsXG4gICAgW0F1dGhFcnJvckNvZGUuVVNFUl9NSVNNQVRDSF06XG4gICAgICAnVGhlIHN1cHBsaWVkIGNyZWRlbnRpYWxzIGRvIG5vdCBjb3JyZXNwb25kIHRvIHRoZSBwcmV2aW91c2x5IHNpZ25lZCBpbiB1c2VyLicsXG4gICAgW0F1dGhFcnJvckNvZGUuVVNFUl9TSUdORURfT1VUXTogJycsXG4gICAgW0F1dGhFcnJvckNvZGUuV0VBS19QQVNTV09SRF06XG4gICAgICAnVGhlIHBhc3N3b3JkIG11c3QgYmUgNiBjaGFyYWN0ZXJzIGxvbmcgb3IgbW9yZS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLldFQl9TVE9SQUdFX1VOU1VQUE9SVEVEXTpcbiAgICAgICdUaGlzIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZCBvciAzcmQgcGFydHkgY29va2llcyBhbmQgZGF0YSBtYXkgYmUgZGlzYWJsZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5BTFJFQURZX0lOSVRJQUxJWkVEXTpcbiAgICAgICdpbml0aWFsaXplQXV0aCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIHdpdGggJyArXG4gICAgICAnZGlmZmVyZW50IG9wdGlvbnMuIFRvIGF2b2lkIHRoaXMgZXJyb3IsIGNhbGwgaW5pdGlhbGl6ZUF1dGgoKSB3aXRoIHRoZSAnICtcbiAgICAgICdzYW1lIG9wdGlvbnMgYXMgd2hlbiBpdCB3YXMgb3JpZ2luYWxseSBjYWxsZWQsIG9yIGNhbGwgZ2V0QXV0aCgpIHRvIHJldHVybiB0aGUnICtcbiAgICAgICcgYWxyZWFkeSBpbml0aWFsaXplZCBpbnN0YW5jZS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOXTpcbiAgICAgICdUaGUgcmVDQVBUQ0hBIHRva2VuIGlzIG1pc3Npbmcgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9UT0tFTl06XG4gICAgICAnVGhlIHJlQ0FQVENIQSB0b2tlbiBpcyBpbnZhbGlkIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OXTpcbiAgICAgICdUaGUgcmVDQVBUQ0hBIGFjdGlvbiBpcyBpbnZhbGlkIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXG4gICAgW0F1dGhFcnJvckNvZGUuUkVDQVBUQ0hBX05PVF9FTkFCTEVEXTpcbiAgICAgICdyZUNBUFRDSEEgRW50ZXJwcmlzZSBpbnRlZ3JhdGlvbiBpcyBub3QgZW5hYmxlZCBmb3IgdGhpcyBwcm9qZWN0LicsXG4gICAgW0F1dGhFcnJvckNvZGUuTUlTU0lOR19DTElFTlRfVFlQRV06XG4gICAgICAnVGhlIHJlQ0FQVENIQSBjbGllbnQgdHlwZSBpcyBtaXNzaW5nIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTl06XG4gICAgICAnVGhlIHJlQ0FQVENIQSB2ZXJzaW9uIGlzIG1pc3Npbmcgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFUV9UWVBFXTogJ0ludmFsaWQgcmVxdWVzdCBwYXJhbWV0ZXJzLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTl06XG4gICAgICAnVGhlIHJlQ0FQVENIQSB2ZXJzaW9uIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJ1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yTWFwUmV0cmlldmVyIGV4dGVuZHMgQXV0aEVycm9yTWFwIHtcbiAgKCk6IEVycm9yTWFwPEF1dGhFcnJvckNvZGU+O1xufVxuXG5mdW5jdGlvbiBfcHJvZEVycm9yTWFwKCk6IEVycm9yTWFwPEF1dGhFcnJvckNvZGU+IHtcbiAgLy8gV2Ugd2lsbCBpbmNsdWRlIHRoaXMgb25lIG1lc3NhZ2UgaW4gdGhlIHByb2QgZXJyb3IgbWFwIHNpbmNlIGJ5IHRoZSB2ZXJ5XG4gIC8vIG5hdHVyZSBvZiB0aGlzIGVycm9yLCBkZXZlbG9wZXJzIHdpbGwgbmV2ZXIgYmUgYWJsZSB0byBzZWUgdGhlIG1lc3NhZ2VcbiAgLy8gdXNpbmcgdGhlIGRlYnVnRXJyb3JNYXAgKHdoaWNoIGlzIGluc3RhbGxlZCBkdXJpbmcgYXV0aCBpbml0aWFsaXphdGlvbikuXG4gIHJldHVybiB7XG4gICAgW0F1dGhFcnJvckNvZGUuREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIXTpcbiAgICAgICdBbm90aGVyIEZpcmViYXNlIFNESyB3YXMgaW5pdGlhbGl6ZWQgYW5kIGlzIHRyeWluZyB0byB1c2UgQXV0aCBiZWZvcmUgQXV0aCBpcyAnICtcbiAgICAgICdpbml0aWFsaXplZC4gUGxlYXNlIGJlIHN1cmUgdG8gY2FsbCBgaW5pdGlhbGl6ZUF1dGhgIG9yIGBnZXRBdXRoYCBiZWZvcmUgJyArXG4gICAgICAnc3RhcnRpbmcgYW55IG90aGVyIEZpcmViYXNlIFNESy4nXG4gIH0gYXMgRXJyb3JNYXA8QXV0aEVycm9yQ29kZT47XG59XG5cbi8qKlxuICogQSB2ZXJib3NlIGVycm9yIG1hcCB3aXRoIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgbW9zdCBlcnJvciBjb2Rlcy5cbiAqXG4gKiBTZWUgZGlzY3Vzc2lvbiBhdCB7QGxpbmsgQXV0aEVycm9yTWFwfVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGRlYnVnRXJyb3JNYXA6IEF1dGhFcnJvck1hcCA9IF9kZWJ1Z0Vycm9yTWFwO1xuXG4vKipcbiAqIEEgbWluaW1hbCBlcnJvciBtYXAgd2l0aCBhbGwgdmVyYm9zZSBlcnJvciBtZXNzYWdlcyBzdHJpcHBlZC5cbiAqXG4gKiBTZWUgZGlzY3Vzc2lvbiBhdCB7QGxpbmsgQXV0aEVycm9yTWFwfVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHByb2RFcnJvck1hcDogQXV0aEVycm9yTWFwID0gX3Byb2RFcnJvck1hcDtcblxuZXhwb3J0IGludGVyZmFjZSBOYW1lZEVycm9yUGFyYW1zIHtcbiAgYXBwTmFtZTogQXBwTmFtZTtcbiAgY3JlZGVudGlhbD86IEF1dGhDcmVkZW50aWFsO1xuICBlbWFpbD86IHN0cmluZztcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG4gIHRlbmFudElkPzogc3RyaW5nO1xuICB1c2VyPzogVXNlcjtcbiAgX3NlcnZlclJlc3BvbnNlPzogb2JqZWN0O1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG50eXBlIEdlbmVyaWNBdXRoRXJyb3JQYXJhbXMgPSB7XG4gIFtrZXkgaW4gRXhjbHVkZTxcbiAgICBBdXRoRXJyb3JDb2RlLFxuICAgIHwgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUlxuICAgIHwgQXV0aEVycm9yQ29kZS5ERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEhcbiAgICB8IEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1JcbiAgICB8IEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEXG4gICAgfCBBdXRoRXJyb3JDb2RlLk5PX0FVVEhfRVZFTlRcbiAgICB8IEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9TVVBQT1JURURcbiAgPl06IHtcbiAgICBhcHBOYW1lPzogQXBwTmFtZTtcbiAgICBlbWFpbD86IHN0cmluZztcbiAgICBwaG9uZU51bWJlcj86IHN0cmluZztcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICB9O1xufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdXRoRXJyb3JQYXJhbXMgZXh0ZW5kcyBHZW5lcmljQXV0aEVycm9yUGFyYW1zIHtcbiAgW0F1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1JdOiB7IGFwcE5hbWU/OiBBcHBOYW1lIH07XG4gIFtBdXRoRXJyb3JDb2RlLkRFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSF06IHsgYXBwTmFtZT86IEFwcE5hbWUgfTtcbiAgW0F1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1JdOiB7IGFwcE5hbWU/OiBBcHBOYW1lIH07XG4gIFtBdXRoRXJyb3JDb2RlLkxPR0lOX0JMT0NLRURdOiB7XG4gICAgYXBwTmFtZT86IEFwcE5hbWU7XG4gICAgb3JpZ2luYWxNZXNzYWdlPzogc3RyaW5nO1xuICB9O1xuICBbQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX1NVUFBPUlRFRF06IHsgYXBwTmFtZT86IEFwcE5hbWUgfTtcbiAgW0F1dGhFcnJvckNvZGUuTk9fQVVUSF9FVkVOVF06IHsgYXBwTmFtZT86IEFwcE5hbWUgfTtcbiAgW0F1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEXToge1xuICAgIGFwcE5hbWU6IEFwcE5hbWU7XG4gICAgX3NlcnZlclJlc3BvbnNlOiBJZFRva2VuTWZhUmVzcG9uc2U7XG4gIH07XG4gIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09SRE9WQV9DT05GSUdVUkFUSU9OXToge1xuICAgIGFwcE5hbWU6IEFwcE5hbWU7XG4gICAgbWlzc2luZ1BsdWdpbj86IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWSA9IG5ldyBFcnJvckZhY3Rvcnk8XG4gIEF1dGhFcnJvckNvZGUsXG4gIEF1dGhFcnJvclBhcmFtc1xuPignYXV0aCcsICdGaXJlYmFzZScsIF9wcm9kRXJyb3JNYXAoKSk7XG5cbi8qKlxuICogQSBtYXAgb2YgcG90ZW50aWFsIGBBdXRoYCBlcnJvciBjb2RlcywgZm9yIGVhc2llciBjb21wYXJpc29uIHdpdGggZXJyb3JzXG4gKiB0aHJvd24gYnkgdGhlIFNESy5cbiAqXG4gKiBAcmVtYXJrc1xuICogTm90ZSB0aGF0IHlvdSBjYW4ndCB0cmVlLXNoYWtlIGluZGl2aWR1YWwga2V5c1xuICogaW4gdGhlIG1hcCwgc28gYnkgdXNpbmcgdGhlIG1hcCB5b3UgbWlnaHQgc3Vic3RhbnRpYWxseSBpbmNyZWFzZSB5b3VyXG4gKiBidW5kbGUgc2l6ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBBVVRIX0VSUk9SX0NPREVTX01BUF9ET19OT1RfVVNFX0lOVEVSTkFMTFkgPSB7XG4gIEFETUlOX09OTFlfT1BFUkFUSU9OOiAnYXV0aC9hZG1pbi1yZXN0cmljdGVkLW9wZXJhdGlvbicsXG4gIEFSR1VNRU5UX0VSUk9SOiAnYXV0aC9hcmd1bWVudC1lcnJvcicsXG4gIEFQUF9OT1RfQVVUSE9SSVpFRDogJ2F1dGgvYXBwLW5vdC1hdXRob3JpemVkJyxcbiAgQVBQX05PVF9JTlNUQUxMRUQ6ICdhdXRoL2FwcC1ub3QtaW5zdGFsbGVkJyxcbiAgQ0FQVENIQV9DSEVDS19GQUlMRUQ6ICdhdXRoL2NhcHRjaGEtY2hlY2stZmFpbGVkJyxcbiAgQ09ERV9FWFBJUkVEOiAnYXV0aC9jb2RlLWV4cGlyZWQnLFxuICBDT1JET1ZBX05PVF9SRUFEWTogJ2F1dGgvY29yZG92YS1ub3QtcmVhZHknLFxuICBDT1JTX1VOU1VQUE9SVEVEOiAnYXV0aC9jb3JzLXVuc3VwcG9ydGVkJyxcbiAgQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRTogJ2F1dGgvY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZScsXG4gIENSRURFTlRJQUxfTUlTTUFUQ0g6ICdhdXRoL2N1c3RvbS10b2tlbi1taXNtYXRjaCcsXG4gIENSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTjogJ2F1dGgvcmVxdWlyZXMtcmVjZW50LWxvZ2luJyxcbiAgREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIOiAnYXV0aC9kZXBlbmRlbnQtc2RrLWluaXRpYWxpemVkLWJlZm9yZS1hdXRoJyxcbiAgRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQ6ICdhdXRoL2R5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkJyxcbiAgRU1BSUxfQ0hBTkdFX05FRURTX1ZFUklGSUNBVElPTjogJ2F1dGgvZW1haWwtY2hhbmdlLW5lZWRzLXZlcmlmaWNhdGlvbicsXG4gIEVNQUlMX0VYSVNUUzogJ2F1dGgvZW1haWwtYWxyZWFkeS1pbi11c2UnLFxuICBFTVVMQVRPUl9DT05GSUdfRkFJTEVEOiAnYXV0aC9lbXVsYXRvci1jb25maWctZmFpbGVkJyxcbiAgRVhQSVJFRF9PT0JfQ09ERTogJ2F1dGgvZXhwaXJlZC1hY3Rpb24tY29kZScsXG4gIEVYUElSRURfUE9QVVBfUkVRVUVTVDogJ2F1dGgvY2FuY2VsbGVkLXBvcHVwLXJlcXVlc3QnLFxuICBJTlRFUk5BTF9FUlJPUjogJ2F1dGgvaW50ZXJuYWwtZXJyb3InLFxuICBJTlZBTElEX0FQSV9LRVk6ICdhdXRoL2ludmFsaWQtYXBpLWtleScsXG4gIElOVkFMSURfQVBQX0NSRURFTlRJQUw6ICdhdXRoL2ludmFsaWQtYXBwLWNyZWRlbnRpYWwnLFxuICBJTlZBTElEX0FQUF9JRDogJ2F1dGgvaW52YWxpZC1hcHAtaWQnLFxuICBJTlZBTElEX0FVVEg6ICdhdXRoL2ludmFsaWQtdXNlci10b2tlbicsXG4gIElOVkFMSURfQVVUSF9FVkVOVDogJ2F1dGgvaW52YWxpZC1hdXRoLWV2ZW50JyxcbiAgSU5WQUxJRF9DRVJUX0hBU0g6ICdhdXRoL2ludmFsaWQtY2VydC1oYXNoJyxcbiAgSU5WQUxJRF9DT0RFOiAnYXV0aC9pbnZhbGlkLXZlcmlmaWNhdGlvbi1jb2RlJyxcbiAgSU5WQUxJRF9DT05USU5VRV9VUkk6ICdhdXRoL2ludmFsaWQtY29udGludWUtdXJpJyxcbiAgSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT046ICdhdXRoL2ludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uJyxcbiAgSU5WQUxJRF9DVVNUT01fVE9LRU46ICdhdXRoL2ludmFsaWQtY3VzdG9tLXRva2VuJyxcbiAgSU5WQUxJRF9EWU5BTUlDX0xJTktfRE9NQUlOOiAnYXV0aC9pbnZhbGlkLWR5bmFtaWMtbGluay1kb21haW4nLFxuICBJTlZBTElEX0VNQUlMOiAnYXV0aC9pbnZhbGlkLWVtYWlsJyxcbiAgSU5WQUxJRF9FTVVMQVRPUl9TQ0hFTUU6ICdhdXRoL2ludmFsaWQtZW11bGF0b3Itc2NoZW1lJyxcbiAgSU5WQUxJRF9JRFBfUkVTUE9OU0U6ICdhdXRoL2ludmFsaWQtY3JlZGVudGlhbCcsXG4gIElOVkFMSURfTUVTU0FHRV9QQVlMT0FEOiAnYXV0aC9pbnZhbGlkLW1lc3NhZ2UtcGF5bG9hZCcsXG4gIElOVkFMSURfTUZBX1NFU1NJT046ICdhdXRoL2ludmFsaWQtbXVsdGktZmFjdG9yLXNlc3Npb24nLFxuICBJTlZBTElEX09BVVRIX0NMSUVOVF9JRDogJ2F1dGgvaW52YWxpZC1vYXV0aC1jbGllbnQtaWQnLFxuICBJTlZBTElEX09BVVRIX1BST1ZJREVSOiAnYXV0aC9pbnZhbGlkLW9hdXRoLXByb3ZpZGVyJyxcbiAgSU5WQUxJRF9PT0JfQ09ERTogJ2F1dGgvaW52YWxpZC1hY3Rpb24tY29kZScsXG4gIElOVkFMSURfT1JJR0lOOiAnYXV0aC91bmF1dGhvcml6ZWQtZG9tYWluJyxcbiAgSU5WQUxJRF9QQVNTV09SRDogJ2F1dGgvd3JvbmctcGFzc3dvcmQnLFxuICBJTlZBTElEX1BFUlNJU1RFTkNFOiAnYXV0aC9pbnZhbGlkLXBlcnNpc3RlbmNlLXR5cGUnLFxuICBJTlZBTElEX1BIT05FX05VTUJFUjogJ2F1dGgvaW52YWxpZC1waG9uZS1udW1iZXInLFxuICBJTlZBTElEX1BST1ZJREVSX0lEOiAnYXV0aC9pbnZhbGlkLXByb3ZpZGVyLWlkJyxcbiAgSU5WQUxJRF9SRUNJUElFTlRfRU1BSUw6ICdhdXRoL2ludmFsaWQtcmVjaXBpZW50LWVtYWlsJyxcbiAgSU5WQUxJRF9TRU5ERVI6ICdhdXRoL2ludmFsaWQtc2VuZGVyJyxcbiAgSU5WQUxJRF9TRVNTSU9OX0lORk86ICdhdXRoL2ludmFsaWQtdmVyaWZpY2F0aW9uLWlkJyxcbiAgSU5WQUxJRF9URU5BTlRfSUQ6ICdhdXRoL2ludmFsaWQtdGVuYW50LWlkJyxcbiAgTUZBX0lORk9fTk9UX0ZPVU5EOiAnYXV0aC9tdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmQnLFxuICBNRkFfUkVRVUlSRUQ6ICdhdXRoL211bHRpLWZhY3Rvci1hdXRoLXJlcXVpcmVkJyxcbiAgTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRTogJ2F1dGgvbWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lJyxcbiAgTUlTU0lOR19BUFBfQ1JFREVOVElBTDogJ2F1dGgvbWlzc2luZy1hcHAtY3JlZGVudGlhbCcsXG4gIE1JU1NJTkdfQVVUSF9ET01BSU46ICdhdXRoL2F1dGgtZG9tYWluLWNvbmZpZy1yZXF1aXJlZCcsXG4gIE1JU1NJTkdfQ09ERTogJ2F1dGgvbWlzc2luZy12ZXJpZmljYXRpb24tY29kZScsXG4gIE1JU1NJTkdfQ09OVElOVUVfVVJJOiAnYXV0aC9taXNzaW5nLWNvbnRpbnVlLXVyaScsXG4gIE1JU1NJTkdfSUZSQU1FX1NUQVJUOiAnYXV0aC9taXNzaW5nLWlmcmFtZS1zdGFydCcsXG4gIE1JU1NJTkdfSU9TX0JVTkRMRV9JRDogJ2F1dGgvbWlzc2luZy1pb3MtYnVuZGxlLWlkJyxcbiAgTUlTU0lOR19PUl9JTlZBTElEX05PTkNFOiAnYXV0aC9taXNzaW5nLW9yLWludmFsaWQtbm9uY2UnLFxuICBNSVNTSU5HX01GQV9JTkZPOiAnYXV0aC9taXNzaW5nLW11bHRpLWZhY3Rvci1pbmZvJyxcbiAgTUlTU0lOR19NRkFfU0VTU0lPTjogJ2F1dGgvbWlzc2luZy1tdWx0aS1mYWN0b3Itc2Vzc2lvbicsXG4gIE1JU1NJTkdfUEhPTkVfTlVNQkVSOiAnYXV0aC9taXNzaW5nLXBob25lLW51bWJlcicsXG4gIE1JU1NJTkdfU0VTU0lPTl9JTkZPOiAnYXV0aC9taXNzaW5nLXZlcmlmaWNhdGlvbi1pZCcsXG4gIE1PRFVMRV9ERVNUUk9ZRUQ6ICdhdXRoL2FwcC1kZWxldGVkJyxcbiAgTkVFRF9DT05GSVJNQVRJT046ICdhdXRoL2FjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWwnLFxuICBORVRXT1JLX1JFUVVFU1RfRkFJTEVEOiAnYXV0aC9uZXR3b3JrLXJlcXVlc3QtZmFpbGVkJyxcbiAgTlVMTF9VU0VSOiAnYXV0aC9udWxsLXVzZXInLFxuICBOT19BVVRIX0VWRU5UOiAnYXV0aC9uby1hdXRoLWV2ZW50JyxcbiAgTk9fU1VDSF9QUk9WSURFUjogJ2F1dGgvbm8tc3VjaC1wcm92aWRlcicsXG4gIE9QRVJBVElPTl9OT1RfQUxMT1dFRDogJ2F1dGgvb3BlcmF0aW9uLW5vdC1hbGxvd2VkJyxcbiAgT1BFUkFUSU9OX05PVF9TVVBQT1JURUQ6ICdhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQnLFxuICBQT1BVUF9CTE9DS0VEOiAnYXV0aC9wb3B1cC1ibG9ja2VkJyxcbiAgUE9QVVBfQ0xPU0VEX0JZX1VTRVI6ICdhdXRoL3BvcHVwLWNsb3NlZC1ieS11c2VyJyxcbiAgUFJPVklERVJfQUxSRUFEWV9MSU5LRUQ6ICdhdXRoL3Byb3ZpZGVyLWFscmVhZHktbGlua2VkJyxcbiAgUVVPVEFfRVhDRUVERUQ6ICdhdXRoL3F1b3RhLWV4Y2VlZGVkJyxcbiAgUkVESVJFQ1RfQ0FOQ0VMTEVEX0JZX1VTRVI6ICdhdXRoL3JlZGlyZWN0LWNhbmNlbGxlZC1ieS11c2VyJyxcbiAgUkVESVJFQ1RfT1BFUkFUSU9OX1BFTkRJTkc6ICdhdXRoL3JlZGlyZWN0LW9wZXJhdGlvbi1wZW5kaW5nJyxcbiAgUkVKRUNURURfQ1JFREVOVElBTDogJ2F1dGgvcmVqZWN0ZWQtY3JlZGVudGlhbCcsXG4gIFNFQ09ORF9GQUNUT1JfQUxSRUFEWV9FTlJPTExFRDogJ2F1dGgvc2Vjb25kLWZhY3Rvci1hbHJlYWR5LWluLXVzZScsXG4gIFNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQ6ICdhdXRoL21heGltdW0tc2Vjb25kLWZhY3Rvci1jb3VudC1leGNlZWRlZCcsXG4gIFRFTkFOVF9JRF9NSVNNQVRDSDogJ2F1dGgvdGVuYW50LWlkLW1pc21hdGNoJyxcbiAgVElNRU9VVDogJ2F1dGgvdGltZW91dCcsXG4gIFRPS0VOX0VYUElSRUQ6ICdhdXRoL3VzZXItdG9rZW4tZXhwaXJlZCcsXG4gIFRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUjogJ2F1dGgvdG9vLW1hbnktcmVxdWVzdHMnLFxuICBVTkFVVEhPUklaRURfRE9NQUlOOiAnYXV0aC91bmF1dGhvcml6ZWQtY29udGludWUtdXJpJyxcbiAgVU5TVVBQT1JURURfRklSU1RfRkFDVE9SOiAnYXV0aC91bnN1cHBvcnRlZC1maXJzdC1mYWN0b3InLFxuICBVTlNVUFBPUlRFRF9QRVJTSVNURU5DRTogJ2F1dGgvdW5zdXBwb3J0ZWQtcGVyc2lzdGVuY2UtdHlwZScsXG4gIFVOU1VQUE9SVEVEX1RFTkFOVF9PUEVSQVRJT046ICdhdXRoL3Vuc3VwcG9ydGVkLXRlbmFudC1vcGVyYXRpb24nLFxuICBVTlZFUklGSUVEX0VNQUlMOiAnYXV0aC91bnZlcmlmaWVkLWVtYWlsJyxcbiAgVVNFUl9DQU5DRUxMRUQ6ICdhdXRoL3VzZXItY2FuY2VsbGVkJyxcbiAgVVNFUl9ERUxFVEVEOiAnYXV0aC91c2VyLW5vdC1mb3VuZCcsXG4gIFVTRVJfRElTQUJMRUQ6ICdhdXRoL3VzZXItZGlzYWJsZWQnLFxuICBVU0VSX01JU01BVENIOiAnYXV0aC91c2VyLW1pc21hdGNoJyxcbiAgVVNFUl9TSUdORURfT1VUOiAnYXV0aC91c2VyLXNpZ25lZC1vdXQnLFxuICBXRUFLX1BBU1NXT1JEOiAnYXV0aC93ZWFrLXBhc3N3b3JkJyxcbiAgV0VCX1NUT1JBR0VfVU5TVVBQT1JURUQ6ICdhdXRoL3dlYi1zdG9yYWdlLXVuc3VwcG9ydGVkJyxcbiAgQUxSRUFEWV9JTklUSUFMSVpFRDogJ2F1dGgvYWxyZWFkeS1pbml0aWFsaXplZCcsXG4gIFJFQ0FQVENIQV9OT1RfRU5BQkxFRDogJ2F1dGgvcmVjYXB0Y2hhLW5vdC1lbmFibGVkJyxcbiAgTUlTU0lOR19SRUNBUFRDSEFfVE9LRU46ICdhdXRoL21pc3NpbmctcmVjYXB0Y2hhLXRva2VuJyxcbiAgSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU46ICdhdXRoL2ludmFsaWQtcmVjYXB0Y2hhLXRva2VuJyxcbiAgSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OOiAnYXV0aC9pbnZhbGlkLXJlY2FwdGNoYS1hY3Rpb24nLFxuICBNSVNTSU5HX0NMSUVOVF9UWVBFOiAnYXV0aC9taXNzaW5nLWNsaWVudC10eXBlJyxcbiAgTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTjogJ2F1dGgvbWlzc2luZy1yZWNhcHRjaGEtdmVyc2lvbicsXG4gIElOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT046ICdhdXRoL2ludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb24nLFxuICBJTlZBTElEX1JFUV9UWVBFOiAnYXV0aC9pbnZhbGlkLXJlcS10eXBlJ1xufSBhcyBjb25zdDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IFNES19WRVJTSU9OIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5cbmV4cG9ydCB7IExvZ0xldmVsIH07XG5cbmNvbnN0IGxvZ0NsaWVudCA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9hdXRoJyk7XG5cbi8vIEhlbHBlciBtZXRob2RzIGFyZSBuZWVkZWQgYmVjYXVzZSB2YXJpYWJsZXMgY2FuJ3QgYmUgZXhwb3J0ZWQgYXMgcmVhZC93cml0ZVxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRMb2dMZXZlbCgpOiBMb2dMZXZlbCB7XG4gIHJldHVybiBsb2dDbGllbnQubG9nTGV2ZWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2V0TG9nTGV2ZWwobmV3TGV2ZWw6IExvZ0xldmVsKTogdm9pZCB7XG4gIGxvZ0NsaWVudC5sb2dMZXZlbCA9IG5ld0xldmVsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2xvZ0RlYnVnKG1zZzogc3RyaW5nLCAuLi5hcmdzOiBzdHJpbmdbXSk6IHZvaWQge1xuICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLkRFQlVHKSB7XG4gICAgbG9nQ2xpZW50LmRlYnVnKGBBdXRoICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfbG9nV2Fybihtc2c6IHN0cmluZywgLi4uYXJnczogc3RyaW5nW10pOiB2b2lkIHtcbiAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5XQVJOKSB7XG4gICAgbG9nQ2xpZW50Lndhcm4oYEF1dGggKCR7U0RLX1ZFUlNJT059KTogJHttc2d9YCwgLi4uYXJncyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9sb2dFcnJvcihtc2c6IHN0cmluZywgLi4uYXJnczogc3RyaW5nW10pOiB2b2lkIHtcbiAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5FUlJPUikge1xuICAgIGxvZ0NsaWVudC5lcnJvcihgQXV0aCAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7XG4gIF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWSxcbiAgQXV0aEVycm9yQ29kZSxcbiAgQXV0aEVycm9yUGFyYW1zLFxuICBwcm9kRXJyb3JNYXAsXG4gIEVycm9yTWFwUmV0cmlldmVyXG59IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBfbG9nRXJyb3IgfSBmcm9tICcuL2xvZyc7XG5cbnR5cGUgQXV0aEVycm9yTGlzdFBhcmFtczxLPiA9IEsgZXh0ZW5kcyBrZXlvZiBBdXRoRXJyb3JQYXJhbXNcbiAgPyBbQXV0aEVycm9yUGFyYW1zW0tdXVxuICA6IFtdO1xudHlwZSBMZXNzQXBwTmFtZTxLIGV4dGVuZHMgQXV0aEVycm9yQ29kZT4gPSBPbWl0PEF1dGhFcnJvclBhcmFtc1tLXSwgJ2FwcE5hbWUnPjtcblxuLyoqXG4gKiBVbmNvbmRpdGlvbmFsbHkgZmFpbHMsIHRocm93aW5nIGEgZGV2ZWxvcGVyIGZhY2luZyBJTlRFUk5BTF9FUlJPUlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBmYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEKTsgIC8vIEVycm9yOiB0aGUgTUZBX1JFUVVJUkVEIGVycm9yIG5lZWRzIG1vcmUgcGFyYW1zIHRoYW4gYXBwTmFtZVxuICogZmFpbChhdXRoLCBBdXRoRXJyb3JDb2RlLk1GQV9SRVFVSVJFRCwge3NlcnZlclJlc3BvbnNlfSk7ICAvLyBDb21waWxlc1xuICogZmFpbChBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTsgIC8vIENvbXBpbGVzOyBpbnRlcm5hbCBlcnJvciBkb2VzIG5vdCBuZWVkIGFwcE5hbWVcbiAqIGZhaWwoQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQpOyAgLy8gRXJyb3I6IFVTRVJfREVMRVRFRCByZXF1aXJlcyBhcHAgbmFtZVxuICogZmFpbChhdXRoLCBBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRCk7ICAvLyBDb21waWxlczsgVVNFUl9ERUxFVEVEIF9vbmx5XyBuZWVkcyBhcHAgbmFtZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFwcE5hbWUgQXBwIG5hbWUgZm9yIHRhZ2dpbmcgdGhlIGVycm9yXG4gKiBAdGhyb3dzIEZpcmViYXNlRXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9mYWlsPEsgZXh0ZW5kcyBBdXRoRXJyb3JDb2RlPihcbiAgY29kZTogSyxcbiAgLi4uZGF0YToge30gZXh0ZW5kcyBBdXRoRXJyb3JQYXJhbXNbS11cbiAgICA/IFtBdXRoRXJyb3JQYXJhbXNbS10/XVxuICAgIDogW0F1dGhFcnJvclBhcmFtc1tLXV1cbik6IG5ldmVyO1xuZXhwb3J0IGZ1bmN0aW9uIF9mYWlsPEsgZXh0ZW5kcyBBdXRoRXJyb3JDb2RlPihcbiAgYXV0aDogQXV0aCxcbiAgY29kZTogSyxcbiAgLi4uZGF0YToge30gZXh0ZW5kcyBMZXNzQXBwTmFtZTxLPiA/IFtMZXNzQXBwTmFtZTxLPj9dIDogW0xlc3NBcHBOYW1lPEs+XVxuKTogbmV2ZXI7XG5leHBvcnQgZnVuY3Rpb24gX2ZhaWw8SyBleHRlbmRzIEF1dGhFcnJvckNvZGU+KFxuICBhdXRoT3JDb2RlOiBBdXRoIHwgSyxcbiAgLi4ucmVzdDogdW5rbm93bltdXG4pOiBuZXZlciB7XG4gIHRocm93IGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlRXJyb3I8SyBleHRlbmRzIEF1dGhFcnJvckNvZGU+KFxuICBjb2RlOiBLLFxuICAuLi5kYXRhOiB7fSBleHRlbmRzIEF1dGhFcnJvclBhcmFtc1tLXVxuICAgID8gW0F1dGhFcnJvclBhcmFtc1tLXT9dXG4gICAgOiBbQXV0aEVycm9yUGFyYW1zW0tdXVxuKTogRmlyZWJhc2VFcnJvcjtcbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlRXJyb3I8SyBleHRlbmRzIEF1dGhFcnJvckNvZGU+KFxuICBhdXRoOiBBdXRoLFxuICBjb2RlOiBLLFxuICAuLi5kYXRhOiB7fSBleHRlbmRzIExlc3NBcHBOYW1lPEs+ID8gW0xlc3NBcHBOYW1lPEs+P10gOiBbTGVzc0FwcE5hbWU8Sz5dXG4pOiBGaXJlYmFzZUVycm9yO1xuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVFcnJvcjxLIGV4dGVuZHMgQXV0aEVycm9yQ29kZT4oXG4gIGF1dGhPckNvZGU6IEF1dGggfCBLLFxuICAuLi5yZXN0OiB1bmtub3duW11cbik6IEZpcmViYXNlRXJyb3Ige1xuICByZXR1cm4gY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKFxuICBhdXRoOiBBdXRoLFxuICBjb2RlOiBBdXRoRXJyb3JDb2RlLFxuICBtZXNzYWdlOiBzdHJpbmdcbik6IEZpcmViYXNlRXJyb3Ige1xuICBjb25zdCBlcnJvck1hcCA9IHtcbiAgICAuLi4ocHJvZEVycm9yTWFwIGFzIEVycm9yTWFwUmV0cmlldmVyKSgpLFxuICAgIFtjb2RlXTogbWVzc2FnZVxuICB9O1xuICBjb25zdCBmYWN0b3J5ID0gbmV3IEVycm9yRmFjdG9yeTxBdXRoRXJyb3JDb2RlLCBBdXRoRXJyb3JQYXJhbXM+KFxuICAgICdhdXRoJyxcbiAgICAnRmlyZWJhc2UnLFxuICAgIGVycm9yTWFwXG4gICk7XG4gIHJldHVybiBmYWN0b3J5LmNyZWF0ZShjb2RlLCB7XG4gICAgYXBwTmFtZTogYXV0aC5uYW1lXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2Fzc2VydEluc3RhbmNlT2YoXG4gIGF1dGg6IEF1dGgsXG4gIG9iamVjdDogb2JqZWN0LFxuICBpbnN0YW5jZTogdW5rbm93blxuKTogdm9pZCB7XG4gIGNvbnN0IGNvbnN0cnVjdG9ySW5zdGFuY2UgPSBpbnN0YW5jZSBhcyB7IG5ldyAoLi4uYXJnczogdW5rbm93bltdKTogdW5rbm93biB9O1xuICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvckluc3RhbmNlKSkge1xuICAgIGlmIChjb25zdHJ1Y3Rvckluc3RhbmNlLm5hbWUgIT09IG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICBfZmFpbChhdXRoLCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SKTtcbiAgICB9XG5cbiAgICB0aHJvdyBfZXJyb3JXaXRoQ3VzdG9tTWVzc2FnZShcbiAgICAgIGF1dGgsXG4gICAgICBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SLFxuICAgICAgYFR5cGUgb2YgJHtvYmplY3QuY29uc3RydWN0b3IubmFtZX0gZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgaW5zdGFuY2UuYCArXG4gICAgICAgIGBEaWQgeW91IHBhc3MgYSByZWZlcmVuY2UgZnJvbSBhIGRpZmZlcmVudCBBdXRoIFNESz9gXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJvckludGVybmFsPEsgZXh0ZW5kcyBBdXRoRXJyb3JDb2RlPihcbiAgYXV0aE9yQ29kZTogQXV0aCB8IEssXG4gIC4uLnJlc3Q6IHVua25vd25bXVxuKTogRmlyZWJhc2VFcnJvciB7XG4gIGlmICh0eXBlb2YgYXV0aE9yQ29kZSAhPT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjb2RlID0gcmVzdFswXSBhcyBLO1xuICAgIGNvbnN0IGZ1bGxQYXJhbXMgPSBbLi4ucmVzdC5zbGljZSgxKV0gYXMgQXV0aEVycm9yTGlzdFBhcmFtczxLPjtcbiAgICBpZiAoZnVsbFBhcmFtc1swXSkge1xuICAgICAgZnVsbFBhcmFtc1swXS5hcHBOYW1lID0gYXV0aE9yQ29kZS5uYW1lO1xuICAgIH1cblxuICAgIHJldHVybiAoYXV0aE9yQ29kZSBhcyBBdXRoSW50ZXJuYWwpLl9lcnJvckZhY3RvcnkuY3JlYXRlKFxuICAgICAgY29kZSxcbiAgICAgIC4uLmZ1bGxQYXJhbXNcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWS5jcmVhdGUoXG4gICAgYXV0aE9yQ29kZSxcbiAgICAuLi4ocmVzdCBhcyBBdXRoRXJyb3JMaXN0UGFyYW1zPEs+KVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2Fzc2VydDxLIGV4dGVuZHMgQXV0aEVycm9yQ29kZT4oXG4gIGFzc2VydGlvbjogdW5rbm93bixcbiAgY29kZTogSyxcbiAgLi4uZGF0YToge30gZXh0ZW5kcyBBdXRoRXJyb3JQYXJhbXNbS11cbiAgICA/IFtBdXRoRXJyb3JQYXJhbXNbS10/XVxuICAgIDogW0F1dGhFcnJvclBhcmFtc1tLXV1cbik6IGFzc2VydHMgYXNzZXJ0aW9uO1xuZXhwb3J0IGZ1bmN0aW9uIF9hc3NlcnQ8SyBleHRlbmRzIEF1dGhFcnJvckNvZGU+KFxuICBhc3NlcnRpb246IHVua25vd24sXG4gIGF1dGg6IEF1dGgsXG4gIGNvZGU6IEssXG4gIC4uLmRhdGE6IHt9IGV4dGVuZHMgTGVzc0FwcE5hbWU8Sz4gPyBbTGVzc0FwcE5hbWU8Sz4/XSA6IFtMZXNzQXBwTmFtZTxLPl1cbik6IGFzc2VydHMgYXNzZXJ0aW9uO1xuZXhwb3J0IGZ1bmN0aW9uIF9hc3NlcnQ8SyBleHRlbmRzIEF1dGhFcnJvckNvZGU+KFxuICBhc3NlcnRpb246IHVua25vd24sXG4gIGF1dGhPckNvZGU6IEF1dGggfCBLLFxuICAuLi5yZXN0OiB1bmtub3duW11cbik6IGFzc2VydHMgYXNzZXJ0aW9uIHtcbiAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICB0aHJvdyBjcmVhdGVFcnJvckludGVybmFsKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xuICB9XG59XG5cbi8vIFdlIHJlYWxseSBkbyB3YW50IHRvIGFjY2VwdCBsaXRlcmFsbHkgYW55IGZ1bmN0aW9uIHR5cGUgaGVyZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbnR5cGUgVHlwZUV4cGVjdGF0aW9uID0gRnVuY3Rpb24gfCBzdHJpbmcgfCBNYXBUeXBlO1xuXG5pbnRlcmZhY2UgTWFwVHlwZSBleHRlbmRzIFJlY29yZDxzdHJpbmcsIFR5cGVFeHBlY3RhdGlvbiB8IE9wdGlvbmFsPiB7fVxuXG5jbGFzcyBPcHRpb25hbCB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHR5cGU6IFR5cGVFeHBlY3RhdGlvbikge31cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdCh0eXBlOiBUeXBlRXhwZWN0YXRpb24pOiBPcHRpb25hbCB7XG4gIHJldHVybiBuZXcgT3B0aW9uYWwodHlwZSk7XG59XG5cbi8qKlxuICogQXNzZXJ0cyB0aGUgcnVudGltZSB0eXBlcyBvZiBhcmd1bWVudHMuIFRoZSAnZXhwZWN0ZWQnIGZpZWxkIGNhbiBiZSBvbmUgb2ZcbiAqIGEgY2xhc3MsIGEgc3RyaW5nIChyZXByZXNlbnRpbmcgYSBcInR5cGVvZlwiIGNhbGwpLCBvciBhIHJlY29yZCBtYXAgb2YgbmFtZVxuICogdG8gdHlwZS4gRnVydGhlcm1vcmUsIHRoZSBvcHQoKSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBtYXJrIGEgZmllbGQgYXNcbiAqIG9wdGlvbmFsLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBmdW5jdGlvbiBmb28oYXV0aDogQXV0aCwgcHJvZmlsZToge2Rpc3BsYXlOYW1lPzogc3RyaW5nfSwgdXBkYXRlID0gZmFsc2UpIHtcbiAqICAgYXNzZXJ0VHlwZXMoYXJndW1lbnRzLCBbQXV0aEltcGwsIHtkaXNwbGF5TmFtZTogb3B0KCdzdHJpbmcnKX0sIG9wdCgnYm9vbGVhbicpXSk7XG4gKiB9XG4gKlxuICogb3B0KCkgY2FuIGJlIHVzZWQgZm9yIGFueSB0eXBlOlxuICogZnVuY3Rpb24gZm9vKGF1dGg/OiBBdXRoKSB7XG4gKiAgIGFzc2VydFR5cGVzKGFyZ3VtZW50cywgW29wdChBdXRoSW1wbCldKTtcbiAqIH1cbiAqXG4gKiBUaGUgc3RyaW5nIHR5cGVzIGNhbiBiZSBvcidkIHRvZ2V0aGVyLCBhbmQgeW91IGNhbiB1c2UgXCJudWxsXCIgYXMgd2VsbCAobm90ZVxuICogdGhhdCB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCc7IHRoaXMgaXMgYW4gZWRnZSBjYXNlKS4gRm9yIGV4YW1wbGU6XG4gKlxuICogZnVuY3Rpb24gZm9vKHByb2ZpbGU6IHtkaXNwbGF5TmFtZT86IHN0cmluZyB8IG51bGx9KSB7XG4gKiAgIGFzc2VydFR5cGVzKGFyZ3VtZW50cywgW3tkaXNwbGF5TmFtZTogb3B0KCdzdHJpbmd8bnVsbCcpfV0pO1xuICogfVxuICpcbiAqIEBwYXJhbSBhcmdzXG4gKiBAcGFyYW0gZXhwZWN0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFR5cGVzKFxuICBhcmdzOiBPbWl0PElBcmd1bWVudHMsICdjYWxsZWUnPixcbiAgLi4uZXhwZWN0ZWQ6IEFycmF5PFR5cGVFeHBlY3RhdGlvbiB8IE9wdGlvbmFsPlxuKTogdm9pZCB7XG4gIGlmIChhcmdzLmxlbmd0aCA+IGV4cGVjdGVkLmxlbmd0aCkge1xuICAgIF9mYWlsKEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IsIHt9KTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgZXhwZWN0ID0gZXhwZWN0ZWRbaV07XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXTtcblxuICAgIGlmIChleHBlY3QgaW5zdGFuY2VvZiBPcHRpb25hbCkge1xuICAgICAgLy8gSWYgdGhlIGFyZyBpcyB1bmRlZmluZWQsIHRoZW4gaXQgbWF0Y2hlcyBcIm9wdGlvbmFsXCIgYW5kIHdlIGNhbiBtb3ZlIHRvXG4gICAgICAvLyB0aGUgbmV4dCBhcmdcbiAgICAgIGlmICh0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGV4cGVjdCA9IGV4cGVjdC50eXBlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZXhwZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSGFuZGxlIHRoZSBlZGdlIGNhc2UgZm9yIG51bGwgYmVjYXVzZSB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcbiAgICAgIGlmIChleHBlY3QuaW5jbHVkZXMoJ251bGwnKSAmJiBhcmcgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcXVpcmVkID0gZXhwZWN0LnNwbGl0KCd8Jyk7XG4gICAgICBfYXNzZXJ0KHJlcXVpcmVkLmluY2x1ZGVzKHR5cGVvZiBhcmcpLCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SLCB7fSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwZWN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gUmVjdXJzaXZlbHkgY2hlY2sgcmVjb3JkIGFyZ3VtZW50c1xuICAgICAgY29uc3QgcmVjb3JkID0gYXJnIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgY29uc3QgbWFwID0gZXhwZWN0IGFzIE1hcFR5cGU7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0KTtcblxuICAgICAgYXNzZXJ0VHlwZXMoXG4gICAgICAgIGtleXMubWFwKGsgPT4gcmVjb3JkW2tdKSxcbiAgICAgICAgLi4ua2V5cy5tYXAoayA9PiBtYXBba10pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXNzZXJ0KGFyZyBpbnN0YW5jZW9mIGV4cGVjdCwgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiwge30pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVuY29uZGl0aW9uYWxseSBmYWlscywgdGhyb3dpbmcgYW4gaW50ZXJuYWwgZXJyb3Igd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gZmFpbHVyZSB0eXBlIG9mIGZhaWx1cmUgZW5jb3VudGVyZWRcbiAqIEB0aHJvd3MgRXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnRmFpbChmYWlsdXJlOiBzdHJpbmcpOiBuZXZlciB7XG4gIC8vIExvZyB0aGUgZmFpbHVyZSBpbiBhZGRpdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24sIGp1c3QgaW4gY2FzZSB0aGVcbiAgLy8gZXhjZXB0aW9uIGlzIHN3YWxsb3dlZC5cbiAgY29uc3QgbWVzc2FnZSA9IGBJTlRFUk5BTCBBU1NFUlRJT04gRkFJTEVEOiBgICsgZmFpbHVyZTtcbiAgX2xvZ0Vycm9yKG1lc3NhZ2UpO1xuXG4gIC8vIE5PVEU6IFdlIGRvbid0IHVzZSBGaXJlYmFzZUVycm9yIGhlcmUgYmVjYXVzZSB0aGVzZSBhcmUgaW50ZXJuYWwgZmFpbHVyZXNcbiAgLy8gdGhhdCBjYW5ub3QgYmUgaGFuZGxlZCBieSB0aGUgdXNlci4gKEFsc28gaXQgd291bGQgY3JlYXRlIGEgY2lyY3VsYXJcbiAgLy8gZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSBlcnJvciBhbmQgYXNzZXJ0IG1vZHVsZXMgd2hpY2ggZG9lc24ndCB3b3JrLilcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEZhaWxzIGlmIHRoZSBnaXZlbiBhc3NlcnRpb24gY29uZGl0aW9uIGlzIGZhbHNlLCB0aHJvd2luZyBhbiBFcnJvciB3aXRoIHRoZVxuICogZ2l2ZW4gbWVzc2FnZSBpZiBpdCBkaWQuXG4gKlxuICogQHBhcmFtIGFzc2VydGlvblxuICogQHBhcmFtIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnQXNzZXJ0KFxuICBhc3NlcnRpb246IHVua25vd24sXG4gIG1lc3NhZ2U6IHN0cmluZ1xuKTogYXNzZXJ0cyBhc3NlcnRpb24ge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIGRlYnVnRmFpbChtZXNzYWdlKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRDdXJyZW50VXJsKCk6IHN0cmluZyB7XG4gIHJldHVybiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYubG9jYXRpb24/LmhyZWYpIHx8ICcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2lzSHR0cE9ySHR0cHMoKTogYm9vbGVhbiB7XG4gIHJldHVybiBfZ2V0Q3VycmVudFNjaGVtZSgpID09PSAnaHR0cDonIHx8IF9nZXRDdXJyZW50U2NoZW1lKCkgPT09ICdodHRwczonO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dldEN1cnJlbnRTY2hlbWUoKTogc3RyaW5nIHwgbnVsbCB7XG4gIHJldHVybiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYubG9jYXRpb24/LnByb3RvY29sKSB8fCBudWxsO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgaXNCcm93c2VyRXh0ZW5zaW9uIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgX2lzSHR0cE9ySHR0cHMgfSBmcm9tICcuL2xvY2F0aW9uJztcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgYnJvd3NlciBpcyB3b3JraW5nIG9ubGluZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzT25saW5lKCk6IGJvb2xlYW4ge1xuICBpZiAoXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBuYXZpZ2F0b3IgJiZcbiAgICAnb25MaW5lJyBpbiBuYXZpZ2F0b3IgJiZcbiAgICB0eXBlb2YgbmF2aWdhdG9yLm9uTGluZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgLy8gQXBwbHkgb25seSBmb3IgdHJhZGl0aW9uYWwgd2ViIGFwcHMgYW5kIENocm9tZSBleHRlbnNpb25zLlxuICAgIC8vIFRoaXMgaXMgZXNwZWNpYWxseSB0cnVlIGZvciBDb3Jkb3ZhIGFwcHMgd2hpY2ggaGF2ZSB1bnJlbGlhYmxlXG4gICAgLy8gbmF2aWdhdG9yLm9uTGluZSBiZWhhdmlvciB1bmxlc3MgY29yZG92YS1wbHVnaW4tbmV0d29yay1pbmZvcm1hdGlvbiBpc1xuICAgIC8vIGluc3RhbGxlZCB3aGljaCBvdmVyd3JpdGVzIHRoZSBuYXRpdmUgbmF2aWdhdG9yLm9uTGluZSB2YWx1ZSBhbmRcbiAgICAvLyBkZWZpbmVzIG5hdmlnYXRvci5jb25uZWN0aW9uLlxuICAgIChfaXNIdHRwT3JIdHRwcygpIHx8IGlzQnJvd3NlckV4dGVuc2lvbigpIHx8ICdjb25uZWN0aW9uJyBpbiBuYXZpZ2F0b3IpXG4gICkge1xuICAgIHJldHVybiBuYXZpZ2F0b3Iub25MaW5lO1xuICB9XG4gIC8vIElmIHdlIGNhbid0IGRldGVybWluZSB0aGUgc3RhdGUsIGFzc3VtZSBpdCBpcyBvbmxpbmUuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dldFVzZXJMYW5ndWFnZSgpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbmF2aWdhdG9yTGFuZ3VhZ2U6IE5hdmlnYXRvckxhbmd1YWdlID0gbmF2aWdhdG9yO1xuICByZXR1cm4gKFxuICAgIC8vIE1vc3QgcmVsaWFibGUsIGJ1dCBvbmx5IHN1cHBvcnRlZCBpbiBDaHJvbWUvRmlyZWZveC5cbiAgICAobmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2VzICYmIG5hdmlnYXRvckxhbmd1YWdlLmxhbmd1YWdlc1swXSkgfHxcbiAgICAvLyBTdXBwb3J0ZWQgaW4gbW9zdCBicm93c2VycywgYnV0IHJldHVybnMgdGhlIGxhbmd1YWdlIG9mIHRoZSBicm93c2VyXG4gICAgLy8gVUksIG5vdCB0aGUgbGFuZ3VhZ2Ugc2V0IGluIGJyb3dzZXIgc2V0dGluZ3MuXG4gICAgbmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2UgfHxcbiAgICAvLyBDb3VsZG4ndCBkZXRlcm1pbmUgbGFuZ3VhZ2UuXG4gICAgbnVsbFxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgaXNNb2JpbGVDb3Jkb3ZhLCBpc1JlYWN0TmF0aXZlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgX2lzT25saW5lIH0gZnJvbSAnLi9uYXZpZ2F0b3InO1xuaW1wb3J0IHsgZGVidWdBc3NlcnQgfSBmcm9tICcuL2Fzc2VydCc7XG5cbmV4cG9ydCBjb25zdCBlbnVtIERlbGF5TWluIHtcbiAgT0ZGTElORSA9IDUwMDBcbn1cblxuLyoqXG4gKiBBIHN0cnVjdHVyZSB0byBoZWxwIHBpY2sgYmV0d2VlbiBhIHJhbmdlIG9mIGxvbmcgYW5kIHNob3J0IGRlbGF5IGR1cmF0aW9uc1xuICogZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBJbiBnZW5lcmFsLCB0aGUgbG9uZyBkZWxheSBpcyB1c2VkIGZvclxuICogbW9iaWxlIGVudmlyb25tZW50cyB3aGVyZWFzIHNob3J0IGRlbGF5cyBhcmUgdXNlZCBmb3IgZGVza3RvcCBlbnZpcm9ubWVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWxheSB7XG4gIC8vIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgb2ZmbGluZSBkZWxheSB0aW1lb3V0IGluIG1zLlxuXG4gIHByaXZhdGUgcmVhZG9ubHkgaXNNb2JpbGU6IGJvb2xlYW47XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2hvcnREZWxheTogbnVtYmVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbG9uZ0RlbGF5OiBudW1iZXJcbiAgKSB7XG4gICAgLy8gSW50ZXJuYWwgZXJyb3Igd2hlbiBpbXByb3Blcmx5IGluaXRpYWxpemVkLlxuICAgIGRlYnVnQXNzZXJ0KFxuICAgICAgbG9uZ0RlbGF5ID4gc2hvcnREZWxheSxcbiAgICAgICdTaG9ydCBkZWxheSBzaG91bGQgYmUgbGVzcyB0aGFuIGxvbmcgZGVsYXkhJ1xuICAgICk7XG4gICAgdGhpcy5pc01vYmlsZSA9IGlzTW9iaWxlQ29yZG92YSgpIHx8IGlzUmVhY3ROYXRpdmUoKTtcbiAgfVxuXG4gIGdldCgpOiBudW1iZXIge1xuICAgIGlmICghX2lzT25saW5lKCkpIHtcbiAgICAgIC8vIFBpY2sgdGhlIHNob3J0ZXIgdGltZW91dC5cbiAgICAgIHJldHVybiBNYXRoLm1pbihEZWxheU1pbi5PRkZMSU5FLCB0aGlzLnNob3J0RGVsYXkpO1xuICAgIH1cbiAgICAvLyBJZiBydW5uaW5nIGluIGEgbW9iaWxlIGVudmlyb25tZW50LCByZXR1cm4gdGhlIGxvbmcgZGVsYXksIG90aGVyd2lzZVxuICAgIC8vIHJldHVybiB0aGUgc2hvcnQgZGVsYXkuXG4gICAgLy8gVGhpcyBjb3VsZCBiZSBpbXByb3ZlZCBpbiB0aGUgZnV0dXJlIHRvIGR5bmFtaWNhbGx5IGNoYW5nZSBiYXNlZCBvbiBvdGhlclxuICAgIC8vIHZhcmlhYmxlcyBpbnN0ZWFkIG9mIGp1c3QgcmVhZGluZyB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAgICByZXR1cm4gdGhpcy5pc01vYmlsZSA/IHRoaXMubG9uZ0RlbGF5IDogdGhpcy5zaG9ydERlbGF5O1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb25maWdJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgZGVidWdBc3NlcnQgfSBmcm9tICcuL2Fzc2VydCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZW11bGF0b3JVcmwoY29uZmlnOiBDb25maWdJbnRlcm5hbCwgcGF0aD86IHN0cmluZyk6IHN0cmluZyB7XG4gIGRlYnVnQXNzZXJ0KGNvbmZpZy5lbXVsYXRvciwgJ0VtdWxhdG9yIHNob3VsZCBhbHdheXMgYmUgc2V0IGhlcmUnKTtcbiAgY29uc3QgeyB1cmwgfSA9IGNvbmZpZy5lbXVsYXRvcjtcblxuICBpZiAoIXBhdGgpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgcmV0dXJuIGAke3VybH0ke3BhdGguc3RhcnRzV2l0aCgnLycpID8gcGF0aC5zbGljZSgxKSA6IHBhdGh9YDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGRlYnVnRmFpbCB9IGZyb20gJy4vYXNzZXJ0JztcblxuZXhwb3J0IGNsYXNzIEZldGNoUHJvdmlkZXIge1xuICBwcml2YXRlIHN0YXRpYyBmZXRjaEltcGw6IHR5cGVvZiBmZXRjaCB8IG51bGw7XG4gIHByaXZhdGUgc3RhdGljIGhlYWRlcnNJbXBsOiB0eXBlb2YgSGVhZGVycyB8IG51bGw7XG4gIHByaXZhdGUgc3RhdGljIHJlc3BvbnNlSW1wbDogdHlwZW9mIFJlc3BvbnNlIHwgbnVsbDtcblxuICBzdGF0aWMgaW5pdGlhbGl6ZShcbiAgICBmZXRjaEltcGw6IHR5cGVvZiBmZXRjaCxcbiAgICBoZWFkZXJzSW1wbD86IHR5cGVvZiBIZWFkZXJzLFxuICAgIHJlc3BvbnNlSW1wbD86IHR5cGVvZiBSZXNwb25zZVxuICApOiB2b2lkIHtcbiAgICB0aGlzLmZldGNoSW1wbCA9IGZldGNoSW1wbDtcbiAgICBpZiAoaGVhZGVyc0ltcGwpIHtcbiAgICAgIHRoaXMuaGVhZGVyc0ltcGwgPSBoZWFkZXJzSW1wbDtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlSW1wbCkge1xuICAgICAgdGhpcy5yZXNwb25zZUltcGwgPSByZXNwb25zZUltcGw7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZldGNoKCk6IHR5cGVvZiBmZXRjaCB7XG4gICAgaWYgKHRoaXMuZmV0Y2hJbXBsKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaEltcGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2ZldGNoJyBpbiBzZWxmKSB7XG4gICAgICByZXR1cm4gc2VsZi5mZXRjaDtcbiAgICB9XG4gICAgZGVidWdGYWlsKFxuICAgICAgJ0NvdWxkIG5vdCBmaW5kIGZldGNoIGltcGxlbWVudGF0aW9uLCBtYWtlIHN1cmUgeW91IGNhbGwgRmV0Y2hQcm92aWRlci5pbml0aWFsaXplKCkgd2l0aCBhbiBhcHByb3ByaWF0ZSBwb2x5ZmlsbCdcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIGhlYWRlcnMoKTogdHlwZW9mIEhlYWRlcnMge1xuICAgIGlmICh0aGlzLmhlYWRlcnNJbXBsKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkZXJzSW1wbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAnSGVhZGVycycgaW4gc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuSGVhZGVycztcbiAgICB9XG4gICAgZGVidWdGYWlsKFxuICAgICAgJ0NvdWxkIG5vdCBmaW5kIEhlYWRlcnMgaW1wbGVtZW50YXRpb24sIG1ha2Ugc3VyZSB5b3UgY2FsbCBGZXRjaFByb3ZpZGVyLmluaXRpYWxpemUoKSB3aXRoIGFuIGFwcHJvcHJpYXRlIHBvbHlmaWxsJ1xuICAgICk7XG4gIH1cblxuICBzdGF0aWMgcmVzcG9uc2UoKTogdHlwZW9mIFJlc3BvbnNlIHtcbiAgICBpZiAodGhpcy5yZXNwb25zZUltcGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlSW1wbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAnUmVzcG9uc2UnIGluIHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLlJlc3BvbnNlO1xuICAgIH1cbiAgICBkZWJ1Z0ZhaWwoXG4gICAgICAnQ291bGQgbm90IGZpbmQgUmVzcG9uc2UgaW1wbGVtZW50YXRpb24sIG1ha2Ugc3VyZSB5b3UgY2FsbCBGZXRjaFByb3ZpZGVyLmluaXRpYWxpemUoKSB3aXRoIGFuIGFwcHJvcHJpYXRlIHBvbHlmaWxsJ1xuICAgICk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9jb3JlL2Vycm9ycyc7XG5cbi8qKlxuICogRXJyb3JzIHRoYXQgY2FuIGJlIHJldHVybmVkIGJ5IHRoZSBiYWNrZW5kXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIFNlcnZlckVycm9yIHtcbiAgQURNSU5fT05MWV9PUEVSQVRJT04gPSAnQURNSU5fT05MWV9PUEVSQVRJT04nLFxuICBCTE9DS0lOR19GVU5DVElPTl9FUlJPUl9SRVNQT05TRSA9ICdCTE9DS0lOR19GVU5DVElPTl9FUlJPUl9SRVNQT05TRScsXG4gIENBUFRDSEFfQ0hFQ0tfRkFJTEVEID0gJ0NBUFRDSEFfQ0hFQ0tfRkFJTEVEJyxcbiAgQ09SU19VTlNVUFBPUlRFRCA9ICdDT1JTX1VOU1VQUE9SVEVEJyxcbiAgQ1JFREVOVElBTF9NSVNNQVRDSCA9ICdDUkVERU5USUFMX01JU01BVENIJyxcbiAgQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOID0gJ0NSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTicsXG4gIERZTkFNSUNfTElOS19OT1RfQUNUSVZBVEVEID0gJ0RZTkFNSUNfTElOS19OT1RfQUNUSVZBVEVEJyxcbiAgRU1BSUxfQ0hBTkdFX05FRURTX1ZFUklGSUNBVElPTiA9ICdFTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OJyxcbiAgRU1BSUxfRVhJU1RTID0gJ0VNQUlMX0VYSVNUUycsXG4gIEVNQUlMX05PVF9GT1VORCA9ICdFTUFJTF9OT1RfRk9VTkQnLFxuICBFWFBJUkVEX09PQl9DT0RFID0gJ0VYUElSRURfT09CX0NPREUnLFxuICBGRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRCA9ICdGRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRCcsXG4gIElOVkFMSURfQVBQX0NSRURFTlRJQUwgPSAnSU5WQUxJRF9BUFBfQ1JFREVOVElBTCcsXG4gIElOVkFMSURfQVBQX0lEID0gJ0lOVkFMSURfQVBQX0lEJyxcbiAgSU5WQUxJRF9DRVJUX0hBU0ggPSAnSU5WQUxJRF9DRVJUX0hBU0gnLFxuICBJTlZBTElEX0NPREUgPSAnSU5WQUxJRF9DT0RFJyxcbiAgSU5WQUxJRF9DT05USU5VRV9VUkkgPSAnSU5WQUxJRF9DT05USU5VRV9VUkknLFxuICBJTlZBTElEX0NVU1RPTV9UT0tFTiA9ICdJTlZBTElEX0NVU1RPTV9UT0tFTicsXG4gIElOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTiA9ICdJTlZBTElEX0RZTkFNSUNfTElOS19ET01BSU4nLFxuICBJTlZBTElEX0VNQUlMID0gJ0lOVkFMSURfRU1BSUwnLFxuICBJTlZBTElEX0lEX1RPS0VOID0gJ0lOVkFMSURfSURfVE9LRU4nLFxuICBJTlZBTElEX0lEUF9SRVNQT05TRSA9ICdJTlZBTElEX0lEUF9SRVNQT05TRScsXG4gIElOVkFMSURfSURFTlRJRklFUiA9ICdJTlZBTElEX0lERU5USUZJRVInLFxuICBJTlZBTElEX01FU1NBR0VfUEFZTE9BRCA9ICdJTlZBTElEX01FU1NBR0VfUEFZTE9BRCcsXG4gIElOVkFMSURfTUZBX1BFTkRJTkdfQ1JFREVOVElBTCA9ICdJTlZBTElEX01GQV9QRU5ESU5HX0NSRURFTlRJQUwnLFxuICBJTlZBTElEX09BVVRIX0NMSUVOVF9JRCA9ICdJTlZBTElEX09BVVRIX0NMSUVOVF9JRCcsXG4gIElOVkFMSURfT09CX0NPREUgPSAnSU5WQUxJRF9PT0JfQ09ERScsXG4gIElOVkFMSURfUEFTU1dPUkQgPSAnSU5WQUxJRF9QQVNTV09SRCcsXG4gIElOVkFMSURfUEVORElOR19UT0tFTiA9ICdJTlZBTElEX1BFTkRJTkdfVE9LRU4nLFxuICBJTlZBTElEX1BIT05FX05VTUJFUiA9ICdJTlZBTElEX1BIT05FX05VTUJFUicsXG4gIElOVkFMSURfUFJPVklERVJfSUQgPSAnSU5WQUxJRF9QUk9WSURFUl9JRCcsXG4gIElOVkFMSURfUkVDSVBJRU5UX0VNQUlMID0gJ0lOVkFMSURfUkVDSVBJRU5UX0VNQUlMJyxcbiAgSU5WQUxJRF9TRU5ERVIgPSAnSU5WQUxJRF9TRU5ERVInLFxuICBJTlZBTElEX1NFU1NJT05fSU5GTyA9ICdJTlZBTElEX1NFU1NJT05fSU5GTycsXG4gIElOVkFMSURfVEVNUE9SQVJZX1BST09GID0gJ0lOVkFMSURfVEVNUE9SQVJZX1BST09GJyxcbiAgSU5WQUxJRF9URU5BTlRfSUQgPSAnSU5WQUxJRF9URU5BTlRfSUQnLFxuICBNRkFfRU5ST0xMTUVOVF9OT1RfRk9VTkQgPSAnTUZBX0VOUk9MTE1FTlRfTk9UX0ZPVU5EJyxcbiAgTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSA9ICdNSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FJyxcbiAgTUlTU0lOR19BUFBfQ1JFREVOVElBTCA9ICdNSVNTSU5HX0FQUF9DUkVERU5USUFMJyxcbiAgTUlTU0lOR19DT0RFID0gJ01JU1NJTkdfQ09ERScsXG4gIE1JU1NJTkdfQ09OVElOVUVfVVJJID0gJ01JU1NJTkdfQ09OVElOVUVfVVJJJyxcbiAgTUlTU0lOR19DVVNUT01fVE9LRU4gPSAnTUlTU0lOR19DVVNUT01fVE9LRU4nLFxuICBNSVNTSU5HX0lPU19CVU5ETEVfSUQgPSAnTUlTU0lOR19JT1NfQlVORExFX0lEJyxcbiAgTUlTU0lOR19NRkFfRU5ST0xMTUVOVF9JRCA9ICdNSVNTSU5HX01GQV9FTlJPTExNRU5UX0lEJyxcbiAgTUlTU0lOR19NRkFfUEVORElOR19DUkVERU5USUFMID0gJ01JU1NJTkdfTUZBX1BFTkRJTkdfQ1JFREVOVElBTCcsXG4gIE1JU1NJTkdfT09CX0NPREUgPSAnTUlTU0lOR19PT0JfQ09ERScsXG4gIE1JU1NJTkdfT1JfSU5WQUxJRF9OT05DRSA9ICdNSVNTSU5HX09SX0lOVkFMSURfTk9OQ0UnLFxuICBNSVNTSU5HX1BBU1NXT1JEID0gJ01JU1NJTkdfUEFTU1dPUkQnLFxuICBNSVNTSU5HX1JFUV9UWVBFID0gJ01JU1NJTkdfUkVRX1RZUEUnLFxuICBNSVNTSU5HX1BIT05FX05VTUJFUiA9ICdNSVNTSU5HX1BIT05FX05VTUJFUicsXG4gIE1JU1NJTkdfU0VTU0lPTl9JTkZPID0gJ01JU1NJTkdfU0VTU0lPTl9JTkZPJyxcbiAgT1BFUkFUSU9OX05PVF9BTExPV0VEID0gJ09QRVJBVElPTl9OT1RfQUxMT1dFRCcsXG4gIFBBU1NXT1JEX0xPR0lOX0RJU0FCTEVEID0gJ1BBU1NXT1JEX0xPR0lOX0RJU0FCTEVEJyxcbiAgUVVPVEFfRVhDRUVERUQgPSAnUVVPVEFfRVhDRUVERUQnLFxuICBSRVNFVF9QQVNTV09SRF9FWENFRURfTElNSVQgPSAnUkVTRVRfUEFTU1dPUkRfRVhDRUVEX0xJTUlUJyxcbiAgUkVKRUNURURfQ1JFREVOVElBTCA9ICdSRUpFQ1RFRF9DUkVERU5USUFMJyxcbiAgU0VDT05EX0ZBQ1RPUl9FWElTVFMgPSAnU0VDT05EX0ZBQ1RPUl9FWElTVFMnLFxuICBTRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEID0gJ1NFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQnLFxuICBTRVNTSU9OX0VYUElSRUQgPSAnU0VTU0lPTl9FWFBJUkVEJyxcbiAgVEVOQU5UX0lEX01JU01BVENIID0gJ1RFTkFOVF9JRF9NSVNNQVRDSCcsXG4gIFRPS0VOX0VYUElSRUQgPSAnVE9LRU5fRVhQSVJFRCcsXG4gIFRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiA9ICdUT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVInLFxuICBVTlNVUFBPUlRFRF9GSVJTVF9GQUNUT1IgPSAnVU5TVVBQT1JURURfRklSU1RfRkFDVE9SJyxcbiAgVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTiA9ICdVTlNVUFBPUlRFRF9URU5BTlRfT1BFUkFUSU9OJyxcbiAgVU5BVVRIT1JJWkVEX0RPTUFJTiA9ICdVTkFVVEhPUklaRURfRE9NQUlOJyxcbiAgVU5WRVJJRklFRF9FTUFJTCA9ICdVTlZFUklGSUVEX0VNQUlMJyxcbiAgVVNFUl9DQU5DRUxMRUQgPSAnVVNFUl9DQU5DRUxMRUQnLFxuICBVU0VSX0RJU0FCTEVEID0gJ1VTRVJfRElTQUJMRUQnLFxuICBVU0VSX05PVF9GT1VORCA9ICdVU0VSX05PVF9GT1VORCcsXG4gIFdFQUtfUEFTU1dPUkQgPSAnV0VBS19QQVNTV09SRCcsXG4gIFJFQ0FQVENIQV9OT1RfRU5BQkxFRCA9ICdSRUNBUFRDSEFfTk9UX0VOQUJMRUQnLFxuICBNSVNTSU5HX1JFQ0FQVENIQV9UT0tFTiA9ICdNSVNTSU5HX1JFQ0FQVENIQV9UT0tFTicsXG4gIElOVkFMSURfUkVDQVBUQ0hBX1RPS0VOID0gJ0lOVkFMSURfUkVDQVBUQ0hBX1RPS0VOJyxcbiAgSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OID0gJ0lOVkFMSURfUkVDQVBUQ0hBX0FDVElPTicsXG4gIE1JU1NJTkdfQ0xJRU5UX1RZUEUgPSAnTUlTU0lOR19DTElFTlRfVFlQRScsXG4gIE1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT04gPSAnTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTicsXG4gIElOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gPSAnSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTicsXG4gIElOVkFMSURfUkVRX1RZUEUgPSAnSU5WQUxJRF9SRVFfVFlQRSdcbn1cblxuLyoqXG4gKiBBUEkgUmVzcG9uc2UgaW4gdGhlIGV2ZW50IG9mIGFuIGVycm9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSnNvbkVycm9yIHtcbiAgZXJyb3I6IHtcbiAgICBjb2RlOiBudW1iZXI7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIGVycm9ycz86IFtcbiAgICAgIHtcbiAgICAgICAgbWVzc2FnZTogU2VydmVyRXJyb3I7XG4gICAgICAgIGRvbWFpbjogc3RyaW5nO1xuICAgICAgICByZWFzb246IHN0cmluZztcbiAgICAgIH1cbiAgICBdO1xuICB9O1xufVxuXG4vKipcbiAqIFR5cGUgZGVmaW5pdGlvbiBmb3IgYSBtYXAgZnJvbSBzZXJ2ZXIgZXJyb3JzIHRvIGRldmVsb3BlciB2aXNpYmxlIGVycm9yc1xuICovXG5leHBvcnQgZGVjbGFyZSB0eXBlIFNlcnZlckVycm9yTWFwPEFwaUVycm9yIGV4dGVuZHMgc3RyaW5nPiA9IHtcbiAgcmVhZG9ubHkgW0sgaW4gQXBpRXJyb3JdOiBBdXRoRXJyb3JDb2RlO1xufTtcblxuLyoqXG4gKiBNYXAgZnJvbSBlcnJvcnMgcmV0dXJuZWQgYnkgdGhlIHNlcnZlciB0byBlcnJvcnMgdG8gZGV2ZWxvcGVyIHZpc2libGUgZXJyb3JzXG4gKi9cbmV4cG9ydCBjb25zdCBTRVJWRVJfRVJST1JfTUFQOiBQYXJ0aWFsPFNlcnZlckVycm9yTWFwPFNlcnZlckVycm9yPj4gPSB7XG4gIC8vIEN1c3RvbSB0b2tlbiBlcnJvcnMuXG4gIFtTZXJ2ZXJFcnJvci5DUkVERU5USUFMX01JU01BVENIXTogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX01JU01BVENILFxuICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXG4gIFtTZXJ2ZXJFcnJvci5NSVNTSU5HX0NVU1RPTV9UT0tFTl06IEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IsXG5cbiAgLy8gQ3JlYXRlIEF1dGggVVJJIGVycm9ycy5cbiAgW1NlcnZlckVycm9yLklOVkFMSURfSURFTlRJRklFUl06IEF1dGhFcnJvckNvZGUuSU5WQUxJRF9FTUFJTCxcbiAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxuICBbU2VydmVyRXJyb3IuTUlTU0lOR19DT05USU5VRV9VUkldOiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SLFxuXG4gIC8vIFNpZ24gaW4gd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQgZXJyb3JzIChzb21lIGFwcGx5IHRvIHNpZ24gdXAgdG9vKS5cbiAgW1NlcnZlckVycm9yLklOVkFMSURfUEFTU1dPUkRdOiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUEFTU1dPUkQsXG4gIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cbiAgW1NlcnZlckVycm9yLk1JU1NJTkdfUEFTU1dPUkRdOiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUEFTU1dPUkQsXG5cbiAgLy8gU2lnbiB1cCB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZCBlcnJvcnMuXG4gIFtTZXJ2ZXJFcnJvci5FTUFJTF9FWElTVFNdOiBBdXRoRXJyb3JDb2RlLkVNQUlMX0VYSVNUUyxcbiAgW1NlcnZlckVycm9yLlBBU1NXT1JEX0xPR0lOX0RJU0FCTEVEXTogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX0FMTE9XRUQsXG5cbiAgLy8gVmVyaWZ5IGFzc2VydGlvbiBmb3Igc2lnbiBpbiB3aXRoIGNyZWRlbnRpYWwgZXJyb3JzOlxuICBbU2VydmVyRXJyb3IuSU5WQUxJRF9JRFBfUkVTUE9OU0VdOiBBdXRoRXJyb3JDb2RlLklOVkFMSURfSURQX1JFU1BPTlNFLFxuICBbU2VydmVyRXJyb3IuSU5WQUxJRF9QRU5ESU5HX1RPS0VOXTogQXV0aEVycm9yQ29kZS5JTlZBTElEX0lEUF9SRVNQT05TRSxcbiAgW1NlcnZlckVycm9yLkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEXTpcbiAgICBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0UsXG5cbiAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxuICBbU2VydmVyRXJyb3IuTUlTU0lOR19SRVFfVFlQRV06IEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IsXG5cbiAgLy8gU2VuZCBQYXNzd29yZCByZXNldCBlbWFpbCBlcnJvcnM6XG4gIFtTZXJ2ZXJFcnJvci5FTUFJTF9OT1RfRk9VTkRdOiBBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRCxcbiAgW1NlcnZlckVycm9yLlJFU0VUX1BBU1NXT1JEX0VYQ0VFRF9MSU1JVF06XG4gICAgQXV0aEVycm9yQ29kZS5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVIsXG5cbiAgW1NlcnZlckVycm9yLkVYUElSRURfT09CX0NPREVdOiBBdXRoRXJyb3JDb2RlLkVYUElSRURfT09CX0NPREUsXG4gIFtTZXJ2ZXJFcnJvci5JTlZBTElEX09PQl9DT0RFXTogQXV0aEVycm9yQ29kZS5JTlZBTElEX09PQl9DT0RFLFxuICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXG4gIFtTZXJ2ZXJFcnJvci5NSVNTSU5HX09PQl9DT0RFXTogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUixcblxuICAvLyBPcGVyYXRpb25zIHRoYXQgcmVxdWlyZSBJRCB0b2tlbiBpbiByZXF1ZXN0OlxuICBbU2VydmVyRXJyb3IuQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOXTpcbiAgICBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTixcbiAgW1NlcnZlckVycm9yLklOVkFMSURfSURfVE9LRU5dOiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSCxcbiAgW1NlcnZlckVycm9yLlRPS0VOX0VYUElSRURdOiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQsXG4gIFtTZXJ2ZXJFcnJvci5VU0VSX05PVF9GT1VORF06IEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCxcblxuICAvLyBPdGhlciBlcnJvcnMuXG4gIFtTZXJ2ZXJFcnJvci5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVJdOlxuICAgIEF1dGhFcnJvckNvZGUuVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSLFxuXG4gIC8vIFBob25lIEF1dGggcmVsYXRlZCBlcnJvcnMuXG4gIFtTZXJ2ZXJFcnJvci5JTlZBTElEX0NPREVdOiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09ERSxcbiAgW1NlcnZlckVycm9yLklOVkFMSURfU0VTU0lPTl9JTkZPXTogQXV0aEVycm9yQ29kZS5JTlZBTElEX1NFU1NJT05fSU5GTyxcbiAgW1NlcnZlckVycm9yLklOVkFMSURfVEVNUE9SQVJZX1BST09GXTogQXV0aEVycm9yQ29kZS5JTlZBTElEX0lEUF9SRVNQT05TRSxcbiAgW1NlcnZlckVycm9yLk1JU1NJTkdfU0VTU0lPTl9JTkZPXTogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1NFU1NJT05fSU5GTyxcbiAgW1NlcnZlckVycm9yLlNFU1NJT05fRVhQSVJFRF06IEF1dGhFcnJvckNvZGUuQ09ERV9FWFBJUkVELFxuXG4gIC8vIE90aGVyIGFjdGlvbiBjb2RlIGVycm9ycyB3aGVuIGFkZGl0aW9uYWwgc2V0dGluZ3MgcGFzc2VkLlxuICAvLyBNSVNTSU5HX0NPTlRJTlVFX1VSSSBpcyBnZXR0aW5nIG1hcHBlZCB0byBJTlRFUk5BTF9FUlJPUiBhYm92ZS5cbiAgLy8gVGhpcyBpcyBPSyBhcyB0aGlzIGVycm9yIHdpbGwgYmUgY2F1Z2h0IGJ5IGNsaWVudCBzaWRlIHZhbGlkYXRpb24uXG4gIFtTZXJ2ZXJFcnJvci5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FXTpcbiAgICBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUsXG4gIFtTZXJ2ZXJFcnJvci5VTkFVVEhPUklaRURfRE9NQUlOXTogQXV0aEVycm9yQ29kZS5VTkFVVEhPUklaRURfRE9NQUlOLFxuXG4gIC8vIGdldFByb2plY3RDb25maWcgZXJyb3JzIHdoZW4gY2xpZW50SWQgaXMgcGFzc2VkLlxuICBbU2VydmVyRXJyb3IuSU5WQUxJRF9PQVVUSF9DTElFTlRfSURdOiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT0FVVEhfQ0xJRU5UX0lELFxuXG4gIC8vIFVzZXIgYWN0aW9ucyAoc2lnbi11cCBvciBkZWxldGlvbikgZGlzYWJsZWQgZXJyb3JzLlxuICBbU2VydmVyRXJyb3IuQURNSU5fT05MWV9PUEVSQVRJT05dOiBBdXRoRXJyb3JDb2RlLkFETUlOX09OTFlfT1BFUkFUSU9OLFxuXG4gIC8vIE11bHRpIGZhY3RvciByZWxhdGVkIGVycm9ycy5cbiAgW1NlcnZlckVycm9yLklOVkFMSURfTUZBX1BFTkRJTkdfQ1JFREVOVElBTF06XG4gICAgQXV0aEVycm9yQ29kZS5JTlZBTElEX01GQV9TRVNTSU9OLFxuICBbU2VydmVyRXJyb3IuTUZBX0VOUk9MTE1FTlRfTk9UX0ZPVU5EXTogQXV0aEVycm9yQ29kZS5NRkFfSU5GT19OT1RfRk9VTkQsXG4gIFtTZXJ2ZXJFcnJvci5NSVNTSU5HX01GQV9FTlJPTExNRU5UX0lEXTogQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9JTkZPLFxuICBbU2VydmVyRXJyb3IuTUlTU0lOR19NRkFfUEVORElOR19DUkVERU5USUFMXTpcbiAgICBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX1NFU1NJT04sXG4gIFtTZXJ2ZXJFcnJvci5TRUNPTkRfRkFDVE9SX0VYSVNUU106XG4gICAgQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0FMUkVBRFlfRU5ST0xMRUQsXG4gIFtTZXJ2ZXJFcnJvci5TRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEXTpcbiAgICBBdXRoRXJyb3JDb2RlLlNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQsXG5cbiAgLy8gQmxvY2tpbmcgZnVuY3Rpb25zIHJlbGF0ZWQgZXJyb3JzLlxuICBbU2VydmVyRXJyb3IuQkxPQ0tJTkdfRlVOQ1RJT05fRVJST1JfUkVTUE9OU0VdOiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SLFxuXG4gIC8vIFJlY2FwdGNoYSByZWxhdGVkIGVycm9ycy5cbiAgW1NlcnZlckVycm9yLlJFQ0FQVENIQV9OT1RfRU5BQkxFRF06IEF1dGhFcnJvckNvZGUuUkVDQVBUQ0hBX05PVF9FTkFCTEVELFxuICBbU2VydmVyRXJyb3IuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU5dOiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOLFxuICBbU2VydmVyRXJyb3IuSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU5dOiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOLFxuICBbU2VydmVyRXJyb3IuSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OXTpcbiAgICBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTixcbiAgW1NlcnZlckVycm9yLk1JU1NJTkdfQ0xJRU5UX1RZUEVdOiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ0xJRU5UX1RZUEUsXG4gIFtTZXJ2ZXJFcnJvci5NSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OXTpcbiAgICBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT04sXG4gIFtTZXJ2ZXJFcnJvci5JTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OXTpcbiAgICBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04sXG4gIFtTZXJ2ZXJFcnJvci5JTlZBTElEX1JFUV9UWVBFXTogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFUV9UWVBFXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciwgcXVlcnlzdHJpbmcgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmltcG9ydCB7IEF1dGhFcnJvckNvZGUsIE5hbWVkRXJyb3JQYXJhbXMgfSBmcm9tICcuLi9jb3JlL2Vycm9ycyc7XG5pbXBvcnQge1xuICBfY3JlYXRlRXJyb3IsXG4gIF9lcnJvcldpdGhDdXN0b21NZXNzYWdlLFxuICBfZmFpbFxufSBmcm9tICcuLi9jb3JlL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IERlbGF5IH0gZnJvbSAnLi4vY29yZS91dGlsL2RlbGF5JztcbmltcG9ydCB7IF9lbXVsYXRvclVybCB9IGZyb20gJy4uL2NvcmUvdXRpbC9lbXVsYXRvcic7XG5pbXBvcnQgeyBGZXRjaFByb3ZpZGVyIH0gZnJvbSAnLi4vY29yZS91dGlsL2ZldGNoX3Byb3ZpZGVyJztcbmltcG9ydCB7IEF1dGggfSBmcm9tICcuLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsLCBDb25maWdJbnRlcm5hbCB9IGZyb20gJy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlLCBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IElkVG9rZW5NZmFSZXNwb25zZSB9IGZyb20gJy4vYXV0aGVudGljYXRpb24vbWZhJztcbmltcG9ydCB7IFNFUlZFUl9FUlJPUl9NQVAsIFNlcnZlckVycm9yLCBTZXJ2ZXJFcnJvck1hcCB9IGZyb20gJy4vZXJyb3JzJztcblxuZXhwb3J0IGNvbnN0IGVudW0gSHR0cE1ldGhvZCB7XG4gIFBPU1QgPSAnUE9TVCcsXG4gIEdFVCA9ICdHRVQnXG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIEh0dHBIZWFkZXIge1xuICBDT05URU5UX1RZUEUgPSAnQ29udGVudC1UeXBlJyxcbiAgWF9GSVJFQkFTRV9MT0NBTEUgPSAnWC1GaXJlYmFzZS1Mb2NhbGUnLFxuICBYX0NMSUVOVF9WRVJTSU9OID0gJ1gtQ2xpZW50LVZlcnNpb24nLFxuICBYX0ZJUkVCQVNFX0dNUElEID0gJ1gtRmlyZWJhc2UtZ21waWQnLFxuICBYX0ZJUkVCQVNFX0NMSUVOVCA9ICdYLUZpcmViYXNlLUNsaWVudCcsXG4gIFhfRklSRUJBU0VfQVBQX0NIRUNLID0gJ1gtRmlyZWJhc2UtQXBwQ2hlY2snXG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIEVuZHBvaW50IHtcbiAgQ1JFQVRFX0FVVEhfVVJJID0gJy92MS9hY2NvdW50czpjcmVhdGVBdXRoVXJpJyxcbiAgREVMRVRFX0FDQ09VTlQgPSAnL3YxL2FjY291bnRzOmRlbGV0ZScsXG4gIFJFU0VUX1BBU1NXT1JEID0gJy92MS9hY2NvdW50czpyZXNldFBhc3N3b3JkJyxcbiAgU0lHTl9VUCA9ICcvdjEvYWNjb3VudHM6c2lnblVwJyxcbiAgU0lHTl9JTl9XSVRIX0NVU1RPTV9UT0tFTiA9ICcvdjEvYWNjb3VudHM6c2lnbkluV2l0aEN1c3RvbVRva2VuJyxcbiAgU0lHTl9JTl9XSVRIX0VNQUlMX0xJTksgPSAnL3YxL2FjY291bnRzOnNpZ25JbldpdGhFbWFpbExpbmsnLFxuICBTSUdOX0lOX1dJVEhfSURQID0gJy92MS9hY2NvdW50czpzaWduSW5XaXRoSWRwJyxcbiAgU0lHTl9JTl9XSVRIX1BBU1NXT1JEID0gJy92MS9hY2NvdW50czpzaWduSW5XaXRoUGFzc3dvcmQnLFxuICBTSUdOX0lOX1dJVEhfUEhPTkVfTlVNQkVSID0gJy92MS9hY2NvdW50czpzaWduSW5XaXRoUGhvbmVOdW1iZXInLFxuICBTRU5EX1ZFUklGSUNBVElPTl9DT0RFID0gJy92MS9hY2NvdW50czpzZW5kVmVyaWZpY2F0aW9uQ29kZScsXG4gIFNFTkRfT09CX0NPREUgPSAnL3YxL2FjY291bnRzOnNlbmRPb2JDb2RlJyxcbiAgU0VUX0FDQ09VTlRfSU5GTyA9ICcvdjEvYWNjb3VudHM6dXBkYXRlJyxcbiAgR0VUX0FDQ09VTlRfSU5GTyA9ICcvdjEvYWNjb3VudHM6bG9va3VwJyxcbiAgR0VUX1JFQ0FQVENIQV9QQVJBTSA9ICcvdjEvcmVjYXB0Y2hhUGFyYW1zJyxcbiAgU1RBUlRfTUZBX0VOUk9MTE1FTlQgPSAnL3YyL2FjY291bnRzL21mYUVucm9sbG1lbnQ6c3RhcnQnLFxuICBGSU5BTElaRV9NRkFfRU5ST0xMTUVOVCA9ICcvdjIvYWNjb3VudHMvbWZhRW5yb2xsbWVudDpmaW5hbGl6ZScsXG4gIFNUQVJUX01GQV9TSUdOX0lOID0gJy92Mi9hY2NvdW50cy9tZmFTaWduSW46c3RhcnQnLFxuICBGSU5BTElaRV9NRkFfU0lHTl9JTiA9ICcvdjIvYWNjb3VudHMvbWZhU2lnbkluOmZpbmFsaXplJyxcbiAgV0lUSERSQVdfTUZBID0gJy92Mi9hY2NvdW50cy9tZmFFbnJvbGxtZW50OndpdGhkcmF3JyxcbiAgR0VUX1BST0pFQ1RfQ09ORklHID0gJy92MS9wcm9qZWN0cycsXG4gIEdFVF9SRUNBUFRDSEFfQ09ORklHID0gJy92Mi9yZWNhcHRjaGFDb25maWcnXG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIFJlY2FwdGNoYUNsaWVudFR5cGUge1xuICBXRUIgPSAnQ0xJRU5UX1RZUEVfV0VCJyxcbiAgQU5EUk9JRCA9ICdDTElFTlRfVFlQRV9BTkRST0lEJyxcbiAgSU9TID0gJ0NMSUVOVF9UWVBFX0lPUydcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gUmVjYXB0Y2hhVmVyc2lvbiB7XG4gIEVOVEVSUFJJU0UgPSAnUkVDQVBUQ0hBX0VOVEVSUFJJU0UnXG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIFJlY2FwdGNoYUFjdGlvbk5hbWUge1xuICBTSUdOX0lOX1dJVEhfUEFTU1dPUkQgPSAnc2lnbkluV2l0aFBhc3N3b3JkJyxcbiAgR0VUX09PQl9DT0RFID0gJ2dldE9vYkNvZGUnLFxuICBTSUdOX1VQX1BBU1NXT1JEID0gJ3NpZ25VcFBhc3N3b3JkJ1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9BUElfVElNRU9VVF9NUyA9IG5ldyBEZWxheSgzMF8wMDAsIDYwXzAwMCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfYWRkVGlkSWZOZWNlc3Nhcnk8VCBleHRlbmRzIHsgdGVuYW50SWQ/OiBzdHJpbmcgfT4oXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFRcbik6IFQge1xuICBpZiAoYXV0aC50ZW5hbnRJZCAmJiAhcmVxdWVzdC50ZW5hbnRJZCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXF1ZXN0LFxuICAgICAgdGVuYW50SWQ6IGF1dGgudGVuYW50SWRcbiAgICB9O1xuICB9XG4gIHJldHVybiByZXF1ZXN0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3BlcmZvcm1BcGlSZXF1ZXN0PFQsIFY+KFxuICBhdXRoOiBBdXRoLFxuICBtZXRob2Q6IEh0dHBNZXRob2QsXG4gIHBhdGg6IEVuZHBvaW50LFxuICByZXF1ZXN0PzogVCxcbiAgY3VzdG9tRXJyb3JNYXA6IFBhcnRpYWw8U2VydmVyRXJyb3JNYXA8U2VydmVyRXJyb3I+PiA9IHt9XG4pOiBQcm9taXNlPFY+IHtcbiAgcmV0dXJuIF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhhdXRoLCBjdXN0b21FcnJvck1hcCwgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBib2R5ID0ge307XG4gICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICBpZiAobWV0aG9kID09PSBIdHRwTWV0aG9kLkdFVCkge1xuICAgICAgICBwYXJhbXMgPSByZXF1ZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm9keSA9IHtcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5ID0gcXVlcnlzdHJpbmcoe1xuICAgICAga2V5OiBhdXRoLmNvbmZpZy5hcGlLZXksXG4gICAgICAuLi5wYXJhbXNcbiAgICB9KS5zbGljZSgxKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCAoYXV0aCBhcyBBdXRoSW50ZXJuYWwpLl9nZXRBZGRpdGlvbmFsSGVhZGVycygpO1xuICAgIGhlYWRlcnNbSHR0cEhlYWRlci5DT05URU5UX1RZUEVdID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuXG4gICAgaWYgKGF1dGgubGFuZ3VhZ2VDb2RlKSB7XG4gICAgICBoZWFkZXJzW0h0dHBIZWFkZXIuWF9GSVJFQkFTRV9MT0NBTEVdID0gYXV0aC5sYW5ndWFnZUNvZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZldGNoUHJvdmlkZXIuZmV0Y2goKShcbiAgICAgIF9nZXRGaW5hbFRhcmdldChhdXRoLCBhdXRoLmNvbmZpZy5hcGlIb3N0LCBwYXRoLCBxdWVyeSksXG4gICAgICB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlcicsXG4gICAgICAgIC4uLmJvZHlcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZzxWPihcbiAgYXV0aDogQXV0aCxcbiAgY3VzdG9tRXJyb3JNYXA6IFBhcnRpYWw8U2VydmVyRXJyb3JNYXA8U2VydmVyRXJyb3I+PixcbiAgZmV0Y2hGbjogKCkgPT4gUHJvbWlzZTxSZXNwb25zZT5cbik6IFByb21pc2U8Vj4ge1xuICAoYXV0aCBhcyBBdXRoSW50ZXJuYWwpLl9jYW5Jbml0RW11bGF0b3IgPSBmYWxzZTtcbiAgY29uc3QgZXJyb3JNYXAgPSB7IC4uLlNFUlZFUl9FUlJPUl9NQVAsIC4uLmN1c3RvbUVycm9yTWFwIH07XG4gIHRyeSB7XG4gICAgY29uc3QgbmV0d29ya1RpbWVvdXQgPSBuZXcgTmV0d29ya1RpbWVvdXQ8UmVzcG9uc2U+KGF1dGgpO1xuICAgIGNvbnN0IHJlc3BvbnNlOiBSZXNwb25zZSA9IGF3YWl0IFByb21pc2UucmFjZTxQcm9taXNlPFJlc3BvbnNlPj4oW1xuICAgICAgZmV0Y2hGbigpLFxuICAgICAgbmV0d29ya1RpbWVvdXQucHJvbWlzZVxuICAgIF0pO1xuXG4gICAgLy8gSWYgd2UndmUgcmVhY2hlZCB0aGlzIHBvaW50LCB0aGUgZmV0Y2ggc3VjY2VlZGVkIGFuZCB0aGUgbmV0d29ya1RpbWVvdXRcbiAgICAvLyBkaWRuJ3QgdGhyb3c7IGNsZWFyIHRoZSBuZXR3b3JrIHRpbWVvdXQgZGVsYXkgc28gdGhhdCBOb2RlIHdvbid0IGhhbmdcbiAgICBuZXR3b3JrVGltZW91dC5jbGVhck5ldHdvcmtUaW1lb3V0KCk7XG5cbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmICgnbmVlZENvbmZpcm1hdGlvbicgaW4ganNvbikge1xuICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OLCBqc29uKTtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2Uub2sgJiYgISgnZXJyb3JNZXNzYWdlJyBpbiBqc29uKSkge1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLm9rID8ganNvbi5lcnJvck1lc3NhZ2UgOiBqc29uLmVycm9yLm1lc3NhZ2U7XG4gICAgICBjb25zdCBbc2VydmVyRXJyb3JDb2RlLCBzZXJ2ZXJFcnJvck1lc3NhZ2VdID0gZXJyb3JNZXNzYWdlLnNwbGl0KCcgOiAnKTtcbiAgICAgIGlmIChzZXJ2ZXJFcnJvckNvZGUgPT09IFNlcnZlckVycm9yLkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEKSB7XG4gICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoXG4gICAgICAgICAgYXV0aCxcbiAgICAgICAgICBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0UsXG4gICAgICAgICAganNvblxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChzZXJ2ZXJFcnJvckNvZGUgPT09IFNlcnZlckVycm9yLkVNQUlMX0VYSVNUUykge1xuICAgICAgICB0aHJvdyBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIEF1dGhFcnJvckNvZGUuRU1BSUxfRVhJU1RTLCBqc29uKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VydmVyRXJyb3JDb2RlID09PSBTZXJ2ZXJFcnJvci5VU0VSX0RJU0FCTEVEKSB7XG4gICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgQXV0aEVycm9yQ29kZS5VU0VSX0RJU0FCTEVELCBqc29uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF1dGhFcnJvciA9XG4gICAgICAgIGVycm9yTWFwW3NlcnZlckVycm9yQ29kZSBhcyBTZXJ2ZXJFcnJvcl0gfHxcbiAgICAgICAgKHNlcnZlckVycm9yQ29kZVxuICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgLnJlcGxhY2UoL1tfXFxzXSsvZywgJy0nKSBhcyB1bmtub3duIGFzIEF1dGhFcnJvckNvZGUpO1xuICAgICAgaWYgKHNlcnZlckVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBfZXJyb3JXaXRoQ3VzdG9tTWVzc2FnZShhdXRoLCBhdXRoRXJyb3IsIHNlcnZlckVycm9yTWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZmFpbChhdXRoLCBhdXRoRXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgLy8gQ2hhbmdpbmcgdGhpcyB0byBhIGRpZmZlcmVudCBlcnJvciBjb2RlIHdpbGwgbG9nIHVzZXIgb3V0IHdoZW4gdGhlcmUgaXMgYSBuZXR3b3JrIGVycm9yXG4gICAgLy8gYmVjYXVzZSB3ZSB0cmVhdCBhbnkgZXJyb3Igb3RoZXIgdGhhbiBORVRXT1JLX1JFUVVFU1RfRkFJTEVEIGFzIHRva2VuIGlzIGludmFsaWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9ibG9iLzRmYmM3MzYxMGQ3MGJlNGUwODUyZTdkZTYzYTM5Y2I3ODk3ZTg1NDYvcGFja2FnZXMvYXV0aC9zcmMvY29yZS9hdXRoL2F1dGhfaW1wbC50cyNMMzA5LUwzMTZcbiAgICBfZmFpbChhdXRoLCBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQsIHsgJ21lc3NhZ2UnOiBTdHJpbmcoZSkgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9wZXJmb3JtU2lnbkluUmVxdWVzdDxULCBWIGV4dGVuZHMgSWRUb2tlblJlc3BvbnNlPihcbiAgYXV0aDogQXV0aCxcbiAgbWV0aG9kOiBIdHRwTWV0aG9kLFxuICBwYXRoOiBFbmRwb2ludCxcbiAgcmVxdWVzdD86IFQsXG4gIGN1c3RvbUVycm9yTWFwOiBQYXJ0aWFsPFNlcnZlckVycm9yTWFwPFNlcnZlckVycm9yPj4gPSB7fVxuKTogUHJvbWlzZTxWPiB7XG4gIGNvbnN0IHNlcnZlclJlc3BvbnNlID0gKGF3YWl0IF9wZXJmb3JtQXBpUmVxdWVzdDxULCBWIHwgSWRUb2tlbk1mYVJlc3BvbnNlPihcbiAgICBhdXRoLFxuICAgIG1ldGhvZCxcbiAgICBwYXRoLFxuICAgIHJlcXVlc3QsXG4gICAgY3VzdG9tRXJyb3JNYXBcbiAgKSkgYXMgVjtcbiAgaWYgKCdtZmFQZW5kaW5nQ3JlZGVudGlhbCcgaW4gc2VydmVyUmVzcG9uc2UpIHtcbiAgICBfZmFpbChhdXRoLCBBdXRoRXJyb3JDb2RlLk1GQV9SRVFVSVJFRCwge1xuICAgICAgX3NlcnZlclJlc3BvbnNlOiBzZXJ2ZXJSZXNwb25zZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHNlcnZlclJlc3BvbnNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dldEZpbmFsVGFyZ2V0KFxuICBhdXRoOiBBdXRoLFxuICBob3N0OiBzdHJpbmcsXG4gIHBhdGg6IHN0cmluZyxcbiAgcXVlcnk6IHN0cmluZ1xuKTogc3RyaW5nIHtcbiAgY29uc3QgYmFzZSA9IGAke2hvc3R9JHtwYXRofT8ke3F1ZXJ5fWA7XG5cbiAgaWYgKCEoYXV0aCBhcyBBdXRoSW50ZXJuYWwpLmNvbmZpZy5lbXVsYXRvcikge1xuICAgIHJldHVybiBgJHthdXRoLmNvbmZpZy5hcGlTY2hlbWV9Oi8vJHtiYXNlfWA7XG4gIH1cblxuICByZXR1cm4gX2VtdWxhdG9yVXJsKGF1dGguY29uZmlnIGFzIENvbmZpZ0ludGVybmFsLCBiYXNlKTtcbn1cblxuY2xhc3MgTmV0d29ya1RpbWVvdXQ8VD4ge1xuICAvLyBOb2RlIHRpbWVycyBhbmQgYnJvd3NlciB0aW1lcnMgYXJlIGZ1bmRhbWVudGFsbHkgaW5jb21wYXRpYmxlLCBidXQgd2VcbiAgLy8gZG9uJ3QgY2FyZSBhYm91dCB0aGUgdmFsdWUgaGVyZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBwcml2YXRlIHRpbWVyOiBhbnkgfCBudWxsID0gbnVsbDtcbiAgcmVhZG9ubHkgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChfLCByZWplY3QpID0+IHtcbiAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICBfY3JlYXRlRXJyb3IodGhpcy5hdXRoLCBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQpXG4gICAgICApO1xuICAgIH0sIERFRkFVTFRfQVBJX1RJTUVPVVRfTVMuZ2V0KCkpO1xuICB9KTtcblxuICBjbGVhck5ldHdvcmtUaW1lb3V0KCk6IHZvaWQge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXV0aDogQXV0aCkge31cbn1cblxuaW50ZXJmYWNlIFBvdGVudGlhbFJlc3BvbnNlIGV4dGVuZHMgSWRUb2tlblJlc3BvbnNlIHtcbiAgZW1haWw/OiBzdHJpbmc7XG4gIHBob25lTnVtYmVyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX21ha2VUYWdnZWRFcnJvcihcbiAgYXV0aDogQXV0aCxcbiAgY29kZTogQXV0aEVycm9yQ29kZSxcbiAgcmVzcG9uc2U6IFBvdGVudGlhbFJlc3BvbnNlXG4pOiBGaXJlYmFzZUVycm9yIHtcbiAgY29uc3QgZXJyb3JQYXJhbXM6IE5hbWVkRXJyb3JQYXJhbXMgPSB7XG4gICAgYXBwTmFtZTogYXV0aC5uYW1lXG4gIH07XG5cbiAgaWYgKHJlc3BvbnNlLmVtYWlsKSB7XG4gICAgZXJyb3JQYXJhbXMuZW1haWwgPSByZXNwb25zZS5lbWFpbDtcbiAgfVxuICBpZiAocmVzcG9uc2UucGhvbmVOdW1iZXIpIHtcbiAgICBlcnJvclBhcmFtcy5waG9uZU51bWJlciA9IHJlc3BvbnNlLnBob25lTnVtYmVyO1xuICB9XG5cbiAgY29uc3QgZXJyb3IgPSBfY3JlYXRlRXJyb3IoYXV0aCwgY29kZSwgZXJyb3JQYXJhbXMpO1xuXG4gIC8vIFdlIGtub3cgY3VzdG9tRGF0YSBpcyBkZWZpbmVkIG9uIGVycm9yIGJlY2F1c2UgZXJyb3JQYXJhbXMgaXMgZGVmaW5lZFxuICAoZXJyb3IuY3VzdG9tRGF0YSEgYXMgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2UpLl90b2tlblJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEVuZHBvaW50LCBIdHRwTWV0aG9kLCBfcGVyZm9ybUFwaVJlcXVlc3QgfSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBNZmFFbnJvbGxtZW50IH0gZnJvbSAnLi9tZmEnO1xuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVsZXRlQWNjb3VudFJlcXVlc3Qge1xuICBpZFRva2VuOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVBY2NvdW50KFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBEZWxldGVBY2NvdW50UmVxdWVzdFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8RGVsZXRlQWNjb3VudFJlcXVlc3QsIHZvaWQ+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LkRFTEVURV9BQ0NPVU5ULFxuICAgIHJlcXVlc3RcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm92aWRlclVzZXJJbmZvIHtcbiAgcHJvdmlkZXJJZDogc3RyaW5nO1xuICByYXdJZD86IHN0cmluZztcbiAgZW1haWw/OiBzdHJpbmc7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICBwaG90b1VybD86IHN0cmluZztcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVsZXRlTGlua2VkQWNjb3VudHNSZXF1ZXN0IHtcbiAgaWRUb2tlbjogc3RyaW5nO1xuICBkZWxldGVQcm92aWRlcjogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVsZXRlTGlua2VkQWNjb3VudHNSZXNwb25zZSB7XG4gIHByb3ZpZGVyVXNlckluZm86IFByb3ZpZGVyVXNlckluZm9bXTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUxpbmtlZEFjY291bnRzKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBEZWxldGVMaW5rZWRBY2NvdW50c1JlcXVlc3Rcbik6IFByb21pc2U8RGVsZXRlTGlua2VkQWNjb3VudHNSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PFxuICAgIERlbGV0ZUxpbmtlZEFjY291bnRzUmVxdWVzdCxcbiAgICBEZWxldGVMaW5rZWRBY2NvdW50c1Jlc3BvbnNlXG4gID4oYXV0aCwgSHR0cE1ldGhvZC5QT1NULCBFbmRwb2ludC5TRVRfQUNDT1VOVF9JTkZPLCByZXF1ZXN0KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBUElVc2VySW5mbyB7XG4gIGxvY2FsSWQ/OiBzdHJpbmc7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICBwaG90b1VybD86IHN0cmluZztcbiAgZW1haWw/OiBzdHJpbmc7XG4gIGVtYWlsVmVyaWZpZWQ/OiBib29sZWFuO1xuICBwaG9uZU51bWJlcj86IHN0cmluZztcbiAgbGFzdExvZ2luQXQ/OiBudW1iZXI7XG4gIGNyZWF0ZWRBdD86IG51bWJlcjtcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG4gIHBhc3N3b3JkSGFzaD86IHN0cmluZztcbiAgcHJvdmlkZXJVc2VySW5mbz86IFByb3ZpZGVyVXNlckluZm9bXTtcbiAgbWZhSW5mbz86IE1mYUVucm9sbG1lbnRbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRBY2NvdW50SW5mb1JlcXVlc3Qge1xuICBpZFRva2VuOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0QWNjb3VudEluZm9SZXNwb25zZSB7XG4gIHVzZXJzOiBBUElVc2VySW5mb1tdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudEluZm8oXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IEdldEFjY291bnRJbmZvUmVxdWVzdFxuKTogUHJvbWlzZTxHZXRBY2NvdW50SW5mb1Jlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8R2V0QWNjb3VudEluZm9SZXF1ZXN0LCBHZXRBY2NvdW50SW5mb1Jlc3BvbnNlPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5HRVRfQUNDT1VOVF9JTkZPLFxuICAgIHJlcXVlc3RcbiAgKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoXG4gIHV0Y1RpbWVzdGFtcD86IHN0cmluZyB8IG51bWJlclxuKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCF1dGNUaW1lc3RhbXApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gQ29udmVydCB0byBkYXRlIG9iamVjdC5cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoTnVtYmVyKHV0Y1RpbWVzdGFtcCkpO1xuICAgIC8vIFRlc3QgZGF0ZSBpcyB2YWxpZC5cbiAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgLy8gQ29udmVydCB0byBVVEMgZGF0ZSBzdHJpbmcuXG4gICAgICByZXR1cm4gZGF0ZS50b1VUQ1N0cmluZygpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIERvIG5vdGhpbmcuIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJZFRva2VuUmVzdWx0LCBQYXJzZWRUb2tlbiwgVXNlciB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBiYXNlNjREZWNvZGUsIGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgX2xvZ0Vycm9yIH0gZnJvbSAnLi4vdXRpbC9sb2cnO1xuaW1wb3J0IHsgdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nIH0gZnJvbSAnLi4vdXRpbC90aW1lJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG4vKipcbiAqIFJldHVybnMgYSBKU09OIFdlYiBUb2tlbiAoSldUKSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB1c2VyIHRvIGEgRmlyZWJhc2Ugc2VydmljZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogUmV0dXJucyB0aGUgY3VycmVudCB0b2tlbiBpZiBpdCBoYXMgbm90IGV4cGlyZWQgb3IgaWYgaXQgd2lsbCBub3QgZXhwaXJlIGluIHRoZSBuZXh0IGZpdmVcbiAqIG1pbnV0ZXMuIE90aGVyd2lzZSwgdGhpcyB3aWxsIHJlZnJlc2ggdGhlIHRva2VuIGFuZCByZXR1cm4gYSBuZXcgb25lLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gRm9yY2UgcmVmcmVzaCByZWdhcmRsZXNzIG9mIHRva2VuIGV4cGlyYXRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWRUb2tlbih1c2VyOiBVc2VyLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikuZ2V0SWRUb2tlbihmb3JjZVJlZnJlc2gpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBkZXNlcmlhbGl6ZWQgSlNPTiBXZWIgVG9rZW4gKEpXVCkgdXNlZCB0byBpZGVudGlmeSB0aGUgdXNlciB0byBhIEZpcmViYXNlIHNlcnZpY2UuXG4gKlxuICogQHJlbWFya3NcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdG9rZW4gaWYgaXQgaGFzIG5vdCBleHBpcmVkIG9yIGlmIGl0IHdpbGwgbm90IGV4cGlyZSBpbiB0aGUgbmV4dCBmaXZlXG4gKiBtaW51dGVzLiBPdGhlcndpc2UsIHRoaXMgd2lsbCByZWZyZXNoIHRoZSB0b2tlbiBhbmQgcmV0dXJuIGEgbmV3IG9uZS5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIGZvcmNlUmVmcmVzaCAtIEZvcmNlIHJlZnJlc2ggcmVnYXJkbGVzcyBvZiB0b2tlbiBleHBpcmF0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldElkVG9rZW5SZXN1bHQoXG4gIHVzZXI6IFVzZXIsXG4gIGZvcmNlUmVmcmVzaCA9IGZhbHNlXG4pOiBQcm9taXNlPElkVG9rZW5SZXN1bHQ+IHtcbiAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpIGFzIFVzZXJJbnRlcm5hbDtcbiAgY29uc3QgdG9rZW4gPSBhd2FpdCB1c2VySW50ZXJuYWwuZ2V0SWRUb2tlbihmb3JjZVJlZnJlc2gpO1xuICBjb25zdCBjbGFpbXMgPSBfcGFyc2VUb2tlbih0b2tlbik7XG5cbiAgX2Fzc2VydChcbiAgICBjbGFpbXMgJiYgY2xhaW1zLmV4cCAmJiBjbGFpbXMuYXV0aF90aW1lICYmIGNsYWltcy5pYXQsXG4gICAgdXNlckludGVybmFsLmF1dGgsXG4gICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUlxuICApO1xuICBjb25zdCBmaXJlYmFzZSA9XG4gICAgdHlwZW9mIGNsYWltcy5maXJlYmFzZSA9PT0gJ29iamVjdCcgPyBjbGFpbXMuZmlyZWJhc2UgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3Qgc2lnbkluUHJvdmlkZXI6IHN0cmluZyB8IHVuZGVmaW5lZCA9IGZpcmViYXNlPy5bJ3NpZ25faW5fcHJvdmlkZXInXTtcblxuICByZXR1cm4ge1xuICAgIGNsYWltcyxcbiAgICB0b2tlbixcbiAgICBhdXRoVGltZTogdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKFxuICAgICAgc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5hdXRoX3RpbWUpXG4gICAgKSEsXG4gICAgaXNzdWVkQXRUaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoXG4gICAgICBzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoY2xhaW1zLmlhdClcbiAgICApISxcbiAgICBleHBpcmF0aW9uVGltZTogdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKFxuICAgICAgc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5leHApXG4gICAgKSEsXG4gICAgc2lnbkluUHJvdmlkZXI6IHNpZ25JblByb3ZpZGVyIHx8IG51bGwsXG4gICAgc2lnbkluU2Vjb25kRmFjdG9yOiBmaXJlYmFzZT8uWydzaWduX2luX3NlY29uZF9mYWN0b3InXSB8fCBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlY29uZHNTdHJpbmdUb01pbGxpc2Vjb25kcyhzZWNvbmRzOiBzdHJpbmcpOiBudW1iZXIge1xuICByZXR1cm4gTnVtYmVyKHNlY29uZHMpICogMTAwMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZVRva2VuKHRva2VuOiBzdHJpbmcpOiBQYXJzZWRUb2tlbiB8IG51bGwge1xuICBjb25zdCBbYWxnb3JpdGhtLCBwYXlsb2FkLCBzaWduYXR1cmVdID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgaWYgKFxuICAgIGFsZ29yaXRobSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgcGF5bG9hZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgc2lnbmF0dXJlID09PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgX2xvZ0Vycm9yKCdKV1QgbWFsZm9ybWVkLCBjb250YWluZWQgZmV3ZXIgdGhhbiAzIHNlY3Rpb25zJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGRlY29kZWQgPSBiYXNlNjREZWNvZGUocGF5bG9hZCk7XG4gICAgaWYgKCFkZWNvZGVkKSB7XG4gICAgICBfbG9nRXJyb3IoJ0ZhaWxlZCB0byBkZWNvZGUgYmFzZTY0IEpXVCBwYXlsb2FkJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBfbG9nRXJyb3IoXG4gICAgICAnQ2F1Z2h0IGVycm9yIHBhcnNpbmcgSldUIHBheWxvYWQgYXMgSlNPTicsXG4gICAgICAoZSBhcyBFcnJvcik/LnRvU3RyaW5nKClcbiAgICApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBleHBpcmVzSW4gVFRMIGZyb20gYSB0b2tlbiBieSBzdWJ0cmFjdGluZyB0aGUgZXhwaXJhdGlvbiBmcm9tIHRoZSBpc3N1YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF90b2tlbkV4cGlyZXNJbih0b2tlbjogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgcGFyc2VkVG9rZW4gPSBfcGFyc2VUb2tlbih0b2tlbik7XG4gIF9hc3NlcnQocGFyc2VkVG9rZW4sIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICBfYXNzZXJ0KHR5cGVvZiBwYXJzZWRUb2tlbi5leHAgIT09ICd1bmRlZmluZWQnLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgX2Fzc2VydCh0eXBlb2YgcGFyc2VkVG9rZW4uaWF0ICE9PSAndW5kZWZpbmVkJywgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gIHJldHVybiBOdW1iZXIocGFyc2VkVG9rZW4uZXhwKSAtIE51bWJlcihwYXJzZWRUb2tlbi5pYXQpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9sb2dvdXRJZkludmFsaWRhdGVkPFQ+KFxuICB1c2VyOiBVc2VySW50ZXJuYWwsXG4gIHByb21pc2U6IFByb21pc2U8VD4sXG4gIGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlXG4pOiBQcm9taXNlPFQ+IHtcbiAgaWYgKGJ5cGFzc0F1dGhTdGF0ZSkge1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IgJiYgaXNVc2VySW52YWxpZGF0ZWQoZSkpIHtcbiAgICAgIGlmICh1c2VyLmF1dGguY3VycmVudFVzZXIgPT09IHVzZXIpIHtcbiAgICAgICAgYXdhaXQgdXNlci5hdXRoLnNpZ25PdXQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVXNlckludmFsaWRhdGVkKHsgY29kZSB9OiBGaXJlYmFzZUVycm9yKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgY29kZSA9PT0gYGF1dGgvJHtBdXRoRXJyb3JDb2RlLlVTRVJfRElTQUJMRUR9YCB8fFxuICAgIGNvZGUgPT09IGBhdXRoLyR7QXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVEfWBcbiAgKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG4vLyBSZWZyZXNoIHRoZSB0b2tlbiBmaXZlIG1pbnV0ZXMgYmVmb3JlIGV4cGlyYXRpb25cbmV4cG9ydCBjb25zdCBlbnVtIER1cmF0aW9uIHtcbiAgT0ZGU0VUID0gNSAqIDEwMDAgKiA2MCxcbiAgUkVUUllfQkFDS09GRl9NSU4gPSAzMCAqIDEwMDAsXG4gIFJFVFJZX0JBQ0tPRkZfTUFYID0gMTYgKiA2MCAqIDEwMDBcbn1cblxuZXhwb3J0IGNsYXNzIFByb2FjdGl2ZVJlZnJlc2gge1xuICBwcml2YXRlIGlzUnVubmluZyA9IGZhbHNlO1xuXG4gIC8vIE5vZGUgdGltZXJzIGFuZCBicm93c2VyIHRpbWVycyByZXR1cm4gZnVuZGFtZW50YWxseSBkaWZmZXJlbnQgdHlwZXMuXG4gIC8vIFdlIGRvbid0IGFjdHVhbGx5IGNhcmUgd2hhdCB0aGUgdmFsdWUgaXMgYnV0IFRTIHdvbid0IGFjY2VwdCB1bmtub3duIGFuZFxuICAvLyB3ZSBjYW4ndCBjYXN0IHByb3Blcmx5IGluIGJvdGggZW52aXJvbm1lbnRzLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBwcml2YXRlIHRpbWVySWQ6IGFueSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGVycm9yQmFja29mZiA9IER1cmF0aW9uLlJFVFJZX0JBQ0tPRkZfTUlOO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgdXNlcjogVXNlckludGVybmFsKSB7fVxuXG4gIF9zdGFydCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5zY2hlZHVsZSgpO1xuICB9XG5cbiAgX3N0b3AoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMudGltZXJJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRJbnRlcnZhbCh3YXNFcnJvcjogYm9vbGVhbik6IG51bWJlciB7XG4gICAgaWYgKHdhc0Vycm9yKSB7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuZXJyb3JCYWNrb2ZmO1xuICAgICAgdGhpcy5lcnJvckJhY2tvZmYgPSBNYXRoLm1pbihcbiAgICAgICAgdGhpcy5lcnJvckJhY2tvZmYgKiAyLFxuICAgICAgICBEdXJhdGlvbi5SRVRSWV9CQUNLT0ZGX01BWFxuICAgICAgKTtcbiAgICAgIHJldHVybiBpbnRlcnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgdGhlIGVycm9yIGJhY2tvZmZcbiAgICAgIHRoaXMuZXJyb3JCYWNrb2ZmID0gRHVyYXRpb24uUkVUUllfQkFDS09GRl9NSU47XG4gICAgICBjb25zdCBleHBUaW1lID0gdGhpcy51c2VyLnN0c1Rva2VuTWFuYWdlci5leHBpcmF0aW9uVGltZSA/PyAwO1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBleHBUaW1lIC0gRGF0ZS5ub3coKSAtIER1cmF0aW9uLk9GRlNFVDtcblxuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGludGVydmFsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNjaGVkdWxlKHdhc0Vycm9yID0gZmFsc2UpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICAvLyBKdXN0IGluIGNhc2UuLi5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuZ2V0SW50ZXJ2YWwod2FzRXJyb3IpO1xuICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5pdGVyYXRpb24oKTtcbiAgICB9LCBpbnRlcnZhbCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGl0ZXJhdGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy51c2VyLmdldElkVG9rZW4odHJ1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gT25seSByZXRyeSBvbiBuZXR3b3JrIGVycm9yc1xuICAgICAgaWYgKFxuICAgICAgICAoZSBhcyBGaXJlYmFzZUVycm9yKT8uY29kZSA9PT1cbiAgICAgICAgYGF1dGgvJHtBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUR9YFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoLyogd2FzRXJyb3IgKi8gdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zY2hlZHVsZSgpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBVc2VyTWV0YWRhdGEgYXMgVXNlck1ldGFkYXRhVHlwZSB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyB9IGZyb20gJy4uL3V0aWwvdGltZSc7XG5cbmV4cG9ydCBjbGFzcyBVc2VyTWV0YWRhdGEgaW1wbGVtZW50cyBVc2VyTWV0YWRhdGFUeXBlIHtcbiAgY3JlYXRpb25UaW1lPzogc3RyaW5nO1xuICBsYXN0U2lnbkluVGltZT86IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNyZWF0ZWRBdD86IHN0cmluZyB8IG51bWJlcixcbiAgICBwcml2YXRlIGxhc3RMb2dpbkF0Pzogc3RyaW5nIHwgbnVtYmVyXG4gICkge1xuICAgIHRoaXMuX2luaXRpYWxpemVUaW1lKCk7XG4gIH1cblxuICBwcml2YXRlIF9pbml0aWFsaXplVGltZSgpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RTaWduSW5UaW1lID0gdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKHRoaXMubGFzdExvZ2luQXQpO1xuICAgIHRoaXMuY3JlYXRpb25UaW1lID0gdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKHRoaXMuY3JlYXRlZEF0KTtcbiAgfVxuXG4gIF9jb3B5KG1ldGFkYXRhOiBVc2VyTWV0YWRhdGEpOiB2b2lkIHtcbiAgICB0aGlzLmNyZWF0ZWRBdCA9IG1ldGFkYXRhLmNyZWF0ZWRBdDtcbiAgICB0aGlzLmxhc3RMb2dpbkF0ID0gbWV0YWRhdGEubGFzdExvZ2luQXQ7XG4gICAgdGhpcy5faW5pdGlhbGl6ZVRpbWUoKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBvYmplY3Qge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVkQXQ6IHRoaXMuY3JlYXRlZEF0LFxuICAgICAgbGFzdExvZ2luQXQ6IHRoaXMubGFzdExvZ2luQXRcbiAgICB9O1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBVc2VyLCBVc2VySW5mbyB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7XG4gIGdldEFjY291bnRJbmZvLFxuICBQcm92aWRlclVzZXJJbmZvXG59IGZyb20gJy4uLy4uL2FwaS9hY2NvdW50X21hbmFnZW1lbnQvYWNjb3VudCc7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IF9sb2dvdXRJZkludmFsaWRhdGVkIH0gZnJvbSAnLi9pbnZhbGlkYXRpb24nO1xuaW1wb3J0IHsgVXNlck1ldGFkYXRhIH0gZnJvbSAnLi91c2VyX21ldGFkYXRhJztcbmltcG9ydCB7IGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9yZWxvYWRXaXRob3V0U2F2aW5nKHVzZXI6IFVzZXJJbnRlcm5hbCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBhdXRoID0gdXNlci5hdXRoO1xuICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQoXG4gICAgdXNlcixcbiAgICBnZXRBY2NvdW50SW5mbyhhdXRoLCB7IGlkVG9rZW4gfSlcbiAgKTtcblxuICBfYXNzZXJ0KHJlc3BvbnNlPy51c2Vycy5sZW5ndGgsIGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuXG4gIGNvbnN0IGNvcmVBY2NvdW50ID0gcmVzcG9uc2UudXNlcnNbMF07XG5cbiAgdXNlci5fbm90aWZ5UmVsb2FkTGlzdGVuZXIoY29yZUFjY291bnQpO1xuXG4gIGNvbnN0IG5ld1Byb3ZpZGVyRGF0YSA9IGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8/Lmxlbmd0aFxuICAgID8gZXh0cmFjdFByb3ZpZGVyRGF0YShjb3JlQWNjb3VudC5wcm92aWRlclVzZXJJbmZvKVxuICAgIDogW107XG5cbiAgY29uc3QgcHJvdmlkZXJEYXRhID0gbWVyZ2VQcm92aWRlckRhdGEodXNlci5wcm92aWRlckRhdGEsIG5ld1Byb3ZpZGVyRGF0YSk7XG5cbiAgLy8gUHJlc2VydmVzIHRoZSBub24tbm9ueW1vdXMgc3RhdHVzIG9mIHRoZSBzdG9yZWQgdXNlciwgZXZlbiBpZiBubyBtb3JlXG4gIC8vIGNyZWRlbnRpYWxzIChmZWRlcmF0ZWQgb3IgZW1haWwvcGFzc3dvcmQpIGFyZSBsaW5rZWQgdG8gdGhlIHVzZXIuIElmXG4gIC8vIHRoZSB1c2VyIHdhcyBwcmV2aW91c2x5IGFub255bW91cywgdGhlbiB1c2UgcHJvdmlkZXIgZGF0YSB0byB1cGRhdGUuXG4gIC8vIE9uIHRoZSBvdGhlciBoYW5kLCBpZiBpdCB3YXMgbm90IGFub255bW91cyBiZWZvcmUsIGl0IHNob3VsZCBuZXZlciBiZVxuICAvLyBjb25zaWRlcmVkIGFub255bW91cyBub3cuXG4gIGNvbnN0IG9sZElzQW5vbnltb3VzID0gdXNlci5pc0Fub255bW91cztcbiAgY29uc3QgbmV3SXNBbm9ueW1vdXMgPVxuICAgICEodXNlci5lbWFpbCAmJiBjb3JlQWNjb3VudC5wYXNzd29yZEhhc2gpICYmICFwcm92aWRlckRhdGE/Lmxlbmd0aDtcbiAgY29uc3QgaXNBbm9ueW1vdXMgPSAhb2xkSXNBbm9ueW1vdXMgPyBmYWxzZSA6IG5ld0lzQW5vbnltb3VzO1xuXG4gIGNvbnN0IHVwZGF0ZXM6IFBhcnRpYWw8VXNlckludGVybmFsPiA9IHtcbiAgICB1aWQ6IGNvcmVBY2NvdW50LmxvY2FsSWQsXG4gICAgZGlzcGxheU5hbWU6IGNvcmVBY2NvdW50LmRpc3BsYXlOYW1lIHx8IG51bGwsXG4gICAgcGhvdG9VUkw6IGNvcmVBY2NvdW50LnBob3RvVXJsIHx8IG51bGwsXG4gICAgZW1haWw6IGNvcmVBY2NvdW50LmVtYWlsIHx8IG51bGwsXG4gICAgZW1haWxWZXJpZmllZDogY29yZUFjY291bnQuZW1haWxWZXJpZmllZCB8fCBmYWxzZSxcbiAgICBwaG9uZU51bWJlcjogY29yZUFjY291bnQucGhvbmVOdW1iZXIgfHwgbnVsbCxcbiAgICB0ZW5hbnRJZDogY29yZUFjY291bnQudGVuYW50SWQgfHwgbnVsbCxcbiAgICBwcm92aWRlckRhdGEsXG4gICAgbWV0YWRhdGE6IG5ldyBVc2VyTWV0YWRhdGEoY29yZUFjY291bnQuY3JlYXRlZEF0LCBjb3JlQWNjb3VudC5sYXN0TG9naW5BdCksXG4gICAgaXNBbm9ueW1vdXNcbiAgfTtcblxuICBPYmplY3QuYXNzaWduKHVzZXIsIHVwZGF0ZXMpO1xufVxuXG4vKipcbiAqIFJlbG9hZHMgdXNlciBhY2NvdW50IGRhdGEsIGlmIHNpZ25lZCBpbi5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbG9hZCh1c2VyOiBVc2VyKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHVzZXJJbnRlcm5hbDogVXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpIGFzIFVzZXJJbnRlcm5hbDtcbiAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlckludGVybmFsKTtcblxuICAvLyBFdmVuIHRob3VnaCB0aGUgY3VycmVudCB1c2VyIGhhc24ndCBjaGFuZ2VkLCB1cGRhdGVcbiAgLy8gY3VycmVudCB1c2VyIHdpbGwgdHJpZ2dlciBhIHBlcnNpc3RlbmNlIHVwZGF0ZSB3LyB0aGVcbiAgLy8gbmV3IGluZm8uXG4gIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VySW50ZXJuYWwpO1xuICB1c2VySW50ZXJuYWwuYXV0aC5fbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHVzZXJJbnRlcm5hbCk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvdmlkZXJEYXRhKFxuICBvcmlnaW5hbDogVXNlckluZm9bXSxcbiAgbmV3RGF0YTogVXNlckluZm9bXVxuKTogVXNlckluZm9bXSB7XG4gIGNvbnN0IGRlZHVwZWQgPSBvcmlnaW5hbC5maWx0ZXIoXG4gICAgbyA9PiAhbmV3RGF0YS5zb21lKG4gPT4gbi5wcm92aWRlcklkID09PSBvLnByb3ZpZGVySWQpXG4gICk7XG4gIHJldHVybiBbLi4uZGVkdXBlZCwgLi4ubmV3RGF0YV07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm92aWRlckRhdGEocHJvdmlkZXJzOiBQcm92aWRlclVzZXJJbmZvW10pOiBVc2VySW5mb1tdIHtcbiAgcmV0dXJuIHByb3ZpZGVycy5tYXAoKHsgcHJvdmlkZXJJZCwgLi4ucHJvdmlkZXIgfSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBwcm92aWRlcklkLFxuICAgICAgdWlkOiBwcm92aWRlci5yYXdJZCB8fCAnJyxcbiAgICAgIGRpc3BsYXlOYW1lOiBwcm92aWRlci5kaXNwbGF5TmFtZSB8fCBudWxsLFxuICAgICAgZW1haWw6IHByb3ZpZGVyLmVtYWlsIHx8IG51bGwsXG4gICAgICBwaG9uZU51bWJlcjogcHJvdmlkZXIucGhvbmVOdW1iZXIgfHwgbnVsbCxcbiAgICAgIHBob3RvVVJMOiBwcm92aWRlci5waG90b1VybCB8fCBudWxsXG4gICAgfTtcbiAgfSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cblxuaW1wb3J0IHsgcXVlcnlzdHJpbmcgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmltcG9ydCB7XG4gIF9nZXRGaW5hbFRhcmdldCxcbiAgX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nLFxuICBIdHRwTWV0aG9kLFxuICBIdHRwSGVhZGVyXG59IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IEZldGNoUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvZmV0Y2hfcHJvdmlkZXInO1xuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcblxuZXhwb3J0IGNvbnN0IGVudW0gRW5kcG9pbnQge1xuICBUT0tFTiA9ICcvdjEvdG9rZW4nXG59XG5cbi8qKiBUaGUgc2VydmVyIHJlc3BvbnNlcyB3aXRoIHNuYWtlX2Nhc2U7IHdlIGNvbnZlcnQgdG8gY2FtZWxDYXNlICovXG5pbnRlcmZhY2UgUmVxdWVzdFN0c1Rva2VuU2VydmVyUmVzcG9uc2Uge1xuICBhY2Nlc3NfdG9rZW46IHN0cmluZztcbiAgZXhwaXJlc19pbjogc3RyaW5nO1xuICByZWZyZXNoX3Rva2VuOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdFN0c1Rva2VuUmVzcG9uc2Uge1xuICBhY2Nlc3NUb2tlbjogc3RyaW5nO1xuICBleHBpcmVzSW46IHN0cmluZztcbiAgcmVmcmVzaFRva2VuOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXF1ZXN0U3RzVG9rZW4oXG4gIGF1dGg6IEF1dGgsXG4gIHJlZnJlc2hUb2tlbjogc3RyaW5nXG4pOiBQcm9taXNlPFJlcXVlc3RTdHNUb2tlblJlc3BvbnNlPiB7XG4gIGNvbnN0IHJlc3BvbnNlID1cbiAgICBhd2FpdCBfcGVyZm9ybUZldGNoV2l0aEVycm9ySGFuZGxpbmc8UmVxdWVzdFN0c1Rva2VuU2VydmVyUmVzcG9uc2U+KFxuICAgICAgYXV0aCxcbiAgICAgIHt9LFxuICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gcXVlcnlzdHJpbmcoe1xuICAgICAgICAgICdncmFudF90eXBlJzogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICAgICdyZWZyZXNoX3Rva2VuJzogcmVmcmVzaFRva2VuXG4gICAgICAgIH0pLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCB7IHRva2VuQXBpSG9zdCwgYXBpS2V5IH0gPSBhdXRoLmNvbmZpZztcbiAgICAgICAgY29uc3QgdXJsID0gX2dldEZpbmFsVGFyZ2V0KFxuICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgdG9rZW5BcGlIb3N0LFxuICAgICAgICAgIEVuZHBvaW50LlRPS0VOLFxuICAgICAgICAgIGBrZXk9JHthcGlLZXl9YFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCAoYXV0aCBhcyBBdXRoSW50ZXJuYWwpLl9nZXRBZGRpdGlvbmFsSGVhZGVycygpO1xuICAgICAgICBoZWFkZXJzW0h0dHBIZWFkZXIuQ09OVEVOVF9UWVBFXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuXG4gICAgICAgIHJldHVybiBGZXRjaFByb3ZpZGVyLmZldGNoKCkodXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBIdHRwTWV0aG9kLlBPU1QsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBib2R5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgLy8gVGhlIHJlc3BvbnNlIGNvbWVzIGJhY2sgaW4gc25ha2VfY2FzZS4gQ29udmVydCB0byBjYW1lbDpcbiAgcmV0dXJuIHtcbiAgICBhY2Nlc3NUb2tlbjogcmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxuICAgIGV4cGlyZXNJbjogcmVzcG9uc2UuZXhwaXJlc19pbixcbiAgICByZWZyZXNoVG9rZW46IHJlc3BvbnNlLnJlZnJlc2hfdG9rZW5cbiAgfTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZpbmFsaXplTWZhUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vbWZhJztcbmltcG9ydCB7IHJlcXVlc3RTdHNUb2tlbiB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi90b2tlbic7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgUGVyc2lzdGVkQmxvYiB9IGZyb20gJy4uL3BlcnNpc3RlbmNlJztcbmltcG9ydCB7IF9hc3NlcnQsIGRlYnVnRmFpbCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IF90b2tlbkV4cGlyZXNJbiB9IGZyb20gJy4vaWRfdG9rZW5fcmVzdWx0JztcblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIG9mZmljaWFsIGV4cGlyYXRpb24gdGltZSBvZiBhIHRva2VuXG4gKiB0byByZWZyZXNoIHRoYXQgdG9rZW4sIHRvIHByb3ZpZGUgYSBidWZmZXIgZm9yIFJQQ3MgdG8gY29tcGxldGUuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEJ1ZmZlciB7XG4gIFRPS0VOX1JFRlJFU0ggPSAzMF8wMDBcbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRvIG1hcmsgdGhpcyBjbGFzcyBhcyBpbnRlcm5hbCBleHBsaWNpdGx5IHRvIGV4Y2x1ZGUgaXQgaW4gdGhlIHB1YmxpYyB0eXBpbmdzLCBiZWNhdXNlXG4gKiBpdCByZWZlcmVuY2VzIEF1dGhJbnRlcm5hbCB3aGljaCBoYXMgYSBjaXJjdWxhciBkZXBlbmRlbmN5IHdpdGggVXNlckludGVybmFsLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgU3RzVG9rZW5NYW5hZ2VyIHtcbiAgcmVmcmVzaFRva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgYWNjZXNzVG9rZW46IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBleHBpcmF0aW9uVGltZTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgZ2V0IGlzRXhwaXJlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgIXRoaXMuZXhwaXJhdGlvblRpbWUgfHxcbiAgICAgIERhdGUubm93KCkgPiB0aGlzLmV4cGlyYXRpb25UaW1lIC0gQnVmZmVyLlRPS0VOX1JFRlJFU0hcbiAgICApO1xuICB9XG5cbiAgdXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKFxuICAgIHJlc3BvbnNlOiBJZFRva2VuUmVzcG9uc2UgfCBGaW5hbGl6ZU1mYVJlc3BvbnNlXG4gICk6IHZvaWQge1xuICAgIF9hc3NlcnQocmVzcG9uc2UuaWRUb2tlbiwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgX2Fzc2VydChcbiAgICAgIHR5cGVvZiByZXNwb25zZS5pZFRva2VuICE9PSAndW5kZWZpbmVkJyxcbiAgICAgIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1JcbiAgICApO1xuICAgIF9hc3NlcnQoXG4gICAgICB0eXBlb2YgcmVzcG9uc2UucmVmcmVzaFRva2VuICE9PSAndW5kZWZpbmVkJyxcbiAgICAgIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1JcbiAgICApO1xuICAgIGNvbnN0IGV4cGlyZXNJbiA9XG4gICAgICAnZXhwaXJlc0luJyBpbiByZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UuZXhwaXJlc0luICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IE51bWJlcihyZXNwb25zZS5leHBpcmVzSW4pXG4gICAgICAgIDogX3Rva2VuRXhwaXJlc0luKHJlc3BvbnNlLmlkVG9rZW4pO1xuICAgIHRoaXMudXBkYXRlVG9rZW5zQW5kRXhwaXJhdGlvbihcbiAgICAgIHJlc3BvbnNlLmlkVG9rZW4sXG4gICAgICByZXNwb25zZS5yZWZyZXNoVG9rZW4sXG4gICAgICBleHBpcmVzSW5cbiAgICApO1xuICB9XG5cbiAgYXN5bmMgZ2V0VG9rZW4oXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGZvcmNlUmVmcmVzaCA9IGZhbHNlXG4gICk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIF9hc3NlcnQoXG4gICAgICAhdGhpcy5hY2Nlc3NUb2tlbiB8fCB0aGlzLnJlZnJlc2hUb2tlbixcbiAgICAgIGF1dGgsXG4gICAgICBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRURcbiAgICApO1xuXG4gICAgaWYgKCFmb3JjZVJlZnJlc2ggJiYgdGhpcy5hY2Nlc3NUb2tlbiAmJiAhdGhpcy5pc0V4cGlyZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlZnJlc2hUb2tlbikge1xuICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoKGF1dGgsIHRoaXMucmVmcmVzaFRva2VuISk7XG4gICAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNsZWFyUmVmcmVzaFRva2VuKCk6IHZvaWQge1xuICAgIHRoaXMucmVmcmVzaFRva2VuID0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVmcmVzaChhdXRoOiBBdXRoSW50ZXJuYWwsIG9sZFRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7IGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIGV4cGlyZXNJbiB9ID0gYXdhaXQgcmVxdWVzdFN0c1Rva2VuKFxuICAgICAgYXV0aCxcbiAgICAgIG9sZFRva2VuXG4gICAgKTtcbiAgICB0aGlzLnVwZGF0ZVRva2Vuc0FuZEV4cGlyYXRpb24oXG4gICAgICBhY2Nlc3NUb2tlbixcbiAgICAgIHJlZnJlc2hUb2tlbixcbiAgICAgIE51bWJlcihleHBpcmVzSW4pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlVG9rZW5zQW5kRXhwaXJhdGlvbihcbiAgICBhY2Nlc3NUb2tlbjogc3RyaW5nLFxuICAgIHJlZnJlc2hUb2tlbjogc3RyaW5nLFxuICAgIGV4cGlyZXNJblNlYzogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIHRoaXMucmVmcmVzaFRva2VuID0gcmVmcmVzaFRva2VuIHx8IG51bGw7XG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuIHx8IG51bGw7XG4gICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IERhdGUubm93KCkgKyBleHBpcmVzSW5TZWMgKiAxMDAwO1xuICB9XG5cbiAgc3RhdGljIGZyb21KU09OKGFwcE5hbWU6IHN0cmluZywgb2JqZWN0OiBQZXJzaXN0ZWRCbG9iKTogU3RzVG9rZW5NYW5hZ2VyIHtcbiAgICBjb25zdCB7IHJlZnJlc2hUb2tlbiwgYWNjZXNzVG9rZW4sIGV4cGlyYXRpb25UaW1lIH0gPSBvYmplY3Q7XG5cbiAgICBjb25zdCBtYW5hZ2VyID0gbmV3IFN0c1Rva2VuTWFuYWdlcigpO1xuICAgIGlmIChyZWZyZXNoVG9rZW4pIHtcbiAgICAgIF9hc3NlcnQodHlwZW9mIHJlZnJlc2hUb2tlbiA9PT0gJ3N0cmluZycsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IsIHtcbiAgICAgICAgYXBwTmFtZVxuICAgICAgfSk7XG4gICAgICBtYW5hZ2VyLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlbjtcbiAgICB9XG4gICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICBfYXNzZXJ0KHR5cGVvZiBhY2Nlc3NUb2tlbiA9PT0gJ3N0cmluZycsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IsIHtcbiAgICAgICAgYXBwTmFtZVxuICAgICAgfSk7XG4gICAgICBtYW5hZ2VyLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgfVxuICAgIGlmIChleHBpcmF0aW9uVGltZSkge1xuICAgICAgX2Fzc2VydChcbiAgICAgICAgdHlwZW9mIGV4cGlyYXRpb25UaW1lID09PSAnbnVtYmVyJyxcbiAgICAgICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUixcbiAgICAgICAge1xuICAgICAgICAgIGFwcE5hbWVcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIG1hbmFnZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hbmFnZXI7XG4gIH1cblxuICB0b0pTT04oKTogb2JqZWN0IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmcmVzaFRva2VuOiB0aGlzLnJlZnJlc2hUb2tlbixcbiAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgICAgZXhwaXJhdGlvblRpbWU6IHRoaXMuZXhwaXJhdGlvblRpbWVcbiAgICB9O1xuICB9XG5cbiAgX2Fzc2lnbihzdHNUb2tlbk1hbmFnZXI6IFN0c1Rva2VuTWFuYWdlcik6IHZvaWQge1xuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBzdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW47XG4gICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBzdHNUb2tlbk1hbmFnZXIucmVmcmVzaFRva2VuO1xuICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBzdHNUb2tlbk1hbmFnZXIuZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBfY2xvbmUoKTogU3RzVG9rZW5NYW5hZ2VyIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgU3RzVG9rZW5NYW5hZ2VyKCksIHRoaXMudG9KU09OKCkpO1xuICB9XG5cbiAgX3BlcmZvcm1SZWZyZXNoKCk6IG5ldmVyIHtcbiAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSWRUb2tlblJlc3VsdCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBOZXh0Rm4gfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmltcG9ydCB7XG4gIEFQSVVzZXJJbmZvLFxuICBkZWxldGVBY2NvdW50XG59IGZyb20gJy4uLy4uL2FwaS9hY2NvdW50X21hbmFnZW1lbnQvYWNjb3VudCc7XG5pbXBvcnQgeyBGaW5hbGl6ZU1mYVJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL21mYSc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7XG4gIE11dGFibGVVc2VySW5mbyxcbiAgVXNlckludGVybmFsLFxuICBVc2VyUGFyYW1ldGVyc1xufSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgUGVyc2lzdGVkQmxvYiB9IGZyb20gJy4uL3BlcnNpc3RlbmNlJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBnZXRJZFRva2VuUmVzdWx0IH0gZnJvbSAnLi9pZF90b2tlbl9yZXN1bHQnO1xuaW1wb3J0IHsgX2xvZ291dElmSW52YWxpZGF0ZWQgfSBmcm9tICcuL2ludmFsaWRhdGlvbic7XG5pbXBvcnQgeyBQcm9hY3RpdmVSZWZyZXNoIH0gZnJvbSAnLi9wcm9hY3RpdmVfcmVmcmVzaCc7XG5pbXBvcnQgeyBfcmVsb2FkV2l0aG91dFNhdmluZywgcmVsb2FkIH0gZnJvbSAnLi9yZWxvYWQnO1xuaW1wb3J0IHsgU3RzVG9rZW5NYW5hZ2VyIH0gZnJvbSAnLi90b2tlbl9tYW5hZ2VyJztcbmltcG9ydCB7IFVzZXJNZXRhZGF0YSB9IGZyb20gJy4vdXNlcl9tZXRhZGF0YSc7XG5pbXBvcnQgeyBQcm92aWRlcklkIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChcbiAgYXNzZXJ0aW9uOiB1bmtub3duLFxuICBhcHBOYW1lOiBzdHJpbmdcbik6IGFzc2VydHMgYXNzZXJ0aW9uIGlzIHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIF9hc3NlcnQoXG4gICAgdHlwZW9mIGFzc2VydGlvbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFzc2VydGlvbiA9PT0gJ3VuZGVmaW5lZCcsXG4gICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUixcbiAgICB7IGFwcE5hbWUgfVxuICApO1xufVxuXG5leHBvcnQgY2xhc3MgVXNlckltcGwgaW1wbGVtZW50cyBVc2VySW50ZXJuYWwge1xuICAvLyBGb3IgdGhlIHVzZXIgb2JqZWN0LCBwcm92aWRlciBpcyBhbHdheXMgRmlyZWJhc2UuXG4gIHJlYWRvbmx5IHByb3ZpZGVySWQgPSBQcm92aWRlcklkLkZJUkVCQVNFO1xuICBzdHNUb2tlbk1hbmFnZXI6IFN0c1Rva2VuTWFuYWdlcjtcbiAgLy8gTGFzdCBrbm93biBhY2Nlc3NUb2tlbiBzbyB3ZSBrbm93IHdoZW4gaXQgY2hhbmdlc1xuICBwcml2YXRlIGFjY2Vzc1Rva2VuOiBzdHJpbmcgfCBudWxsO1xuXG4gIHVpZDogc3RyaW5nO1xuICBhdXRoOiBBdXRoSW50ZXJuYWw7XG4gIGVtYWlsVmVyaWZpZWQ6IGJvb2xlYW47XG4gIGlzQW5vbnltb3VzOiBib29sZWFuO1xuICB0ZW5hbnRJZDogc3RyaW5nIHwgbnVsbDtcbiAgcmVhZG9ubHkgbWV0YWRhdGE6IFVzZXJNZXRhZGF0YTtcbiAgcHJvdmlkZXJEYXRhOiBNdXRhYmxlVXNlckluZm9bXTtcblxuICAvLyBPcHRpb25hbCBmaWVsZHMgZnJvbSBVc2VySW5mb1xuICBkaXNwbGF5TmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgZW1haWw6IHN0cmluZyB8IG51bGw7XG4gIHBob25lTnVtYmVyOiBzdHJpbmcgfCBudWxsO1xuICBwaG90b1VSTDogc3RyaW5nIHwgbnVsbDtcblxuICBfcmVkaXJlY3RFdmVudElkPzogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IHByb2FjdGl2ZVJlZnJlc2ggPSBuZXcgUHJvYWN0aXZlUmVmcmVzaCh0aGlzKTtcblxuICBjb25zdHJ1Y3Rvcih7IHVpZCwgYXV0aCwgc3RzVG9rZW5NYW5hZ2VyLCAuLi5vcHQgfTogVXNlclBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnVpZCA9IHVpZDtcbiAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIHRoaXMuc3RzVG9rZW5NYW5hZ2VyID0gc3RzVG9rZW5NYW5hZ2VyO1xuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBzdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW47XG4gICAgdGhpcy5kaXNwbGF5TmFtZSA9IG9wdC5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgIHRoaXMuZW1haWwgPSBvcHQuZW1haWwgfHwgbnVsbDtcbiAgICB0aGlzLmVtYWlsVmVyaWZpZWQgPSBvcHQuZW1haWxWZXJpZmllZCB8fCBmYWxzZTtcbiAgICB0aGlzLnBob25lTnVtYmVyID0gb3B0LnBob25lTnVtYmVyIHx8IG51bGw7XG4gICAgdGhpcy5waG90b1VSTCA9IG9wdC5waG90b1VSTCB8fCBudWxsO1xuICAgIHRoaXMuaXNBbm9ueW1vdXMgPSBvcHQuaXNBbm9ueW1vdXMgfHwgZmFsc2U7XG4gICAgdGhpcy50ZW5hbnRJZCA9IG9wdC50ZW5hbnRJZCB8fCBudWxsO1xuICAgIHRoaXMucHJvdmlkZXJEYXRhID0gb3B0LnByb3ZpZGVyRGF0YSA/IFsuLi5vcHQucHJvdmlkZXJEYXRhXSA6IFtdO1xuICAgIHRoaXMubWV0YWRhdGEgPSBuZXcgVXNlck1ldGFkYXRhKFxuICAgICAgb3B0LmNyZWF0ZWRBdCB8fCB1bmRlZmluZWQsXG4gICAgICBvcHQubGFzdExvZ2luQXQgfHwgdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGdldElkVG9rZW4oZm9yY2VSZWZyZXNoPzogYm9vbGVhbik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgYWNjZXNzVG9rZW4gPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZChcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci5nZXRUb2tlbih0aGlzLmF1dGgsIGZvcmNlUmVmcmVzaClcbiAgICApO1xuICAgIF9hc3NlcnQoYWNjZXNzVG9rZW4sIHRoaXMuYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG5cbiAgICBpZiAodGhpcy5hY2Nlc3NUb2tlbiAhPT0gYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgICAgIGF3YWl0IHRoaXMuYXV0aC5fcGVyc2lzdFVzZXJJZkN1cnJlbnQodGhpcyk7XG4gICAgICB0aGlzLmF1dGguX25vdGlmeUxpc3RlbmVyc0lmQ3VycmVudCh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXNzVG9rZW47XG4gIH1cblxuICBnZXRJZFRva2VuUmVzdWx0KGZvcmNlUmVmcmVzaD86IGJvb2xlYW4pOiBQcm9taXNlPElkVG9rZW5SZXN1bHQ+IHtcbiAgICByZXR1cm4gZ2V0SWRUb2tlblJlc3VsdCh0aGlzLCBmb3JjZVJlZnJlc2gpO1xuICB9XG5cbiAgcmVsb2FkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiByZWxvYWQodGhpcyk7XG4gIH1cblxuICBwcml2YXRlIHJlbG9hZFVzZXJJbmZvOiBBUElVc2VySW5mbyB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHJlbG9hZExpc3RlbmVyOiBOZXh0Rm48QVBJVXNlckluZm8+IHwgbnVsbCA9IG51bGw7XG5cbiAgX2Fzc2lnbih1c2VyOiBVc2VySW50ZXJuYWwpOiB2b2lkIHtcbiAgICBpZiAodGhpcyA9PT0gdXNlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfYXNzZXJ0KHRoaXMudWlkID09PSB1c2VyLnVpZCwgdGhpcy5hdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICB0aGlzLmRpc3BsYXlOYW1lID0gdXNlci5kaXNwbGF5TmFtZTtcbiAgICB0aGlzLnBob3RvVVJMID0gdXNlci5waG90b1VSTDtcbiAgICB0aGlzLmVtYWlsID0gdXNlci5lbWFpbDtcbiAgICB0aGlzLmVtYWlsVmVyaWZpZWQgPSB1c2VyLmVtYWlsVmVyaWZpZWQ7XG4gICAgdGhpcy5waG9uZU51bWJlciA9IHVzZXIucGhvbmVOdW1iZXI7XG4gICAgdGhpcy5pc0Fub255bW91cyA9IHVzZXIuaXNBbm9ueW1vdXM7XG4gICAgdGhpcy50ZW5hbnRJZCA9IHVzZXIudGVuYW50SWQ7XG4gICAgdGhpcy5wcm92aWRlckRhdGEgPSB1c2VyLnByb3ZpZGVyRGF0YS5tYXAodXNlckluZm8gPT4gKHsgLi4udXNlckluZm8gfSkpO1xuICAgIHRoaXMubWV0YWRhdGEuX2NvcHkodXNlci5tZXRhZGF0YSk7XG4gICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIuX2Fzc2lnbih1c2VyLnN0c1Rva2VuTWFuYWdlcik7XG4gIH1cblxuICBfY2xvbmUoYXV0aDogQXV0aEludGVybmFsKTogVXNlckludGVybmFsIHtcbiAgICBjb25zdCBuZXdVc2VyID0gbmV3IFVzZXJJbXBsKHtcbiAgICAgIC4uLnRoaXMsXG4gICAgICBhdXRoLFxuICAgICAgc3RzVG9rZW5NYW5hZ2VyOiB0aGlzLnN0c1Rva2VuTWFuYWdlci5fY2xvbmUoKVxuICAgIH0pO1xuICAgIG5ld1VzZXIubWV0YWRhdGEuX2NvcHkodGhpcy5tZXRhZGF0YSk7XG4gICAgcmV0dXJuIG5ld1VzZXI7XG4gIH1cblxuICBfb25SZWxvYWQoY2FsbGJhY2s6IE5leHRGbjxBUElVc2VySW5mbz4pOiB2b2lkIHtcbiAgICAvLyBUaGVyZSBzaG91bGQgb25seSBldmVyIGJlIG9uZSBsaXN0ZW5lciwgYW5kIHRoYXQgaXMgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgTXVsdGlGYWN0b3JVc2VyXG4gICAgX2Fzc2VydCghdGhpcy5yZWxvYWRMaXN0ZW5lciwgdGhpcy5hdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICB0aGlzLnJlbG9hZExpc3RlbmVyID0gY2FsbGJhY2s7XG4gICAgaWYgKHRoaXMucmVsb2FkVXNlckluZm8pIHtcbiAgICAgIHRoaXMuX25vdGlmeVJlbG9hZExpc3RlbmVyKHRoaXMucmVsb2FkVXNlckluZm8pO1xuICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgX25vdGlmeVJlbG9hZExpc3RlbmVyKHVzZXJJbmZvOiBBUElVc2VySW5mbyk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJlbG9hZExpc3RlbmVyKSB7XG4gICAgICB0aGlzLnJlbG9hZExpc3RlbmVyKHVzZXJJbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gbGlzdGVuZXIgaXMgc3Vic2NyaWJlZCB5ZXQsIHNhdmUgdGhlIHJlc3VsdCBzbyBpdCdzIGF2YWlsYWJsZSB3aGVuIHRoZXkgZG8gc3Vic2NyaWJlXG4gICAgICB0aGlzLnJlbG9hZFVzZXJJbmZvID0gdXNlckluZm87XG4gICAgfVxuICB9XG5cbiAgX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpOiB2b2lkIHtcbiAgICB0aGlzLnByb2FjdGl2ZVJlZnJlc2guX3N0YXJ0KCk7XG4gIH1cblxuICBfc3RvcFByb2FjdGl2ZVJlZnJlc2goKTogdm9pZCB7XG4gICAgdGhpcy5wcm9hY3RpdmVSZWZyZXNoLl9zdG9wKCk7XG4gIH1cblxuICBhc3luYyBfdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkoXG4gICAgcmVzcG9uc2U6IElkVG9rZW5SZXNwb25zZSB8IEZpbmFsaXplTWZhUmVzcG9uc2UsXG4gICAgcmVsb2FkID0gZmFsc2VcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbGV0IHRva2Vuc1JlZnJlc2hlZCA9IGZhbHNlO1xuICAgIGlmIChcbiAgICAgIHJlc3BvbnNlLmlkVG9rZW4gJiZcbiAgICAgIHJlc3BvbnNlLmlkVG9rZW4gIT09IHRoaXMuc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuXG4gICAgKSB7XG4gICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci51cGRhdGVGcm9tU2VydmVyUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgdG9rZW5zUmVmcmVzaGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocmVsb2FkKSB7XG4gICAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh0aGlzKTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmF1dGguX3BlcnNpc3RVc2VySWZDdXJyZW50KHRoaXMpO1xuICAgIGlmICh0b2tlbnNSZWZyZXNoZWQpIHtcbiAgICAgIHRoaXMuYXV0aC5fbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdGhpcy5nZXRJZFRva2VuKCk7XG4gICAgYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcywgZGVsZXRlQWNjb3VudCh0aGlzLmF1dGgsIHsgaWRUb2tlbiB9KSk7XG4gICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIuY2xlYXJSZWZyZXNoVG9rZW4oKTtcblxuICAgIC8vIFRPRE86IERldGVybWluZSBpZiBjYW5jZWxsYWJsZS1wcm9taXNlcyBhcmUgbmVjZXNzYXJ5IHRvIHVzZSBpbiB0aGlzIGNsYXNzIHNvIHRoYXQgZGVsZXRlKClcbiAgICAvLyAgICAgICBjYW5jZWxzIHBlbmRpbmcgYWN0aW9ucy4uLlxuXG4gICAgcmV0dXJuIHRoaXMuYXV0aC5zaWduT3V0KCk7XG4gIH1cblxuICB0b0pTT04oKTogUGVyc2lzdGVkQmxvYiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICBlbWFpbDogdGhpcy5lbWFpbCB8fCB1bmRlZmluZWQsXG4gICAgICBlbWFpbFZlcmlmaWVkOiB0aGlzLmVtYWlsVmVyaWZpZWQsXG4gICAgICBkaXNwbGF5TmFtZTogdGhpcy5kaXNwbGF5TmFtZSB8fCB1bmRlZmluZWQsXG4gICAgICBpc0Fub255bW91czogdGhpcy5pc0Fub255bW91cyxcbiAgICAgIHBob3RvVVJMOiB0aGlzLnBob3RvVVJMIHx8IHVuZGVmaW5lZCxcbiAgICAgIHBob25lTnVtYmVyOiB0aGlzLnBob25lTnVtYmVyIHx8IHVuZGVmaW5lZCxcbiAgICAgIHRlbmFudElkOiB0aGlzLnRlbmFudElkIHx8IHVuZGVmaW5lZCxcbiAgICAgIHByb3ZpZGVyRGF0YTogdGhpcy5wcm92aWRlckRhdGEubWFwKHVzZXJJbmZvID0+ICh7IC4uLnVzZXJJbmZvIH0pKSxcbiAgICAgIHN0c1Rva2VuTWFuYWdlcjogdGhpcy5zdHNUb2tlbk1hbmFnZXIudG9KU09OKCksXG4gICAgICAvLyBSZWRpcmVjdCBldmVudCBJRCBtdXN0IGJlIG1haW50YWluZWQgaW4gY2FzZSB0aGVyZSBpcyBhIHBlbmRpbmdcbiAgICAgIC8vIHJlZGlyZWN0IGV2ZW50LlxuICAgICAgX3JlZGlyZWN0RXZlbnRJZDogdGhpcy5fcmVkaXJlY3RFdmVudElkLFxuICAgICAgLi4udGhpcy5tZXRhZGF0YS50b0pTT04oKSxcblxuICAgICAgLy8gUmVxdWlyZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgbGVnYWN5IFNESyAoZ28vZmlyZWJhc2UtYXV0aC1zZGstcGVyc2lzdGVuY2UtcGFyc2luZyk6XG4gICAgICBhcGlLZXk6IHRoaXMuYXV0aC5jb25maWcuYXBpS2V5LFxuICAgICAgYXBwTmFtZTogdGhpcy5hdXRoLm5hbWVcbiAgICAgIC8vIE1pc3NpbmcgYXV0aERvbWFpbiB3aWxsIGJlIHRvbGVyYXRlZCBieSB0aGUgbGVnYWN5IFNESy5cbiAgICAgIC8vIHN0c1Rva2VuTWFuYWdlci5hcGlLZXkgaXNuJ3QgYWN0dWFsbHkgcmVxdWlyZWQgKGRlc3BpdGUgdGhlIGxlZ2FjeSBTREsgcGVyc2lzdGluZyBpdCkuXG4gICAgfTtcbiAgfVxuXG4gIGdldCByZWZyZXNoVG9rZW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdHNUb2tlbk1hbmFnZXIucmVmcmVzaFRva2VuIHx8ICcnO1xuICB9XG5cbiAgc3RhdGljIF9mcm9tSlNPTihhdXRoOiBBdXRoSW50ZXJuYWwsIG9iamVjdDogUGVyc2lzdGVkQmxvYik6IFVzZXJJbnRlcm5hbCB7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBvYmplY3QuZGlzcGxheU5hbWUgPz8gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGVtYWlsID0gb2JqZWN0LmVtYWlsID8/IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwaG9uZU51bWJlciA9IG9iamVjdC5waG9uZU51bWJlciA/PyB1bmRlZmluZWQ7XG4gICAgY29uc3QgcGhvdG9VUkwgPSBvYmplY3QucGhvdG9VUkwgPz8gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHRlbmFudElkID0gb2JqZWN0LnRlbmFudElkID8/IHVuZGVmaW5lZDtcbiAgICBjb25zdCBfcmVkaXJlY3RFdmVudElkID0gb2JqZWN0Ll9yZWRpcmVjdEV2ZW50SWQgPz8gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG9iamVjdC5jcmVhdGVkQXQgPz8gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxhc3RMb2dpbkF0ID0gb2JqZWN0Lmxhc3RMb2dpbkF0ID8/IHVuZGVmaW5lZDtcbiAgICBjb25zdCB7XG4gICAgICB1aWQsXG4gICAgICBlbWFpbFZlcmlmaWVkLFxuICAgICAgaXNBbm9ueW1vdXMsXG4gICAgICBwcm92aWRlckRhdGEsXG4gICAgICBzdHNUb2tlbk1hbmFnZXI6IHBsYWluT2JqZWN0VG9rZW5NYW5hZ2VyXG4gICAgfSA9IG9iamVjdDtcblxuICAgIF9hc3NlcnQodWlkICYmIHBsYWluT2JqZWN0VG9rZW5NYW5hZ2VyLCBhdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcblxuICAgIGNvbnN0IHN0c1Rva2VuTWFuYWdlciA9IFN0c1Rva2VuTWFuYWdlci5mcm9tSlNPTihcbiAgICAgIHRoaXMubmFtZSxcbiAgICAgIHBsYWluT2JqZWN0VG9rZW5NYW5hZ2VyIGFzIFBlcnNpc3RlZEJsb2JcbiAgICApO1xuXG4gICAgX2Fzc2VydCh0eXBlb2YgdWlkID09PSAnc3RyaW5nJywgYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoZGlzcGxheU5hbWUsIGF1dGgubmFtZSk7XG4gICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoZW1haWwsIGF1dGgubmFtZSk7XG4gICAgX2Fzc2VydChcbiAgICAgIHR5cGVvZiBlbWFpbFZlcmlmaWVkID09PSAnYm9vbGVhbicsXG4gICAgICBhdXRoLFxuICAgICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUlxuICAgICk7XG4gICAgX2Fzc2VydChcbiAgICAgIHR5cGVvZiBpc0Fub255bW91cyA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgYXV0aCxcbiAgICAgIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1JcbiAgICApO1xuICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHBob25lTnVtYmVyLCBhdXRoLm5hbWUpO1xuICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHBob3RvVVJMLCBhdXRoLm5hbWUpO1xuICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHRlbmFudElkLCBhdXRoLm5hbWUpO1xuICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKF9yZWRpcmVjdEV2ZW50SWQsIGF1dGgubmFtZSk7XG4gICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoY3JlYXRlZEF0LCBhdXRoLm5hbWUpO1xuICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGxhc3RMb2dpbkF0LCBhdXRoLm5hbWUpO1xuICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlckltcGwoe1xuICAgICAgdWlkLFxuICAgICAgYXV0aCxcbiAgICAgIGVtYWlsLFxuICAgICAgZW1haWxWZXJpZmllZCxcbiAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgaXNBbm9ueW1vdXMsXG4gICAgICBwaG90b1VSTCxcbiAgICAgIHBob25lTnVtYmVyLFxuICAgICAgdGVuYW50SWQsXG4gICAgICBzdHNUb2tlbk1hbmFnZXIsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBsYXN0TG9naW5BdFxuICAgIH0pO1xuXG4gICAgaWYgKHByb3ZpZGVyRGF0YSAmJiBBcnJheS5pc0FycmF5KHByb3ZpZGVyRGF0YSkpIHtcbiAgICAgIHVzZXIucHJvdmlkZXJEYXRhID0gcHJvdmlkZXJEYXRhLm1hcCh1c2VySW5mbyA9PiAoeyAuLi51c2VySW5mbyB9KSk7XG4gICAgfVxuXG4gICAgaWYgKF9yZWRpcmVjdEV2ZW50SWQpIHtcbiAgICAgIHVzZXIuX3JlZGlyZWN0RXZlbnRJZCA9IF9yZWRpcmVjdEV2ZW50SWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIFVzZXIgZnJvbSBhbiBpZFRva2VuIHNlcnZlciByZXNwb25zZVxuICAgKiBAcGFyYW0gYXV0aFxuICAgKiBAcGFyYW0gaWRUb2tlblJlc3BvbnNlXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgX2Zyb21JZFRva2VuUmVzcG9uc2UoXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGlkVG9rZW5SZXNwb25zZTogSWRUb2tlblJlc3BvbnNlLFxuICAgIGlzQW5vbnltb3VzOiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTxVc2VySW50ZXJuYWw+IHtcbiAgICBjb25zdCBzdHNUb2tlbk1hbmFnZXIgPSBuZXcgU3RzVG9rZW5NYW5hZ2VyKCk7XG4gICAgc3RzVG9rZW5NYW5hZ2VyLnVwZGF0ZUZyb21TZXJ2ZXJSZXNwb25zZShpZFRva2VuUmVzcG9uc2UpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRmlyZWJhc2UgQXV0aCB1c2VyLlxuICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlckltcGwoe1xuICAgICAgdWlkOiBpZFRva2VuUmVzcG9uc2UubG9jYWxJZCxcbiAgICAgIGF1dGgsXG4gICAgICBzdHNUb2tlbk1hbmFnZXIsXG4gICAgICBpc0Fub255bW91c1xuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlcyB0aGUgdXNlciBpbmZvIGFuZCBkYXRhIGFuZCByZXNvbHZlcyB3aXRoIGEgdXNlciBpbnN0YW5jZS5cbiAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgZGVidWdBc3NlcnQgfSBmcm9tICcuL2Fzc2VydCc7XG5cbi8qKlxuICogT3VyIEFQSSBoYXMgYSBsb3Qgb2Ygb25lLW9mZiBjb25zdGFudHMgdGhhdCBhcmUgdXNlZCB0byBkbyB0aGluZ3MuXG4gKiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0IGV4cG9ydCB0aGVzZSBhcyBjbGFzc2VzIGluc3RhbnRpYXRlZCBkaXJlY3RseSBzaW5jZVxuICogdGhlIGNvbnN0cnVjdG9yIG1heSBzaWRlIGVmZmVjdCBhbmQgdGhlcmVmb3JlIGNhbid0IGJlIHByb3ZlbiB0byBiZSBzYWZlbHlcbiAqIGN1bGxlZC4gSW5zdGVhZCwgd2UgZXhwb3J0IHRoZXNlIGNsYXNzZXMgdGhlbXNlbHZlcyBhcyBhIGxvd2VyQ2FtZWxDYXNlXG4gKiBjb25zdGFudCwgYW5kIGluc3RhbnRpYXRlIHRoZW0gdW5kZXIgdGhlIGhvb2QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2luZ2xldG9uSW5zdGFudGlhdG9yPFQ+IHtcbiAgbmV3ICgpOiBUO1xufVxuXG5jb25zdCBpbnN0YW5jZUNhY2hlOiBNYXA8dW5rbm93biwgdW5rbm93bj4gPSBuZXcgTWFwKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0SW5zdGFuY2U8VD4oY2xzOiB1bmtub3duKTogVCB7XG4gIGRlYnVnQXNzZXJ0KGNscyBpbnN0YW5jZW9mIEZ1bmN0aW9uLCAnRXhwZWN0ZWQgYSBjbGFzcyBkZWZpbml0aW9uJyk7XG4gIGxldCBpbnN0YW5jZSA9IGluc3RhbmNlQ2FjaGUuZ2V0KGNscykgYXMgVCB8IHVuZGVmaW5lZDtcblxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBkZWJ1Z0Fzc2VydChcbiAgICAgIGluc3RhbmNlIGluc3RhbmNlb2YgY2xzLFxuICAgICAgJ0luc3RhbmNlIHN0b3JlZCBpbiBjYWNoZSBtaXNtYXRjaGVkIHdpdGggY2xhc3MnXG4gICAgKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBpbnN0YW5jZSA9IG5ldyAoY2xzIGFzIFNpbmdsZXRvbkluc3RhbnRpYXRvcjxUPikoKTtcbiAgaW5zdGFuY2VDYWNoZS5zZXQoY2xzLCBpbnN0YW5jZSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9jbGVhckluc3RhbmNlTWFwKCk6IHZvaWQge1xuICBpbnN0YW5jZUNhY2hlLmNsZWFyKCk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQZXJzaXN0ZW5jZSB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7XG4gIFBlcnNpc3RlbmNlSW50ZXJuYWwsXG4gIFBlcnNpc3RlbmNlVHlwZSxcbiAgUGVyc2lzdGVuY2VWYWx1ZSxcbiAgU3RvcmFnZUV2ZW50TGlzdGVuZXJcbn0gZnJvbSAnLi4vcGVyc2lzdGVuY2UnO1xuXG5leHBvcnQgY2xhc3MgSW5NZW1vcnlQZXJzaXN0ZW5jZSBpbXBsZW1lbnRzIFBlcnNpc3RlbmNlSW50ZXJuYWwge1xuICBzdGF0aWMgdHlwZTogJ05PTkUnID0gJ05PTkUnO1xuICByZWFkb25seSB0eXBlID0gUGVyc2lzdGVuY2VUeXBlLk5PTkU7XG4gIHN0b3JhZ2U6IFJlY29yZDxzdHJpbmcsIFBlcnNpc3RlbmNlVmFsdWU+ID0ge307XG5cbiAgYXN5bmMgX2lzQXZhaWxhYmxlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgYXN5bmMgX3NldChrZXk6IHN0cmluZywgdmFsdWU6IFBlcnNpc3RlbmNlVmFsdWUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLnN0b3JhZ2Vba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgYXN5bmMgX2dldDxUIGV4dGVuZHMgUGVyc2lzdGVuY2VWYWx1ZT4oa2V5OiBzdHJpbmcpOiBQcm9taXNlPFQgfCBudWxsPiB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0b3JhZ2Vba2V5XTtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiAodmFsdWUgYXMgVCk7XG4gIH1cblxuICBhc3luYyBfcmVtb3ZlKGtleTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXldO1xuICB9XG5cbiAgX2FkZExpc3RlbmVyKF9rZXk6IHN0cmluZywgX2xpc3RlbmVyOiBTdG9yYWdlRXZlbnRMaXN0ZW5lcik6IHZvaWQge1xuICAgIC8vIExpc3RlbmVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgaW4tbWVtb3J5IHN0b3JhZ2Ugc2luY2UgaXQgY2Fubm90IGJlIHNoYXJlZCBhY3Jvc3Mgd2luZG93cy93b3JrZXJzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgX3JlbW92ZUxpc3RlbmVyKF9rZXk6IHN0cmluZywgX2xpc3RlbmVyOiBTdG9yYWdlRXZlbnRMaXN0ZW5lcik6IHZvaWQge1xuICAgIC8vIExpc3RlbmVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgaW4tbWVtb3J5IHN0b3JhZ2Ugc2luY2UgaXQgY2Fubm90IGJlIHNoYXJlZCBhY3Jvc3Mgd2luZG93cy93b3JrZXJzXG4gICAgcmV0dXJuO1xuICB9XG59XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFBlcnNpc3RlbmNlfSBvZiB0eXBlICdOT05FJy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBpbk1lbW9yeVBlcnNpc3RlbmNlOiBQZXJzaXN0ZW5jZSA9IEluTWVtb3J5UGVyc2lzdGVuY2U7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBcGlLZXksIEFwcE5hbWUsIEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBQZXJzaXN0ZWRCbG9iLCBQZXJzaXN0ZW5jZUludGVybmFsIH0gZnJvbSAnLi4vcGVyc2lzdGVuY2UnO1xuaW1wb3J0IHsgVXNlckltcGwgfSBmcm9tICcuLi91c2VyL3VzZXJfaW1wbCc7XG5pbXBvcnQgeyBfZ2V0SW5zdGFuY2UgfSBmcm9tICcuLi91dGlsL2luc3RhbnRpYXRvcic7XG5pbXBvcnQgeyBpbk1lbW9yeVBlcnNpc3RlbmNlIH0gZnJvbSAnLi9pbl9tZW1vcnknO1xuXG5leHBvcnQgY29uc3QgZW51bSBLZXlOYW1lIHtcbiAgQVVUSF9VU0VSID0gJ2F1dGhVc2VyJyxcbiAgQVVUSF9FVkVOVCA9ICdhdXRoRXZlbnQnLFxuICBSRURJUkVDVF9VU0VSID0gJ3JlZGlyZWN0VXNlcicsXG4gIFBFUlNJU1RFTkNFX1VTRVIgPSAncGVyc2lzdGVuY2UnXG59XG5leHBvcnQgY29uc3QgZW51bSBOYW1lc3BhY2Uge1xuICBQRVJTSVNURU5DRSA9ICdmaXJlYmFzZSdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wZXJzaXN0ZW5jZUtleU5hbWUoXG4gIGtleTogc3RyaW5nLFxuICBhcGlLZXk6IEFwaUtleSxcbiAgYXBwTmFtZTogQXBwTmFtZVxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke05hbWVzcGFjZS5QRVJTSVNURU5DRX06JHtrZXl9OiR7YXBpS2V5fToke2FwcE5hbWV9YDtcbn1cblxuZXhwb3J0IGNsYXNzIFBlcnNpc3RlbmNlVXNlck1hbmFnZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGZ1bGxVc2VyS2V5OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgZnVsbFBlcnNpc3RlbmNlS2V5OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgYm91bmRFdmVudEhhbmRsZXI6ICgpID0+IHZvaWQ7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcGVyc2lzdGVuY2U6IFBlcnNpc3RlbmNlSW50ZXJuYWwsXG4gICAgcHJpdmF0ZSByZWFkb25seSBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgcHJpdmF0ZSByZWFkb25seSB1c2VyS2V5OiBzdHJpbmdcbiAgKSB7XG4gICAgY29uc3QgeyBjb25maWcsIG5hbWUgfSA9IHRoaXMuYXV0aDtcbiAgICB0aGlzLmZ1bGxVc2VyS2V5ID0gX3BlcnNpc3RlbmNlS2V5TmFtZSh0aGlzLnVzZXJLZXksIGNvbmZpZy5hcGlLZXksIG5hbWUpO1xuICAgIHRoaXMuZnVsbFBlcnNpc3RlbmNlS2V5ID0gX3BlcnNpc3RlbmNlS2V5TmFtZShcbiAgICAgIEtleU5hbWUuUEVSU0lTVEVOQ0VfVVNFUixcbiAgICAgIGNvbmZpZy5hcGlLZXksXG4gICAgICBuYW1lXG4gICAgKTtcbiAgICB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyID0gYXV0aC5fb25TdG9yYWdlRXZlbnQuYmluZChhdXRoKTtcbiAgICB0aGlzLnBlcnNpc3RlbmNlLl9hZGRMaXN0ZW5lcih0aGlzLmZ1bGxVc2VyS2V5LCB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyKTtcbiAgfVxuXG4gIHNldEN1cnJlbnRVc2VyKHVzZXI6IFVzZXJJbnRlcm5hbCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9zZXQodGhpcy5mdWxsVXNlcktleSwgdXNlci50b0pTT04oKSk7XG4gIH1cblxuICBhc3luYyBnZXRDdXJyZW50VXNlcigpOiBQcm9taXNlPFVzZXJJbnRlcm5hbCB8IG51bGw+IHtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5fZ2V0PFBlcnNpc3RlZEJsb2I+KHRoaXMuZnVsbFVzZXJLZXkpO1xuICAgIHJldHVybiBibG9iID8gVXNlckltcGwuX2Zyb21KU09OKHRoaXMuYXV0aCwgYmxvYikgOiBudWxsO1xuICB9XG5cbiAgcmVtb3ZlQ3VycmVudFVzZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuX3JlbW92ZSh0aGlzLmZ1bGxVc2VyS2V5KTtcbiAgfVxuXG4gIHNhdmVQZXJzaXN0ZW5jZUZvclJlZGlyZWN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9zZXQoXG4gICAgICB0aGlzLmZ1bGxQZXJzaXN0ZW5jZUtleSxcbiAgICAgIHRoaXMucGVyc2lzdGVuY2UudHlwZVxuICAgICk7XG4gIH1cblxuICBhc3luYyBzZXRQZXJzaXN0ZW5jZShuZXdQZXJzaXN0ZW5jZTogUGVyc2lzdGVuY2VJbnRlcm5hbCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlID09PSBuZXdQZXJzaXN0ZW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50VXNlcigpO1xuICAgIGF3YWl0IHRoaXMucmVtb3ZlQ3VycmVudFVzZXIoKTtcblxuICAgIHRoaXMucGVyc2lzdGVuY2UgPSBuZXdQZXJzaXN0ZW5jZTtcblxuICAgIGlmIChjdXJyZW50VXNlcikge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFVzZXIoY3VycmVudFVzZXIpO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLnBlcnNpc3RlbmNlLl9yZW1vdmVMaXN0ZW5lcih0aGlzLmZ1bGxVc2VyS2V5LCB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyKTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIHBlcnNpc3RlbmNlSGllcmFyY2h5OiBQZXJzaXN0ZW5jZUludGVybmFsW10sXG4gICAgdXNlcktleSA9IEtleU5hbWUuQVVUSF9VU0VSXG4gICk6IFByb21pc2U8UGVyc2lzdGVuY2VVc2VyTWFuYWdlcj4ge1xuICAgIGlmICghcGVyc2lzdGVuY2VIaWVyYXJjaHkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIoXG4gICAgICAgIF9nZXRJbnN0YW5jZShpbk1lbW9yeVBlcnNpc3RlbmNlKSxcbiAgICAgICAgYXV0aCxcbiAgICAgICAgdXNlcktleVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBFbGltaW5hdGUgYW55IHBlcnNpc3RlbmNlcyB0aGF0IGFyZSBub3QgYXZhaWxhYmxlXG4gICAgY29uc3QgYXZhaWxhYmxlUGVyc2lzdGVuY2VzID0gKFxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHBlcnNpc3RlbmNlSGllcmFyY2h5Lm1hcChhc3luYyBwZXJzaXN0ZW5jZSA9PiB7XG4gICAgICAgICAgaWYgKGF3YWl0IHBlcnNpc3RlbmNlLl9pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVyc2lzdGVuY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKS5maWx0ZXIocGVyc2lzdGVuY2UgPT4gcGVyc2lzdGVuY2UpIGFzIFBlcnNpc3RlbmNlSW50ZXJuYWxbXTtcblxuICAgIC8vIEZhbGwgYmFjayB0byB0aGUgZmlyc3QgcGVyc2lzdGVuY2UgbGlzdGVkLCBvciBpbiBtZW1vcnkgaWYgbm9uZSBhdmFpbGFibGVcbiAgICBsZXQgc2VsZWN0ZWRQZXJzaXN0ZW5jZSA9XG4gICAgICBhdmFpbGFibGVQZXJzaXN0ZW5jZXNbMF0gfHxcbiAgICAgIF9nZXRJbnN0YW5jZTxQZXJzaXN0ZW5jZUludGVybmFsPihpbk1lbW9yeVBlcnNpc3RlbmNlKTtcblxuICAgIGNvbnN0IGtleSA9IF9wZXJzaXN0ZW5jZUtleU5hbWUodXNlcktleSwgYXV0aC5jb25maWcuYXBpS2V5LCBhdXRoLm5hbWUpO1xuXG4gICAgLy8gUHVsbCBvdXQgdGhlIGV4aXN0aW5nIHVzZXIsIHNldHRpbmcgdGhlIGNob3NlbiBwZXJzaXN0ZW5jZSB0byB0aGF0XG4gICAgLy8gcGVyc2lzdGVuY2UgaWYgdGhlIHVzZXIgZXhpc3RzLlxuICAgIGxldCB1c2VyVG9NaWdyYXRlOiBVc2VySW50ZXJuYWwgfCBudWxsID0gbnVsbDtcbiAgICAvLyBOb3RlLCBoZXJlIHdlIGNoZWNrIGZvciBhIHVzZXIgaW4gX2FsbF8gcGVyc2lzdGVuY2VzLCBub3QganVzdCB0aGVcbiAgICAvLyBvbmVzIGRlZW1lZCBhdmFpbGFibGUuIElmIHdlIGNhbiBtaWdyYXRlIGEgdXNlciBvdXQgb2YgYSBicm9rZW5cbiAgICAvLyBwZXJzaXN0ZW5jZSwgd2Ugd2lsbCAoYnV0IG9ubHkgaWYgdGhhdCBwZXJzaXN0ZW5jZSBzdXBwb3J0cyBtaWdyYXRpb24pLlxuICAgIGZvciAoY29uc3QgcGVyc2lzdGVuY2Ugb2YgcGVyc2lzdGVuY2VIaWVyYXJjaHkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBwZXJzaXN0ZW5jZS5fZ2V0PFBlcnNpc3RlZEJsb2I+KGtleSk7XG4gICAgICAgIGlmIChibG9iKSB7XG4gICAgICAgICAgY29uc3QgdXNlciA9IFVzZXJJbXBsLl9mcm9tSlNPTihhdXRoLCBibG9iKTsgLy8gdGhyb3dzIGZvciB1bnBhcnNhYmxlIGJsb2IgKHdyb25nIGZvcm1hdClcbiAgICAgICAgICBpZiAocGVyc2lzdGVuY2UgIT09IHNlbGVjdGVkUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgIHVzZXJUb01pZ3JhdGUgPSB1c2VyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxlY3RlZFBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBmaW5kIHRoZSB1c2VyIGluIGEgcGVyc2lzdGVuY2UgdGhhdCBkb2VzIHN1cHBvcnQgbWlncmF0aW9uLCB1c2VcbiAgICAvLyB0aGF0IG1pZ3JhdGlvbiBwYXRoIChvZiBvbmx5IHBlcnNpc3RlbmNlcyB0aGF0IHN1cHBvcnQgbWlncmF0aW9uKVxuICAgIGNvbnN0IG1pZ3JhdGlvbkhpZXJhcmNoeSA9IGF2YWlsYWJsZVBlcnNpc3RlbmNlcy5maWx0ZXIoXG4gICAgICBwID0+IHAuX3Nob3VsZEFsbG93TWlncmF0aW9uXG4gICAgKTtcblxuICAgIC8vIElmIHRoZSBwZXJzaXN0ZW5jZSBkb2VzIF9ub3RfIGFsbG93IG1pZ3JhdGlvbiwganVzdCBmaW5pc2ggb2ZmIGhlcmVcbiAgICBpZiAoXG4gICAgICAhc2VsZWN0ZWRQZXJzaXN0ZW5jZS5fc2hvdWxkQWxsb3dNaWdyYXRpb24gfHxcbiAgICAgICFtaWdyYXRpb25IaWVyYXJjaHkubGVuZ3RoXG4gICAgKSB7XG4gICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIoc2VsZWN0ZWRQZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSk7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRQZXJzaXN0ZW5jZSA9IG1pZ3JhdGlvbkhpZXJhcmNoeVswXTtcbiAgICBpZiAodXNlclRvTWlncmF0ZSkge1xuICAgICAgLy8gVGhpcyBub3JtYWxseSBzaG91bGRuJ3QgdGhyb3cgc2luY2UgY2hvc2VuUGVyc2lzdGVuY2UuaXNBdmFpbGFibGUoKSBpcyB0cnVlLCBidXQgaWYgaXQgZG9lc1xuICAgICAgLy8gd2UnbGwganVzdCBsZXQgaXQgYnViYmxlIHRvIHN1cmZhY2UgdGhlIGVycm9yLlxuICAgICAgYXdhaXQgc2VsZWN0ZWRQZXJzaXN0ZW5jZS5fc2V0KGtleSwgdXNlclRvTWlncmF0ZS50b0pTT04oKSk7XG4gICAgfVxuXG4gICAgLy8gQXR0ZW1wdCB0byBjbGVhciB0aGUga2V5IGluIG90aGVyIHBlcnNpc3RlbmNlcyBidXQgaWdub3JlIGVycm9ycy4gVGhpcyBoZWxwcyBwcmV2ZW50IGlzc3Vlc1xuICAgIC8vIHN1Y2ggYXMgdXNlcnMgZ2V0dGluZyBzdHVjayB3aXRoIGEgcHJldmlvdXMgYWNjb3VudCBhZnRlciBzaWduaW5nIG91dCBhbmQgcmVmcmVzaGluZyB0aGUgdGFiLlxuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgcGVyc2lzdGVuY2VIaWVyYXJjaHkubWFwKGFzeW5jIHBlcnNpc3RlbmNlID0+IHtcbiAgICAgICAgaWYgKHBlcnNpc3RlbmNlICE9PSBzZWxlY3RlZFBlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHBlcnNpc3RlbmNlLl9yZW1vdmUoa2V5KTtcbiAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIoc2VsZWN0ZWRQZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGlzSUUsIGdldFVBIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbnRlcmZhY2UgTmF2aWdhdG9yU3RhbmRhbG9uZSBleHRlbmRzIE5hdmlnYXRvciB7XG4gIHN0YW5kYWxvbmU/OiB1bmtub3duO1xufVxuXG5pbnRlcmZhY2UgRG9jdW1lbnQge1xuICBkb2N1bWVudE1vZGU/OiBudW1iZXI7XG59XG5cbi8qKlxuICogRW51bXMgZm9yIEJyb3dzZXIgbmFtZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gQnJvd3Nlck5hbWUge1xuICBBTkRST0lEID0gJ0FuZHJvaWQnLFxuICBCTEFDS0JFUlJZID0gJ0JsYWNrYmVycnknLFxuICBFREdFID0gJ0VkZ2UnLFxuICBGSVJFRk9YID0gJ0ZpcmVmb3gnLFxuICBJRSA9ICdJRScsXG4gIElFTU9CSUxFID0gJ0lFTW9iaWxlJyxcbiAgT1BFUkEgPSAnT3BlcmEnLFxuICBPVEhFUiA9ICdPdGhlcicsXG4gIENIUk9NRSA9ICdDaHJvbWUnLFxuICBTQUZBUkkgPSAnU2FmYXJpJyxcbiAgU0lMSyA9ICdTaWxrJyxcbiAgV0VCT1MgPSAnV2Vib3MnXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBicm93c2VyIGZvciB0aGUgcHVycG9zZXMgb2YgcmVwb3J0aW5nIHVzYWdlIHRvIHRoZSBBUElcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCcm93c2VyTmFtZSh1c2VyQWdlbnQ6IHN0cmluZyk6IEJyb3dzZXJOYW1lIHwgc3RyaW5nIHtcbiAgY29uc3QgdWEgPSB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHVhLmluY2x1ZGVzKCdvcGVyYS8nKSB8fCB1YS5pbmNsdWRlcygnb3ByLycpIHx8IHVhLmluY2x1ZGVzKCdvcGlvcy8nKSkge1xuICAgIHJldHVybiBCcm93c2VyTmFtZS5PUEVSQTtcbiAgfSBlbHNlIGlmIChfaXNJRU1vYmlsZSh1YSkpIHtcbiAgICAvLyBXaW5kb3dzIHBob25lIElFTW9iaWxlIGJyb3dzZXIuXG4gICAgcmV0dXJuIEJyb3dzZXJOYW1lLklFTU9CSUxFO1xuICB9IGVsc2UgaWYgKHVhLmluY2x1ZGVzKCdtc2llJykgfHwgdWEuaW5jbHVkZXMoJ3RyaWRlbnQvJykpIHtcbiAgICByZXR1cm4gQnJvd3Nlck5hbWUuSUU7XG4gIH0gZWxzZSBpZiAodWEuaW5jbHVkZXMoJ2VkZ2UvJykpIHtcbiAgICByZXR1cm4gQnJvd3Nlck5hbWUuRURHRTtcbiAgfSBlbHNlIGlmIChfaXNGaXJlZm94KHVhKSkge1xuICAgIHJldHVybiBCcm93c2VyTmFtZS5GSVJFRk9YO1xuICB9IGVsc2UgaWYgKHVhLmluY2x1ZGVzKCdzaWxrLycpKSB7XG4gICAgcmV0dXJuIEJyb3dzZXJOYW1lLlNJTEs7XG4gIH0gZWxzZSBpZiAoX2lzQmxhY2tCZXJyeSh1YSkpIHtcbiAgICAvLyBCbGFja2JlcnJ5IGJyb3dzZXIuXG4gICAgcmV0dXJuIEJyb3dzZXJOYW1lLkJMQUNLQkVSUlk7XG4gIH0gZWxzZSBpZiAoX2lzV2ViT1ModWEpKSB7XG4gICAgLy8gV2ViT1MgZGVmYXVsdCBicm93c2VyLlxuICAgIHJldHVybiBCcm93c2VyTmFtZS5XRUJPUztcbiAgfSBlbHNlIGlmIChfaXNTYWZhcmkodWEpKSB7XG4gICAgcmV0dXJuIEJyb3dzZXJOYW1lLlNBRkFSSTtcbiAgfSBlbHNlIGlmIChcbiAgICAodWEuaW5jbHVkZXMoJ2Nocm9tZS8nKSB8fCBfaXNDaHJvbWVJT1ModWEpKSAmJlxuICAgICF1YS5pbmNsdWRlcygnZWRnZS8nKVxuICApIHtcbiAgICByZXR1cm4gQnJvd3Nlck5hbWUuQ0hST01FO1xuICB9IGVsc2UgaWYgKF9pc0FuZHJvaWQodWEpKSB7XG4gICAgLy8gQW5kcm9pZCBzdG9jayBicm93c2VyLlxuICAgIHJldHVybiBCcm93c2VyTmFtZS5BTkRST0lEO1xuICB9IGVsc2Uge1xuICAgIC8vIE1vc3QgbW9kZXJuIGJyb3dzZXJzIGhhdmUgbmFtZS92ZXJzaW9uIGF0IGVuZCBvZiB1c2VyIGFnZW50IHN0cmluZy5cbiAgICBjb25zdCByZSA9IC8oW2EtekEtWlxcZFxcLl0rKVxcL1thLXpBLVpcXGRcXC5dKiQvO1xuICAgIGNvbnN0IG1hdGNoZXMgPSB1c2VyQWdlbnQubWF0Y2gocmUpO1xuICAgIGlmIChtYXRjaGVzPy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQnJvd3Nlck5hbWUuT1RIRVI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNGaXJlZm94KHVhID0gZ2V0VUEoKSk6IGJvb2xlYW4ge1xuICByZXR1cm4gL2ZpcmVmb3hcXC8vaS50ZXN0KHVhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pc1NhZmFyaSh1c2VyQWdlbnQgPSBnZXRVQSgpKTogYm9vbGVhbiB7XG4gIGNvbnN0IHVhID0gdXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAoXG4gICAgdWEuaW5jbHVkZXMoJ3NhZmFyaS8nKSAmJlxuICAgICF1YS5pbmNsdWRlcygnY2hyb21lLycpICYmXG4gICAgIXVhLmluY2x1ZGVzKCdjcmlvcy8nKSAmJlxuICAgICF1YS5pbmNsdWRlcygnYW5kcm9pZCcpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNDaHJvbWVJT1ModWEgPSBnZXRVQSgpKTogYm9vbGVhbiB7XG4gIHJldHVybiAvY3Jpb3NcXC8vaS50ZXN0KHVhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pc0lFTW9iaWxlKHVhID0gZ2V0VUEoKSk6IGJvb2xlYW4ge1xuICByZXR1cm4gL2llbW9iaWxlL2kudGVzdCh1YSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNBbmRyb2lkKHVhID0gZ2V0VUEoKSk6IGJvb2xlYW4ge1xuICByZXR1cm4gL2FuZHJvaWQvaS50ZXN0KHVhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pc0JsYWNrQmVycnkodWEgPSBnZXRVQSgpKTogYm9vbGVhbiB7XG4gIHJldHVybiAvYmxhY2tiZXJyeS9pLnRlc3QodWEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2lzV2ViT1ModWEgPSBnZXRVQSgpKTogYm9vbGVhbiB7XG4gIHJldHVybiAvd2Vib3MvaS50ZXN0KHVhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pc0lPUyh1YSA9IGdldFVBKCkpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICAvaXBob25lfGlwYWR8aXBvZC9pLnRlc3QodWEpIHx8XG4gICAgKC9tYWNpbnRvc2gvaS50ZXN0KHVhKSAmJiAvbW9iaWxlL2kudGVzdCh1YSkpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNJT1M3T3I4KHVhID0gZ2V0VUEoKSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIC8oaVBhZHxpUGhvbmV8aVBvZCkuKk9TIDdfXFxkL2kudGVzdCh1YSkgfHxcbiAgICAvKGlQYWR8aVBob25lfGlQb2QpLipPUyA4X1xcZC9pLnRlc3QodWEpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNJT1NTdGFuZGFsb25lKHVhID0gZ2V0VUEoKSk6IGJvb2xlYW4ge1xuICByZXR1cm4gX2lzSU9TKHVhKSAmJiAhISh3aW5kb3cubmF2aWdhdG9yIGFzIE5hdmlnYXRvclN0YW5kYWxvbmUpPy5zdGFuZGFsb25lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2lzSUUxMCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzSUUoKSAmJiAoZG9jdW1lbnQgYXMgRG9jdW1lbnQpLmRvY3VtZW50TW9kZSA9PT0gMTA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNNb2JpbGVCcm93c2VyKHVhOiBzdHJpbmcgPSBnZXRVQSgpKTogYm9vbGVhbiB7XG4gIC8vIFRPRE86IGltcGxlbWVudCBnZXRCcm93c2VyTmFtZSBlcXVpdmFsZW50IGZvciBPUy5cbiAgcmV0dXJuIChcbiAgICBfaXNJT1ModWEpIHx8XG4gICAgX2lzQW5kcm9pZCh1YSkgfHxcbiAgICBfaXNXZWJPUyh1YSkgfHxcbiAgICBfaXNCbGFja0JlcnJ5KHVhKSB8fFxuICAgIC93aW5kb3dzIHBob25lL2kudGVzdCh1YSkgfHxcbiAgICBfaXNJRU1vYmlsZSh1YSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pc0lmcmFtZSgpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBjdXJyZW50IHdpbmRvdyBpcyBub3QgdGhlIHRvcCB3aW5kb3cuXG4gICAgLy8gSWYgc28sIHJldHVybiB0cnVlLlxuICAgIHJldHVybiAhISh3aW5kb3cgJiYgd2luZG93ICE9PSB3aW5kb3cudG9wKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgU0RLX1ZFUlNJT04gfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IF9nZXRCcm93c2VyTmFtZSB9IGZyb20gJy4vYnJvd3Nlcic7XG5pbXBvcnQgeyBnZXRVQSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuZXhwb3J0IGNvbnN0IGVudW0gQ2xpZW50SW1wbGVtZW50YXRpb24ge1xuICBDT1JFID0gJ0pzQ29yZSdcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gQ2xpZW50UGxhdGZvcm0ge1xuICBCUk9XU0VSID0gJ0Jyb3dzZXInLFxuICBOT0RFID0gJ05vZGUnLFxuICBSRUFDVF9OQVRJVkUgPSAnUmVhY3ROYXRpdmUnLFxuICBDT1JET1ZBID0gJ0NvcmRvdmEnLFxuICBXT1JLRVIgPSAnV29ya2VyJ1xufVxuXG4vKlxuICogRGV0ZXJtaW5lIHRoZSBTREsgdmVyc2lvbiBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRDbGllbnRWZXJzaW9uKFxuICBjbGllbnRQbGF0Zm9ybTogQ2xpZW50UGxhdGZvcm0sXG4gIGZyYW1ld29ya3M6IHJlYWRvbmx5IHN0cmluZ1tdID0gW11cbik6IHN0cmluZyB7XG4gIGxldCByZXBvcnRlZFBsYXRmb3JtOiBzdHJpbmc7XG4gIHN3aXRjaCAoY2xpZW50UGxhdGZvcm0pIHtcbiAgICBjYXNlIENsaWVudFBsYXRmb3JtLkJST1dTRVI6XG4gICAgICAvLyBJbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQsIHJlcG9ydCB0aGUgYnJvd3NlciBuYW1lLlxuICAgICAgcmVwb3J0ZWRQbGF0Zm9ybSA9IF9nZXRCcm93c2VyTmFtZShnZXRVQSgpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ2xpZW50UGxhdGZvcm0uV09SS0VSOlxuICAgICAgLy8gVGVjaG5pY2FsbHkgYSB3b3JrZXIgcnVucyBmcm9tIGEgYnJvd3NlciBidXQgd2UgbmVlZCB0byBkaWZmZXJlbnRpYXRlIGFcbiAgICAgIC8vIHdvcmtlciBmcm9tIGEgYnJvd3Nlci5cbiAgICAgIC8vIEZvciBleGFtcGxlOiBDaHJvbWUtV29ya2VyL0pzQ29yZS80LjkuMS9GaXJlYmFzZUNvcmUtd2ViLlxuICAgICAgcmVwb3J0ZWRQbGF0Zm9ybSA9IGAke19nZXRCcm93c2VyTmFtZShnZXRVQSgpKX0tJHtjbGllbnRQbGF0Zm9ybX1gO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBjbGllbnRQbGF0Zm9ybTtcbiAgfVxuICBjb25zdCByZXBvcnRlZEZyYW1ld29ya3MgPSBmcmFtZXdvcmtzLmxlbmd0aFxuICAgID8gZnJhbWV3b3Jrcy5qb2luKCcsJylcbiAgICA6ICdGaXJlYmFzZUNvcmUtd2ViJzsgLyogZGVmYXVsdCB2YWx1ZSBpZiBubyBvdGhlciBmcmFtZXdvcmsgaXMgdXNlZCAqL1xuICByZXR1cm4gYCR7cmVwb3J0ZWRQbGF0Zm9ybX0vJHtDbGllbnRJbXBsZW1lbnRhdGlvbi5DT1JFfS8ke1NES19WRVJTSU9OfS8ke3JlcG9ydGVkRnJhbWV3b3Jrc31gO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRW5kcG9pbnQsXG4gIEh0dHBNZXRob2QsXG4gIFJlY2FwdGNoYUNsaWVudFR5cGUsXG4gIFJlY2FwdGNoYVZlcnNpb24sXG4gIF9wZXJmb3JtQXBpUmVxdWVzdCxcbiAgX2FkZFRpZElmTmVjZXNzYXJ5XG59IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IEF1dGggfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbnRlcmZhY2UgR2V0UmVjYXB0Y2hhUGFyYW1SZXNwb25zZSB7XG4gIHJlY2FwdGNoYVNpdGVLZXk/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWNhcHRjaGFQYXJhbXMoYXV0aDogQXV0aCk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiAoXG4gICAgKFxuICAgICAgYXdhaXQgX3BlcmZvcm1BcGlSZXF1ZXN0PHZvaWQsIEdldFJlY2FwdGNoYVBhcmFtUmVzcG9uc2U+KFxuICAgICAgICBhdXRoLFxuICAgICAgICBIdHRwTWV0aG9kLkdFVCxcbiAgICAgICAgRW5kcG9pbnQuR0VUX1JFQ0FQVENIQV9QQVJBTVxuICAgICAgKVxuICAgICkucmVjYXB0Y2hhU2l0ZUtleSB8fCAnJ1xuICApO1xufVxuXG4vLyBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgZm9yIHJlQ0FQVENIQSBlbnRlcnByaXNlIGludGVncmF0aW9uLlxuaW50ZXJmYWNlIEdldFJlY2FwdGNoYUNvbmZpZ1JlcXVlc3Qge1xuICB0ZW5hbnRJZD86IHN0cmluZztcbiAgY2xpZW50VHlwZT86IFJlY2FwdGNoYUNsaWVudFR5cGU7XG4gIHZlcnNpb24/OiBSZWNhcHRjaGFWZXJzaW9uO1xufVxuXG5pbnRlcmZhY2UgUmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSB7XG4gIHByb3ZpZGVyOiBzdHJpbmc7XG4gIGVuZm9yY2VtZW50U3RhdGU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRSZWNhcHRjaGFDb25maWdSZXNwb25zZSB7XG4gIHJlY2FwdGNoYUtleTogc3RyaW5nO1xuICByZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlOiBSZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlW107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWNhcHRjaGFDb25maWcoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IEdldFJlY2FwdGNoYUNvbmZpZ1JlcXVlc3Rcbik6IFByb21pc2U8R2V0UmVjYXB0Y2hhQ29uZmlnUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxcbiAgICBHZXRSZWNhcHRjaGFDb25maWdSZXF1ZXN0LFxuICAgIEdldFJlY2FwdGNoYUNvbmZpZ1Jlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLkdFVCxcbiAgICBFbmRwb2ludC5HRVRfUkVDQVBUQ0hBX0NPTkZJRyxcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFJlY2FwdGNoYVBhcmFtZXRlcnMgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgR2V0UmVjYXB0Y2hhQ29uZmlnUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vcmVjYXB0Y2hhJztcblxuLy8gcmVDQVBUQ0hBIHYyIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBSZWNhcHRjaGEge1xuICByZW5kZXI6IChjb250YWluZXI6IEhUTUxFbGVtZW50LCBwYXJhbWV0ZXJzOiBSZWNhcHRjaGFQYXJhbWV0ZXJzKSA9PiBudW1iZXI7XG4gIGdldFJlc3BvbnNlOiAoaWQ6IG51bWJlcikgPT4gc3RyaW5nO1xuICBleGVjdXRlOiAoaWQ6IG51bWJlcikgPT4gdW5rbm93bjtcbiAgcmVzZXQ6IChpZDogbnVtYmVyKSA9PiB1bmtub3duO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWMihcbiAgZ3JlY2FwdGNoYTogUmVjYXB0Y2hhIHwgR3JlQ0FQVENIQSB8IHVuZGVmaW5lZFxuKTogZ3JlY2FwdGNoYSBpcyBSZWNhcHRjaGEge1xuICByZXR1cm4gKFxuICAgIGdyZWNhcHRjaGEgIT09IHVuZGVmaW5lZCAmJlxuICAgIChncmVjYXB0Y2hhIGFzIFJlY2FwdGNoYSkuZ2V0UmVzcG9uc2UgIT09IHVuZGVmaW5lZFxuICApO1xufVxuXG4vLyByZUNBUFRDSEEgRW50ZXJwcmlzZSAmIHYzIHNoYXJlZCBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgR3JlQ0FQVENIQVRvcExldmVsIGV4dGVuZHMgR3JlQ0FQVENIQSB7XG4gIGVudGVycHJpc2U6IEdyZUNBUFRDSEE7XG59XG5cbi8vIHJlQ0FQVENIQSBFbnRlcnByaXNlIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBHcmVDQVBUQ0hBIHtcbiAgcmVhZHk6IChjYWxsYmFjazogKCkgPT4gdm9pZCkgPT4gdm9pZDtcbiAgZXhlY3V0ZTogKHNpdGVLZXk6IHN0cmluZywgb3B0aW9uczogeyBhY3Rpb246IHN0cmluZyB9KSA9PiBQcm9taXNlPHN0cmluZz47XG4gIHJlbmRlcjogKFxuICAgIGNvbnRhaW5lcjogc3RyaW5nIHwgSFRNTEVsZW1lbnQsXG4gICAgcGFyYW1ldGVyczogR3JlQ0FQVENIQVJlbmRlck9wdGlvblxuICApID0+IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcmVDQVBUQ0hBUmVuZGVyT3B0aW9uIHtcbiAgc2l0ZWtleTogc3RyaW5nO1xuICBzaXplOiAnaW52aXNpYmxlJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW50ZXJwcmlzZShcbiAgZ3JlY2FwdGNoYTogUmVjYXB0Y2hhIHwgR3JlQ0FQVENIQSB8IHVuZGVmaW5lZFxuKTogZ3JlY2FwdGNoYSBpcyBHcmVDQVBUQ0hBVG9wTGV2ZWwge1xuICByZXR1cm4gKFxuICAgIGdyZWNhcHRjaGEgIT09IHVuZGVmaW5lZCAmJlxuICAgIChncmVjYXB0Y2hhIGFzIEdyZUNBUFRDSEFUb3BMZXZlbCkuZW50ZXJwcmlzZSAhPT0gdW5kZWZpbmVkXG4gICk7XG59XG5cbi8vIFRPRE8oY2h1YW5yKTogUmVwbGFjZSB0aGlzIHdpdGggdGhlIEF1dGhXaW5kb3cgYWZ0ZXIgcmVzb2x2aW5nIHRoZSBkZXBlbmRlbmN5IGlzc3VlIGluIE5vZGUuanMgZW52LlxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBncmVjYXB0Y2hhPzogUmVjYXB0Y2hhIHwgR3JlQ0FQVENIQVRvcExldmVsO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSZWNhcHRjaGFDb25maWcge1xuICAvKipcbiAgICogVGhlIHJlQ0FQVENIQSBzaXRlIGtleS5cbiAgICovXG4gIHNpdGVLZXk6IHN0cmluZyA9ICcnO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVDQVBUQ0hBIGVuYWJsZW1lbnQgc3RhdHVzIG9mIHRoZSB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IGZvciB0aGUgY3VycmVudCB0ZW5hbnQuXG4gICAqL1xuICBlbWFpbFBhc3N3b3JkRW5hYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlOiBHZXRSZWNhcHRjaGFDb25maWdSZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5yZWNhcHRjaGFLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNhcHRjaGFLZXkgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIC8vIEV4YW1wbGUgcmVzcG9uc2UucmVjYXB0Y2hhS2V5OiBcInByb2plY3RzL3Byb2oxMjMva2V5cy9zaXRla2V5MTIzXCJcbiAgICB0aGlzLnNpdGVLZXkgPSByZXNwb25zZS5yZWNhcHRjaGFLZXkuc3BsaXQoJy8nKVszXTtcbiAgICB0aGlzLmVtYWlsUGFzc3dvcmRFbmFibGVkID0gcmVzcG9uc2UucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZS5zb21lKFxuICAgICAgZW5mb3JjZW1lbnRTdGF0ZSA9PlxuICAgICAgICBlbmZvcmNlbWVudFN0YXRlLnByb3ZpZGVyID09PSAnRU1BSUxfUEFTU1dPUkRfUFJPVklERVInICYmXG4gICAgICAgIGVuZm9yY2VtZW50U3RhdGUuZW5mb3JjZW1lbnRTdGF0ZSAhPT0gJ09GRidcbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgX2NyZWF0ZUVycm9yIH0gZnJvbSAnLi4vY29yZS91dGlsL2Fzc2VydCc7XG5cbmZ1bmN0aW9uIGdldFNjcmlwdFBhcmVudEVsZW1lbnQoKTogSFRNTERvY3VtZW50IHwgSFRNTEhlYWRFbGVtZW50IHtcbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJyk/LlswXSA/PyBkb2N1bWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9sb2FkSlModXJsOiBzdHJpbmcpOiBQcm9taXNlPEV2ZW50PiB7XG4gIC8vIFRPRE86IGNvbnNpZGVyIGFkZGluZyB0aW1lb3V0IHN1cHBvcnQgJiBjYW5jZWxsYXRpb25cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsKTtcbiAgICBlbC5vbmxvYWQgPSByZXNvbHZlO1xuICAgIGVsLm9uZXJyb3IgPSBlID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gX2NyZWF0ZUVycm9yKEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgICAgZXJyb3IuY3VzdG9tRGF0YSA9IGUgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfTtcbiAgICBlbC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgZWwuY2hhcnNldCA9ICdVVEYtOCc7XG4gICAgZ2V0U2NyaXB0UGFyZW50RWxlbWVudCgpLmFwcGVuZENoaWxkKGVsKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2VuZXJhdGVDYWxsYmFja05hbWUocHJlZml4OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gYF9fJHtwcmVmaXh9JHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKX1gO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgaXNFbnRlcnByaXNlLCBSZWNhcHRjaGFDb25maWcgfSBmcm9tICcuL3JlY2FwdGNoYSc7XG5pbXBvcnQgeyBnZXRSZWNhcHRjaGFDb25maWcgfSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vcmVjYXB0Y2hhJztcbmltcG9ydCB7XG4gIFJlY2FwdGNoYUNsaWVudFR5cGUsXG4gIFJlY2FwdGNoYVZlcnNpb24sXG4gIFJlY2FwdGNoYUFjdGlvbk5hbWVcbn0gZnJvbSAnLi4vLi4vYXBpJztcblxuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4uLy4uL2NvcmUvYXV0aC9hdXRoX2ltcGwnO1xuaW1wb3J0ICogYXMganNIZWxwZXJzIGZyb20gJy4uL2xvYWRfanMnO1xuXG5jb25zdCBSRUNBUFRDSEFfRU5URVJQUklTRV9VUkwgPVxuICAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9yZWNhcHRjaGEvZW50ZXJwcmlzZS5qcz9yZW5kZXI9JztcblxuZXhwb3J0IGNvbnN0IFJFQ0FQVENIQV9FTlRFUlBSSVNFX1ZFUklGSUVSX1RZUEUgPSAncmVjYXB0Y2hhLWVudGVycHJpc2UnO1xuZXhwb3J0IGNvbnN0IEZBS0VfVE9LRU4gPSAnTk9fUkVDQVBUQ0hBJztcblxuZXhwb3J0IGNsYXNzIFJlY2FwdGNoYUVudGVycHJpc2VWZXJpZmllciB7XG4gIC8qKlxuICAgKiBJZGVudGlmaWVzIHRoZSB0eXBlIG9mIGFwcGxpY2F0aW9uIHZlcmlmaWVyIChlLmcuIFwicmVjYXB0Y2hhLWVudGVycHJpc2VcIikuXG4gICAqL1xuICByZWFkb25seSB0eXBlID0gUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVkVSSUZJRVJfVFlQRTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGF1dGg6IEF1dGhJbnRlcm5hbDtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGF1dGhFeHRlcm4gLSBUaGUgY29ycmVzcG9uZGluZyBGaXJlYmFzZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhdXRoRXh0ZXJuOiBBdXRoKSB7XG4gICAgdGhpcy5hdXRoID0gX2Nhc3RBdXRoKGF1dGhFeHRlcm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSB2ZXJpZmljYXRpb24gcHJvY2Vzcy5cbiAgICpcbiAgICogQHJldHVybnMgQSBQcm9taXNlIGZvciBhIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSB2YWxpZGl0eSBvZiBhIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyB2ZXJpZnkoXG4gICAgYWN0aW9uOiBzdHJpbmcgPSAndmVyaWZ5JyxcbiAgICBmb3JjZVJlZnJlc2ggPSBmYWxzZVxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIHJldHJpZXZlU2l0ZUtleShhdXRoOiBBdXRoSW50ZXJuYWwpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgaWYgKCFmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgaWYgKGF1dGgudGVuYW50SWQgPT0gbnVsbCAmJiBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGF1dGguX2FnZW50UmVjYXB0Y2hhQ29uZmlnLnNpdGVLZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGF1dGgudGVuYW50SWQgIT0gbnVsbCAmJlxuICAgICAgICAgIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0gIT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gYXV0aC5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1thdXRoLnRlbmFudElkXS5zaXRlS2V5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZ2V0UmVjYXB0Y2hhQ29uZmlnKGF1dGgsIHtcbiAgICAgICAgICBjbGllbnRUeXBlOiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQixcbiAgICAgICAgICB2ZXJzaW9uOiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0VcbiAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UucmVjYXB0Y2hhS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigncmVjYXB0Y2hhIEVudGVycHJpc2Ugc2l0ZSBrZXkgdW5kZWZpbmVkJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gbmV3IFJlY2FwdGNoYUNvbmZpZyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgIGlmIChhdXRoLnRlbmFudElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdXRoLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW2F1dGgudGVuYW50SWRdID0gY29uZmlnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGNvbmZpZy5zaXRlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV0cmlldmVSZWNhcHRjaGFUb2tlbihcbiAgICAgIHNpdGVLZXk6IHN0cmluZyxcbiAgICAgIHJlc29sdmU6ICh2YWx1ZTogc3RyaW5nIHwgUHJvbWlzZUxpa2U8c3RyaW5nPikgPT4gdm9pZCxcbiAgICAgIHJlamVjdDogKHJlYXNvbj86IHVua25vd24pID0+IHZvaWRcbiAgICApOiB2b2lkIHtcbiAgICAgIGNvbnN0IGdyZWNhcHRjaGEgPSB3aW5kb3cuZ3JlY2FwdGNoYTtcbiAgICAgIGlmIChpc0VudGVycHJpc2UoZ3JlY2FwdGNoYSkpIHtcbiAgICAgICAgZ3JlY2FwdGNoYS5lbnRlcnByaXNlLnJlYWR5KCgpID0+IHtcbiAgICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2VcbiAgICAgICAgICAgIC5leGVjdXRlKHNpdGVLZXksIHsgYWN0aW9uIH0pXG4gICAgICAgICAgICAudGhlbih0b2tlbiA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUodG9rZW4pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUoRkFLRV9UT0tFTik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QoRXJyb3IoJ05vIHJlQ0FQVENIQSBlbnRlcnByaXNlIHNjcmlwdCBsb2FkZWQuJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJldHJpZXZlU2l0ZUtleSh0aGlzLmF1dGgpXG4gICAgICAgIC50aGVuKHNpdGVLZXkgPT4ge1xuICAgICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIGlzRW50ZXJwcmlzZSh3aW5kb3cuZ3JlY2FwdGNoYSkpIHtcbiAgICAgICAgICAgIHJldHJpZXZlUmVjYXB0Y2hhVG9rZW4oc2l0ZUtleSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoJ1JlY2FwdGNoYVZlcmlmaWVyIGlzIG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqc0hlbHBlcnNcbiAgICAgICAgICAgICAgLl9sb2FkSlMoUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVVJMICsgc2l0ZUtleSlcbiAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHJpZXZlUmVjYXB0Y2hhVG9rZW4oc2l0ZUtleSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluamVjdFJlY2FwdGNoYUZpZWxkczxUPihcbiAgYXV0aDogQXV0aEludGVybmFsLFxuICByZXF1ZXN0OiBULFxuICBhY3Rpb246IFJlY2FwdGNoYUFjdGlvbk5hbWUsXG4gIGNhcHRjaGFSZXNwID0gZmFsc2Vcbik6IFByb21pc2U8VD4ge1xuICBjb25zdCB2ZXJpZmllciA9IG5ldyBSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIoYXV0aCk7XG4gIGxldCBjYXB0Y2hhUmVzcG9uc2U7XG4gIHRyeSB7XG4gICAgY2FwdGNoYVJlc3BvbnNlID0gYXdhaXQgdmVyaWZpZXIudmVyaWZ5KGFjdGlvbik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdGNoYVJlc3BvbnNlID0gYXdhaXQgdmVyaWZpZXIudmVyaWZ5KGFjdGlvbiwgdHJ1ZSk7XG4gIH1cbiAgY29uc3QgbmV3UmVxdWVzdCA9IHsgLi4ucmVxdWVzdCB9O1xuICBpZiAoIWNhcHRjaGFSZXNwKSB7XG4gICAgT2JqZWN0LmFzc2lnbihuZXdSZXF1ZXN0LCB7IGNhcHRjaGFSZXNwb25zZSB9KTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgJ2NhcHRjaGFSZXNwJzogY2FwdGNoYVJlc3BvbnNlIH0pO1xuICB9XG4gIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwgeyAnY2xpZW50VHlwZSc6IFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCIH0pO1xuICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHtcbiAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFJlY2FwdGNoYVZlcnNpb24uRU5URVJQUklTRVxuICB9KTtcbiAgcmV0dXJuIG5ld1JlcXVlc3Q7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IFVuc3Vic2NyaWJlLCBVc2VyIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5pbnRlcmZhY2UgTWlkZGxld2FyZUVudHJ5IHtcbiAgKHVzZXI6IFVzZXIgfCBudWxsKTogUHJvbWlzZTx2b2lkPjtcbiAgb25BYm9ydD86ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoTWlkZGxld2FyZVF1ZXVlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBxdWV1ZTogTWlkZGxld2FyZUVudHJ5W10gPSBbXTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGF1dGg6IEF1dGhJbnRlcm5hbCkge31cblxuICBwdXNoQ2FsbGJhY2soXG4gICAgY2FsbGJhY2s6ICh1c2VyOiBVc2VyIHwgbnVsbCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gICAgb25BYm9ydD86ICgpID0+IHZvaWRcbiAgKTogVW5zdWJzY3JpYmUge1xuICAgIC8vIFRoZSBjYWxsYmFjayBjb3VsZCBiZSBzeW5jIG9yIGFzeW5jLiBXcmFwIGl0IGludG8gYVxuICAgIC8vIGZ1bmN0aW9uIHRoYXQgaXMgYWx3YXlzIGFzeW5jLlxuICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjazogTWlkZGxld2FyZUVudHJ5ID0gKFxuICAgICAgdXNlcjogVXNlciB8IG51bGxcbiAgICApOiBQcm9taXNlPHZvaWQ+ID0+XG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2sodXNlcik7XG4gICAgICAgICAgLy8gRWl0aGVyIHJlc29sdmUgd2l0aCBleGlzdGluZyBwcm9taXNlIG9yIHdyYXAgYSBub24tcHJvbWlzZVxuICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpbnRvIGEgcHJvbWlzZS5cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBTeW5jIGNhbGxiYWNrIHRocm93cy5cbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIC8vIEF0dGFjaCB0aGUgb25BYm9ydCBpZiBwcmVzZW50XG4gICAgd3JhcHBlZENhbGxiYWNrLm9uQWJvcnQgPSBvbkFib3J0O1xuICAgIHRoaXMucXVldWUucHVzaCh3cmFwcGVkQ2FsbGJhY2spO1xuXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIFVuc3Vic2NyaWJlLiBSZXBsYWNlIHdpdGggbm8tb3AuIERvIG5vdCByZW1vdmUgZnJvbSBhcnJheSwgb3IgaXQgd2lsbCBkaXN0dXJiXG4gICAgICAvLyBpbmRleGluZyBvZiBvdGhlciBlbGVtZW50cy5cbiAgICAgIHRoaXMucXVldWVbaW5kZXhdID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHJ1bk1pZGRsZXdhcmUobmV4dFVzZXI6IFVzZXIgfCBudWxsKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuYXV0aC5jdXJyZW50VXNlciA9PT0gbmV4dFVzZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXaGlsZSBydW5uaW5nIHRoZSBtaWRkbGV3YXJlLCBidWlsZCBhIHRlbXBvcmFyeSBzdGFjayBvZiBvbkFib3J0XG4gICAgLy8gY2FsbGJhY2tzIHRvIGNhbGwgaWYgb25lIG1pZGRsZXdhcmUgY2FsbGJhY2sgcmVqZWN0cy5cblxuICAgIGNvbnN0IG9uQWJvcnRTdGFjazogQXJyYXk8KCkgPT4gdm9pZD4gPSBbXTtcbiAgICB0cnkge1xuICAgICAgZm9yIChjb25zdCBiZWZvcmVTdGF0ZUNhbGxiYWNrIG9mIHRoaXMucXVldWUpIHtcbiAgICAgICAgYXdhaXQgYmVmb3JlU3RhdGVDYWxsYmFjayhuZXh0VXNlcik7XG5cbiAgICAgICAgLy8gT25seSBwdXNoIHRoZSBvbkFib3J0IGlmIHRoZSBjYWxsYmFjayBzdWNjZWVkc1xuICAgICAgICBpZiAoYmVmb3JlU3RhdGVDYWxsYmFjay5vbkFib3J0KSB7XG4gICAgICAgICAgb25BYm9ydFN0YWNrLnB1c2goYmVmb3JlU3RhdGVDYWxsYmFjay5vbkFib3J0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFJ1biBhbGwgb25BYm9ydCwgd2l0aCBzZXBhcmF0ZSB0cnkvY2F0Y2ggdG8gaWdub3JlIGFueSBlcnJvcnMgYW5kXG4gICAgICAvLyBjb250aW51ZVxuICAgICAgb25BYm9ydFN0YWNrLnJldmVyc2UoKTtcbiAgICAgIGZvciAoY29uc3Qgb25BYm9ydCBvZiBvbkFib3J0U3RhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvbkFib3J0KCk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAvKiBzd2FsbG93IGVycm9yICovXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgdGhpcy5hdXRoLl9lcnJvckZhY3RvcnkuY3JlYXRlKEF1dGhFcnJvckNvZGUuTE9HSU5fQkxPQ0tFRCwge1xuICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IChlIGFzIEVycm9yKT8ubWVzc2FnZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBfRmlyZWJhc2VTZXJ2aWNlLCBGaXJlYmFzZUFwcCB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IEFwcENoZWNrSW50ZXJuYWxDb21wb25lbnROYW1lIH0gZnJvbSAnQGZpcmViYXNlL2FwcC1jaGVjay1pbnRlcm9wLXR5cGVzJztcbmltcG9ydCB7XG4gIEF1dGgsXG4gIEF1dGhFcnJvck1hcCxcbiAgQXV0aFNldHRpbmdzLFxuICBFbXVsYXRvckNvbmZpZyxcbiAgTmV4dE9yT2JzZXJ2ZXIsXG4gIFBlcnNpc3RlbmNlLFxuICBQb3B1cFJlZGlyZWN0UmVzb2x2ZXIsXG4gIFVzZXIsXG4gIFVzZXJDcmVkZW50aWFsLFxuICBDb21wbGV0ZUZuLFxuICBFcnJvckZuLFxuICBOZXh0Rm4sXG4gIFVuc3Vic2NyaWJlXG59IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVTdWJzY3JpYmUsXG4gIEVycm9yRmFjdG9yeSxcbiAgRmlyZWJhc2VFcnJvcixcbiAgZ2V0TW9kdWxhckluc3RhbmNlLFxuICBPYnNlcnZlcixcbiAgU3Vic2NyaWJlXG59IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHsgQXV0aEludGVybmFsLCBDb25maWdJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9wb3B1cF9yZWRpcmVjdCc7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7XG4gIEF1dGhFcnJvckNvZGUsXG4gIEF1dGhFcnJvclBhcmFtcyxcbiAgRXJyb3JNYXBSZXRyaWV2ZXIsXG4gIF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWVxufSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgUGVyc2lzdGVuY2VJbnRlcm5hbCB9IGZyb20gJy4uL3BlcnNpc3RlbmNlJztcbmltcG9ydCB7XG4gIEtleU5hbWUsXG4gIFBlcnNpc3RlbmNlVXNlck1hbmFnZXJcbn0gZnJvbSAnLi4vcGVyc2lzdGVuY2UvcGVyc2lzdGVuY2VfdXNlcl9tYW5hZ2VyJztcbmltcG9ydCB7IF9yZWxvYWRXaXRob3V0U2F2aW5nIH0gZnJvbSAnLi4vdXNlci9yZWxvYWQnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IF9nZXRJbnN0YW5jZSB9IGZyb20gJy4uL3V0aWwvaW5zdGFudGlhdG9yJztcbmltcG9ydCB7IF9nZXRVc2VyTGFuZ3VhZ2UgfSBmcm9tICcuLi91dGlsL25hdmlnYXRvcic7XG5pbXBvcnQgeyBfZ2V0Q2xpZW50VmVyc2lvbiB9IGZyb20gJy4uL3V0aWwvdmVyc2lvbic7XG5pbXBvcnQgeyBIdHRwSGVhZGVyLCBSZWNhcHRjaGFDbGllbnRUeXBlLCBSZWNhcHRjaGFWZXJzaW9uIH0gZnJvbSAnLi4vLi4vYXBpJztcbmltcG9ydCB7IGdldFJlY2FwdGNoYUNvbmZpZyB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9yZWNhcHRjaGEnO1xuaW1wb3J0IHsgUmVjYXB0Y2hhRW50ZXJwcmlzZVZlcmlmaWVyIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm1fYnJvd3Nlci9yZWNhcHRjaGEvcmVjYXB0Y2hhX2VudGVycHJpc2VfdmVyaWZpZXInO1xuaW1wb3J0IHsgQXV0aE1pZGRsZXdhcmVRdWV1ZSB9IGZyb20gJy4vbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBSZWNhcHRjaGFDb25maWcgfSBmcm9tICcuLi8uLi9wbGF0Zm9ybV9icm93c2VyL3JlY2FwdGNoYS9yZWNhcHRjaGEnO1xuaW1wb3J0IHsgX2xvZ1dhcm4gfSBmcm9tICcuLi91dGlsL2xvZyc7XG5cbmludGVyZmFjZSBBc3luY0FjdGlvbiB7XG4gICgpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG5leHBvcnQgY29uc3QgZW51bSBEZWZhdWx0Q29uZmlnIHtcbiAgVE9LRU5fQVBJX0hPU1QgPSAnc2VjdXJldG9rZW4uZ29vZ2xlYXBpcy5jb20nLFxuICBBUElfSE9TVCA9ICdpZGVudGl0eXRvb2xraXQuZ29vZ2xlYXBpcy5jb20nLFxuICBBUElfU0NIRU1FID0gJ2h0dHBzJ1xufVxuXG5leHBvcnQgY2xhc3MgQXV0aEltcGwgaW1wbGVtZW50cyBBdXRoSW50ZXJuYWwsIF9GaXJlYmFzZVNlcnZpY2Uge1xuICBjdXJyZW50VXNlcjogVXNlciB8IG51bGwgPSBudWxsO1xuICBlbXVsYXRvckNvbmZpZzogRW11bGF0b3JDb25maWcgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBvcGVyYXRpb25zID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHByaXZhdGUgcGVyc2lzdGVuY2VNYW5hZ2VyPzogUGVyc2lzdGVuY2VVc2VyTWFuYWdlcjtcbiAgcHJpdmF0ZSByZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcj86IFBlcnNpc3RlbmNlVXNlck1hbmFnZXI7XG4gIHByaXZhdGUgYXV0aFN0YXRlU3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbjxVc2VyPih0aGlzKTtcbiAgcHJpdmF0ZSBpZFRva2VuU3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbjxVc2VyPih0aGlzKTtcbiAgcHJpdmF0ZSByZWFkb25seSBiZWZvcmVTdGF0ZVF1ZXVlID0gbmV3IEF1dGhNaWRkbGV3YXJlUXVldWUodGhpcyk7XG4gIHByaXZhdGUgcmVkaXJlY3RVc2VyOiBVc2VySW50ZXJuYWwgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gQW55IG5ldHdvcmsgY2FsbHMgd2lsbCBzZXQgdGhpcyB0byB0cnVlIGFuZCBwcmV2ZW50IHN1YnNlcXVlbnQgZW11bGF0b3JcbiAgLy8gaW5pdGlhbGl6YXRpb25cbiAgX2NhbkluaXRFbXVsYXRvciA9IHRydWU7XG4gIF9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIF9kZWxldGVkID0gZmFsc2U7XG4gIF9pbml0aWFsaXphdGlvblByb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbDtcbiAgX3BvcHVwUmVkaXJlY3RSZXNvbHZlcjogUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWwgfCBudWxsID0gbnVsbDtcbiAgX2Vycm9yRmFjdG9yeTogRXJyb3JGYWN0b3J5PEF1dGhFcnJvckNvZGUsIEF1dGhFcnJvclBhcmFtcz4gPVxuICAgIF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWTtcbiAgX2FnZW50UmVjYXB0Y2hhQ29uZmlnOiBSZWNhcHRjaGFDb25maWcgfCBudWxsID0gbnVsbDtcbiAgX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3M6IFJlY29yZDxzdHJpbmcsIFJlY2FwdGNoYUNvbmZpZz4gPSB7fTtcbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8vIFRyYWNrcyB0aGUgbGFzdCBub3RpZmllZCBVSUQgZm9yIHN0YXRlIGNoYW5nZSBsaXN0ZW5lcnMgdG8gcHJldmVudFxuICAvLyByZXBlYXRlZCBjYWxscyB0byB0aGUgY2FsbGJhY2tzLiBVbmRlZmluZWQgbWVhbnMgaXQncyBuZXZlciBiZWVuXG4gIC8vIGNhbGxlZCwgd2hlcmVhcyBudWxsIG1lYW5zIGl0J3MgYmVlbiBjYWxsZWQgd2l0aCBhIHNpZ25lZCBvdXQgdXNlclxuICBwcml2YXRlIGxhc3ROb3RpZmllZFVpZDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICBsYW5ndWFnZUNvZGU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICB0ZW5hbnRJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHNldHRpbmdzOiBBdXRoU2V0dGluZ3MgPSB7IGFwcFZlcmlmaWNhdGlvbkRpc2FibGVkRm9yVGVzdGluZzogZmFsc2UgfTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgYXBwOiBGaXJlYmFzZUFwcCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlcjogUHJvdmlkZXI8J2hlYXJ0YmVhdCc+LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXI6IFByb3ZpZGVyPEFwcENoZWNrSW50ZXJuYWxDb21wb25lbnROYW1lPixcbiAgICBwdWJsaWMgcmVhZG9ubHkgY29uZmlnOiBDb25maWdJbnRlcm5hbFxuICApIHtcbiAgICB0aGlzLm5hbWUgPSBhcHAubmFtZTtcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBjb25maWcuc2RrQ2xpZW50VmVyc2lvbjtcbiAgfVxuXG4gIF9pbml0aWFsaXplV2l0aFBlcnNpc3RlbmNlKFxuICAgIHBlcnNpc3RlbmNlSGllcmFyY2h5OiBQZXJzaXN0ZW5jZUludGVybmFsW10sXG4gICAgcG9wdXBSZWRpcmVjdFJlc29sdmVyPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgIHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciA9IF9nZXRJbnN0YW5jZShwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpO1xuICAgIH1cblxuICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGFwcCBkZWxldGlvbiB0aHJvdWdob3V0IGluaXRpYWxpemF0aW9uIChhZnRlciBlYWNoXG4gICAgLy8gcHJvbWlzZSByZXNvbHV0aW9uKVxuICAgIHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZSA9IHRoaXMucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBlcnNpc3RlbmNlTWFuYWdlciA9IGF3YWl0IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIuY3JlYXRlKFxuICAgICAgICB0aGlzLFxuICAgICAgICBwZXJzaXN0ZW5jZUhpZXJhcmNoeVxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXplIHRoZSByZXNvbHZlciBlYXJseSBpZiBuZWNlc3NhcnkgKG9ubHkgYXBwbGljYWJsZSB0byB3ZWI6XG4gICAgICAvLyB0aGlzIHdpbGwgY2F1c2UgdGhlIGlmcmFtZSB0byBsb2FkIGltbWVkaWF0ZWx5IGluIGNlcnRhaW4gY2FzZXMpXG4gICAgICBpZiAodGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyPy5fc2hvdWxkSW5pdFByb2FjdGl2ZWx5KSB7XG4gICAgICAgIC8vIElmIHRoaXMgZmFpbHMsIGRvbid0IGhhbHQgYXV0aCBsb2FkaW5nXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9pbml0aWFsaXplKHRoaXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLyogSWdub3JlIHRoZSBlcnJvciAqL1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUN1cnJlbnRVc2VyKHBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XG4gICAgICB0aGlzLmxhc3ROb3RpZmllZFVpZCA9IHRoaXMuY3VycmVudFVzZXI/LnVpZCB8fCBudWxsO1xuXG4gICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcGVyc2lzdGVuY2UgaXMgY2hhbmdlZCBpbiBhbm90aGVyIHdpbmRvdywgdGhlIHVzZXIgbWFuYWdlciB3aWxsIGxldCB1cyBrbm93XG4gICAqL1xuICBhc3luYyBfb25TdG9yYWdlRXZlbnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLmdldEN1cnJlbnRVc2VyKCk7XG5cbiAgICBpZiAoIXRoaXMuY3VycmVudFVzZXIgJiYgIXVzZXIpIHtcbiAgICAgIC8vIE5vIGNoYW5nZSwgZG8gbm90aGluZyAod2FzIHNpZ25lZCBvdXQgYW5kIHJlbWFpbmVkIHNpZ25lZCBvdXQpLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzYW1lIHVzZXIgaXMgdG8gYmUgc3luY2hyb25pemVkLlxuICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyICYmIHVzZXIgJiYgdGhpcy5jdXJyZW50VXNlci51aWQgPT09IHVzZXIudWlkKSB7XG4gICAgICAvLyBEYXRhIHVwZGF0ZSwgc2ltcGx5IGNvcHkgZGF0YSBjaGFuZ2VzLlxuICAgICAgdGhpcy5fY3VycmVudFVzZXIuX2Fzc2lnbih1c2VyKTtcbiAgICAgIC8vIElmIHRva2VucyBjaGFuZ2VkIGZyb20gcHJldmlvdXMgdXNlciB0b2tlbnMsIHRoaXMgd2lsbCB0cmlnZ2VyXG4gICAgICAvLyBub3RpZnlBdXRoTGlzdGVuZXJzXy5cbiAgICAgIGF3YWl0IHRoaXMuY3VycmVudFVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBjdXJyZW50IEF1dGggc3RhdGUuIEVpdGhlciBhIG5ldyBsb2dpbiBvciBsb2dvdXQuXG4gICAgLy8gU2tpcCBibG9ja2luZyBjYWxsYmFja3MsIHRoZXkgc2hvdWxkIG5vdCBhcHBseSB0byBhIGNoYW5nZSBpbiBhbm90aGVyIHRhYi5cbiAgICBhd2FpdCB0aGlzLl91cGRhdGVDdXJyZW50VXNlcih1c2VyLCAvKiBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgKi8gdHJ1ZSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGluaXRpYWxpemVDdXJyZW50VXNlcihcbiAgICBwb3B1cFJlZGlyZWN0UmVzb2x2ZXI/OiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gRmlyc3QgY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBwZW5kaW5nIHJlZGlyZWN0IGV2ZW50LlxuICAgIGNvbnN0IHByZXZpb3VzbHlTdG9yZWRVc2VyID1cbiAgICAgIChhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UuZ2V0Q3VycmVudFVzZXIoKSkgYXMgVXNlckludGVybmFsIHwgbnVsbDtcbiAgICBsZXQgZnV0dXJlQ3VycmVudFVzZXIgPSBwcmV2aW91c2x5U3RvcmVkVXNlcjtcbiAgICBsZXQgbmVlZHNUb2NoZWNrTWlkZGxld2FyZSA9IGZhbHNlO1xuICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIgJiYgdGhpcy5jb25maWcuYXV0aERvbWFpbikge1xuICAgICAgYXdhaXQgdGhpcy5nZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcigpO1xuICAgICAgY29uc3QgcmVkaXJlY3RVc2VyRXZlbnRJZCA9IHRoaXMucmVkaXJlY3RVc2VyPy5fcmVkaXJlY3RFdmVudElkO1xuICAgICAgY29uc3Qgc3RvcmVkVXNlckV2ZW50SWQgPSBmdXR1cmVDdXJyZW50VXNlcj8uX3JlZGlyZWN0RXZlbnRJZDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudHJ5UmVkaXJlY3RTaWduSW4ocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcblxuICAgICAgLy8gSWYgdGhlIHN0b3JlZCB1c2VyIChpLmUuIHRoZSBvbGQgXCJjdXJyZW50VXNlclwiKSBoYXMgYSByZWRpcmVjdElkIHRoYXRcbiAgICAgIC8vIG1hdGNoZXMgdGhlIHJlZGlyZWN0IHVzZXIsIHRoZW4gd2Ugd2FudCB0byBpbml0aWFsbHkgc2lnbiBpbiB3aXRoIHRoZVxuICAgICAgLy8gbmV3IHVzZXIgb2JqZWN0IGZyb20gcmVzdWx0LlxuICAgICAgLy8gVE9ETyhzYW1naG8pOiBNb3JlIHRob3JvdWdobHkgdGVzdCBhbGwgb2YgdGhpc1xuICAgICAgaWYgKFxuICAgICAgICAoIXJlZGlyZWN0VXNlckV2ZW50SWQgfHwgcmVkaXJlY3RVc2VyRXZlbnRJZCA9PT0gc3RvcmVkVXNlckV2ZW50SWQpICYmXG4gICAgICAgIHJlc3VsdD8udXNlclxuICAgICAgKSB7XG4gICAgICAgIGZ1dHVyZUN1cnJlbnRVc2VyID0gcmVzdWx0LnVzZXIgYXMgVXNlckludGVybmFsO1xuICAgICAgICBuZWVkc1RvY2hlY2tNaWRkbGV3YXJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyB1c2VyIGluIHBlcnNpc3RlbmNlLCB0aGVyZSBpcyBubyBjdXJyZW50IHVzZXIuIFNldCB0byBudWxsLlxuICAgIGlmICghZnV0dXJlQ3VycmVudFVzZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKCFmdXR1cmVDdXJyZW50VXNlci5fcmVkaXJlY3RFdmVudElkKSB7XG4gICAgICAvLyBUaGlzIGlzbid0IGEgcmVkaXJlY3QgbGluayBvcGVyYXRpb24sIHdlIGNhbiByZWxvYWQgYW5kIGJhaWwuXG4gICAgICAvLyBGaXJzdCB0aG91Z2gsIGVuc3VyZSB0aGF0IHdlIGNoZWNrIHRoZSBtaWRkbGV3YXJlIGlzIGhhcHB5LlxuICAgICAgaWYgKG5lZWRzVG9jaGVja01pZGRsZXdhcmUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZShmdXR1cmVDdXJyZW50VXNlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBmdXR1cmVDdXJyZW50VXNlciA9IHByZXZpb3VzbHlTdG9yZWRVc2VyO1xuICAgICAgICAgIC8vIFdlIGtub3cgdGhpcyBpcyBhdmFpbGFibGUgc2luY2UgdGhlIGJpdCBpcyBvbmx5IHNldCB3aGVuIHRoZVxuICAgICAgICAgIC8vIHJlc29sdmVyIGlzIGF2YWlsYWJsZVxuICAgICAgICAgIHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciEuX292ZXJyaWRlUmVkaXJlY3RSZXN1bHQodGhpcywgKCkgPT5cbiAgICAgICAgICAgIFByb21pc2UucmVqZWN0KGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZnV0dXJlQ3VycmVudFVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsb2FkQW5kU2V0Q3VycmVudFVzZXJPckNsZWFyKGZ1dHVyZUN1cnJlbnRVc2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2Fzc2VydCh0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIsIHRoaXMsIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IpO1xuICAgIGF3YWl0IHRoaXMuZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIoKTtcblxuICAgIC8vIElmIHRoZSByZWRpcmVjdCB1c2VyJ3MgZXZlbnQgSUQgbWF0Y2hlcyB0aGUgY3VycmVudCB1c2VyJ3MgZXZlbnQgSUQsXG4gICAgLy8gRE8gTk9UIHJlbG9hZCB0aGUgY3VycmVudCB1c2VyLCBvdGhlcndpc2UgdGhleSdsbCBiZSBjbGVhcmVkIGZyb20gc3RvcmFnZS5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgdGhlIHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0KCkgZmxvdy5cbiAgICBpZiAoXG4gICAgICB0aGlzLnJlZGlyZWN0VXNlciAmJlxuICAgICAgdGhpcy5yZWRpcmVjdFVzZXIuX3JlZGlyZWN0RXZlbnRJZCA9PT0gZnV0dXJlQ3VycmVudFVzZXIuX3JlZGlyZWN0RXZlbnRJZFxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihmdXR1cmVDdXJyZW50VXNlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVsb2FkQW5kU2V0Q3VycmVudFVzZXJPckNsZWFyKGZ1dHVyZUN1cnJlbnRVc2VyKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgdHJ5UmVkaXJlY3RTaWduSW4oXG4gICAgcmVkaXJlY3RSZXNvbHZlcjogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4gICk6IFByb21pc2U8VXNlckNyZWRlbnRpYWwgfCBudWxsPiB7XG4gICAgLy8gVGhlIHJlZGlyZWN0IHVzZXIgbmVlZHMgdG8gYmUgY2hlY2tlZCAoYW5kIHNpZ25lZCBpbiBpZiBhdmFpbGFibGUpXG4gICAgLy8gZHVyaW5nIGF1dGggaW5pdGlhbGl6YXRpb24uIEFsbCBvZiB0aGUgbm9ybWFsIHNpZ24gaW4gYW5kIGxpbmsvcmVhdXRoXG4gICAgLy8gZmxvd3MgY2FsbCBiYWNrIGludG8gYXV0aCBhbmQgcHVzaCB0aGluZ3Mgb250byB0aGUgcHJvbWlzZSBxdWV1ZS4gV2VcbiAgICAvLyBuZWVkIHRvIGF3YWl0IHRoZSByZXN1bHQgb2YgdGhlIHJlZGlyZWN0IHNpZ24gaW4gKmluc2lkZSB0aGUgcHJvbWlzZVxuICAgIC8vIHF1ZXVlKi4gVGhpcyBwcmVzZW50cyBhIHByb2JsZW06IHdlIHJ1biBpbnRvIGRlYWRsb2NrLiBTZWU6XG4gICAgLy8gICAg4pSMPiBbSW5pdGlhbGl6YXRpb25dIOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgIC8vICAgIOKUjD4gWzxvdGhlciBxdWV1ZSB0YXNrcz5dIOKUglxuICAgIC8vICAgIOKUlOKUgCBbZ2V0UmVkaXJlY3RSZXN1bHRdIDzilIDilJhcbiAgICAvLyAgICB3aGVyZSBbXSBhcmUgdGFza3Mgb24gdGhlIHF1ZXVlIGFuZCBhcnJvd3MgZGVub3RlIGF3YWl0c1xuICAgIC8vIEluaXRpYWxpemF0aW9uIHdpbGwgbmV2ZXIgY29tcGxldGUgYmVjYXVzZSBpdCdzIHdhaXRpbmcgb24gc29tZXRoaW5nXG4gICAgLy8gdGhhdCdzIHdhaXRpbmcgZm9yIGluaXRpYWxpemF0aW9uIHRvIGNvbXBsZXRlIVxuICAgIC8vXG4gICAgLy8gSW5zdGVhZCwgdGhpcyBtZXRob2QgY2FsbHMgZ2V0UmVkaXJlY3RSZXN1bHQoKSAoc3RvcmVkIGluXG4gICAgLy8gX2NvbXBsZXRlUmVkaXJlY3RGbikgd2l0aCBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBpbnN0cnVjdHMgYWxsIG9mXG4gICAgLy8gdGhlIHVuZGVybHlpbmcgYXV0aCBvcGVyYXRpb25zIHRvIHNraXAgYW55dGhpbmcgdGhhdCBtdXRhdGVzIGF1dGggc3RhdGUuXG5cbiAgICBsZXQgcmVzdWx0OiBVc2VyQ3JlZGVudGlhbCB8IG51bGwgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAvLyBXZSBrbm93IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciBpcyBzZXQgc2luY2UgcmVkaXJlY3RSZXNvbHZlclxuICAgICAgLy8gaXMgcGFzc2VkIGluLiBUaGUgX2NvbXBsZXRlUmVkaXJlY3RGbiBleHBlY3RzIHRoZSB1bndyYXBwZWQgZXh0ZXJuLlxuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyIS5fY29tcGxldGVSZWRpcmVjdEZuKFxuICAgICAgICB0aGlzLFxuICAgICAgICByZWRpcmVjdFJlc29sdmVyLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFN3YWxsb3cgYW55IGVycm9ycyBoZXJlOyB0aGUgY29kZSBjYW4gcmV0cmlldmUgdGhlbSBpblxuICAgICAgLy8gZ2V0UmVkaXJlY3RSZXN1bHQoKS5cbiAgICAgIGF3YWl0IHRoaXMuX3NldFJlZGlyZWN0VXNlcihudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZWxvYWRBbmRTZXRDdXJyZW50VXNlck9yQ2xlYXIoXG4gICAgdXNlcjogVXNlckludGVybmFsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChlIGFzIEZpcmViYXNlRXJyb3IpPy5jb2RlICE9PVxuICAgICAgICBgYXV0aC8ke0F1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRH1gXG4gICAgICApIHtcbiAgICAgICAgLy8gU29tZXRoaW5nJ3Mgd3Jvbmcgd2l0aCB0aGUgdXNlcidzIHRva2VuLiBMb2cgdGhlbSBvdXQgYW5kIHJlbW92ZVxuICAgICAgICAvLyB0aGVtIGZyb20gc3RvcmFnZVxuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XG4gIH1cblxuICB1c2VEZXZpY2VMYW5ndWFnZSgpOiB2b2lkIHtcbiAgICB0aGlzLmxhbmd1YWdlQ29kZSA9IF9nZXRVc2VyTGFuZ3VhZ2UoKTtcbiAgfVxuXG4gIGFzeW5jIF9kZWxldGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5fZGVsZXRlZCA9IHRydWU7XG4gIH1cblxuICBhc3luYyB1cGRhdGVDdXJyZW50VXNlcih1c2VyRXh0ZXJuOiBVc2VyIHwgbnVsbCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFRoZSBwdWJsaWMgdXBkYXRlQ3VycmVudFVzZXIgbWV0aG9kIG5lZWRzIHRvIG1ha2UgYSBjb3B5IG9mIHRoZSB1c2VyLFxuICAgIC8vIGFuZCBhbHNvIGNoZWNrIHRoYXQgdGhlIHByb2plY3QgbWF0Y2hlc1xuICAgIGNvbnN0IHVzZXIgPSB1c2VyRXh0ZXJuXG4gICAgICA/IChnZXRNb2R1bGFySW5zdGFuY2UodXNlckV4dGVybikgYXMgVXNlckludGVybmFsKVxuICAgICAgOiBudWxsO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICBfYXNzZXJ0KFxuICAgICAgICB1c2VyLmF1dGguY29uZmlnLmFwaUtleSA9PT0gdGhpcy5jb25maWcuYXBpS2V5LFxuICAgICAgICB0aGlzLFxuICAgICAgICBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXIgJiYgdXNlci5fY2xvbmUodGhpcykpO1xuICB9XG5cbiAgYXN5bmMgX3VwZGF0ZUN1cnJlbnRVc2VyKFxuICAgIHVzZXI6IFVzZXIgfCBudWxsLFxuICAgIHNraXBCZWZvcmVTdGF0ZUNhbGxiYWNrczogYm9vbGVhbiA9IGZhbHNlXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1c2VyKSB7XG4gICAgICBfYXNzZXJ0KFxuICAgICAgICB0aGlzLnRlbmFudElkID09PSB1c2VyLnRlbmFudElkLFxuICAgICAgICB0aGlzLFxuICAgICAgICBBdXRoRXJyb3JDb2RlLlRFTkFOVF9JRF9NSVNNQVRDSFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXNraXBCZWZvcmVTdGF0ZUNhbGxiYWNrcykge1xuICAgICAgYXdhaXQgdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnJ1bk1pZGRsZXdhcmUodXNlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIgYXMgVXNlckludGVybmFsIHwgbnVsbCk7XG4gICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNpZ25PdXQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gUnVuIGZpcnN0LCB0byBibG9jayBfc2V0UmVkaXJlY3RVc2VyKCkgaWYgYW55IGNhbGxiYWNrcyBmYWlsLlxuICAgIGF3YWl0IHRoaXMuYmVmb3JlU3RhdGVRdWV1ZS5ydW5NaWRkbGV3YXJlKG51bGwpO1xuICAgIC8vIENsZWFyIHRoZSByZWRpcmVjdCB1c2VyIHdoZW4gc2lnbk91dCBpcyBjYWxsZWRcbiAgICBpZiAodGhpcy5yZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlciB8fCB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3NldFJlZGlyZWN0VXNlcihudWxsKTtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGNhbGxiYWNrcyBmcm9tIGJlaW5nIGNhbGxlZCBhZ2FpbiBpbiBfdXBkYXRlQ3VycmVudFVzZXIsIGFzXG4gICAgLy8gdGhleSB3ZXJlIGFscmVhZHkgY2FsbGVkIGluIHRoZSBmaXJzdCBsaW5lLlxuICAgIHJldHVybiB0aGlzLl91cGRhdGVDdXJyZW50VXNlcihudWxsLCAvKiBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgKi8gdHJ1ZSk7XG4gIH1cblxuICBzZXRQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZTogUGVyc2lzdGVuY2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2Uuc2V0UGVyc2lzdGVuY2UoX2dldEluc3RhbmNlKHBlcnNpc3RlbmNlKSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0UmVjYXB0Y2hhQ29uZmlnKHRoaXMsIHtcbiAgICAgIGNsaWVudFR5cGU6IFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCLFxuICAgICAgdmVyc2lvbjogUmVjYXB0Y2hhVmVyc2lvbi5FTlRFUlBSSVNFXG4gICAgfSk7XG5cbiAgICBjb25zdCBjb25maWcgPSBuZXcgUmVjYXB0Y2hhQ29uZmlnKHJlc3BvbnNlKTtcbiAgICBpZiAodGhpcy50ZW5hbnRJZCA9PSBudWxsKSB7XG4gICAgICB0aGlzLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IGNvbmZpZztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1t0aGlzLnRlbmFudElkXSA9IGNvbmZpZztcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmVtYWlsUGFzc3dvcmRFbmFibGVkKSB7XG4gICAgICBjb25zdCB2ZXJpZmllciA9IG5ldyBSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIodGhpcyk7XG4gICAgICB2b2lkIHZlcmlmaWVyLnZlcmlmeSgpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRSZWNhcHRjaGFDb25maWcoKTogUmVjYXB0Y2hhQ29uZmlnIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMudGVuYW50SWQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FnZW50UmVjYXB0Y2hhQ29uZmlnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1t0aGlzLnRlbmFudElkXTtcbiAgICB9XG4gIH1cblxuICBfZ2V0UGVyc2lzdGVuY2UoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLnBlcnNpc3RlbmNlLnR5cGU7XG4gIH1cblxuICBfdXBkYXRlRXJyb3JNYXAoZXJyb3JNYXA6IEF1dGhFcnJvck1hcCk6IHZvaWQge1xuICAgIHRoaXMuX2Vycm9yRmFjdG9yeSA9IG5ldyBFcnJvckZhY3Rvcnk8QXV0aEVycm9yQ29kZSwgQXV0aEVycm9yUGFyYW1zPihcbiAgICAgICdhdXRoJyxcbiAgICAgICdGaXJlYmFzZScsXG4gICAgICAoZXJyb3JNYXAgYXMgRXJyb3JNYXBSZXRyaWV2ZXIpKClcbiAgICApO1xuICB9XG5cbiAgb25BdXRoU3RhdGVDaGFuZ2VkKFxuICAgIG5leHRPck9ic2VydmVyOiBOZXh0T3JPYnNlcnZlcjxVc2VyPixcbiAgICBlcnJvcj86IEVycm9yRm4sXG4gICAgY29tcGxldGVkPzogQ29tcGxldGVGblxuICApOiBVbnN1YnNjcmliZSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJTdGF0ZUxpc3RlbmVyKFxuICAgICAgdGhpcy5hdXRoU3RhdGVTdWJzY3JpcHRpb24sXG4gICAgICBuZXh0T3JPYnNlcnZlcixcbiAgICAgIGVycm9yLFxuICAgICAgY29tcGxldGVkXG4gICAgKTtcbiAgfVxuXG4gIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoXG4gICAgY2FsbGJhY2s6ICh1c2VyOiBVc2VyIHwgbnVsbCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gICAgb25BYm9ydD86ICgpID0+IHZvaWRcbiAgKTogVW5zdWJzY3JpYmUge1xuICAgIHJldHVybiB0aGlzLmJlZm9yZVN0YXRlUXVldWUucHVzaENhbGxiYWNrKGNhbGxiYWNrLCBvbkFib3J0KTtcbiAgfVxuXG4gIG9uSWRUb2tlbkNoYW5nZWQoXG4gICAgbmV4dE9yT2JzZXJ2ZXI6IE5leHRPck9ic2VydmVyPFVzZXI+LFxuICAgIGVycm9yPzogRXJyb3JGbixcbiAgICBjb21wbGV0ZWQ/OiBDb21wbGV0ZUZuXG4gICk6IFVuc3Vic2NyaWJlIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlclN0YXRlTGlzdGVuZXIoXG4gICAgICB0aGlzLmlkVG9rZW5TdWJzY3JpcHRpb24sXG4gICAgICBuZXh0T3JPYnNlcnZlcixcbiAgICAgIGVycm9yLFxuICAgICAgY29tcGxldGVkXG4gICAgKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBvYmplY3Qge1xuICAgIHJldHVybiB7XG4gICAgICBhcGlLZXk6IHRoaXMuY29uZmlnLmFwaUtleSxcbiAgICAgIGF1dGhEb21haW46IHRoaXMuY29uZmlnLmF1dGhEb21haW4sXG4gICAgICBhcHBOYW1lOiB0aGlzLm5hbWUsXG4gICAgICBjdXJyZW50VXNlcjogdGhpcy5fY3VycmVudFVzZXI/LnRvSlNPTigpXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIF9zZXRSZWRpcmVjdFVzZXIoXG4gICAgdXNlcjogVXNlckludGVybmFsIHwgbnVsbCxcbiAgICBwb3B1cFJlZGlyZWN0UmVzb2x2ZXI/OiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcmVkaXJlY3RNYW5hZ2VyID0gYXdhaXQgdGhpcy5nZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcihcbiAgICAgIHBvcHVwUmVkaXJlY3RSZXNvbHZlclxuICAgICk7XG4gICAgcmV0dXJuIHVzZXIgPT09IG51bGxcbiAgICAgID8gcmVkaXJlY3RNYW5hZ2VyLnJlbW92ZUN1cnJlbnRVc2VyKClcbiAgICAgIDogcmVkaXJlY3RNYW5hZ2VyLnNldEN1cnJlbnRVc2VyKHVzZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcihcbiAgICBwb3B1cFJlZGlyZWN0UmVzb2x2ZXI/OiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJcbiAgKTogUHJvbWlzZTxQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyPiB7XG4gICAgaWYgKCF0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKSB7XG4gICAgICBjb25zdCByZXNvbHZlcjogUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWwgfCBudWxsID1cbiAgICAgICAgKHBvcHVwUmVkaXJlY3RSZXNvbHZlciAmJiBfZ2V0SW5zdGFuY2UocG9wdXBSZWRpcmVjdFJlc29sdmVyKSkgfHxcbiAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyO1xuICAgICAgX2Fzc2VydChyZXNvbHZlciwgdGhpcywgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUik7XG4gICAgICB0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyID0gYXdhaXQgUGVyc2lzdGVuY2VVc2VyTWFuYWdlci5jcmVhdGUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIFtfZ2V0SW5zdGFuY2UocmVzb2x2ZXIuX3JlZGlyZWN0UGVyc2lzdGVuY2UpXSxcbiAgICAgICAgS2V5TmFtZS5SRURJUkVDVF9VU0VSXG4gICAgICApO1xuICAgICAgdGhpcy5yZWRpcmVjdFVzZXIgPVxuICAgICAgICBhd2FpdCB0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyLmdldEN1cnJlbnRVc2VyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXI7XG4gIH1cblxuICBhc3luYyBfcmVkaXJlY3RVc2VyRm9ySWQoaWQ6IHN0cmluZyk6IFByb21pc2U8VXNlckludGVybmFsIHwgbnVsbD4ge1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBjbGVhcmVkIGFueSBwZW5kaW5nIHBlcnNpc3RlbmNlIGFjdGlvbnMgaWYgd2UncmUgbm90IGluXG4gICAgLy8gdGhlIGluaXRpYWxpemVyXG4gICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMucXVldWUoYXN5bmMgKCkgPT4ge30pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jdXJyZW50VXNlcj8uX3JlZGlyZWN0RXZlbnRJZCA9PT0gaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VXNlcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWRpcmVjdFVzZXI/Ll9yZWRpcmVjdEV2ZW50SWQgPT09IGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWRpcmVjdFVzZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBhc3luYyBfcGVyc2lzdFVzZXJJZkN1cnJlbnQodXNlcjogVXNlckludGVybmFsKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHVzZXIgPT09IHRoaXMuY3VycmVudFVzZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcih1c2VyKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIE5vdGlmaWVzIGxpc3RlbmVycyBvbmx5IGlmIHRoZSB1c2VyIGlzIGN1cnJlbnQgKi9cbiAgX25vdGlmeUxpc3RlbmVyc0lmQ3VycmVudCh1c2VyOiBVc2VySW50ZXJuYWwpOiB2b2lkIHtcbiAgICBpZiAodXNlciA9PT0gdGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgdGhpcy5ub3RpZnlBdXRoTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9XG5cbiAgX2tleSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmNvbmZpZy5hdXRoRG9tYWlufToke3RoaXMuY29uZmlnLmFwaUtleX06JHt0aGlzLm5hbWV9YDtcbiAgfVxuXG4gIF9zdGFydFByb2FjdGl2ZVJlZnJlc2goKTogdm9pZCB7XG4gICAgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgdGhpcy5fY3VycmVudFVzZXIuX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgIH1cbiAgfVxuXG4gIF9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpOiB2b2lkIHtcbiAgICB0aGlzLmlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgdGhpcy5fY3VycmVudFVzZXIuX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIGN1cnJlbnQgdXNlciBjYXN0IGFzIHRoZSBpbnRlcm5hbCB0eXBlICovXG4gIGdldCBfY3VycmVudFVzZXIoKTogVXNlckludGVybmFsIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VXNlciBhcyBVc2VySW50ZXJuYWw7XG4gIH1cblxuICBwcml2YXRlIG5vdGlmeUF1dGhMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pZFRva2VuU3Vic2NyaXB0aW9uLm5leHQodGhpcy5jdXJyZW50VXNlcik7XG5cbiAgICBjb25zdCBjdXJyZW50VWlkID0gdGhpcy5jdXJyZW50VXNlcj8udWlkID8/IG51bGw7XG4gICAgaWYgKHRoaXMubGFzdE5vdGlmaWVkVWlkICE9PSBjdXJyZW50VWlkKSB7XG4gICAgICB0aGlzLmxhc3ROb3RpZmllZFVpZCA9IGN1cnJlbnRVaWQ7XG4gICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbi5uZXh0KHRoaXMuY3VycmVudFVzZXIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXJTdGF0ZUxpc3RlbmVyKFxuICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uPFVzZXI+LFxuICAgIG5leHRPck9ic2VydmVyOiBOZXh0T3JPYnNlcnZlcjxVc2VyPixcbiAgICBlcnJvcj86IEVycm9yRm4sXG4gICAgY29tcGxldGVkPzogQ29tcGxldGVGblxuICApOiBVbnN1YnNjcmliZSB7XG4gICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBjYiA9XG4gICAgICB0eXBlb2YgbmV4dE9yT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBuZXh0T3JPYnNlcnZlclxuICAgICAgICA6IG5leHRPck9ic2VydmVyLm5leHQuYmluZChuZXh0T3JPYnNlcnZlcik7XG5cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5faXNJbml0aWFsaXplZFxuICAgICAgPyBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgOiB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgX2Fzc2VydChwcm9taXNlLCB0aGlzLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICAvLyBUaGUgY2FsbGJhY2sgbmVlZHMgdG8gYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IHBlciB0aGUgc3BlYy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgcHJvbWlzZS50aGVuKCgpID0+IGNiKHRoaXMuY3VycmVudFVzZXIpKTtcblxuICAgIGlmICh0eXBlb2YgbmV4dE9yT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb24uYWRkT2JzZXJ2ZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9uLmFkZE9ic2VydmVyKG5leHRPck9ic2VydmVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5wcm90ZWN0ZWQgKGZyb20gcmFjZSBjb25kaXRpb25zKSBtZXRob2QgdG8gc2V0IHRoZSBjdXJyZW50IHVzZXIuIFRoaXNcbiAgICogc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZyb20gd2l0aGluIGEgcXVldWVkIGNhbGxiYWNrLiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiBiZWNhdXNlIHRoZSBxdWV1ZSBzaG91bGRuJ3QgcmVseSBvbiBhbm90aGVyIHF1ZXVlZCBjYWxsYmFjay5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZGlyZWN0bHlTZXRDdXJyZW50VXNlcihcbiAgICB1c2VyOiBVc2VySW50ZXJuYWwgfCBudWxsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyICYmIHRoaXMuY3VycmVudFVzZXIgIT09IHVzZXIpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRVc2VyLl9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgIH1cbiAgICBpZiAodXNlciAmJiB0aGlzLmlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQpIHtcbiAgICAgIHVzZXIuX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFVzZXIgPSB1c2VyO1xuXG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5zZXRDdXJyZW50VXNlcih1c2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLnJlbW92ZUN1cnJlbnRVc2VyKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBxdWV1ZShhY3Rpb246IEFzeW5jQWN0aW9uKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gSW4gY2FzZSBzb21ldGhpbmcgZXJyb3JzLCB0aGUgY2FsbGJhY2sgc3RpbGwgc2hvdWxkIGJlIGNhbGxlZCBpbiBvcmRlclxuICAgIC8vIHRvIGtlZXAgdGhlIHByb21pc2UgY2hhaW4gYWxpdmVcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSB0aGlzLm9wZXJhdGlvbnMudGhlbihhY3Rpb24sIGFjdGlvbik7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0aW9ucztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGFzc2VydGVkUGVyc2lzdGVuY2UoKTogUGVyc2lzdGVuY2VVc2VyTWFuYWdlciB7XG4gICAgX2Fzc2VydCh0aGlzLnBlcnNpc3RlbmNlTWFuYWdlciwgdGhpcywgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2VNYW5hZ2VyO1xuICB9XG5cbiAgcHJpdmF0ZSBmcmFtZXdvcmtzOiBzdHJpbmdbXSA9IFtdO1xuICBwcml2YXRlIGNsaWVudFZlcnNpb246IHN0cmluZztcbiAgX2xvZ0ZyYW1ld29yayhmcmFtZXdvcms6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghZnJhbWV3b3JrIHx8IHRoaXMuZnJhbWV3b3Jrcy5pbmNsdWRlcyhmcmFtZXdvcmspKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZnJhbWV3b3Jrcy5wdXNoKGZyYW1ld29yayk7XG5cbiAgICAvLyBTb3J0IGFscGhhYmV0aWNhbGx5IHNvIHRoYXQgXCJGaXJlYmFzZUNvcmUtd2ViLEZpcmViYXNlVUktd2ViXCIgYW5kXG4gICAgLy8gXCJGaXJlYmFzZVVJLXdlYixGaXJlYmFzZUNvcmUtd2ViXCIgYXJlbid0IHZpZXdlZCBhcyBkaWZmZXJlbnQuXG4gICAgdGhpcy5mcmFtZXdvcmtzLnNvcnQoKTtcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBfZ2V0Q2xpZW50VmVyc2lvbihcbiAgICAgIHRoaXMuY29uZmlnLmNsaWVudFBsYXRmb3JtLFxuICAgICAgdGhpcy5fZ2V0RnJhbWV3b3JrcygpXG4gICAgKTtcbiAgfVxuICBfZ2V0RnJhbWV3b3JrcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWV3b3JrcztcbiAgfVxuICBhc3luYyBfZ2V0QWRkaXRpb25hbEhlYWRlcnMoKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB7XG4gICAgLy8gQWRkaXRpb25hbCBoZWFkZXJzIG9uIGV2ZXJ5IHJlcXVlc3RcbiAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgW0h0dHBIZWFkZXIuWF9DTElFTlRfVkVSU0lPTl06IHRoaXMuY2xpZW50VmVyc2lvblxuICAgIH07XG5cbiAgICBpZiAodGhpcy5hcHAub3B0aW9ucy5hcHBJZCkge1xuICAgICAgaGVhZGVyc1tIdHRwSGVhZGVyLlhfRklSRUJBU0VfR01QSURdID0gdGhpcy5hcHAub3B0aW9ucy5hcHBJZDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaGVhcnRiZWF0IHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIGhlYXJ0YmVhdCBzdHJpbmdcbiAgICBjb25zdCBoZWFydGJlYXRzSGVhZGVyID0gYXdhaXQgdGhpcy5oZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXJcbiAgICAgIC5nZXRJbW1lZGlhdGUoe1xuICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgfSlcbiAgICAgID8uZ2V0SGVhcnRiZWF0c0hlYWRlcigpO1xuICAgIGlmIChoZWFydGJlYXRzSGVhZGVyKSB7XG4gICAgICBoZWFkZXJzW0h0dHBIZWFkZXIuWF9GSVJFQkFTRV9DTElFTlRdID0gaGVhcnRiZWF0c0hlYWRlcjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgQXBwIENoZWNrIHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIEFwcCBDaGVjayB0b2tlbiBpbiB0aGUgaGVhZGVyc1xuICAgIGNvbnN0IGFwcENoZWNrVG9rZW4gPSBhd2FpdCB0aGlzLl9nZXRBcHBDaGVja1Rva2VuKCk7XG4gICAgaWYgKGFwcENoZWNrVG9rZW4pIHtcbiAgICAgIGhlYWRlcnNbSHR0cEhlYWRlci5YX0ZJUkVCQVNFX0FQUF9DSEVDS10gPSBhcHBDaGVja1Rva2VuO1xuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzO1xuICB9XG5cbiAgYXN5bmMgX2dldEFwcENoZWNrVG9rZW4oKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBhcHBDaGVja1Rva2VuUmVzdWx0ID0gYXdhaXQgdGhpcy5hcHBDaGVja1NlcnZpY2VQcm92aWRlclxuICAgICAgLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pXG4gICAgICA/LmdldFRva2VuKCk7XG4gICAgaWYgKGFwcENoZWNrVG9rZW5SZXN1bHQ/LmVycm9yKSB7XG4gICAgICAvLyBDb250ZXh0OiBhcHBDaGVjay5nZXRUb2tlbigpIHdpbGwgbmV2ZXIgdGhyb3cgZXZlbiBpZiBhbiBlcnJvciBoYXBwZW5lZC5cbiAgICAgIC8vIEluIHRoZSBlcnJvciBjYXNlLCBhIGR1bW15IHRva2VuIHdpbGwgYmUgcmV0dXJuZWQgYWxvbmcgd2l0aCBhbiBlcnJvciBmaWVsZCBkZXNjcmliaW5nXG4gICAgICAvLyB0aGUgZXJyb3IuIEluIGdlbmVyYWwsIHdlIHNob3VsZG4ndCBjYXJlIGFib3V0IHRoZSBlcnJvciBjb25kaXRpb24gYW5kIGp1c3QgdXNlXG4gICAgICAvLyB0aGUgdG9rZW4gKGFjdHVhbCBvciBkdW1teSkgdG8gc2VuZCByZXF1ZXN0cy5cbiAgICAgIF9sb2dXYXJuKFxuICAgICAgICBgRXJyb3Igd2hpbGUgcmV0cmlldmluZyBBcHAgQ2hlY2sgdG9rZW46ICR7YXBwQ2hlY2tUb2tlblJlc3VsdC5lcnJvcn1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gYXBwQ2hlY2tUb2tlblJlc3VsdD8udG9rZW47XG4gIH1cbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgdXNlZCB0byBjYXN0IGRvd24gdG8gb3VyIHByaXZhdGUgaW1wbG1lbnRhdGlvbiBvZiBBdXRoLlxuICogSXQgd2lsbCBhbHNvIGhhbmRsZSB1bndyYXBwaW5nIGZyb20gdGhlIGNvbXBhdCB0eXBlIGlmIG5lY2Vzc2FyeVxuICpcbiAqIEBwYXJhbSBhdXRoIEF1dGggb2JqZWN0IHBhc3NlZCBpbiBmcm9tIGRldmVsb3BlclxuICovXG5leHBvcnQgZnVuY3Rpb24gX2Nhc3RBdXRoKGF1dGg6IEF1dGgpOiBBdXRoSW50ZXJuYWwge1xuICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpIGFzIEF1dGhJbnRlcm5hbDtcbn1cblxuLyoqIEhlbHBlciBjbGFzcyB0byB3cmFwIHN1YnNjcmliZXIgbG9naWMgKi9cbmNsYXNzIFN1YnNjcmlwdGlvbjxUPiB7XG4gIHByaXZhdGUgb2JzZXJ2ZXI6IE9ic2VydmVyPFQgfCBudWxsPiB8IG51bGwgPSBudWxsO1xuICByZWFkb25seSBhZGRPYnNlcnZlcjogU3Vic2NyaWJlPFQgfCBudWxsPiA9IGNyZWF0ZVN1YnNjcmliZShcbiAgICBvYnNlcnZlciA9PiAodGhpcy5vYnNlcnZlciA9IG9ic2VydmVyKVxuICApO1xuXG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGF1dGg6IEF1dGhJbnRlcm5hbCkge31cblxuICBnZXQgbmV4dCgpOiBOZXh0Rm48VCB8IG51bGw+IHtcbiAgICBfYXNzZXJ0KHRoaXMub2JzZXJ2ZXIsIHRoaXMuYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXIubmV4dC5iaW5kKHRoaXMub2JzZXJ2ZXIpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBfZ2V0UHJvdmlkZXIsIEZpcmViYXNlQXBwIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBkZWVwRXF1YWwgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBBdXRoLCBEZXBlbmRlbmNpZXMgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IFBlcnNpc3RlbmNlSW50ZXJuYWwgfSBmcm9tICcuLi9wZXJzaXN0ZW5jZSc7XG5pbXBvcnQgeyBfZmFpbCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IF9nZXRJbnN0YW5jZSB9IGZyb20gJy4uL3V0aWwvaW5zdGFudGlhdG9yJztcbmltcG9ydCB7IEF1dGhJbXBsIH0gZnJvbSAnLi9hdXRoX2ltcGwnO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZSB3aXRoIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAqIHtAbGluayBEZXBlbmRlbmNpZXN9LlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgbW9yZSBjb250cm9sIG92ZXIgdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB0aGFuXG4gKiB7QGxpbmsgZ2V0QXV0aH0uIGBnZXRBdXRoYCB1c2VzIHBsYXRmb3JtLXNwZWNpZmljIGRlZmF1bHRzIHRvIHN1cHBseVxuICogdGhlIHtAbGluayBEZXBlbmRlbmNpZXN9LiBJbiBnZW5lcmFsLCBgZ2V0QXV0aGAgaXMgdGhlIGVhc2llc3Qgd2F5IHRvXG4gKiBpbml0aWFsaXplIEF1dGggYW5kIHdvcmtzIGZvciBtb3N0IHVzZSBjYXNlcy4gVXNlIGBpbml0aWFsaXplQXV0aGAgaWYgeW91XG4gKiBuZWVkIGNvbnRyb2wgb3ZlciB3aGljaCBwZXJzaXN0ZW5jZSBsYXllciBpcyB1c2VkLCBvciB0byBtaW5pbWl6ZSBidW5kbGVcbiAqIHNpemUgaWYgeW91J3JlIG5vdCB1c2luZyBlaXRoZXIgYHNpZ25JbldpdGhQb3B1cGAgb3IgYHNpZ25JbldpdGhSZWRpcmVjdGAuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdXIgYXBwIG9ubHkgdXNlcyBhbm9ueW1vdXMgYWNjb3VudHMgYW5kIHlvdSBvbmx5IHdhbnRcbiAqIGFjY291bnRzIHNhdmVkIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLCBpbml0aWFsaXplIGBBdXRoYCB3aXRoOlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBhdXRoID0gaW5pdGlhbGl6ZUF1dGgoYXBwLCB7XG4gKiAgIHBlcnNpc3RlbmNlOiBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlLFxuICogICBwb3B1cFJlZGlyZWN0UmVzb2x2ZXI6IHVuZGVmaW5lZCxcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUF1dGgoYXBwOiBGaXJlYmFzZUFwcCwgZGVwcz86IERlcGVuZGVuY2llcyk6IEF1dGgge1xuICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdhdXRoJyk7XG5cbiAgaWYgKHByb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgIGNvbnN0IGF1dGggPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKSBhcyBBdXRoSW1wbDtcbiAgICBjb25zdCBpbml0aWFsT3B0aW9ucyA9IHByb3ZpZGVyLmdldE9wdGlvbnMoKSBhcyBEZXBlbmRlbmNpZXM7XG4gICAgaWYgKGRlZXBFcXVhbChpbml0aWFsT3B0aW9ucywgZGVwcyA/PyB7fSkpIHtcbiAgICAgIHJldHVybiBhdXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZmFpbChhdXRoLCBBdXRoRXJyb3JDb2RlLkFMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGF1dGggPSBwcm92aWRlci5pbml0aWFsaXplKHsgb3B0aW9uczogZGVwcyB9KSBhcyBBdXRoSW1wbDtcblxuICByZXR1cm4gYXV0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pbml0aWFsaXplQXV0aEluc3RhbmNlKFxuICBhdXRoOiBBdXRoSW1wbCxcbiAgZGVwcz86IERlcGVuZGVuY2llc1xuKTogdm9pZCB7XG4gIGNvbnN0IHBlcnNpc3RlbmNlID0gZGVwcz8ucGVyc2lzdGVuY2UgfHwgW107XG4gIGNvbnN0IGhpZXJhcmNoeSA9IChcbiAgICBBcnJheS5pc0FycmF5KHBlcnNpc3RlbmNlKSA/IHBlcnNpc3RlbmNlIDogW3BlcnNpc3RlbmNlXVxuICApLm1hcDxQZXJzaXN0ZW5jZUludGVybmFsPihfZ2V0SW5zdGFuY2UpO1xuICBpZiAoZGVwcz8uZXJyb3JNYXApIHtcbiAgICBhdXRoLl91cGRhdGVFcnJvck1hcChkZXBzLmVycm9yTWFwKTtcbiAgfVxuXG4gIC8vIFRoaXMgcHJvbWlzZSBpcyBpbnRlbmRlZCB0byBmbG9hdDsgYXV0aCBpbml0aWFsaXphdGlvbiBoYXBwZW5zIGluIHRoZVxuICAvLyBiYWNrZ3JvdW5kLCBtZWFud2hpbGUgdGhlIGF1dGggb2JqZWN0IG1heSBiZSB1c2VkIGJ5IHRoZSBhcHAuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgYXV0aC5faW5pdGlhbGl6ZVdpdGhQZXJzaXN0ZW5jZShoaWVyYXJjaHksIGRlcHM/LnBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBfY2FzdEF1dGggfSBmcm9tICcuL2F1dGhfaW1wbCc7XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUge0BsaW5rIEF1dGh9IGluc3RhbmNlIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIEZpcmViYXNlIEF1dGggRW11bGF0b3IsIGluc3RlYWQgb2YgcHJvZHVjdGlvblxuICogRmlyZWJhc2UgQXV0aCBzZXJ2aWNlcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5IGltbWVkaWF0ZWx5IGZvbGxvd2luZyB0aGUgZmlyc3QgY2FsbCB0b1xuICoge0BsaW5rIGluaXRpYWxpemVBdXRofS4gIERvIG5vdCB1c2Ugd2l0aCBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzIGFzIGVtdWxhdG9yXG4gKiB0cmFmZmljIGlzIG5vdCBlbmNyeXB0ZWQuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25uZWN0QXV0aEVtdWxhdG9yKGF1dGgsICdodHRwOi8vMTI3LjAuMC4xOjkwOTknLCB7IGRpc2FibGVXYXJuaW5nczogdHJ1ZSB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIGF0IHdoaWNoIHRoZSBlbXVsYXRvciBpcyBydW5uaW5nIChlZywgJ2h0dHA6Ly9sb2NhbGhvc3Q6OTA5OScpLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gYG9wdGlvbnMuZGlzYWJsZVdhcm5pbmdzYCBkZWZhdWx0cyB0byBgZmFsc2VgLiBTZXQgaXQgdG9cbiAqIGB0cnVlYCB0byBkaXNhYmxlIHRoZSB3YXJuaW5nIGJhbm5lciBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3RBdXRoRW11bGF0b3IoXG4gIGF1dGg6IEF1dGgsXG4gIHVybDogc3RyaW5nLFxuICBvcHRpb25zPzogeyBkaXNhYmxlV2FybmluZ3M6IGJvb2xlYW4gfVxuKTogdm9pZCB7XG4gIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgX2Fzc2VydChcbiAgICBhdXRoSW50ZXJuYWwuX2NhbkluaXRFbXVsYXRvcixcbiAgICBhdXRoSW50ZXJuYWwsXG4gICAgQXV0aEVycm9yQ29kZS5FTVVMQVRPUl9DT05GSUdfRkFJTEVEXG4gICk7XG5cbiAgX2Fzc2VydChcbiAgICAvXmh0dHBzPzpcXC9cXC8vLnRlc3QodXJsKSxcbiAgICBhdXRoSW50ZXJuYWwsXG4gICAgQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNVUxBVE9SX1NDSEVNRVxuICApO1xuXG4gIGNvbnN0IGRpc2FibGVXYXJuaW5ncyA9ICEhb3B0aW9ucz8uZGlzYWJsZVdhcm5pbmdzO1xuXG4gIGNvbnN0IHByb3RvY29sID0gZXh0cmFjdFByb3RvY29sKHVybCk7XG4gIGNvbnN0IHsgaG9zdCwgcG9ydCB9ID0gZXh0cmFjdEhvc3RBbmRQb3J0KHVybCk7XG4gIGNvbnN0IHBvcnRTdHIgPSBwb3J0ID09PSBudWxsID8gJycgOiBgOiR7cG9ydH1gO1xuXG4gIC8vIEFsd2F5cyByZXBsYWNlIHBhdGggd2l0aCBcIi9cIiAoZXZlbiBpZiBpbnB1dCB1cmwgaGFkIG5vIHBhdGggYXQgYWxsLCBvciBoYWQgYSBkaWZmZXJlbnQgb25lKS5cbiAgYXV0aEludGVybmFsLmNvbmZpZy5lbXVsYXRvciA9IHsgdXJsOiBgJHtwcm90b2NvbH0vLyR7aG9zdH0ke3BvcnRTdHJ9L2AgfTtcbiAgYXV0aEludGVybmFsLnNldHRpbmdzLmFwcFZlcmlmaWNhdGlvbkRpc2FibGVkRm9yVGVzdGluZyA9IHRydWU7XG4gIGF1dGhJbnRlcm5hbC5lbXVsYXRvckNvbmZpZyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGhvc3QsXG4gICAgcG9ydCxcbiAgICBwcm90b2NvbDogcHJvdG9jb2wucmVwbGFjZSgnOicsICcnKSxcbiAgICBvcHRpb25zOiBPYmplY3QuZnJlZXplKHsgZGlzYWJsZVdhcm5pbmdzIH0pXG4gIH0pO1xuXG4gIGlmICghZGlzYWJsZVdhcm5pbmdzKSB7XG4gICAgZW1pdEVtdWxhdG9yV2FybmluZygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHByb3RvY29sRW5kID0gdXJsLmluZGV4T2YoJzonKTtcbiAgcmV0dXJuIHByb3RvY29sRW5kIDwgMCA/ICcnIDogdXJsLnN1YnN0cigwLCBwcm90b2NvbEVuZCArIDEpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SG9zdEFuZFBvcnQodXJsOiBzdHJpbmcpOiB7XG4gIGhvc3Q6IHN0cmluZztcbiAgcG9ydDogbnVtYmVyIHwgbnVsbDtcbn0ge1xuICBjb25zdCBwcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbCh1cmwpO1xuICBjb25zdCBhdXRob3JpdHkgPSAvKFxcL1xcLyk/KFtePyMvXSspLy5leGVjKHVybC5zdWJzdHIocHJvdG9jb2wubGVuZ3RoKSk7IC8vIEJldHdlZW4gLy8gYW5kIC8sID8gb3IgIy5cbiAgaWYgKCFhdXRob3JpdHkpIHtcbiAgICByZXR1cm4geyBob3N0OiAnJywgcG9ydDogbnVsbCB9O1xuICB9XG4gIGNvbnN0IGhvc3RBbmRQb3J0ID0gYXV0aG9yaXR5WzJdLnNwbGl0KCdAJykucG9wKCkgfHwgJyc7IC8vIFN0cmlwIG91dCBcInVzZXJuYW1lOnBhc3N3b3JkQFwiLlxuICBjb25zdCBicmFja2V0ZWRJUHY2ID0gL14oXFxbW15cXF1dK1xcXSkoOnwkKS8uZXhlYyhob3N0QW5kUG9ydCk7XG4gIGlmIChicmFja2V0ZWRJUHY2KSB7XG4gICAgY29uc3QgaG9zdCA9IGJyYWNrZXRlZElQdjZbMV07XG4gICAgcmV0dXJuIHsgaG9zdCwgcG9ydDogcGFyc2VQb3J0KGhvc3RBbmRQb3J0LnN1YnN0cihob3N0Lmxlbmd0aCArIDEpKSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtob3N0LCBwb3J0XSA9IGhvc3RBbmRQb3J0LnNwbGl0KCc6Jyk7XG4gICAgcmV0dXJuIHsgaG9zdCwgcG9ydDogcGFyc2VQb3J0KHBvcnQpIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VQb3J0KHBvcnRTdHI6IHN0cmluZyk6IG51bWJlciB8IG51bGwge1xuICBpZiAoIXBvcnRTdHIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwb3J0ID0gTnVtYmVyKHBvcnRTdHIpO1xuICBpZiAoaXNOYU4ocG9ydCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcG9ydDtcbn1cblxuZnVuY3Rpb24gZW1pdEVtdWxhdG9yV2FybmluZygpOiB2b2lkIHtcbiAgZnVuY3Rpb24gYXR0YWNoQmFubmVyKCk6IHZvaWQge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIGNvbnN0IHN0eSA9IGVsLnN0eWxlO1xuICAgIGVsLmlubmVyVGV4dCA9XG4gICAgICAnUnVubmluZyBpbiBlbXVsYXRvciBtb2RlLiBEbyBub3QgdXNlIHdpdGggcHJvZHVjdGlvbiBjcmVkZW50aWFscy4nO1xuICAgIHN0eS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgc3R5LndpZHRoID0gJzEwMCUnO1xuICAgIHN0eS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZmZmZic7XG4gICAgc3R5LmJvcmRlciA9ICcuMWVtIHNvbGlkICMwMDAwMDAnO1xuICAgIHN0eS5jb2xvciA9ICcjYjUwMDAwJztcbiAgICBzdHkuYm90dG9tID0gJzBweCc7XG4gICAgc3R5LmxlZnQgPSAnMHB4JztcbiAgICBzdHkubWFyZ2luID0gJzBweCc7XG4gICAgc3R5LnpJbmRleCA9ICcxMDAwMCc7XG4gICAgc3R5LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZpcmViYXNlLWVtdWxhdG9yLXdhcm5pbmcnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuaW5mbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICdXQVJOSU5HOiBZb3UgYXJlIHVzaW5nIHRoZSBBdXRoIEVtdWxhdG9yLCcgK1xuICAgICAgICAnIHdoaWNoIGlzIGludGVuZGVkIGZvciBsb2NhbCB0ZXN0aW5nIG9ubHkuICBEbyBub3QgdXNlIHdpdGgnICtcbiAgICAgICAgJyBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzLidcbiAgICApO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBhdHRhY2hCYW5uZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRhY2hCYW5uZXIoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFBob25lT3JPYXV0aFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vbWZhJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgZGVidWdGYWlsIH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuXG4vKipcbiAqIEludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IGFuIHtAbGluayBBdXRoUHJvdmlkZXJ9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBJbXBsZW1lbnRhdGlvbnMgc3BlY2lmeSB0aGUgZGV0YWlscyBhYm91dCBlYWNoIGF1dGggcHJvdmlkZXIncyBjcmVkZW50aWFsIHJlcXVpcmVtZW50cy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoQ3JlZGVudGlhbCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlciBJRCBmb3IgdGhlIGNyZWRlbnRpYWwuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEZvciBleGFtcGxlLCAnZmFjZWJvb2suY29tJywgb3IgJ2dvb2dsZS5jb20nLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHByb3ZpZGVySWQ6IHN0cmluZyxcbiAgICAvKipcbiAgICAgKiBUaGUgYXV0aGVudGljYXRpb24gc2lnbiBpbiBtZXRob2QgZm9yIHRoZSBjcmVkZW50aWFsLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBGb3IgZXhhbXBsZSwge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQsIG9yXG4gICAgICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgc2lnbi1pbiBtZXRob2RcbiAgICAgKiBpZGVudGlmaWVyIGFzIHJldHVybmVkIGluIHtAbGluayBmZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbH0uXG4gICAgICovXG4gICAgcmVhZG9ubHkgc2lnbkluTWV0aG9kOiBzdHJpbmdcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAqL1xuICB0b0pTT04oKTogb2JqZWN0IHtcbiAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldElkVG9rZW5SZXNwb25zZShfYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxQaG9uZU9yT2F1dGhUb2tlblJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfbGlua1RvSWRUb2tlbihcbiAgICBfYXV0aDogQXV0aEludGVybmFsLFxuICAgIF9pZFRva2VuOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxJZFRva2VuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoX2F1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8SWRUb2tlblJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEFjdGlvbkNvZGVPcGVyYXRpb24sIEF1dGggfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQge1xuICBFbmRwb2ludCxcbiAgSHR0cE1ldGhvZCxcbiAgX2FkZFRpZElmTmVjZXNzYXJ5LFxuICBfcGVyZm9ybUFwaVJlcXVlc3Rcbn0gZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgTWZhRW5yb2xsbWVudCB9IGZyb20gJy4vbWZhJztcblxuZXhwb3J0IGludGVyZmFjZSBSZXNldFBhc3N3b3JkUmVxdWVzdCB7XG4gIG9vYkNvZGU6IHN0cmluZztcbiAgbmV3UGFzc3dvcmQ/OiBzdHJpbmc7XG4gIHRlbmFudElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc2V0UGFzc3dvcmRSZXNwb25zZSB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG5ld0VtYWlsPzogc3RyaW5nO1xuICByZXF1ZXN0VHlwZT86IEFjdGlvbkNvZGVPcGVyYXRpb247XG4gIG1mYUluZm8/OiBNZmFFbnJvbGxtZW50O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzZXRQYXNzd29yZChcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogUmVzZXRQYXNzd29yZFJlcXVlc3Rcbik6IFByb21pc2U8UmVzZXRQYXNzd29yZFJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8UmVzZXRQYXNzd29yZFJlcXVlc3QsIFJlc2V0UGFzc3dvcmRSZXNwb25zZT4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuUkVTRVRfUEFTU1dPUkQsXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUVtYWlsUGFzc3dvcmRSZXF1ZXN0IHtcbiAgaWRUb2tlbjogc3RyaW5nO1xuICByZXR1cm5TZWN1cmVUb2tlbj86IGJvb2xlYW47XG4gIGVtYWlsPzogc3RyaW5nO1xuICBwYXNzd29yZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVFbWFpbFBhc3N3b3JkUmVzcG9uc2UgZXh0ZW5kcyBJZFRva2VuUmVzcG9uc2Uge31cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUVtYWlsUGFzc3dvcmQoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFVwZGF0ZUVtYWlsUGFzc3dvcmRSZXF1ZXN0XG4pOiBQcm9taXNlPFVwZGF0ZUVtYWlsUGFzc3dvcmRSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PFxuICAgIFVwZGF0ZUVtYWlsUGFzc3dvcmRSZXF1ZXN0LFxuICAgIFVwZGF0ZUVtYWlsUGFzc3dvcmRSZXNwb25zZVxuICA+KGF1dGgsIEh0dHBNZXRob2QuUE9TVCwgRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTywgcmVxdWVzdCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwbHlBY3Rpb25Db2RlUmVxdWVzdCB7XG4gIG9vYkNvZGU6IHN0cmluZztcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwbHlBY3Rpb25Db2RlUmVzcG9uc2Uge31cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwcGx5QWN0aW9uQ29kZShcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogQXBwbHlBY3Rpb25Db2RlUmVxdWVzdFxuKTogUHJvbWlzZTxBcHBseUFjdGlvbkNvZGVSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PEFwcGx5QWN0aW9uQ29kZVJlcXVlc3QsIEFwcGx5QWN0aW9uQ29kZVJlc3BvbnNlPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5TRVRfQUNDT1VOVF9JTkZPLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQWN0aW9uQ29kZU9wZXJhdGlvbiwgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7XG4gIEVuZHBvaW50LFxuICBIdHRwTWV0aG9kLFxuICBSZWNhcHRjaGFDbGllbnRUeXBlLFxuICBSZWNhcHRjaGFWZXJzaW9uLFxuICBfYWRkVGlkSWZOZWNlc3NhcnksXG4gIF9wZXJmb3JtQXBpUmVxdWVzdCxcbiAgX3BlcmZvcm1TaWduSW5SZXF1ZXN0XG59IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IElkVG9rZW4sIElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcblxuZXhwb3J0IGludGVyZmFjZSBTaWduSW5XaXRoUGFzc3dvcmRSZXF1ZXN0IHtcbiAgcmV0dXJuU2VjdXJlVG9rZW4/OiBib29sZWFuO1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICB0ZW5hbnRJZD86IHN0cmluZztcbiAgY2FwdGNoYVJlc3BvbnNlPzogc3RyaW5nO1xuICBjbGllbnRUeXBlPzogUmVjYXB0Y2hhQ2xpZW50VHlwZTtcbiAgcmVjYXB0Y2hhVmVyc2lvbj86IFJlY2FwdGNoYVZlcnNpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbkluV2l0aFBhc3N3b3JkUmVzcG9uc2UgZXh0ZW5kcyBJZFRva2VuUmVzcG9uc2Uge1xuICBlbWFpbDogc3RyaW5nO1xuICBkaXNwbGF5TmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aFBhc3N3b3JkKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBTaWduSW5XaXRoUGFzc3dvcmRSZXF1ZXN0XG4pOiBQcm9taXNlPFNpZ25JbldpdGhQYXNzd29yZFJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3Q8XG4gICAgU2lnbkluV2l0aFBhc3N3b3JkUmVxdWVzdCxcbiAgICBTaWduSW5XaXRoUGFzc3dvcmRSZXNwb25zZVxuICA+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QQVNTV09SRCxcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRPb2JDb2RlUmVxdWVzdCB7XG4gIGVtYWlsPzogc3RyaW5nOyAvLyBFdmVyeXRoaW5nIGV4Y2VwdCBWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFxuICBjb250aW51ZVVybD86IHN0cmluZztcbiAgaU9TQnVuZGxlSWQ/OiBzdHJpbmc7XG4gIGlvc0FwcFN0b3JlSWQ/OiBzdHJpbmc7XG4gIGFuZHJvaWRQYWNrYWdlTmFtZT86IHN0cmluZztcbiAgYW5kcm9pZEluc3RhbGxBcHA/OiBib29sZWFuO1xuICBhbmRyb2lkTWluaW11bVZlcnNpb25Db2RlPzogc3RyaW5nO1xuICBjYW5IYW5kbGVDb2RlSW5BcHA/OiBib29sZWFuO1xuICBkeW5hbWljTGlua0RvbWFpbj86IHN0cmluZztcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG4gIHRhcmdldFByb2plY3RpZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlFbWFpbFJlcXVlc3QgZXh0ZW5kcyBHZXRPb2JDb2RlUmVxdWVzdCB7XG4gIHJlcXVlc3RUeXBlOiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9FTUFJTDtcbiAgaWRUb2tlbjogSWRUb2tlbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXNzd29yZFJlc2V0UmVxdWVzdCBleHRlbmRzIEdldE9vYkNvZGVSZXF1ZXN0IHtcbiAgcmVxdWVzdFR5cGU6IEFjdGlvbkNvZGVPcGVyYXRpb24uUEFTU1dPUkRfUkVTRVQ7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGNhcHRjaGFSZXNwPzogc3RyaW5nO1xuICBjbGllbnRUeXBlPzogUmVjYXB0Y2hhQ2xpZW50VHlwZTtcbiAgcmVjYXB0Y2hhVmVyc2lvbj86IFJlY2FwdGNoYVZlcnNpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW1haWxTaWduSW5SZXF1ZXN0IGV4dGVuZHMgR2V0T29iQ29kZVJlcXVlc3Qge1xuICByZXF1ZXN0VHlwZTogQWN0aW9uQ29kZU9wZXJhdGlvbi5FTUFJTF9TSUdOSU47XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGNhcHRjaGFSZXNwPzogc3RyaW5nO1xuICBjbGllbnRUeXBlPzogUmVjYXB0Y2hhQ2xpZW50VHlwZTtcbiAgcmVjYXB0Y2hhVmVyc2lvbj86IFJlY2FwdGNoYVZlcnNpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5QW5kQ2hhbmdlRW1haWxSZXF1ZXN0IGV4dGVuZHMgR2V0T29iQ29kZVJlcXVlc3Qge1xuICByZXF1ZXN0VHlwZTogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTDtcbiAgaWRUb2tlbjogSWRUb2tlbjtcbiAgbmV3RW1haWw6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEdldE9vYkNvZGVSZXNwb25zZSB7XG4gIGVtYWlsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5RW1haWxSZXNwb25zZSBleHRlbmRzIEdldE9vYkNvZGVSZXNwb25zZSB7fVxuZXhwb3J0IGludGVyZmFjZSBQYXNzd29yZFJlc2V0UmVzcG9uc2UgZXh0ZW5kcyBHZXRPb2JDb2RlUmVzcG9uc2Uge31cbmV4cG9ydCBpbnRlcmZhY2UgRW1haWxTaWduSW5SZXNwb25zZSBleHRlbmRzIEdldE9vYkNvZGVSZXNwb25zZSB7fVxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlBbmRDaGFuZ2VFbWFpbFJlc3BvbnNlIGV4dGVuZHMgR2V0T29iQ29kZVJlcXVlc3Qge31cblxuYXN5bmMgZnVuY3Rpb24gc2VuZE9vYkNvZGUoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IEdldE9vYkNvZGVSZXF1ZXN0XG4pOiBQcm9taXNlPEdldE9vYkNvZGVSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PEdldE9vYkNvZGVSZXF1ZXN0LCBHZXRPb2JDb2RlUmVzcG9uc2U+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LlNFTkRfT09CX0NPREUsXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kRW1haWxWZXJpZmljYXRpb24oXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFZlcmlmeUVtYWlsUmVxdWVzdFxuKTogUHJvbWlzZTxWZXJpZnlFbWFpbFJlc3BvbnNlPiB7XG4gIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRQYXNzd29yZFJlc2V0RW1haWwoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFBhc3N3b3JkUmVzZXRSZXF1ZXN0XG4pOiBQcm9taXNlPFBhc3N3b3JkUmVzZXRSZXNwb25zZT4ge1xuICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kU2lnbkluTGlua1RvRW1haWwoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IEVtYWlsU2lnbkluUmVxdWVzdFxuKTogUHJvbWlzZTxFbWFpbFNpZ25JblJlc3BvbnNlPiB7XG4gIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeUFuZENoYW5nZUVtYWlsKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBWZXJpZnlBbmRDaGFuZ2VFbWFpbFJlcXVlc3Rcbik6IFByb21pc2U8VmVyaWZ5QW5kQ2hhbmdlRW1haWxSZXNwb25zZT4ge1xuICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBfcGVyZm9ybVNpZ25JblJlcXVlc3QsXG4gIEVuZHBvaW50LFxuICBIdHRwTWV0aG9kLFxuICBfYWRkVGlkSWZOZWNlc3Nhcnlcbn0gZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbkluV2l0aEVtYWlsTGlua1JlcXVlc3Qge1xuICBlbWFpbDogc3RyaW5nO1xuICBvb2JDb2RlOiBzdHJpbmc7XG4gIHRlbmFudElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25JbldpdGhFbWFpbExpbmtSZXNwb25zZSBleHRlbmRzIElkVG9rZW5SZXNwb25zZSB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGlzTmV3VXNlcjogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbExpbmsoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFNpZ25JbldpdGhFbWFpbExpbmtSZXF1ZXN0XG4pOiBQcm9taXNlPFNpZ25JbldpdGhFbWFpbExpbmtSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0PFxuICAgIFNpZ25JbldpdGhFbWFpbExpbmtSZXF1ZXN0LFxuICAgIFNpZ25JbldpdGhFbWFpbExpbmtSZXNwb25zZVxuICA+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LlNJR05fSU5fV0lUSF9FTUFJTF9MSU5LLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25JbldpdGhFbWFpbExpbmtGb3JMaW5raW5nUmVxdWVzdFxuICBleHRlbmRzIFNpZ25JbldpdGhFbWFpbExpbmtSZXF1ZXN0IHtcbiAgaWRUb2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsTGlua0ZvckxpbmtpbmcoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFNpZ25JbldpdGhFbWFpbExpbmtGb3JMaW5raW5nUmVxdWVzdFxuKTogUHJvbWlzZTxTaWduSW5XaXRoRW1haWxMaW5rUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdDxcbiAgICBTaWduSW5XaXRoRW1haWxMaW5rRm9yTGlua2luZ1JlcXVlc3QsXG4gICAgU2lnbkluV2l0aEVtYWlsTGlua1Jlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0VNQUlMX0xJTkssXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQcm92aWRlcklkLCBTaWduSW5NZXRob2QgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbmltcG9ydCB7IHVwZGF0ZUVtYWlsUGFzc3dvcmQgfSBmcm9tICcuLi8uLi9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L2VtYWlsX2FuZF9wYXNzd29yZCc7XG5pbXBvcnQge1xuICBzaWduSW5XaXRoUGFzc3dvcmQsXG4gIFNpZ25JbldpdGhQYXNzd29yZFJlcXVlc3Rcbn0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL2VtYWlsX2FuZF9wYXNzd29yZCc7XG5pbXBvcnQge1xuICBzaWduSW5XaXRoRW1haWxMaW5rLFxuICBzaWduSW5XaXRoRW1haWxMaW5rRm9yTGlua2luZ1xufSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vZW1haWxfbGluayc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgX2ZhaWwgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4vYXV0aF9jcmVkZW50aWFsJztcbmltcG9ydCB7IGluamVjdFJlY2FwdGNoYUZpZWxkcyB9IGZyb20gJy4uLy4uL3BsYXRmb3JtX2Jyb3dzZXIvcmVjYXB0Y2hhL3JlY2FwdGNoYV9lbnRlcnByaXNlX3ZlcmlmaWVyJztcbmltcG9ydCB7IFJlY2FwdGNoYUFjdGlvbk5hbWUsIFJlY2FwdGNoYUNsaWVudFR5cGUgfSBmcm9tICcuLi8uLi9hcGknO1xuLyoqXG4gKiBJbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjcmVkZW50aWFscyByZXR1cm5lZCBieSB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IGZvclxuICoge0BsaW5rIFByb3ZpZGVySWR9LlBBU1NXT1JEXG4gKlxuICogQHJlbWFya3NcbiAqIENvdmVycyBib3RoIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX1BBU1NXT1JEIGFuZFxuICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBFbWFpbEF1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHJlYWRvbmx5IF9lbWFpbDogc3RyaW5nLFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICByZWFkb25seSBfcGFzc3dvcmQ6IHN0cmluZyxcbiAgICBzaWduSW5NZXRob2Q6IFNpZ25Jbk1ldGhvZCxcbiAgICAvKiogQGludGVybmFsICovXG4gICAgcmVhZG9ubHkgX3RlbmFudElkOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICApIHtcbiAgICBzdXBlcihQcm92aWRlcklkLlBBU1NXT1JELCBzaWduSW5NZXRob2QpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21FbWFpbEFuZFBhc3N3b3JkKFxuICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgcGFzc3dvcmQ6IHN0cmluZ1xuICApOiBFbWFpbEF1dGhDcmVkZW50aWFsIHtcbiAgICByZXR1cm4gbmV3IEVtYWlsQXV0aENyZWRlbnRpYWwoXG4gICAgICBlbWFpbCxcbiAgICAgIHBhc3N3b3JkLFxuICAgICAgU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEXG4gICAgKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9mcm9tRW1haWxBbmRDb2RlKFxuICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgb29iQ29kZTogc3RyaW5nLFxuICAgIHRlbmFudElkOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICApOiBFbWFpbEF1dGhDcmVkZW50aWFsIHtcbiAgICByZXR1cm4gbmV3IEVtYWlsQXV0aENyZWRlbnRpYWwoXG4gICAgICBlbWFpbCxcbiAgICAgIG9vYkNvZGUsXG4gICAgICBTaWduSW5NZXRob2QuRU1BSUxfTElOSyxcbiAgICAgIHRlbmFudElkXG4gICAgKTtcbiAgfVxuXG4gIC8qKiB7QGluaGVyaXRkb2MgQXV0aENyZWRlbnRpYWwudG9KU09OfSAqL1xuICB0b0pTT04oKTogb2JqZWN0IHtcbiAgICByZXR1cm4ge1xuICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxuICAgICAgcGFzc3dvcmQ6IHRoaXMuX3Bhc3N3b3JkLFxuICAgICAgc2lnbkluTWV0aG9kOiB0aGlzLnNpZ25Jbk1ldGhvZCxcbiAgICAgIHRlbmFudElkOiB0aGlzLl90ZW5hbnRJZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCB0byBkZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGludG8gYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0uXG4gICAqXG4gICAqIEBwYXJhbSBqc29uIC0gRWl0aGVyIGBvYmplY3RgIG9yIHRoZSBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LiBXaGVuIHN0cmluZyBpc1xuICAgKiBwcm92aWRlZCwgYEpTT04ucGFyc2VgIHdvdWxkIGJlIGNhbGxlZCBmaXJzdC5cbiAgICpcbiAgICogQHJldHVybnMgSWYgdGhlIEpTT04gaW5wdXQgZG9lcyBub3QgcmVwcmVzZW50IGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0sIG51bGwgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBzdGF0aWMgZnJvbUpTT04oanNvbjogb2JqZWN0IHwgc3RyaW5nKTogRW1haWxBdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICAgIGlmIChvYmo/LmVtYWlsICYmIG9iaj8ucGFzc3dvcmQpIHtcbiAgICAgIGlmIChvYmouc2lnbkluTWV0aG9kID09PSBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zyb21FbWFpbEFuZFBhc3N3b3JkKG9iai5lbWFpbCwgb2JqLnBhc3N3b3JkKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqLnNpZ25Jbk1ldGhvZCA9PT0gU2lnbkluTWV0aG9kLkVNQUlMX0xJTkspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zyb21FbWFpbEFuZENvZGUob2JqLmVtYWlsLCBvYmoucGFzc3dvcmQsIG9iai50ZW5hbnRJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBfZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8SWRUb2tlblJlc3BvbnNlPiB7XG4gICAgc3dpdGNoICh0aGlzLnNpZ25Jbk1ldGhvZCkge1xuICAgICAgY2FzZSBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQ6XG4gICAgICAgIGNvbnN0IHJlcXVlc3Q6IFNpZ25JbldpdGhQYXNzd29yZFJlcXVlc3QgPSB7XG4gICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXG4gICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxuICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcbiAgICAgICAgICBjbGllbnRUeXBlOiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQlxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXV0aC5fZ2V0UmVjYXB0Y2hhQ29uZmlnKCk/LmVtYWlsUGFzc3dvcmRFbmFibGVkKSB7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoXG4gICAgICAgICAgICBhdXRoLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9JTl9XSVRIX1BBU1NXT1JEXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gc2lnbkluV2l0aFBhc3N3b3JkKGF1dGgsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2lnbkluV2l0aFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpLmNhdGNoKGFzeW5jIGVycm9yID0+IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOfWBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAnU2lnbi1pbiB3aXRoIGVtYWlsIGFkZHJlc3MgYW5kIHBhc3N3b3JkIGlzIHByb3RlY3RlZCBieSByZUNBUFRDSEEgZm9yIHRoaXMgcHJvamVjdC4gQXV0b21hdGljYWxseSB0cmlnZ2VyaW5nIHRoZSByZUNBUFRDSEEgZmxvdyBhbmQgcmVzdGFydGluZyB0aGUgc2lnbi1pbiBmbG93LidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoXG4gICAgICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9JTl9XSVRIX1BBU1NXT1JEXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBzaWduSW5XaXRoUGFzc3dvcmQoYXV0aCwgcmVxdWVzdFdpdGhSZWNhcHRjaGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBTaWduSW5NZXRob2QuRU1BSUxfTElOSzpcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwge1xuICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcbiAgICAgICAgICBvb2JDb2RlOiB0aGlzLl9wYXNzd29yZFxuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIF9mYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgX2xpbmtUb0lkVG9rZW4oXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGlkVG9rZW46IHN0cmluZ1xuICApOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT4ge1xuICAgIHN3aXRjaCAodGhpcy5zaWduSW5NZXRob2QpIHtcbiAgICAgIGNhc2UgU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEOlxuICAgICAgICByZXR1cm4gdXBkYXRlRW1haWxQYXNzd29yZChhdXRoLCB7XG4gICAgICAgICAgaWRUb2tlbixcbiAgICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcbiAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXG4gICAgICAgICAgcGFzc3dvcmQ6IHRoaXMuX3Bhc3N3b3JkXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBTaWduSW5NZXRob2QuRU1BSUxfTElOSzpcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhFbWFpbExpbmtGb3JMaW5raW5nKGF1dGgsIHtcbiAgICAgICAgICBpZFRva2VuLFxuICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcbiAgICAgICAgICBvb2JDb2RlOiB0aGlzLl9wYXNzd29yZFxuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIF9mYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoOiBBdXRoSW50ZXJuYWwpOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEVuZHBvaW50LFxuICBIdHRwTWV0aG9kLFxuICBfYWRkVGlkSWZOZWNlc3NhcnksXG4gIF9wZXJmb3JtU2lnbkluUmVxdWVzdFxufSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBJZFRva2VuLCBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBTaWduSW5XaXRoSWRwUmVxdWVzdCB7XG4gIHJlcXVlc3RVcmk6IHN0cmluZztcbiAgcG9zdEJvZHk/OiBzdHJpbmc7XG4gIHNlc3Npb25JZD86IHN0cmluZztcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG4gIHJldHVyblNlY3VyZVRva2VuOiBib29sZWFuO1xuICByZXR1cm5JZHBDcmVkZW50aWFsPzogYm9vbGVhbjtcbiAgaWRUb2tlbj86IElkVG9rZW47XG4gIGF1dG9DcmVhdGU/OiBib29sZWFuO1xuICBwZW5kaW5nVG9rZW4/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbkluV2l0aElkcFJlc3BvbnNlIGV4dGVuZHMgSWRUb2tlblJlc3BvbnNlIHtcbiAgb2F1dGhBY2Nlc3NUb2tlbj86IHN0cmluZztcbiAgb2F1dGhUb2tlblNlY3JldD86IHN0cmluZztcbiAgbm9uY2U/OiBzdHJpbmc7XG4gIG9hdXRoSWRUb2tlbj86IHN0cmluZztcbiAgcGVuZGluZ1Rva2VuPzogc3RyaW5nO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aElkcChcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogU2lnbkluV2l0aElkcFJlcXVlc3Rcbik6IFByb21pc2U8U2lnbkluV2l0aElkcFJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3Q8U2lnbkluV2l0aElkcFJlcXVlc3QsIFNpZ25JbldpdGhJZHBSZXNwb25zZT4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0lEUCxcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IHF1ZXJ5c3RyaW5nIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbXBvcnQge1xuICBzaWduSW5XaXRoSWRwLFxuICBTaWduSW5XaXRoSWRwUmVxdWVzdFxufSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vaWRwJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBfZmFpbCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IEF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi9hdXRoX2NyZWRlbnRpYWwnO1xuXG5jb25zdCBJRFBfUkVRVUVTVF9VUkkgPSAnaHR0cDovL2xvY2FsaG9zdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT0F1dGhDcmVkZW50aWFsUGFyYW1zIHtcbiAgLy8gT0F1dGggMiB1c2VzIGVpdGhlciBpZCB0b2tlbiBvciBhY2Nlc3MgdG9rZW5cbiAgaWRUb2tlbj86IHN0cmluZyB8IG51bGw7XG4gIGFjY2Vzc1Rva2VuPzogc3RyaW5nIHwgbnVsbDtcblxuICAvLyBUaGVzZSBmaWVsZHMgYXJlIHVzZWQgd2l0aCBPQXV0aCAxXG4gIG9hdXRoVG9rZW4/OiBzdHJpbmc7XG4gIHNlY3JldD86IHN0cmluZztcbiAgb2F1dGhUb2tlblNlY3JldD86IHN0cmluZztcblxuICAvLyBOb25jZSBpcyBvbmx5IHNldCBpZiBwZW5kaW5nVG9rZW4gaXMgbm90IHByZXNlbnRcbiAgbm9uY2U/OiBzdHJpbmc7XG4gIHBlbmRpbmdUb2tlbj86IHN0cmluZztcblxuICAvLyBVdGlsaXRpZXNcbiAgcHJvdmlkZXJJZDogc3RyaW5nO1xuICBzaWduSW5NZXRob2Q6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBPQXV0aCBjcmVkZW50aWFscyByZXR1cm5lZCBieSBhbiB7QGxpbmsgT0F1dGhQcm92aWRlcn0uXG4gKlxuICogQHJlbWFya3NcbiAqIEltcGxlbWVudGF0aW9ucyBzcGVjaWZ5IHRoZSBkZXRhaWxzIGFib3V0IGVhY2ggYXV0aCBwcm92aWRlcidzIGNyZWRlbnRpYWwgcmVxdWlyZW1lbnRzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE9BdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcbiAgLyoqXG4gICAqIFRoZSBPQXV0aCBJRCB0b2tlbiBhc3NvY2lhdGVkIHdpdGggdGhlIGNyZWRlbnRpYWwgaWYgaXQgYmVsb25ncyB0byBhbiBPSURDIHByb3ZpZGVyLFxuICAgKiBzdWNoIGFzIGBnb29nbGUuY29tYC5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBpZFRva2VuPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIE9BdXRoIGFjY2VzcyB0b2tlbiBhc3NvY2lhdGVkIHdpdGggdGhlIGNyZWRlbnRpYWwgaWYgaXQgYmVsb25ncyB0byBhblxuICAgKiB7QGxpbmsgT0F1dGhQcm92aWRlcn0sIHN1Y2ggYXMgYGZhY2Vib29rLmNvbWAsIGB0d2l0dGVyLmNvbWAsIGV0Yy5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBhY2Nlc3NUb2tlbj86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBPQXV0aCBhY2Nlc3MgdG9rZW4gc2VjcmV0IGFzc29jaWF0ZWQgd2l0aCB0aGUgY3JlZGVudGlhbCBpZiBpdCBiZWxvbmdzIHRvIGFuIE9BdXRoIDEuMFxuICAgKiBwcm92aWRlciwgc3VjaCBhcyBgdHdpdHRlci5jb21gLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHNlY3JldD86IHN0cmluZztcblxuICBwcml2YXRlIG5vbmNlPzogc3RyaW5nO1xuICBwcml2YXRlIHBlbmRpbmdUb2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21QYXJhbXMocGFyYW1zOiBPQXV0aENyZWRlbnRpYWxQYXJhbXMpOiBPQXV0aENyZWRlbnRpYWwge1xuICAgIGNvbnN0IGNyZWQgPSBuZXcgT0F1dGhDcmVkZW50aWFsKHBhcmFtcy5wcm92aWRlcklkLCBwYXJhbXMuc2lnbkluTWV0aG9kKTtcblxuICAgIGlmIChwYXJhbXMuaWRUb2tlbiB8fCBwYXJhbXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgIC8vIE9BdXRoIDIgYW5kIGVpdGhlciBJRCB0b2tlbiBvciBhY2Nlc3MgdG9rZW4uXG4gICAgICBpZiAocGFyYW1zLmlkVG9rZW4pIHtcbiAgICAgICAgY3JlZC5pZFRva2VuID0gcGFyYW1zLmlkVG9rZW47XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY3JlZC5hY2Nlc3NUb2tlbiA9IHBhcmFtcy5hY2Nlc3NUb2tlbjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIG5vbmNlIGlmIGF2YWlsYWJsZSBhbmQgbm8gcGVuZGluZ1Rva2VuIGlzIHByZXNlbnQuXG4gICAgICBpZiAocGFyYW1zLm5vbmNlICYmICFwYXJhbXMucGVuZGluZ1Rva2VuKSB7XG4gICAgICAgIGNyZWQubm9uY2UgPSBwYXJhbXMubm9uY2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMucGVuZGluZ1Rva2VuKSB7XG4gICAgICAgIGNyZWQucGVuZGluZ1Rva2VuID0gcGFyYW1zLnBlbmRpbmdUb2tlbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5vYXV0aFRva2VuICYmIHBhcmFtcy5vYXV0aFRva2VuU2VjcmV0KSB7XG4gICAgICAvLyBPQXV0aCAxIGFuZCBPQXV0aCB0b2tlbiB3aXRoIHRva2VuIHNlY3JldFxuICAgICAgY3JlZC5hY2Nlc3NUb2tlbiA9IHBhcmFtcy5vYXV0aFRva2VuO1xuICAgICAgY3JlZC5zZWNyZXQgPSBwYXJhbXMub2F1dGhUb2tlblNlY3JldDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2ZhaWwoQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWQ7XG4gIH1cblxuICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gICovXG4gIHRvSlNPTigpOiBvYmplY3Qge1xuICAgIHJldHVybiB7XG4gICAgICBpZFRva2VuOiB0aGlzLmlkVG9rZW4sXG4gICAgICBhY2Nlc3NUb2tlbjogdGhpcy5hY2Nlc3NUb2tlbixcbiAgICAgIHNlY3JldDogdGhpcy5zZWNyZXQsXG4gICAgICBub25jZTogdGhpcy5ub25jZSxcbiAgICAgIHBlbmRpbmdUb2tlbjogdGhpcy5wZW5kaW5nVG9rZW4sXG4gICAgICBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWQsXG4gICAgICBzaWduSW5NZXRob2Q6IHRoaXMuc2lnbkluTWV0aG9kXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIHRvIGRlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW50byBhblxuICAgKiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfS5cbiAgICpcbiAgICogQHBhcmFtIGpzb24gLSBJbnB1dCBjYW4gYmUgZWl0aGVyIE9iamVjdCBvciB0aGUgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICogV2hlbiBzdHJpbmcgaXMgcHJvdmlkZWQsIEpTT04ucGFyc2Ugd291bGQgYmUgY2FsbGVkIGZpcnN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0sIG51bGwgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBzdGF0aWMgZnJvbUpTT04oanNvbjogc3RyaW5nIHwgb2JqZWN0KTogT0F1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XG4gICAgY29uc3QgeyBwcm92aWRlcklkLCBzaWduSW5NZXRob2QsIC4uLnJlc3QgfTogT0F1dGhDcmVkZW50aWFsUGFyYW1zID0gb2JqO1xuICAgIGlmICghcHJvdmlkZXJJZCB8fCAhc2lnbkluTWV0aG9kKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjcmVkID0gbmV3IE9BdXRoQ3JlZGVudGlhbChwcm92aWRlcklkLCBzaWduSW5NZXRob2QpO1xuICAgIGNyZWQuaWRUb2tlbiA9IHJlc3QuaWRUb2tlbiB8fCB1bmRlZmluZWQ7XG4gICAgY3JlZC5hY2Nlc3NUb2tlbiA9IHJlc3QuYWNjZXNzVG9rZW4gfHwgdW5kZWZpbmVkO1xuICAgIGNyZWQuc2VjcmV0ID0gcmVzdC5zZWNyZXQ7XG4gICAgY3JlZC5ub25jZSA9IHJlc3Qubm9uY2U7XG4gICAgY3JlZC5wZW5kaW5nVG9rZW4gPSByZXN0LnBlbmRpbmdUb2tlbiB8fCBudWxsO1xuICAgIHJldHVybiBjcmVkO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8SWRUb2tlblJlc3BvbnNlPiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9saW5rVG9JZFRva2VuKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBpZFRva2VuOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxJZFRva2VuUmVzcG9uc2U+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0LmlkVG9rZW4gPSBpZFRva2VuO1xuICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8SWRUb2tlblJlc3BvbnNlPiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5hdXRvQ3JlYXRlID0gZmFsc2U7XG4gICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkUmVxdWVzdCgpOiBTaWduSW5XaXRoSWRwUmVxdWVzdCB7XG4gICAgY29uc3QgcmVxdWVzdDogU2lnbkluV2l0aElkcFJlcXVlc3QgPSB7XG4gICAgICByZXF1ZXN0VXJpOiBJRFBfUkVRVUVTVF9VUkksXG4gICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5wZW5kaW5nVG9rZW4pIHtcbiAgICAgIHJlcXVlc3QucGVuZGluZ1Rva2VuID0gdGhpcy5wZW5kaW5nVG9rZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvc3RCb2R5OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgICBpZiAodGhpcy5pZFRva2VuKSB7XG4gICAgICAgIHBvc3RCb2R5WydpZF90b2tlbiddID0gdGhpcy5pZFRva2VuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcG9zdEJvZHlbJ2FjY2Vzc190b2tlbiddID0gdGhpcy5hY2Nlc3NUb2tlbjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlY3JldCkge1xuICAgICAgICBwb3N0Qm9keVsnb2F1dGhfdG9rZW5fc2VjcmV0J10gPSB0aGlzLnNlY3JldDtcbiAgICAgIH1cblxuICAgICAgcG9zdEJvZHlbJ3Byb3ZpZGVySWQnXSA9IHRoaXMucHJvdmlkZXJJZDtcbiAgICAgIGlmICh0aGlzLm5vbmNlICYmICF0aGlzLnBlbmRpbmdUb2tlbikge1xuICAgICAgICBwb3N0Qm9keVsnbm9uY2UnXSA9IHRoaXMubm9uY2U7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QucG9zdEJvZHkgPSBxdWVyeXN0cmluZyhwb3N0Qm9keSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEVuZHBvaW50LFxuICBIdHRwTWV0aG9kLFxuICBfYWRkVGlkSWZOZWNlc3NhcnksXG4gIF9tYWtlVGFnZ2VkRXJyb3IsXG4gIF9wZXJmb3JtQXBpUmVxdWVzdCxcbiAgX3BlcmZvcm1TaWduSW5SZXF1ZXN0XG59IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi8uLi9jb3JlL2Vycm9ycyc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBTZXJ2ZXJFcnJvciwgU2VydmVyRXJyb3JNYXAgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VuZFBob25lVmVyaWZpY2F0aW9uQ29kZVJlcXVlc3Qge1xuICBwaG9uZU51bWJlcjogc3RyaW5nO1xuICByZWNhcHRjaGFUb2tlbjogc3RyaW5nO1xuICB0ZW5hbnRJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZW5kUGhvbmVWZXJpZmljYXRpb25Db2RlUmVzcG9uc2Uge1xuICBzZXNzaW9uSW5mbzogc3RyaW5nO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZFBob25lVmVyaWZpY2F0aW9uQ29kZShcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogU2VuZFBob25lVmVyaWZpY2F0aW9uQ29kZVJlcXVlc3Rcbik6IFByb21pc2U8U2VuZFBob25lVmVyaWZpY2F0aW9uQ29kZVJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8XG4gICAgU2VuZFBob25lVmVyaWZpY2F0aW9uQ29kZVJlcXVlc3QsXG4gICAgU2VuZFBob25lVmVyaWZpY2F0aW9uQ29kZVJlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU0VORF9WRVJJRklDQVRJT05fQ09ERSxcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXF1ZXN0IHtcbiAgdGVtcG9yYXJ5UHJvb2Y/OiBzdHJpbmc7XG4gIHBob25lTnVtYmVyPzogc3RyaW5nO1xuICBzZXNzaW9uSW5mbz86IHN0cmluZztcbiAgY29kZT86IHN0cmluZztcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua1dpdGhQaG9uZU51bWJlclJlcXVlc3RcbiAgZXh0ZW5kcyBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXF1ZXN0IHtcbiAgaWRUb2tlbjogc3RyaW5nO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25JbldpdGhQaG9uZU51bWJlclJlc3BvbnNlIGV4dGVuZHMgSWRUb2tlblJlc3BvbnNlIHtcbiAgdGVtcG9yYXJ5UHJvb2Y/OiBzdHJpbmc7XG4gIHBob25lTnVtYmVyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aFBob25lTnVtYmVyKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXF1ZXN0XG4pOiBQcm9taXNlPFNpZ25JbldpdGhQaG9uZU51bWJlclJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3Q8XG4gICAgU2lnbkluV2l0aFBob25lTnVtYmVyUmVxdWVzdCxcbiAgICBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXNwb25zZVxuICA+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIsXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsaW5rV2l0aFBob25lTnVtYmVyKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBMaW5rV2l0aFBob25lTnVtYmVyUmVxdWVzdFxuKTogUHJvbWlzZTxTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXNwb25zZT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9wZXJmb3JtU2lnbkluUmVxdWVzdDxcbiAgICBMaW5rV2l0aFBob25lTnVtYmVyUmVxdWVzdCxcbiAgICBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXNwb25zZVxuICA+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIsXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG4gIGlmIChyZXNwb25zZS50ZW1wb3JhcnlQcm9vZikge1xuICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgQXV0aEVycm9yQ29kZS5ORUVEX0NPTkZJUk1BVElPTiwgcmVzcG9uc2UpO1xuICB9XG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuaW50ZXJmYWNlIFZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmdSZXF1ZXN0XG4gIGV4dGVuZHMgU2lnbkluV2l0aFBob25lTnVtYmVyUmVxdWVzdCB7XG4gIG9wZXJhdGlvbjogJ1JFQVVUSCc7XG59XG5cbmNvbnN0IFZFUklGWV9QSE9ORV9OVU1CRVJfRk9SX0VYSVNUSU5HX0VSUk9SX01BUF86IFBhcnRpYWw8XG4gIFNlcnZlckVycm9yTWFwPFNlcnZlckVycm9yPlxuPiA9IHtcbiAgW1NlcnZlckVycm9yLlVTRVJfTk9UX0ZPVU5EXTogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURURcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlQaG9uZU51bWJlckZvckV4aXN0aW5nKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXF1ZXN0XG4pOiBQcm9taXNlPFNpZ25JbldpdGhQaG9uZU51bWJlclJlc3BvbnNlPiB7XG4gIGNvbnN0IGFwaVJlcXVlc3Q6IFZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmdSZXF1ZXN0ID0ge1xuICAgIC4uLnJlcXVlc3QsXG4gICAgb3BlcmF0aW9uOiAnUkVBVVRIJ1xuICB9O1xuICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0PFxuICAgIFZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmdSZXF1ZXN0LFxuICAgIFNpZ25JbldpdGhQaG9uZU51bWJlclJlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BIT05FX05VTUJFUixcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgYXBpUmVxdWVzdCksXG4gICAgVkVSSUZZX1BIT05FX05VTUJFUl9GT1JfRVhJU1RJTkdfRVJST1JfTUFQX1xuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUHJvdmlkZXJJZCwgU2lnbkluTWV0aG9kIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG5pbXBvcnQgeyBQaG9uZU9yT2F1dGhUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL21mYSc7XG5pbXBvcnQge1xuICBsaW5rV2l0aFBob25lTnVtYmVyLFxuICBzaWduSW5XaXRoUGhvbmVOdW1iZXIsXG4gIFNpZ25JbldpdGhQaG9uZU51bWJlclJlcXVlc3QsXG4gIHZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3Rpbmdcbn0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL3Ntcyc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IEF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi9hdXRoX2NyZWRlbnRpYWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBob25lQXV0aENyZWRlbnRpYWxQYXJhbWV0ZXJzIHtcbiAgdmVyaWZpY2F0aW9uSWQ/OiBzdHJpbmc7XG4gIHZlcmlmaWNhdGlvbkNvZGU/OiBzdHJpbmc7XG4gIHBob25lTnVtYmVyPzogc3RyaW5nO1xuICB0ZW1wb3JhcnlQcm9vZj86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjcmVkZW50aWFscyByZXR1cm5lZCBieSB7QGxpbmsgUGhvbmVBdXRoUHJvdmlkZXJ9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFBob25lQXV0aENyZWRlbnRpYWwgZXh0ZW5kcyBBdXRoQ3JlZGVudGlhbCB7XG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwYXJhbXM6IFBob25lQXV0aENyZWRlbnRpYWxQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIoUHJvdmlkZXJJZC5QSE9ORSwgU2lnbkluTWV0aG9kLlBIT05FKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9mcm9tVmVyaWZpY2F0aW9uKFxuICAgIHZlcmlmaWNhdGlvbklkOiBzdHJpbmcsXG4gICAgdmVyaWZpY2F0aW9uQ29kZTogc3RyaW5nXG4gICk6IFBob25lQXV0aENyZWRlbnRpYWwge1xuICAgIHJldHVybiBuZXcgUGhvbmVBdXRoQ3JlZGVudGlhbCh7IHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlIH0pO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21Ub2tlblJlc3BvbnNlKFxuICAgIHBob25lTnVtYmVyOiBzdHJpbmcsXG4gICAgdGVtcG9yYXJ5UHJvb2Y6IHN0cmluZ1xuICApOiBQaG9uZUF1dGhDcmVkZW50aWFsIHtcbiAgICByZXR1cm4gbmV3IFBob25lQXV0aENyZWRlbnRpYWwoeyBwaG9uZU51bWJlciwgdGVtcG9yYXJ5UHJvb2YgfSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxQaG9uZU9yT2F1dGhUb2tlblJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHNpZ25JbldpdGhQaG9uZU51bWJlcihhdXRoLCB0aGlzLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2xpbmtUb0lkVG9rZW4oXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGlkVG9rZW46IHN0cmluZ1xuICApOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT4ge1xuICAgIHJldHVybiBsaW5rV2l0aFBob25lTnVtYmVyKGF1dGgsIHtcbiAgICAgIGlkVG9rZW4sXG4gICAgICAuLi50aGlzLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpXG4gICAgfSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxJZFRva2VuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdmVyaWZ5UGhvbmVOdW1iZXJGb3JFeGlzdGluZyhhdXRoLCB0aGlzLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX21ha2VWZXJpZmljYXRpb25SZXF1ZXN0KCk6IFNpZ25JbldpdGhQaG9uZU51bWJlclJlcXVlc3Qge1xuICAgIGNvbnN0IHsgdGVtcG9yYXJ5UHJvb2YsIHBob25lTnVtYmVyLCB2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSB9ID1cbiAgICAgIHRoaXMucGFyYW1zO1xuICAgIGlmICh0ZW1wb3JhcnlQcm9vZiAmJiBwaG9uZU51bWJlcikge1xuICAgICAgcmV0dXJuIHsgdGVtcG9yYXJ5UHJvb2YsIHBob25lTnVtYmVyIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNlc3Npb25JbmZvOiB2ZXJpZmljYXRpb25JZCxcbiAgICAgIGNvZGU6IHZlcmlmaWNhdGlvbkNvZGVcbiAgICB9O1xuICB9XG5cbiAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICovXG4gIHRvSlNPTigpOiBvYmplY3Qge1xuICAgIGNvbnN0IG9iajogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZFxuICAgIH07XG4gICAgaWYgKHRoaXMucGFyYW1zLnBob25lTnVtYmVyKSB7XG4gICAgICBvYmoucGhvbmVOdW1iZXIgPSB0aGlzLnBhcmFtcy5waG9uZU51bWJlcjtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyYW1zLnRlbXBvcmFyeVByb29mKSB7XG4gICAgICBvYmoudGVtcG9yYXJ5UHJvb2YgPSB0aGlzLnBhcmFtcy50ZW1wb3JhcnlQcm9vZjtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbkNvZGUpIHtcbiAgICAgIG9iai52ZXJpZmljYXRpb25Db2RlID0gdGhpcy5wYXJhbXMudmVyaWZpY2F0aW9uQ29kZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbklkKSB7XG4gICAgICBvYmoudmVyaWZpY2F0aW9uSWQgPSB0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25JZDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLyoqIEdlbmVyYXRlcyBhIHBob25lIGNyZWRlbnRpYWwgYmFzZWQgb24gYSBwbGFpbiBvYmplY3Qgb3IgYSBKU09OIHN0cmluZy4gKi9cbiAgc3RhdGljIGZyb21KU09OKGpzb246IG9iamVjdCB8IHN0cmluZyk6IFBob25lQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlLCBwaG9uZU51bWJlciwgdGVtcG9yYXJ5UHJvb2YgfSA9XG4gICAgICBqc29uIGFzIHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gICAgaWYgKFxuICAgICAgIXZlcmlmaWNhdGlvbkNvZGUgJiZcbiAgICAgICF2ZXJpZmljYXRpb25JZCAmJlxuICAgICAgIXBob25lTnVtYmVyICYmXG4gICAgICAhdGVtcG9yYXJ5UHJvb2ZcbiAgICApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUGhvbmVBdXRoQ3JlZGVudGlhbCh7XG4gICAgICB2ZXJpZmljYXRpb25JZCxcbiAgICAgIHZlcmlmaWNhdGlvbkNvZGUsXG4gICAgICBwaG9uZU51bWJlcixcbiAgICAgIHRlbXBvcmFyeVByb29mXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGV4dHJhY3RRdWVyeXN0cmluZywgcXVlcnlzdHJpbmdEZWNvZGUgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBBY3Rpb25Db2RlT3BlcmF0aW9uIH0gZnJvbSAnLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi91dGlsL2Fzc2VydCc7XG5cbi8qKlxuICogRW51bXMgZm9yIGZpZWxkcyBpbiBVUkwgcXVlcnkgc3RyaW5nLlxuICpcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGVudW0gUXVlcnlGaWVsZCB7XG4gIEFQSV9LRVkgPSAnYXBpS2V5JyxcbiAgQ09ERSA9ICdvb2JDb2RlJyxcbiAgQ09OVElOVUVfVVJMID0gJ2NvbnRpbnVlVXJsJyxcbiAgTEFOR1VBR0VfQ09ERSA9ICdsYW5ndWFnZUNvZGUnLFxuICBNT0RFID0gJ21vZGUnLFxuICBURU5BTlRfSUQgPSAndGVuYW50SWQnXG59XG5cbi8qKlxuICogTWFwcyB0aGUgbW9kZSBzdHJpbmcgaW4gYWN0aW9uIGNvZGUgVVJMIHRvIEFjdGlvbiBDb2RlIEluZm8gb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSBtb2RlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTW9kZShtb2RlOiBzdHJpbmcgfCBudWxsKTogQWN0aW9uQ29kZU9wZXJhdGlvbiB8IG51bGwge1xuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdyZWNvdmVyRW1haWwnOlxuICAgICAgcmV0dXJuIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVDT1ZFUl9FTUFJTDtcbiAgICBjYXNlICdyZXNldFBhc3N3b3JkJzpcbiAgICAgIHJldHVybiBBY3Rpb25Db2RlT3BlcmF0aW9uLlBBU1NXT1JEX1JFU0VUO1xuICAgIGNhc2UgJ3NpZ25Jbic6XG4gICAgICByZXR1cm4gQWN0aW9uQ29kZU9wZXJhdGlvbi5FTUFJTF9TSUdOSU47XG4gICAgY2FzZSAndmVyaWZ5RW1haWwnOlxuICAgICAgcmV0dXJuIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0VNQUlMO1xuICAgIGNhc2UgJ3ZlcmlmeUFuZENoYW5nZUVtYWlsJzpcbiAgICAgIHJldHVybiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMO1xuICAgIGNhc2UgJ3JldmVydFNlY29uZEZhY3RvckFkZGl0aW9uJzpcbiAgICAgIHJldHVybiBBY3Rpb25Db2RlT3BlcmF0aW9uLlJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byBwYXJzZSBGREwgbGlua3NcbiAqXG4gKiBAcGFyYW0gdXJsXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGVlcExpbmsodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBsaW5rID0gcXVlcnlzdHJpbmdEZWNvZGUoZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybCkpWydsaW5rJ107XG5cbiAgLy8gRG91YmxlIGxpbmsgY2FzZSAoYXV0b21hdGljIHJlZGlyZWN0KS5cbiAgY29uc3QgZG91YmxlRGVlcExpbmsgPSBsaW5rXG4gICAgPyBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcobGluaykpWydkZWVwX2xpbmtfaWQnXVxuICAgIDogbnVsbDtcbiAgLy8gaU9TIGN1c3RvbSBzY2hlbWUgbGlua3MuXG4gIGNvbnN0IGlPU0RlZXBMaW5rID0gcXVlcnlzdHJpbmdEZWNvZGUoZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybCkpW1xuICAgICdkZWVwX2xpbmtfaWQnXG4gIF07XG4gIGNvbnN0IGlPU0RvdWJsZURlZXBMaW5rID0gaU9TRGVlcExpbmtcbiAgICA/IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyhpT1NEZWVwTGluaykpWydsaW5rJ11cbiAgICA6IG51bGw7XG4gIHJldHVybiBpT1NEb3VibGVEZWVwTGluayB8fCBpT1NEZWVwTGluayB8fCBkb3VibGVEZWVwTGluayB8fCBsaW5rIHx8IHVybDtcbn1cblxuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gcGFyc2UgZW1haWwgYWN0aW9uIFVSTHMgc3VjaCBhcyBwYXNzd29yZCByZXNldCwgZW1haWwgdmVyaWZpY2F0aW9uLFxuICogZW1haWwgbGluayBzaWduIGluLCBldGMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQWN0aW9uQ29kZVVSTCB7XG4gIC8qKlxuICAgKiBUaGUgQVBJIGtleSBvZiB0aGUgZW1haWwgYWN0aW9uIGxpbmsuXG4gICAqL1xuICByZWFkb25seSBhcGlLZXk6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBhY3Rpb24gY29kZSBvZiB0aGUgZW1haWwgYWN0aW9uIGxpbmsuXG4gICAqL1xuICByZWFkb25seSBjb2RlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgY29udGludWUgVVJMIG9mIHRoZSBlbWFpbCBhY3Rpb24gbGluay4gTnVsbCBpZiBub3QgcHJvdmlkZWQuXG4gICAqL1xuICByZWFkb25seSBjb250aW51ZVVybDogc3RyaW5nIHwgbnVsbDtcbiAgLyoqXG4gICAqIFRoZSBsYW5ndWFnZSBjb2RlIG9mIHRoZSBlbWFpbCBhY3Rpb24gbGluay4gTnVsbCBpZiBub3QgcHJvdmlkZWQuXG4gICAqL1xuICByZWFkb25seSBsYW5ndWFnZUNvZGU6IHN0cmluZyB8IG51bGw7XG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIHBlcmZvcm1lZCBieSB0aGUgZW1haWwgYWN0aW9uIGxpbmsuIEl0IHJldHVybnMgZnJvbSBvbmUgb2YgdGhlIHR5cGVzIGZyb21cbiAgICoge0BsaW5rIEFjdGlvbkNvZGVJbmZvfVxuICAgKi9cbiAgcmVhZG9ubHkgb3BlcmF0aW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdGVuYW50IElEIG9mIHRoZSBlbWFpbCBhY3Rpb24gbGluay4gTnVsbCBpZiB0aGUgZW1haWwgYWN0aW9uIGlzIGZyb20gdGhlIHBhcmVudCBwcm9qZWN0LlxuICAgKi9cbiAgcmVhZG9ubHkgdGVuYW50SWQ6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhY3Rpb25MaW5rIC0gVGhlIGxpbmsgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBVUkwuXG4gICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gb2JqZWN0LCBvciBudWxsIGlmIHRoZSBsaW5rIGlzIGludmFsaWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoYWN0aW9uTGluazogc3RyaW5nKSB7XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gcXVlcnlzdHJpbmdEZWNvZGUoZXh0cmFjdFF1ZXJ5c3RyaW5nKGFjdGlvbkxpbmspKTtcbiAgICBjb25zdCBhcGlLZXkgPSBzZWFyY2hQYXJhbXNbUXVlcnlGaWVsZC5BUElfS0VZXSA/PyBudWxsO1xuICAgIGNvbnN0IGNvZGUgPSBzZWFyY2hQYXJhbXNbUXVlcnlGaWVsZC5DT0RFXSA/PyBudWxsO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHBhcnNlTW9kZShzZWFyY2hQYXJhbXNbUXVlcnlGaWVsZC5NT0RFXSA/PyBudWxsKTtcbiAgICAvLyBWYWxpZGF0ZSBBUEkga2V5LCBjb2RlIGFuZCBtb2RlLlxuICAgIF9hc3NlcnQoYXBpS2V5ICYmIGNvZGUgJiYgb3BlcmF0aW9uLCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SKTtcbiAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuY29udGludWVVcmwgPSBzZWFyY2hQYXJhbXNbUXVlcnlGaWVsZC5DT05USU5VRV9VUkxdID8/IG51bGw7XG4gICAgdGhpcy5sYW5ndWFnZUNvZGUgPSBzZWFyY2hQYXJhbXNbUXVlcnlGaWVsZC5MQU5HVUFHRV9DT0RFXSA/PyBudWxsO1xuICAgIHRoaXMudGVuYW50SWQgPSBzZWFyY2hQYXJhbXNbUXVlcnlGaWVsZC5URU5BTlRfSURdID8/IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIHRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcgYW5kIHJldHVybnMgYW4ge0BsaW5rIEFjdGlvbkNvZGVVUkx9IGlmIHRoZSBsaW5rIGlzIHZhbGlkLFxuICAgKiBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICAgKlxuICAgKiBAcGFyYW0gbGluayAgLSBUaGUgZW1haWwgYWN0aW9uIGxpbmsgc3RyaW5nLlxuICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIEFjdGlvbkNvZGVVUkx9IG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgbGluayBpcyBpbnZhbGlkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgcGFyc2VMaW5rKGxpbms6IHN0cmluZyk6IEFjdGlvbkNvZGVVUkwgfCBudWxsIHtcbiAgICBjb25zdCBhY3Rpb25MaW5rID0gcGFyc2VEZWVwTGluayhsaW5rKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBBY3Rpb25Db2RlVVJMKGFjdGlvbkxpbmspO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcgYW5kIHJldHVybnMgYW4ge0BsaW5rIEFjdGlvbkNvZGVVUkx9IGlmXG4gKiB0aGUgbGluayBpcyB2YWxpZCwgb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFjdGlvbkNvZGVVUkwobGluazogc3RyaW5nKTogQWN0aW9uQ29kZVVSTCB8IG51bGwge1xuICByZXR1cm4gQWN0aW9uQ29kZVVSTC5wYXJzZUxpbmsobGluayk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQcm92aWRlcklkLCBTaWduSW5NZXRob2QgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5pbXBvcnQgeyBBdXRoUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBBY3Rpb25Db2RlVVJMIH0gZnJvbSAnLi4vYWN0aW9uX2NvZGVfdXJsJztcbmltcG9ydCB7IEVtYWlsQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuLi9jcmVkZW50aWFscy9lbWFpbCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcge0BsaW5rIEVtYWlsQXV0aENyZWRlbnRpYWx9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEVtYWlsQXV0aFByb3ZpZGVyIGltcGxlbWVudHMgQXV0aFByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LlBBU1NXT1JELCBldmVuIGZvciBlbWFpbCBsaW5rLlxuICAgKi9cbiAgc3RhdGljIHJlYWRvbmx5IFBST1ZJREVSX0lEOiAncGFzc3dvcmQnID0gUHJvdmlkZXJJZC5QQVNTV09SRDtcbiAgLyoqXG4gICAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQuXG4gICAqL1xuICBzdGF0aWMgcmVhZG9ubHkgRU1BSUxfUEFTU1dPUkRfU0lHTl9JTl9NRVRIT0Q6ICdwYXNzd29yZCcgPVxuICAgIFNpZ25Jbk1ldGhvZC5FTUFJTF9QQVNTV09SRDtcbiAgLyoqXG4gICAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy5cbiAgICovXG4gIHN0YXRpYyByZWFkb25seSBFTUFJTF9MSU5LX1NJR05fSU5fTUVUSE9EOiAnZW1haWxMaW5rJyA9XG4gICAgU2lnbkluTWV0aG9kLkVNQUlMX0xJTks7XG4gIC8qKlxuICAgKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5QQVNTV09SRCwgZXZlbiBmb3IgZW1haWwgbGluay5cbiAgICovXG4gIHJlYWRvbmx5IHByb3ZpZGVySWQgPSBFbWFpbEF1dGhQcm92aWRlci5QUk9WSURFUl9JRDtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IHVzaW5nIGFuIGVtYWlsIGFuZCBwYXNzd29yZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBhdXRoQ3JlZGVudGlhbCA9IEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkKTtcbiAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBhdXRoQ3JlZGVudGlhbCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQoYXV0aCwgZW1haWwsIHBhc3N3b3JkKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBlbWFpbCAtIEVtYWlsIGFkZHJlc3MuXG4gICAqIEBwYXJhbSBwYXNzd29yZCAtIFVzZXIgYWNjb3VudCBwYXNzd29yZC5cbiAgICogQHJldHVybnMgVGhlIGF1dGggcHJvdmlkZXIgY3JlZGVudGlhbC5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBFbWFpbEF1dGhDcmVkZW50aWFsIHtcbiAgICByZXR1cm4gRW1haWxBdXRoQ3JlZGVudGlhbC5fZnJvbUVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gdXNpbmcgYW4gZW1haWwgYW5kIGFuIGVtYWlsIGxpbmsgYWZ0ZXIgYSBzaWduIGluIHdpdGhcbiAgICogZW1haWwgbGluayBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgYXV0aENyZWRlbnRpYWwgPSBFbWFpbEF1dGhQcm92aWRlci5jcmVkZW50aWFsV2l0aExpbmsoYXV0aCwgZW1haWwsIGVtYWlsTGluayk7XG4gICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aCwgYXV0aENyZWRlbnRpYWwpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBhd2FpdCBzZW5kU2lnbkluTGlua1RvRW1haWwoYXV0aCwgZW1haWwpO1xuICAgKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdXNlci5cbiAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsLCBlbWFpbExpbmspO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlIHVzZWQgdG8gdmVyaWZ5IHRoZSBsaW5rLlxuICAgKiBAcGFyYW0gZW1haWwgLSBFbWFpbCBhZGRyZXNzLlxuICAgKiBAcGFyYW0gZW1haWxMaW5rIC0gU2lnbi1pbiBlbWFpbCBsaW5rLlxuICAgKiBAcmV0dXJucyAtIFRoZSBhdXRoIHByb3ZpZGVyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbFdpdGhMaW5rKFxuICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgZW1haWxMaW5rOiBzdHJpbmdcbiAgKTogRW1haWxBdXRoQ3JlZGVudGlhbCB7XG4gICAgY29uc3QgYWN0aW9uQ29kZVVybCA9IEFjdGlvbkNvZGVVUkwucGFyc2VMaW5rKGVtYWlsTGluayk7XG4gICAgX2Fzc2VydChhY3Rpb25Db2RlVXJsLCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SKTtcblxuICAgIHJldHVybiBFbWFpbEF1dGhDcmVkZW50aWFsLl9mcm9tRW1haWxBbmRDb2RlKFxuICAgICAgZW1haWwsXG4gICAgICBhY3Rpb25Db2RlVXJsLmNvZGUsXG4gICAgICBhY3Rpb25Db2RlVXJsLnRlbmFudElkXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuLyoqXG4gKiBNYXAgb2YgT0F1dGggQ3VzdG9tIFBhcmFtZXRlcnMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBDdXN0b21QYXJhbWV0ZXJzID0gUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIEZlZGVyYXRlZCBwcm92aWRlcnMgKE9BdXRoIChpbmNsdWRpbmcgT0lEQyksIFNBTUwpLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgbm90IG1lYW50IHRvIGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIgaW1wbGVtZW50cyBBdXRoUHJvdmlkZXIge1xuICAvKiogQGludGVybmFsICovXG4gIGRlZmF1bHRMYW5ndWFnZUNvZGU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgY3VzdG9tUGFyYW1ldGVyczogQ3VzdG9tUGFyYW1ldGVycyA9IHt9O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgZ2VuZXJpYyBPQXV0aCBwcm92aWRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBwcm92aWRlcklkIC0gUHJvdmlkZXIgZm9yIHdoaWNoIGNyZWRlbnRpYWxzIHNob3VsZCBiZSBnZW5lcmF0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBwcm92aWRlcklkOiBzdHJpbmcpIHt9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGFuZ3VhZ2UgZ29kZS5cbiAgICpcbiAgICogQHBhcmFtIGxhbmd1YWdlQ29kZSAtIGxhbmd1YWdlIGNvZGVcbiAgICovXG4gIHNldERlZmF1bHRMYW5ndWFnZShsYW5ndWFnZUNvZGU6IHN0cmluZyB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLmRlZmF1bHRMYW5ndWFnZUNvZGUgPSBsYW5ndWFnZUNvZGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgT0F1dGggY3VzdG9tIHBhcmFtZXRlcnMgdG8gcGFzcyBpbiBhbiBPQXV0aCByZXF1ZXN0IGZvciBwb3B1cCBhbmQgcmVkaXJlY3Qgc2lnbi1pblxuICAgKiBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBGb3IgYSBkZXRhaWxlZCBsaXN0LCBjaGVjayB0aGUgcmVzZXJ2ZWQgcmVxdWlyZWQgT0F1dGggMi4wIHBhcmFtZXRlcnMgc3VjaCBhcyBgY2xpZW50X2lkYCxcbiAgICogYHJlZGlyZWN0X3VyaWAsIGBzY29wZWAsIGByZXNwb25zZV90eXBlYCwgYW5kIGBzdGF0ZWAgYXJlIG5vdCBhbGxvd2VkIGFuZCB3aWxsIGJlIGlnbm9yZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjdXN0b21PQXV0aFBhcmFtZXRlcnMgLSBUaGUgY3VzdG9tIE9BdXRoIHBhcmFtZXRlcnMgdG8gcGFzcyBpbiB0aGUgT0F1dGggcmVxdWVzdC5cbiAgICovXG4gIHNldEN1c3RvbVBhcmFtZXRlcnMoY3VzdG9tT0F1dGhQYXJhbWV0ZXJzOiBDdXN0b21QYXJhbWV0ZXJzKTogQXV0aFByb3ZpZGVyIHtcbiAgICB0aGlzLmN1c3RvbVBhcmFtZXRlcnMgPSBjdXN0b21PQXV0aFBhcmFtZXRlcnM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQgbGlzdCBvZiB7QGxpbmsgQ3VzdG9tUGFyYW1ldGVyc30uXG4gICAqL1xuICBnZXRDdXN0b21QYXJhbWV0ZXJzKCk6IEN1c3RvbVBhcmFtZXRlcnMge1xuICAgIHJldHVybiB0aGlzLmN1c3RvbVBhcmFtZXRlcnM7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEF1dGhQcm92aWRlciwgVXNlckNyZWRlbnRpYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmltcG9ydCB7IE9BdXRoQ3JlZGVudGlhbCwgT0F1dGhDcmVkZW50aWFsUGFyYW1zIH0gZnJvbSAnLi4vY3JlZGVudGlhbHMvb2F1dGgnO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgU2lnbkluV2l0aElkcFJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vLi4vaW50ZXJuYWwnO1xuaW1wb3J0IHsgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi9mZWRlcmF0ZWQnO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogRm9yIElEIHRva2VucyB3aXRoIG5vbmNlIGNsYWltLCB0aGUgcmF3IG5vbmNlIGhhcyB0byBhbHNvIGJlIHByb3ZpZGVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPQXV0aENyZWRlbnRpYWxPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBPQXV0aCBJRCB0b2tlbiB1c2VkIHRvIGluaXRpYWxpemUgdGhlIHtAbGluayBPQXV0aENyZWRlbnRpYWx9LlxuICAgKi9cbiAgaWRUb2tlbj86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBPQXV0aCBhY2Nlc3MgdG9rZW4gdXNlZCB0byBpbml0aWFsaXplIHRoZSB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfS5cbiAgICovXG4gIGFjY2Vzc1Rva2VuPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHJhdyBub25jZSBhc3NvY2lhdGVkIHdpdGggdGhlIElEIHRva2VuLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJdCBpcyByZXF1aXJlZCB3aGVuIGFuIElEIHRva2VuIHdpdGggYSBub25jZSBmaWVsZCBpcyBwcm92aWRlZC4gVGhlIFNIQS0yNTYgaGFzaCBvZiB0aGVcbiAgICogcmF3IG5vbmNlIG11c3QgbWF0Y2ggdGhlIG5vbmNlIGZpZWxkIGluIHRoZSBJRCB0b2tlbi5cbiAgICovXG4gIHJhd05vbmNlPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIENvbW1vbiBjb2RlIHRvIGFsbCBPQXV0aCBwcm92aWRlcnMuIFRoaXMgaXMgc2VwYXJhdGUgZnJvbSB0aGVcbiAqIHtAbGluayBPQXV0aFByb3ZpZGVyfSBzbyB0aGF0IGNoaWxkIHByb3ZpZGVycyAobGlrZVxuICoge0BsaW5rIEdvb2dsZUF1dGhQcm92aWRlcn0pIGRvbid0IGluaGVyaXQgdGhlIGBjcmVkZW50aWFsYCBpbnN0YW5jZSBtZXRob2QuXG4gKiBJbnN0ZWFkLCB0aGV5IHJlbHkgb24gYSBzdGF0aWMgYGNyZWRlbnRpYWxgIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VPQXV0aFByb3ZpZGVyXG4gIGV4dGVuZHMgRmVkZXJhdGVkQXV0aFByb3ZpZGVyXG4gIGltcGxlbWVudHMgQXV0aFByb3ZpZGVyXG57XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzY29wZXM6IHN0cmluZ1tdID0gW107XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBPQXV0aCBzY29wZSB0byB0aGUgY3JlZGVudGlhbC5cbiAgICpcbiAgICogQHBhcmFtIHNjb3BlIC0gUHJvdmlkZXIgT0F1dGggc2NvcGUgdG8gYWRkLlxuICAgKi9cbiAgYWRkU2NvcGUoc2NvcGU6IHN0cmluZyk6IEF1dGhQcm92aWRlciB7XG4gICAgLy8gSWYgbm90IGFscmVhZHkgYWRkZWQsIGFkZCBzY29wZSB0byBsaXN0LlxuICAgIGlmICghdGhpcy5zY29wZXMuaW5jbHVkZXMoc2NvcGUpKSB7XG4gICAgICB0aGlzLnNjb3Blcy5wdXNoKHNjb3BlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQgbGlzdCBvZiBPQXV0aCBzY29wZXMuXG4gICAqL1xuICBnZXRTY29wZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5zY29wZXNdO1xuICB9XG59XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgZ2VuZXJpYyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgT0F1dGhQcm92aWRlcignZ29vZ2xlLmNvbScpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgT0F1dGggQWNjZXNzIFRva2VuIGZvciB0aGUgcHJvdmlkZXIuXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBwcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChhdXRoLCByZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgT0F1dGhQcm92aWRlcignZ29vZ2xlLmNvbScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcbiAqXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgT0F1dGggQWNjZXNzIFRva2VuIGZvciB0aGUgcHJvdmlkZXIuXG4gKiBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQoYXV0aCwgcmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgT0F1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIEpTT04gc3RyaW5nIG9yIGEgcGxhaW4gb2JqZWN0LlxuICAgKiBAcGFyYW0ganNvbiAtIEEgcGxhaW4gb2JqZWN0IG9yIGEgSlNPTiBzdHJpbmdcbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsRnJvbUpTT04oanNvbjogb2JqZWN0IHwgc3RyaW5nKTogT0F1dGhDcmVkZW50aWFsIHtcbiAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbiAgICBfYXNzZXJ0KFxuICAgICAgJ3Byb3ZpZGVySWQnIGluIG9iaiAmJiAnc2lnbkluTWV0aG9kJyBpbiBvYmosXG4gICAgICBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SXG4gICAgKTtcbiAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKG9iaik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSBnZW5lcmljIE9BdXRoIHByb3ZpZGVyJ3MgYWNjZXNzIHRva2VuIG9yIElEIHRva2VuLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgcmF3IG5vbmNlIGlzIHJlcXVpcmVkIHdoZW4gYW4gSUQgdG9rZW4gd2l0aCBhIG5vbmNlIGZpZWxkIGlzIHByb3ZpZGVkLiBUaGUgU0hBLTI1NiBoYXNoIG9mXG4gICAqIHRoZSByYXcgbm9uY2UgbXVzdCBtYXRjaCB0aGUgbm9uY2UgZmllbGQgaW4gdGhlIElEIHRva2VuLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIGBnb29nbGVVc2VyYCBmcm9tIHRoZSBvbnN1Y2Nlc3MgR29vZ2xlIFNpZ24gSW4gY2FsbGJhY2suXG4gICAqIC8vIEluaXRpYWxpemUgYSBnZW5lcmF0ZSBPQXV0aCBwcm92aWRlciB3aXRoIGEgYGdvb2dsZS5jb21gIHByb3ZpZGVySWQuXG4gICAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IE9BdXRoUHJvdmlkZXIoJ2dvb2dsZS5jb20nKTtcbiAgICogY29uc3QgY3JlZGVudGlhbCA9IHByb3ZpZGVyLmNyZWRlbnRpYWwoe1xuICAgKiAgIGlkVG9rZW46IGdvb2dsZVVzZXIuZ2V0QXV0aFJlc3BvbnNlKCkuaWRfdG9rZW4sXG4gICAqIH0pO1xuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBFaXRoZXIgdGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIElEIHRva2VuLCBhY2Nlc3MgdG9rZW4gYW5kIHJhdyBub25jZVxuICAgKiBvciB0aGUgSUQgdG9rZW4gc3RyaW5nLlxuICAgKi9cbiAgY3JlZGVudGlhbChwYXJhbXM6IE9BdXRoQ3JlZGVudGlhbE9wdGlvbnMpOiBPQXV0aENyZWRlbnRpYWwge1xuICAgIHJldHVybiB0aGlzLl9jcmVkZW50aWFsKHsgLi4ucGFyYW1zLCBub25jZTogcGFyYW1zLnJhd05vbmNlIH0pO1xuICB9XG5cbiAgLyoqIEFuIGludGVybmFsIGNyZWRlbnRpYWwgbWV0aG9kIHRoYXQgYWNjZXB0cyBtb3JlIHBlcm1pc3NpdmUgb3B0aW9ucyAqL1xuICBwcml2YXRlIF9jcmVkZW50aWFsKFxuICAgIHBhcmFtczogT21pdDxPQXV0aENyZWRlbnRpYWxQYXJhbXMsICdzaWduSW5NZXRob2QnIHwgJ3Byb3ZpZGVySWQnPlxuICApOiBPQXV0aENyZWRlbnRpYWwge1xuICAgIF9hc3NlcnQocGFyYW1zLmlkVG9rZW4gfHwgcGFyYW1zLmFjY2Vzc1Rva2VuLCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SKTtcbiAgICAvLyBGb3IgT0F1dGhDcmVkZW50aWFsLCBzaWduIGluIG1ldGhvZCBpcyBzYW1lIGFzIHByb3ZpZGVySWQuXG4gICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWQsXG4gICAgICBzaWduSW5NZXRob2Q6IHRoaXMucHJvdmlkZXJJZFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdChcbiAgICB1c2VyQ3JlZGVudGlhbDogVXNlckNyZWRlbnRpYWxcbiAgKTogT0F1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgcmV0dXJuIE9BdXRoUHJvdmlkZXIub2F1dGhDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdChcbiAgICAgIHVzZXJDcmVkZW50aWFsIGFzIFVzZXJDcmVkZW50aWFsSW50ZXJuYWxcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3I6IEZpcmViYXNlRXJyb3IpOiBPQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICByZXR1cm4gT0F1dGhQcm92aWRlci5vYXV0aENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KFxuICAgICAgKGVycm9yLmN1c3RvbURhdGEgfHwge30pIGFzIFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIG9hdXRoQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3Qoe1xuICAgIF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlXG4gIH06IFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlKTogT0F1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBvYXV0aElkVG9rZW4sXG4gICAgICBvYXV0aEFjY2Vzc1Rva2VuLFxuICAgICAgb2F1dGhUb2tlblNlY3JldCxcbiAgICAgIHBlbmRpbmdUb2tlbixcbiAgICAgIG5vbmNlLFxuICAgICAgcHJvdmlkZXJJZFxuICAgIH0gPSB0b2tlblJlc3BvbnNlIGFzIFNpZ25JbldpdGhJZHBSZXNwb25zZTtcbiAgICBpZiAoXG4gICAgICAhb2F1dGhBY2Nlc3NUb2tlbiAmJlxuICAgICAgIW9hdXRoVG9rZW5TZWNyZXQgJiZcbiAgICAgICFvYXV0aElkVG9rZW4gJiZcbiAgICAgICFwZW5kaW5nVG9rZW5cbiAgICApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghcHJvdmlkZXJJZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgT0F1dGhQcm92aWRlcihwcm92aWRlcklkKS5fY3JlZGVudGlhbCh7XG4gICAgICAgIGlkVG9rZW46IG9hdXRoSWRUb2tlbixcbiAgICAgICAgYWNjZXNzVG9rZW46IG9hdXRoQWNjZXNzVG9rZW4sXG4gICAgICAgIG5vbmNlLFxuICAgICAgICBwZW5kaW5nVG9rZW5cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHsgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBPQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuLi9jcmVkZW50aWFscy9vYXV0aCc7XG5pbXBvcnQgeyBCYXNlT0F1dGhQcm92aWRlciB9IGZyb20gJy4vb2F1dGgnO1xuaW1wb3J0IHsgUHJvdmlkZXJJZCwgU2lnbkluTWV0aG9kIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uRkFDRUJPT0suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEZhY2Vib29rQXV0aFByb3ZpZGVyKCk7XG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXG4gKiBwcm92aWRlci5hZGRTY29wZSgndXNlcl9iaXJ0aGRheScpO1xuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgRmFjZWJvb2sgQWNjZXNzIFRva2VuLlxuICogICBjb25zdCBjcmVkZW50aWFsID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEZhY2Vib29rQXV0aFByb3ZpZGVyKCk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgndXNlcl9iaXJ0aGRheScpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcbiAqXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgRmFjZWJvb2sgQWNjZXNzIFRva2VuLlxuICogY29uc3QgY3JlZGVudGlhbCA9IEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWNlYm9va0F1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcbiAgLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRkFDRUJPT0suICovXG4gIHN0YXRpYyByZWFkb25seSBGQUNFQk9PS19TSUdOX0lOX01FVEhPRDogJ2ZhY2Vib29rLmNvbScgPVxuICAgIFNpZ25Jbk1ldGhvZC5GQUNFQk9PSztcbiAgLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LkZBQ0VCT09LLiAqL1xuICBzdGF0aWMgcmVhZG9ubHkgUFJPVklERVJfSUQ6ICdmYWNlYm9vay5jb20nID0gUHJvdmlkZXJJZC5GQUNFQk9PSztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihQcm92aWRlcklkLkZBQ0VCT09LKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgRmFjZWJvb2suXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gYGV2ZW50YCBmcm9tIHRoZSBGYWNlYm9vayBhdXRoLmF1dGhSZXNwb25zZUNoYW5nZSBjYWxsYmFjay5cbiAgICogY29uc3QgY3JlZGVudGlhbCA9IEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwoZXZlbnQuYXV0aFJlc3BvbnNlLmFjY2Vzc1Rva2VuKTtcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoY3JlZGVudGlhbCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gLSBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbChhY2Nlc3NUb2tlbjogc3RyaW5nKTogT0F1dGhDcmVkZW50aWFsIHtcbiAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcbiAgICAgIHByb3ZpZGVySWQ6IEZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxuICAgICAgc2lnbkluTWV0aG9kOiBGYWNlYm9va0F1dGhQcm92aWRlci5GQUNFQk9PS19TSUdOX0lOX01FVEhPRCxcbiAgICAgIGFjY2Vzc1Rva2VuXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KFxuICAgIHVzZXJDcmVkZW50aWFsOiBVc2VyQ3JlZGVudGlhbFxuICApOiBPQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICByZXR1cm4gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoXG4gICAgICB1c2VyQ3JlZGVudGlhbCBhcyBVc2VyQ3JlZGVudGlhbEludGVybmFsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3I6IEZpcmViYXNlRXJyb3IpOiBPQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICByZXR1cm4gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoXG4gICAgICAoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkgYXMgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2VcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3Qoe1xuICAgIF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlXG4gIH06IFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlKTogT0F1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgaWYgKCF0b2tlblJlc3BvbnNlIHx8ICEoJ29hdXRoQWNjZXNzVG9rZW4nIGluIHRva2VuUmVzcG9uc2UpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsKHRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbik7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmltcG9ydCB7IFNpZ25JbldpdGhJZHBSZXNwb25zZSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9pZHAnO1xuaW1wb3J0IHsgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBPQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuLi9jcmVkZW50aWFscy9vYXV0aCc7XG5pbXBvcnQgeyBCYXNlT0F1dGhQcm92aWRlciB9IGZyb20gJy4vb2F1dGgnO1xuaW1wb3J0IHsgUHJvdmlkZXJJZCwgU2lnbkluTWV0aG9kIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uR09PR0xFLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBHb29nbGVBdXRoUHJvdmlkZXIoKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgnZW1haWwnKTtcbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGlmIChyZXN1bHQpIHtcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIEdvb2dsZSBBY2Nlc3MgVG9rZW4uXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdvb2dsZUF1dGhQcm92aWRlcigpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcbiAqXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR29vZ2xlIEFjY2VzcyBUb2tlbi5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEdvb2dsZUF1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcbiAgLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uR09PR0xFLiAqL1xuICBzdGF0aWMgcmVhZG9ubHkgR09PR0xFX1NJR05fSU5fTUVUSE9EOiAnZ29vZ2xlLmNvbScgPSBTaWduSW5NZXRob2QuR09PR0xFO1xuICAvKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uR09PR0xFLiAqL1xuICBzdGF0aWMgcmVhZG9ubHkgUFJPVklERVJfSUQ6ICdnb29nbGUuY29tJyA9IFByb3ZpZGVySWQuR09PR0xFO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFByb3ZpZGVySWQuR09PR0xFKTtcbiAgICB0aGlzLmFkZFNjb3BlKCdwcm9maWxlJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZm9yIEdvb2dsZS4gQXQgbGVhc3Qgb25lIG9mIElEIHRva2VuIGFuZCBhY2Nlc3MgdG9rZW4gaXMgcmVxdWlyZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gXFxgZ29vZ2xlVXNlclxcYCBmcm9tIHRoZSBvbnN1Y2Nlc3MgR29vZ2xlIFNpZ24gSW4gY2FsbGJhY2suXG4gICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChnb29nbGVVc2VyLmdldEF1dGhSZXNwb25zZSgpLmlkX3Rva2VuKTtcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoY3JlZGVudGlhbCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gaWRUb2tlbiAtIEdvb2dsZSBJRCB0b2tlbi5cbiAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIC0gR29vZ2xlIGFjY2VzcyB0b2tlbi5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsKFxuICAgIGlkVG9rZW4/OiBzdHJpbmcgfCBudWxsLFxuICAgIGFjY2Vzc1Rva2VuPzogc3RyaW5nIHwgbnVsbFxuICApOiBPQXV0aENyZWRlbnRpYWwge1xuICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoe1xuICAgICAgcHJvdmlkZXJJZDogR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxuICAgICAgc2lnbkluTWV0aG9kOiBHb29nbGVBdXRoUHJvdmlkZXIuR09PR0xFX1NJR05fSU5fTUVUSE9ELFxuICAgICAgaWRUb2tlbixcbiAgICAgIGFjY2Vzc1Rva2VuXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KFxuICAgIHVzZXJDcmVkZW50aWFsOiBVc2VyQ3JlZGVudGlhbFxuICApOiBPQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICByZXR1cm4gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KFxuICAgICAgdXNlckNyZWRlbnRpYWwgYXMgVXNlckNyZWRlbnRpYWxJbnRlcm5hbFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcjogRmlyZWJhc2VFcnJvcik6IE9BdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIHJldHVybiBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoXG4gICAgICAoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkgYXMgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2VcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3Qoe1xuICAgIF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlXG4gIH06IFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlKTogT0F1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7IG9hdXRoSWRUb2tlbiwgb2F1dGhBY2Nlc3NUb2tlbiB9ID1cbiAgICAgIHRva2VuUmVzcG9uc2UgYXMgU2lnbkluV2l0aElkcFJlc3BvbnNlO1xuICAgIGlmICghb2F1dGhJZFRva2VuICYmICFvYXV0aEFjY2Vzc1Rva2VuKSB7XG4gICAgICAvLyBUaGlzIGNvdWxkIGJlIGFuIG9hdXRoIDEgY3JlZGVudGlhbCBvciBhIHBob25lIGNyZWRlbnRpYWxcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwob2F1dGhJZFRva2VuLCBvYXV0aEFjY2Vzc1Rva2VuKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHsgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBPQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuLi9jcmVkZW50aWFscy9vYXV0aCc7XG5pbXBvcnQgeyBCYXNlT0F1dGhQcm92aWRlciB9IGZyb20gJy4vb2F1dGgnO1xuaW1wb3J0IHsgUHJvdmlkZXJJZCwgU2lnbkluTWV0aG9kIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uR0lUSFVCLlxuICpcbiAqIEByZW1hcmtzXG4gKiBHaXRIdWIgcmVxdWlyZXMgYW4gT0F1dGggMi4wIHJlZGlyZWN0LCBzbyB5b3UgY2FuIGVpdGhlciBoYW5kbGUgdGhlIHJlZGlyZWN0IGRpcmVjdGx5LCBvciB1c2VcbiAqIHRoZSB7QGxpbmsgc2lnbkluV2l0aFBvcHVwfSBoYW5kbGVyOlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBHaXRodWJBdXRoUHJvdmlkZXIoKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdyZXBvJyk7XG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBpZiAocmVzdWx0KSB7XG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBHaXRodWIgQWNjZXNzIFRva2VuLlxuICogICBjb25zdCBjcmVkZW50aWFsID0gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBHaXRodWJBdXRoUHJvdmlkZXIoKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdyZXBvJyk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBHaXRodWIgQWNjZXNzIFRva2VuLlxuICogY29uc3QgY3JlZGVudGlhbCA9IEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBHaXRodWJBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XG4gIC8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LkdJVEhVQi4gKi9cbiAgc3RhdGljIHJlYWRvbmx5IEdJVEhVQl9TSUdOX0lOX01FVEhPRDogJ2dpdGh1Yi5jb20nID0gU2lnbkluTWV0aG9kLkdJVEhVQjtcbiAgLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LkdJVEhVQi4gKi9cbiAgc3RhdGljIHJlYWRvbmx5IFBST1ZJREVSX0lEOiAnZ2l0aHViLmNvbScgPSBQcm92aWRlcklkLkdJVEhVQjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihQcm92aWRlcklkLkdJVEhVQik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZm9yIEdpdGh1Yi5cbiAgICpcbiAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIC0gR2l0aHViIGFjY2VzcyB0b2tlbi5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsKGFjY2Vzc1Rva2VuOiBzdHJpbmcpOiBPQXV0aENyZWRlbnRpYWwge1xuICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoe1xuICAgICAgcHJvdmlkZXJJZDogR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxuICAgICAgc2lnbkluTWV0aG9kOiBHaXRodWJBdXRoUHJvdmlkZXIuR0lUSFVCX1NJR05fSU5fTUVUSE9ELFxuICAgICAgYWNjZXNzVG9rZW5cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQoXG4gICAgdXNlckNyZWRlbnRpYWw6IFVzZXJDcmVkZW50aWFsXG4gICk6IE9BdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIHJldHVybiBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoXG4gICAgICB1c2VyQ3JlZGVudGlhbCBhcyBVc2VyQ3JlZGVudGlhbEludGVybmFsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3I6IEZpcmViYXNlRXJyb3IpOiBPQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICByZXR1cm4gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KFxuICAgICAgKGVycm9yLmN1c3RvbURhdGEgfHwge30pIGFzIFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHtcbiAgICBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZVxuICB9OiBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZSk6IE9BdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIGlmICghdG9rZW5SZXNwb25zZSB8fCAhKCdvYXV0aEFjY2Vzc1Rva2VuJyBpbiB0b2tlblJlc3BvbnNlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwodG9rZW5SZXNwb25zZS5vYXV0aEFjY2Vzc1Rva2VuKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBTQU1MIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IGFuIHtAbGluayBTQU1MQXV0aFByb3ZpZGVyfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuaW1wb3J0IHtcbiAgc2lnbkluV2l0aElkcCxcbiAgU2lnbkluV2l0aElkcFJlcXVlc3Rcbn0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL2lkcCc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IEF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi9hdXRoX2NyZWRlbnRpYWwnO1xuXG5jb25zdCBJRFBfUkVRVUVTVF9VUkkgPSAnaHR0cDovL2xvY2FsaG9zdCc7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgU0FNTEF1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgcHJvdmlkZXJJZDogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGVuZGluZ1Rva2VuOiBzdHJpbmdcbiAgKSB7XG4gICAgc3VwZXIocHJvdmlkZXJJZCwgcHJvdmlkZXJJZCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxJZFRva2VuUmVzcG9uc2U+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcbiAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2xpbmtUb0lkVG9rZW4oXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGlkVG9rZW46IHN0cmluZ1xuICApOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgIHJlcXVlc3QuaWRUb2tlbiA9IGlkVG9rZW47XG4gICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxJZFRva2VuUmVzcG9uc2U+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0LmF1dG9DcmVhdGUgPSBmYWxzZTtcbiAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKiB7QGluaGVyaXRkb2MgQXV0aENyZWRlbnRpYWwudG9KU09OfSAgKi9cbiAgdG9KU09OKCk6IG9iamVjdCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ25Jbk1ldGhvZDogdGhpcy5zaWduSW5NZXRob2QsXG4gICAgICBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWQsXG4gICAgICBwZW5kaW5nVG9rZW46IHRoaXMucGVuZGluZ1Rva2VuXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIHRvIGRlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW50byBhblxuICAgKiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfS5cbiAgICpcbiAgICogQHBhcmFtIGpzb24gLSBJbnB1dCBjYW4gYmUgZWl0aGVyIE9iamVjdCBvciB0aGUgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICogV2hlbiBzdHJpbmcgaXMgcHJvdmlkZWQsIEpTT04ucGFyc2Ugd291bGQgYmUgY2FsbGVkIGZpcnN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0sIG51bGwgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBzdGF0aWMgZnJvbUpTT04oanNvbjogc3RyaW5nIHwgb2JqZWN0KTogU0FNTEF1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XG4gICAgY29uc3QgeyBwcm92aWRlcklkLCBzaWduSW5NZXRob2QsIHBlbmRpbmdUb2tlbiB9OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID1cbiAgICAgIG9iajtcbiAgICBpZiAoXG4gICAgICAhcHJvdmlkZXJJZCB8fFxuICAgICAgIXNpZ25Jbk1ldGhvZCB8fFxuICAgICAgIXBlbmRpbmdUb2tlbiB8fFxuICAgICAgcHJvdmlkZXJJZCAhPT0gc2lnbkluTWV0aG9kXG4gICAgKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNBTUxBdXRoQ3JlZGVudGlhbChwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBzdGF0aWMgbWV0aG9kIHRvIGF2b2lkIGV4cG9zaW5nIHRoZSBjb25zdHJ1Y3RvciB0byBlbmQgdXNlcnMuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIF9jcmVhdGUocHJvdmlkZXJJZDogc3RyaW5nLCBwZW5kaW5nVG9rZW46IHN0cmluZyk6IFNBTUxBdXRoQ3JlZGVudGlhbCB7XG4gICAgcmV0dXJuIG5ldyBTQU1MQXV0aENyZWRlbnRpYWwocHJvdmlkZXJJZCwgcGVuZGluZ1Rva2VuKTtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRSZXF1ZXN0KCk6IFNpZ25JbldpdGhJZHBSZXF1ZXN0IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWVzdFVyaTogSURQX1JFUVVFU1RfVVJJLFxuICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXG4gICAgICBwZW5kaW5nVG9rZW46IHRoaXMucGVuZGluZ1Rva2VuXG4gICAgfTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFNpZ25JbldpdGhJZHBSZXNwb25zZSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9pZHAnO1xuaW1wb3J0IHsgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IFNBTUxBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uL2NyZWRlbnRpYWxzL3NhbWwnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi9mZWRlcmF0ZWQnO1xuXG5jb25zdCBTQU1MX1BST1ZJREVSX1BSRUZJWCA9ICdzYW1sLic7XG5cbi8qKlxuICogQW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gZm9yIFNBTUwuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgU0FNTEF1dGhQcm92aWRlciBleHRlbmRzIEZlZGVyYXRlZEF1dGhQcm92aWRlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci4gVGhlIHByb3ZpZGVySWQgbXVzdCBzdGFydCB3aXRoIFwic2FtbC5cIlxuICAgKiBAcGFyYW0gcHJvdmlkZXJJZCAtIFNBTUwgcHJvdmlkZXIgSUQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlcklkOiBzdHJpbmcpIHtcbiAgICBfYXNzZXJ0KFxuICAgICAgcHJvdmlkZXJJZC5zdGFydHNXaXRoKFNBTUxfUFJPVklERVJfUFJFRklYKSxcbiAgICAgIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1JcbiAgICApO1xuICAgIHN1cGVyKHByb3ZpZGVySWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9IGFmdGVyIGFcbiAgICogc3VjY2Vzc2Z1bCBTQU1MIGZsb3cgY29tcGxldGVzLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gZ2V0IGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0sIHlvdSBjb3VsZCB3cml0ZSB0aGVcbiAgICogZm9sbG93aW5nIGNvZGU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHNhbWxQcm92aWRlcik7XG4gICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBTQU1MQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQoXG4gICAgdXNlckNyZWRlbnRpYWw6IFVzZXJDcmVkZW50aWFsXG4gICk6IEF1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgcmV0dXJuIFNBTUxBdXRoUHJvdmlkZXIuc2FtbENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KFxuICAgICAgdXNlckNyZWRlbnRpYWwgYXMgVXNlckNyZWRlbnRpYWxJbnRlcm5hbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcbiAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yOiBGaXJlYmFzZUVycm9yKTogQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICByZXR1cm4gU0FNTEF1dGhQcm92aWRlci5zYW1sQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoXG4gICAgICAoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkgYXMgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2VcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSBmcm9tIGEgSlNPTiBzdHJpbmcgb3IgYSBwbGFpbiBvYmplY3QuXG4gICAqIEBwYXJhbSBqc29uIC0gQSBwbGFpbiBvYmplY3Qgb3IgYSBKU09OIHN0cmluZ1xuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tSlNPTihqc29uOiBzdHJpbmcgfCBvYmplY3QpOiBBdXRoQ3JlZGVudGlhbCB7XG4gICAgY29uc3QgY3JlZGVudGlhbCA9IFNBTUxBdXRoQ3JlZGVudGlhbC5mcm9tSlNPTihqc29uKTtcbiAgICBfYXNzZXJ0KGNyZWRlbnRpYWwsIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IpO1xuICAgIHJldHVybiBjcmVkZW50aWFsO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgc2FtbENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHtcbiAgICBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZVxuICB9OiBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZSk6IFNBTUxBdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgeyBwZW5kaW5nVG9rZW4sIHByb3ZpZGVySWQgfSA9IHRva2VuUmVzcG9uc2UgYXMgU2lnbkluV2l0aElkcFJlc3BvbnNlO1xuXG4gICAgaWYgKCFwZW5kaW5nVG9rZW4gfHwgIXByb3ZpZGVySWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gU0FNTEF1dGhDcmVkZW50aWFsLl9jcmVhdGUocHJvdmlkZXJJZCwgcGVuZGluZ1Rva2VuKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIFR3aXR0ZXIgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbXBvcnQgeyBTaWduSW5XaXRoSWRwUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vaWRwJztcbmltcG9ydCB7IFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgT0F1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi4vY3JlZGVudGlhbHMvb2F1dGgnO1xuaW1wb3J0IHsgQmFzZU9BdXRoUHJvdmlkZXIgfSBmcm9tICcuL29hdXRoJztcbmltcG9ydCB7IFByb3ZpZGVySWQsIFNpZ25Jbk1ldGhvZCB9IGZyb20gJy4uLy4uL21vZGVsL2VudW1zJztcblxuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmb3Ige0BsaW5rIFByb3ZpZGVySWR9LlRXSVRURVIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IFR3aXR0ZXJBdXRoUHJvdmlkZXIoKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGlmIChyZXN1bHQpIHtcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIFR3aXR0ZXIgQWNjZXNzIFRva2VuIGFuZCBTZWNyZXQuXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqICAgY29uc3Qgc2VjcmV0ID0gY3JlZGVudGlhbC5zZWNyZXQ7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgVHdpdHRlckF1dGhQcm92aWRlcigpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcbiAqXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgVHdpdHRlciBBY2Nlc3MgVG9rZW4gYW5kIFNlY3JldC5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiBjb25zdCBzZWNyZXQgPSBjcmVkZW50aWFsLnNlY3JldDtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFR3aXR0ZXJBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XG4gIC8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LlRXSVRURVIuICovXG4gIHN0YXRpYyByZWFkb25seSBUV0lUVEVSX1NJR05fSU5fTUVUSE9EOiAndHdpdHRlci5jb20nID0gU2lnbkluTWV0aG9kLlRXSVRURVI7XG4gIC8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5UV0lUVEVSLiAqL1xuICBzdGF0aWMgcmVhZG9ubHkgUFJPVklERVJfSUQ6ICd0d2l0dGVyLmNvbScgPSBQcm92aWRlcklkLlRXSVRURVI7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoUHJvdmlkZXJJZC5UV0lUVEVSKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgVHdpdHRlci5cbiAgICpcbiAgICogQHBhcmFtIHRva2VuIC0gVHdpdHRlciBhY2Nlc3MgdG9rZW4uXG4gICAqIEBwYXJhbSBzZWNyZXQgLSBUd2l0dGVyIHNlY3JldC5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsKHRva2VuOiBzdHJpbmcsIHNlY3JldDogc3RyaW5nKTogT0F1dGhDcmVkZW50aWFsIHtcbiAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcbiAgICAgIHByb3ZpZGVySWQ6IFR3aXR0ZXJBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXG4gICAgICBzaWduSW5NZXRob2Q6IFR3aXR0ZXJBdXRoUHJvdmlkZXIuVFdJVFRFUl9TSUdOX0lOX01FVEhPRCxcbiAgICAgIG9hdXRoVG9rZW46IHRva2VuLFxuICAgICAgb2F1dGhUb2tlblNlY3JldDogc2VjcmV0XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KFxuICAgIHVzZXJDcmVkZW50aWFsOiBVc2VyQ3JlZGVudGlhbFxuICApOiBPQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICByZXR1cm4gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdChcbiAgICAgIHVzZXJDcmVkZW50aWFsIGFzIFVzZXJDcmVkZW50aWFsSW50ZXJuYWxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcjogRmlyZWJhc2VFcnJvcik6IE9BdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIHJldHVybiBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KFxuICAgICAgKGVycm9yLmN1c3RvbURhdGEgfHwge30pIGFzIFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHtcbiAgICBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZVxuICB9OiBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZSk6IE9BdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgb2F1dGhBY2Nlc3NUb2tlbiwgb2F1dGhUb2tlblNlY3JldCB9ID1cbiAgICAgIHRva2VuUmVzcG9uc2UgYXMgU2lnbkluV2l0aElkcFJlc3BvbnNlO1xuICAgIGlmICghb2F1dGhBY2Nlc3NUb2tlbiB8fCAhb2F1dGhUb2tlblNlY3JldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwob2F1dGhBY2Nlc3NUb2tlbiwgb2F1dGhUb2tlblNlY3JldCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEVuZHBvaW50LFxuICBIdHRwTWV0aG9kLFxuICBSZWNhcHRjaGFDbGllbnRUeXBlLFxuICBSZWNhcHRjaGFWZXJzaW9uLFxuICBfYWRkVGlkSWZOZWNlc3NhcnksXG4gIF9wZXJmb3JtU2lnbkluUmVxdWVzdFxufSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBTaWduVXBSZXF1ZXN0IHtcbiAgcmV0dXJuU2VjdXJlVG9rZW4/OiBib29sZWFuO1xuICBlbWFpbD86IHN0cmluZztcbiAgcGFzc3dvcmQ/OiBzdHJpbmc7XG4gIHRlbmFudElkPzogc3RyaW5nO1xuICBjYXB0Y2hhUmVzcG9uc2U/OiBzdHJpbmc7XG4gIGNsaWVudFR5cGU/OiBSZWNhcHRjaGFDbGllbnRUeXBlO1xuICByZWNhcHRjaGFWZXJzaW9uPzogUmVjYXB0Y2hhVmVyc2lvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaWduVXBSZXNwb25zZSBleHRlbmRzIElkVG9rZW5SZXNwb25zZSB7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICBlbWFpbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25VcChcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogU2lnblVwUmVxdWVzdFxuKTogUHJvbWlzZTxTaWduVXBSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0PFNpZ25VcFJlcXVlc3QsIFNpZ25VcFJlc3BvbnNlPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5TSUdOX1VQLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUGhvbmVPck9hdXRoVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9tZmEnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgVXNlckludGVybmFsLCBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBVc2VySW1wbCB9IGZyb20gJy4vdXNlcl9pbXBsJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgT3BlcmF0aW9uVHlwZSwgUHJvdmlkZXJJZCB9IGZyb20gJy4uLy4uL21vZGVsL2VudW1zJztcblxuaW50ZXJmYWNlIFVzZXJDcmVkZW50aWFsUGFyYW1zIHtcbiAgcmVhZG9ubHkgdXNlcjogVXNlckludGVybmFsO1xuICByZWFkb25seSBwcm92aWRlcklkOiBQcm92aWRlcklkIHwgc3RyaW5nIHwgbnVsbDtcbiAgcmVhZG9ubHkgX3Rva2VuUmVzcG9uc2U/OiBQaG9uZU9yT2F1dGhUb2tlblJlc3BvbnNlO1xuICByZWFkb25seSBvcGVyYXRpb25UeXBlOiBPcGVyYXRpb25UeXBlO1xufVxuXG5leHBvcnQgY2xhc3MgVXNlckNyZWRlbnRpYWxJbXBsXG4gIGltcGxlbWVudHMgVXNlckNyZWRlbnRpYWxJbnRlcm5hbCwgVXNlckNyZWRlbnRpYWxQYXJhbXNcbntcbiAgcmVhZG9ubHkgdXNlcjogVXNlckludGVybmFsO1xuICByZWFkb25seSBwcm92aWRlcklkOiBQcm92aWRlcklkIHwgc3RyaW5nIHwgbnVsbDtcbiAgcmVhZG9ubHkgX3Rva2VuUmVzcG9uc2U6IFBob25lT3JPYXV0aFRva2VuUmVzcG9uc2UgfCB1bmRlZmluZWQ7XG4gIHJlYWRvbmx5IG9wZXJhdGlvblR5cGU6IE9wZXJhdGlvblR5cGU7XG5cbiAgY29uc3RydWN0b3IocGFyYW1zOiBVc2VyQ3JlZGVudGlhbFBhcmFtcykge1xuICAgIHRoaXMudXNlciA9IHBhcmFtcy51c2VyO1xuICAgIHRoaXMucHJvdmlkZXJJZCA9IHBhcmFtcy5wcm92aWRlcklkO1xuICAgIHRoaXMuX3Rva2VuUmVzcG9uc2UgPSBwYXJhbXMuX3Rva2VuUmVzcG9uc2U7XG4gICAgdGhpcy5vcGVyYXRpb25UeXBlID0gcGFyYW1zLm9wZXJhdGlvblR5cGU7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgX2Zyb21JZFRva2VuUmVzcG9uc2UoXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIG9wZXJhdGlvblR5cGU6IE9wZXJhdGlvblR5cGUsXG4gICAgaWRUb2tlblJlc3BvbnNlOiBJZFRva2VuUmVzcG9uc2UsXG4gICAgaXNBbm9ueW1vdXM6IGJvb2xlYW4gPSBmYWxzZVxuICApOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWw+IHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlckltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoXG4gICAgICBhdXRoLFxuICAgICAgaWRUb2tlblJlc3BvbnNlLFxuICAgICAgaXNBbm9ueW1vdXNcbiAgICApO1xuICAgIGNvbnN0IHByb3ZpZGVySWQgPSBwcm92aWRlcklkRm9yUmVzcG9uc2UoaWRUb2tlblJlc3BvbnNlKTtcbiAgICBjb25zdCB1c2VyQ3JlZCA9IG5ldyBVc2VyQ3JlZGVudGlhbEltcGwoe1xuICAgICAgdXNlcixcbiAgICAgIHByb3ZpZGVySWQsXG4gICAgICBfdG9rZW5SZXNwb25zZTogaWRUb2tlblJlc3BvbnNlLFxuICAgICAgb3BlcmF0aW9uVHlwZVxuICAgIH0pO1xuICAgIHJldHVybiB1c2VyQ3JlZDtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBfZm9yT3BlcmF0aW9uKFxuICAgIHVzZXI6IFVzZXJJbnRlcm5hbCxcbiAgICBvcGVyYXRpb25UeXBlOiBPcGVyYXRpb25UeXBlLFxuICAgIHJlc3BvbnNlOiBQaG9uZU9yT2F1dGhUb2tlblJlc3BvbnNlXG4gICk6IFByb21pc2U8VXNlckNyZWRlbnRpYWxJbXBsPiB7XG4gICAgYXdhaXQgdXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkocmVzcG9uc2UsIC8qIHJlbG9hZCAqLyB0cnVlKTtcbiAgICBjb25zdCBwcm92aWRlcklkID0gcHJvdmlkZXJJZEZvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICByZXR1cm4gbmV3IFVzZXJDcmVkZW50aWFsSW1wbCh7XG4gICAgICB1c2VyLFxuICAgICAgcHJvdmlkZXJJZCxcbiAgICAgIF90b2tlblJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgIG9wZXJhdGlvblR5cGVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm92aWRlcklkRm9yUmVzcG9uc2UoXG4gIHJlc3BvbnNlOiBJZFRva2VuUmVzcG9uc2Vcbik6IFByb3ZpZGVySWQgfCBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKHJlc3BvbnNlLnByb3ZpZGVySWQpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UucHJvdmlkZXJJZDtcbiAgfVxuXG4gIGlmICgncGhvbmVOdW1iZXInIGluIHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIFByb3ZpZGVySWQuUEhPTkU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEF1dGgsIFVzZXJDcmVkZW50aWFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IHNpZ25VcCB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9zaWduX3VwJztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbXBsIH0gZnJvbSAnLi4vdXNlci91c2VyX2NyZWRlbnRpYWxfaW1wbCc7XG5pbXBvcnQgeyBfY2FzdEF1dGggfSBmcm9tICcuLi9hdXRoL2F1dGhfaW1wbCc7XG5pbXBvcnQgeyBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIGFzIGFuIGFub255bW91cyB1c2VyLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIGFub255bW91cyB1c2VyIHNpZ25lZCBpbiwgdGhhdCB1c2VyIHdpbGwgYmUgcmV0dXJuZWQ7IG90aGVyd2lzZSwgYVxuICogbmV3IGFub255bW91cyB1c2VyIGlkZW50aXR5IHdpbGwgYmUgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25JbkFub255bW91c2x5KGF1dGg6IEF1dGgpOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsPiB7XG4gIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgYXdhaXQgYXV0aEludGVybmFsLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gIGlmIChhdXRoSW50ZXJuYWwuY3VycmVudFVzZXI/LmlzQW5vbnltb3VzKSB7XG4gICAgLy8gSWYgYW4gYW5vbnltb3VzIHVzZXIgaXMgYWxyZWFkeSBzaWduZWQgaW4sIG5vIG5lZWQgdG8gc2lnbiB0aGVtIGluIGFnYWluLlxuICAgIHJldHVybiBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcbiAgICAgIHVzZXI6IGF1dGhJbnRlcm5hbC5jdXJyZW50VXNlciBhcyBVc2VySW50ZXJuYWwsXG4gICAgICBwcm92aWRlcklkOiBudWxsLFxuICAgICAgb3BlcmF0aW9uVHlwZTogT3BlcmF0aW9uVHlwZS5TSUdOX0lOXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzaWduVXAoYXV0aEludGVybmFsLCB7XG4gICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcbiAgfSk7XG4gIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKFxuICAgIGF1dGhJbnRlcm5hbCxcbiAgICBPcGVyYXRpb25UeXBlLlNJR05fSU4sXG4gICAgcmVzcG9uc2UsXG4gICAgdHJ1ZVxuICApO1xuICBhd2FpdCBhdXRoSW50ZXJuYWwuX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xuICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBNdWx0aUZhY3RvckVycm9yIGFzIE11bHRpRmFjdG9yRXJyb3JQdWJsaWMgfSBmcm9tICcuLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2NvcmUvZXJyb3JzJztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCB9IGZyb20gJy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuLi9jb3JlL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IElkVG9rZW5NZmFSZXNwb25zZSB9IGZyb20gJy4uL2FwaS9hdXRoZW50aWNhdGlvbi9tZmEnO1xuaW1wb3J0IHsgT3BlcmF0aW9uVHlwZSB9IGZyb20gJy4uL21vZGVsL2VudW1zJztcblxuZXhwb3J0IHR5cGUgTXVsdGlGYWN0b3JFcnJvckRhdGEgPSBNdWx0aUZhY3RvckVycm9yUHVibGljWydjdXN0b21EYXRhJ10gJiB7XG4gIF9zZXJ2ZXJSZXNwb25zZTogSWRUb2tlbk1mYVJlc3BvbnNlO1xufTtcblxuZXhwb3J0IGNsYXNzIE11bHRpRmFjdG9yRXJyb3JcbiAgZXh0ZW5kcyBGaXJlYmFzZUVycm9yXG4gIGltcGxlbWVudHMgTXVsdGlGYWN0b3JFcnJvclB1YmxpY1xue1xuICByZWFkb25seSBjdXN0b21EYXRhOiBNdWx0aUZhY3RvckVycm9yRGF0YTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBlcnJvcjogRmlyZWJhc2VFcnJvcixcbiAgICByZWFkb25seSBvcGVyYXRpb25UeXBlOiBPcGVyYXRpb25UeXBlLFxuICAgIHJlYWRvbmx5IHVzZXI/OiBVc2VySW50ZXJuYWxcbiAgKSB7XG4gICAgc3VwZXIoZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYXN0ZXIvQnJlYWtpbmctQ2hhbmdlcy5tZCNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTXVsdGlGYWN0b3JFcnJvci5wcm90b3R5cGUpO1xuICAgIHRoaXMuY3VzdG9tRGF0YSA9IHtcbiAgICAgIGFwcE5hbWU6IGF1dGgubmFtZSxcbiAgICAgIHRlbmFudElkOiBhdXRoLnRlbmFudElkID8/IHVuZGVmaW5lZCxcbiAgICAgIF9zZXJ2ZXJSZXNwb25zZTogZXJyb3IuY3VzdG9tRGF0YSEuX3NlcnZlclJlc3BvbnNlIGFzIElkVG9rZW5NZmFSZXNwb25zZSxcbiAgICAgIG9wZXJhdGlvblR5cGVcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIF9mcm9tRXJyb3JBbmRPcGVyYXRpb24oXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGVycm9yOiBGaXJlYmFzZUVycm9yLFxuICAgIG9wZXJhdGlvblR5cGU6IE9wZXJhdGlvblR5cGUsXG4gICAgdXNlcj86IFVzZXJJbnRlcm5hbFxuICApOiBNdWx0aUZhY3RvckVycm9yIHtcbiAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yRXJyb3IoYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkoXG4gIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgb3BlcmF0aW9uVHlwZTogT3BlcmF0aW9uVHlwZSxcbiAgY3JlZGVudGlhbDogQXV0aENyZWRlbnRpYWwsXG4gIHVzZXI/OiBVc2VySW50ZXJuYWxcbik6IFByb21pc2U8SWRUb2tlblJlc3BvbnNlPiB7XG4gIGNvbnN0IGlkVG9rZW5Qcm92aWRlciA9XG4gICAgb3BlcmF0aW9uVHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURVxuICAgICAgPyBjcmVkZW50aWFsLl9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aClcbiAgICAgIDogY3JlZGVudGlhbC5fZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpO1xuXG4gIHJldHVybiBpZFRva2VuUHJvdmlkZXIuY2F0Y2goZXJyb3IgPT4ge1xuICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke0F1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEfWApIHtcbiAgICAgIHRocm93IE11bHRpRmFjdG9yRXJyb3IuX2Zyb21FcnJvckFuZE9wZXJhdGlvbihcbiAgICAgICAgYXV0aCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIG9wZXJhdGlvblR5cGUsXG4gICAgICAgIHVzZXJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBQcm92aWRlckFzc29jaWF0ZWRPYmplY3Qge1xuICBwcm92aWRlcklkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIFVzZXJJbmZvIHByb3ZpZGVyIGRhdGEgYW5kIGNvbnZlcnRzIGl0IHRvIGEgc2V0IG9mIG5hbWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm92aWRlckRhdGFBc05hbWVzPFQgZXh0ZW5kcyBQcm92aWRlckFzc29jaWF0ZWRPYmplY3Q+KFxuICBwcm92aWRlckRhdGE6IFRbXVxuKTogU2V0PHN0cmluZz4ge1xuICByZXR1cm4gbmV3IFNldChcbiAgICBwcm92aWRlckRhdGFcbiAgICAgIC5tYXAoKHsgcHJvdmlkZXJJZCB9KSA9PiBwcm92aWRlcklkKVxuICAgICAgLmZpbHRlcihwaWQgPT4gISFwaWQpIGFzIHN0cmluZ1tdXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHsgZGVsZXRlTGlua2VkQWNjb3VudHMgfSBmcm9tICcuLi8uLi9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L2FjY291bnQnO1xuaW1wb3J0IHsgVXNlckludGVybmFsLCBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IHByb3ZpZGVyRGF0YUFzTmFtZXMgfSBmcm9tICcuLi91dGlsL3Byb3ZpZGVycyc7XG5pbXBvcnQgeyBfbG9nb3V0SWZJbnZhbGlkYXRlZCB9IGZyb20gJy4vaW52YWxpZGF0aW9uJztcbmltcG9ydCB7IF9yZWxvYWRXaXRob3V0U2F2aW5nIH0gZnJvbSAnLi9yZWxvYWQnO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbXBsIH0gZnJvbSAnLi91c2VyX2NyZWRlbnRpYWxfaW1wbCc7XG5pbXBvcnQgeyBnZXRNb2R1bGFySW5zdGFuY2UgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBPcGVyYXRpb25UeXBlLCBQcm92aWRlcklkIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG4vKipcbiAqIFVubGlua3MgYSBwcm92aWRlciBmcm9tIGEgdXNlciBhY2NvdW50LlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gcHJvdmlkZXJJZCAtIFRoZSBwcm92aWRlciB0byB1bmxpbmsuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdW5saW5rKHVzZXI6IFVzZXIsIHByb3ZpZGVySWQ6IHN0cmluZyk6IFByb21pc2U8VXNlcj4ge1xuICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsO1xuICBhd2FpdCBfYXNzZXJ0TGlua2VkU3RhdHVzKHRydWUsIHVzZXJJbnRlcm5hbCwgcHJvdmlkZXJJZCk7XG4gIGNvbnN0IHsgcHJvdmlkZXJVc2VySW5mbyB9ID0gYXdhaXQgZGVsZXRlTGlua2VkQWNjb3VudHModXNlckludGVybmFsLmF1dGgsIHtcbiAgICBpZFRva2VuOiBhd2FpdCB1c2VySW50ZXJuYWwuZ2V0SWRUb2tlbigpLFxuICAgIGRlbGV0ZVByb3ZpZGVyOiBbcHJvdmlkZXJJZF1cbiAgfSk7XG5cbiAgY29uc3QgcHJvdmlkZXJzTGVmdCA9IHByb3ZpZGVyRGF0YUFzTmFtZXMocHJvdmlkZXJVc2VySW5mbyB8fCBbXSk7XG5cbiAgdXNlckludGVybmFsLnByb3ZpZGVyRGF0YSA9IHVzZXJJbnRlcm5hbC5wcm92aWRlckRhdGEuZmlsdGVyKHBkID0+XG4gICAgcHJvdmlkZXJzTGVmdC5oYXMocGQucHJvdmlkZXJJZClcbiAgKTtcbiAgaWYgKCFwcm92aWRlcnNMZWZ0LmhhcyhQcm92aWRlcklkLlBIT05FKSkge1xuICAgIHVzZXJJbnRlcm5hbC5waG9uZU51bWJlciA9IG51bGw7XG4gIH1cblxuICBhd2FpdCB1c2VySW50ZXJuYWwuYXV0aC5fcGVyc2lzdFVzZXJJZkN1cnJlbnQodXNlckludGVybmFsKTtcbiAgcmV0dXJuIHVzZXJJbnRlcm5hbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9saW5rKFxuICB1c2VyOiBVc2VySW50ZXJuYWwsXG4gIGNyZWRlbnRpYWw6IEF1dGhDcmVkZW50aWFsLFxuICBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZVxuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEludGVybmFsPiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQoXG4gICAgdXNlcixcbiAgICBjcmVkZW50aWFsLl9saW5rVG9JZFRva2VuKHVzZXIuYXV0aCwgYXdhaXQgdXNlci5nZXRJZFRva2VuKCkpLFxuICAgIGJ5cGFzc0F1dGhTdGF0ZVxuICApO1xuICByZXR1cm4gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24odXNlciwgT3BlcmF0aW9uVHlwZS5MSU5LLCByZXNwb25zZSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfYXNzZXJ0TGlua2VkU3RhdHVzKFxuICBleHBlY3RlZDogYm9vbGVhbixcbiAgdXNlcjogVXNlckludGVybmFsLFxuICBwcm92aWRlcjogc3RyaW5nXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlcik7XG4gIGNvbnN0IHByb3ZpZGVySWRzID0gcHJvdmlkZXJEYXRhQXNOYW1lcyh1c2VyLnByb3ZpZGVyRGF0YSk7XG5cbiAgY29uc3QgY29kZSA9XG4gICAgZXhwZWN0ZWQgPT09IGZhbHNlXG4gICAgICA/IEF1dGhFcnJvckNvZGUuUFJPVklERVJfQUxSRUFEWV9MSU5LRURcbiAgICAgIDogQXV0aEVycm9yQ29kZS5OT19TVUNIX1BST1ZJREVSO1xuICBfYXNzZXJ0KHByb3ZpZGVySWRzLmhhcyhwcm92aWRlcikgPT09IGV4cGVjdGVkLCB1c2VyLmF1dGgsIGNvZGUpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeSB9IGZyb20gJy4uLy4uL21mYS9tZmFfZXJyb3InO1xuaW1wb3J0IHsgT3BlcmF0aW9uVHlwZSB9IGZyb20gJy4uLy4uL21vZGVsL2VudW1zJztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuLi9jcmVkZW50aWFscyc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQsIF9mYWlsIH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgX3BhcnNlVG9rZW4gfSBmcm9tICcuL2lkX3Rva2VuX3Jlc3VsdCc7XG5pbXBvcnQgeyBfbG9nb3V0SWZJbnZhbGlkYXRlZCB9IGZyb20gJy4vaW52YWxpZGF0aW9uJztcbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsSW1wbCB9IGZyb20gJy4vdXNlcl9jcmVkZW50aWFsX2ltcGwnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3JlYXV0aGVudGljYXRlKFxuICB1c2VyOiBVc2VySW50ZXJuYWwsXG4gIGNyZWRlbnRpYWw6IEF1dGhDcmVkZW50aWFsLFxuICBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZVxuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEltcGw+IHtcbiAgY29uc3QgeyBhdXRoIH0gPSB1c2VyO1xuICBjb25zdCBvcGVyYXRpb25UeXBlID0gT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQoXG4gICAgICB1c2VyLFxuICAgICAgX3Byb2Nlc3NDcmVkZW50aWFsU2F2aW5nTWZhQ29udGV4dElmTmVjZXNzYXJ5KFxuICAgICAgICBhdXRoLFxuICAgICAgICBvcGVyYXRpb25UeXBlLFxuICAgICAgICBjcmVkZW50aWFsLFxuICAgICAgICB1c2VyXG4gICAgICApLFxuICAgICAgYnlwYXNzQXV0aFN0YXRlXG4gICAgKTtcbiAgICBfYXNzZXJ0KHJlc3BvbnNlLmlkVG9rZW4sIGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgIGNvbnN0IHBhcnNlZCA9IF9wYXJzZVRva2VuKHJlc3BvbnNlLmlkVG9rZW4pO1xuICAgIF9hc3NlcnQocGFyc2VkLCBhdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcblxuICAgIGNvbnN0IHsgc3ViOiBsb2NhbElkIH0gPSBwYXJzZWQ7XG4gICAgX2Fzc2VydCh1c2VyLnVpZCA9PT0gbG9jYWxJZCwgYXV0aCwgQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIKTtcblxuICAgIHJldHVybiBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbih1c2VyLCBvcGVyYXRpb25UeXBlLCByZXNwb25zZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBDb252ZXJ0IHVzZXIgZGVsZXRlZCBlcnJvciBpbnRvIHVzZXIgbWlzbWF0Y2hcbiAgICBpZiAoKGUgYXMgRmlyZWJhc2VFcnJvcik/LmNvZGUgPT09IGBhdXRoLyR7QXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUR9YCkge1xuICAgICAgX2ZhaWwoYXV0aCwgQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIKTtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWwsIEF1dGgsIFVzZXIgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkgfSBmcm9tICcuLi8uLi9tZmEvbWZhX2Vycm9yJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IF9hc3NlcnRMaW5rZWRTdGF0dXMsIF9saW5rIH0gZnJvbSAnLi4vdXNlci9saW5rX3VubGluayc7XG5pbXBvcnQgeyBfcmVhdXRoZW50aWNhdGUgfSBmcm9tICcuLi91c2VyL3JlYXV0aGVudGljYXRlJztcbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsSW1wbCB9IGZyb20gJy4uL3VzZXIvdXNlcl9jcmVkZW50aWFsX2ltcGwnO1xuaW1wb3J0IHsgX2Nhc3RBdXRoIH0gZnJvbSAnLi4vYXV0aC9hdXRoX2ltcGwnO1xuaW1wb3J0IHsgZ2V0TW9kdWxhckluc3RhbmNlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgT3BlcmF0aW9uVHlwZSB9IGZyb20gJy4uLy4uL21vZGVsL2VudW1zJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9zaWduSW5XaXRoQ3JlZGVudGlhbChcbiAgYXV0aDogQXV0aEludGVybmFsLFxuICBjcmVkZW50aWFsOiBBdXRoQ3JlZGVudGlhbCxcbiAgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2Vcbik6IFByb21pc2U8VXNlckNyZWRlbnRpYWw+IHtcbiAgY29uc3Qgb3BlcmF0aW9uVHlwZSA9IE9wZXJhdGlvblR5cGUuU0lHTl9JTjtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkoXG4gICAgYXV0aCxcbiAgICBvcGVyYXRpb25UeXBlLFxuICAgIGNyZWRlbnRpYWxcbiAgKTtcbiAgY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoXG4gICAgYXV0aCxcbiAgICBvcGVyYXRpb25UeXBlLFxuICAgIHJlc3BvbnNlXG4gICk7XG5cbiAgaWYgKCFieXBhc3NBdXRoU3RhdGUpIHtcbiAgICBhd2FpdCBhdXRoLl91cGRhdGVDdXJyZW50VXNlcih1c2VyQ3JlZGVudGlhbC51c2VyKTtcbiAgfVxuICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gd2l0aCB0aGUgZ2l2ZW4gY3JlZGVudGlhbHMuXG4gKlxuICogQHJlbWFya3NcbiAqIEFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjcmVkZW50aWFsLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGF1dGggY3JlZGVudGlhbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoQ3JlZGVudGlhbChcbiAgYXV0aDogQXV0aCxcbiAgY3JlZGVudGlhbDogQXV0aENyZWRlbnRpYWxcbik6IFByb21pc2U8VXNlckNyZWRlbnRpYWw+IHtcbiAgcmV0dXJuIF9zaWduSW5XaXRoQ3JlZGVudGlhbChfY2FzdEF1dGgoYXV0aCksIGNyZWRlbnRpYWwpO1xufVxuXG4vKipcbiAqIExpbmtzIHRoZSB1c2VyIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gY3JlZGVudGlhbHMuXG4gKlxuICogQHJlbWFya3NcbiAqIEFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjcmVkZW50aWFsLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIFRoZSBhdXRoIGNyZWRlbnRpYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbGlua1dpdGhDcmVkZW50aWFsKFxuICB1c2VyOiBVc2VyLFxuICBjcmVkZW50aWFsOiBBdXRoQ3JlZGVudGlhbFxuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbD4ge1xuICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsO1xuXG4gIGF3YWl0IF9hc3NlcnRMaW5rZWRTdGF0dXMoZmFsc2UsIHVzZXJJbnRlcm5hbCwgY3JlZGVudGlhbC5wcm92aWRlcklkKTtcblxuICByZXR1cm4gX2xpbmsodXNlckludGVybmFsLCBjcmVkZW50aWFsKTtcbn1cblxuLyoqXG4gKiBSZS1hdXRoZW50aWNhdGVzIGEgdXNlciB1c2luZyBhIGZyZXNoIGNyZWRlbnRpYWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFVzZSBiZWZvcmUgb3BlcmF0aW9ucyBzdWNoIGFzIHtAbGluayB1cGRhdGVQYXNzd29yZH0gdGhhdCByZXF1aXJlIHRva2VucyBmcm9tIHJlY2VudCBzaWduLWluXG4gKiBhdHRlbXB0cy4gVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gcmVjb3ZlciBmcm9tIGEgYENSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTmAgZXJyb3JcbiAqIG9yIGEgYFRPS0VOX0VYUElSRURgIGVycm9yLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIFRoZSBhdXRoIGNyZWRlbnRpYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbChcbiAgdXNlcjogVXNlcixcbiAgY3JlZGVudGlhbDogQXV0aENyZWRlbnRpYWxcbik6IFByb21pc2U8VXNlckNyZWRlbnRpYWw+IHtcbiAgcmV0dXJuIF9yZWF1dGhlbnRpY2F0ZShnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsLCBjcmVkZW50aWFsKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEVuZHBvaW50LFxuICBIdHRwTWV0aG9kLFxuICBfYWRkVGlkSWZOZWNlc3NhcnksXG4gIF9wZXJmb3JtU2lnbkluUmVxdWVzdFxufSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBTaWduSW5XaXRoQ3VzdG9tVG9rZW5SZXF1ZXN0IHtcbiAgdG9rZW46IHN0cmluZztcbiAgcmV0dXJuU2VjdXJlVG9rZW46IGJvb2xlYW47XG4gIHRlbmFudElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25JbldpdGhDdXN0b21Ub2tlblJlc3BvbnNlIGV4dGVuZHMgSWRUb2tlblJlc3BvbnNlIHt9XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoQ3VzdG9tVG9rZW4oXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFNpZ25JbldpdGhDdXN0b21Ub2tlblJlcXVlc3Rcbik6IFByb21pc2U8U2lnbkluV2l0aEN1c3RvbVRva2VuUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdDxcbiAgICBTaWduSW5XaXRoQ3VzdG9tVG9rZW5SZXF1ZXN0LFxuICAgIFNpZ25JbldpdGhDdXN0b21Ub2tlblJlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0NVU1RPTV9UT0tFTixcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEF1dGgsIFVzZXJDcmVkZW50aWFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHsgc2lnbkluV2l0aEN1c3RvbVRva2VuIGFzIGdldElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9jdXN0b21fdG9rZW4nO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbXBsIH0gZnJvbSAnLi4vdXNlci91c2VyX2NyZWRlbnRpYWxfaW1wbCc7XG5pbXBvcnQgeyBfY2FzdEF1dGggfSBmcm9tICcuLi9hdXRoL2F1dGhfaW1wbCc7XG5pbXBvcnQgeyBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHVzaW5nIGEgY3VzdG9tIHRva2VuLlxuICpcbiAqIEByZW1hcmtzXG4gKiBDdXN0b20gdG9rZW5zIGFyZSB1c2VkIHRvIGludGVncmF0ZSBGaXJlYmFzZSBBdXRoIHdpdGggZXhpc3RpbmcgYXV0aCBzeXN0ZW1zLCBhbmQgbXVzdFxuICogYmUgZ2VuZXJhdGVkIGJ5IGFuIGF1dGggYmFja2VuZCB1c2luZyB0aGVcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9yZWZlcmVuY2UvYWRtaW4vbm9kZS9hZG1pbi5hdXRoLkF1dGgjY3JlYXRlY3VzdG9tdG9rZW4gfCBjcmVhdGVDdXN0b21Ub2tlbn1cbiAqIG1ldGhvZCBpbiB0aGUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2F1dGgvYWRtaW4gfCBBZG1pbiBTREt9IC5cbiAqXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSB0b2tlbiBpcyBpbnZhbGlkLCBleHBpcmVkLCBvciBub3QgYWNjZXB0ZWQgYnkgdGhlIEZpcmViYXNlIEF1dGggc2VydmljZS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gY3VzdG9tVG9rZW4gLSBUaGUgY3VzdG9tIHRva2VuIHRvIHNpZ24gaW4gd2l0aC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoQ3VzdG9tVG9rZW4oXG4gIGF1dGg6IEF1dGgsXG4gIGN1c3RvbVRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8VXNlckNyZWRlbnRpYWw+IHtcbiAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICBjb25zdCByZXNwb25zZTogSWRUb2tlblJlc3BvbnNlID0gYXdhaXQgZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGhJbnRlcm5hbCwge1xuICAgIHRva2VuOiBjdXN0b21Ub2tlbixcbiAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxuICB9KTtcbiAgY29uc3QgY3JlZCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShcbiAgICBhdXRoSW50ZXJuYWwsXG4gICAgT3BlcmF0aW9uVHlwZS5TSUdOX0lOLFxuICAgIHJlc3BvbnNlXG4gICk7XG4gIGF3YWl0IGF1dGhJbnRlcm5hbC5fdXBkYXRlQ3VycmVudFVzZXIoY3JlZC51c2VyKTtcbiAgcmV0dXJuIGNyZWQ7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBGYWN0b3JJZCxcbiAgTXVsdGlGYWN0b3JJbmZvLFxuICBQaG9uZU11bHRpRmFjdG9ySW5mbyxcbiAgVG90cE11bHRpRmFjdG9ySW5mb1xufSBmcm9tICcuLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHtcbiAgUGhvbmVNZmFFbnJvbGxtZW50LFxuICBNZmFFbnJvbGxtZW50LFxuICBUb3RwTWZhRW5yb2xsbWVudFxufSBmcm9tICcuLi9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L21mYSc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgX2ZhaWwgfSBmcm9tICcuLi9jb3JlL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uL21vZGVsL2F1dGgnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTXVsdGlGYWN0b3JJbmZvSW1wbCBpbXBsZW1lbnRzIE11bHRpRmFjdG9ySW5mbyB7XG4gIHJlYWRvbmx5IHVpZDogc3RyaW5nO1xuICByZWFkb25seSBkaXNwbGF5TmFtZT86IHN0cmluZyB8IG51bGw7XG4gIHJlYWRvbmx5IGVucm9sbG1lbnRUaW1lOiBzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGZhY3RvcklkOiBGYWN0b3JJZCwgcmVzcG9uc2U6IE1mYUVucm9sbG1lbnQpIHtcbiAgICB0aGlzLnVpZCA9IHJlc3BvbnNlLm1mYUVucm9sbG1lbnRJZDtcbiAgICB0aGlzLmVucm9sbG1lbnRUaW1lID0gbmV3IERhdGUocmVzcG9uc2UuZW5yb2xsZWRBdCkudG9VVENTdHJpbmcoKTtcbiAgICB0aGlzLmRpc3BsYXlOYW1lID0gcmVzcG9uc2UuZGlzcGxheU5hbWU7XG4gIH1cblxuICBzdGF0aWMgX2Zyb21TZXJ2ZXJSZXNwb25zZShcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgZW5yb2xsbWVudDogTWZhRW5yb2xsbWVudFxuICApOiBNdWx0aUZhY3RvckluZm9JbXBsIHtcbiAgICBpZiAoJ3Bob25lSW5mbycgaW4gZW5yb2xsbWVudCkge1xuICAgICAgcmV0dXJuIFBob25lTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKGF1dGgsIGVucm9sbG1lbnQpO1xuICAgIH0gZWxzZSBpZiAoJ3RvdHBJbmZvJyBpbiBlbnJvbGxtZW50KSB7XG4gICAgICByZXR1cm4gVG90cE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShhdXRoLCBlbnJvbGxtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIF9mYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGxcbiAgZXh0ZW5kcyBNdWx0aUZhY3RvckluZm9JbXBsXG4gIGltcGxlbWVudHMgUGhvbmVNdWx0aUZhY3RvckluZm9cbntcbiAgcmVhZG9ubHkgcGhvbmVOdW1iZXI6IHN0cmluZztcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKHJlc3BvbnNlOiBQaG9uZU1mYUVucm9sbG1lbnQpIHtcbiAgICBzdXBlcihGYWN0b3JJZC5QSE9ORSwgcmVzcG9uc2UpO1xuICAgIHRoaXMucGhvbmVOdW1iZXIgPSByZXNwb25zZS5waG9uZUluZm87XG4gIH1cblxuICBzdGF0aWMgX2Zyb21TZXJ2ZXJSZXNwb25zZShcbiAgICBfYXV0aDogQXV0aEludGVybmFsLFxuICAgIGVucm9sbG1lbnQ6IE1mYUVucm9sbG1lbnRcbiAgKTogUGhvbmVNdWx0aUZhY3RvckluZm9JbXBsIHtcbiAgICByZXR1cm4gbmV3IFBob25lTXVsdGlGYWN0b3JJbmZvSW1wbChlbnJvbGxtZW50IGFzIFBob25lTWZhRW5yb2xsbWVudCk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBUb3RwTXVsdGlGYWN0b3JJbmZvSW1wbFxuICBleHRlbmRzIE11bHRpRmFjdG9ySW5mb0ltcGxcbiAgaW1wbGVtZW50cyBUb3RwTXVsdGlGYWN0b3JJbmZvXG57XG4gIHByaXZhdGUgY29uc3RydWN0b3IocmVzcG9uc2U6IFRvdHBNZmFFbnJvbGxtZW50KSB7XG4gICAgc3VwZXIoRmFjdG9ySWQuVE9UUCwgcmVzcG9uc2UpO1xuICB9XG5cbiAgc3RhdGljIF9mcm9tU2VydmVyUmVzcG9uc2UoXG4gICAgX2F1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBlbnJvbGxtZW50OiBNZmFFbnJvbGxtZW50XG4gICk6IFRvdHBNdWx0aUZhY3RvckluZm9JbXBsIHtcbiAgICByZXR1cm4gbmV3IFRvdHBNdWx0aUZhY3RvckluZm9JbXBsKGVucm9sbG1lbnQgYXMgVG90cE1mYUVucm9sbG1lbnQpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBY3Rpb25Db2RlU2V0dGluZ3MsIEF1dGggfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBHZXRPb2JDb2RlUmVxdWVzdCB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9lbWFpbF9hbmRfcGFzc3dvcmQnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuXG5leHBvcnQgZnVuY3Rpb24gX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogR2V0T29iQ29kZVJlcXVlc3QsXG4gIGFjdGlvbkNvZGVTZXR0aW5nczogQWN0aW9uQ29kZVNldHRpbmdzXG4pOiB2b2lkIHtcbiAgX2Fzc2VydChcbiAgICBhY3Rpb25Db2RlU2V0dGluZ3MudXJsPy5sZW5ndGggPiAwLFxuICAgIGF1dGgsXG4gICAgQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPTlRJTlVFX1VSSVxuICApO1xuICBfYXNzZXJ0KFxuICAgIHR5cGVvZiBhY3Rpb25Db2RlU2V0dGluZ3MuZHluYW1pY0xpbmtEb21haW4gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICBhY3Rpb25Db2RlU2V0dGluZ3MuZHluYW1pY0xpbmtEb21haW4ubGVuZ3RoID4gMCxcbiAgICBhdXRoLFxuICAgIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9EWU5BTUlDX0xJTktfRE9NQUlOXG4gICk7XG5cbiAgcmVxdWVzdC5jb250aW51ZVVybCA9IGFjdGlvbkNvZGVTZXR0aW5ncy51cmw7XG4gIHJlcXVlc3QuZHluYW1pY0xpbmtEb21haW4gPSBhY3Rpb25Db2RlU2V0dGluZ3MuZHluYW1pY0xpbmtEb21haW47XG4gIHJlcXVlc3QuY2FuSGFuZGxlQ29kZUluQXBwID0gYWN0aW9uQ29kZVNldHRpbmdzLmhhbmRsZUNvZGVJbkFwcDtcblxuICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzLmlPUykge1xuICAgIF9hc3NlcnQoXG4gICAgICBhY3Rpb25Db2RlU2V0dGluZ3MuaU9TLmJ1bmRsZUlkLmxlbmd0aCA+IDAsXG4gICAgICBhdXRoLFxuICAgICAgQXV0aEVycm9yQ29kZS5NSVNTSU5HX0lPU19CVU5ETEVfSURcbiAgICApO1xuICAgIHJlcXVlc3QuaU9TQnVuZGxlSWQgPSBhY3Rpb25Db2RlU2V0dGluZ3MuaU9TLmJ1bmRsZUlkO1xuICB9XG5cbiAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkKSB7XG4gICAgX2Fzc2VydChcbiAgICAgIGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkLnBhY2thZ2VOYW1lLmxlbmd0aCA+IDAsXG4gICAgICBhdXRoLFxuICAgICAgQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FXG4gICAgKTtcbiAgICByZXF1ZXN0LmFuZHJvaWRJbnN0YWxsQXBwID0gYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQuaW5zdGFsbEFwcDtcbiAgICByZXF1ZXN0LmFuZHJvaWRNaW5pbXVtVmVyc2lvbkNvZGUgPVxuICAgICAgYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQubWluaW11bVZlcnNpb247XG4gICAgcmVxdWVzdC5hbmRyb2lkUGFja2FnZU5hbWUgPSBhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5wYWNrYWdlTmFtZTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgQWN0aW9uQ29kZUluZm8sXG4gIEFjdGlvbkNvZGVPcGVyYXRpb24sXG4gIEFjdGlvbkNvZGVTZXR0aW5ncyxcbiAgQXV0aCxcbiAgVXNlckNyZWRlbnRpYWxcbn0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0ICogYXMgYWNjb3VudCBmcm9tICcuLi8uLi9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L2VtYWlsX2FuZF9wYXNzd29yZCc7XG5pbXBvcnQgKiBhcyBhdXRoZW50aWNhdGlvbiBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vZW1haWxfYW5kX3Bhc3N3b3JkJztcbmltcG9ydCB7IHNpZ25VcCwgU2lnblVwUmVxdWVzdCB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9zaWduX3VwJztcbmltcG9ydCB7IE11bHRpRmFjdG9ySW5mb0ltcGwgfSBmcm9tICcuLi8uLi9tZmEvbWZhX2luZm8nO1xuaW1wb3J0IHsgRW1haWxBdXRoUHJvdmlkZXIgfSBmcm9tICcuLi9wcm92aWRlcnMvZW1haWwnO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbXBsIH0gZnJvbSAnLi4vdXNlci91c2VyX2NyZWRlbnRpYWxfaW1wbCc7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdCB9IGZyb20gJy4vYWN0aW9uX2NvZGVfc2V0dGluZ3MnO1xuaW1wb3J0IHsgc2lnbkluV2l0aENyZWRlbnRpYWwgfSBmcm9tICcuL2NyZWRlbnRpYWwnO1xuaW1wb3J0IHsgX2Nhc3RBdXRoIH0gZnJvbSAnLi4vYXV0aC9hdXRoX2ltcGwnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXRNb2R1bGFySW5zdGFuY2UgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuaW1wb3J0IHsgaW5qZWN0UmVjYXB0Y2hhRmllbGRzIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm1fYnJvd3Nlci9yZWNhcHRjaGEvcmVjYXB0Y2hhX2VudGVycHJpc2VfdmVyaWZpZXInO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgUmVjYXB0Y2hhQWN0aW9uTmFtZSwgUmVjYXB0Y2hhQ2xpZW50VHlwZSB9IGZyb20gJy4uLy4uL2FwaSc7XG5cbi8qKlxuICogU2VuZHMgYSBwYXNzd29yZCByZXNldCBlbWFpbCB0byB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVG8gY29tcGxldGUgdGhlIHBhc3N3b3JkIHJlc2V0LCBjYWxsIHtAbGluayBjb25maXJtUGFzc3dvcmRSZXNldH0gd2l0aCB0aGUgY29kZSBzdXBwbGllZCBpblxuICogdGhlIGVtYWlsIHNlbnQgdG8gdGhlIHVzZXIsIGFsb25nIHdpdGggdGhlIG5ldyBwYXNzd29yZCBzcGVjaWZpZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcbiAqICAgdXJsOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vP2VtYWlsPXVzZXJAZXhhbXBsZS5jb20nLFxuICogICBpT1M6IHtcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXG4gKiAgIH0sXG4gKiAgIGFuZHJvaWQ6IHtcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxuICogICAgIGluc3RhbGxBcHA6IHRydWUsXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcbiAqICAgfSxcbiAqICAgaGFuZGxlQ29kZUluQXBwOiB0cnVlXG4gKiB9O1xuICogYXdhaXQgc2VuZFBhc3N3b3JkUmVzZXRFbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gY29kZSBmcm9tIHVzZXIuXG4gKiBhd2FpdCBjb25maXJtUGFzc3dvcmRSZXNldCgndXNlckBleGFtcGxlLmNvbScsIGNvZGUpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKFxuICBhdXRoOiBBdXRoLFxuICBlbWFpbDogc3RyaW5nLFxuICBhY3Rpb25Db2RlU2V0dGluZ3M/OiBBY3Rpb25Db2RlU2V0dGluZ3Ncbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gIGNvbnN0IHJlcXVlc3Q6IGF1dGhlbnRpY2F0aW9uLlBhc3N3b3JkUmVzZXRSZXF1ZXN0ID0ge1xuICAgIHJlcXVlc3RUeXBlOiBBY3Rpb25Db2RlT3BlcmF0aW9uLlBBU1NXT1JEX1JFU0VULFxuICAgIGVtYWlsLFxuICAgIGNsaWVudFR5cGU6IFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCXG4gIH07XG4gIGlmIChhdXRoSW50ZXJuYWwuX2dldFJlY2FwdGNoYUNvbmZpZygpPy5lbWFpbFBhc3N3b3JkRW5hYmxlZCkge1xuICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKFxuICAgICAgYXV0aEludGVybmFsLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChcbiAgICAgICAgYXV0aEludGVybmFsLFxuICAgICAgICByZXF1ZXN0V2l0aFJlY2FwdGNoYSxcbiAgICAgICAgYWN0aW9uQ29kZVNldHRpbmdzXG4gICAgICApO1xuICAgIH1cbiAgICBhd2FpdCBhdXRoZW50aWNhdGlvbi5zZW5kUGFzc3dvcmRSZXNldEVtYWlsKFxuICAgICAgYXV0aEludGVybmFsLFxuICAgICAgcmVxdWVzdFdpdGhSZWNhcHRjaGFcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QoXG4gICAgICAgIGF1dGhJbnRlcm5hbCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgYWN0aW9uQ29kZVNldHRpbmdzXG4gICAgICApO1xuICAgIH1cbiAgICBhd2FpdCBhdXRoZW50aWNhdGlvblxuICAgICAgLnNlbmRQYXNzd29yZFJlc2V0RW1haWwoYXV0aEludGVybmFsLCByZXF1ZXN0KVxuICAgICAgLmNhdGNoKGFzeW5jIGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGBhdXRoLyR7QXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTn1gKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAnUGFzc3dvcmQgcmVzZXRzIGFyZSBwcm90ZWN0ZWQgYnkgcmVDQVBUQ0hBIGZvciB0aGlzIHByb2plY3QuIEF1dG9tYXRpY2FsbHkgdHJpZ2dlcmluZyB0aGUgcmVDQVBUQ0hBIGZsb3cgYW5kIHJlc3RhcnRpbmcgdGhlIHBhc3N3b3JkIHJlc2V0IGZsb3cuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoXG4gICAgICAgICAgICBhdXRoSW50ZXJuYWwsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgICAgICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KFxuICAgICAgICAgICAgICBhdXRoSW50ZXJuYWwsXG4gICAgICAgICAgICAgIHJlcXVlc3RXaXRoUmVjYXB0Y2hhLFxuICAgICAgICAgICAgICBhY3Rpb25Db2RlU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IGF1dGhlbnRpY2F0aW9uLnNlbmRQYXNzd29yZFJlc2V0RW1haWwoXG4gICAgICAgICAgICBhdXRoSW50ZXJuYWwsXG4gICAgICAgICAgICByZXF1ZXN0V2l0aFJlY2FwdGNoYVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wbGV0ZXMgdGhlIHBhc3N3b3JkIHJlc2V0IHByb2Nlc3MsIGdpdmVuIGEgY29uZmlybWF0aW9uIGNvZGUgYW5kIG5ldyBwYXNzd29yZC5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gb29iQ29kZSAtIEEgY29uZmlybWF0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cbiAqIEBwYXJhbSBuZXdQYXNzd29yZCAtIFRoZSBuZXcgcGFzc3dvcmQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29uZmlybVBhc3N3b3JkUmVzZXQoXG4gIGF1dGg6IEF1dGgsXG4gIG9vYkNvZGU6IHN0cmluZyxcbiAgbmV3UGFzc3dvcmQ6IHN0cmluZ1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IGFjY291bnQucmVzZXRQYXNzd29yZChnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIHtcbiAgICBvb2JDb2RlLFxuICAgIG5ld1Bhc3N3b3JkXG4gIH0pO1xuICAvLyBEbyBub3QgcmV0dXJuIHRoZSBlbWFpbC5cbn1cblxuLyoqXG4gKiBBcHBsaWVzIGEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlciBieSBlbWFpbCBvciBvdGhlciBvdXQtb2YtYmFuZCBtZWNoYW5pc20uXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIG9vYkNvZGUgLSBBIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXBwbHlBY3Rpb25Db2RlKFxuICBhdXRoOiBBdXRoLFxuICBvb2JDb2RlOiBzdHJpbmdcbik6IFByb21pc2U8dm9pZD4ge1xuICBhd2FpdCBhY2NvdW50LmFwcGx5QWN0aW9uQ29kZShnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIHsgb29iQ29kZSB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cbiAqXG4gKiBAcmV0dXJucyBtZXRhZGF0YSBhYm91dCB0aGUgY29kZS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gb29iQ29kZSAtIEEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja0FjdGlvbkNvZGUoXG4gIGF1dGg6IEF1dGgsXG4gIG9vYkNvZGU6IHN0cmluZ1xuKTogUHJvbWlzZTxBY3Rpb25Db2RlSW5mbz4ge1xuICBjb25zdCBhdXRoTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhY2NvdW50LnJlc2V0UGFzc3dvcmQoYXV0aE1vZHVsYXIsIHsgb29iQ29kZSB9KTtcblxuICAvLyBFbWFpbCBjb3VsZCBiZSBlbXB0eSBvbmx5IGlmIHRoZSByZXF1ZXN0IHR5cGUgaXMgRU1BSUxfU0lHTklOIG9yXG4gIC8vIFZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMLlxuICAvLyBOZXcgZW1haWwgc2hvdWxkIG5vdCBiZSBlbXB0eSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzXG4gIC8vIFZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMLlxuICAvLyBNdWx0aS1mYWN0b3IgaW5mbyBjb3VsZCBub3QgYmUgZW1wdHkgaWYgdGhlIHJlcXVlc3QgdHlwZSBpc1xuICAvLyBSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTi5cbiAgY29uc3Qgb3BlcmF0aW9uID0gcmVzcG9uc2UucmVxdWVzdFR5cGU7XG4gIF9hc3NlcnQob3BlcmF0aW9uLCBhdXRoTW9kdWxhciwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgY2FzZSBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTDpcbiAgICAgIF9hc3NlcnQocmVzcG9uc2UubmV3RW1haWwsIGF1dGhNb2R1bGFyLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQWN0aW9uQ29kZU9wZXJhdGlvbi5SRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTjpcbiAgICAgIF9hc3NlcnQocmVzcG9uc2UubWZhSW5mbywgYXV0aE1vZHVsYXIsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgIGRlZmF1bHQ6XG4gICAgICBfYXNzZXJ0KHJlc3BvbnNlLmVtYWlsLCBhdXRoTW9kdWxhciwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gIH1cblxuICAvLyBUaGUgbXVsdGktZmFjdG9yIGluZm8gZm9yIHJldmVydCBzZWNvbmQgZmFjdG9yIGFkZGl0aW9uXG4gIGxldCBtdWx0aUZhY3RvckluZm86IE11bHRpRmFjdG9ySW5mb0ltcGwgfCBudWxsID0gbnVsbDtcbiAgaWYgKHJlc3BvbnNlLm1mYUluZm8pIHtcbiAgICBtdWx0aUZhY3RvckluZm8gPSBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UoXG4gICAgICBfY2FzdEF1dGgoYXV0aE1vZHVsYXIpLFxuICAgICAgcmVzcG9uc2UubWZhSW5mb1xuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRhdGE6IHtcbiAgICAgIGVtYWlsOlxuICAgICAgICAocmVzcG9uc2UucmVxdWVzdFR5cGUgPT09IEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcbiAgICAgICAgICA/IHJlc3BvbnNlLm5ld0VtYWlsXG4gICAgICAgICAgOiByZXNwb25zZS5lbWFpbCkgfHwgbnVsbCxcbiAgICAgIHByZXZpb3VzRW1haWw6XG4gICAgICAgIChyZXNwb25zZS5yZXF1ZXN0VHlwZSA9PT0gQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTFxuICAgICAgICAgID8gcmVzcG9uc2UuZW1haWxcbiAgICAgICAgICA6IHJlc3BvbnNlLm5ld0VtYWlsKSB8fCBudWxsLFxuICAgICAgbXVsdGlGYWN0b3JJbmZvXG4gICAgfSxcbiAgICBvcGVyYXRpb25cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBwYXNzd29yZCByZXNldCBjb2RlIHNlbnQgdG8gdGhlIHVzZXIgYnkgZW1haWwgb3Igb3RoZXIgb3V0LW9mLWJhbmQgbWVjaGFuaXNtLlxuICpcbiAqIEByZXR1cm5zIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcyBpZiB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gY29kZSAtIEEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZShcbiAgYXV0aDogQXV0aCxcbiAgY29kZTogc3RyaW5nXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGNoZWNrQWN0aW9uQ29kZShnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIGNvZGUpO1xuICAvLyBFbWFpbCBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgc2luY2UgYSBjb2RlIHdhcyBzZW50IHRvIGl0XG4gIHJldHVybiBkYXRhLmVtYWlsITtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHVzZXIgYWNjb3VudCBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBlbWFpbCBhZGRyZXNzIGFuZCBwYXNzd29yZC5cbiAqXG4gKiBAcmVtYXJrc1xuICogT24gc3VjY2Vzc2Z1bCBjcmVhdGlvbiBvZiB0aGUgdXNlciBhY2NvdW50LCB0aGlzIHVzZXIgd2lsbCBhbHNvIGJlIHNpZ25lZCBpbiB0byB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqIFVzZXIgYWNjb3VudCBjcmVhdGlvbiBjYW4gZmFpbCBpZiB0aGUgYWNjb3VudCBhbHJlYWR5IGV4aXN0cyBvciB0aGUgcGFzc3dvcmQgaXMgaW52YWxpZC5cbiAqXG4gKiBOb3RlOiBUaGUgZW1haWwgYWRkcmVzcyBhY3RzIGFzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB1c2VyIGFuZCBlbmFibGVzIGFuIGVtYWlsLWJhc2VkXG4gKiBwYXNzd29yZCByZXNldC4gVGhpcyBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIG5ldyB1c2VyIGFjY291bnQgYW5kIHNldCB0aGUgaW5pdGlhbCB1c2VyIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSB1c2VyJ3MgY2hvc2VuIHBhc3N3b3JkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZChcbiAgYXV0aDogQXV0aCxcbiAgZW1haWw6IHN0cmluZyxcbiAgcGFzc3dvcmQ6IHN0cmluZ1xuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbD4ge1xuICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gIGNvbnN0IHJlcXVlc3Q6IFNpZ25VcFJlcXVlc3QgPSB7XG4gICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXG4gICAgZW1haWwsXG4gICAgcGFzc3dvcmQsXG4gICAgY2xpZW50VHlwZTogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUJcbiAgfTtcbiAgbGV0IHNpZ25VcFJlc3BvbnNlOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT47XG4gIGlmIChhdXRoSW50ZXJuYWwuX2dldFJlY2FwdGNoYUNvbmZpZygpPy5lbWFpbFBhc3N3b3JkRW5hYmxlZCkge1xuICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKFxuICAgICAgYXV0aEludGVybmFsLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9VUF9QQVNTV09SRFxuICAgICk7XG4gICAgc2lnblVwUmVzcG9uc2UgPSBzaWduVXAoYXV0aEludGVybmFsLCByZXF1ZXN0V2l0aFJlY2FwdGNoYSk7XG4gIH0gZWxzZSB7XG4gICAgc2lnblVwUmVzcG9uc2UgPSBzaWduVXAoYXV0aEludGVybmFsLCByZXF1ZXN0KS5jYXRjaChhc3luYyBlcnJvciA9PiB7XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOfWApIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgJ1NpZ24tdXAgaXMgcHJvdGVjdGVkIGJ5IHJlQ0FQVENIQSBmb3IgdGhpcyBwcm9qZWN0LiBBdXRvbWF0aWNhbGx5IHRyaWdnZXJpbmcgdGhlIHJlQ0FQVENIQSBmbG93IGFuZCByZXN0YXJ0aW5nIHRoZSBzaWduLXVwIGZsb3cuJ1xuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhcbiAgICAgICAgICBhdXRoSW50ZXJuYWwsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBSZWNhcHRjaGFBY3Rpb25OYW1lLlNJR05fVVBfUEFTU1dPUkRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHNpZ25VcChhdXRoSW50ZXJuYWwsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25VcFJlc3BvbnNlLmNhdGNoKGVycm9yID0+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9KTtcblxuICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShcbiAgICBhdXRoSW50ZXJuYWwsXG4gICAgT3BlcmF0aW9uVHlwZS5TSUdOX0lOLFxuICAgIHJlc3BvbnNlXG4gICk7XG4gIGF3YWl0IGF1dGhJbnRlcm5hbC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XG5cbiAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHVzaW5nIGFuIGVtYWlsIGFuZCBwYXNzd29yZC5cbiAqXG4gKiBAcmVtYXJrc1xuICogRmFpbHMgd2l0aCBhbiBlcnJvciBpZiB0aGUgZW1haWwgYWRkcmVzcyBhbmQgcGFzc3dvcmQgZG8gbm90IG1hdGNoLlxuICpcbiAqIE5vdGU6IFRoZSB1c2VyJ3MgcGFzc3dvcmQgaXMgTk9UIHRoZSBwYXNzd29yZCB1c2VkIHRvIGFjY2VzcyB0aGUgdXNlcidzIGVtYWlsIGFjY291bnQuIFRoZVxuICogZW1haWwgYWRkcmVzcyBzZXJ2ZXMgYXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHVzZXIsIGFuZCB0aGUgcGFzc3dvcmQgaXMgdXNlZCB0byBhY2Nlc3NcbiAqIHRoZSB1c2VyJ3MgYWNjb3VudCBpbiB5b3VyIEZpcmViYXNlIHByb2plY3QuIFNlZSBhbHNvOiB7QGxpbmsgY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcnMgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSB1c2VycyBwYXNzd29yZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChcbiAgYXV0aDogQXV0aCxcbiAgZW1haWw6IHN0cmluZyxcbiAgcGFzc3dvcmQ6IHN0cmluZ1xuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbD4ge1xuICByZXR1cm4gc2lnbkluV2l0aENyZWRlbnRpYWwoXG4gICAgZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLFxuICAgIEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkKVxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgQWN0aW9uQ29kZU9wZXJhdGlvbixcbiAgQWN0aW9uQ29kZVNldHRpbmdzLFxuICBBdXRoLFxuICBVc2VyQ3JlZGVudGlhbFxufSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgKiBhcyBhcGkgZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL2VtYWlsX2FuZF9wYXNzd29yZCc7XG5pbXBvcnQgeyBBY3Rpb25Db2RlVVJMIH0gZnJvbSAnLi4vYWN0aW9uX2NvZGVfdXJsJztcbmltcG9ydCB7IEVtYWlsQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2VtYWlsJztcbmltcG9ydCB7IF9nZXRDdXJyZW50VXJsIH0gZnJvbSAnLi4vdXRpbC9sb2NhdGlvbic7XG5pbXBvcnQgeyBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0IH0gZnJvbSAnLi9hY3Rpb25fY29kZV9zZXR0aW5ncyc7XG5pbXBvcnQgeyBzaWduSW5XaXRoQ3JlZGVudGlhbCB9IGZyb20gJy4vY3JlZGVudGlhbCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBnZXRNb2R1bGFySW5zdGFuY2UgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBfY2FzdEF1dGggfSBmcm9tICcuLi9hdXRoL2F1dGhfaW1wbCc7XG5pbXBvcnQgeyBpbmplY3RSZWNhcHRjaGFGaWVsZHMgfSBmcm9tICcuLi8uLi9wbGF0Zm9ybV9icm93c2VyL3JlY2FwdGNoYS9yZWNhcHRjaGFfZW50ZXJwcmlzZV92ZXJpZmllcic7XG5pbXBvcnQgeyBSZWNhcHRjaGFBY3Rpb25OYW1lLCBSZWNhcHRjaGFDbGllbnRUeXBlIH0gZnJvbSAnLi4vLi4vYXBpJztcblxuLyoqXG4gKiBTZW5kcyBhIHNpZ24taW4gZW1haWwgbGluayB0byB0aGUgdXNlciB3aXRoIHRoZSBzcGVjaWZpZWQgZW1haWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBzaWduLWluIG9wZXJhdGlvbiBoYXMgdG8gYWx3YXlzIGJlIGNvbXBsZXRlZCBpbiB0aGUgYXBwIHVubGlrZSBvdGhlciBvdXQgb2YgYmFuZCBlbWFpbFxuICogYWN0aW9ucyAocGFzc3dvcmQgcmVzZXQgYW5kIGVtYWlsIHZlcmlmaWNhdGlvbnMpLiBUaGlzIGlzIGJlY2F1c2UsIGF0IHRoZSBlbmQgb2YgdGhlIGZsb3csXG4gKiB0aGUgdXNlciBpcyBleHBlY3RlZCB0byBiZSBzaWduZWQgaW4gYW5kIHRoZWlyIEF1dGggc3RhdGUgcGVyc2lzdGVkIHdpdGhpbiB0aGUgYXBwLlxuICpcbiAqIFRvIGNvbXBsZXRlIHNpZ24gaW4gd2l0aCB0aGUgZW1haWwgbGluaywgY2FsbCB7QGxpbmsgc2lnbkluV2l0aEVtYWlsTGlua30gd2l0aCB0aGUgZW1haWxcbiAqIGFkZHJlc3MgYW5kIHRoZSBlbWFpbCBsaW5rIHN1cHBsaWVkIGluIHRoZSBlbWFpbCBzZW50IHRvIHRoZSB1c2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdGhlIHVzZXIuXG4gKiBpZihpc1NpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWxMaW5rKSkge1xuICogICBhd2FpdCBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgZW1haWxMaW5rKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoSW50ZXJuYWwgLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kU2lnbkluTGlua1RvRW1haWwoXG4gIGF1dGg6IEF1dGgsXG4gIGVtYWlsOiBzdHJpbmcsXG4gIGFjdGlvbkNvZGVTZXR0aW5nczogQWN0aW9uQ29kZVNldHRpbmdzXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICBjb25zdCByZXF1ZXN0OiBhcGkuRW1haWxTaWduSW5SZXF1ZXN0ID0ge1xuICAgIHJlcXVlc3RUeXBlOiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTixcbiAgICBlbWFpbCxcbiAgICBjbGllbnRUeXBlOiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQlxuICB9O1xuICBmdW5jdGlvbiBzZXRBY3Rpb25Db2RlU2V0dGluZ3MoXG4gICAgcmVxdWVzdDogYXBpLkVtYWlsU2lnbkluUmVxdWVzdCxcbiAgICBhY3Rpb25Db2RlU2V0dGluZ3M6IEFjdGlvbkNvZGVTZXR0aW5nc1xuICApOiB2b2lkIHtcbiAgICBfYXNzZXJ0KFxuICAgICAgYWN0aW9uQ29kZVNldHRpbmdzLmhhbmRsZUNvZGVJbkFwcCxcbiAgICAgIGF1dGhJbnRlcm5hbCxcbiAgICAgIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1JcbiAgICApO1xuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QoXG4gICAgICAgIGF1dGhJbnRlcm5hbCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgYWN0aW9uQ29kZVNldHRpbmdzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoYXV0aEludGVybmFsLl9nZXRSZWNhcHRjaGFDb25maWcoKT8uZW1haWxQYXNzd29yZEVuYWJsZWQpIHtcbiAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhcbiAgICAgIGF1dGhJbnRlcm5hbCxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBSZWNhcHRjaGFBY3Rpb25OYW1lLkdFVF9PT0JfQ09ERSxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHNldEFjdGlvbkNvZGVTZXR0aW5ncyhyZXF1ZXN0V2l0aFJlY2FwdGNoYSwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAgICBhd2FpdCBhcGkuc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGhJbnRlcm5hbCwgcmVxdWVzdFdpdGhSZWNhcHRjaGEpO1xuICB9IGVsc2Uge1xuICAgIHNldEFjdGlvbkNvZGVTZXR0aW5ncyhyZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICAgIGF3YWl0IGFwaVxuICAgICAgLnNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoSW50ZXJuYWwsIHJlcXVlc3QpXG4gICAgICAuY2F0Y2goYXN5bmMgZXJyb3IgPT4ge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOfWApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICdFbWFpbCBsaW5rIHNpZ24taW4gaXMgcHJvdGVjdGVkIGJ5IHJlQ0FQVENIQSBmb3IgdGhpcyBwcm9qZWN0LiBBdXRvbWF0aWNhbGx5IHRyaWdnZXJpbmcgdGhlIHJlQ0FQVENIQSBmbG93IGFuZCByZXN0YXJ0aW5nIHRoZSBzaWduLWluIGZsb3cuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoXG4gICAgICAgICAgICBhdXRoSW50ZXJuYWwsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRBY3Rpb25Db2RlU2V0dGluZ3MocmVxdWVzdFdpdGhSZWNhcHRjaGEsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gICAgICAgICAgYXdhaXQgYXBpLnNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoSW50ZXJuYWwsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBpbmNvbWluZyBsaW5rIGlzIGEgc2lnbi1pbiB3aXRoIGVtYWlsIGxpbmsgc3VpdGFibGUgZm9yIHtAbGluayBzaWduSW5XaXRoRW1haWxMaW5rfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWxMaW5rIC0gVGhlIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTaWduSW5XaXRoRW1haWxMaW5rKGF1dGg6IEF1dGgsIGVtYWlsTGluazogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGFjdGlvbkNvZGVVcmwgPSBBY3Rpb25Db2RlVVJMLnBhcnNlTGluayhlbWFpbExpbmspO1xuICByZXR1cm4gYWN0aW9uQ29kZVVybD8ub3BlcmF0aW9uID09PSBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTjtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBzaWducyBpbiB1c2luZyBhbiBlbWFpbCBhbmQgc2lnbi1pbiBlbWFpbCBsaW5rLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiBubyBsaW5rIGlzIHBhc3NlZCwgdGhlIGxpbmsgaXMgaW5mZXJyZWQgZnJvbSB0aGUgY3VycmVudCBVUkwuXG4gKlxuICogRmFpbHMgd2l0aCBhbiBlcnJvciBpZiB0aGUgZW1haWwgYWRkcmVzcyBpcyBpbnZhbGlkIG9yIE9UUCBpbiBlbWFpbCBsaW5rIGV4cGlyZXMuXG4gKlxuICogTm90ZTogQ29uZmlybSB0aGUgbGluayBpcyBhIHNpZ24taW4gZW1haWwgbGluayBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZCBmaXJlYmFzZS5hdXRoLkF1dGguaXNTaWduSW5XaXRoRW1haWxMaW5rLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdGhlIHVzZXIuXG4gKiBpZihpc1NpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWxMaW5rKSkge1xuICogICBhd2FpdCBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgZW1haWxMaW5rKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSBlbWFpbExpbmsgLSBUaGUgbGluayBzZW50IHRvIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoRW1haWxMaW5rKFxuICBhdXRoOiBBdXRoLFxuICBlbWFpbDogc3RyaW5nLFxuICBlbWFpbExpbms/OiBzdHJpbmdcbik6IFByb21pc2U8VXNlckNyZWRlbnRpYWw+IHtcbiAgY29uc3QgYXV0aE1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XG4gIGNvbnN0IGNyZWRlbnRpYWwgPSBFbWFpbEF1dGhQcm92aWRlci5jcmVkZW50aWFsV2l0aExpbmsoXG4gICAgZW1haWwsXG4gICAgZW1haWxMaW5rIHx8IF9nZXRDdXJyZW50VXJsKClcbiAgKTtcbiAgLy8gQ2hlY2sgaWYgdGhlIHRlbmFudCBJRCBpbiB0aGUgZW1haWwgbGluayBtYXRjaGVzIHRoZSB0ZW5hbnQgSUQgb24gQXV0aFxuICAvLyBpbnN0YW5jZS5cbiAgX2Fzc2VydChcbiAgICBjcmVkZW50aWFsLl90ZW5hbnRJZCA9PT0gKGF1dGhNb2R1bGFyLnRlbmFudElkIHx8IG51bGwpLFxuICAgIGF1dGhNb2R1bGFyLFxuICAgIEF1dGhFcnJvckNvZGUuVEVOQU5UX0lEX01JU01BVENIXG4gICk7XG4gIHJldHVybiBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoTW9kdWxhciwgY3JlZGVudGlhbCk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBFbmRwb2ludCxcbiAgSHR0cE1ldGhvZCxcbiAgX2FkZFRpZElmTmVjZXNzYXJ5LFxuICBfcGVyZm9ybUFwaVJlcXVlc3Rcbn0gZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQXV0aFVyaVJlcXVlc3Qge1xuICBpZGVudGlmaWVyOiBzdHJpbmc7XG4gIGNvbnRpbnVlVXJpOiBzdHJpbmc7XG4gIHRlbmFudElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUF1dGhVcmlSZXNwb25zZSB7XG4gIHNpZ25pbk1ldGhvZHM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQXV0aFVyaShcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogQ3JlYXRlQXV0aFVyaVJlcXVlc3Rcbik6IFByb21pc2U8Q3JlYXRlQXV0aFVyaVJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8Q3JlYXRlQXV0aFVyaVJlcXVlc3QsIENyZWF0ZUF1dGhVcmlSZXNwb25zZT4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuQ1JFQVRFX0FVVEhfVVJJLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgQWN0aW9uQ29kZU9wZXJhdGlvbixcbiAgQWN0aW9uQ29kZVNldHRpbmdzLFxuICBBdXRoLFxuICBVc2VyXG59IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZUF1dGhVcmksXG4gIENyZWF0ZUF1dGhVcmlSZXF1ZXN0XG59IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9jcmVhdGVfYXV0aF91cmknO1xuaW1wb3J0ICogYXMgYXBpIGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9lbWFpbF9hbmRfcGFzc3dvcmQnO1xuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBfZ2V0Q3VycmVudFVybCwgX2lzSHR0cE9ySHR0cHMgfSBmcm9tICcuLi91dGlsL2xvY2F0aW9uJztcbmltcG9ydCB7IF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QgfSBmcm9tICcuL2FjdGlvbl9jb2RlX3NldHRpbmdzJztcbmltcG9ydCB7IGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IG9mIHBvc3NpYmxlIHNpZ24gaW4gbWV0aG9kcyBmb3IgdGhlIGdpdmVuIGVtYWlsIGFkZHJlc3MuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgaXMgdXNlZnVsIHRvIGRpZmZlcmVudGlhdGUgbWV0aG9kcyBvZiBzaWduLWluIGZvciB0aGUgc2FtZSBwcm92aWRlciwgZWcuXG4gKiB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IHdoaWNoIGhhcyAyIG1ldGhvZHMgb2Ygc2lnbi1pbixcbiAqIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX1BBU1NXT1JEIGFuZFxuICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWwoXG4gIGF1dGg6IEF1dGgsXG4gIGVtYWlsOiBzdHJpbmdcbik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgLy8gY3JlYXRlQXV0aFVyaSByZXR1cm5zIGFuIGVycm9yIGlmIGNvbnRpbnVlIFVSSSBpcyBub3QgaHR0cCBvciBodHRwcy5cbiAgLy8gRm9yIGVudmlyb25tZW50cyBsaWtlIENvcmRvdmEsIENocm9tZSBleHRlbnNpb25zLCBuYXRpdmUgZnJhbWV3b3JrcywgZmlsZVxuICAvLyBzeXN0ZW1zLCBldGMsIHVzZSBodHRwOi8vbG9jYWxob3N0IGFzIGNvbnRpbnVlIFVSTC5cbiAgY29uc3QgY29udGludWVVcmkgPSBfaXNIdHRwT3JIdHRwcygpID8gX2dldEN1cnJlbnRVcmwoKSA6ICdodHRwOi8vbG9jYWxob3N0JztcbiAgY29uc3QgcmVxdWVzdDogQ3JlYXRlQXV0aFVyaVJlcXVlc3QgPSB7XG4gICAgaWRlbnRpZmllcjogZW1haWwsXG4gICAgY29udGludWVVcmlcbiAgfTtcblxuICBjb25zdCB7IHNpZ25pbk1ldGhvZHMgfSA9IGF3YWl0IGNyZWF0ZUF1dGhVcmkoXG4gICAgZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLFxuICAgIHJlcXVlc3RcbiAgKTtcblxuICByZXR1cm4gc2lnbmluTWV0aG9kcyB8fCBbXTtcbn1cblxuLyoqXG4gKiBTZW5kcyBhIHZlcmlmaWNhdGlvbiBlbWFpbCB0byBhIHVzZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSB2ZXJpZmljYXRpb24gcHJvY2VzcyBpcyBjb21wbGV0ZWQgYnkgY2FsbGluZyB7QGxpbmsgYXBwbHlBY3Rpb25Db2RlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXG4gKiAgIGlPUzoge1xuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcbiAqICAgfSxcbiAqICAgYW5kcm9pZDoge1xuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xuICogICB9LFxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcbiAqIH07XG4gKiBhd2FpdCBzZW5kRW1haWxWZXJpZmljYXRpb24odXNlciwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAqIC8vIE9idGFpbiBjb2RlIGZyb20gdGhlIHVzZXIuXG4gKiBhd2FpdCBhcHBseUFjdGlvbkNvZGUoYXV0aCwgY29kZSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kRW1haWxWZXJpZmljYXRpb24oXG4gIHVzZXI6IFVzZXIsXG4gIGFjdGlvbkNvZGVTZXR0aW5ncz86IEFjdGlvbkNvZGVTZXR0aW5ncyB8IG51bGxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsO1xuICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gIGNvbnN0IHJlcXVlc3Q6IGFwaS5WZXJpZnlFbWFpbFJlcXVlc3QgPSB7XG4gICAgcmVxdWVzdFR5cGU6IEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0VNQUlMLFxuICAgIGlkVG9rZW5cbiAgfTtcbiAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QoXG4gICAgICB1c2VySW50ZXJuYWwuYXV0aCxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBhY3Rpb25Db2RlU2V0dGluZ3NcbiAgICApO1xuICB9XG5cbiAgY29uc3QgeyBlbWFpbCB9ID0gYXdhaXQgYXBpLnNlbmRFbWFpbFZlcmlmaWNhdGlvbih1c2VySW50ZXJuYWwuYXV0aCwgcmVxdWVzdCk7XG5cbiAgaWYgKGVtYWlsICE9PSB1c2VyLmVtYWlsKSB7XG4gICAgYXdhaXQgdXNlci5yZWxvYWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNlbmRzIGEgdmVyaWZpY2F0aW9uIGVtYWlsIHRvIGEgbmV3IGVtYWlsIGFkZHJlc3MuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSB1c2VyJ3MgZW1haWwgd2lsbCBiZSB1cGRhdGVkIHRvIHRoZSBuZXcgb25lIGFmdGVyIGJlaW5nIHZlcmlmaWVkLlxuICpcbiAqIElmIHlvdSBoYXZlIGEgY3VzdG9tIGVtYWlsIGFjdGlvbiBoYW5kbGVyLCB5b3UgY2FuIGNvbXBsZXRlIHRoZSB2ZXJpZmljYXRpb24gcHJvY2VzcyBieSBjYWxsaW5nXG4gKiB7QGxpbmsgYXBwbHlBY3Rpb25Db2RlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXG4gKiAgIGlPUzoge1xuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcbiAqICAgfSxcbiAqICAgYW5kcm9pZDoge1xuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xuICogICB9LFxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcbiAqIH07XG4gKiBhd2FpdCB2ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbCh1c2VyLCAnbmV3ZW1haWxAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICogLy8gT2J0YWluIGNvZGUgZnJvbSB0aGUgdXNlci5cbiAqIGF3YWl0IGFwcGx5QWN0aW9uQ29kZShhdXRoLCBjb2RlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gbmV3RW1haWwgLSBUaGUgbmV3IGVtYWlsIGFkZHJlc3MgdG8gYmUgdmVyaWZpZWQgYmVmb3JlIHVwZGF0ZS5cbiAqIEBwYXJhbSBhY3Rpb25Db2RlU2V0dGluZ3MgLSBUaGUge0BsaW5rIEFjdGlvbkNvZGVTZXR0aW5nc30uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwoXG4gIHVzZXI6IFVzZXIsXG4gIG5ld0VtYWlsOiBzdHJpbmcsXG4gIGFjdGlvbkNvZGVTZXR0aW5ncz86IEFjdGlvbkNvZGVTZXR0aW5ncyB8IG51bGxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsO1xuICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gIGNvbnN0IHJlcXVlc3Q6IGFwaS5WZXJpZnlBbmRDaGFuZ2VFbWFpbFJlcXVlc3QgPSB7XG4gICAgcmVxdWVzdFR5cGU6IEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwsXG4gICAgaWRUb2tlbixcbiAgICBuZXdFbWFpbFxuICB9O1xuICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChcbiAgICAgIHVzZXJJbnRlcm5hbC5hdXRoLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGFjdGlvbkNvZGVTZXR0aW5nc1xuICAgICk7XG4gIH1cblxuICBjb25zdCB7IGVtYWlsIH0gPSBhd2FpdCBhcGkudmVyaWZ5QW5kQ2hhbmdlRW1haWwodXNlckludGVybmFsLmF1dGgsIHJlcXVlc3QpO1xuXG4gIGlmIChlbWFpbCAhPT0gdXNlci5lbWFpbCkge1xuICAgIC8vIElmIHRoZSBsb2NhbCBjb3B5IG9mIHRoZSBlbWFpbCBvbiB1c2VyIGlzIG91dGRhdGVkLCByZWxvYWQgdGhlXG4gICAgLy8gdXNlci5cbiAgICBhd2FpdCB1c2VyLnJlbG9hZCgpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBFbmRwb2ludCwgSHR0cE1ldGhvZCwgX3BlcmZvcm1BcGlSZXF1ZXN0IH0gZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlUHJvZmlsZVJlcXVlc3Qge1xuICBpZFRva2VuOiBzdHJpbmc7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nIHwgbnVsbDtcbiAgcGhvdG9Vcmw/OiBzdHJpbmcgfCBudWxsO1xuICByZXR1cm5TZWN1cmVUb2tlbjogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVQcm9maWxlUmVzcG9uc2UgZXh0ZW5kcyBJZFRva2VuUmVzcG9uc2Uge1xuICBkaXNwbGF5TmFtZT86IHN0cmluZyB8IG51bGw7XG4gIHBob3RvVXJsPzogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGUoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFVwZGF0ZVByb2ZpbGVSZXF1ZXN0XG4pOiBQcm9taXNlPFVwZGF0ZVByb2ZpbGVSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PFVwZGF0ZVByb2ZpbGVSZXF1ZXN0LCBVcGRhdGVQcm9maWxlUmVzcG9uc2U+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8sXG4gICAgcmVxdWVzdFxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7XG4gIHVwZGF0ZUVtYWlsUGFzc3dvcmQgYXMgYXBpVXBkYXRlRW1haWxQYXNzd29yZCxcbiAgVXBkYXRlRW1haWxQYXNzd29yZFJlcXVlc3Rcbn0gZnJvbSAnLi4vLi4vYXBpL2FjY291bnRfbWFuYWdlbWVudC9lbWFpbF9hbmRfcGFzc3dvcmQnO1xuaW1wb3J0IHsgdXBkYXRlUHJvZmlsZSBhcyBhcGlVcGRhdGVQcm9maWxlIH0gZnJvbSAnLi4vLi4vYXBpL2FjY291bnRfbWFuYWdlbWVudC9wcm9maWxlJztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgX2xvZ291dElmSW52YWxpZGF0ZWQgfSBmcm9tICcuL2ludmFsaWRhdGlvbic7XG5pbXBvcnQgeyBnZXRNb2R1bGFySW5zdGFuY2UgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBQcm92aWRlcklkIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG4vKipcbiAqIFVwZGF0ZXMgYSB1c2VyJ3MgcHJvZmlsZSBkYXRhLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gcHJvZmlsZSAtIFRoZSBwcm9maWxlJ3MgYGRpc3BsYXlOYW1lYCBhbmQgYHBob3RvVVJMYCB0byB1cGRhdGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJvZmlsZShcbiAgdXNlcjogVXNlcixcbiAge1xuICAgIGRpc3BsYXlOYW1lLFxuICAgIHBob3RvVVJMOiBwaG90b1VybFxuICB9OiB7IGRpc3BsYXlOYW1lPzogc3RyaW5nIHwgbnVsbDsgcGhvdG9VUkw/OiBzdHJpbmcgfCBudWxsIH1cbik6IFByb21pc2U8dm9pZD4ge1xuICBpZiAoZGlzcGxheU5hbWUgPT09IHVuZGVmaW5lZCAmJiBwaG90b1VybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpIGFzIFVzZXJJbnRlcm5hbDtcbiAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXJJbnRlcm5hbC5nZXRJZFRva2VuKCk7XG4gIGNvbnN0IHByb2ZpbGVSZXF1ZXN0ID0ge1xuICAgIGlkVG9rZW4sXG4gICAgZGlzcGxheU5hbWUsXG4gICAgcGhvdG9VcmwsXG4gICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcbiAgfTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZChcbiAgICB1c2VySW50ZXJuYWwsXG4gICAgYXBpVXBkYXRlUHJvZmlsZSh1c2VySW50ZXJuYWwuYXV0aCwgcHJvZmlsZVJlcXVlc3QpXG4gICk7XG5cbiAgdXNlckludGVybmFsLmRpc3BsYXlOYW1lID0gcmVzcG9uc2UuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgdXNlckludGVybmFsLnBob3RvVVJMID0gcmVzcG9uc2UucGhvdG9VcmwgfHwgbnVsbDtcblxuICAvLyBVcGRhdGUgdGhlIHBhc3N3b3JkIHByb3ZpZGVyIGFzIHdlbGxcbiAgY29uc3QgcGFzc3dvcmRQcm92aWRlciA9IHVzZXJJbnRlcm5hbC5wcm92aWRlckRhdGEuZmluZChcbiAgICAoeyBwcm92aWRlcklkIH0pID0+IHByb3ZpZGVySWQgPT09IFByb3ZpZGVySWQuUEFTU1dPUkRcbiAgKTtcbiAgaWYgKHBhc3N3b3JkUHJvdmlkZXIpIHtcbiAgICBwYXNzd29yZFByb3ZpZGVyLmRpc3BsYXlOYW1lID0gdXNlckludGVybmFsLmRpc3BsYXlOYW1lO1xuICAgIHBhc3N3b3JkUHJvdmlkZXIucGhvdG9VUkwgPSB1c2VySW50ZXJuYWwucGhvdG9VUkw7XG4gIH1cblxuICBhd2FpdCB1c2VySW50ZXJuYWwuX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KHJlc3BvbnNlKTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogQW4gZW1haWwgd2lsbCBiZSBzZW50IHRvIHRoZSBvcmlnaW5hbCBlbWFpbCBhZGRyZXNzIChpZiBpdCB3YXMgc2V0KSB0aGF0IGFsbG93cyB0byByZXZva2UgdGhlXG4gKiBlbWFpbCBhZGRyZXNzIGNoYW5nZSwgaW4gb3JkZXIgdG8gcHJvdGVjdCB0aGVtIGZyb20gYWNjb3VudCBoaWphY2tpbmcuXG4gKlxuICogSW1wb3J0YW50OiB0aGlzIGlzIGEgc2VjdXJpdHkgc2Vuc2l0aXZlIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIHRoZSB1c2VyIHRvIGhhdmUgcmVjZW50bHkgc2lnbmVkXG4gKiBpbi4gSWYgdGhpcyByZXF1aXJlbWVudCBpc24ndCBtZXQsIGFzayB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUgYWdhaW4gYW5kIHRoZW4gY2FsbFxuICoge0BsaW5rIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWx9LlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gbmV3RW1haWwgLSBUaGUgbmV3IGVtYWlsIGFkZHJlc3MuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRW1haWwodXNlcjogVXNlciwgbmV3RW1haWw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gdXBkYXRlRW1haWxPclBhc3N3b3JkKFxuICAgIGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWwsXG4gICAgbmV3RW1haWwsXG4gICAgbnVsbFxuICApO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHVzZXIncyBwYXNzd29yZC5cbiAqXG4gKiBAcmVtYXJrc1xuICogSW1wb3J0YW50OiB0aGlzIGlzIGEgc2VjdXJpdHkgc2Vuc2l0aXZlIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIHRoZSB1c2VyIHRvIGhhdmUgcmVjZW50bHkgc2lnbmVkXG4gKiBpbi4gSWYgdGhpcyByZXF1aXJlbWVudCBpc24ndCBtZXQsIGFzayB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUgYWdhaW4gYW5kIHRoZW4gY2FsbFxuICoge0BsaW5rIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWx9LlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gbmV3UGFzc3dvcmQgLSBUaGUgbmV3IHBhc3N3b3JkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVBhc3N3b3JkKHVzZXI6IFVzZXIsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIHVwZGF0ZUVtYWlsT3JQYXNzd29yZChcbiAgICBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsLFxuICAgIG51bGwsXG4gICAgbmV3UGFzc3dvcmRcbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlRW1haWxPclBhc3N3b3JkKFxuICB1c2VyOiBVc2VySW50ZXJuYWwsXG4gIGVtYWlsOiBzdHJpbmcgfCBudWxsLFxuICBwYXNzd29yZDogc3RyaW5nIHwgbnVsbFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHsgYXV0aCB9ID0gdXNlcjtcbiAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICBjb25zdCByZXF1ZXN0OiBVcGRhdGVFbWFpbFBhc3N3b3JkUmVxdWVzdCA9IHtcbiAgICBpZFRva2VuLFxuICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXG4gIH07XG5cbiAgaWYgKGVtYWlsKSB7XG4gICAgcmVxdWVzdC5lbWFpbCA9IGVtYWlsO1xuICB9XG5cbiAgaWYgKHBhc3N3b3JkKSB7XG4gICAgcmVxdWVzdC5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICB9XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZChcbiAgICB1c2VyLFxuICAgIGFwaVVwZGF0ZUVtYWlsUGFzc3dvcmQoYXV0aCwgcmVxdWVzdClcbiAgKTtcbiAgYXdhaXQgdXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkocmVzcG9uc2UsIC8qIHJlbG9hZCAqLyB0cnVlKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEFkZGl0aW9uYWxVc2VySW5mbywgVXNlckNyZWRlbnRpYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlLCBJZFRva2VuUmVzcG9uc2VLaW5kIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgX3BhcnNlVG9rZW4gfSBmcm9tICcuL2lkX3Rva2VuX3Jlc3VsdCc7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBQcm92aWRlcklkIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBgQWRkaXRpb25hbFVzZXJJbmZvYCBmcm9tIHRoZSBJRCB0b2tlbiByZXNwb25zZS5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZnJvbUlkVG9rZW5SZXNwb25zZShcbiAgaWRUb2tlblJlc3BvbnNlPzogSWRUb2tlblJlc3BvbnNlXG4pOiBBZGRpdGlvbmFsVXNlckluZm8gfCBudWxsIHtcbiAgaWYgKCFpZFRva2VuUmVzcG9uc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7IHByb3ZpZGVySWQgfSA9IGlkVG9rZW5SZXNwb25zZTtcbiAgY29uc3QgcHJvZmlsZSA9IGlkVG9rZW5SZXNwb25zZS5yYXdVc2VySW5mb1xuICAgID8gSlNPTi5wYXJzZShpZFRva2VuUmVzcG9uc2UucmF3VXNlckluZm8pXG4gICAgOiB7fTtcbiAgY29uc3QgaXNOZXdVc2VyID1cbiAgICBpZFRva2VuUmVzcG9uc2UuaXNOZXdVc2VyIHx8XG4gICAgaWRUb2tlblJlc3BvbnNlLmtpbmQgPT09IElkVG9rZW5SZXNwb25zZUtpbmQuU2lnbnVwTmV3VXNlcjtcbiAgaWYgKCFwcm92aWRlcklkICYmIGlkVG9rZW5SZXNwb25zZT8uaWRUb2tlbikge1xuICAgIGNvbnN0IHNpZ25JblByb3ZpZGVyID0gX3BhcnNlVG9rZW4oaWRUb2tlblJlc3BvbnNlLmlkVG9rZW4pPy5maXJlYmFzZT8uW1xuICAgICAgJ3NpZ25faW5fcHJvdmlkZXInXG4gICAgXTtcbiAgICBpZiAoc2lnbkluUHJvdmlkZXIpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkUHJvdmlkZXJJZCA9XG4gICAgICAgIHNpZ25JblByb3ZpZGVyICE9PSBQcm92aWRlcklkLkFOT05ZTU9VUyAmJlxuICAgICAgICBzaWduSW5Qcm92aWRlciAhPT0gUHJvdmlkZXJJZC5DVVNUT01cbiAgICAgICAgICA/IChzaWduSW5Qcm92aWRlciBhcyBQcm92aWRlcklkKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIC8vIFVzZXMgZ2VuZXJpYyBjbGFzcyBpbiBhY2NvcmRhbmNlIHdpdGggdGhlIGxlZ2FjeSBTREsuXG4gICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBmaWx0ZXJlZFByb3ZpZGVySWQpO1xuICAgIH1cbiAgfVxuICBpZiAoIXByb3ZpZGVySWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzd2l0Y2ggKHByb3ZpZGVySWQpIHtcbiAgICBjYXNlIFByb3ZpZGVySWQuRkFDRUJPT0s6XG4gICAgICByZXR1cm4gbmV3IEZhY2Vib29rQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSk7XG4gICAgY2FzZSBQcm92aWRlcklkLkdJVEhVQjpcbiAgICAgIHJldHVybiBuZXcgR2l0aHViQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSk7XG4gICAgY2FzZSBQcm92aWRlcklkLkdPT0dMRTpcbiAgICAgIHJldHVybiBuZXcgR29vZ2xlQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSk7XG4gICAgY2FzZSBQcm92aWRlcklkLlRXSVRURVI6XG4gICAgICByZXR1cm4gbmV3IFR3aXR0ZXJBZGRpdGlvbmFsVXNlckluZm8oXG4gICAgICAgIGlzTmV3VXNlcixcbiAgICAgICAgcHJvZmlsZSxcbiAgICAgICAgaWRUb2tlblJlc3BvbnNlLnNjcmVlbk5hbWUgfHwgbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIFByb3ZpZGVySWQuQ1VTVE9NOlxuICAgIGNhc2UgUHJvdmlkZXJJZC5BTk9OWU1PVVM6XG4gICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBudWxsKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ldyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSk7XG4gIH1cbn1cblxuY2xhc3MgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyBpbXBsZW1lbnRzIEFkZGl0aW9uYWxVc2VySW5mbyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGlzTmV3VXNlcjogYm9vbGVhbixcbiAgICByZWFkb25seSBwcm92aWRlcklkOiBQcm92aWRlcklkIHwgc3RyaW5nIHwgbnVsbCxcbiAgICByZWFkb25seSBwcm9maWxlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9XG4gICkge31cbn1cblxuY2xhc3MgRmVkZXJhdGVkQWRkaXRpb25hbFVzZXJJbmZvV2l0aFVzZXJuYW1lIGV4dGVuZHMgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGlzTmV3VXNlcjogYm9vbGVhbixcbiAgICBwcm92aWRlcklkOiBQcm92aWRlcklkLFxuICAgIHByb2ZpbGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgIHJlYWRvbmx5IHVzZXJuYW1lOiBzdHJpbmcgfCBudWxsXG4gICkge1xuICAgIHN1cGVyKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSk7XG4gIH1cbn1cblxuY2xhc3MgRmFjZWJvb2tBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcbiAgY29uc3RydWN0b3IoaXNOZXdVc2VyOiBib29sZWFuLCBwcm9maWxlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIHN1cGVyKGlzTmV3VXNlciwgUHJvdmlkZXJJZC5GQUNFQk9PSywgcHJvZmlsZSk7XG4gIH1cbn1cblxuY2xhc3MgR2l0aHViQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgRmVkZXJhdGVkQWRkaXRpb25hbFVzZXJJbmZvV2l0aFVzZXJuYW1lIHtcbiAgY29uc3RydWN0b3IoaXNOZXdVc2VyOiBib29sZWFuLCBwcm9maWxlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIHN1cGVyKFxuICAgICAgaXNOZXdVc2VyLFxuICAgICAgUHJvdmlkZXJJZC5HSVRIVUIsXG4gICAgICBwcm9maWxlLFxuICAgICAgdHlwZW9mIHByb2ZpbGU/LmxvZ2luID09PSAnc3RyaW5nJyA/IHByb2ZpbGU/LmxvZ2luIDogbnVsbFxuICAgICk7XG4gIH1cbn1cblxuY2xhc3MgR29vZ2xlQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XG4gIGNvbnN0cnVjdG9yKGlzTmV3VXNlcjogYm9vbGVhbiwgcHJvZmlsZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICBzdXBlcihpc05ld1VzZXIsIFByb3ZpZGVySWQuR09PR0xFLCBwcm9maWxlKTtcbiAgfVxufVxuXG5jbGFzcyBUd2l0dGVyQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgRmVkZXJhdGVkQWRkaXRpb25hbFVzZXJJbmZvV2l0aFVzZXJuYW1lIHtcbiAgY29uc3RydWN0b3IoXG4gICAgaXNOZXdVc2VyOiBib29sZWFuLFxuICAgIHByb2ZpbGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgIHNjcmVlbk5hbWU6IHN0cmluZyB8IG51bGxcbiAgKSB7XG4gICAgc3VwZXIoaXNOZXdVc2VyLCBQcm92aWRlcklkLlRXSVRURVIsIHByb2ZpbGUsIHNjcmVlbk5hbWUpO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdHMgcHJvdmlkZXIgc3BlY2lmaWMge0BsaW5rIEFkZGl0aW9uYWxVc2VySW5mb30gZm9yIHRoZSBnaXZlbiBjcmVkZW50aWFsLlxuICpcbiAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkaXRpb25hbFVzZXJJbmZvKFxuICB1c2VyQ3JlZGVudGlhbDogVXNlckNyZWRlbnRpYWxcbik6IEFkZGl0aW9uYWxVc2VySW5mbyB8IG51bGwge1xuICBjb25zdCB7IHVzZXIsIF90b2tlblJlc3BvbnNlIH0gPSB1c2VyQ3JlZGVudGlhbCBhcyBVc2VyQ3JlZGVudGlhbEludGVybmFsO1xuICBpZiAodXNlci5pc0Fub255bW91cyAmJiAhX3Rva2VuUmVzcG9uc2UpIHtcbiAgICAvLyBIYW5kbGUgdGhlIHNwZWNpYWwgY2FzZSB3aGVyZSBzaWduSW5Bbm9ueW1vdXNseSgpIGdldHMgY2FsbGVkIHR3aWNlLlxuICAgIC8vIE5vIG5ldHdvcmsgY2FsbCBpcyBtYWRlIHNvIHRoZXJlJ3Mgbm90aGluZyB0byBhY3R1YWxseSBmaWxsIHRoaXMgaW5cbiAgICByZXR1cm4ge1xuICAgICAgcHJvdmlkZXJJZDogbnVsbCxcbiAgICAgIGlzTmV3VXNlcjogZmFsc2UsXG4gICAgICBwcm9maWxlOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZnJvbUlkVG9rZW5SZXNwb25zZShfdG9rZW5SZXNwb25zZSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBnZXRNb2R1bGFySW5zdGFuY2UgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQge1xuICBBdXRoLFxuICBOZXh0T3JPYnNlcnZlcixcbiAgUGVyc2lzdGVuY2UsXG4gIFVzZXIsXG4gIENvbXBsZXRlRm4sXG4gIEVycm9yRm4sXG4gIFVuc3Vic2NyaWJlXG59IGZyb20gJy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBfY2FzdEF1dGggfSBmcm9tICcuLi9jb3JlL2F1dGgvYXV0aF9pbXBsJztcblxuZXhwb3J0IHtcbiAgZGVidWdFcnJvck1hcCxcbiAgcHJvZEVycm9yTWFwLFxuICBBVVRIX0VSUk9SX0NPREVTX01BUF9ET19OT1RfVVNFX0lOVEVSTkFMTFkgYXMgQXV0aEVycm9yQ29kZXNcbn0gZnJvbSAnLi9lcnJvcnMnO1xuXG4vLyBOb24tb3B0aW9uYWwgYXV0aCBtZXRob2RzLlxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB0eXBlIG9mIHBlcnNpc3RlbmNlIG9uIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50bHkgc2F2ZWRcbiAqIGBBdXRoYCBzZXNzaW9uIGFuZCBhcHBsaWVzIHRoaXMgdHlwZSBvZiBwZXJzaXN0ZW5jZSBmb3IgZnV0dXJlIHNpZ24taW4gcmVxdWVzdHMsIGluY2x1ZGluZ1xuICogc2lnbi1pbiB3aXRoIHJlZGlyZWN0IHJlcXVlc3RzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIG1ha2VzIGl0IGVhc3kgZm9yIGEgdXNlciBzaWduaW5nIGluIHRvIHNwZWNpZnkgd2hldGhlciB0aGVpciBzZXNzaW9uIHNob3VsZCBiZVxuICogcmVtZW1iZXJlZCBvciBub3QuIEl0IGFsc28gbWFrZXMgaXQgZWFzaWVyIHRvIG5ldmVyIHBlcnNpc3QgdGhlIGBBdXRoYCBzdGF0ZSBmb3IgYXBwbGljYXRpb25zXG4gKiB0aGF0IGFyZSBzaGFyZWQgYnkgb3RoZXIgdXNlcnMgb3IgaGF2ZSBzZW5zaXRpdmUgZGF0YS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogc2V0UGVyc2lzdGVuY2UoYXV0aCwgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gcGVyc2lzdGVuY2UgLSBUaGUge0BsaW5rIFBlcnNpc3RlbmNlfSB0byB1c2UuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIHBlcnNpc3RlbmNlIGNoYW5nZSBoYXMgY29tcGxldGVkXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UGVyc2lzdGVuY2UoXG4gIGF1dGg6IEF1dGgsXG4gIHBlcnNpc3RlbmNlOiBQZXJzaXN0ZW5jZVxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2UpO1xufVxuXG4vKipcbiAqIExvYWRzIHRoZSByZUNBUFRDSEEgY29uZmlndXJhdGlvbiBpbnRvIHRoZSBgQXV0aGAgaW5zdGFuY2UuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgd2lsbCBsb2FkIHRoZSByZUNBUFRDSEEgY29uZmlnLCB3aGljaCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVDQVBUQ0hBXG4gKiB2ZXJpZmljYXRpb24gZmxvdyBzaG91bGQgYmUgdHJpZ2dlcmVkIGZvciBlYWNoIGF1dGggcHJvdmlkZXIsIGludG8gdGhlXG4gKiBjdXJyZW50IEF1dGggc2Vzc2lvbi5cbiAqXG4gKiBJZiBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKCkgaXMgbm90IGludm9rZWQsIHRoZSBhdXRoIGZsb3cgd2lsbCBhbHdheXMgc3RhcnRcbiAqIHdpdGhvdXQgcmVDQVBUQ0hBIHZlcmlmaWNhdGlvbi4gSWYgdGhlIHByb3ZpZGVyIGlzIGNvbmZpZ3VyZWQgdG8gcmVxdWlyZSByZUNBUFRDSEFcbiAqIHZlcmlmaWNhdGlvbiwgdGhlIFNESyB3aWxsIHRyYW5zcGFyZW50bHkgbG9hZCB0aGUgcmVDQVBUQ0hBIGNvbmZpZyBhbmQgcmVzdGFydCB0aGVcbiAqIGF1dGggZmxvd3MuXG4gKlxuICogVGh1cywgYnkgY2FsbGluZyB0aGlzIG9wdGlvbmFsIG1ldGhvZCwgeW91IHdpbGwgcmVkdWNlIHRoZSBsYXRlbmN5IG9mIGZ1dHVyZSBhdXRoIGZsb3dzLlxuICogTG9hZGluZyB0aGUgcmVDQVBUQ0hBIGNvbmZpZyBlYXJseSB3aWxsIGFsc28gZW5oYW5jZSB0aGUgc2lnbmFsIGNvbGxlY3RlZCBieSByZUNBUFRDSEEuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyhhdXRoOiBBdXRoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgcmV0dXJuIGF1dGhJbnRlcm5hbC5pbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKCk7XG59XG5cbi8qKlxuICogQWRkcyBhbiBvYnNlcnZlciBmb3IgY2hhbmdlcyB0byB0aGUgc2lnbmVkLWluIHVzZXIncyBJRCB0b2tlbi5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBpbmNsdWRlcyBzaWduLWluLCBzaWduLW91dCwgYW5kIHRva2VuIHJlZnJlc2ggZXZlbnRzLlxuICogVGhpcyB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB1cG9uIElEIHRva2VuIGV4cGlyYXRpb24uIFVzZSB7QGxpbmsgVXNlci5nZXRJZFRva2VufSB0byByZWZyZXNoIHRoZSBJRCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gbmV4dE9yT2JzZXJ2ZXIgLSBjYWxsYmFjayB0cmlnZ2VyZWQgb24gY2hhbmdlLlxuICogQHBhcmFtIGVycm9yIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuIEVycm9yc1xuICogb24gc2lnbmluZyBpbi9vdXQgY2FuIGJlIGNhdWdodCBpbiBwcm9taXNlcyByZXR1cm5lZCBmcm9tXG4gKiBzaWduLWluL3NpZ24tb3V0IGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBjb21wbGV0ZWQgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbklkVG9rZW5DaGFuZ2VkKFxuICBhdXRoOiBBdXRoLFxuICBuZXh0T3JPYnNlcnZlcjogTmV4dE9yT2JzZXJ2ZXI8VXNlcj4sXG4gIGVycm9yPzogRXJyb3JGbixcbiAgY29tcGxldGVkPzogQ29tcGxldGVGblxuKTogVW5zdWJzY3JpYmUge1xuICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLm9uSWRUb2tlbkNoYW5nZWQoXG4gICAgbmV4dE9yT2JzZXJ2ZXIsXG4gICAgZXJyb3IsXG4gICAgY29tcGxldGVkXG4gICk7XG59XG4vKipcbiAqIEFkZHMgYSBibG9ja2luZyBjYWxsYmFjayB0aGF0IHJ1bnMgYmVmb3JlIGFuIGF1dGggc3RhdGUgY2hhbmdlXG4gKiBzZXRzIGEgbmV3IHVzZXIuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGNhbGxiYWNrIC0gY2FsbGJhY2sgdHJpZ2dlcmVkIGJlZm9yZSBuZXcgdXNlciB2YWx1ZSBpcyBzZXQuXG4gKiAgIElmIHRoaXMgdGhyb3dzLCBpdCBibG9ja3MgdGhlIHVzZXIgZnJvbSBiZWluZyBzZXQuXG4gKiBAcGFyYW0gb25BYm9ydCAtIGNhbGxiYWNrIHRyaWdnZXJlZCBpZiBhIGxhdGVyIGBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkKClgXG4gKiAgIGNhbGxiYWNrIHRocm93cywgYWxsb3dpbmcgeW91IHRvIHVuZG8gYW55IHNpZGUgZWZmZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoXG4gIGF1dGg6IEF1dGgsXG4gIGNhbGxiYWNrOiAodXNlcjogVXNlciB8IG51bGwpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+LFxuICBvbkFib3J0PzogKCkgPT4gdm9pZFxuKTogVW5zdWJzY3JpYmUge1xuICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLmJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoY2FsbGJhY2ssIG9uQWJvcnQpO1xufVxuLyoqXG4gKiBBZGRzIGFuIG9ic2VydmVyIGZvciBjaGFuZ2VzIHRvIHRoZSB1c2VyJ3Mgc2lnbi1pbiBzdGF0ZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVG8ga2VlcCB0aGUgb2xkIGJlaGF2aW9yLCBzZWUge0BsaW5rIG9uSWRUb2tlbkNoYW5nZWR9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBuZXh0T3JPYnNlcnZlciAtIGNhbGxiYWNrIHRyaWdnZXJlZCBvbiBjaGFuZ2UuXG4gKiBAcGFyYW0gZXJyb3IgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC4gRXJyb3JzXG4gKiBvbiBzaWduaW5nIGluL291dCBjYW4gYmUgY2F1Z2h0IGluIHByb21pc2VzIHJldHVybmVkIGZyb21cbiAqIHNpZ24taW4vc2lnbi1vdXQgZnVuY3Rpb25zLlxuICogQHBhcmFtIGNvbXBsZXRlZCAtIERlcHJlY2F0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbmV2ZXIgdHJpZ2dlcmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uQXV0aFN0YXRlQ2hhbmdlZChcbiAgYXV0aDogQXV0aCxcbiAgbmV4dE9yT2JzZXJ2ZXI6IE5leHRPck9ic2VydmVyPFVzZXI+LFxuICBlcnJvcj86IEVycm9yRm4sXG4gIGNvbXBsZXRlZD86IENvbXBsZXRlRm5cbik6IFVuc3Vic2NyaWJlIHtcbiAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5vbkF1dGhTdGF0ZUNoYW5nZWQoXG4gICAgbmV4dE9yT2JzZXJ2ZXIsXG4gICAgZXJyb3IsXG4gICAgY29tcGxldGVkXG4gICk7XG59XG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgbGFuZ3VhZ2UgdG8gdGhlIGRlZmF1bHQgZGV2aWNlL2Jyb3dzZXIgcHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGV2aWNlTGFuZ3VhZ2UoYXV0aDogQXV0aCk6IHZvaWQge1xuICBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkudXNlRGV2aWNlTGFuZ3VhZ2UoKTtcbn1cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2V0cyB0aGUgcHJvdmlkZWQgdXNlciBhcyB7QGxpbmsgQXV0aC5jdXJyZW50VXNlcn0gb24gdGhlXG4gKiB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHJlbWFya3NcbiAqIEEgbmV3IGluc3RhbmNlIGNvcHkgb2YgdGhlIHVzZXIgcHJvdmlkZWQgd2lsbCBiZSBtYWRlIGFuZCBzZXQgYXMgY3VycmVudFVzZXIuXG4gKlxuICogVGhpcyB3aWxsIHRyaWdnZXIge0BsaW5rIG9uQXV0aFN0YXRlQ2hhbmdlZH0gYW5kIHtAbGluayBvbklkVG9rZW5DaGFuZ2VkfSBsaXN0ZW5lcnNcbiAqIGxpa2Ugb3RoZXIgc2lnbiBpbiBtZXRob2RzLlxuICpcbiAqIFRoZSBvcGVyYXRpb24gZmFpbHMgd2l0aCBhbiBlcnJvciBpZiB0aGUgdXNlciB0byBiZSB1cGRhdGVkIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgRmlyZWJhc2VcbiAqIHByb2plY3QuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIHVzZXIgLSBUaGUgbmV3IHtAbGluayBVc2VyfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDdXJyZW50VXNlcihcbiAgYXV0aDogQXV0aCxcbiAgdXNlcjogVXNlciB8IG51bGxcbik6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnVwZGF0ZUN1cnJlbnRVc2VyKHVzZXIpO1xufVxuLyoqXG4gKiBTaWducyBvdXQgdGhlIGN1cnJlbnQgdXNlci5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbk91dChhdXRoOiBBdXRoKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuc2lnbk91dCgpO1xufVxuXG5leHBvcnQgeyBpbml0aWFsaXplQXV0aCB9IGZyb20gJy4vYXV0aC9pbml0aWFsaXplJztcbmV4cG9ydCB7IGNvbm5lY3RBdXRoRW11bGF0b3IgfSBmcm9tICcuL2F1dGgvZW11bGF0b3InO1xuXG4vLyBjcmVkZW50aWFsc1xuZXhwb3J0IHsgQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuL2NyZWRlbnRpYWxzJztcbmV4cG9ydCB7IEVtYWlsQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuL2NyZWRlbnRpYWxzL2VtYWlsJztcbmV4cG9ydCB7IE9BdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4vY3JlZGVudGlhbHMvb2F1dGgnO1xuZXhwb3J0IHsgUGhvbmVBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4vY3JlZGVudGlhbHMvcGhvbmUnO1xuXG4vLyBwZXJzaXN0ZW5jZVxuZXhwb3J0IHsgaW5NZW1vcnlQZXJzaXN0ZW5jZSB9IGZyb20gJy4vcGVyc2lzdGVuY2UvaW5fbWVtb3J5JztcblxuLy8gcHJvdmlkZXJzXG5leHBvcnQgeyBFbWFpbEF1dGhQcm92aWRlciB9IGZyb20gJy4vcHJvdmlkZXJzL2VtYWlsJztcbmV4cG9ydCB7IEZhY2Vib29rQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZmFjZWJvb2snO1xuZXhwb3J0IHsgQ3VzdG9tUGFyYW1ldGVycyB9IGZyb20gJy4vcHJvdmlkZXJzL2ZlZGVyYXRlZCc7XG5leHBvcnQgeyBHb29nbGVBdXRoUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9nb29nbGUnO1xuZXhwb3J0IHsgR2l0aHViQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZ2l0aHViJztcbmV4cG9ydCB7IE9BdXRoUHJvdmlkZXIsIE9BdXRoQ3JlZGVudGlhbE9wdGlvbnMgfSBmcm9tICcuL3Byb3ZpZGVycy9vYXV0aCc7XG5leHBvcnQgeyBTQU1MQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvc2FtbCc7XG5leHBvcnQgeyBUd2l0dGVyQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvdHdpdHRlcic7XG5cbi8vIHN0cmF0ZWdpZXNcbmV4cG9ydCB7IHNpZ25JbkFub255bW91c2x5IH0gZnJvbSAnLi9zdHJhdGVnaWVzL2Fub255bW91cyc7XG5leHBvcnQge1xuICBzaWduSW5XaXRoQ3JlZGVudGlhbCxcbiAgbGlua1dpdGhDcmVkZW50aWFsLFxuICByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsXG59IGZyb20gJy4vc3RyYXRlZ2llcy9jcmVkZW50aWFsJztcbmV4cG9ydCB7IHNpZ25JbldpdGhDdXN0b21Ub2tlbiB9IGZyb20gJy4vc3RyYXRlZ2llcy9jdXN0b21fdG9rZW4nO1xuZXhwb3J0IHtcbiAgc2VuZFBhc3N3b3JkUmVzZXRFbWFpbCxcbiAgY29uZmlybVBhc3N3b3JkUmVzZXQsXG4gIGFwcGx5QWN0aW9uQ29kZSxcbiAgY2hlY2tBY3Rpb25Db2RlLFxuICB2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZSxcbiAgY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkLFxuICBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZFxufSBmcm9tICcuL3N0cmF0ZWdpZXMvZW1haWxfYW5kX3Bhc3N3b3JkJztcbmV4cG9ydCB7XG4gIHNlbmRTaWduSW5MaW5rVG9FbWFpbCxcbiAgaXNTaWduSW5XaXRoRW1haWxMaW5rLFxuICBzaWduSW5XaXRoRW1haWxMaW5rXG59IGZyb20gJy4vc3RyYXRlZ2llcy9lbWFpbF9saW5rJztcbmV4cG9ydCB7XG4gIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsLFxuICBzZW5kRW1haWxWZXJpZmljYXRpb24sXG4gIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsXG59IGZyb20gJy4vc3RyYXRlZ2llcy9lbWFpbCc7XG5cbi8vIGNvcmVcbmV4cG9ydCB7IEFjdGlvbkNvZGVVUkwsIHBhcnNlQWN0aW9uQ29kZVVSTCB9IGZyb20gJy4vYWN0aW9uX2NvZGVfdXJsJztcblxuLy8gdXNlclxuZXhwb3J0IHtcbiAgdXBkYXRlUHJvZmlsZSxcbiAgdXBkYXRlRW1haWwsXG4gIHVwZGF0ZVBhc3N3b3JkXG59IGZyb20gJy4vdXNlci9hY2NvdW50X2luZm8nO1xuZXhwb3J0IHsgZ2V0SWRUb2tlbiwgZ2V0SWRUb2tlblJlc3VsdCB9IGZyb20gJy4vdXNlci9pZF90b2tlbl9yZXN1bHQnO1xuZXhwb3J0IHsgdW5saW5rIH0gZnJvbSAnLi91c2VyL2xpbmtfdW5saW5rJztcbmV4cG9ydCB7IGdldEFkZGl0aW9uYWxVc2VySW5mbyB9IGZyb20gJy4vdXNlci9hZGRpdGlvbmFsX3VzZXJfaW5mbyc7XG5cbi8vIE5vbi1vcHRpb25hbCB1c2VyIG1ldGhvZHMuXG5leHBvcnQgeyByZWxvYWQgfSBmcm9tICcuL3VzZXIvcmVsb2FkJztcbi8qKlxuICogRGVsZXRlcyBhbmQgc2lnbnMgb3V0IHRoZSB1c2VyLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJbXBvcnRhbnQ6IHRoaXMgaXMgYSBzZWN1cml0eS1zZW5zaXRpdmUgb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHVzZXIgdG8gaGF2ZSByZWNlbnRseVxuICogc2lnbmVkIGluLiBJZiB0aGlzIHJlcXVpcmVtZW50IGlzbid0IG1ldCwgYXNrIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbiBhbmQgdGhlbiBjYWxsXG4gKiB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVVc2VyKHVzZXI6IFVzZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKS5kZWxldGUoKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IE11bHRpRmFjdG9yU2Vzc2lvbiB9IGZyb20gJy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBlbnVtIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUge1xuICBFTlJPTEwgPSAnZW5yb2xsJyxcbiAgU0lHTl9JTiA9ICdzaWduaW4nXG59XG5cbmludGVyZmFjZSBTZXJpYWxpemVkTXVsdGlGYWN0b3JTZXNzaW9uIHtcbiAgbXVsdGlGYWN0b3JTZXNzaW9uOiB7XG4gICAgaWRUb2tlbj86IHN0cmluZztcbiAgICBwZW5kaW5nQ3JlZGVudGlhbD86IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwgaW1wbGVtZW50cyBNdWx0aUZhY3RvclNlc3Npb24ge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IHR5cGU6IE11bHRpRmFjdG9yU2Vzc2lvblR5cGUsXG4gICAgcmVhZG9ubHkgY3JlZGVudGlhbDogc3RyaW5nLFxuICAgIHJlYWRvbmx5IGF1dGg/OiBBdXRoSW50ZXJuYWxcbiAgKSB7fVxuXG4gIHN0YXRpYyBfZnJvbUlkdG9rZW4oXG4gICAgaWRUb2tlbjogc3RyaW5nLFxuICAgIGF1dGg/OiBBdXRoSW50ZXJuYWxcbiAgKTogTXVsdGlGYWN0b3JTZXNzaW9uSW1wbCB7XG4gICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvclNlc3Npb25JbXBsKFxuICAgICAgTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5FTlJPTEwsXG4gICAgICBpZFRva2VuLFxuICAgICAgYXV0aFxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbChcbiAgICBtZmFQZW5kaW5nQ3JlZGVudGlhbDogc3RyaW5nXG4gICk6IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwge1xuICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbChcbiAgICAgIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuU0lHTl9JTixcbiAgICAgIG1mYVBlbmRpbmdDcmVkZW50aWFsXG4gICAgKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBTZXJpYWxpemVkTXVsdGlGYWN0b3JTZXNzaW9uIHtcbiAgICBjb25zdCBrZXkgPVxuICAgICAgdGhpcy50eXBlID09PSBNdWx0aUZhY3RvclNlc3Npb25UeXBlLkVOUk9MTFxuICAgICAgICA/ICdpZFRva2VuJ1xuICAgICAgICA6ICdwZW5kaW5nQ3JlZGVudGlhbCc7XG4gICAgcmV0dXJuIHtcbiAgICAgIG11bHRpRmFjdG9yU2Vzc2lvbjoge1xuICAgICAgICBba2V5XTogdGhpcy5jcmVkZW50aWFsXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihcbiAgICBvYmo6IFBhcnRpYWw8U2VyaWFsaXplZE11bHRpRmFjdG9yU2Vzc2lvbj5cbiAgKTogTXVsdGlGYWN0b3JTZXNzaW9uSW1wbCB8IG51bGwge1xuICAgIGlmIChvYmo/Lm11bHRpRmFjdG9yU2Vzc2lvbikge1xuICAgICAgaWYgKG9iai5tdWx0aUZhY3RvclNlc3Npb24/LnBlbmRpbmdDcmVkZW50aWFsKSB7XG4gICAgICAgIHJldHVybiBNdWx0aUZhY3RvclNlc3Npb25JbXBsLl9mcm9tTWZhUGVuZGluZ0NyZWRlbnRpYWwoXG4gICAgICAgICAgb2JqLm11bHRpRmFjdG9yU2Vzc2lvbi5wZW5kaW5nQ3JlZGVudGlhbFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChvYmoubXVsdGlGYWN0b3JTZXNzaW9uPy5pZFRva2VuKSB7XG4gICAgICAgIHJldHVybiBNdWx0aUZhY3RvclNlc3Npb25JbXBsLl9mcm9tSWR0b2tlbihcbiAgICAgICAgICBvYmoubXVsdGlGYWN0b3JTZXNzaW9uLmlkVG9rZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEF1dGgsXG4gIE11bHRpRmFjdG9yUmVzb2x2ZXIsXG4gIFVzZXJDcmVkZW50aWFsLFxuICBNdWx0aUZhY3RvckVycm9yXG59IGZyb20gJy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4uL2NvcmUvYXV0aC9hdXRoX2ltcGwnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2NvcmUvZXJyb3JzJztcbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsSW1wbCB9IGZyb20gJy4uL2NvcmUvdXNlci91c2VyX2NyZWRlbnRpYWxfaW1wbCc7XG5pbXBvcnQgeyBfYXNzZXJ0LCBfZmFpbCB9IGZyb20gJy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbnRlcm5hbCB9IGZyb20gJy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIH0gZnJvbSAnLi9tZmFfYXNzZXJ0aW9uJztcbmltcG9ydCB7IE11bHRpRmFjdG9yRXJyb3IgYXMgTXVsdGlGYWN0b3JFcnJvckludGVybmFsIH0gZnJvbSAnLi9tZmFfZXJyb3InO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JJbmZvSW1wbCB9IGZyb20gJy4vbWZhX2luZm8nO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbCB9IGZyb20gJy4vbWZhX3Nlc3Npb24nO1xuaW1wb3J0IHsgZ2V0TW9kdWxhckluc3RhbmNlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgT3BlcmF0aW9uVHlwZSB9IGZyb20gJy4uL21vZGVsL2VudW1zJztcblxuZXhwb3J0IGNsYXNzIE11bHRpRmFjdG9yUmVzb2x2ZXJJbXBsIGltcGxlbWVudHMgTXVsdGlGYWN0b3JSZXNvbHZlciB7XG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgc2Vzc2lvbjogTXVsdGlGYWN0b3JTZXNzaW9uSW1wbCxcbiAgICByZWFkb25seSBoaW50czogTXVsdGlGYWN0b3JJbmZvSW1wbFtdLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2lnbkluUmVzb2x2ZXI6IChcbiAgICAgIGFzc2VydGlvbjogTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsXG4gICAgKSA9PiBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWw+XG4gICkge31cblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZnJvbUVycm9yKFxuICAgIGF1dGhFeHRlcm46IEF1dGgsXG4gICAgZXJyb3I6IE11bHRpRmFjdG9yRXJyb3JJbnRlcm5hbFxuICApOiBNdWx0aUZhY3RvclJlc29sdmVySW1wbCB7XG4gICAgY29uc3QgYXV0aCA9IF9jYXN0QXV0aChhdXRoRXh0ZXJuKTtcbiAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IGVycm9yLmN1c3RvbURhdGEuX3NlcnZlclJlc3BvbnNlO1xuICAgIGNvbnN0IGhpbnRzID0gKHNlcnZlclJlc3BvbnNlLm1mYUluZm8gfHwgW10pLm1hcChlbnJvbGxtZW50ID0+XG4gICAgICBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudClcbiAgICApO1xuXG4gICAgX2Fzc2VydChcbiAgICAgIHNlcnZlclJlc3BvbnNlLm1mYVBlbmRpbmdDcmVkZW50aWFsLFxuICAgICAgYXV0aCxcbiAgICAgIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1JcbiAgICApO1xuICAgIGNvbnN0IHNlc3Npb24gPSBNdWx0aUZhY3RvclNlc3Npb25JbXBsLl9mcm9tTWZhUGVuZGluZ0NyZWRlbnRpYWwoXG4gICAgICBzZXJ2ZXJSZXNwb25zZS5tZmFQZW5kaW5nQ3JlZGVudGlhbFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yUmVzb2x2ZXJJbXBsKFxuICAgICAgc2Vzc2lvbixcbiAgICAgIGhpbnRzLFxuICAgICAgYXN5bmMgKFxuICAgICAgICBhc3NlcnRpb246IE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbFxuICAgICAgKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEludGVybmFsPiA9PiB7XG4gICAgICAgIGNvbnN0IG1mYVJlc3BvbnNlID0gYXdhaXQgYXNzZXJ0aW9uLl9wcm9jZXNzKGF1dGgsIHNlc3Npb24pO1xuICAgICAgICAvLyBDbGVhciBvdXQgdGhlIHVubmVlZGVkIGZpZWxkcyBmcm9tIHRoZSBvbGQgbG9naW4gcmVzcG9uc2VcbiAgICAgICAgZGVsZXRlIHNlcnZlclJlc3BvbnNlLm1mYUluZm87XG4gICAgICAgIGRlbGV0ZSBzZXJ2ZXJSZXNwb25zZS5tZmFQZW5kaW5nQ3JlZGVudGlhbDtcblxuICAgICAgICAvLyBVc2UgaW4gdGhlIG5ldyB0b2tlbiAmIHJlZnJlc2ggdG9rZW4gaW4gdGhlIG9sZCByZXNwb25zZVxuICAgICAgICBjb25zdCBpZFRva2VuUmVzcG9uc2UgPSB7XG4gICAgICAgICAgLi4uc2VydmVyUmVzcG9uc2UsXG4gICAgICAgICAgaWRUb2tlbjogbWZhUmVzcG9uc2UuaWRUb2tlbixcbiAgICAgICAgICByZWZyZXNoVG9rZW46IG1mYVJlc3BvbnNlLnJlZnJlc2hUb2tlblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBjb2xsYXBzZSB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQgaW50byBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbiBhbmQgaGF2ZSBpdCBzdXBwb3J0IHRoZSBTSUdOX0lOIGNhc2VcbiAgICAgICAgc3dpdGNoIChlcnJvci5vcGVyYXRpb25UeXBlKSB7XG4gICAgICAgICAgY2FzZSBPcGVyYXRpb25UeXBlLlNJR05fSU46XG4gICAgICAgICAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9XG4gICAgICAgICAgICAgIGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShcbiAgICAgICAgICAgICAgICBhdXRoLFxuICAgICAgICAgICAgICAgIGVycm9yLm9wZXJhdGlvblR5cGUsXG4gICAgICAgICAgICAgICAgaWRUb2tlblJlc3BvbnNlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhd2FpdCBhdXRoLl91cGRhdGVDdXJyZW50VXNlcih1c2VyQ3JlZGVudGlhbC51c2VyKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyQ3JlZGVudGlhbDtcbiAgICAgICAgICBjYXNlIE9wZXJhdGlvblR5cGUuUkVBVVRIRU5USUNBVEU6XG4gICAgICAgICAgICBfYXNzZXJ0KGVycm9yLnVzZXIsIGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgICAgICAgICAgcmV0dXJuIFVzZXJDcmVkZW50aWFsSW1wbC5fZm9yT3BlcmF0aW9uKFxuICAgICAgICAgICAgICBlcnJvci51c2VyLFxuICAgICAgICAgICAgICBlcnJvci5vcGVyYXRpb25UeXBlLFxuICAgICAgICAgICAgICBpZFRva2VuUmVzcG9uc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIF9mYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIHJlc29sdmVTaWduSW4oXG4gICAgYXNzZXJ0aW9uRXh0ZXJuOiBNdWx0aUZhY3RvckFzc2VydGlvbkltcGxcbiAgKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbD4ge1xuICAgIGNvbnN0IGFzc2VydGlvbiA9IGFzc2VydGlvbkV4dGVybiBhcyBNdWx0aUZhY3RvckFzc2VydGlvbkltcGw7XG4gICAgcmV0dXJuIHRoaXMuc2lnbkluUmVzb2x2ZXIoYXNzZXJ0aW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIFByb3ZpZGVzIGEge0BsaW5rIE11bHRpRmFjdG9yUmVzb2x2ZXJ9IHN1aXRhYmxlIGZvciBjb21wbGV0aW9uIG9mIGFcbiAqIG11bHRpLWZhY3RvciBmbG93LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlcnJvciAtIFRoZSB7QGxpbmsgTXVsdGlGYWN0b3JFcnJvcn0gcmFpc2VkIGR1cmluZyBhIHNpZ24taW4sIG9yXG4gKiByZWF1dGhlbnRpY2F0aW9uIG9wZXJhdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNdWx0aUZhY3RvclJlc29sdmVyKFxuICBhdXRoOiBBdXRoLFxuICBlcnJvcjogTXVsdGlGYWN0b3JFcnJvclxuKTogTXVsdGlGYWN0b3JSZXNvbHZlciB7XG4gIGNvbnN0IGF1dGhNb2R1bGFyID0gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpO1xuICBjb25zdCBlcnJvckludGVybmFsID0gZXJyb3IgYXMgTXVsdGlGYWN0b3JFcnJvckludGVybmFsO1xuICBfYXNzZXJ0KFxuICAgIGVycm9yLmN1c3RvbURhdGEub3BlcmF0aW9uVHlwZSxcbiAgICBhdXRoTW9kdWxhcixcbiAgICBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SXG4gICk7XG4gIF9hc3NlcnQoXG4gICAgZXJyb3JJbnRlcm5hbC5jdXN0b21EYXRhLl9zZXJ2ZXJSZXNwb25zZT8ubWZhUGVuZGluZ0NyZWRlbnRpYWwsXG4gICAgYXV0aE1vZHVsYXIsXG4gICAgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUlxuICApO1xuXG4gIHJldHVybiBNdWx0aUZhY3RvclJlc29sdmVySW1wbC5fZnJvbUVycm9yKGF1dGhNb2R1bGFyLCBlcnJvckludGVybmFsKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEVuZHBvaW50LFxuICBIdHRwTWV0aG9kLFxuICBfYWRkVGlkSWZOZWNlc3NhcnksXG4gIF9wZXJmb3JtQXBpUmVxdWVzdFxufSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXF1ZXN0IH0gZnJvbSAnLi4vYXV0aGVudGljYXRpb24vc21zJztcbmltcG9ydCB7IEZpbmFsaXplTWZhUmVzcG9uc2UgfSBmcm9tICcuLi9hdXRoZW50aWNhdGlvbi9tZmEnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5cbi8qKlxuICogTUZBIEluZm8gYXMgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAqL1xuaW50ZXJmYWNlIEJhc2VNZmFFbnJvbGxtZW50IHtcbiAgbWZhRW5yb2xsbWVudElkOiBzdHJpbmc7XG4gIGVucm9sbGVkQXQ6IG51bWJlcjtcbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQW4gTUZBIHByb3ZpZGVkIGJ5IFNNUyB2ZXJpZmljYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGhvbmVNZmFFbnJvbGxtZW50IGV4dGVuZHMgQmFzZU1mYUVucm9sbG1lbnQge1xuICBwaG9uZUluZm86IHN0cmluZztcbn1cblxuLyoqXG4gKiBBbiBNRkEgcHJvdmlkZWQgYnkgVE9UUCAoVGltZS1iYXNlZCBPbmUgVGltZSBQYXNzd29yZCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG90cE1mYUVucm9sbG1lbnQgZXh0ZW5kcyBCYXNlTWZhRW5yb2xsbWVudCB7fVxuXG4vKipcbiAqIE1mYUVucm9sbG1lbnQgY2FuIGJlIGFueSBzdWJ0eXBlIG9mIEJhc2VNZmFFbnJvbGxtZW50LCBjdXJyZW50bHkgb25seSBQaG9uZU1mYUVucm9sbG1lbnQgYW5kIFRvdHBNZmFFbnJvbGxtZW50IGFyZSBzdXBwb3J0ZWQuXG4gKi9cbmV4cG9ydCB0eXBlIE1mYUVucm9sbG1lbnQgPSBQaG9uZU1mYUVucm9sbG1lbnQgfCBUb3RwTWZhRW5yb2xsbWVudDtcblxuZXhwb3J0IGludGVyZmFjZSBTdGFydFBob25lTWZhRW5yb2xsbWVudFJlcXVlc3Qge1xuICBpZFRva2VuOiBzdHJpbmc7XG4gIHBob25lRW5yb2xsbWVudEluZm86IHtcbiAgICBwaG9uZU51bWJlcjogc3RyaW5nO1xuICAgIHJlY2FwdGNoYVRva2VuOiBzdHJpbmc7XG4gIH07XG4gIHRlbmFudElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXJ0UGhvbmVNZmFFbnJvbGxtZW50UmVzcG9uc2Uge1xuICBwaG9uZVNlc3Npb25JbmZvOiB7XG4gICAgc2Vzc2lvbkluZm86IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0RW5yb2xsUGhvbmVNZmEoXG4gIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgcmVxdWVzdDogU3RhcnRQaG9uZU1mYUVucm9sbG1lbnRSZXF1ZXN0XG4pOiBQcm9taXNlPFN0YXJ0UGhvbmVNZmFFbnJvbGxtZW50UmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxcbiAgICBTdGFydFBob25lTWZhRW5yb2xsbWVudFJlcXVlc3QsXG4gICAgU3RhcnRQaG9uZU1mYUVucm9sbG1lbnRSZXNwb25zZVxuICA+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LlNUQVJUX01GQV9FTlJPTExNRU5ULFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmFsaXplUGhvbmVNZmFFbnJvbGxtZW50UmVxdWVzdCB7XG4gIGlkVG9rZW46IHN0cmluZztcbiAgcGhvbmVWZXJpZmljYXRpb25JbmZvOiBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXF1ZXN0O1xuICBkaXNwbGF5TmFtZT86IHN0cmluZyB8IG51bGw7XG4gIHRlbmFudElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmFsaXplUGhvbmVNZmFFbnJvbGxtZW50UmVzcG9uc2VcbiAgZXh0ZW5kcyBGaW5hbGl6ZU1mYVJlc3BvbnNlIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5hbGl6ZUVucm9sbFBob25lTWZhKFxuICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gIHJlcXVlc3Q6IEZpbmFsaXplUGhvbmVNZmFFbnJvbGxtZW50UmVxdWVzdFxuKTogUHJvbWlzZTxGaW5hbGl6ZVBob25lTWZhRW5yb2xsbWVudFJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8XG4gICAgRmluYWxpemVQaG9uZU1mYUVucm9sbG1lbnRSZXF1ZXN0LFxuICAgIEZpbmFsaXplUGhvbmVNZmFFbnJvbGxtZW50UmVzcG9uc2VcbiAgPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5GSU5BTElaRV9NRkFfRU5ST0xMTUVOVCxcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlcXVlc3Qge1xuICBpZFRva2VuOiBzdHJpbmc7XG4gIHRvdHBFbnJvbGxtZW50SW5mbzoge307XG4gIHRlbmFudElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXJ0VG90cE1mYUVucm9sbG1lbnRSZXNwb25zZSB7XG4gIHRvdHBTZXNzaW9uSW5mbzoge1xuICAgIHNoYXJlZFNlY3JldEtleTogc3RyaW5nO1xuICAgIHZlcmlmaWNhdGlvbkNvZGVMZW5ndGg6IG51bWJlcjtcbiAgICBoYXNoaW5nQWxnb3JpdGhtOiBzdHJpbmc7XG4gICAgcGVyaW9kU2VjOiBudW1iZXI7XG4gICAgc2Vzc2lvbkluZm86IHN0cmluZztcbiAgICBmaW5hbGl6ZUVucm9sbG1lbnRUaW1lOiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydEVucm9sbFRvdHBNZmEoXG4gIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgcmVxdWVzdDogU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlcXVlc3Rcbik6IFByb21pc2U8U3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8XG4gICAgU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlcXVlc3QsXG4gICAgU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU1RBUlRfTUZBX0VOUk9MTE1FTlQsXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG90cFZlcmlmaWNhdGlvbkluZm8ge1xuICBzZXNzaW9uSW5mbzogc3RyaW5nO1xuICB2ZXJpZmljYXRpb25Db2RlOiBzdHJpbmc7XG59XG5leHBvcnQgaW50ZXJmYWNlIEZpbmFsaXplVG90cE1mYUVucm9sbG1lbnRSZXF1ZXN0IHtcbiAgaWRUb2tlbjogc3RyaW5nO1xuICB0b3RwVmVyaWZpY2F0aW9uSW5mbzogVG90cFZlcmlmaWNhdGlvbkluZm87XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nIHwgbnVsbDtcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluYWxpemVUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlXG4gIGV4dGVuZHMgRmluYWxpemVNZmFSZXNwb25zZSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gZmluYWxpemVFbnJvbGxUb3RwTWZhKFxuICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gIHJlcXVlc3Q6IEZpbmFsaXplVG90cE1mYUVucm9sbG1lbnRSZXF1ZXN0XG4pOiBQcm9taXNlPEZpbmFsaXplVG90cE1mYUVucm9sbG1lbnRSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PFxuICAgIEZpbmFsaXplVG90cE1mYUVucm9sbG1lbnRSZXF1ZXN0LFxuICAgIEZpbmFsaXplVG90cE1mYUVucm9sbG1lbnRSZXNwb25zZVxuICA+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LkZJTkFMSVpFX01GQV9FTlJPTExNRU5ULFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdpdGhkcmF3TWZhUmVxdWVzdCB7XG4gIGlkVG9rZW46IHN0cmluZztcbiAgbWZhRW5yb2xsbWVudElkOiBzdHJpbmc7XG4gIHRlbmFudElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdpdGhkcmF3TWZhUmVzcG9uc2UgZXh0ZW5kcyBGaW5hbGl6ZU1mYVJlc3BvbnNlIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoZHJhd01mYShcbiAgYXV0aDogQXV0aEludGVybmFsLFxuICByZXF1ZXN0OiBXaXRoZHJhd01mYVJlcXVlc3Rcbik6IFByb21pc2U8V2l0aGRyYXdNZmFSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PFdpdGhkcmF3TWZhUmVxdWVzdCwgV2l0aGRyYXdNZmFSZXNwb25zZT4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuV0lUSERSQVdfTUZBLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7XG4gIE11bHRpRmFjdG9yQXNzZXJ0aW9uLFxuICBNdWx0aUZhY3RvckluZm8sXG4gIE11bHRpRmFjdG9yU2Vzc2lvbixcbiAgTXVsdGlGYWN0b3JVc2VyLFxuICBVc2VyXG59IGZyb20gJy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IHdpdGhkcmF3TWZhIH0gZnJvbSAnLi4vYXBpL2FjY291bnRfbWFuYWdlbWVudC9tZmEnO1xuaW1wb3J0IHsgX2xvZ291dElmSW52YWxpZGF0ZWQgfSBmcm9tICcuLi9jb3JlL3VzZXIvaW52YWxpZGF0aW9uJztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCB9IGZyb20gJy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIH0gZnJvbSAnLi9tZmFfYXNzZXJ0aW9uJztcbmltcG9ydCB7IE11bHRpRmFjdG9ySW5mb0ltcGwgfSBmcm9tICcuL21mYV9pbmZvJztcbmltcG9ydCB7IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwgfSBmcm9tICcuL21mYV9zZXNzaW9uJztcbmltcG9ydCB7IGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuZXhwb3J0IGNsYXNzIE11bHRpRmFjdG9yVXNlckltcGwgaW1wbGVtZW50cyBNdWx0aUZhY3RvclVzZXIge1xuICBlbnJvbGxlZEZhY3RvcnM6IE11bHRpRmFjdG9ySW5mb1tdID0gW107XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihyZWFkb25seSB1c2VyOiBVc2VySW50ZXJuYWwpIHtcbiAgICB1c2VyLl9vblJlbG9hZCh1c2VySW5mbyA9PiB7XG4gICAgICBpZiAodXNlckluZm8ubWZhSW5mbykge1xuICAgICAgICB0aGlzLmVucm9sbGVkRmFjdG9ycyA9IHVzZXJJbmZvLm1mYUluZm8ubWFwKGVucm9sbG1lbnQgPT5cbiAgICAgICAgICBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UodXNlci5hdXRoLCBlbnJvbGxtZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIF9mcm9tVXNlcih1c2VyOiBVc2VySW50ZXJuYWwpOiBNdWx0aUZhY3RvclVzZXJJbXBsIHtcbiAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yVXNlckltcGwodXNlcik7XG4gIH1cblxuICBhc3luYyBnZXRTZXNzaW9uKCk6IFByb21pc2U8TXVsdGlGYWN0b3JTZXNzaW9uPiB7XG4gICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21JZHRva2VuKFxuICAgICAgYXdhaXQgdGhpcy51c2VyLmdldElkVG9rZW4oKSxcbiAgICAgIHRoaXMudXNlci5hdXRoXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGVucm9sbChcbiAgICBhc3NlcnRpb25FeHRlcm46IE11bHRpRmFjdG9yQXNzZXJ0aW9uLFxuICAgIGRpc3BsYXlOYW1lPzogc3RyaW5nIHwgbnVsbFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBhc3NlcnRpb24gPSBhc3NlcnRpb25FeHRlcm4gYXMgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsO1xuICAgIGNvbnN0IHNlc3Npb24gPSAoYXdhaXQgdGhpcy5nZXRTZXNzaW9uKCkpIGFzIE11bHRpRmFjdG9yU2Vzc2lvbkltcGw7XG4gICAgY29uc3QgZmluYWxpemVNZmFSZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKFxuICAgICAgdGhpcy51c2VyLFxuICAgICAgYXNzZXJ0aW9uLl9wcm9jZXNzKHRoaXMudXNlci5hdXRoLCBzZXNzaW9uLCBkaXNwbGF5TmFtZSlcbiAgICApO1xuICAgIC8vIE5ldyB0b2tlbnMgd2lsbCBiZSBpc3N1ZWQgYWZ0ZXIgZW5yb2xsbWVudCBvZiB0aGUgbmV3IHNlY29uZCBmYWN0b3JzLlxuICAgIC8vIFRoZXkgbmVlZCB0byBiZSB1cGRhdGVkIG9uIHRoZSB1c2VyLlxuICAgIGF3YWl0IHRoaXMudXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkoZmluYWxpemVNZmFSZXNwb25zZSk7XG4gICAgLy8gVGhlIHVzZXIgbmVlZHMgdG8gYmUgcmVsb2FkZWQgdG8gZ2V0IHRoZSBuZXcgbXVsdGktZmFjdG9yIGluZm9ybWF0aW9uXG4gICAgLy8gZnJvbSBzZXJ2ZXIuIFVTRVJfUkVMT0FERUQgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgYW5kIGBlbnJvbGxlZEZhY3RvcnNgXG4gICAgLy8gd2lsbCBiZSB1cGRhdGVkLlxuICAgIHJldHVybiB0aGlzLnVzZXIucmVsb2FkKCk7XG4gIH1cblxuICBhc3luYyB1bmVucm9sbChpbmZvT3JVaWQ6IE11bHRpRmFjdG9ySW5mbyB8IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1mYUVucm9sbG1lbnRJZCA9XG4gICAgICB0eXBlb2YgaW5mb09yVWlkID09PSAnc3RyaW5nJyA/IGluZm9PclVpZCA6IGluZm9PclVpZC51aWQ7XG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHRoaXMudXNlci5nZXRJZFRva2VuKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGlkVG9rZW5SZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKFxuICAgICAgICB0aGlzLnVzZXIsXG4gICAgICAgIHdpdGhkcmF3TWZhKHRoaXMudXNlci5hdXRoLCB7XG4gICAgICAgICAgaWRUb2tlbixcbiAgICAgICAgICBtZmFFbnJvbGxtZW50SWRcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICAvLyBSZW1vdmUgdGhlIHNlY29uZCBmYWN0b3IgZnJvbSB0aGUgdXNlcidzIGxpc3QuXG4gICAgICB0aGlzLmVucm9sbGVkRmFjdG9ycyA9IHRoaXMuZW5yb2xsZWRGYWN0b3JzLmZpbHRlcihcbiAgICAgICAgKHsgdWlkIH0pID0+IHVpZCAhPT0gbWZhRW5yb2xsbWVudElkXG4gICAgICApO1xuICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGJhY2tlbmQgZGVjaWRlZCB0byByZXZva2UgdGhlIHVzZXIncyBzZXNzaW9uLFxuICAgICAgLy8gdGhlIHRva2VuUmVzcG9uc2UgbWF5IGJlIGVtcHR5LiBJZiB0aGUgdG9rZW5zIHdlcmUgbm90IHVwZGF0ZWQgKGFuZCB0aGV5XG4gICAgICAvLyBhcmUgbm93IGludmFsaWQpLCByZWxvYWRpbmcgdGhlIHVzZXIgd2lsbCBkaXNjb3ZlciB0aGlzIGFuZCBpbnZhbGlkYXRlXG4gICAgICAvLyB0aGUgdXNlcidzIHN0YXRlIGFjY29yZGluZ2x5LlxuICAgICAgYXdhaXQgdGhpcy51c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShpZFRva2VuUmVzcG9uc2UpO1xuICAgICAgYXdhaXQgdGhpcy51c2VyLnJlbG9hZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG11bHRpRmFjdG9yVXNlckNhY2hlID0gbmV3IFdlYWtNYXA8VXNlciwgTXVsdGlGYWN0b3JVc2VyPigpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgTXVsdGlGYWN0b3JVc2VyfSBjb3JyZXNwb25kaW5nIHRvIHRoZSB1c2VyLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGlzIHVzZWQgdG8gYWNjZXNzIGFsbCBtdWx0aS1mYWN0b3IgcHJvcGVydGllcyBhbmQgb3BlcmF0aW9ucyByZWxhdGVkIHRvIHRoZSB1c2VyLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlGYWN0b3IodXNlcjogVXNlcik6IE11bHRpRmFjdG9yVXNlciB7XG4gIGNvbnN0IHVzZXJNb2R1bGFyID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICBpZiAoIW11bHRpRmFjdG9yVXNlckNhY2hlLmhhcyh1c2VyTW9kdWxhcikpIHtcbiAgICBtdWx0aUZhY3RvclVzZXJDYWNoZS5zZXQoXG4gICAgICB1c2VyTW9kdWxhcixcbiAgICAgIE11bHRpRmFjdG9yVXNlckltcGwuX2Zyb21Vc2VyKHVzZXJNb2R1bGFyIGFzIFVzZXJJbnRlcm5hbClcbiAgICApO1xuICB9XG4gIHJldHVybiBtdWx0aUZhY3RvclVzZXJDYWNoZS5nZXQodXNlck1vZHVsYXIpITtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBQZXJzaXN0ZW5jZSB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBlbnVtIFBlcnNpc3RlbmNlVHlwZSB7XG4gIFNFU1NJT04gPSAnU0VTU0lPTicsXG4gIExPQ0FMID0gJ0xPQ0FMJyxcbiAgTk9ORSA9ICdOT05FJ1xufVxuXG5leHBvcnQgdHlwZSBQZXJzaXN0ZWRCbG9iID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5zdGFudGlhdG9yPFQ+IHtcbiAgKGJsb2I6IFBlcnNpc3RlZEJsb2IpOiBUO1xufVxuXG5leHBvcnQgdHlwZSBQZXJzaXN0ZW5jZVZhbHVlID0gUGVyc2lzdGVkQmxvYiB8IHN0cmluZztcblxuZXhwb3J0IGNvbnN0IFNUT1JBR0VfQVZBSUxBQkxFX0tFWSA9ICdfX3Nhayc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RvcmFnZUV2ZW50TGlzdGVuZXIge1xuICAodmFsdWU6IFBlcnNpc3RlbmNlVmFsdWUgfCBudWxsKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQZXJzaXN0ZW5jZUludGVybmFsIGV4dGVuZHMgUGVyc2lzdGVuY2Uge1xuICB0eXBlOiBQZXJzaXN0ZW5jZVR5cGU7XG4gIF9pc0F2YWlsYWJsZSgpOiBQcm9taXNlPGJvb2xlYW4+O1xuICBfc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogUGVyc2lzdGVuY2VWYWx1ZSk6IFByb21pc2U8dm9pZD47XG4gIF9nZXQ8VCBleHRlbmRzIFBlcnNpc3RlbmNlVmFsdWU+KGtleTogc3RyaW5nKTogUHJvbWlzZTxUIHwgbnVsbD47XG4gIF9yZW1vdmUoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuICBfYWRkTGlzdGVuZXIoa2V5OiBzdHJpbmcsIGxpc3RlbmVyOiBTdG9yYWdlRXZlbnRMaXN0ZW5lcik6IHZvaWQ7XG4gIF9yZW1vdmVMaXN0ZW5lcihrZXk6IHN0cmluZywgbGlzdGVuZXI6IFN0b3JhZ2VFdmVudExpc3RlbmVyKTogdm9pZDtcbiAgLy8gU2hvdWxkIHRoaXMgcGVyc2lzdGVuY2UgYWxsb3cgbWlncmF0aW9uIHVwIHRoZSBjaG9zZW4gaGllcmFyY2h5P1xuICBfc2hvdWxkQWxsb3dNaWdyYXRpb24/OiBib29sZWFuO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgUGVyc2lzdGVuY2VWYWx1ZSxcbiAgU1RPUkFHRV9BVkFJTEFCTEVfS0VZLFxuICBQZXJzaXN0ZW5jZVR5cGVcbn0gZnJvbSAnLi4vLi4vY29yZS9wZXJzaXN0ZW5jZSc7XG5cbi8vIFRoZXJlIGFyZSB0d28gZGlmZmVyZW50IGJyb3dzZXIgcGVyc2lzdGVuY2UgdHlwZXM6IGxvY2FsIGFuZCBzZXNzaW9uLlxuLy8gQm90aCBoYXZlIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGJ1dCB1c2UgYSBkaWZmZXJlbnQgdW5kZXJseWluZyBzdG9yYWdlXG4vLyBvYmplY3QuXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCcm93c2VyUGVyc2lzdGVuY2VDbGFzcyB7XG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgc3RvcmFnZVJldHJpZXZlcjogKCkgPT4gU3RvcmFnZSxcbiAgICByZWFkb25seSB0eXBlOiBQZXJzaXN0ZW5jZVR5cGVcbiAgKSB7fVxuXG4gIF9pc0F2YWlsYWJsZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLnN0b3JhZ2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0FWQUlMQUJMRV9LRVksICcxJyk7XG4gICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0FWQUlMQUJMRV9LRVkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9zZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBQZXJzaXN0ZW5jZVZhbHVlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIF9nZXQ8VCBleHRlbmRzIFBlcnNpc3RlbmNlVmFsdWU+KGtleTogc3RyaW5nKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoanNvbiA/IEpTT04ucGFyc2UoanNvbikgOiBudWxsKTtcbiAgfVxuXG4gIF9yZW1vdmUoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgc3RvcmFnZSgpOiBTdG9yYWdlIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUmV0cmlldmVyKCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFBlcnNpc3RlbmNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHsgZ2V0VUEgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQge1xuICBfaXNTYWZhcmksXG4gIF9pc0lPUyxcbiAgX2lzSWZyYW1lLFxuICBfaXNNb2JpbGVCcm93c2VyLFxuICBfaXNJRTEwXG59IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9icm93c2VyJztcbmltcG9ydCB7XG4gIFBlcnNpc3RlbmNlSW50ZXJuYWwgYXMgSW50ZXJuYWxQZXJzaXN0ZW5jZSxcbiAgUGVyc2lzdGVuY2VUeXBlLFxuICBQZXJzaXN0ZW5jZVZhbHVlLFxuICBTdG9yYWdlRXZlbnRMaXN0ZW5lclxufSBmcm9tICcuLi8uLi9jb3JlL3BlcnNpc3RlbmNlJztcbmltcG9ydCB7IEJyb3dzZXJQZXJzaXN0ZW5jZUNsYXNzIH0gZnJvbSAnLi9icm93c2VyJztcblxuZnVuY3Rpb24gX2lmcmFtZUNhbm5vdFN5bmNXZWJTdG9yYWdlKCk6IGJvb2xlYW4ge1xuICBjb25zdCB1YSA9IGdldFVBKCk7XG4gIHJldHVybiBfaXNTYWZhcmkodWEpIHx8IF9pc0lPUyh1YSk7XG59XG5cbi8vIFRoZSBwb2xsaW5nIHBlcmlvZCBpbiBjYXNlIGV2ZW50cyBhcmUgbm90IHN1cHBvcnRlZFxuZXhwb3J0IGNvbnN0IF9QT0xMSU5HX0lOVEVSVkFMX01TID0gMTAwMDtcblxuLy8gVGhlIElFIDEwIGxvY2FsU3RvcmFnZSBjcm9zcyB0YWIgc3luY2hyb25pemF0aW9uIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuY29uc3QgSUUxMF9MT0NBTF9TVE9SQUdFX1NZTkNfREVMQVkgPSAxMDtcblxuY2xhc3MgQnJvd3NlckxvY2FsUGVyc2lzdGVuY2VcbiAgZXh0ZW5kcyBCcm93c2VyUGVyc2lzdGVuY2VDbGFzc1xuICBpbXBsZW1lbnRzIEludGVybmFsUGVyc2lzdGVuY2VcbntcbiAgc3RhdGljIHR5cGU6ICdMT0NBTCcgPSAnTE9DQUwnO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCgpID0+IHdpbmRvdy5sb2NhbFN0b3JhZ2UsIFBlcnNpc3RlbmNlVHlwZS5MT0NBTCk7XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IGJvdW5kRXZlbnRIYW5kbGVyID0gKFxuICAgIGV2ZW50OiBTdG9yYWdlRXZlbnQsXG4gICAgcG9sbD86IGJvb2xlYW5cbiAgKTogdm9pZCA9PiB0aGlzLm9uU3RvcmFnZUV2ZW50KGV2ZW50LCBwb2xsKTtcbiAgcHJpdmF0ZSByZWFkb25seSBsaXN0ZW5lcnM6IFJlY29yZDxzdHJpbmcsIFNldDxTdG9yYWdlRXZlbnRMaXN0ZW5lcj4+ID0ge307XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9jYWxDYWNoZTogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVsbD4gPSB7fTtcbiAgLy8gc2V0VGltZW91dCByZXR1cm4gdmFsdWUgaXMgcGxhdGZvcm0gc3BlY2lmaWNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgcHJpdmF0ZSBwb2xsVGltZXI6IGFueSB8IG51bGwgPSBudWxsO1xuXG4gIC8vIFNhZmFyaSBvciBpT1MgYnJvd3NlciBhbmQgZW1iZWRkZWQgaW4gYW4gaWZyYW1lLlxuICBwcml2YXRlIHJlYWRvbmx5IHNhZmFyaUxvY2FsU3RvcmFnZU5vdFN5bmNlZCA9XG4gICAgX2lmcmFtZUNhbm5vdFN5bmNXZWJTdG9yYWdlKCkgJiYgX2lzSWZyYW1lKCk7XG4gIC8vIFdoZXRoZXIgdG8gdXNlIHBvbGxpbmcgaW5zdGVhZCBvZiBkZXBlbmRpbmcgb24gd2luZG93IGV2ZW50c1xuICBwcml2YXRlIHJlYWRvbmx5IGZhbGxiYWNrVG9Qb2xsaW5nID0gX2lzTW9iaWxlQnJvd3NlcigpO1xuICByZWFkb25seSBfc2hvdWxkQWxsb3dNaWdyYXRpb24gPSB0cnVlO1xuXG4gIHByaXZhdGUgZm9yQWxsQ2hhbmdlZEtleXMoXG4gICAgY2I6IChrZXk6IHN0cmluZywgb2xkVmFsdWU6IHN0cmluZyB8IG51bGwsIG5ld1ZhbHVlOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkXG4gICk6IHZvaWQge1xuICAgIC8vIENoZWNrIGFsbCBrZXlzIHdpdGggbGlzdGVuZXJzIG9uIHRoZW0uXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnMpKSB7XG4gICAgICAvLyBHZXQgdmFsdWUgZnJvbSBsb2NhbFN0b3JhZ2UuXG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMubG9jYWxDYWNoZVtrZXldO1xuICAgICAgLy8gSWYgbG9jYWwgbWFwIHZhbHVlIGRvZXMgbm90IG1hdGNoLCB0cmlnZ2VyIGxpc3RlbmVyIHdpdGggc3RvcmFnZSBldmVudC5cbiAgICAgIC8vIERpZmZlcmVudGlhdGUgdGhpcyBzaW11bGF0ZWQgZXZlbnQgZnJvbSB0aGUgcmVhbCBzdG9yYWdlIGV2ZW50LlxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICBjYihrZXksIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvblN0b3JhZ2VFdmVudChldmVudDogU3RvcmFnZUV2ZW50LCBwb2xsID0gZmFsc2UpOiB2b2lkIHtcbiAgICAvLyBLZXkgd291bGQgYmUgbnVsbCBpbiBzb21lIHNpdHVhdGlvbnMsIGxpa2Ugd2hlbiBsb2NhbFN0b3JhZ2UgaXMgY2xlYXJlZFxuICAgIGlmICghZXZlbnQua2V5KSB7XG4gICAgICB0aGlzLmZvckFsbENoYW5nZWRLZXlzKFxuICAgICAgICAoa2V5OiBzdHJpbmcsIF9vbGRWYWx1ZTogc3RyaW5nIHwgbnVsbCwgbmV3VmFsdWU6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSBldmVudC5rZXk7XG5cbiAgICAvLyBDaGVjayB0aGUgbWVjaGFuaXNtIGhvdyB0aGlzIGV2ZW50IHdhcyBkZXRlY3RlZC5cbiAgICAvLyBUaGUgZmlyc3QgZXZlbnQgd2lsbCBkaWN0YXRlIHRoZSBtZWNoYW5pc20gdG8gYmUgdXNlZC5cbiAgICBpZiAocG9sbCkge1xuICAgICAgLy8gRW52aXJvbm1lbnQgZGV0ZWN0cyBzdG9yYWdlIGNoYW5nZXMgdmlhIHBvbGxpbmcuXG4gICAgICAvLyBSZW1vdmUgc3RvcmFnZSBldmVudCBsaXN0ZW5lciB0byBwcmV2ZW50IHBvc3NpYmxlIGV2ZW50IGR1cGxpY2F0aW9uLlxuICAgICAgdGhpcy5kZXRhY2hMaXN0ZW5lcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbnZpcm9ubWVudCBkZXRlY3RzIHN0b3JhZ2UgY2hhbmdlcyB2aWEgc3RvcmFnZSBldmVudCBsaXN0ZW5lci5cbiAgICAgIC8vIFJlbW92ZSBwb2xsaW5nIGxpc3RlbmVyIHRvIHByZXZlbnQgcG9zc2libGUgZXZlbnQgZHVwbGljYXRpb24uXG4gICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgfVxuXG4gICAgLy8gU2FmYXJpIGVtYmVkZGVkIGlmcmFtZS4gU3RvcmFnZSBldmVudCB3aWxsIHRyaWdnZXIgd2l0aCB0aGUgZGVsdGFcbiAgICAvLyBjaGFuZ2VzIGJ1dCBubyBjaGFuZ2VzIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgaWZyYW1lIGxvY2FsU3RvcmFnZS5cbiAgICBpZiAodGhpcy5zYWZhcmlMb2NhbFN0b3JhZ2VOb3RTeW5jZWQpIHtcbiAgICAgIC8vIEdldCBjdXJyZW50IGlmcmFtZSBwYWdlIHZhbHVlLlxuICAgICAgY29uc3Qgc3RvcmVkVmFsdWUgPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgLy8gVmFsdWUgbm90IHN5bmNocm9uaXplZCwgc3luY2hyb25pemUgbWFudWFsbHkuXG4gICAgICBpZiAoZXZlbnQubmV3VmFsdWUgIT09IHN0b3JlZFZhbHVlKSB7XG4gICAgICAgIGlmIChldmVudC5uZXdWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFZhbHVlIGNoYW5nZWQgZnJvbSBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgZXZlbnQubmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEN1cnJlbnQgdmFsdWUgZGVsZXRlZC5cbiAgICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxDYWNoZVtrZXldID09PSBldmVudC5uZXdWYWx1ZSAmJiAhcG9sbCkge1xuICAgICAgICAvLyBBbHJlYWR5IGRldGVjdGVkIGFuZCBwcm9jZXNzZWQsIGRvIG5vdCB0cmlnZ2VyIGxpc3RlbmVycyBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRyaWdnZXJMaXN0ZW5lcnMgPSAoKTogdm9pZCA9PiB7XG4gICAgICAvLyBLZWVwIGxvY2FsIG1hcCB1cCB0byBkYXRlIGluIGNhc2Ugc3RvcmFnZSBldmVudCBpcyB0cmlnZ2VyZWQgYmVmb3JlXG4gICAgICAvLyBwb2xsLlxuICAgICAgY29uc3Qgc3RvcmVkVmFsdWUgPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgaWYgKCFwb2xsICYmIHRoaXMubG9jYWxDYWNoZVtrZXldID09PSBzdG9yZWRWYWx1ZSkge1xuICAgICAgICAvLyBSZWFsIHN0b3JhZ2UgZXZlbnQgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBkZXRlY3RlZCwgZG8gbm90aGluZy5cbiAgICAgICAgLy8gVGhpcyBzZWVtcyB0byB0cmlnZ2VyIGluIHNvbWUgSUUgYnJvd3NlcnMgZm9yIHNvbWUgcmVhc29uLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhrZXksIHN0b3JlZFZhbHVlKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc3RvcmVkVmFsdWUgPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGlmIChcbiAgICAgIF9pc0lFMTAoKSAmJlxuICAgICAgc3RvcmVkVmFsdWUgIT09IGV2ZW50Lm5ld1ZhbHVlICYmXG4gICAgICBldmVudC5uZXdWYWx1ZSAhPT0gZXZlbnQub2xkVmFsdWVcbiAgICApIHtcbiAgICAgIC8vIElFIDEwIGhhcyB0aGlzIHdlaXJkIGJ1ZyB3aGVyZSBhIHN0b3JhZ2UgZXZlbnQgd291bGQgdHJpZ2dlciB3aXRoIHRoZVxuICAgICAgLy8gY29ycmVjdCBrZXksIG9sZFZhbHVlIGFuZCBuZXdWYWx1ZSBidXQgbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSBkb2VzXG4gICAgICAvLyBub3QgeWllbGQgdGhlIHVwZGF0ZWQgdmFsdWUgdW50aWwgYSBmZXcgbWlsbGlzZWNvbmRzLiBUaGlzIGVuc3VyZXNcbiAgICAgIC8vIHRoaXMgcmVjb3ZlcnMgZnJvbSB0aGF0IHNpdHVhdGlvbi5cbiAgICAgIHNldFRpbWVvdXQodHJpZ2dlckxpc3RlbmVycywgSUUxMF9MT0NBTF9TVE9SQUdFX1NZTkNfREVMQVkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBub3RpZnlMaXN0ZW5lcnMoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBudWxsKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbENhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1trZXldO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgQXJyYXkuZnJvbShsaXN0ZW5lcnMpKSB7XG4gICAgICAgIGxpc3RlbmVyKHZhbHVlID8gSlNPTi5wYXJzZSh2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGFydFBvbGxpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5zdG9wUG9sbGluZygpO1xuXG4gICAgdGhpcy5wb2xsVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLmZvckFsbENoYW5nZWRLZXlzKFxuICAgICAgICAoa2V5OiBzdHJpbmcsIG9sZFZhbHVlOiBzdHJpbmcgfCBudWxsLCBuZXdWYWx1ZTogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICAgICAgICAgIHRoaXMub25TdG9yYWdlRXZlbnQoXG4gICAgICAgICAgICBuZXcgU3RvcmFnZUV2ZW50KCdzdG9yYWdlJywge1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgICAgICBuZXdWYWx1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKiBwb2xsICovIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sIF9QT0xMSU5HX0lOVEVSVkFMX01TKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RvcFBvbGxpbmcoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucG9sbFRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMucG9sbFRpbWVyKTtcbiAgICAgIHRoaXMucG9sbFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGF0dGFjaExpc3RlbmVyKCk6IHZvaWQge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgdGhpcy5ib3VuZEV2ZW50SGFuZGxlcik7XG4gIH1cblxuICBwcml2YXRlIGRldGFjaExpc3RlbmVyKCk6IHZvaWQge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgdGhpcy5ib3VuZEV2ZW50SGFuZGxlcik7XG4gIH1cblxuICBfYWRkTGlzdGVuZXIoa2V5OiBzdHJpbmcsIGxpc3RlbmVyOiBTdG9yYWdlRXZlbnRMaXN0ZW5lcik6IHZvaWQge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVycykubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBXaGV0aGVyIGJyb3dzZXIgY2FuIGRldGVjdCBzdG9yYWdlIGV2ZW50IHdoZW4gaXQgaGFkIGFscmVhZHkgYmVlbiBwdXNoZWQgdG8gdGhlIGJhY2tncm91bmQuXG4gICAgICAvLyBUaGlzIG1heSBoYXBwZW4gaW4gc29tZSBtb2JpbGUgYnJvd3NlcnMuIEEgbG9jYWxTdG9yYWdlIGNoYW5nZSBpbiB0aGUgZm9yZWdyb3VuZCB3aW5kb3dcbiAgICAgIC8vIHdpbGwgbm90IGJlIGRldGVjdGVkIGluIHRoZSBiYWNrZ3JvdW5kIHdpbmRvdyB2aWEgdGhlIHN0b3JhZ2UgZXZlbnQuXG4gICAgICAvLyBUaGlzIHdhcyBkZXRlY3RlZCBpbiBpT1MgNy54IG1vYmlsZSBicm93c2Vyc1xuICAgICAgaWYgKHRoaXMuZmFsbGJhY2tUb1BvbGxpbmcpIHtcbiAgICAgICAgdGhpcy5zdGFydFBvbGxpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXR0YWNoTGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1trZXldKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc1trZXldID0gbmV3IFNldCgpO1xuICAgICAgLy8gUG9wdWxhdGUgdGhlIGNhY2hlIHRvIGF2b2lkIHNwdXJpb3VzbHkgdHJpZ2dlcmluZyBvbiBmaXJzdCBwb2xsLlxuICAgICAgdGhpcy5sb2NhbENhY2hlW2tleV0gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVyc1trZXldLmFkZChsaXN0ZW5lcik7XG4gIH1cblxuICBfcmVtb3ZlTGlzdGVuZXIoa2V5OiBzdHJpbmcsIGxpc3RlbmVyOiBTdG9yYWdlRXZlbnRMaXN0ZW5lcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmxpc3RlbmVyc1trZXldKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc1trZXldLmRlbGV0ZShsaXN0ZW5lcik7XG5cbiAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1trZXldLnNpemUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMubGlzdGVuZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZGV0YWNoTGlzdGVuZXIoKTtcbiAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgbG9jYWwgY2FjaGUgb24gYmFzZSBvcGVyYXRpb25zOlxuXG4gIGFzeW5jIF9zZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBQZXJzaXN0ZW5jZVZhbHVlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgc3VwZXIuX3NldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLmxvY2FsQ2FjaGVba2V5XSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxuXG4gIGFzeW5jIF9nZXQ8VCBleHRlbmRzIFBlcnNpc3RlbmNlVmFsdWU+KGtleTogc3RyaW5nKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgc3VwZXIuX2dldDxUPihrZXkpO1xuICAgIHRoaXMubG9jYWxDYWNoZVtrZXldID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGFzeW5jIF9yZW1vdmUoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBzdXBlci5fcmVtb3ZlKGtleSk7XG4gICAgZGVsZXRlIHRoaXMubG9jYWxDYWNoZVtrZXldO1xuICB9XG59XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFBlcnNpc3RlbmNlfSBvZiB0eXBlIGBMT0NBTGAgdXNpbmcgYGxvY2FsU3RvcmFnZWBcbiAqIGZvciB0aGUgdW5kZXJseWluZyBzdG9yYWdlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlOiBQZXJzaXN0ZW5jZSA9IEJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUGVyc2lzdGVuY2UgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQge1xuICBQZXJzaXN0ZW5jZUludGVybmFsIGFzIEludGVybmFsUGVyc2lzdGVuY2UsXG4gIFBlcnNpc3RlbmNlVHlwZSxcbiAgU3RvcmFnZUV2ZW50TGlzdGVuZXJcbn0gZnJvbSAnLi4vLi4vY29yZS9wZXJzaXN0ZW5jZSc7XG5pbXBvcnQgeyBCcm93c2VyUGVyc2lzdGVuY2VDbGFzcyB9IGZyb20gJy4vYnJvd3Nlcic7XG5cbmNsYXNzIEJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2VcbiAgZXh0ZW5kcyBCcm93c2VyUGVyc2lzdGVuY2VDbGFzc1xuICBpbXBsZW1lbnRzIEludGVybmFsUGVyc2lzdGVuY2VcbntcbiAgc3RhdGljIHR5cGU6ICdTRVNTSU9OJyA9ICdTRVNTSU9OJztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigoKSA9PiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UsIFBlcnNpc3RlbmNlVHlwZS5TRVNTSU9OKTtcbiAgfVxuXG4gIF9hZGRMaXN0ZW5lcihfa2V5OiBzdHJpbmcsIF9saXN0ZW5lcjogU3RvcmFnZUV2ZW50TGlzdGVuZXIpOiB2b2lkIHtcbiAgICAvLyBMaXN0ZW5lcnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHNlc3Npb24gc3RvcmFnZSBzaW5jZSBpdCBjYW5ub3QgYmUgc2hhcmVkIGFjcm9zcyB3aW5kb3dzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgX3JlbW92ZUxpc3RlbmVyKF9rZXk6IHN0cmluZywgX2xpc3RlbmVyOiBTdG9yYWdlRXZlbnRMaXN0ZW5lcik6IHZvaWQge1xuICAgIC8vIExpc3RlbmVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3Igc2Vzc2lvbiBzdG9yYWdlIHNpbmNlIGl0IGNhbm5vdCBiZSBzaGFyZWQgYWNyb3NzIHdpbmRvd3NcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgUGVyc2lzdGVuY2V9IG9mIGBTRVNTSU9OYCB1c2luZyBgc2Vzc2lvblN0b3JhZ2VgXG4gKiBmb3IgdGhlIHVuZGVybHlpbmcgc3RvcmFnZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlOiBQZXJzaXN0ZW5jZSA9IEJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2U7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogVE9ETzogcmVtb3ZlIHRoaXMgb25jZSB0c2xpYiBoYXMgYSBwb2x5ZmlsbCBmb3IgUHJvbWlzZS5hbGxTZXR0bGVkICovXG5pbnRlcmZhY2UgUHJvbWlzZUZ1bGZpbGxlZFJlc3VsdDxUPiB7XG4gIGZ1bGZpbGxlZDogdHJ1ZTtcbiAgdmFsdWU6IFQ7XG59XG5cbmludGVyZmFjZSBQcm9taXNlUmVqZWN0ZWRSZXN1bHQge1xuICBmdWxmaWxsZWQ6IGZhbHNlO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICByZWFzb246IGFueTtcbn1cblxuZXhwb3J0IHR5cGUgUHJvbWlzZVNldHRsZWRSZXN1bHQ8VD4gPVxuICB8IFByb21pc2VGdWxmaWxsZWRSZXN1bHQ8VD5cbiAgfCBQcm9taXNlUmVqZWN0ZWRSZXN1bHQ7XG5cbi8qKlxuICogU2hpbSBmb3IgUHJvbWlzZS5hbGxTZXR0bGVkLCBub3RlIHRoZSBzbGlnaHRseSBkaWZmZXJlbnQgZm9ybWF0IG9mIGBmdWxmaWxsZWRgIHZzIGBzdGF0dXNgLlxuICpcbiAqIEBwYXJhbSBwcm9taXNlcyAtIEFycmF5IG9mIHByb21pc2VzIHRvIHdhaXQgb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYWxsU2V0dGxlZDxUPihcbiAgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8VD4+XG4pOiBQcm9taXNlPEFycmF5PFByb21pc2VTZXR0bGVkUmVzdWx0PFQ+Pj4ge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgcHJvbWlzZXMubWFwKGFzeW5jIHByb21pc2UgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwcm9taXNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZ1bGZpbGxlZDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9IGFzIFByb21pc2VGdWxmaWxsZWRSZXN1bHQ8VD47XG4gICAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmdWxmaWxsZWQ6IGZhbHNlLFxuICAgICAgICAgIHJlYXNvblxuICAgICAgICB9IGFzIFByb21pc2VSZWplY3RlZFJlc3VsdDtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgUmVjZWl2ZXJIYW5kbGVyLFxuICBfRXZlbnRUeXBlLFxuICBfUmVjZWl2ZXJSZXNwb25zZSxcbiAgU2VuZGVyTWVzc2FnZUV2ZW50LFxuICBfU3RhdHVzLFxuICBfU2VuZGVyUmVxdWVzdFxufSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IF9hbGxTZXR0bGVkIH0gZnJvbSAnLi9wcm9taXNlJztcblxuLyoqXG4gKiBJbnRlcmZhY2UgY2xhc3MgZm9yIHJlY2VpdmluZyBtZXNzYWdlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWNlaXZlciB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHJlY2VpdmVyczogUmVjZWl2ZXJbXSA9IFtdO1xuICBwcml2YXRlIHJlYWRvbmx5IGJvdW5kRXZlbnRIYW5kbGVyOiBFdmVudExpc3RlbmVyO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgaGFuZGxlcnNNYXA6IHtcbiAgICAvLyBUeXBlc2NyaXB0IGRvZXNuJ3QgaGF2ZSBleGlzdGVudGlhbCB0eXBlcyA6KFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgW2V2ZW50VHlwZTogc3RyaW5nXTogU2V0PFJlY2VpdmVySGFuZGxlcjxhbnksIGFueT4+O1xuICB9ID0ge307XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBldmVudFRhcmdldDogRXZlbnRUYXJnZXQpIHtcbiAgICB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbiBhbiBpbnN0YW5jZSBvZiBhIFJlY2VpdmVyIGZvciBhIGdpdmVuIGV2ZW50IHRhcmdldCwgaWYgbm9uZSBleGlzdHMgaXQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnRUYXJnZXQgLSBBbiBldmVudCB0YXJnZXQgKHN1Y2ggYXMgd2luZG93IG9yIHNlbGYpIHRocm91Z2ggd2hpY2ggdGhlIHVuZGVybHlpbmdcbiAgICogbWVzc2FnZXMgd2lsbCBiZSByZWNlaXZlZC5cbiAgICovXG4gIHN0YXRpYyBfZ2V0SW5zdGFuY2UoZXZlbnRUYXJnZXQ6IEV2ZW50VGFyZ2V0KTogUmVjZWl2ZXIge1xuICAgIC8vIFRoZSByZXN1bHRzIGFyZSBzdG9yZWQgaW4gYW4gYXJyYXkgc2luY2Ugb2JqZWN0cyBjYW4ndCBiZSBrZXlzIGZvciBvdGhlclxuICAgIC8vIG9iamVjdHMuIEluIGFkZGl0aW9uLCBzZXR0aW5nIGEgdW5pcXVlIHByb3BlcnR5IG9uIGFuIGV2ZW50IHRhcmdldCBhcyBhXG4gICAgLy8gaGFzaCBtYXAga2V5IG1heSBub3QgYmUgYWxsb3dlZCBkdWUgdG8gQ09SUyByZXN0cmljdGlvbnMuXG4gICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IHRoaXMucmVjZWl2ZXJzLmZpbmQocmVjZWl2ZXIgPT5cbiAgICAgIHJlY2VpdmVyLmlzTGlzdGVuaW5ndG8oZXZlbnRUYXJnZXQpXG4gICAgKTtcbiAgICBpZiAoZXhpc3RpbmdJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nSW5zdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IG5ld0luc3RhbmNlID0gbmV3IFJlY2VpdmVyKGV2ZW50VGFyZ2V0KTtcbiAgICB0aGlzLnJlY2VpdmVycy5wdXNoKG5ld0luc3RhbmNlKTtcbiAgICByZXR1cm4gbmV3SW5zdGFuY2U7XG4gIH1cblxuICBwcml2YXRlIGlzTGlzdGVuaW5ndG8oZXZlbnRUYXJnZXQ6IEV2ZW50VGFyZ2V0KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRUYXJnZXQgPT09IGV2ZW50VGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZhbnMgb3V0IGEgTWVzc2FnZUV2ZW50IHRvIHRoZSBhcHByb3ByaWF0ZSBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFNlbmRzIGFuIHtAbGluayBTdGF0dXMuQUNLfSB1cG9uIHJlY2VpcHQgYW5kIGEge0BsaW5rIFN0YXR1cy5ET05FfSBvbmNlIGFsbCBoYW5kbGVycyBoYXZlXG4gICAqIGZpbmlzaGVkIHByb2Nlc3NpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBNZXNzYWdlRXZlbnQuXG4gICAqXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGhhbmRsZUV2ZW50PFxuICAgIFQgZXh0ZW5kcyBfUmVjZWl2ZXJSZXNwb25zZSxcbiAgICBTIGV4dGVuZHMgX1NlbmRlclJlcXVlc3RcbiAgPihldmVudDogRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtZXNzYWdlRXZlbnQgPSBldmVudCBhcyBNZXNzYWdlRXZlbnQ8U2VuZGVyTWVzc2FnZUV2ZW50PFM+PjtcbiAgICBjb25zdCB7IGV2ZW50SWQsIGV2ZW50VHlwZSwgZGF0YSB9ID0gbWVzc2FnZUV2ZW50LmRhdGE7XG5cbiAgICBjb25zdCBoYW5kbGVyczogU2V0PFJlY2VpdmVySGFuZGxlcjxULCBTPj4gfCB1bmRlZmluZWQgPVxuICAgICAgdGhpcy5oYW5kbGVyc01hcFtldmVudFR5cGVdO1xuICAgIGlmICghaGFuZGxlcnM/LnNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZXNzYWdlRXZlbnQucG9ydHNbMF0ucG9zdE1lc3NhZ2Uoe1xuICAgICAgc3RhdHVzOiBfU3RhdHVzLkFDSyxcbiAgICAgIGV2ZW50SWQsXG4gICAgICBldmVudFR5cGVcbiAgICB9KTtcblxuICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbShoYW5kbGVycykubWFwKGFzeW5jIGhhbmRsZXIgPT5cbiAgICAgIGhhbmRsZXIobWVzc2FnZUV2ZW50Lm9yaWdpbiwgZGF0YSlcbiAgICApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2FsbFNldHRsZWQocHJvbWlzZXMpO1xuICAgIG1lc3NhZ2VFdmVudC5wb3J0c1swXS5wb3N0TWVzc2FnZSh7XG4gICAgICBzdGF0dXM6IF9TdGF0dXMuRE9ORSxcbiAgICAgIGV2ZW50SWQsXG4gICAgICBldmVudFR5cGUsXG4gICAgICByZXNwb25zZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBhbiBldmVudCBoYW5kbGVyIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudFR5cGUgLSBFdmVudCBuYW1lIHRvIHN1YnNjcmliZSB0by5cbiAgICogQHBhcmFtIGV2ZW50SGFuZGxlciAtIFRoZSBldmVudCBoYW5kbGVyIHdoaWNoIHNob3VsZCByZWNlaXZlIHRoZSBldmVudHMuXG4gICAqXG4gICAqL1xuICBfc3Vic2NyaWJlPFQgZXh0ZW5kcyBfUmVjZWl2ZXJSZXNwb25zZSwgUyBleHRlbmRzIF9TZW5kZXJSZXF1ZXN0PihcbiAgICBldmVudFR5cGU6IF9FdmVudFR5cGUsXG4gICAgZXZlbnRIYW5kbGVyOiBSZWNlaXZlckhhbmRsZXI8VCwgUz5cbiAgKTogdm9pZCB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcnNNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5ldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5ib3VuZEV2ZW50SGFuZGxlcik7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhhbmRsZXJzTWFwW2V2ZW50VHlwZV0pIHtcbiAgICAgIHRoaXMuaGFuZGxlcnNNYXBbZXZlbnRUeXBlXSA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZXJzTWFwW2V2ZW50VHlwZV0uYWRkKGV2ZW50SGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgYW4gZXZlbnQgaGFuZGxlciBmcm9tIGEgcGFydGljdWxhciBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50VHlwZSAtIEV2ZW50IG5hbWUgdG8gdW5zdWJzY3JpYmUgZnJvbS5cbiAgICogQHBhcmFtIGV2ZW50SGFuZGxlciAtIE9wdGlub2FsIGV2ZW50IGhhbmRsZXIsIGlmIG5vbmUgcHJvdmlkZWQsIHVuc3Vic2NyaWJlIGFsbCBoYW5kbGVycyBvbiB0aGlzIGV2ZW50LlxuICAgKlxuICAgKi9cbiAgX3Vuc3Vic2NyaWJlPFQgZXh0ZW5kcyBfUmVjZWl2ZXJSZXNwb25zZSwgUyBleHRlbmRzIF9TZW5kZXJSZXF1ZXN0PihcbiAgICBldmVudFR5cGU6IF9FdmVudFR5cGUsXG4gICAgZXZlbnRIYW5kbGVyPzogUmVjZWl2ZXJIYW5kbGVyPFQsIFM+XG4gICk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZXJzTWFwW2V2ZW50VHlwZV0gJiYgZXZlbnRIYW5kbGVyKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzTWFwW2V2ZW50VHlwZV0uZGVsZXRlKGV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIGlmICghZXZlbnRIYW5kbGVyIHx8IHRoaXMuaGFuZGxlcnNNYXBbZXZlbnRUeXBlXS5zaXplID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5oYW5kbGVyc01hcFtldmVudFR5cGVdO1xuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmhhbmRsZXJzTWFwKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuYm91bmRFdmVudEhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZW5lcmF0ZUV2ZW50SWQocHJlZml4ID0gJycsIGRpZ2l0cyA9IDEwKTogc3RyaW5nIHtcbiAgbGV0IHJhbmRvbSA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZ2l0czsgaSsrKSB7XG4gICAgcmFuZG9tICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKTtcbiAgfVxuICByZXR1cm4gcHJlZml4ICsgcmFuZG9tO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgX2dlbmVyYXRlRXZlbnRJZCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9ldmVudF9pZCc7XG5pbXBvcnQge1xuICBfU2VuZGVyUmVxdWVzdCxcbiAgX0V2ZW50VHlwZSxcbiAgUmVjZWl2ZXJNZXNzYWdlRXZlbnQsXG4gIF9NZXNzYWdlRXJyb3IsXG4gIFNlbmRlck1lc3NhZ2VFdmVudCxcbiAgX1N0YXR1cyxcbiAgX1JlY2VpdmVyTWVzc2FnZVJlc3BvbnNlLFxuICBfUmVjZWl2ZXJSZXNwb25zZSxcbiAgX1RpbWVvdXREdXJhdGlvblxufSBmcm9tICcuL2luZGV4JztcblxuaW50ZXJmYWNlIE1lc3NhZ2VIYW5kbGVyIHtcbiAgbWVzc2FnZUNoYW5uZWw6IE1lc3NhZ2VDaGFubmVsO1xuICBvbk1lc3NhZ2U6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3Q7XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBzZW5kaW5nIG1lc3NhZ2VzIGFuZCB3YWl0aW5nIGZvciBhIGNvbXBsZXRpb24gcmVzcG9uc2UuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgU2VuZGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBoYW5kbGVycyA9IG5ldyBTZXQ8TWVzc2FnZUhhbmRsZXI+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB0YXJnZXQ6IFNlcnZpY2VXb3JrZXIpIHt9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIHRoZSBoYW5kbGVyIGFuZCByZW1vdmUgaXQgZnJvbSBvdXIgdHJhY2tpbmcgU2V0LlxuICAgKlxuICAgKiBAcGFyYW0gaGFuZGxlciAtIFRoZSBoYW5kbGVyIHRvIHVuc3Vic2NyaWJlLlxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVNZXNzYWdlSGFuZGxlcihoYW5kbGVyOiBNZXNzYWdlSGFuZGxlcik6IHZvaWQge1xuICAgIGlmIChoYW5kbGVyLm1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICBoYW5kbGVyLm1lc3NhZ2VDaGFubmVsLnBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdtZXNzYWdlJyxcbiAgICAgICAgaGFuZGxlci5vbk1lc3NhZ2VcbiAgICAgICk7XG4gICAgICBoYW5kbGVyLm1lc3NhZ2VDaGFubmVsLnBvcnQxLmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlcnMuZGVsZXRlKGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBSZWNlaXZlciBsb2NhdGVkIGF0IHtAbGluayB0YXJnZXR9LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBXZSdsbCBmaXJzdCB3YWl0IGEgYml0IGZvciBhbiBBQ0sgLCBpZiB3ZSBnZXQgb25lIHdlIHdpbGwgd2FpdCBzaWduaWZpY2FudGx5IGxvbmdlciB1bnRpbCB0aGVcbiAgICogcmVjZWl2ZXIgaGFzIGhhZCBhIGNoYW5jZSB0byBmdWxseSBwcm9jZXNzIHRoZSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFR5cGUgb2YgZXZlbnQgdG8gc2VuZC5cbiAgICogQHBhcmFtIGRhdGEgLSBUaGUgcGF5bG9hZCBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB0aW1lb3V0IC0gVGltZW91dCBmb3Igd2FpdGluZyBvbiBhbiBBQ0sgZnJvbSB0aGUgcmVjZWl2ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHNldHRsZWQgcHJvbWlzZXMgZnJvbSBhbGwgdGhlIGhhbmRsZXJzIHRoYXQgd2VyZSBsaXN0ZW5pbmcgb24gdGhlIHJlY2VpdmVyLlxuICAgKi9cbiAgYXN5bmMgX3NlbmQ8VCBleHRlbmRzIF9SZWNlaXZlclJlc3BvbnNlLCBTIGV4dGVuZHMgX1NlbmRlclJlcXVlc3Q+KFxuICAgIGV2ZW50VHlwZTogX0V2ZW50VHlwZSxcbiAgICBkYXRhOiBTLFxuICAgIHRpbWVvdXQgPSBfVGltZW91dER1cmF0aW9uLkFDS1xuICApOiBQcm9taXNlPF9SZWNlaXZlck1lc3NhZ2VSZXNwb25zZTxUPj4ge1xuICAgIGNvbnN0IG1lc3NhZ2VDaGFubmVsID1cbiAgICAgIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgTWVzc2FnZUNoYW5uZWwoKSA6IG51bGw7XG4gICAgaWYgKCFtZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKF9NZXNzYWdlRXJyb3IuQ09OTkVDVElPTl9VTkFWQUlMQUJMRSk7XG4gICAgfVxuICAgIC8vIE5vZGUgdGltZXJzIGFuZCBicm93c2VyIHRpbWVycyByZXR1cm4gZnVuZGFtZW50YWxseSBkaWZmZXJlbnQgdHlwZXMuXG4gICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgY2FyZSB3aGF0IHRoZSB2YWx1ZSBpcyBidXQgVFMgd29uJ3QgYWNjZXB0IHVua25vd24gYW5kXG4gICAgLy8gd2UgY2FuJ3QgY2FzdCBwcm9wZXJseSBpbiBib3RoIGVudmlyb25tZW50cy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGxldCBjb21wbGV0aW9uVGltZXI6IGFueTtcbiAgICBsZXQgaGFuZGxlcjogTWVzc2FnZUhhbmRsZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPF9SZWNlaXZlck1lc3NhZ2VSZXNwb25zZTxUPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZXZlbnRJZCA9IF9nZW5lcmF0ZUV2ZW50SWQoJycsIDIwKTtcbiAgICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQxLnN0YXJ0KCk7XG4gICAgICBjb25zdCBhY2tUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKF9NZXNzYWdlRXJyb3IuVU5TVVBQT1JURURfRVZFTlQpKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgaGFuZGxlciA9IHtcbiAgICAgICAgbWVzc2FnZUNoYW5uZWwsXG4gICAgICAgIG9uTWVzc2FnZShldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlRXZlbnQgPSBldmVudCBhcyBNZXNzYWdlRXZlbnQ8UmVjZWl2ZXJNZXNzYWdlRXZlbnQ8VD4+O1xuICAgICAgICAgIGlmIChtZXNzYWdlRXZlbnQuZGF0YS5ldmVudElkICE9PSBldmVudElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAobWVzc2FnZUV2ZW50LmRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIF9TdGF0dXMuQUNLOlxuICAgICAgICAgICAgICAvLyBUaGUgcmVjZWl2ZXIgc2hvdWxkIEFDSyBmaXJzdC5cbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFja1RpbWVyKTtcbiAgICAgICAgICAgICAgY29tcGxldGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihfTWVzc2FnZUVycm9yLlRJTUVPVVQpKTtcbiAgICAgICAgICAgICAgfSwgX1RpbWVvdXREdXJhdGlvbi5DT01QTEVUSU9OKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9TdGF0dXMuRE9ORTpcbiAgICAgICAgICAgICAgLy8gT25jZSB0aGUgcmVjZWl2ZXIncyBoYW5kbGVycyBhcmUgZmluaXNoZWQgd2Ugd2lsbCBnZXQgdGhlIHJlc3VsdHMuXG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb21wbGV0aW9uVGltZXIpO1xuICAgICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2VFdmVudC5kYXRhLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYWNrVGltZXIpO1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29tcGxldGlvblRpbWVyKTtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihfTWVzc2FnZUVycm9yLklOVkFMSURfUkVTUE9OU0UpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5oYW5kbGVycy5hZGQoaGFuZGxlcik7XG4gICAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlci5vbk1lc3NhZ2UpO1xuICAgICAgdGhpcy50YXJnZXQucG9zdE1lc3NhZ2UoXG4gICAgICAgIHtcbiAgICAgICAgICBldmVudFR5cGUsXG4gICAgICAgICAgZXZlbnRJZCxcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH0gYXMgU2VuZGVyTWVzc2FnZUV2ZW50PFM+LFxuICAgICAgICBbbWVzc2FnZUNoYW5uZWwucG9ydDJdXG4gICAgICApO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVNZXNzYWdlSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUmVjYXB0Y2hhLCBHcmVDQVBUQ0hBVG9wTGV2ZWwgfSBmcm9tICcuL3JlY2FwdGNoYS9yZWNhcHRjaGEnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgd2luZG93IHR5cGUgdGhhdCBtZWxkcyB0aGUgbm9ybWFsIHdpbmRvdyB0eXBlIHBsdXMgdGhlXG4gKiB2YXJpb3VzIGJpdHMgd2UgbmVlZC4gVGhlIHRocmVlIGRpZmZlcmVudCBibG9ja3MgdGhhdCBhcmUgJidkIHRvZ2V0aGVyXG4gKiBjYW50IGJlIGRlZmluZWQgaW4gdGhlIHNhbWUgYmxvY2sgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCB0eXBlIEF1dGhXaW5kb3cgPSB7XG4gIC8vIFN0YW5kYXJkIHdpbmRvdyB0eXBlc1xuICBbVCBpbiBrZXlvZiBXaW5kb3ddOiBXaW5kb3dbVF07XG59ICYge1xuICAvLyBBbnkga25vd24gLyBuYW1lZCBwcm9wZXJ0aWVzIHdlIHdhbnQgdG8gYWRkXG4gIGdyZWNhcHRjaGE/OiBSZWNhcHRjaGEgfCBHcmVDQVBUQ0hBVG9wTGV2ZWw7XG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4gIF9fX2pzbD86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIGdhcGk/OiB0eXBlb2YgZ2FwaTtcbn0gJiB7XG4gIC8vIEEgZmluYWwgY2F0Y2gtYWxsIGZvciBjYWxsYmFja3MgKHdoaWNoIHdpbGwgaGF2ZSByYW5kb20gbmFtZXMpIHRoYXRcbiAgLy8gd2Ugd2lsbCBzdGljayBvbiB0aGUgd2luZG93LlxuICBbY2FsbGJhY2s6IHN0cmluZ106ICguLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWQ7XG59O1xuXG4vKipcbiAqIExhenkgYWNjZXNzb3IgZm9yIHdpbmRvdywgc2luY2UgdGhlIGNvbXBhdCBsYXllciB3b24ndCB0cmVlIHNoYWtlIHRoaXMgb3V0LFxuICogd2UgbmVlZCB0byBtYWtlIHN1cmUgbm90IHRvIG1lc3Mgd2l0aCB3aW5kb3cgdW5sZXNzIHdlIGhhdmUgdG9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF93aW5kb3coKTogQXV0aFdpbmRvdyB7XG4gIHJldHVybiB3aW5kb3cgYXMgdW5rbm93biBhcyBBdXRoV2luZG93O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3NldFdpbmRvd0xvY2F0aW9uKHVybDogc3RyaW5nKTogdm9pZCB7XG4gIF93aW5kb3coKS5sb2NhdGlvbi5ocmVmID0gdXJsO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IF93aW5kb3cgfSBmcm9tICcuLi9hdXRoX3dpbmRvdyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNXb3JrZXIoKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIF93aW5kb3coKVsnV29ya2VyR2xvYmFsU2NvcGUnXSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgX3dpbmRvdygpWydpbXBvcnRTY3JpcHRzJ10gPT09ICdmdW5jdGlvbidcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9nZXRBY3RpdmVTZXJ2aWNlV29ya2VyKCk6IFByb21pc2U8U2VydmljZVdvcmtlciB8IG51bGw+IHtcbiAgaWYgKCFuYXZpZ2F0b3I/LnNlcnZpY2VXb3JrZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IGF3YWl0IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlYWR5O1xuICAgIHJldHVybiByZWdpc3RyYXRpb24uYWN0aXZlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dldFNlcnZpY2VXb3JrZXJDb250cm9sbGVyKCk6IFNlcnZpY2VXb3JrZXIgfCBudWxsIHtcbiAgcmV0dXJuIG5hdmlnYXRvcj8uc2VydmljZVdvcmtlcj8uY29udHJvbGxlciB8fCBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dldFdvcmtlckdsb2JhbFNjb3BlKCk6IFNlcnZpY2VXb3JrZXIgfCBudWxsIHtcbiAgcmV0dXJuIF9pc1dvcmtlcigpID8gKHNlbGYgYXMgdW5rbm93biBhcyBTZXJ2aWNlV29ya2VyKSA6IG51bGw7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQZXJzaXN0ZW5jZSB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQge1xuICBQZXJzaXN0ZWRCbG9iLFxuICBQZXJzaXN0ZW5jZUludGVybmFsIGFzIEludGVybmFsUGVyc2lzdGVuY2UsXG4gIFBlcnNpc3RlbmNlVHlwZSxcbiAgUGVyc2lzdGVuY2VWYWx1ZSxcbiAgU3RvcmFnZUV2ZW50TGlzdGVuZXIsXG4gIFNUT1JBR0VfQVZBSUxBQkxFX0tFWVxufSBmcm9tICcuLi8uLi9jb3JlL3BlcnNpc3RlbmNlLyc7XG5pbXBvcnQge1xuICBfRXZlbnRUeXBlLFxuICBfUGluZ1Jlc3BvbnNlLFxuICBLZXlDaGFuZ2VkUmVzcG9uc2UsXG4gIEtleUNoYW5nZWRSZXF1ZXN0LFxuICBQaW5nUmVxdWVzdCxcbiAgX1RpbWVvdXREdXJhdGlvblxufSBmcm9tICcuLi9tZXNzYWdlY2hhbm5lbC9pbmRleCc7XG5pbXBvcnQgeyBSZWNlaXZlciB9IGZyb20gJy4uL21lc3NhZ2VjaGFubmVsL3JlY2VpdmVyJztcbmltcG9ydCB7IFNlbmRlciB9IGZyb20gJy4uL21lc3NhZ2VjaGFubmVsL3NlbmRlcic7XG5pbXBvcnQge1xuICBfaXNXb3JrZXIsXG4gIF9nZXRBY3RpdmVTZXJ2aWNlV29ya2VyLFxuICBfZ2V0U2VydmljZVdvcmtlckNvbnRyb2xsZXIsXG4gIF9nZXRXb3JrZXJHbG9iYWxTY29wZVxufSBmcm9tICcuLi91dGlsL3dvcmtlcic7XG5cbmV4cG9ydCBjb25zdCBEQl9OQU1FID0gJ2ZpcmViYXNlTG9jYWxTdG9yYWdlRGInO1xuY29uc3QgREJfVkVSU0lPTiA9IDE7XG5jb25zdCBEQl9PQkpFQ1RTVE9SRV9OQU1FID0gJ2ZpcmViYXNlTG9jYWxTdG9yYWdlJztcbmNvbnN0IERCX0RBVEFfS0VZUEFUSCA9ICdmYmFzZV9rZXknO1xuXG5pbnRlcmZhY2UgREJPYmplY3Qge1xuICBbREJfREFUQV9LRVlQQVRIXTogc3RyaW5nO1xuICB2YWx1ZTogUGVyc2lzdGVkQmxvYjtcbn1cblxuLyoqXG4gKiBQcm9taXNlIHdyYXBwZXIgZm9yIElEQlJlcXVlc3RcbiAqXG4gKiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0IGNsZWFubHkgZXh0ZW5kIFByb21pc2U8VD4gc2luY2UgcHJvbWlzZXMgYXJlIG5vdCBjYWxsYWJsZSBpbiBFUzZcbiAqXG4gKi9cbmNsYXNzIERCUHJvbWlzZTxUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcmVxdWVzdDogSURCUmVxdWVzdCkge31cblxuICB0b1Byb21pc2UoKTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgKCkgPT4ge1xuICAgICAgICByZXNvbHZlKHRoaXMucmVxdWVzdC5yZXN1bHQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgIHJlamVjdCh0aGlzLnJlcXVlc3QuZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0T2JqZWN0U3RvcmUoZGI6IElEQkRhdGFiYXNlLCBpc1JlYWRXcml0ZTogYm9vbGVhbik6IElEQk9iamVjdFN0b3JlIHtcbiAgcmV0dXJuIGRiXG4gICAgLnRyYW5zYWN0aW9uKFtEQl9PQkpFQ1RTVE9SRV9OQU1FXSwgaXNSZWFkV3JpdGUgPyAncmVhZHdyaXRlJyA6ICdyZWFkb25seScpXG4gICAgLm9iamVjdFN0b3JlKERCX09CSkVDVFNUT1JFX05BTUUpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX2NsZWFyRGF0YWJhc2UoZGI6IElEQkRhdGFiYXNlKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IG9iamVjdFN0b3JlID0gZ2V0T2JqZWN0U3RvcmUoZGIsIHRydWUpO1xuICByZXR1cm4gbmV3IERCUHJvbWlzZTx2b2lkPihvYmplY3RTdG9yZS5jbGVhcigpKS50b1Byb21pc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9kZWxldGVEYXRhYmFzZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShEQl9OQU1FKTtcbiAgcmV0dXJuIG5ldyBEQlByb21pc2U8dm9pZD4ocmVxdWVzdCkudG9Qcm9taXNlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfb3BlbkRhdGFiYXNlKCk6IFByb21pc2U8SURCRGF0YWJhc2U+IHtcbiAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKERCX05BTUUsIERCX1ZFUlNJT04pO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKSA9PiB7XG4gICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgfSk7XG5cbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3VwZ3JhZGVuZWVkZWQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkYiA9IHJlcXVlc3QucmVzdWx0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEQl9PQkpFQ1RTVE9SRV9OQU1FLCB7IGtleVBhdGg6IERCX0RBVEFfS0VZUEFUSCB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGI6IElEQkRhdGFiYXNlID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAvLyBTdHJhbmdlIGJ1ZyB0aGF0IG9jY3VycyBpbiBGaXJlZm94IHdoZW4gbXVsdGlwbGUgdGFicyBhcmUgb3BlbmVkIGF0IHRoZVxuICAgICAgLy8gc2FtZSB0aW1lLiBUaGUgb25seSB3YXkgdG8gcmVjb3ZlciBzZWVtcyB0byBiZSBkZWxldGluZyB0aGUgZGF0YWJhc2VcbiAgICAgIC8vIGFuZCByZS1pbml0aWFsaXppbmcgaXQuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2lzc3Vlcy82MzRcblxuICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKERCX09CSkVDVFNUT1JFX05BTUUpKSB7XG4gICAgICAgIC8vIE5lZWQgdG8gY2xvc2UgdGhlIGRhdGFiYXNlIG9yIGVsc2UgeW91IGdldCBhIGBibG9ja2VkYCBldmVudFxuICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICBhd2FpdCBfZGVsZXRlRGF0YWJhc2UoKTtcbiAgICAgICAgcmVzb2x2ZShhd2FpdCBfb3BlbkRhdGFiYXNlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShkYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3B1dE9iamVjdChcbiAgZGI6IElEQkRhdGFiYXNlLFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IFBlcnNpc3RlbmNlVmFsdWUgfCBzdHJpbmdcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZXF1ZXN0ID0gZ2V0T2JqZWN0U3RvcmUoZGIsIHRydWUpLnB1dCh7XG4gICAgW0RCX0RBVEFfS0VZUEFUSF06IGtleSxcbiAgICB2YWx1ZVxuICB9KTtcbiAgcmV0dXJuIG5ldyBEQlByb21pc2U8dm9pZD4ocmVxdWVzdCkudG9Qcm9taXNlKCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldE9iamVjdChcbiAgZGI6IElEQkRhdGFiYXNlLFxuICBrZXk6IHN0cmluZ1xuKTogUHJvbWlzZTxQZXJzaXN0ZWRCbG9iIHwgbnVsbD4ge1xuICBjb25zdCByZXF1ZXN0ID0gZ2V0T2JqZWN0U3RvcmUoZGIsIGZhbHNlKS5nZXQoa2V5KTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IG5ldyBEQlByb21pc2U8REJPYmplY3QgfCB1bmRlZmluZWQ+KHJlcXVlc3QpLnRvUHJvbWlzZSgpO1xuICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRhdGEudmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZGVsZXRlT2JqZWN0KGRiOiBJREJEYXRhYmFzZSwga2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgcmVxdWVzdCA9IGdldE9iamVjdFN0b3JlKGRiLCB0cnVlKS5kZWxldGUoa2V5KTtcbiAgcmV0dXJuIG5ldyBEQlByb21pc2U8dm9pZD4ocmVxdWVzdCkudG9Qcm9taXNlKCk7XG59XG5cbmV4cG9ydCBjb25zdCBfUE9MTElOR19JTlRFUlZBTF9NUyA9IDgwMDtcbmV4cG9ydCBjb25zdCBfVFJBTlNBQ1RJT05fUkVUUllfQ09VTlQgPSAzO1xuXG5jbGFzcyBJbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlIGltcGxlbWVudHMgSW50ZXJuYWxQZXJzaXN0ZW5jZSB7XG4gIHN0YXRpYyB0eXBlOiAnTE9DQUwnID0gJ0xPQ0FMJztcblxuICB0eXBlID0gUGVyc2lzdGVuY2VUeXBlLkxPQ0FMO1xuICBkYj86IElEQkRhdGFiYXNlO1xuICByZWFkb25seSBfc2hvdWxkQWxsb3dNaWdyYXRpb24gPSB0cnVlO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgbGlzdGVuZXJzOiBSZWNvcmQ8c3RyaW5nLCBTZXQ8U3RvcmFnZUV2ZW50TGlzdGVuZXI+PiA9IHt9O1xuICBwcml2YXRlIHJlYWRvbmx5IGxvY2FsQ2FjaGU6IFJlY29yZDxzdHJpbmcsIFBlcnNpc3RlbmNlVmFsdWUgfCBudWxsPiA9IHt9O1xuICAvLyBzZXRUaW1lb3V0IHJldHVybiB2YWx1ZSBpcyBwbGF0Zm9ybSBzcGVjaWZpY1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBwcml2YXRlIHBvbGxUaW1lcjogYW55IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcGVuZGluZ1dyaXRlcyA9IDA7XG5cbiAgcHJpdmF0ZSByZWNlaXZlcjogUmVjZWl2ZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBzZW5kZXI6IFNlbmRlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHNlcnZpY2VXb3JrZXJSZWNlaXZlckF2YWlsYWJsZSA9IGZhbHNlO1xuICBwcml2YXRlIGFjdGl2ZVNlcnZpY2VXb3JrZXI6IFNlcnZpY2VXb3JrZXIgfCBudWxsID0gbnVsbDtcbiAgLy8gVmlzaWJsZSBmb3IgdGVzdGluZyBvbmx5XG4gIHJlYWRvbmx5IF93b3JrZXJJbml0aWFsaXphdGlvblByb21pc2U6IFByb21pc2U8dm9pZD47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gRmlyZSAmIGZvcmdldCB0aGUgc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIGFzIGl0IG1heSBuZXZlciByZXNvbHZlXG4gICAgdGhpcy5fd29ya2VySW5pdGlhbGl6YXRpb25Qcm9taXNlID1cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVNlcnZpY2VXb3JrZXJNZXNzYWdpbmcoKS50aGVuKFxuICAgICAgICAoKSA9PiB7fSxcbiAgICAgICAgKCkgPT4ge31cbiAgICAgICk7XG4gIH1cblxuICBhc3luYyBfb3BlbkRiKCk6IFByb21pc2U8SURCRGF0YWJhc2U+IHtcbiAgICBpZiAodGhpcy5kYikge1xuICAgICAgcmV0dXJuIHRoaXMuZGI7XG4gICAgfVxuICAgIHRoaXMuZGIgPSBhd2FpdCBfb3BlbkRhdGFiYXNlKCk7XG4gICAgcmV0dXJuIHRoaXMuZGI7XG4gIH1cblxuICBhc3luYyBfd2l0aFJldHJpZXM8VD4ob3A6IChkYjogSURCRGF0YWJhc2UpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICBsZXQgbnVtQXR0ZW1wdHMgPSAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5fb3BlbkRiKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBvcChkYik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChudW1BdHRlbXB0cysrID4gX1RSQU5TQUNUSU9OX1JFVFJZX0NPVU5UKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYikge1xuICAgICAgICAgIHRoaXMuZGIuY2xvc2UoKTtcbiAgICAgICAgICB0aGlzLmRiID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGFkZGluZyBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4ZWREQiBldmVudHMgZG8gbm90IHByb3BhZ2F0ZSBmcm9tIHRoZSBtYWluIHdpbmRvdyB0byB0aGUgd29ya2VyIGNvbnRleHQuICBXZSByZWx5IG9uIGFcbiAgICogcG9zdE1lc3NhZ2UgaW50ZXJmYWNlIHRvIHNlbmQgdGhlc2UgZXZlbnRzIHRvIHRoZSB3b3JrZXIgb3Vyc2VsdmVzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplU2VydmljZVdvcmtlck1lc3NhZ2luZygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gX2lzV29ya2VyKCkgPyB0aGlzLmluaXRpYWxpemVSZWNlaXZlcigpIDogdGhpcy5pbml0aWFsaXplU2VuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQXMgdGhlIHdvcmtlciB3ZSBzaG91bGQgbGlzdGVuIHRvIGV2ZW50cyBmcm9tIHRoZSBtYWluIHdpbmRvdy5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZVJlY2VpdmVyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMucmVjZWl2ZXIgPSBSZWNlaXZlci5fZ2V0SW5zdGFuY2UoX2dldFdvcmtlckdsb2JhbFNjb3BlKCkhKTtcbiAgICAvLyBSZWZyZXNoIGZyb20gcGVyc2lzdGVuY2UgaWYgd2UgcmVjZWl2ZSBhIEtleUNoYW5nZWQgbWVzc2FnZS5cbiAgICB0aGlzLnJlY2VpdmVyLl9zdWJzY3JpYmUoXG4gICAgICBfRXZlbnRUeXBlLktFWV9DSEFOR0VELFxuICAgICAgYXN5bmMgKF9vcmlnaW46IHN0cmluZywgZGF0YTogS2V5Q2hhbmdlZFJlcXVlc3QpID0+IHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IHRoaXMuX3BvbGwoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXlQcm9jZXNzZWQ6IGtleXMuaW5jbHVkZXMoZGF0YS5rZXkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgKTtcbiAgICAvLyBMZXQgdGhlIHNlbmRlciBrbm93IHRoYXQgd2UgYXJlIGxpc3RlbmluZyBzbyB0aGV5IGdpdmUgdXMgbW9yZSB0aW1lb3V0LlxuICAgIHRoaXMucmVjZWl2ZXIuX3N1YnNjcmliZShcbiAgICAgIF9FdmVudFR5cGUuUElORyxcbiAgICAgIGFzeW5jIChfb3JpZ2luOiBzdHJpbmcsIF9kYXRhOiBQaW5nUmVxdWVzdCkgPT4ge1xuICAgICAgICByZXR1cm4gW19FdmVudFR5cGUuS0VZX0NIQU5HRURdO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQXMgdGhlIG1haW4gd2luZG93LCB3ZSBzaG91bGQgbGV0IHRoZSB3b3JrZXIga25vdyB3aGVuIGtleXMgY2hhbmdlIChzZXQgYW5kIHJlbW92ZSkuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmljZVdvcmtlckNvbnRhaW5lci9yZWFkeSB8IFNlcnZpY2VXb3JrZXJDb250YWluZXIucmVhZHl9XG4gICAqIG1heSBub3QgcmVzb2x2ZS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZVNlbmRlcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlcmUncyBhbiBhY3RpdmUgc2VydmljZSB3b3JrZXIuXG4gICAgdGhpcy5hY3RpdmVTZXJ2aWNlV29ya2VyID0gYXdhaXQgX2dldEFjdGl2ZVNlcnZpY2VXb3JrZXIoKTtcbiAgICBpZiAoIXRoaXMuYWN0aXZlU2VydmljZVdvcmtlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbmRlciA9IG5ldyBTZW5kZXIodGhpcy5hY3RpdmVTZXJ2aWNlV29ya2VyKTtcbiAgICAvLyBQaW5nIHRoZSBzZXJ2aWNlIHdvcmtlciB0byBjaGVjayB3aGF0IGV2ZW50cyB0aGV5IGNhbiBoYW5kbGUuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2VuZGVyLl9zZW5kPF9QaW5nUmVzcG9uc2UsIFBpbmdSZXF1ZXN0PihcbiAgICAgIF9FdmVudFR5cGUuUElORyxcbiAgICAgIHt9LFxuICAgICAgX1RpbWVvdXREdXJhdGlvbi5MT05HX0FDS1xuICAgICk7XG4gICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHJlc3VsdHNbMF0/LmZ1bGZpbGxlZCAmJlxuICAgICAgcmVzdWx0c1swXT8udmFsdWUuaW5jbHVkZXMoX0V2ZW50VHlwZS5LRVlfQ0hBTkdFRClcbiAgICApIHtcbiAgICAgIHRoaXMuc2VydmljZVdvcmtlclJlY2VpdmVyQXZhaWxhYmxlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGV0IHRoZSB3b3JrZXIga25vdyBhYm91dCBhIGNoYW5nZWQga2V5LCB0aGUgZXhhY3Qga2V5IGRvZXNuJ3QgdGVjaG5pY2FsbHkgbWF0dGVyIHNpbmNlIHRoZVxuICAgKiB3b3JrZXIgd2lsbCBqdXN0IHRyaWdnZXIgYSBmdWxsIHN5bmMgYW55d2F5LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBGb3Igbm93LCB3ZSBvbmx5IHN1cHBvcnQgb25lIHNlcnZpY2Ugd29ya2VyIHBlciBwYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IC0gU3RvcmFnZSBrZXkgd2hpY2ggY2hhbmdlZC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbm90aWZ5U2VydmljZVdvcmtlcihrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChcbiAgICAgICF0aGlzLnNlbmRlciB8fFxuICAgICAgIXRoaXMuYWN0aXZlU2VydmljZVdvcmtlciB8fFxuICAgICAgX2dldFNlcnZpY2VXb3JrZXJDb250cm9sbGVyKCkgIT09IHRoaXMuYWN0aXZlU2VydmljZVdvcmtlclxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zZW5kZXIuX3NlbmQ8S2V5Q2hhbmdlZFJlc3BvbnNlLCBLZXlDaGFuZ2VkUmVxdWVzdD4oXG4gICAgICAgIF9FdmVudFR5cGUuS0VZX0NIQU5HRUQsXG4gICAgICAgIHsga2V5IH0sXG4gICAgICAgIC8vIFVzZSBsb25nIHRpbWVvdXQgaWYgcmVjZWl2ZXIgaGFzIHByZXZpb3VzbHkgcmVzcG9uZGVkIHRvIGEgcGluZyBmcm9tIHVzLlxuICAgICAgICB0aGlzLnNlcnZpY2VXb3JrZXJSZWNlaXZlckF2YWlsYWJsZVxuICAgICAgICAgID8gX1RpbWVvdXREdXJhdGlvbi5MT05HX0FDS1xuICAgICAgICAgIDogX1RpbWVvdXREdXJhdGlvbi5BQ0tcbiAgICAgICk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBUaGlzIGlzIGEgYmVzdCBlZmZvcnQgYXBwcm9hY2guIElnbm9yZSBlcnJvcnMuXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2lzQXZhaWxhYmxlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWluZGV4ZWREQikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBkYiA9IGF3YWl0IF9vcGVuRGF0YWJhc2UoKTtcbiAgICAgIGF3YWl0IF9wdXRPYmplY3QoZGIsIFNUT1JBR0VfQVZBSUxBQkxFX0tFWSwgJzEnKTtcbiAgICAgIGF3YWl0IF9kZWxldGVPYmplY3QoZGIsIFNUT1JBR0VfQVZBSUxBQkxFX0tFWSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfd2l0aFBlbmRpbmdXcml0ZSh3cml0ZTogKCkgPT4gUHJvbWlzZTx2b2lkPik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMucGVuZGluZ1dyaXRlcysrO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3cml0ZSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnBlbmRpbmdXcml0ZXMtLTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogUGVyc2lzdGVuY2VWYWx1ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl93aXRoUGVuZGluZ1dyaXRlKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuX3dpdGhSZXRyaWVzKChkYjogSURCRGF0YWJhc2UpID0+IF9wdXRPYmplY3QoZGIsIGtleSwgdmFsdWUpKTtcbiAgICAgIHRoaXMubG9jYWxDYWNoZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5ub3RpZnlTZXJ2aWNlV29ya2VyKGtleSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBfZ2V0PFQgZXh0ZW5kcyBQZXJzaXN0ZW5jZVZhbHVlPihrZXk6IHN0cmluZyk6IFByb21pc2U8VCB8IG51bGw+IHtcbiAgICBjb25zdCBvYmogPSAoYXdhaXQgdGhpcy5fd2l0aFJldHJpZXMoKGRiOiBJREJEYXRhYmFzZSkgPT5cbiAgICAgIGdldE9iamVjdChkYiwga2V5KVxuICAgICkpIGFzIFQ7XG4gICAgdGhpcy5sb2NhbENhY2hlW2tleV0gPSBvYmo7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGFzeW5jIF9yZW1vdmUoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aFBlbmRpbmdXcml0ZShhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLl93aXRoUmV0cmllcygoZGI6IElEQkRhdGFiYXNlKSA9PiBfZGVsZXRlT2JqZWN0KGRiLCBrZXkpKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvY2FsQ2FjaGVba2V5XTtcbiAgICAgIHJldHVybiB0aGlzLm5vdGlmeVNlcnZpY2VXb3JrZXIoa2V5KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3BvbGwoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIFRPRE86IGNoZWNrIGlmIHdlIG5lZWQgdG8gZmFsbGJhY2sgaWYgZ2V0QWxsIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl93aXRoUmV0cmllcygoZGI6IElEQkRhdGFiYXNlKSA9PiB7XG4gICAgICBjb25zdCBnZXRBbGxSZXF1ZXN0ID0gZ2V0T2JqZWN0U3RvcmUoZGIsIGZhbHNlKS5nZXRBbGwoKTtcbiAgICAgIHJldHVybiBuZXcgREJQcm9taXNlPERCT2JqZWN0W10gfCBudWxsPihnZXRBbGxSZXF1ZXN0KS50b1Byb21pc2UoKTtcbiAgICB9KTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdyaXRlcyBpbiBwcm9ncmVzcyBhYm9ydCwgd2UnbGwgZ2V0IHBpY2tlZCB1cCBvbiB0aGUgbmV4dCBwb2xsXG4gICAgaWYgKHRoaXMucGVuZGluZ1dyaXRlcyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBjb25zdCBrZXlzSW5SZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB7IGZiYXNlX2tleToga2V5LCB2YWx1ZSB9IG9mIHJlc3VsdCkge1xuICAgICAga2V5c0luUmVzdWx0LmFkZChrZXkpO1xuICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHRoaXMubG9jYWxDYWNoZVtrZXldKSAhPT0gSlNPTi5zdHJpbmdpZnkodmFsdWUpKSB7XG4gICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKGtleSwgdmFsdWUgYXMgUGVyc2lzdGVuY2VWYWx1ZSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxvY2FsS2V5IG9mIE9iamVjdC5rZXlzKHRoaXMubG9jYWxDYWNoZSkpIHtcbiAgICAgIGlmICh0aGlzLmxvY2FsQ2FjaGVbbG9jYWxLZXldICYmICFrZXlzSW5SZXN1bHQuaGFzKGxvY2FsS2V5KSkge1xuICAgICAgICAvLyBEZWxldGVkXG4gICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKGxvY2FsS2V5LCBudWxsKTtcbiAgICAgICAga2V5cy5wdXNoKGxvY2FsS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICBwcml2YXRlIG5vdGlmeUxpc3RlbmVycyhcbiAgICBrZXk6IHN0cmluZyxcbiAgICBuZXdWYWx1ZTogUGVyc2lzdGVuY2VWYWx1ZSB8IG51bGxcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbENhY2hlW2tleV0gPSBuZXdWYWx1ZTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1trZXldO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgQXJyYXkuZnJvbShsaXN0ZW5lcnMpKSB7XG4gICAgICAgIGxpc3RlbmVyKG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXJ0UG9sbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG5cbiAgICB0aGlzLnBvbGxUaW1lciA9IHNldEludGVydmFsKFxuICAgICAgYXN5bmMgKCkgPT4gdGhpcy5fcG9sbCgpLFxuICAgICAgX1BPTExJTkdfSU5URVJWQUxfTVNcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdG9wUG9sbGluZygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wb2xsVGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5wb2xsVGltZXIpO1xuICAgICAgdGhpcy5wb2xsVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9hZGRMaXN0ZW5lcihrZXk6IHN0cmluZywgbGlzdGVuZXI6IFN0b3JhZ2VFdmVudExpc3RlbmVyKTogdm9pZCB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMubGlzdGVuZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhcnRQb2xsaW5nKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5saXN0ZW5lcnNba2V5XSkge1xuICAgICAgdGhpcy5saXN0ZW5lcnNba2V5XSA9IG5ldyBTZXQoKTtcbiAgICAgIC8vIFBvcHVsYXRlIHRoZSBjYWNoZSB0byBhdm9pZCBzcHVyaW91c2x5IHRyaWdnZXJpbmcgb24gZmlyc3QgcG9sbC5cbiAgICAgIHZvaWQgdGhpcy5fZ2V0KGtleSk7IC8vIFRoaXMgY2FuIGhhcHBlbiBpbiB0aGUgYmFja2dyb3VuZCBhc3luYyBhbmQgd2UgY2FuIHJldHVybiBpbW1lZGlhdGVseS5cbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnNba2V5XS5hZGQobGlzdGVuZXIpO1xuICB9XG5cbiAgX3JlbW92ZUxpc3RlbmVyKGtleTogc3RyaW5nLCBsaXN0ZW5lcjogU3RvcmFnZUV2ZW50TGlzdGVuZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5saXN0ZW5lcnNba2V5XSkge1xuICAgICAgdGhpcy5saXN0ZW5lcnNba2V5XS5kZWxldGUobGlzdGVuZXIpO1xuXG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnNba2V5XS5zaXplID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVycykubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFBlcnNpc3RlbmNlfSBvZiB0eXBlIGBMT0NBTGAgdXNpbmcgYGluZGV4ZWREQmBcbiAqIGZvciB0aGUgdW5kZXJseWluZyBzdG9yYWdlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2U6IFBlcnNpc3RlbmNlID0gSW5kZXhlZERCTG9jYWxQZXJzaXN0ZW5jZTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIF9wZXJmb3JtQXBpUmVxdWVzdCxcbiAgRW5kcG9pbnQsXG4gIEh0dHBNZXRob2QsXG4gIF9hZGRUaWRJZk5lY2Vzc2FyeVxufSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IE1mYUVucm9sbG1lbnQgfSBmcm9tICcuLi9hY2NvdW50X21hbmFnZW1lbnQvbWZhJztcbmltcG9ydCB7IFNpZ25JbldpdGhJZHBSZXNwb25zZSB9IGZyb20gJy4vaWRwJztcbmltcG9ydCB7XG4gIFNpZ25JbldpdGhQaG9uZU51bWJlclJlcXVlc3QsXG4gIFNpZ25JbldpdGhQaG9uZU51bWJlclJlc3BvbnNlXG59IGZyb20gJy4vc21zJztcblxuZXhwb3J0IGludGVyZmFjZSBGaW5hbGl6ZU1mYVJlc3BvbnNlIHtcbiAgaWRUb2tlbjogc3RyaW5nO1xuICByZWZyZXNoVG9rZW46IHN0cmluZztcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJZFRva2VuTWZhUmVzcG9uc2UgZXh0ZW5kcyBJZFRva2VuUmVzcG9uc2Uge1xuICBtZmFQZW5kaW5nQ3JlZGVudGlhbD86IHN0cmluZztcbiAgbWZhSW5mbz86IE1mYUVucm9sbG1lbnRbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGFydFBob25lTWZhU2lnbkluUmVxdWVzdCB7XG4gIG1mYVBlbmRpbmdDcmVkZW50aWFsOiBzdHJpbmc7XG4gIG1mYUVucm9sbG1lbnRJZDogc3RyaW5nO1xuICBwaG9uZVNpZ25JbkluZm86IHtcbiAgICByZWNhcHRjaGFUb2tlbjogc3RyaW5nO1xuICB9O1xuICB0ZW5hbnRJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGFydFBob25lTWZhU2lnbkluUmVzcG9uc2Uge1xuICBwaG9uZVJlc3BvbnNlSW5mbzoge1xuICAgIHNlc3Npb25JbmZvOiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFNpZ25JblBob25lTWZhKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBTdGFydFBob25lTWZhU2lnbkluUmVxdWVzdFxuKTogUHJvbWlzZTxTdGFydFBob25lTWZhU2lnbkluUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxcbiAgICBTdGFydFBob25lTWZhU2lnbkluUmVxdWVzdCxcbiAgICBTdGFydFBob25lTWZhU2lnbkluUmVzcG9uc2VcbiAgPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5TVEFSVF9NRkFfU0lHTl9JTixcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaW5hbGl6ZVBob25lTWZhU2lnbkluUmVxdWVzdCB7XG4gIG1mYVBlbmRpbmdDcmVkZW50aWFsOiBzdHJpbmc7XG4gIHBob25lVmVyaWZpY2F0aW9uSW5mbzogU2lnbkluV2l0aFBob25lTnVtYmVyUmVxdWVzdDtcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbi8vIFRPVFAgTUZBIFNpZ24gaW4gb25seSBoYXMgYSBmaW5hbGl6ZSBwaGFzZS4gUGhvbmUgTUZBIGhhcyBhIHN0YXJ0IHBoYXNlIHRvIGluaXRpYXRlIHNlbmRpbmcgYW5cbi8vIFNNUyBhbmQgYSBmaW5hbGl6ZSBwaGFzZSB0byBjb21wbGV0ZSBzaWduIGluLiBXaXRoIFRPVFAsIHRoZSB1c2VyIGFscmVhZHkgaGFzIHRoZSBPVFAgaW4gdGhlXG4vLyBUT1RQL0F1dGhlbnRpY2F0b3IgYXBwLlxuZXhwb3J0IGludGVyZmFjZSBGaW5hbGl6ZVRvdHBNZmFTaWduSW5SZXF1ZXN0IHtcbiAgbWZhUGVuZGluZ0NyZWRlbnRpYWw6IHN0cmluZztcbiAgdG90cFZlcmlmaWNhdGlvbkluZm86IHsgdmVyaWZpY2F0aW9uQ29kZTogc3RyaW5nIH07XG4gIHRlbmFudElkPzogc3RyaW5nO1xuICBtZmFFbnJvbGxtZW50SWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaW5hbGl6ZVBob25lTWZhU2lnbkluUmVzcG9uc2UgZXh0ZW5kcyBGaW5hbGl6ZU1mYVJlc3BvbnNlIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluYWxpemVUb3RwTWZhU2lnbkluUmVzcG9uc2UgZXh0ZW5kcyBGaW5hbGl6ZU1mYVJlc3BvbnNlIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5hbGl6ZVNpZ25JblBob25lTWZhKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBGaW5hbGl6ZVBob25lTWZhU2lnbkluUmVxdWVzdFxuKTogUHJvbWlzZTxGaW5hbGl6ZVBob25lTWZhU2lnbkluUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxcbiAgICBGaW5hbGl6ZVBob25lTWZhU2lnbkluUmVxdWVzdCxcbiAgICBGaW5hbGl6ZVBob25lTWZhU2lnbkluUmVzcG9uc2VcbiAgPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5GSU5BTElaRV9NRkFfU0lHTl9JTixcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmFsaXplU2lnbkluVG90cE1mYShcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogRmluYWxpemVUb3RwTWZhU2lnbkluUmVxdWVzdFxuKTogUHJvbWlzZTxGaW5hbGl6ZVRvdHBNZmFTaWduSW5SZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PFxuICAgIEZpbmFsaXplVG90cE1mYVNpZ25JblJlcXVlc3QsXG4gICAgRmluYWxpemVUb3RwTWZhU2lnbkluUmVzcG9uc2VcbiAgPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5GSU5BTElaRV9NRkFfU0lHTl9JTixcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgUGhvbmVPck9hdXRoVG9rZW5SZXNwb25zZSA9XG4gIHwgU2lnbkluV2l0aFBob25lTnVtYmVyUmVzcG9uc2VcbiAgfCBTaWduSW5XaXRoSWRwUmVzcG9uc2VcbiAgfCBJZFRva2VuUmVzcG9uc2U7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBSZWNhcHRjaGFQYXJhbWV0ZXJzIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7XG4gIFJlY2FwdGNoYSxcbiAgR3JlQ0FQVENIQVRvcExldmVsLFxuICBHcmVDQVBUQ0hBUmVuZGVyT3B0aW9uLFxuICBHcmVDQVBUQ0hBXG59IGZyb20gJy4vcmVjYXB0Y2hhJztcblxuZXhwb3J0IGNvbnN0IF9TT0xWRV9USU1FX01TID0gNTAwO1xuZXhwb3J0IGNvbnN0IF9FWFBJUkFUSU9OX1RJTUVfTVMgPSA2MF8wMDA7XG5leHBvcnQgY29uc3QgX1dJREdFVF9JRF9TVEFSVCA9IDFfMDAwXzAwMF8wMDBfMDAwO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdpZGdldCB7XG4gIGdldFJlc3BvbnNlOiAoKSA9PiBzdHJpbmcgfCBudWxsO1xuICBkZWxldGU6ICgpID0+IHZvaWQ7XG4gIGV4ZWN1dGU6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBNb2NrUmVDYXB0Y2hhIGltcGxlbWVudHMgUmVjYXB0Y2hhIHtcbiAgcHJpdmF0ZSBjb3VudGVyID0gX1dJREdFVF9JRF9TVEFSVDtcbiAgX3dpZGdldHMgPSBuZXcgTWFwPG51bWJlciwgV2lkZ2V0PigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXV0aDogQXV0aEludGVybmFsKSB7fVxuXG4gIHJlbmRlcihcbiAgICBjb250YWluZXI6IHN0cmluZyB8IEhUTUxFbGVtZW50LFxuICAgIHBhcmFtZXRlcnM/OiBSZWNhcHRjaGFQYXJhbWV0ZXJzXG4gICk6IG51bWJlciB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmNvdW50ZXI7XG4gICAgdGhpcy5fd2lkZ2V0cy5zZXQoXG4gICAgICBpZCxcbiAgICAgIG5ldyBNb2NrV2lkZ2V0KGNvbnRhaW5lciwgdGhpcy5hdXRoLm5hbWUsIHBhcmFtZXRlcnMgfHwge30pXG4gICAgKTtcbiAgICB0aGlzLmNvdW50ZXIrKztcbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICByZXNldChvcHRXaWRnZXRJZD86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGlkID0gb3B0V2lkZ2V0SWQgfHwgX1dJREdFVF9JRF9TVEFSVDtcbiAgICB2b2lkIHRoaXMuX3dpZGdldHMuZ2V0KGlkKT8uZGVsZXRlKCk7XG4gICAgdGhpcy5fd2lkZ2V0cy5kZWxldGUoaWQpO1xuICB9XG5cbiAgZ2V0UmVzcG9uc2Uob3B0V2lkZ2V0SWQ/OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IGlkID0gb3B0V2lkZ2V0SWQgfHwgX1dJREdFVF9JRF9TVEFSVDtcbiAgICByZXR1cm4gdGhpcy5fd2lkZ2V0cy5nZXQoaWQpPy5nZXRSZXNwb25zZSgpIHx8ICcnO1xuICB9XG5cbiAgYXN5bmMgZXhlY3V0ZShvcHRXaWRnZXRJZD86IG51bWJlciB8IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgaWQ6IG51bWJlciA9IChvcHRXaWRnZXRJZCBhcyBudW1iZXIpIHx8IF9XSURHRVRfSURfU1RBUlQ7XG4gICAgdm9pZCB0aGlzLl93aWRnZXRzLmdldChpZCk/LmV4ZWN1dGUoKTtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1vY2tHcmVDQVBUQ0hBVG9wTGV2ZWwgaW1wbGVtZW50cyBHcmVDQVBUQ0hBVG9wTGV2ZWwge1xuICBlbnRlcnByaXNlOiBHcmVDQVBUQ0hBID0gbmV3IE1vY2tHcmVDQVBUQ0hBKCk7XG4gIHJlYWR5KGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGV4ZWN1dGUoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9zaXRlS2V5OiBzdHJpbmcsXG4gICAgX29wdGlvbnM6IHsgYWN0aW9uOiBzdHJpbmcgfVxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ3Rva2VuJyk7XG4gIH1cbiAgcmVuZGVyKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBfY29udGFpbmVyOiBzdHJpbmcgfCBIVE1MRWxlbWVudCxcbiAgICBfcGFyYW1ldGVyczogR3JlQ0FQVENIQVJlbmRlck9wdGlvblxuICApOiBzdHJpbmcge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTW9ja0dyZUNBUFRDSEEgaW1wbGVtZW50cyBHcmVDQVBUQ0hBIHtcbiAgcmVhZHkoY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgZXhlY3V0ZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX3NpdGVLZXk6IHN0cmluZyxcbiAgICBfb3B0aW9uczogeyBhY3Rpb246IHN0cmluZyB9XG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgndG9rZW4nKTtcbiAgfVxuICByZW5kZXIoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9jb250YWluZXI6IHN0cmluZyB8IEhUTUxFbGVtZW50LFxuICAgIF9wYXJhbWV0ZXJzOiBHcmVDQVBUQ0hBUmVuZGVyT3B0aW9uXG4gICk6IHN0cmluZyB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNb2NrV2lkZ2V0IHtcbiAgcHJpdmF0ZSByZWFkb25seSBjb250YWluZXI6IEhUTUxFbGVtZW50O1xuICBwcml2YXRlIHJlYWRvbmx5IGlzVmlzaWJsZTogYm9vbGVhbjtcbiAgcHJpdmF0ZSB0aW1lcklkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBkZWxldGVkID0gZmFsc2U7XG4gIHByaXZhdGUgcmVzcG9uc2VUb2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2xpY2tIYW5kbGVyID0gKCk6IHZvaWQgPT4ge1xuICAgIHRoaXMuZXhlY3V0ZSgpO1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNvbnRhaW5lck9ySWQ6IHN0cmluZyB8IEhUTUxFbGVtZW50LFxuICAgIGFwcE5hbWU6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhcmFtczogUmVjYXB0Y2hhUGFyYW1ldGVyc1xuICApIHtcbiAgICBjb25zdCBjb250YWluZXIgPVxuICAgICAgdHlwZW9mIGNvbnRhaW5lck9ySWQgPT09ICdzdHJpbmcnXG4gICAgICAgID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVyT3JJZClcbiAgICAgICAgOiBjb250YWluZXJPcklkO1xuICAgIF9hc3NlcnQoY29udGFpbmVyLCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SLCB7IGFwcE5hbWUgfSk7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmlzVmlzaWJsZSA9IHRoaXMucGFyYW1zLnNpemUgIT09ICdpbnZpc2libGUnO1xuICAgIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgdGhpcy5leGVjdXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGdldFJlc3BvbnNlKCk6IHN0cmluZyB8IG51bGwge1xuICAgIHRoaXMuY2hlY2tJZkRlbGV0ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZVRva2VuO1xuICB9XG5cbiAgZGVsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tJZkRlbGV0ZWQoKTtcbiAgICB0aGlzLmRlbGV0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLnRpbWVySWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgdGhpcy50aW1lcklkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcik7XG4gIH1cblxuICBleGVjdXRlKCk6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tJZkRlbGV0ZWQoKTtcbiAgICBpZiAodGhpcy50aW1lcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50aW1lcklkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5yZXNwb25zZVRva2VuID0gZ2VuZXJhdGVSYW5kb21BbHBoYU51bWVyaWNTdHJpbmcoNTApO1xuICAgICAgY29uc3QgeyBjYWxsYmFjaywgJ2V4cGlyZWQtY2FsbGJhY2snOiBleHBpcmVkQ2FsbGJhY2sgfSA9IHRoaXMucGFyYW1zO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbGJhY2sodGhpcy5yZXNwb25zZVRva2VuKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cblxuICAgICAgdGhpcy50aW1lcklkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnRpbWVySWQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc3BvbnNlVG9rZW4gPSBudWxsO1xuICAgICAgICBpZiAoZXhwaXJlZENhbGxiYWNrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV4cGlyZWRDYWxsYmFjaygpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICAgICAgfVxuICAgICAgfSwgX0VYUElSQVRJT05fVElNRV9NUyk7XG4gICAgfSwgX1NPTFZFX1RJTUVfTVMpO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0lmRGVsZXRlZCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlQ0FQVENIQSBtb2NrIHdhcyBhbHJlYWR5IGRlbGV0ZWQhJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tQWxwaGFOdW1lcmljU3RyaW5nKGxlbjogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgY2hhcnMgPSBbXTtcbiAgY29uc3QgYWxsb3dlZENoYXJzID1cbiAgICAnMTIzNDU2Nzg5MGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2hhcnMucHVzaChcbiAgICAgIGFsbG93ZWRDaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYWxsb3dlZENoYXJzLmxlbmd0aCkpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2hhcnMuam9pbignJyk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBxdWVyeXN0cmluZyB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQsIF9jcmVhdGVFcnJvciB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgRGVsYXkgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvZGVsYXknO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBfd2luZG93IH0gZnJvbSAnLi4vYXV0aF93aW5kb3cnO1xuaW1wb3J0ICogYXMganNIZWxwZXJzIGZyb20gJy4uL2xvYWRfanMnO1xuaW1wb3J0IHsgUmVjYXB0Y2hhLCBpc1YyIH0gZnJvbSAnLi9yZWNhcHRjaGEnO1xuaW1wb3J0IHsgTW9ja1JlQ2FwdGNoYSB9IGZyb20gJy4vcmVjYXB0Y2hhX21vY2snO1xuXG4vLyBSZUNhcHRjaGEgd2lsbCBsb2FkIHVzaW5nIHRoZSBzYW1lIGNhbGxiYWNrLCBzbyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gbmVlZHNcbi8vIHRvIGJlIGtlcHQgYXJvdW5kXG5leHBvcnQgY29uc3QgX0pTTE9BRF9DQUxMQkFDSyA9IGpzSGVscGVycy5fZ2VuZXJhdGVDYWxsYmFja05hbWUoJ3JjYicpO1xuY29uc3QgTkVUV09SS19USU1FT1VUX0RFTEFZID0gbmV3IERlbGF5KDMwMDAwLCA2MDAwMCk7XG5jb25zdCBSRUNBUFRDSEFfQkFTRSA9ICdodHRwczovL3d3dy5nb29nbGUuY29tL3JlY2FwdGNoYS9hcGkuanM/JztcblxuLyoqXG4gKiBXZSBuZWVkIHRvIG1hcmsgdGhpcyBpbnRlcmZhY2UgYXMgaW50ZXJuYWwgZXhwbGljaXRseSB0byBleGNsdWRlIGl0IGluIHRoZSBwdWJsaWMgdHlwaW5ncywgYmVjYXVzZVxuICogaXQgcmVmZXJlbmNlcyBBdXRoSW50ZXJuYWwgd2hpY2ggaGFzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSB3aXRoIFVzZXJJbnRlcm5hbC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZUNhcHRjaGFMb2FkZXIge1xuICBsb2FkKGF1dGg6IEF1dGhJbnRlcm5hbCwgaGw/OiBzdHJpbmcpOiBQcm9taXNlPFJlY2FwdGNoYT47XG4gIGNsZWFyZWRPbmVJbnN0YW5jZSgpOiB2b2lkO1xufVxuXG4vKipcbiAqIExvYWRlciBmb3IgdGhlIEdSZUNhcHRjaGEgbGlicmFyeS4gVGhlcmUgc2hvdWxkIG9ubHkgZXZlciBiZSBvbmUgb2YgdGhpcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlQ2FwdGNoYUxvYWRlckltcGwgaW1wbGVtZW50cyBSZUNhcHRjaGFMb2FkZXIge1xuICBwcml2YXRlIGhvc3RMYW5ndWFnZSA9ICcnO1xuICBwcml2YXRlIGNvdW50ZXIgPSAwO1xuICAvKipcbiAgICogQ2hlY2sgZm9yIGByZW5kZXIoKWAgbWV0aG9kLiBgd2luZG93LmdyZWNhcHRjaGFgIHdpbGwgZXhpc3QgaWYgdGhlIEVudGVycHJpc2VcbiAgICogdmVyc2lvbiBvZiB0aGUgUmVDQVBUQ0hBIHNjcmlwdCB3YXMgbG9hZGVkIGJ5IHNvbWVvbmUgZWxzZSAoZS5nLiBBcHAgQ2hlY2spIGJ1dFxuICAgKiBgd2luZG93LmdyZWNhcHRjaGEucmVuZGVyKClgIHdpbGwgbm90LiBBbm90aGVyIGxvYWQgd2lsbCBhZGQgaXQuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGxpYnJhcnlTZXBhcmF0ZWx5TG9hZGVkID0gISFfd2luZG93KCkuZ3JlY2FwdGNoYT8ucmVuZGVyO1xuXG4gIGxvYWQoYXV0aDogQXV0aEludGVybmFsLCBobCA9ICcnKTogUHJvbWlzZTxSZWNhcHRjaGE+IHtcbiAgICBfYXNzZXJ0KGlzSG9zdExhbmd1YWdlVmFsaWQoaGwpLCBhdXRoLCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SKTtcblxuICAgIGlmICh0aGlzLnNob3VsZFJlc29sdmVJbW1lZGlhdGVseShobCkgJiYgaXNWMihfd2luZG93KCkuZ3JlY2FwdGNoYSkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3dpbmRvdygpLmdyZWNhcHRjaGEhIGFzIFJlY2FwdGNoYSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxSZWNhcHRjaGE+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IG5ldHdvcmtUaW1lb3V0ID0gX3dpbmRvdygpLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QoX2NyZWF0ZUVycm9yKGF1dGgsIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCkpO1xuICAgICAgfSwgTkVUV09SS19USU1FT1VUX0RFTEFZLmdldCgpKTtcblxuICAgICAgX3dpbmRvdygpW19KU0xPQURfQ0FMTEJBQ0tdID0gKCkgPT4ge1xuICAgICAgICBfd2luZG93KCkuY2xlYXJUaW1lb3V0KG5ldHdvcmtUaW1lb3V0KTtcbiAgICAgICAgZGVsZXRlIF93aW5kb3coKVtfSlNMT0FEX0NBTExCQUNLXTtcblxuICAgICAgICBjb25zdCByZWNhcHRjaGEgPSBfd2luZG93KCkuZ3JlY2FwdGNoYSBhcyBSZWNhcHRjaGE7XG5cbiAgICAgICAgaWYgKCFyZWNhcHRjaGEgfHwgIWlzVjIocmVjYXB0Y2hhKSkge1xuICAgICAgICAgIHJlamVjdChfY3JlYXRlRXJyb3IoYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyYXAgdGhlIGdyZXB0Y2hhIHJlbmRlciBmdW5jdGlvbiBzbyB0aGF0IHdlIGtub3cgaWYgdGhlIGRldmVsb3BlciBoYXNcbiAgICAgICAgLy8gY2FsbGVkIGl0IHNlcGFyYXRlbHlcbiAgICAgICAgY29uc3QgcmVuZGVyID0gcmVjYXB0Y2hhLnJlbmRlcjtcbiAgICAgICAgcmVjYXB0Y2hhLnJlbmRlciA9IChjb250YWluZXIsIHBhcmFtcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHdpZGdldElkID0gcmVuZGVyKGNvbnRhaW5lciwgcGFyYW1zKTtcbiAgICAgICAgICB0aGlzLmNvdW50ZXIrKztcbiAgICAgICAgICByZXR1cm4gd2lkZ2V0SWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ob3N0TGFuZ3VhZ2UgPSBobDtcbiAgICAgICAgcmVzb2x2ZShyZWNhcHRjaGEpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDQVBUQ0hBX0JBU0V9PyR7cXVlcnlzdHJpbmcoe1xuICAgICAgICBvbmxvYWQ6IF9KU0xPQURfQ0FMTEJBQ0ssXG4gICAgICAgIHJlbmRlcjogJ2V4cGxpY2l0JyxcbiAgICAgICAgaGxcbiAgICAgIH0pfWA7XG5cbiAgICAgIGpzSGVscGVycy5fbG9hZEpTKHVybCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQobmV0d29ya1RpbWVvdXQpO1xuICAgICAgICByZWplY3QoX2NyZWF0ZUVycm9yKGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJlZE9uZUluc3RhbmNlKCk6IHZvaWQge1xuICAgIHRoaXMuY291bnRlci0tO1xuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRSZXNvbHZlSW1tZWRpYXRlbHkoaGw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIFdlIGNhbiByZXNvbHZlIGltbWVkaWF0ZWx5IGlmOlxuICAgIC8vICAg4oCiIGdyZWNhcHRjaGEgaXMgYWxyZWFkeSBkZWZpbmVkIEFORCAoXG4gICAgLy8gICAgIDEuIHRoZSByZXF1ZXN0ZWQgbGFuZ3VhZ2UgY29kZXMgYXJlIHRoZSBzYW1lIE9SXG4gICAgLy8gICAgIDIuIHRoZXJlIGV4aXN0cyBhbHJlYWR5IGEgUmVDYXB0Y2hhIG9uIHRoZSBwYWdlXG4gICAgLy8gICAgIDMuIHRoZSBsaWJyYXJ5IHdhcyBhbHJlYWR5IGxvYWRlZCBieSB0aGUgYXBwXG4gICAgLy8gSW4gY2FzZXMgKDIpIGFuZCAoMyksIHdlIF9jYW4ndF8gcmVsb2FkIGFzIGl0IHdvdWxkIGJyZWFrIHRoZSByZWNhcHRjaGFzXG4gICAgLy8gdGhhdCBhcmUgYWxyZWFkeSBpbiB0aGUgcGFnZVxuICAgIHJldHVybiAoXG4gICAgICAhIV93aW5kb3coKS5ncmVjYXB0Y2hhPy5yZW5kZXIgJiZcbiAgICAgIChobCA9PT0gdGhpcy5ob3N0TGFuZ3VhZ2UgfHxcbiAgICAgICAgdGhpcy5jb3VudGVyID4gMCB8fFxuICAgICAgICB0aGlzLmxpYnJhcnlTZXBhcmF0ZWx5TG9hZGVkKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNIb3N0TGFuZ3VhZ2VWYWxpZChobDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBobC5sZW5ndGggPD0gNiAmJiAvXlxccypbYS16QS1aMC05XFwtXSpcXHMqJC8udGVzdChobCk7XG59XG5cbmV4cG9ydCBjbGFzcyBNb2NrUmVDYXB0Y2hhTG9hZGVySW1wbCBpbXBsZW1lbnRzIFJlQ2FwdGNoYUxvYWRlciB7XG4gIGFzeW5jIGxvYWQoYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxSZWNhcHRjaGE+IHtcbiAgICByZXR1cm4gbmV3IE1vY2tSZUNhcHRjaGEoYXV0aCk7XG4gIH1cblxuICBjbGVhcmVkT25lSW5zdGFuY2UoKTogdm9pZCB7fVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aCwgUmVjYXB0Y2hhUGFyYW1ldGVycyB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBnZXRSZWNhcHRjaGFQYXJhbXMgfSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vcmVjYXB0Y2hhJztcbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4uLy4uL2NvcmUvYXV0aC9hdXRoX2ltcGwnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IF9pc0h0dHBPckh0dHBzIH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2xvY2F0aW9uJztcbmltcG9ydCB7IEFwcGxpY2F0aW9uVmVyaWZpZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2FwcGxpY2F0aW9uX3ZlcmlmaWVyJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgX3dpbmRvdyB9IGZyb20gJy4uL2F1dGhfd2luZG93JztcbmltcG9ydCB7IF9pc1dvcmtlciB9IGZyb20gJy4uL3V0aWwvd29ya2VyJztcbmltcG9ydCB7IFJlY2FwdGNoYSB9IGZyb20gJy4vcmVjYXB0Y2hhJztcbmltcG9ydCB7XG4gIE1vY2tSZUNhcHRjaGFMb2FkZXJJbXBsLFxuICBSZUNhcHRjaGFMb2FkZXIsXG4gIFJlQ2FwdGNoYUxvYWRlckltcGxcbn0gZnJvbSAnLi9yZWNhcHRjaGFfbG9hZGVyJztcblxuZXhwb3J0IGNvbnN0IFJFQ0FQVENIQV9WRVJJRklFUl9UWVBFID0gJ3JlY2FwdGNoYSc7XG5cbmNvbnN0IERFRkFVTFRfUEFSQU1TOiBSZWNhcHRjaGFQYXJhbWV0ZXJzID0ge1xuICB0aGVtZTogJ2xpZ2h0JyxcbiAgdHlwZTogJ2ltYWdlJ1xufTtcblxudHlwZSBUb2tlbkNhbGxiYWNrID0gKHRva2VuOiBzdHJpbmcpID0+IHZvaWQ7XG5cbi8qKlxuICogQW4ge0BsaW5rIGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vcmVjYXB0Y2hhLyB8IHJlQ0FQVENIQX0tYmFzZWQgYXBwbGljYXRpb24gdmVyaWZpZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVjYXB0Y2hhVmVyaWZpZXIgaW1wbGVtZW50cyBBcHBsaWNhdGlvblZlcmlmaWVySW50ZXJuYWwge1xuICAvKipcbiAgICogVGhlIGFwcGxpY2F0aW9uIHZlcmlmaWVyIHR5cGUuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEZvciBhIHJlQ0FQVENIQSB2ZXJpZmllciwgdGhpcyBpcyAncmVjYXB0Y2hhJy5cbiAgICovXG4gIHJlYWRvbmx5IHR5cGUgPSBSRUNBUFRDSEFfVkVSSUZJRVJfVFlQRTtcbiAgcHJpdmF0ZSBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSB3aWRnZXRJZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSByZWFkb25seSBpc0ludmlzaWJsZTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSB0b2tlbkNoYW5nZUxpc3RlbmVycyA9IG5ldyBTZXQ8VG9rZW5DYWxsYmFjaz4oKTtcbiAgcHJpdmF0ZSByZW5kZXJQcm9taXNlOiBQcm9taXNlPG51bWJlcj4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSByZWFkb25seSBhdXRoOiBBdXRoSW50ZXJuYWw7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWFkb25seSBfcmVjYXB0Y2hhTG9hZGVyOiBSZUNhcHRjaGFMb2FkZXI7XG4gIHByaXZhdGUgcmVjYXB0Y2hhOiBSZWNhcHRjaGEgfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGNvbnRhaW5lck9ySWQgLSBUaGUgcmVDQVBUQ0hBIGNvbnRhaW5lciBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoaXMgaGFzIGRpZmZlcmVudCBtZWFuaW5nIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSByZUNBUFRDSEEgaXMgaGlkZGVuIG9yIHZpc2libGUuIEZvciBhXG4gICAqIHZpc2libGUgcmVDQVBUQ0hBIHRoZSBjb250YWluZXIgbXVzdCBiZSBlbXB0eS4gSWYgYSBzdHJpbmcgaXMgdXNlZCwgaXQgaGFzIHRvIGNvcnJlc3BvbmQgdG9cbiAgICogYW4gZWxlbWVudCBJRC4gVGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBtdXN0IGFsc28gbXVzdCBiZSBpbiB0aGUgRE9NIGF0IHRoZSB0aW1lIG9mXG4gICAqIGluaXRpYWxpemF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1ldGVycyAtIFRoZSBvcHRpb25hbCByZUNBUFRDSEEgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQ2hlY2sgdGhlIHJlQ0FQVENIQSBkb2NzIGZvciBhIGNvbXByZWhlbnNpdmUgbGlzdC4gQWxsIHBhcmFtZXRlcnMgYXJlIGFjY2VwdGVkIGV4Y2VwdCBmb3JcbiAgICogdGhlIHNpdGVrZXkuIEZpcmViYXNlIEF1dGggYmFja2VuZCBwcm92aXNpb25zIGEgcmVDQVBUQ0hBIGZvciBlYWNoIHByb2plY3QgYW5kIHdpbGxcbiAgICogY29uZmlndXJlIHRoaXMgdXBvbiByZW5kZXJpbmcuIEZvciBhbiBpbnZpc2libGUgcmVDQVBUQ0hBLCBhIHNpemUga2V5IG11c3QgaGF2ZSB0aGUgdmFsdWVcbiAgICogJ2ludmlzaWJsZScuXG4gICAqXG4gICAqIEBwYXJhbSBhdXRoRXh0ZXJuIC0gVGhlIGNvcnJlc3BvbmRpbmcgRmlyZWJhc2Uge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgY29udGFpbmVyT3JJZDogSFRNTEVsZW1lbnQgfCBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwYXJhbWV0ZXJzOiBSZWNhcHRjaGFQYXJhbWV0ZXJzID0ge1xuICAgICAgLi4uREVGQVVMVF9QQVJBTVNcbiAgICB9LFxuICAgIGF1dGhFeHRlcm46IEF1dGhcbiAgKSB7XG4gICAgdGhpcy5hdXRoID0gX2Nhc3RBdXRoKGF1dGhFeHRlcm4pO1xuICAgIHRoaXMuaXNJbnZpc2libGUgPSB0aGlzLnBhcmFtZXRlcnMuc2l6ZSA9PT0gJ2ludmlzaWJsZSc7XG4gICAgX2Fzc2VydChcbiAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgICB0aGlzLmF1dGgsXG4gICAgICBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEXG4gICAgKTtcbiAgICBjb25zdCBjb250YWluZXIgPVxuICAgICAgdHlwZW9mIGNvbnRhaW5lck9ySWQgPT09ICdzdHJpbmcnXG4gICAgICAgID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVyT3JJZClcbiAgICAgICAgOiBjb250YWluZXJPcklkO1xuICAgIF9hc3NlcnQoY29udGFpbmVyLCB0aGlzLmF1dGgsIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IpO1xuXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5wYXJhbWV0ZXJzLmNhbGxiYWNrID0gdGhpcy5tYWtlVG9rZW5DYWxsYmFjayh0aGlzLnBhcmFtZXRlcnMuY2FsbGJhY2spO1xuXG4gICAgdGhpcy5fcmVjYXB0Y2hhTG9hZGVyID0gdGhpcy5hdXRoLnNldHRpbmdzLmFwcFZlcmlmaWNhdGlvbkRpc2FibGVkRm9yVGVzdGluZ1xuICAgICAgPyBuZXcgTW9ja1JlQ2FwdGNoYUxvYWRlckltcGwoKVxuICAgICAgOiBuZXcgUmVDYXB0Y2hhTG9hZGVySW1wbCgpO1xuXG4gICAgdGhpcy52YWxpZGF0ZVN0YXJ0aW5nU3RhdGUoKTtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IGlmIHNkayB2ZXJzaW9uIGlzIG5lZWRlZFxuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciB0aGUgdXNlciB0byBzb2x2ZSB0aGUgcmVDQVBUQ0hBIGFuZCByZXNvbHZlcyB3aXRoIHRoZSByZUNBUFRDSEEgdG9rZW4uXG4gICAqXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSBmb3IgdGhlIHJlQ0FQVENIQSB0b2tlbi5cbiAgICovXG4gIGFzeW5jIHZlcmlmeSgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRoaXMuYXNzZXJ0Tm90RGVzdHJveWVkKCk7XG4gICAgY29uc3QgaWQgPSBhd2FpdCB0aGlzLnJlbmRlcigpO1xuICAgIGNvbnN0IHJlY2FwdGNoYSA9IHRoaXMuZ2V0QXNzZXJ0ZWRSZWNhcHRjaGEoKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gcmVjYXB0Y2hhLmdldFJlc3BvbnNlKGlkKTtcbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPihyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHRva2VuQ2hhbmdlID0gKHRva2VuOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgIHJldHVybjsgLy8gSWdub3JlIHRva2VuIGV4cGlyYXRpb25zLlxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5DaGFuZ2VMaXN0ZW5lcnMuZGVsZXRlKHRva2VuQ2hhbmdlKTtcbiAgICAgICAgcmVzb2x2ZSh0b2tlbik7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnRva2VuQ2hhbmdlTGlzdGVuZXJzLmFkZCh0b2tlbkNoYW5nZSk7XG4gICAgICBpZiAodGhpcy5pc0ludmlzaWJsZSkge1xuICAgICAgICByZWNhcHRjaGEuZXhlY3V0ZShpZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcmVDQVBUQ0hBIHdpZGdldCBvbiB0aGUgcGFnZS5cbiAgICpcbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVDQVBUQ0hBIHdpZGdldCBJRC5cbiAgICovXG4gIHJlbmRlcigpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmFzc2VydE5vdERlc3Ryb3llZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgYSBwcm9taXNlLiBTaW5jZSBpdCdzIG5vdCBhc3luYyAod2Ugd2FudCB0byByZXR1cm4gdGhlXG4gICAgICAvLyBfc2FtZV8gcHJvbWlzZSBpZiByZW5kZXJpbmcgaXMgc3RpbGwgb2NjdXJyaW5nKSwgdGhlIEFQSSBzdXJmYWNlIHNob3VsZFxuICAgICAgLy8gcmVqZWN0IHdpdGggdGhlIGVycm9yIHJhdGhlciB0aGFuIGp1c3QgdGhyb3dcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJQcm9taXNlO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyUHJvbWlzZSA9IHRoaXMubWFrZVJlbmRlclByb21pc2UoKS5jYXRjaChlID0+IHtcbiAgICAgIHRoaXMucmVuZGVyUHJvbWlzZSA9IG51bGw7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyUHJvbWlzZTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3Jlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuYXNzZXJ0Tm90RGVzdHJveWVkKCk7XG4gICAgaWYgKHRoaXMud2lkZ2V0SWQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZ2V0QXNzZXJ0ZWRSZWNhcHRjaGEoKS5yZXNldCh0aGlzLndpZGdldElkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSByZUNBUFRDSEEgd2lkZ2V0IGZyb20gdGhlIHBhZ2UgYW5kIGRlc3Ryb3lzIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuYXNzZXJ0Tm90RGVzdHJveWVkKCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3JlY2FwdGNoYUxvYWRlci5jbGVhcmVkT25lSW5zdGFuY2UoKTtcbiAgICBpZiAoIXRoaXMuaXNJbnZpc2libGUpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNoaWxkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlU3RhcnRpbmdTdGF0ZSgpOiB2b2lkIHtcbiAgICBfYXNzZXJ0KCF0aGlzLnBhcmFtZXRlcnMuc2l0ZWtleSwgdGhpcy5hdXRoLCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SKTtcbiAgICBfYXNzZXJ0KFxuICAgICAgdGhpcy5pc0ludmlzaWJsZSB8fCAhdGhpcy5jb250YWluZXIuaGFzQ2hpbGROb2RlcygpLFxuICAgICAgdGhpcy5hdXRoLFxuICAgICAgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUlxuICAgICk7XG4gICAgX2Fzc2VydChcbiAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgICB0aGlzLmF1dGgsXG4gICAgICBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgbWFrZVRva2VuQ2FsbGJhY2soXG4gICAgZXhpc3Rpbmc6IFRva2VuQ2FsbGJhY2sgfCBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKTogVG9rZW5DYWxsYmFjayB7XG4gICAgcmV0dXJuIHRva2VuID0+IHtcbiAgICAgIHRoaXMudG9rZW5DaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcih0b2tlbikpO1xuICAgICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBleGlzdGluZyh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgZ2xvYmFsRnVuYyA9IF93aW5kb3coKVtleGlzdGluZ107XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsRnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdsb2JhbEZ1bmModG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYXNzZXJ0Tm90RGVzdHJveWVkKCk6IHZvaWQge1xuICAgIF9hc3NlcnQoIXRoaXMuZGVzdHJveWVkLCB0aGlzLmF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBtYWtlUmVuZGVyUHJvbWlzZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGlmICghdGhpcy53aWRnZXRJZCkge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgaWYgKCF0aGlzLmlzSW52aXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IGd1YXJhbnRlZWRFbXB0eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ3VhcmFudGVlZEVtcHR5KTtcbiAgICAgICAgY29udGFpbmVyID0gZ3VhcmFudGVlZEVtcHR5O1xuICAgICAgfVxuXG4gICAgICB0aGlzLndpZGdldElkID0gdGhpcy5nZXRBc3NlcnRlZFJlY2FwdGNoYSgpLnJlbmRlcihcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICB0aGlzLnBhcmFtZXRlcnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMud2lkZ2V0SWQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgX2Fzc2VydChcbiAgICAgIF9pc0h0dHBPckh0dHBzKCkgJiYgIV9pc1dvcmtlcigpLFxuICAgICAgdGhpcy5hdXRoLFxuICAgICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUlxuICAgICk7XG5cbiAgICBhd2FpdCBkb21SZWFkeSgpO1xuICAgIHRoaXMucmVjYXB0Y2hhID0gYXdhaXQgdGhpcy5fcmVjYXB0Y2hhTG9hZGVyLmxvYWQoXG4gICAgICB0aGlzLmF1dGgsXG4gICAgICB0aGlzLmF1dGgubGFuZ3VhZ2VDb2RlIHx8IHVuZGVmaW5lZFxuICAgICk7XG5cbiAgICBjb25zdCBzaXRlS2V5ID0gYXdhaXQgZ2V0UmVjYXB0Y2hhUGFyYW1zKHRoaXMuYXV0aCk7XG4gICAgX2Fzc2VydChzaXRlS2V5LCB0aGlzLmF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgIHRoaXMucGFyYW1ldGVycy5zaXRla2V5ID0gc2l0ZUtleTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QXNzZXJ0ZWRSZWNhcHRjaGEoKTogUmVjYXB0Y2hhIHtcbiAgICBfYXNzZXJ0KHRoaXMucmVjYXB0Y2hhLCB0aGlzLmF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgIHJldHVybiB0aGlzLnJlY2FwdGNoYTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb21SZWFkeSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgbGV0IHJlc29sdmVyOiAoKCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4ge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRG9jdW1lbnQgbm90IHJlYWR5LCB3YWl0IGZvciBsb2FkIGJlZm9yZSByZXNvbHZpbmcuXG4gICAgLy8gU2F2ZSByZXNvbHZlciwgc28gd2UgY2FuIHJlbW92ZSBsaXN0ZW5lciBpbiBjYXNlIGl0IHdhcyBleHRlcm5hbGx5XG4gICAgLy8gY2FuY2VsbGVkLlxuICAgIHJlc29sdmVyID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgcmVzb2x2ZXIpO1xuICB9KS5jYXRjaChlID0+IHtcbiAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgcmVzb2x2ZXIpO1xuICAgIH1cblxuICAgIHRocm93IGU7XG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgQXBwbGljYXRpb25WZXJpZmllcixcbiAgQXV0aCxcbiAgQ29uZmlybWF0aW9uUmVzdWx0LFxuICBQaG9uZUluZm9PcHRpb25zLFxuICBVc2VyLFxuICBVc2VyQ3JlZGVudGlhbFxufSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBzdGFydEVucm9sbFBob25lTWZhIH0gZnJvbSAnLi4vLi4vYXBpL2FjY291bnRfbWFuYWdlbWVudC9tZmEnO1xuaW1wb3J0IHsgc3RhcnRTaWduSW5QaG9uZU1mYSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9tZmEnO1xuaW1wb3J0IHsgc2VuZFBob25lVmVyaWZpY2F0aW9uQ29kZSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9zbXMnO1xuaW1wb3J0IHsgQXBwbGljYXRpb25WZXJpZmllckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXBwbGljYXRpb25fdmVyaWZpZXInO1xuaW1wb3J0IHsgUGhvbmVBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uLy4uL2NvcmUvY3JlZGVudGlhbHMvcGhvbmUnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnRMaW5rZWRTdGF0dXMsIF9saW5rIH0gZnJvbSAnLi4vLi4vY29yZS91c2VyL2xpbmtfdW5saW5rJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHtcbiAgbGlua1dpdGhDcmVkZW50aWFsLFxuICByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsLFxuICBzaWduSW5XaXRoQ3JlZGVudGlhbFxufSBmcm9tICcuLi8uLi9jb3JlL3N0cmF0ZWdpZXMvY3JlZGVudGlhbCc7XG5pbXBvcnQge1xuICBNdWx0aUZhY3RvclNlc3Npb25JbXBsLFxuICBNdWx0aUZhY3RvclNlc3Npb25UeXBlXG59IGZyb20gJy4uLy4uL21mYS9tZmFfc2Vzc2lvbic7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IFJFQ0FQVENIQV9WRVJJRklFUl9UWVBFIH0gZnJvbSAnLi4vcmVjYXB0Y2hhL3JlY2FwdGNoYV92ZXJpZmllcic7XG5pbXBvcnQgeyBfY2FzdEF1dGggfSBmcm9tICcuLi8uLi9jb3JlL2F1dGgvYXV0aF9pbXBsJztcbmltcG9ydCB7IGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFByb3ZpZGVySWQgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbmludGVyZmFjZSBPbkNvbmZpcm1hdGlvbkNhbGxiYWNrIHtcbiAgKGNyZWRlbnRpYWw6IFBob25lQXV0aENyZWRlbnRpYWwpOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsPjtcbn1cblxuY2xhc3MgQ29uZmlybWF0aW9uUmVzdWx0SW1wbCBpbXBsZW1lbnRzIENvbmZpcm1hdGlvblJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IHZlcmlmaWNhdGlvbklkOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBvbkNvbmZpcm1hdGlvbjogT25Db25maXJtYXRpb25DYWxsYmFja1xuICApIHt9XG5cbiAgY29uZmlybSh2ZXJpZmljYXRpb25Db2RlOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsPiB7XG4gICAgY29uc3QgYXV0aENyZWRlbnRpYWwgPSBQaG9uZUF1dGhDcmVkZW50aWFsLl9mcm9tVmVyaWZpY2F0aW9uKFxuICAgICAgdGhpcy52ZXJpZmljYXRpb25JZCxcbiAgICAgIHZlcmlmaWNhdGlvbkNvZGVcbiAgICApO1xuICAgIHJldHVybiB0aGlzLm9uQ29uZmlybWF0aW9uKGF1dGhDcmVkZW50aWFsKTtcbiAgfVxufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHVzaW5nIGEgcGhvbmUgbnVtYmVyLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIG1ldGhvZCBzZW5kcyBhIGNvZGUgdmlhIFNNUyB0byB0aGUgZ2l2ZW5cbiAqIHBob25lIG51bWJlciwgYW5kIHJldHVybnMgYSB7QGxpbmsgQ29uZmlybWF0aW9uUmVzdWx0fS4gQWZ0ZXIgdGhlIHVzZXJcbiAqIHByb3ZpZGVzIHRoZSBjb2RlIHNlbnQgdG8gdGhlaXIgcGhvbmUsIGNhbGwge0BsaW5rIENvbmZpcm1hdGlvblJlc3VsdC5jb25maXJtfVxuICogd2l0aCB0aGUgY29kZSB0byBzaWduIHRoZSB1c2VyIGluLlxuICpcbiAqIEZvciBhYnVzZSBwcmV2ZW50aW9uLCB0aGlzIG1ldGhvZCBhbHNvIHJlcXVpcmVzIGEge0BsaW5rIEFwcGxpY2F0aW9uVmVyaWZpZXJ9LlxuICogVGhpcyBTREsgaW5jbHVkZXMgYSByZUNBUFRDSEEtYmFzZWQgaW1wbGVtZW50YXRpb24sIHtAbGluayBSZWNhcHRjaGFWZXJpZmllcn0uXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiB3b3JrIG9uIG90aGVyIHBsYXRmb3JtcyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoZVxuICoge0BsaW5rIFJlY2FwdGNoYVZlcmlmaWVyfSAobGlrZSBSZWFjdCBOYXRpdmUpLCBidXQgeW91IG5lZWQgdG8gdXNlIGFcbiAqIHRoaXJkLXBhcnR5IHtAbGluayBBcHBsaWNhdGlvblZlcmlmaWVyfSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gJ3JlY2FwdGNoYS1jb250YWluZXInIGlzIHRoZSBJRCBvZiBhbiBlbGVtZW50IGluIHRoZSBET00uXG4gKiBjb25zdCBhcHBsaWNhdGlvblZlcmlmaWVyID0gbmV3IGZpcmViYXNlLmF1dGguUmVjYXB0Y2hhVmVyaWZpZXIoJ3JlY2FwdGNoYS1jb250YWluZXInKTtcbiAqIGNvbnN0IGNvbmZpcm1hdGlvblJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQaG9uZU51bWJlcihhdXRoLCBwaG9uZU51bWJlciwgYXBwbGljYXRpb25WZXJpZmllcik7XG4gKiAvLyBPYnRhaW4gYSB2ZXJpZmljYXRpb25Db2RlIGZyb20gdGhlIHVzZXIuXG4gKiBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgY29uZmlybWF0aW9uUmVzdWx0LmNvbmZpcm0odmVyaWZpY2F0aW9uQ29kZSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gcGhvbmVOdW1iZXIgLSBUaGUgdXNlcidzIHBob25lIG51bWJlciBpbiBFLjE2NCBmb3JtYXQgKGUuZy4gKzE2NTA1NTUwMTAxKS5cbiAqIEBwYXJhbSBhcHBWZXJpZmllciAtIFRoZSB7QGxpbmsgQXBwbGljYXRpb25WZXJpZmllcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aFBob25lTnVtYmVyKFxuICBhdXRoOiBBdXRoLFxuICBwaG9uZU51bWJlcjogc3RyaW5nLFxuICBhcHBWZXJpZmllcjogQXBwbGljYXRpb25WZXJpZmllclxuKTogUHJvbWlzZTxDb25maXJtYXRpb25SZXN1bHQ+IHtcbiAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICBjb25zdCB2ZXJpZmljYXRpb25JZCA9IGF3YWl0IF92ZXJpZnlQaG9uZU51bWJlcihcbiAgICBhdXRoSW50ZXJuYWwsXG4gICAgcGhvbmVOdW1iZXIsXG4gICAgZ2V0TW9kdWxhckluc3RhbmNlKGFwcFZlcmlmaWVyIGFzIEFwcGxpY2F0aW9uVmVyaWZpZXJJbnRlcm5hbClcbiAgKTtcbiAgcmV0dXJuIG5ldyBDb25maXJtYXRpb25SZXN1bHRJbXBsKHZlcmlmaWNhdGlvbklkLCBjcmVkID0+XG4gICAgc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aEludGVybmFsLCBjcmVkKVxuICApO1xufVxuXG4vKipcbiAqIExpbmtzIHRoZSB1c2VyIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gcGhvbmUgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gcGhvbmVOdW1iZXIgLSBUaGUgdXNlcidzIHBob25lIG51bWJlciBpbiBFLjE2NCBmb3JtYXQgKGUuZy4gKzE2NTA1NTUwMTAxKS5cbiAqIEBwYXJhbSBhcHBWZXJpZmllciAtIFRoZSB7QGxpbmsgQXBwbGljYXRpb25WZXJpZmllcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbGlua1dpdGhQaG9uZU51bWJlcihcbiAgdXNlcjogVXNlcixcbiAgcGhvbmVOdW1iZXI6IHN0cmluZyxcbiAgYXBwVmVyaWZpZXI6IEFwcGxpY2F0aW9uVmVyaWZpZXJcbik6IFByb21pc2U8Q29uZmlybWF0aW9uUmVzdWx0PiB7XG4gIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWw7XG4gIGF3YWl0IF9hc3NlcnRMaW5rZWRTdGF0dXMoZmFsc2UsIHVzZXJJbnRlcm5hbCwgUHJvdmlkZXJJZC5QSE9ORSk7XG4gIGNvbnN0IHZlcmlmaWNhdGlvbklkID0gYXdhaXQgX3ZlcmlmeVBob25lTnVtYmVyKFxuICAgIHVzZXJJbnRlcm5hbC5hdXRoLFxuICAgIHBob25lTnVtYmVyLFxuICAgIGdldE1vZHVsYXJJbnN0YW5jZShhcHBWZXJpZmllciBhcyBBcHBsaWNhdGlvblZlcmlmaWVySW50ZXJuYWwpXG4gICk7XG4gIHJldHVybiBuZXcgQ29uZmlybWF0aW9uUmVzdWx0SW1wbCh2ZXJpZmljYXRpb25JZCwgY3JlZCA9PlxuICAgIGxpbmtXaXRoQ3JlZGVudGlhbCh1c2VySW50ZXJuYWwsIGNyZWQpXG4gICk7XG59XG5cbi8qKlxuICogUmUtYXV0aGVudGljYXRlcyBhIHVzZXIgdXNpbmcgYSBmcmVzaCBwaG9uZSBjcmVkZW50aWFsLlxuICpcbiAqIEByZW1hcmtzIFVzZSBiZWZvcmUgb3BlcmF0aW9ucyBzdWNoIGFzIHtAbGluayB1cGRhdGVQYXNzd29yZH0gdGhhdCByZXF1aXJlIHRva2VucyBmcm9tIHJlY2VudCBzaWduLWluIGF0dGVtcHRzLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gcGhvbmVOdW1iZXIgLSBUaGUgdXNlcidzIHBob25lIG51bWJlciBpbiBFLjE2NCBmb3JtYXQgKGUuZy4gKzE2NTA1NTUwMTAxKS5cbiAqIEBwYXJhbSBhcHBWZXJpZmllciAtIFRoZSB7QGxpbmsgQXBwbGljYXRpb25WZXJpZmllcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhdXRoZW50aWNhdGVXaXRoUGhvbmVOdW1iZXIoXG4gIHVzZXI6IFVzZXIsXG4gIHBob25lTnVtYmVyOiBzdHJpbmcsXG4gIGFwcFZlcmlmaWVyOiBBcHBsaWNhdGlvblZlcmlmaWVyXG4pOiBQcm9taXNlPENvbmZpcm1hdGlvblJlc3VsdD4ge1xuICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsO1xuICBjb25zdCB2ZXJpZmljYXRpb25JZCA9IGF3YWl0IF92ZXJpZnlQaG9uZU51bWJlcihcbiAgICB1c2VySW50ZXJuYWwuYXV0aCxcbiAgICBwaG9uZU51bWJlcixcbiAgICBnZXRNb2R1bGFySW5zdGFuY2UoYXBwVmVyaWZpZXIgYXMgQXBwbGljYXRpb25WZXJpZmllckludGVybmFsKVxuICApO1xuICByZXR1cm4gbmV3IENvbmZpcm1hdGlvblJlc3VsdEltcGwodmVyaWZpY2F0aW9uSWQsIGNyZWQgPT5cbiAgICByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsKHVzZXJJbnRlcm5hbCwgY3JlZClcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdmVyaWZpY2F0aW9uIElEIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgU01TIGNvZGUgdGhhdCBpcyBzZW50LlxuICpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF92ZXJpZnlQaG9uZU51bWJlcihcbiAgYXV0aDogQXV0aEludGVybmFsLFxuICBvcHRpb25zOiBQaG9uZUluZm9PcHRpb25zIHwgc3RyaW5nLFxuICB2ZXJpZmllcjogQXBwbGljYXRpb25WZXJpZmllckludGVybmFsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCByZWNhcHRjaGFUb2tlbiA9IGF3YWl0IHZlcmlmaWVyLnZlcmlmeSgpO1xuXG4gIHRyeSB7XG4gICAgX2Fzc2VydChcbiAgICAgIHR5cGVvZiByZWNhcHRjaGFUb2tlbiA9PT0gJ3N0cmluZycsXG4gICAgICBhdXRoLFxuICAgICAgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUlxuICAgICk7XG4gICAgX2Fzc2VydChcbiAgICAgIHZlcmlmaWVyLnR5cGUgPT09IFJFQ0FQVENIQV9WRVJJRklFUl9UWVBFLFxuICAgICAgYXV0aCxcbiAgICAgIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1JcbiAgICApO1xuXG4gICAgbGV0IHBob25lSW5mb09wdGlvbnM6IFBob25lSW5mb09wdGlvbnM7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwaG9uZUluZm9PcHRpb25zID0ge1xuICAgICAgICBwaG9uZU51bWJlcjogb3B0aW9uc1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGhvbmVJbmZvT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKCdzZXNzaW9uJyBpbiBwaG9uZUluZm9PcHRpb25zKSB7XG4gICAgICBjb25zdCBzZXNzaW9uID0gcGhvbmVJbmZvT3B0aW9ucy5zZXNzaW9uIGFzIE11bHRpRmFjdG9yU2Vzc2lvbkltcGw7XG5cbiAgICAgIGlmICgncGhvbmVOdW1iZXInIGluIHBob25lSW5mb09wdGlvbnMpIHtcbiAgICAgICAgX2Fzc2VydChcbiAgICAgICAgICBzZXNzaW9uLnR5cGUgPT09IE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMLFxuICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUlxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN0YXJ0RW5yb2xsUGhvbmVNZmEoYXV0aCwge1xuICAgICAgICAgIGlkVG9rZW46IHNlc3Npb24uY3JlZGVudGlhbCxcbiAgICAgICAgICBwaG9uZUVucm9sbG1lbnRJbmZvOiB7XG4gICAgICAgICAgICBwaG9uZU51bWJlcjogcGhvbmVJbmZvT3B0aW9ucy5waG9uZU51bWJlcixcbiAgICAgICAgICAgIHJlY2FwdGNoYVRva2VuXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnBob25lU2Vzc2lvbkluZm8uc2Vzc2lvbkluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYXNzZXJ0KFxuICAgICAgICAgIHNlc3Npb24udHlwZSA9PT0gTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5TSUdOX0lOLFxuICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBtZmFFbnJvbGxtZW50SWQgPVxuICAgICAgICAgIHBob25lSW5mb09wdGlvbnMubXVsdGlGYWN0b3JIaW50Py51aWQgfHxcbiAgICAgICAgICBwaG9uZUluZm9PcHRpb25zLm11bHRpRmFjdG9yVWlkO1xuICAgICAgICBfYXNzZXJ0KG1mYUVucm9sbG1lbnRJZCwgYXV0aCwgQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9JTkZPKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdGFydFNpZ25JblBob25lTWZhKGF1dGgsIHtcbiAgICAgICAgICBtZmFQZW5kaW5nQ3JlZGVudGlhbDogc2Vzc2lvbi5jcmVkZW50aWFsLFxuICAgICAgICAgIG1mYUVucm9sbG1lbnRJZCxcbiAgICAgICAgICBwaG9uZVNpZ25JbkluZm86IHtcbiAgICAgICAgICAgIHJlY2FwdGNoYVRva2VuXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnBob25lUmVzcG9uc2VJbmZvLnNlc3Npb25JbmZvO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IHNlc3Npb25JbmZvIH0gPSBhd2FpdCBzZW5kUGhvbmVWZXJpZmljYXRpb25Db2RlKGF1dGgsIHtcbiAgICAgICAgcGhvbmVOdW1iZXI6IHBob25lSW5mb09wdGlvbnMucGhvbmVOdW1iZXIsXG4gICAgICAgIHJlY2FwdGNoYVRva2VuXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZXNzaW9uSW5mbztcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdmVyaWZpZXIuX3Jlc2V0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB1c2VyJ3MgcGhvbmUgbnVtYmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIC8vICdyZWNhcHRjaGEtY29udGFpbmVyJyBpcyB0aGUgSUQgb2YgYW4gZWxlbWVudCBpbiB0aGUgRE9NLlxuICogY29uc3QgYXBwbGljYXRpb25WZXJpZmllciA9IG5ldyBSZWNhcHRjaGFWZXJpZmllcigncmVjYXB0Y2hhLWNvbnRhaW5lcicpO1xuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgUGhvbmVBdXRoUHJvdmlkZXIoYXV0aCk7XG4gKiBjb25zdCB2ZXJpZmljYXRpb25JZCA9IGF3YWl0IHByb3ZpZGVyLnZlcmlmeVBob25lTnVtYmVyKCcrMTY1MDU1NTAxMDEnLCBhcHBsaWNhdGlvblZlcmlmaWVyKTtcbiAqIC8vIE9idGFpbiB0aGUgdmVyaWZpY2F0aW9uQ29kZSBmcm9tIHRoZSB1c2VyLlxuICogY29uc3QgcGhvbmVDcmVkZW50aWFsID0gUGhvbmVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbCh2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSk7XG4gKiBhd2FpdCB1cGRhdGVQaG9uZU51bWJlcih1c2VyLCBwaG9uZUNyZWRlbnRpYWwpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gQSBjcmVkZW50aWFsIGF1dGhlbnRpY2F0aW5nIHRoZSBuZXcgcGhvbmUgbnVtYmVyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVBob25lTnVtYmVyKFxuICB1c2VyOiBVc2VyLFxuICBjcmVkZW50aWFsOiBQaG9uZUF1dGhDcmVkZW50aWFsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgX2xpbmsoZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpIGFzIFVzZXJJbnRlcm5hbCwgY3JlZGVudGlhbCk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBBdXRoLFxuICBQaG9uZUluZm9PcHRpb25zLFxuICBBcHBsaWNhdGlvblZlcmlmaWVyLFxuICBVc2VyQ3JlZGVudGlhbFxufSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXNwb25zZSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9zbXMnO1xuaW1wb3J0IHsgQXBwbGljYXRpb25WZXJpZmllckludGVybmFsIGFzIEFwcGxpY2F0aW9uVmVyaWZpZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2FwcGxpY2F0aW9uX3ZlcmlmaWVyJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCBhcyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgYXMgVXNlckNyZWRlbnRpYWxJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgUGhvbmVBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uLy4uL2NvcmUvY3JlZGVudGlhbHMvcGhvbmUnO1xuaW1wb3J0IHsgX3ZlcmlmeVBob25lTnVtYmVyIH0gZnJvbSAnLi4vc3RyYXRlZ2llcy9waG9uZSc7XG5pbXBvcnQgeyBfY2FzdEF1dGggfSBmcm9tICcuLi8uLi9jb3JlL2F1dGgvYXV0aF9pbXBsJztcbmltcG9ydCB7IEF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yLCBnZXRNb2R1bGFySW5zdGFuY2UgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IFByb3ZpZGVySWQsIFNpZ25Jbk1ldGhvZCB9IGZyb20gJy4uLy4uL21vZGVsL2VudW1zJztcblxuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgUGhvbmVBdXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vICdyZWNhcHRjaGEtY29udGFpbmVyJyBpcyB0aGUgSUQgb2YgYW4gZWxlbWVudCBpbiB0aGUgRE9NLlxuICogY29uc3QgYXBwbGljYXRpb25WZXJpZmllciA9IG5ldyBSZWNhcHRjaGFWZXJpZmllcigncmVjYXB0Y2hhLWNvbnRhaW5lcicpO1xuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgUGhvbmVBdXRoUHJvdmlkZXIoYXV0aCk7XG4gKiBjb25zdCB2ZXJpZmljYXRpb25JZCA9IGF3YWl0IHByb3ZpZGVyLnZlcmlmeVBob25lTnVtYmVyKCcrMTY1MDU1NTAxMDEnLCBhcHBsaWNhdGlvblZlcmlmaWVyKTtcbiAqIC8vIE9idGFpbiB0aGUgdmVyaWZpY2F0aW9uQ29kZSBmcm9tIHRoZSB1c2VyLlxuICogY29uc3QgcGhvbmVDcmVkZW50aWFsID0gUGhvbmVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbCh2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSk7XG4gKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIHBob25lQ3JlZGVudGlhbCk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBQaG9uZUF1dGhQcm92aWRlciB7XG4gIC8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5QSE9ORS4gKi9cbiAgc3RhdGljIHJlYWRvbmx5IFBST1ZJREVSX0lEOiAncGhvbmUnID0gUHJvdmlkZXJJZC5QSE9ORTtcbiAgLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uUEhPTkUuICovXG4gIHN0YXRpYyByZWFkb25seSBQSE9ORV9TSUdOX0lOX01FVEhPRDogJ3Bob25lJyA9IFNpZ25Jbk1ldGhvZC5QSE9ORTtcblxuICAvKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uUEhPTkUuICovXG4gIHJlYWRvbmx5IHByb3ZpZGVySWQgPSBQaG9uZUF1dGhQcm92aWRlci5QUk9WSURFUl9JRDtcbiAgcHJpdmF0ZSByZWFkb25seSBhdXRoOiBBdXRoSW50ZXJuYWw7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhdXRoIC0gVGhlIEZpcmViYXNlIHtAbGluayBBdXRofSBpbnN0YW5jZSBpbiB3aGljaCBzaWduLWlucyBzaG91bGQgb2NjdXIuXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhdXRoOiBBdXRoKSB7XG4gICAgdGhpcy5hdXRoID0gX2Nhc3RBdXRoKGF1dGgpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIFN0YXJ0cyBhIHBob25lIG51bWJlciBhdXRoZW50aWNhdGlvbiBmbG93IGJ5IHNlbmRpbmcgYSB2ZXJpZmljYXRpb24gY29kZSB0byB0aGUgZ2l2ZW4gcGhvbmVcbiAgICogbnVtYmVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IFBob25lQXV0aFByb3ZpZGVyKGF1dGgpO1xuICAgKiBjb25zdCB2ZXJpZmljYXRpb25JZCA9IGF3YWl0IHByb3ZpZGVyLnZlcmlmeVBob25lTnVtYmVyKHBob25lTnVtYmVyLCBhcHBsaWNhdGlvblZlcmlmaWVyKTtcbiAgICogLy8gT2J0YWluIHZlcmlmaWNhdGlvbkNvZGUgZnJvbSB0aGUgdXNlci5cbiAgICogY29uc3QgYXV0aENyZWRlbnRpYWwgPSBQaG9uZUF1dGhQcm92aWRlci5jcmVkZW50aWFsKHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlKTtcbiAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBhdXRoQ3JlZGVudGlhbCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBBbiBhbHRlcm5hdGl2ZSBmbG93IGlzIHByb3ZpZGVkIHVzaW5nIHRoZSBgc2lnbkluV2l0aFBob25lTnVtYmVyYCBtZXRob2QuXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgY29uZmlybWF0aW9uUmVzdWx0ID0gc2lnbkluV2l0aFBob25lTnVtYmVyKGF1dGgsIHBob25lTnVtYmVyLCBhcHBsaWNhdGlvblZlcmlmaWVyKTtcbiAgICogLy8gT2J0YWluIHZlcmlmaWNhdGlvbkNvZGUgZnJvbSB0aGUgdXNlci5cbiAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBjb25maXJtYXRpb25SZXN1bHQuY29uZmlybSh2ZXJpZmljYXRpb25Db2RlKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBwaG9uZUluZm9PcHRpb25zIC0gVGhlIHVzZXIncyB7QGxpbmsgUGhvbmVJbmZvT3B0aW9uc30uIFRoZSBwaG9uZSBudW1iZXIgc2hvdWxkIGJlIGluXG4gICAqIEUuMTY0IGZvcm1hdCAoZS5nLiArMTY1MDU1NTAxMDEpLlxuICAgKiBAcGFyYW0gYXBwbGljYXRpb25WZXJpZmllciAtIEZvciBhYnVzZSBwcmV2ZW50aW9uLCB0aGlzIG1ldGhvZCBhbHNvIHJlcXVpcmVzIGFcbiAgICoge0BsaW5rIEFwcGxpY2F0aW9uVmVyaWZpZXJ9LiBUaGlzIFNESyBpbmNsdWRlcyBhIHJlQ0FQVENIQS1iYXNlZCBpbXBsZW1lbnRhdGlvbixcbiAgICoge0BsaW5rIFJlY2FwdGNoYVZlcmlmaWVyfS5cbiAgICpcbiAgICogQHJldHVybnMgQSBQcm9taXNlIGZvciBhIHZlcmlmaWNhdGlvbiBJRCB0aGF0IGNhbiBiZSBwYXNzZWQgdG9cbiAgICoge0BsaW5rIFBob25lQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWx9IHRvIGlkZW50aWZ5IHRoaXMgZmxvdy4uXG4gICAqL1xuICB2ZXJpZnlQaG9uZU51bWJlcihcbiAgICBwaG9uZU9wdGlvbnM6IFBob25lSW5mb09wdGlvbnMgfCBzdHJpbmcsXG4gICAgYXBwbGljYXRpb25WZXJpZmllcjogQXBwbGljYXRpb25WZXJpZmllclxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiBfdmVyaWZ5UGhvbmVOdW1iZXIoXG4gICAgICB0aGlzLmF1dGgsXG4gICAgICBwaG9uZU9wdGlvbnMsXG4gICAgICBnZXRNb2R1bGFySW5zdGFuY2UoYXBwbGljYXRpb25WZXJpZmllciBhcyBBcHBsaWNhdGlvblZlcmlmaWVySW50ZXJuYWwpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcGhvbmUgYXV0aCBjcmVkZW50aWFsLCBnaXZlbiB0aGUgdmVyaWZpY2F0aW9uIElEIGZyb21cbiAgICoge0BsaW5rIFBob25lQXV0aFByb3ZpZGVyLnZlcmlmeVBob25lTnVtYmVyfSBhbmQgdGhlIGNvZGUgdGhhdCB3YXMgc2VudCB0byB0aGUgdXNlcidzXG4gICAqIG1vYmlsZSBkZXZpY2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgcHJvdmlkZXIgPSBuZXcgUGhvbmVBdXRoUHJvdmlkZXIoYXV0aCk7XG4gICAqIGNvbnN0IHZlcmlmaWNhdGlvbklkID0gcHJvdmlkZXIudmVyaWZ5UGhvbmVOdW1iZXIocGhvbmVOdW1iZXIsIGFwcGxpY2F0aW9uVmVyaWZpZXIpO1xuICAgKiAvLyBPYnRhaW4gdmVyaWZpY2F0aW9uQ29kZSBmcm9tIHRoZSB1c2VyLlxuICAgKiBjb25zdCBhdXRoQ3JlZGVudGlhbCA9IFBob25lQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwodmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUpO1xuICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGF1dGhDcmVkZW50aWFsKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIEFuIGFsdGVybmF0aXZlIGZsb3cgaXMgcHJvdmlkZWQgdXNpbmcgdGhlIGBzaWduSW5XaXRoUGhvbmVOdW1iZXJgIG1ldGhvZC5cbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBjb25maXJtYXRpb25SZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUGhvbmVOdW1iZXIoYXV0aCwgcGhvbmVOdW1iZXIsIGFwcGxpY2F0aW9uVmVyaWZpZXIpO1xuICAgKiAvLyBPYnRhaW4gdmVyaWZpY2F0aW9uQ29kZSBmcm9tIHRoZSB1c2VyLlxuICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IGNvbmZpcm1hdGlvblJlc3VsdC5jb25maXJtKHZlcmlmaWNhdGlvbkNvZGUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHZlcmlmaWNhdGlvbklkIC0gVGhlIHZlcmlmaWNhdGlvbiBJRCByZXR1cm5lZCBmcm9tIHtAbGluayBQaG9uZUF1dGhQcm92aWRlci52ZXJpZnlQaG9uZU51bWJlcn0uXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25Db2RlIC0gVGhlIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIncyBtb2JpbGUgZGV2aWNlLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgYXV0aCBwcm92aWRlciBjcmVkZW50aWFsLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWwoXG4gICAgdmVyaWZpY2F0aW9uSWQ6IHN0cmluZyxcbiAgICB2ZXJpZmljYXRpb25Db2RlOiBzdHJpbmdcbiAgKTogUGhvbmVBdXRoQ3JlZGVudGlhbCB7XG4gICAgcmV0dXJuIFBob25lQXV0aENyZWRlbnRpYWwuX2Zyb21WZXJpZmljYXRpb24oXG4gICAgICB2ZXJpZmljYXRpb25JZCxcbiAgICAgIHZlcmlmaWNhdGlvbkNvZGVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxuICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KFxuICAgIHVzZXJDcmVkZW50aWFsOiBVc2VyQ3JlZGVudGlhbFxuICApOiBBdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIGNvbnN0IGNyZWRlbnRpYWwgPSB1c2VyQ3JlZGVudGlhbCBhcyBVc2VyQ3JlZGVudGlhbEludGVybmFsO1xuICAgIHJldHVybiBQaG9uZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdChjcmVkZW50aWFsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gd2hlbiBwYXNzZWQgYW4gZXJyb3IuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHdvcmtzIGZvciBlcnJvcnMgbGlrZVxuICAgKiBgYXV0aC9hY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsc2AuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiByZWNvdmVyaW5nIHdoZW4gYXR0ZW1wdGluZyB0byBzZXQgYSB1c2VyJ3MgcGhvbmUgbnVtYmVyIGJ1dCB0aGUgbnVtYmVyXG4gICAqIGluIHF1ZXN0aW9uIGlzIGFscmVhZHkgdGllZCB0byBhbm90aGVyIGFjY291bnQuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nXG4gICAqIGNvZGUgdHJpZXMgdG8gdXBkYXRlIHRoZSBjdXJyZW50IHVzZXIncyBwaG9uZSBudW1iZXIsIGFuZCBpZiB0aGF0XG4gICAqIGZhaWxzLCBsaW5rcyB0aGUgdXNlciB3aXRoIHRoZSBhY2NvdW50IGFzc29jaWF0ZWQgd2l0aCB0aGF0IG51bWJlcjpcbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgcHJvdmlkZXIgPSBuZXcgUGhvbmVBdXRoUHJvdmlkZXIoYXV0aCk7XG4gICAqIGNvbnN0IHZlcmlmaWNhdGlvbklkID0gYXdhaXQgcHJvdmlkZXIudmVyaWZ5UGhvbmVOdW1iZXIobnVtYmVyLCB2ZXJpZmllcik7XG4gICAqIHRyeSB7XG4gICAqICAgY29uc3QgY29kZSA9ICcnOyAvLyBQcm9tcHQgdGhlIHVzZXIgZm9yIHRoZSB2ZXJpZmljYXRpb24gY29kZVxuICAgKiAgIGF3YWl0IHVwZGF0ZVBob25lTnVtYmVyKFxuICAgKiAgICAgICBhdXRoLmN1cnJlbnRVc2VyLFxuICAgKiAgICAgICBQaG9uZUF1dGhQcm92aWRlci5jcmVkZW50aWFsKHZlcmlmaWNhdGlvbklkLCBjb2RlKSk7XG4gICAqIH0gY2F0Y2ggKGUpIHtcbiAgICogICBpZiAoKGUgYXMgRmlyZWJhc2VFcnJvcik/LmNvZGUgPT09ICdhdXRoL2FjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWwnKSB7XG4gICAqICAgICBjb25zdCBjcmVkID0gUGhvbmVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21FcnJvcihlKTtcbiAgICogICAgIGF3YWl0IGxpbmtXaXRoQ3JlZGVudGlhbChhdXRoLmN1cnJlbnRVc2VyLCBjcmVkKTtcbiAgICogICB9XG4gICAqIH1cbiAgICpcbiAgICogLy8gQXQgdGhpcyBwb2ludCwgYXV0aC5jdXJyZW50VXNlci5waG9uZU51bWJlciA9PT0gbnVtYmVyLlxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRvIGdlbmVyYXRlIGEgY3JlZGVudGlhbCBmcm9tLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3I6IEZpcmViYXNlRXJyb3IpOiBBdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIHJldHVybiBQaG9uZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdChcbiAgICAgIChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSBhcyBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7XG4gICAgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2VcbiAgfTogVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2UpOiBBdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgcGhvbmVOdW1iZXIsIHRlbXBvcmFyeVByb29mIH0gPVxuICAgICAgdG9rZW5SZXNwb25zZSBhcyBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXNwb25zZTtcbiAgICBpZiAocGhvbmVOdW1iZXIgJiYgdGVtcG9yYXJ5UHJvb2YpIHtcbiAgICAgIHJldHVybiBQaG9uZUF1dGhDcmVkZW50aWFsLl9mcm9tVG9rZW5SZXNwb25zZShcbiAgICAgICAgcGhvbmVOdW1iZXIsXG4gICAgICAgIHRlbXBvcmFyeVByb29mXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUG9wdXBSZWRpcmVjdFJlc29sdmVyIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9wb3B1cF9yZWRpcmVjdCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuL2Fzc2VydCc7XG5pbXBvcnQgeyBfZ2V0SW5zdGFuY2UgfSBmcm9tICcuL2luc3RhbnRpYXRvcic7XG5cbi8qKlxuICogQ2hvb3NlcyBhIHBvcHVwL3JlZGlyZWN0IHJlc29sdmVyIHRvIHVzZS4gVGhpcyBwcmVmZXJzIHRoZSBvdmVycmlkZSAod2hpY2hcbiAqIGlzIGRpcmVjdGx5IHBhc3NlZCBpbiksIGFuZCBmYWxscyBiYWNrIHRvIHRoZSBwcm9wZXJ0eSBzZXQgb24gdGhlIGF1dGhcbiAqIG9iamVjdC4gSWYgbmVpdGhlciBhcmUgYXZhaWxhYmxlLCB0aGlzIGZ1bmN0aW9uIGVycm9ycyB3LyBhbiBhcmd1bWVudCBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF93aXRoRGVmYXVsdFJlc29sdmVyKFxuICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gIHJlc29sdmVyT3ZlcnJpZGU6IFBvcHVwUmVkaXJlY3RSZXNvbHZlciB8IHVuZGVmaW5lZFxuKTogUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWwge1xuICBpZiAocmVzb2x2ZXJPdmVycmlkZSkge1xuICAgIHJldHVybiBfZ2V0SW5zdGFuY2UocmVzb2x2ZXJPdmVycmlkZSk7XG4gIH1cblxuICBfYXNzZXJ0KGF1dGguX3BvcHVwUmVkaXJlY3RSZXNvbHZlciwgYXV0aCwgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUik7XG5cbiAgcmV0dXJuIGF1dGguX3BvcHVwUmVkaXJlY3RSZXNvbHZlcjtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIHNpZ25JbldpdGhJZHAsXG4gIFNpZ25JbldpdGhJZHBSZXF1ZXN0XG59IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9pZHAnO1xuaW1wb3J0IHsgUGhvbmVPck9hdXRoVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9tZmEnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwsIFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IEF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi4vY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgX2xpbmsgYXMgX2xpbmtVc2VyIH0gZnJvbSAnLi4vdXNlci9saW5rX3VubGluayc7XG5pbXBvcnQgeyBfcmVhdXRoZW50aWNhdGUgfSBmcm9tICcuLi91c2VyL3JlYXV0aGVudGljYXRlJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBfc2lnbkluV2l0aENyZWRlbnRpYWwgfSBmcm9tICcuL2NyZWRlbnRpYWwnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBQcm92aWRlcklkIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElkcFRhc2tQYXJhbXMge1xuICBhdXRoOiBBdXRoSW50ZXJuYWw7XG4gIHJlcXVlc3RVcmk6IHN0cmluZztcbiAgc2Vzc2lvbklkPzogc3RyaW5nO1xuICB0ZW5hbnRJZD86IHN0cmluZztcbiAgcG9zdEJvZHk/OiBzdHJpbmc7XG4gIHBlbmRpbmdUb2tlbj86IHN0cmluZztcbiAgdXNlcj86IFVzZXJJbnRlcm5hbDtcbiAgYnlwYXNzQXV0aFN0YXRlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IHR5cGUgSWRwVGFzayA9IChcbiAgcGFyYW1zOiBJZHBUYXNrUGFyYW1zXG4pID0+IFByb21pc2U8VXNlckNyZWRlbnRpYWxJbnRlcm5hbD47XG5cbmNsYXNzIElkcENyZWRlbnRpYWwgZXh0ZW5kcyBBdXRoQ3JlZGVudGlhbCB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHBhcmFtczogSWRwVGFza1BhcmFtcykge1xuICAgIHN1cGVyKFByb3ZpZGVySWQuQ1VTVE9NLCBQcm92aWRlcklkLkNVU1RPTSk7XG4gIH1cblxuICBfZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8UGhvbmVPck9hdXRoVG9rZW5SZXNwb25zZT4ge1xuICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHRoaXMuX2J1aWxkSWRwUmVxdWVzdCgpKTtcbiAgfVxuXG4gIF9saW5rVG9JZFRva2VuKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBpZFRva2VuOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxJZFRva2VuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCB0aGlzLl9idWlsZElkcFJlcXVlc3QoaWRUb2tlbikpO1xuICB9XG5cbiAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoOiBBdXRoSW50ZXJuYWwpOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT4ge1xuICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHRoaXMuX2J1aWxkSWRwUmVxdWVzdCgpKTtcbiAgfVxuXG4gIHByaXZhdGUgX2J1aWxkSWRwUmVxdWVzdChpZFRva2VuPzogc3RyaW5nKTogU2lnbkluV2l0aElkcFJlcXVlc3Qge1xuICAgIGNvbnN0IHJlcXVlc3Q6IFNpZ25JbldpdGhJZHBSZXF1ZXN0ID0ge1xuICAgICAgcmVxdWVzdFVyaTogdGhpcy5wYXJhbXMucmVxdWVzdFVyaSxcbiAgICAgIHNlc3Npb25JZDogdGhpcy5wYXJhbXMuc2Vzc2lvbklkLFxuICAgICAgcG9zdEJvZHk6IHRoaXMucGFyYW1zLnBvc3RCb2R5LFxuICAgICAgdGVuYW50SWQ6IHRoaXMucGFyYW1zLnRlbmFudElkLFxuICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBhcmFtcy5wZW5kaW5nVG9rZW4sXG4gICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcbiAgICAgIHJldHVybklkcENyZWRlbnRpYWw6IHRydWVcbiAgICB9O1xuXG4gICAgaWYgKGlkVG9rZW4pIHtcbiAgICAgIHJlcXVlc3QuaWRUb2tlbiA9IGlkVG9rZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9zaWduSW4oXG4gIHBhcmFtczogSWRwVGFza1BhcmFtc1xuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEludGVybmFsPiB7XG4gIHJldHVybiBfc2lnbkluV2l0aENyZWRlbnRpYWwoXG4gICAgcGFyYW1zLmF1dGgsXG4gICAgbmV3IElkcENyZWRlbnRpYWwocGFyYW1zKSxcbiAgICBwYXJhbXMuYnlwYXNzQXV0aFN0YXRlXG4gICkgYXMgUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEludGVybmFsPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZWF1dGgoXG4gIHBhcmFtczogSWRwVGFza1BhcmFtc1xuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEludGVybmFsPiB7XG4gIGNvbnN0IHsgYXV0aCwgdXNlciB9ID0gcGFyYW1zO1xuICBfYXNzZXJ0KHVzZXIsIGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICByZXR1cm4gX3JlYXV0aGVudGljYXRlKFxuICAgIHVzZXIsXG4gICAgbmV3IElkcENyZWRlbnRpYWwocGFyYW1zKSxcbiAgICBwYXJhbXMuYnlwYXNzQXV0aFN0YXRlXG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfbGluayhcbiAgcGFyYW1zOiBJZHBUYXNrUGFyYW1zXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWw+IHtcbiAgY29uc3QgeyBhdXRoLCB1c2VyIH0gPSBwYXJhbXM7XG4gIF9hc3NlcnQodXNlciwgYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gIHJldHVybiBfbGlua1VzZXIodXNlciwgbmV3IElkcENyZWRlbnRpYWwocGFyYW1zKSwgcGFyYW1zLmJ5cGFzc0F1dGhTdGF0ZSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbXBvcnQge1xuICBBdXRoRXZlbnQsXG4gIEF1dGhFdmVudENvbnN1bWVyLFxuICBBdXRoRXZlbnRUeXBlLFxuICBFdmVudE1hbmFnZXIsXG4gIFBvcHVwUmVkaXJlY3RSZXNvbHZlckludGVybmFsXG59IGZyb20gJy4uLy4uL21vZGVsL3BvcHVwX3JlZGlyZWN0JztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCwgVXNlckNyZWRlbnRpYWxJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBkZWJ1Z0Fzc2VydCwgX2ZhaWwgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQge1xuICBfbGluayxcbiAgX3JlYXV0aCxcbiAgX3NpZ25JbixcbiAgSWRwVGFzayxcbiAgSWRwVGFza1BhcmFtc1xufSBmcm9tICcuLi9zdHJhdGVnaWVzL2lkcCc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcblxuaW50ZXJmYWNlIFBlbmRpbmdQcm9taXNlIHtcbiAgcmVzb2x2ZTogKGNyZWQ6IFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfCBudWxsKSA9PiB2b2lkO1xuICByZWplY3Q6IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogUG9wdXAgZXZlbnQgbWFuYWdlci4gSGFuZGxlcyB0aGUgcG9wdXAncyBlbnRpcmUgbGlmZWN5Y2xlOyBsaXN0ZW5zIHRvIGF1dGhcbiAqIGV2ZW50c1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RQb3B1cFJlZGlyZWN0T3BlcmF0aW9uXG4gIGltcGxlbWVudHMgQXV0aEV2ZW50Q29uc3VtZXJcbntcbiAgcHJpdmF0ZSBwZW5kaW5nUHJvbWlzZTogUGVuZGluZ1Byb21pc2UgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBldmVudE1hbmFnZXI6IEV2ZW50TWFuYWdlciB8IG51bGwgPSBudWxsO1xuICByZWFkb25seSBmaWx0ZXI6IEF1dGhFdmVudFR5cGVbXTtcblxuICBhYnN0cmFjdCBldmVudElkOiBzdHJpbmcgfCBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCByZWFkb25seSBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgZmlsdGVyOiBBdXRoRXZlbnRUeXBlIHwgQXV0aEV2ZW50VHlwZVtdLFxuICAgIHByb3RlY3RlZCByZWFkb25seSByZXNvbHZlcjogUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWwsXG4gICAgcHJvdGVjdGVkIHVzZXI/OiBVc2VySW50ZXJuYWwsXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlXG4gICkge1xuICAgIHRoaXMuZmlsdGVyID0gQXJyYXkuaXNBcnJheShmaWx0ZXIpID8gZmlsdGVyIDogW2ZpbHRlcl07XG4gIH1cblxuICBhYnN0cmFjdCBvbkV4ZWN1dGlvbigpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGV4ZWN1dGUoKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEludGVybmFsIHwgbnVsbD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEludGVybmFsIHwgbnVsbD4oXG4gICAgICBhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMucGVuZGluZ1Byb21pc2UgPSB7IHJlc29sdmUsIHJlamVjdCB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBhd2FpdCB0aGlzLnJlc29sdmVyLl9pbml0aWFsaXplKHRoaXMuYXV0aCk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5vbkV4ZWN1dGlvbigpO1xuICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyQ29uc3VtZXIodGhpcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLnJlamVjdChlIGFzIEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBhc3luYyBvbkF1dGhFdmVudChldmVudDogQXV0aEV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgeyB1cmxSZXNwb25zZSwgc2Vzc2lvbklkLCBwb3N0Qm9keSwgdGVuYW50SWQsIGVycm9yLCB0eXBlIH0gPSBldmVudDtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbXM6IElkcFRhc2tQYXJhbXMgPSB7XG4gICAgICBhdXRoOiB0aGlzLmF1dGgsXG4gICAgICByZXF1ZXN0VXJpOiB1cmxSZXNwb25zZSEsXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCEsXG4gICAgICB0ZW5hbnRJZDogdGVuYW50SWQgfHwgdW5kZWZpbmVkLFxuICAgICAgcG9zdEJvZHk6IHBvc3RCb2R5IHx8IHVuZGVmaW5lZCxcbiAgICAgIHVzZXI6IHRoaXMudXNlcixcbiAgICAgIGJ5cGFzc0F1dGhTdGF0ZTogdGhpcy5ieXBhc3NBdXRoU3RhdGVcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVzb2x2ZShhd2FpdCB0aGlzLmdldElkcFRhc2sodHlwZSkocGFyYW1zKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5yZWplY3QoZSBhcyBFcnJvcik7XG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihlcnJvcjogRmlyZWJhc2VFcnJvcik6IHZvaWQge1xuICAgIHRoaXMucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0SWRwVGFzayh0eXBlOiBBdXRoRXZlbnRUeXBlKTogSWRwVGFzayB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEF1dGhFdmVudFR5cGUuU0lHTl9JTl9WSUFfUE9QVVA6XG4gICAgICBjYXNlIEF1dGhFdmVudFR5cGUuU0lHTl9JTl9WSUFfUkVESVJFQ1Q6XG4gICAgICAgIHJldHVybiBfc2lnbkluO1xuICAgICAgY2FzZSBBdXRoRXZlbnRUeXBlLkxJTktfVklBX1BPUFVQOlxuICAgICAgY2FzZSBBdXRoRXZlbnRUeXBlLkxJTktfVklBX1JFRElSRUNUOlxuICAgICAgICByZXR1cm4gX2xpbms7XG4gICAgICBjYXNlIEF1dGhFdmVudFR5cGUuUkVBVVRIX1ZJQV9QT1BVUDpcbiAgICAgIGNhc2UgQXV0aEV2ZW50VHlwZS5SRUFVVEhfVklBX1JFRElSRUNUOlxuICAgICAgICByZXR1cm4gX3JlYXV0aDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIF9mYWlsKHRoaXMuYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHJlc29sdmUoY3JlZDogVXNlckNyZWRlbnRpYWxJbnRlcm5hbCB8IG51bGwpOiB2b2lkIHtcbiAgICBkZWJ1Z0Fzc2VydCh0aGlzLnBlbmRpbmdQcm9taXNlLCAnUGVuZGluZyBwcm9taXNlIHdhcyBuZXZlciBzZXQnKTtcbiAgICB0aGlzLnBlbmRpbmdQcm9taXNlLnJlc29sdmUoY3JlZCk7XG4gICAgdGhpcy51bnJlZ2lzdGVyQW5kQ2xlYW5VcCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlamVjdChlcnJvcjogRXJyb3IpOiB2b2lkIHtcbiAgICBkZWJ1Z0Fzc2VydCh0aGlzLnBlbmRpbmdQcm9taXNlLCAnUGVuZGluZyBwcm9taXNlIHdhcyBuZXZlciBzZXQnKTtcbiAgICB0aGlzLnBlbmRpbmdQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgdGhpcy51bnJlZ2lzdGVyQW5kQ2xlYW5VcCgpO1xuICB9XG5cbiAgcHJpdmF0ZSB1bnJlZ2lzdGVyQW5kQ2xlYW5VcCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5ldmVudE1hbmFnZXIpIHtcbiAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnVucmVnaXN0ZXJDb25zdW1lcih0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmdQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLmNsZWFuVXAoKTtcbiAgfVxuXG4gIGFic3RyYWN0IGNsZWFuVXAoKTogdm9pZDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEF1dGgsXG4gIEF1dGhQcm92aWRlcixcbiAgUG9wdXBSZWRpcmVjdFJlc29sdmVyLFxuICBVc2VyLFxuICBVc2VyQ3JlZGVudGlhbFxufSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBfY2FzdEF1dGggfSBmcm9tICcuLi8uLi9jb3JlL2F1dGgvYXV0aF9pbXBsJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi8uLi9jb3JlL2Vycm9ycyc7XG5pbXBvcnQge1xuICBfYXNzZXJ0LFxuICBkZWJ1Z0Fzc2VydCxcbiAgX2NyZWF0ZUVycm9yLFxuICBfYXNzZXJ0SW5zdGFuY2VPZlxufSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IERlbGF5IH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2RlbGF5JztcbmltcG9ydCB7IF9nZW5lcmF0ZUV2ZW50SWQgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvZXZlbnRfaWQnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQge1xuICBBdXRoRXZlbnRUeXBlLFxuICBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJJbnRlcm5hbFxufSBmcm9tICcuLi8uLi9tb2RlbC9wb3B1cF9yZWRpcmVjdCc7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IF93aXRoRGVmYXVsdFJlc29sdmVyIH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL3Jlc29sdmVyJztcbmltcG9ydCB7IEF1dGhQb3B1cCB9IGZyb20gJy4uL3V0aWwvcG9wdXAnO1xuaW1wb3J0IHsgQWJzdHJhY3RQb3B1cFJlZGlyZWN0T3BlcmF0aW9uIH0gZnJvbSAnLi4vLi4vY29yZS9zdHJhdGVnaWVzL2Fic3RyYWN0X3BvcHVwX3JlZGlyZWN0X29wZXJhdGlvbic7XG5pbXBvcnQgeyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9jb3JlL3Byb3ZpZGVycy9mZWRlcmF0ZWQnO1xuaW1wb3J0IHsgZ2V0TW9kdWxhckluc3RhbmNlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKlxuICogVGhlIGV2ZW50IHRpbWVvdXQgaXMgdGhlIHNhbWUgb24gbW9iaWxlIGFuZCBkZXNrdG9wLCBubyBuZWVkIGZvciBEZWxheS4gU2V0IHRoaXMgdG8gOHMgc2luY2VcbiAqIGJsb2NraW5nIGZ1bmN0aW9ucyBjYW4gdGFrZSB1cHRvIDdzIHRvIGNvbXBsZXRlIHNpZ24gaW4sIGFzIGRvY3VtZW50ZWQgaW46XG4gKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWRlbnRpdHktcGxhdGZvcm0vZG9jcy9ibG9ja2luZy1mdW5jdGlvbnMjdW5kZXJzdGFuZGluZ19ibG9ja2luZ19mdW5jdGlvbnNcbiAqIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2F1dGgvZXh0ZW5kLXdpdGgtYmxvY2tpbmctZnVuY3Rpb25zI3VuZGVyc3RhbmRpbmdfYmxvY2tpbmdfZnVuY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIF9UaW1lb3V0IHtcbiAgQVVUSF9FVkVOVCA9IDgwMDBcbn1cbmV4cG9ydCBjb25zdCBfUE9MTF9XSU5ET1dfQ0xPU0VfVElNRU9VVCA9IG5ldyBEZWxheSgyMDAwLCAxMDAwMCk7XG5cbi8qKlxuICogQXV0aGVudGljYXRlcyBhIEZpcmViYXNlIGNsaWVudCB1c2luZyBhIHBvcHVwLWJhc2VkIE9BdXRoIGF1dGhlbnRpY2F0aW9uIGZsb3cuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHN1Y2NlZWRzLCByZXR1cm5zIHRoZSBzaWduZWQgaW4gdXNlciBhbG9uZyB3aXRoIHRoZSBwcm92aWRlcidzIGNyZWRlbnRpYWwuIElmIHNpZ24gaW4gd2FzXG4gKiB1bnN1Y2Nlc3NmdWwsIHJldHVybnMgYW4gZXJyb3Igb2JqZWN0IGNvbnRhaW5pbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXJyb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEZhY2Vib29rQXV0aFByb3ZpZGVyKCk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXG4gKiBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQoYXV0aCwgcmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBwcm92aWRlciAtIFRoZSBwcm92aWRlciB0byBhdXRoZW50aWNhdGUuIFRoZSBwcm92aWRlciBoYXMgdG8gYmUgYW4ge0BsaW5rIE9BdXRoUHJvdmlkZXJ9LlxuICogTm9uLU9BdXRoIHByb3ZpZGVycyBsaWtlIHtAbGluayBFbWFpbEF1dGhQcm92aWRlcn0gd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqIEBwYXJhbSByZXNvbHZlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJ9LCBvcHRpb25hbFxuICogaWYgYWxyZWFkeSBzdXBwbGllZCB0byB7QGxpbmsgaW5pdGlhbGl6ZUF1dGh9IG9yIHByb3ZpZGVkIGJ5IHtAbGluayBnZXRBdXRofS5cbiAqXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aFBvcHVwKFxuICBhdXRoOiBBdXRoLFxuICBwcm92aWRlcjogQXV0aFByb3ZpZGVyLFxuICByZXNvbHZlcj86IFBvcHVwUmVkaXJlY3RSZXNvbHZlclxuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbD4ge1xuICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gIF9hc3NlcnRJbnN0YW5jZU9mKGF1dGgsIHByb3ZpZGVyLCBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIpO1xuICBjb25zdCByZXNvbHZlckludGVybmFsID0gX3dpdGhEZWZhdWx0UmVzb2x2ZXIoYXV0aEludGVybmFsLCByZXNvbHZlcik7XG4gIGNvbnN0IGFjdGlvbiA9IG5ldyBQb3B1cE9wZXJhdGlvbihcbiAgICBhdXRoSW50ZXJuYWwsXG4gICAgQXV0aEV2ZW50VHlwZS5TSUdOX0lOX1ZJQV9QT1BVUCxcbiAgICBwcm92aWRlcixcbiAgICByZXNvbHZlckludGVybmFsXG4gICk7XG4gIHJldHVybiBhY3Rpb24uZXhlY3V0ZU5vdE51bGwoKTtcbn1cblxuLyoqXG4gKiBSZWF1dGhlbnRpY2F0ZXMgdGhlIGN1cnJlbnQgdXNlciB3aXRoIHRoZSBzcGVjaWZpZWQge0BsaW5rIE9BdXRoUHJvdmlkZXJ9IHVzaW5nIGEgcG9wLXVwIGJhc2VkXG4gKiBPQXV0aCBmbG93LlxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiB0aGUgcmVhdXRoZW50aWNhdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgcmV0dXJuZWQgcmVzdWx0IHdpbGwgY29udGFpbiB0aGUgdXNlciBhbmQgdGhlXG4gKiBwcm92aWRlcidzIGNyZWRlbnRpYWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEZhY2Vib29rQXV0aFByb3ZpZGVyKCk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gUmVhdXRoZW50aWNhdGUgdXNpbmcgYSBwb3B1cC5cbiAqIGF3YWl0IHJlYXV0aGVudGljYXRlV2l0aFBvcHVwKHJlc3VsdC51c2VyLCBwcm92aWRlcik7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIHByb3ZpZGVyIC0gVGhlIHByb3ZpZGVyIHRvIGF1dGhlbnRpY2F0ZS4gVGhlIHByb3ZpZGVyIGhhcyB0byBiZSBhbiB7QGxpbmsgT0F1dGhQcm92aWRlcn0uXG4gKiBOb24tT0F1dGggcHJvdmlkZXJzIGxpa2Uge0BsaW5rIEVtYWlsQXV0aFByb3ZpZGVyfSB3aWxsIHRocm93IGFuIGVycm9yLlxuICogQHBhcmFtIHJlc29sdmVyIC0gQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFBvcHVwUmVkaXJlY3RSZXNvbHZlcn0sIG9wdGlvbmFsXG4gKiBpZiBhbHJlYWR5IHN1cHBsaWVkIHRvIHtAbGluayBpbml0aWFsaXplQXV0aH0gb3IgcHJvdmlkZWQgYnkge0BsaW5rIGdldEF1dGh9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYXV0aGVudGljYXRlV2l0aFBvcHVwKFxuICB1c2VyOiBVc2VyLFxuICBwcm92aWRlcjogQXV0aFByb3ZpZGVyLFxuICByZXNvbHZlcj86IFBvcHVwUmVkaXJlY3RSZXNvbHZlclxuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbD4ge1xuICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsO1xuICBfYXNzZXJ0SW5zdGFuY2VPZih1c2VySW50ZXJuYWwuYXV0aCwgcHJvdmlkZXIsIEZlZGVyYXRlZEF1dGhQcm92aWRlcik7XG4gIGNvbnN0IHJlc29sdmVySW50ZXJuYWwgPSBfd2l0aERlZmF1bHRSZXNvbHZlcih1c2VySW50ZXJuYWwuYXV0aCwgcmVzb2x2ZXIpO1xuICBjb25zdCBhY3Rpb24gPSBuZXcgUG9wdXBPcGVyYXRpb24oXG4gICAgdXNlckludGVybmFsLmF1dGgsXG4gICAgQXV0aEV2ZW50VHlwZS5SRUFVVEhfVklBX1BPUFVQLFxuICAgIHByb3ZpZGVyLFxuICAgIHJlc29sdmVySW50ZXJuYWwsXG4gICAgdXNlckludGVybmFsXG4gICk7XG4gIHJldHVybiBhY3Rpb24uZXhlY3V0ZU5vdE51bGwoKTtcbn1cblxuLyoqXG4gKiBMaW5rcyB0aGUgYXV0aGVudGljYXRlZCBwcm92aWRlciB0byB0aGUgdXNlciBhY2NvdW50IHVzaW5nIGEgcG9wLXVwIGJhc2VkIE9BdXRoIGZsb3cuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHRoZSBsaW5raW5nIGlzIHN1Y2Nlc3NmdWwsIHRoZSByZXR1cm5lZCByZXN1bHQgd2lsbCBjb250YWluIHRoZSB1c2VyIGFuZCB0aGUgcHJvdmlkZXIncyBjcmVkZW50aWFsLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBzb21lIG90aGVyIHByb3ZpZGVyLlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQoYXV0aCwgZW1haWwsIHBhc3N3b3JkKTtcbiAqIC8vIExpbmsgdXNpbmcgYSBwb3B1cC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEZhY2Vib29rQXV0aFByb3ZpZGVyKCk7XG4gKiBhd2FpdCBsaW5rV2l0aFBvcHVwKHJlc3VsdC51c2VyLCBwcm92aWRlcik7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIHByb3ZpZGVyIC0gVGhlIHByb3ZpZGVyIHRvIGF1dGhlbnRpY2F0ZS4gVGhlIHByb3ZpZGVyIGhhcyB0byBiZSBhbiB7QGxpbmsgT0F1dGhQcm92aWRlcn0uXG4gKiBOb24tT0F1dGggcHJvdmlkZXJzIGxpa2Uge0BsaW5rIEVtYWlsQXV0aFByb3ZpZGVyfSB3aWxsIHRocm93IGFuIGVycm9yLlxuICogQHBhcmFtIHJlc29sdmVyIC0gQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFBvcHVwUmVkaXJlY3RSZXNvbHZlcn0sIG9wdGlvbmFsXG4gKiBpZiBhbHJlYWR5IHN1cHBsaWVkIHRvIHtAbGluayBpbml0aWFsaXplQXV0aH0gb3IgcHJvdmlkZWQgYnkge0BsaW5rIGdldEF1dGh9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpbmtXaXRoUG9wdXAoXG4gIHVzZXI6IFVzZXIsXG4gIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gIHJlc29sdmVyPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsPiB7XG4gIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWw7XG4gIF9hc3NlcnRJbnN0YW5jZU9mKHVzZXJJbnRlcm5hbC5hdXRoLCBwcm92aWRlciwgRmVkZXJhdGVkQXV0aFByb3ZpZGVyKTtcbiAgY29uc3QgcmVzb2x2ZXJJbnRlcm5hbCA9IF93aXRoRGVmYXVsdFJlc29sdmVyKHVzZXJJbnRlcm5hbC5hdXRoLCByZXNvbHZlcik7XG5cbiAgY29uc3QgYWN0aW9uID0gbmV3IFBvcHVwT3BlcmF0aW9uKFxuICAgIHVzZXJJbnRlcm5hbC5hdXRoLFxuICAgIEF1dGhFdmVudFR5cGUuTElOS19WSUFfUE9QVVAsXG4gICAgcHJvdmlkZXIsXG4gICAgcmVzb2x2ZXJJbnRlcm5hbCxcbiAgICB1c2VySW50ZXJuYWxcbiAgKTtcbiAgcmV0dXJuIGFjdGlvbi5leGVjdXRlTm90TnVsbCgpO1xufVxuXG4vKipcbiAqIFBvcHVwIGV2ZW50IG1hbmFnZXIuIEhhbmRsZXMgdGhlIHBvcHVwJ3MgZW50aXJlIGxpZmVjeWNsZTsgbGlzdGVucyB0byBhdXRoXG4gKiBldmVudHNcbiAqXG4gKi9cbmNsYXNzIFBvcHVwT3BlcmF0aW9uIGV4dGVuZHMgQWJzdHJhY3RQb3B1cFJlZGlyZWN0T3BlcmF0aW9uIHtcbiAgLy8gT25seSBvbmUgcG9wdXAgaXMgZXZlciBzaG93biBhdCBvbmNlLiBUaGUgbGlmZWN5Y2xlIG9mIHRoZSBjdXJyZW50IHBvcHVwXG4gIC8vIGNhbiBiZSBtYW5hZ2VkIC8gY2FuY2VsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAgcHJpdmF0ZSBzdGF0aWMgY3VycmVudFBvcHVwQWN0aW9uOiBQb3B1cE9wZXJhdGlvbiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGF1dGhXaW5kb3c6IEF1dGhQb3B1cCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHBvbGxJZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGZpbHRlcjogQXV0aEV2ZW50VHlwZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gICAgcmVzb2x2ZXI6IFBvcHVwUmVkaXJlY3RSZXNvbHZlckludGVybmFsLFxuICAgIHVzZXI/OiBVc2VySW50ZXJuYWxcbiAgKSB7XG4gICAgc3VwZXIoYXV0aCwgZmlsdGVyLCByZXNvbHZlciwgdXNlcik7XG4gICAgaWYgKFBvcHVwT3BlcmF0aW9uLmN1cnJlbnRQb3B1cEFjdGlvbikge1xuICAgICAgUG9wdXBPcGVyYXRpb24uY3VycmVudFBvcHVwQWN0aW9uLmNhbmNlbCgpO1xuICAgIH1cblxuICAgIFBvcHVwT3BlcmF0aW9uLmN1cnJlbnRQb3B1cEFjdGlvbiA9IHRoaXM7XG4gIH1cblxuICBhc3luYyBleGVjdXRlTm90TnVsbCgpOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRlKCk7XG4gICAgX2Fzc2VydChyZXN1bHQsIHRoaXMuYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGFzeW5jIG9uRXhlY3V0aW9uKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGRlYnVnQXNzZXJ0KFxuICAgICAgdGhpcy5maWx0ZXIubGVuZ3RoID09PSAxLFxuICAgICAgJ1BvcHVwIG9wZXJhdGlvbnMgb25seSBoYW5kbGUgb25lIGV2ZW50J1xuICAgICk7XG4gICAgY29uc3QgZXZlbnRJZCA9IF9nZW5lcmF0ZUV2ZW50SWQoKTtcbiAgICB0aGlzLmF1dGhXaW5kb3cgPSBhd2FpdCB0aGlzLnJlc29sdmVyLl9vcGVuUG9wdXAoXG4gICAgICB0aGlzLmF1dGgsXG4gICAgICB0aGlzLnByb3ZpZGVyLFxuICAgICAgdGhpcy5maWx0ZXJbMF0sIC8vIFRoZXJlJ3MgYWx3YXlzIG9uZSwgc2VlIGNvbnN0cnVjdG9yXG4gICAgICBldmVudElkXG4gICAgKTtcbiAgICB0aGlzLmF1dGhXaW5kb3cuYXNzb2NpYXRlZEV2ZW50ID0gZXZlbnRJZDtcblxuICAgIC8vIENoZWNrIGZvciB3ZWIgc3RvcmFnZSBzdXBwb3J0IGFuZCBvcmlnaW4gdmFsaWRhdGlvbiBfYWZ0ZXJfIHRoZSBwb3B1cCBpc1xuICAgIC8vIGxvYWRlZC4gVGhlc2Ugb3BlcmF0aW9ucyBhcmUgc2xvdyAofjEgc2Vjb25kIG9yIHNvKSBSYXRoZXIgdGhhblxuICAgIC8vIHdhaXRpbmcgb24gdGhlbSBiZWZvcmUgb3BlbmluZyB0aGUgd2luZG93LCBvcHRpbWlzdGljYWxseSBvcGVuIHRoZSBwb3B1cFxuICAgIC8vIGFuZCBjaGVjayBmb3Igc3RvcmFnZSBzdXBwb3J0IGF0IHRoZSBzYW1lIHRpbWUuIElmIHN0b3JhZ2Ugc3VwcG9ydCBpc1xuICAgIC8vIG5vdCBhdmFpbGFibGUsIHRoaXMgd2lsbCBjYXVzZSB0aGUgd2hvbGUgdGhpbmcgdG8gcmVqZWN0IHByb3Blcmx5LiBJdFxuICAgIC8vIHdpbGwgYWxzbyBjbG9zZSB0aGUgcG9wdXAsIGJ1dCBzaW5jZSB0aGUgcHJvbWlzZSBoYXMgYWxyZWFkeSByZWplY3RlZCxcbiAgICAvLyB0aGUgcG9wdXAgY2xvc2VkIGJ5IHVzZXIgcG9sbCB3aWxsIHJlamVjdCBpbnRvIHRoZSB2b2lkLlxuICAgIHRoaXMucmVzb2x2ZXIuX29yaWdpblZhbGlkYXRpb24odGhpcy5hdXRoKS5jYXRjaChlID0+IHtcbiAgICAgIHRoaXMucmVqZWN0KGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZXNvbHZlci5faXNJZnJhbWVXZWJTdG9yYWdlU3VwcG9ydGVkKHRoaXMuYXV0aCwgaXNTdXBwb3J0ZWQgPT4ge1xuICAgICAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgICAgICB0aGlzLnJlamVjdChcbiAgICAgICAgICBfY3JlYXRlRXJyb3IodGhpcy5hdXRoLCBBdXRoRXJyb3JDb2RlLldFQl9TVE9SQUdFX1VOU1VQUE9SVEVEKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIHVzZXIgY2xvc3VyZS4gTm90aWNlIHRoaXMgZG9lcyAqbm90KiB1c2UgYXdhaXRcbiAgICB0aGlzLnBvbGxVc2VyQ2FuY2VsbGF0aW9uKCk7XG4gIH1cblxuICBnZXQgZXZlbnRJZCgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5hdXRoV2luZG93Py5hc3NvY2lhdGVkRXZlbnQgfHwgbnVsbDtcbiAgfVxuXG4gIGNhbmNlbCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlamVjdChfY3JlYXRlRXJyb3IodGhpcy5hdXRoLCBBdXRoRXJyb3JDb2RlLkVYUElSRURfUE9QVVBfUkVRVUVTVCkpO1xuICB9XG5cbiAgY2xlYW5VcCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5hdXRoV2luZG93KSB7XG4gICAgICB0aGlzLmF1dGhXaW5kb3cuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wb2xsSWQpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5wb2xsSWQpO1xuICAgIH1cblxuICAgIHRoaXMuYXV0aFdpbmRvdyA9IG51bGw7XG4gICAgdGhpcy5wb2xsSWQgPSBudWxsO1xuICAgIFBvcHVwT3BlcmF0aW9uLmN1cnJlbnRQb3B1cEFjdGlvbiA9IG51bGw7XG4gIH1cblxuICBwcml2YXRlIHBvbGxVc2VyQ2FuY2VsbGF0aW9uKCk6IHZvaWQge1xuICAgIGNvbnN0IHBvbGwgPSAoKTogdm9pZCA9PiB7XG4gICAgICBpZiAodGhpcy5hdXRoV2luZG93Py53aW5kb3c/LmNsb3NlZCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGVyZSBpcyBzdWZmaWNpZW50IHRpbWUgZm9yIHdoYXRldmVyIGFjdGlvbiB0b1xuICAgICAgICAvLyBjb21wbGV0ZS4gVGhlIHdpbmRvdyBjb3VsZCBoYXZlIGNsb3NlZCBidXQgdGhlIHNpZ24gaW4gbmV0d29ya1xuICAgICAgICAvLyBjYWxsIGNvdWxkIHN0aWxsIGJlIGluIGZsaWdodC4gVGhpcyBpcyBzcGVjaWZpY2FsbHkgdHJ1ZSBmb3JcbiAgICAgICAgLy8gRmlyZWZveCBvciBpZiB0aGUgb3BlbmVyIGlzIGluIGFuIGlmcmFtZSwgaW4gd2hpY2ggY2FzZSB0aGUgb2F1dGhcbiAgICAgICAgLy8gaGVscGVyIGNsb3NlcyB0aGUgcG9wdXAuXG4gICAgICAgIHRoaXMucG9sbElkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucG9sbElkID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlamVjdChcbiAgICAgICAgICAgIF9jcmVhdGVFcnJvcih0aGlzLmF1dGgsIEF1dGhFcnJvckNvZGUuUE9QVVBfQ0xPU0VEX0JZX1VTRVIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSwgX1RpbWVvdXQuQVVUSF9FVkVOVCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb2xsSWQgPSB3aW5kb3cuc2V0VGltZW91dChwb2xsLCBfUE9MTF9XSU5ET1dfQ0xPU0VfVElNRU9VVC5nZXQoKSk7XG4gICAgfTtcblxuICAgIHBvbGwoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQge1xuICBBdXRoRXZlbnQsXG4gIEF1dGhFdmVudFR5cGUsXG4gIFBvcHVwUmVkaXJlY3RSZXNvbHZlckludGVybmFsXG59IGZyb20gJy4uLy4uL21vZGVsL3BvcHVwX3JlZGlyZWN0JztcbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IFBlcnNpc3RlbmNlSW50ZXJuYWwgfSBmcm9tICcuLi9wZXJzaXN0ZW5jZSc7XG5pbXBvcnQgeyBfcGVyc2lzdGVuY2VLZXlOYW1lIH0gZnJvbSAnLi4vcGVyc2lzdGVuY2UvcGVyc2lzdGVuY2VfdXNlcl9tYW5hZ2VyJztcbmltcG9ydCB7IF9nZXRJbnN0YW5jZSB9IGZyb20gJy4uL3V0aWwvaW5zdGFudGlhdG9yJztcbmltcG9ydCB7IEFic3RyYWN0UG9wdXBSZWRpcmVjdE9wZXJhdGlvbiB9IGZyb20gJy4vYWJzdHJhY3RfcG9wdXBfcmVkaXJlY3Rfb3BlcmF0aW9uJztcblxuY29uc3QgUEVORElOR19SRURJUkVDVF9LRVkgPSAncGVuZGluZ1JlZGlyZWN0JztcblxuLy8gV2Ugb25seSBnZXQgb25lIHJlZGlyZWN0IG91dGNvbWUgZm9yIGFueSBvbmUgYXV0aCwgc28ganVzdCBzdG9yZSBpdFxuLy8gaW4gaGVyZS5cbmNvbnN0IHJlZGlyZWN0T3V0Y29tZU1hcDogTWFwPFxuICBzdHJpbmcsXG4gICgpID0+IFByb21pc2U8VXNlckNyZWRlbnRpYWxJbnRlcm5hbCB8IG51bGw+XG4+ID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgY2xhc3MgUmVkaXJlY3RBY3Rpb24gZXh0ZW5kcyBBYnN0cmFjdFBvcHVwUmVkaXJlY3RPcGVyYXRpb24ge1xuICBldmVudElkID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgcmVzb2x2ZXI6IFBvcHVwUmVkaXJlY3RSZXNvbHZlckludGVybmFsLFxuICAgIGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlXG4gICkge1xuICAgIHN1cGVyKFxuICAgICAgYXV0aCxcbiAgICAgIFtcbiAgICAgICAgQXV0aEV2ZW50VHlwZS5TSUdOX0lOX1ZJQV9SRURJUkVDVCxcbiAgICAgICAgQXV0aEV2ZW50VHlwZS5MSU5LX1ZJQV9SRURJUkVDVCxcbiAgICAgICAgQXV0aEV2ZW50VHlwZS5SRUFVVEhfVklBX1JFRElSRUNULFxuICAgICAgICBBdXRoRXZlbnRUeXBlLlVOS05PV05cbiAgICAgIF0sXG4gICAgICByZXNvbHZlcixcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGJ5cGFzc0F1dGhTdGF0ZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGV4ZWN1dGUgZnVuY3Rpb247IGlmIHdlIGFscmVhZHkgaGF2ZSBhIHJlZGlyZWN0IHJlc3VsdCwgdGhlblxuICAgKiBqdXN0IHJldHVybiBpdC5cbiAgICovXG4gIGFzeW5jIGV4ZWN1dGUoKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEludGVybmFsIHwgbnVsbD4ge1xuICAgIGxldCByZWFkeU91dGNvbWUgPSByZWRpcmVjdE91dGNvbWVNYXAuZ2V0KHRoaXMuYXV0aC5fa2V5KCkpO1xuICAgIGlmICghcmVhZHlPdXRjb21lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoYXNQZW5kaW5nUmVkaXJlY3QgPSBhd2FpdCBfZ2V0QW5kQ2xlYXJQZW5kaW5nUmVkaXJlY3RTdGF0dXMoXG4gICAgICAgICAgdGhpcy5yZXNvbHZlcixcbiAgICAgICAgICB0aGlzLmF1dGhcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGFzUGVuZGluZ1JlZGlyZWN0ID8gYXdhaXQgc3VwZXIuZXhlY3V0ZSgpIDogbnVsbDtcbiAgICAgICAgcmVhZHlPdXRjb21lID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlYWR5T3V0Y29tZSA9ICgpID0+IFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgfVxuXG4gICAgICByZWRpcmVjdE91dGNvbWVNYXAuc2V0KHRoaXMuYXV0aC5fa2V5KCksIHJlYWR5T3V0Y29tZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgbm90IGJ5cGFzc2luZyBhdXRoIHN0YXRlLCB0aGUgcmVhZHkgb3V0Y29tZSBzaG91bGQgYmUgc2V0IHRvXG4gICAgLy8gbnVsbC5cbiAgICBpZiAoIXRoaXMuYnlwYXNzQXV0aFN0YXRlKSB7XG4gICAgICByZWRpcmVjdE91dGNvbWVNYXAuc2V0KHRoaXMuYXV0aC5fa2V5KCksICgpID0+IFByb21pc2UucmVzb2x2ZShudWxsKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWR5T3V0Y29tZSgpO1xuICB9XG5cbiAgYXN5bmMgb25BdXRoRXZlbnQoZXZlbnQ6IEF1dGhFdmVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChldmVudC50eXBlID09PSBBdXRoRXZlbnRUeXBlLlNJR05fSU5fVklBX1JFRElSRUNUKSB7XG4gICAgICByZXR1cm4gc3VwZXIub25BdXRoRXZlbnQoZXZlbnQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gQXV0aEV2ZW50VHlwZS5VTktOT1dOKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2VudGluZWwgdmFsdWUgaW5kaWNhdGluZyB0aGVyZSdzIG5vIHBlbmRpbmcgcmVkaXJlY3RcbiAgICAgIHRoaXMucmVzb2x2ZShudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuZXZlbnRJZCkge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuYXV0aC5fcmVkaXJlY3RVc2VyRm9ySWQoZXZlbnQuZXZlbnRJZCk7XG4gICAgICBpZiAodXNlcikge1xuICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xuICAgICAgICByZXR1cm4gc3VwZXIub25BdXRoRXZlbnQoZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIG9uRXhlY3V0aW9uKCk6IFByb21pc2U8dm9pZD4ge31cblxuICBjbGVhblVwKCk6IHZvaWQge31cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9nZXRBbmRDbGVhclBlbmRpbmdSZWRpcmVjdFN0YXR1cyhcbiAgcmVzb2x2ZXI6IFBvcHVwUmVkaXJlY3RSZXNvbHZlckludGVybmFsLFxuICBhdXRoOiBBdXRoSW50ZXJuYWxcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBrZXkgPSBwZW5kaW5nUmVkaXJlY3RLZXkoYXV0aCk7XG4gIGNvbnN0IHBlcnNpc3RlbmNlID0gcmVzb2x2ZXJQZXJzaXN0ZW5jZShyZXNvbHZlcik7XG4gIGlmICghKGF3YWl0IHBlcnNpc3RlbmNlLl9pc0F2YWlsYWJsZSgpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBoYXNQZW5kaW5nUmVkaXJlY3QgPSAoYXdhaXQgcGVyc2lzdGVuY2UuX2dldChrZXkpKSA9PT0gJ3RydWUnO1xuICBhd2FpdCBwZXJzaXN0ZW5jZS5fcmVtb3ZlKGtleSk7XG4gIHJldHVybiBoYXNQZW5kaW5nUmVkaXJlY3Q7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfc2V0UGVuZGluZ1JlZGlyZWN0U3RhdHVzKFxuICByZXNvbHZlcjogUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWwsXG4gIGF1dGg6IEF1dGhJbnRlcm5hbFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiByZXNvbHZlclBlcnNpc3RlbmNlKHJlc29sdmVyKS5fc2V0KHBlbmRpbmdSZWRpcmVjdEtleShhdXRoKSwgJ3RydWUnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9jbGVhclJlZGlyZWN0T3V0Y29tZXMoKTogdm9pZCB7XG4gIHJlZGlyZWN0T3V0Y29tZU1hcC5jbGVhcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX292ZXJyaWRlUmVkaXJlY3RSZXN1bHQoXG4gIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgcmVzdWx0OiAoKSA9PiBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfCBudWxsPlxuKTogdm9pZCB7XG4gIHJlZGlyZWN0T3V0Y29tZU1hcC5zZXQoYXV0aC5fa2V5KCksIHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVyUGVyc2lzdGVuY2UoXG4gIHJlc29sdmVyOiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJJbnRlcm5hbFxuKTogUGVyc2lzdGVuY2VJbnRlcm5hbCB7XG4gIHJldHVybiBfZ2V0SW5zdGFuY2UocmVzb2x2ZXIuX3JlZGlyZWN0UGVyc2lzdGVuY2UpO1xufVxuXG5mdW5jdGlvbiBwZW5kaW5nUmVkaXJlY3RLZXkoYXV0aDogQXV0aEludGVybmFsKTogc3RyaW5nIHtcbiAgcmV0dXJuIF9wZXJzaXN0ZW5jZUtleU5hbWUoXG4gICAgUEVORElOR19SRURJUkVDVF9LRVksXG4gICAgYXV0aC5jb25maWcuYXBpS2V5LFxuICAgIGF1dGgubmFtZVxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgQXV0aCxcbiAgQXV0aFByb3ZpZGVyLFxuICBQb3B1cFJlZGlyZWN0UmVzb2x2ZXIsXG4gIFVzZXIsXG4gIFVzZXJDcmVkZW50aWFsXG59IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4uLy4uL2NvcmUvYXV0aC9hdXRoX2ltcGwnO1xuaW1wb3J0IHsgX2Fzc2VydExpbmtlZFN0YXR1cyB9IGZyb20gJy4uLy4uL2NvcmUvdXNlci9saW5rX3VubGluayc7XG5pbXBvcnQgeyBfYXNzZXJ0SW5zdGFuY2VPZiB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgX2dlbmVyYXRlRXZlbnRJZCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9ldmVudF9pZCc7XG5pbXBvcnQgeyBBdXRoRXZlbnRUeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWwvcG9wdXBfcmVkaXJlY3QnO1xuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBfd2l0aERlZmF1bHRSZXNvbHZlciB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9yZXNvbHZlcic7XG5pbXBvcnQge1xuICBSZWRpcmVjdEFjdGlvbixcbiAgX3NldFBlbmRpbmdSZWRpcmVjdFN0YXR1c1xufSBmcm9tICcuLi8uLi9jb3JlL3N0cmF0ZWdpZXMvcmVkaXJlY3QnO1xuaW1wb3J0IHsgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vY29yZS9wcm92aWRlcnMvZmVkZXJhdGVkJztcbmltcG9ydCB7IGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXG4gKiBBdXRoZW50aWNhdGVzIGEgRmlyZWJhc2UgY2xpZW50IHVzaW5nIGEgZnVsbC1wYWdlIHJlZGlyZWN0IGZsb3cuXG4gKlxuICogQHJlbWFya3NcbiAqIFRvIGhhbmRsZSB0aGUgcmVzdWx0cyBhbmQgZXJyb3JzIGZvciB0aGlzIG9wZXJhdGlvbiwgcmVmZXIgdG8ge0BsaW5rIGdldFJlZGlyZWN0UmVzdWx0fS5cbiAqIEZvbGxvdyB0aGUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2F1dGgvd2ViL3JlZGlyZWN0LWJlc3QtcHJhY3RpY2VzXG4gKiB8IGJlc3QgcHJhY3RpY2VzfSB3aGVuIHVzaW5nIHtAbGluayBzaWduSW5XaXRoUmVkaXJlY3R9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBGYWNlYm9va0F1dGhQcm92aWRlcigpO1xuICogLy8gWW91IGNhbiBhZGQgYWRkaXRpb25hbCBzY29wZXMgdG8gdGhlIHByb3ZpZGVyOlxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3VzZXJfYmlydGhkYXknKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGlmIChyZXN1bHQpIHtcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIEZhY2Vib29rIEFjY2VzcyBUb2tlbi5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IHByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KGF1dGgsIHJlc3VsdCk7XG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIH1cbiAqIC8vIEFzIHRoaXMgQVBJIGNhbiBiZSB1c2VkIGZvciBzaWduLWluLCBsaW5raW5nIGFuZCByZWF1dGhlbnRpY2F0aW9uLFxuICogLy8gY2hlY2sgdGhlIG9wZXJhdGlvblR5cGUgdG8gZGV0ZXJtaW5lIHdoYXQgdHJpZ2dlcmVkIHRoaXMgcmVkaXJlY3RcbiAqIC8vIG9wZXJhdGlvbi5cbiAqIGNvbnN0IG9wZXJhdGlvblR5cGUgPSByZXN1bHQub3BlcmF0aW9uVHlwZTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBwcm92aWRlciAtIFRoZSBwcm92aWRlciB0byBhdXRoZW50aWNhdGUuIFRoZSBwcm92aWRlciBoYXMgdG8gYmUgYW4ge0BsaW5rIE9BdXRoUHJvdmlkZXJ9LlxuICogTm9uLU9BdXRoIHByb3ZpZGVycyBsaWtlIHtAbGluayBFbWFpbEF1dGhQcm92aWRlcn0gd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqIEBwYXJhbSByZXNvbHZlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJ9LCBvcHRpb25hbFxuICogaWYgYWxyZWFkeSBzdXBwbGllZCB0byB7QGxpbmsgaW5pdGlhbGl6ZUF1dGh9IG9yIHByb3ZpZGVkIGJ5IHtAbGluayBnZXRBdXRofS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduSW5XaXRoUmVkaXJlY3QoXG4gIGF1dGg6IEF1dGgsXG4gIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gIHJlc29sdmVyPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4pOiBQcm9taXNlPG5ldmVyPiB7XG4gIHJldHVybiBfc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyLCByZXNvbHZlcikgYXMgUHJvbWlzZTxuZXZlcj47XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfc2lnbkluV2l0aFJlZGlyZWN0KFxuICBhdXRoOiBBdXRoLFxuICBwcm92aWRlcjogQXV0aFByb3ZpZGVyLFxuICByZXNvbHZlcj86IFBvcHVwUmVkaXJlY3RSZXNvbHZlclxuKTogUHJvbWlzZTx2b2lkIHwgbmV2ZXI+IHtcbiAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICBfYXNzZXJ0SW5zdGFuY2VPZihhdXRoLCBwcm92aWRlciwgRmVkZXJhdGVkQXV0aFByb3ZpZGVyKTtcbiAgLy8gV2FpdCBmb3IgYXV0aCBpbml0aWFsaXphdGlvbiB0byBjb21wbGV0ZSwgdGhpcyB3aWxsIHByb2Nlc3MgcGVuZGluZyByZWRpcmVjdHMgYW5kIGNsZWFyIHRoZVxuICAvLyBQRU5ESU5HX1JFRElSRUNUX0tFWSBpbiBwZXJzaXN0ZW5jZS4gVGhpcyBzaG91bGQgYmUgY29tcGxldGVkIGJlZm9yZSBzdGFydGluZyBhIG5ld1xuICAvLyByZWRpcmVjdCBhbmQgY3JlYXRpbmcgYSBQRU5ESU5HX1JFRElSRUNUX0tFWSBlbnRyeS5cbiAgYXdhaXQgYXV0aEludGVybmFsLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gIGNvbnN0IHJlc29sdmVySW50ZXJuYWwgPSBfd2l0aERlZmF1bHRSZXNvbHZlcihhdXRoSW50ZXJuYWwsIHJlc29sdmVyKTtcbiAgYXdhaXQgX3NldFBlbmRpbmdSZWRpcmVjdFN0YXR1cyhyZXNvbHZlckludGVybmFsLCBhdXRoSW50ZXJuYWwpO1xuXG4gIHJldHVybiByZXNvbHZlckludGVybmFsLl9vcGVuUmVkaXJlY3QoXG4gICAgYXV0aEludGVybmFsLFxuICAgIHByb3ZpZGVyLFxuICAgIEF1dGhFdmVudFR5cGUuU0lHTl9JTl9WSUFfUkVESVJFQ1RcbiAgKTtcbn1cblxuLyoqXG4gKiBSZWF1dGhlbnRpY2F0ZXMgdGhlIGN1cnJlbnQgdXNlciB3aXRoIHRoZSBzcGVjaWZpZWQge0BsaW5rIE9BdXRoUHJvdmlkZXJ9IHVzaW5nIGEgZnVsbC1wYWdlIHJlZGlyZWN0IGZsb3cuXG4gKiBAcmVtYXJrc1xuICogVG8gaGFuZGxlIHRoZSByZXN1bHRzIGFuZCBlcnJvcnMgZm9yIHRoaXMgb3BlcmF0aW9uLCByZWZlciB0byB7QGxpbmsgZ2V0UmVkaXJlY3RSZXN1bHR9LlxuICogRm9sbG93IHRoZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvYXV0aC93ZWIvcmVkaXJlY3QtYmVzdC1wcmFjdGljZXNcbiAqIHwgYmVzdCBwcmFjdGljZXN9IHdoZW4gdXNpbmcge0BsaW5rIHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIC8vIFJlYXV0aGVudGljYXRlIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBhd2FpdCByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdChyZXN1bHQudXNlciwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIGFnYWluIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIHByb3ZpZGVyIC0gVGhlIHByb3ZpZGVyIHRvIGF1dGhlbnRpY2F0ZS4gVGhlIHByb3ZpZGVyIGhhcyB0byBiZSBhbiB7QGxpbmsgT0F1dGhQcm92aWRlcn0uXG4gKiBOb24tT0F1dGggcHJvdmlkZXJzIGxpa2Uge0BsaW5rIEVtYWlsQXV0aFByb3ZpZGVyfSB3aWxsIHRocm93IGFuIGVycm9yLlxuICogQHBhcmFtIHJlc29sdmVyIC0gQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFBvcHVwUmVkaXJlY3RSZXNvbHZlcn0sIG9wdGlvbmFsXG4gKiBpZiBhbHJlYWR5IHN1cHBsaWVkIHRvIHtAbGluayBpbml0aWFsaXplQXV0aH0gb3IgcHJvdmlkZWQgYnkge0BsaW5rIGdldEF1dGh9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0KFxuICB1c2VyOiBVc2VyLFxuICBwcm92aWRlcjogQXV0aFByb3ZpZGVyLFxuICByZXNvbHZlcj86IFBvcHVwUmVkaXJlY3RSZXNvbHZlclxuKTogUHJvbWlzZTxuZXZlcj4ge1xuICByZXR1cm4gX3JlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0KFxuICAgIHVzZXIsXG4gICAgcHJvdmlkZXIsXG4gICAgcmVzb2x2ZXJcbiAgKSBhcyBQcm9taXNlPG5ldmVyPjtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3QoXG4gIHVzZXI6IFVzZXIsXG4gIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gIHJlc29sdmVyPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4pOiBQcm9taXNlPHZvaWQgfCBuZXZlcj4ge1xuICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsO1xuICBfYXNzZXJ0SW5zdGFuY2VPZih1c2VySW50ZXJuYWwuYXV0aCwgcHJvdmlkZXIsIEZlZGVyYXRlZEF1dGhQcm92aWRlcik7XG4gIC8vIFdhaXQgZm9yIGF1dGggaW5pdGlhbGl6YXRpb24gdG8gY29tcGxldGUsIHRoaXMgd2lsbCBwcm9jZXNzIHBlbmRpbmcgcmVkaXJlY3RzIGFuZCBjbGVhciB0aGVcbiAgLy8gUEVORElOR19SRURJUkVDVF9LRVkgaW4gcGVyc2lzdGVuY2UuIFRoaXMgc2hvdWxkIGJlIGNvbXBsZXRlZCBiZWZvcmUgc3RhcnRpbmcgYSBuZXdcbiAgLy8gcmVkaXJlY3QgYW5kIGNyZWF0aW5nIGEgUEVORElOR19SRURJUkVDVF9LRVkgZW50cnkuXG4gIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gIC8vIEFsbG93IHRoZSByZXNvbHZlciB0byBlcnJvciBiZWZvcmUgcGVyc2lzdGluZyB0aGUgcmVkaXJlY3QgdXNlclxuICBjb25zdCByZXNvbHZlckludGVybmFsID0gX3dpdGhEZWZhdWx0UmVzb2x2ZXIodXNlckludGVybmFsLmF1dGgsIHJlc29sdmVyKTtcbiAgYXdhaXQgX3NldFBlbmRpbmdSZWRpcmVjdFN0YXR1cyhyZXNvbHZlckludGVybmFsLCB1c2VySW50ZXJuYWwuYXV0aCk7XG5cbiAgY29uc3QgZXZlbnRJZCA9IGF3YWl0IHByZXBhcmVVc2VyRm9yUmVkaXJlY3QodXNlckludGVybmFsKTtcbiAgcmV0dXJuIHJlc29sdmVySW50ZXJuYWwuX29wZW5SZWRpcmVjdChcbiAgICB1c2VySW50ZXJuYWwuYXV0aCxcbiAgICBwcm92aWRlcixcbiAgICBBdXRoRXZlbnRUeXBlLlJFQVVUSF9WSUFfUkVESVJFQ1QsXG4gICAgZXZlbnRJZFxuICApO1xufVxuXG4vKipcbiAqIExpbmtzIHRoZSB7QGxpbmsgT0F1dGhQcm92aWRlcn0gdG8gdGhlIHVzZXIgYWNjb3VudCB1c2luZyBhIGZ1bGwtcGFnZSByZWRpcmVjdCBmbG93LlxuICogQHJlbWFya3NcbiAqIFRvIGhhbmRsZSB0aGUgcmVzdWx0cyBhbmQgZXJyb3JzIGZvciB0aGlzIG9wZXJhdGlvbiwgcmVmZXIgdG8ge0BsaW5rIGdldFJlZGlyZWN0UmVzdWx0fS5cbiAqIEZvbGxvdyB0aGUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2F1dGgvd2ViL3JlZGlyZWN0LWJlc3QtcHJhY3RpY2VzXG4gKiB8IGJlc3QgcHJhY3RpY2VzfSB3aGVuIHVzaW5nIHtAbGluayBsaW5rV2l0aFJlZGlyZWN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBzb21lIG90aGVyIHByb3ZpZGVyLlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQoYXV0aCwgZW1haWwsIHBhc3N3b3JkKTtcbiAqIC8vIExpbmsgdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEZhY2Vib29rQXV0aFByb3ZpZGVyKCk7XG4gKiBhd2FpdCBsaW5rV2l0aFJlZGlyZWN0KHJlc3VsdC51c2VyLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gcHJvdmlkZXIgLSBUaGUgcHJvdmlkZXIgdG8gYXV0aGVudGljYXRlLiBUaGUgcHJvdmlkZXIgaGFzIHRvIGJlIGFuIHtAbGluayBPQXV0aFByb3ZpZGVyfS5cbiAqIE5vbi1PQXV0aCBwcm92aWRlcnMgbGlrZSB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKiBAcGFyYW0gcmVzb2x2ZXIgLSBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgUG9wdXBSZWRpcmVjdFJlc29sdmVyfSwgb3B0aW9uYWxcbiAqIGlmIGFscmVhZHkgc3VwcGxpZWQgdG8ge0BsaW5rIGluaXRpYWxpemVBdXRofSBvciBwcm92aWRlZCBieSB7QGxpbmsgZ2V0QXV0aH0uXG4gKlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmtXaXRoUmVkaXJlY3QoXG4gIHVzZXI6IFVzZXIsXG4gIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gIHJlc29sdmVyPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4pOiBQcm9taXNlPG5ldmVyPiB7XG4gIHJldHVybiBfbGlua1dpdGhSZWRpcmVjdCh1c2VyLCBwcm92aWRlciwgcmVzb2x2ZXIpIGFzIFByb21pc2U8bmV2ZXI+O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9saW5rV2l0aFJlZGlyZWN0KFxuICB1c2VyOiBVc2VyLFxuICBwcm92aWRlcjogQXV0aFByb3ZpZGVyLFxuICByZXNvbHZlcj86IFBvcHVwUmVkaXJlY3RSZXNvbHZlclxuKTogUHJvbWlzZTx2b2lkIHwgbmV2ZXI+IHtcbiAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpIGFzIFVzZXJJbnRlcm5hbDtcbiAgX2Fzc2VydEluc3RhbmNlT2YodXNlckludGVybmFsLmF1dGgsIHByb3ZpZGVyLCBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIpO1xuICAvLyBXYWl0IGZvciBhdXRoIGluaXRpYWxpemF0aW9uIHRvIGNvbXBsZXRlLCB0aGlzIHdpbGwgcHJvY2VzcyBwZW5kaW5nIHJlZGlyZWN0cyBhbmQgY2xlYXIgdGhlXG4gIC8vIFBFTkRJTkdfUkVESVJFQ1RfS0VZIGluIHBlcnNpc3RlbmNlLiBUaGlzIHNob3VsZCBiZSBjb21wbGV0ZWQgYmVmb3JlIHN0YXJ0aW5nIGEgbmV3XG4gIC8vIHJlZGlyZWN0IGFuZCBjcmVhdGluZyBhIFBFTkRJTkdfUkVESVJFQ1RfS0VZIGVudHJ5LlxuICBhd2FpdCB1c2VySW50ZXJuYWwuYXV0aC5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAvLyBBbGxvdyB0aGUgcmVzb2x2ZXIgdG8gZXJyb3IgYmVmb3JlIHBlcnNpc3RpbmcgdGhlIHJlZGlyZWN0IHVzZXJcbiAgY29uc3QgcmVzb2x2ZXJJbnRlcm5hbCA9IF93aXRoRGVmYXVsdFJlc29sdmVyKHVzZXJJbnRlcm5hbC5hdXRoLCByZXNvbHZlcik7XG4gIGF3YWl0IF9hc3NlcnRMaW5rZWRTdGF0dXMoZmFsc2UsIHVzZXJJbnRlcm5hbCwgcHJvdmlkZXIucHJvdmlkZXJJZCk7XG4gIGF3YWl0IF9zZXRQZW5kaW5nUmVkaXJlY3RTdGF0dXMocmVzb2x2ZXJJbnRlcm5hbCwgdXNlckludGVybmFsLmF1dGgpO1xuXG4gIGNvbnN0IGV2ZW50SWQgPSBhd2FpdCBwcmVwYXJlVXNlckZvclJlZGlyZWN0KHVzZXJJbnRlcm5hbCk7XG4gIHJldHVybiByZXNvbHZlckludGVybmFsLl9vcGVuUmVkaXJlY3QoXG4gICAgdXNlckludGVybmFsLmF1dGgsXG4gICAgcHJvdmlkZXIsXG4gICAgQXV0aEV2ZW50VHlwZS5MSU5LX1ZJQV9SRURJUkVDVCxcbiAgICBldmVudElkXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0gZnJvbSB0aGUgcmVkaXJlY3QtYmFzZWQgc2lnbi1pbiBmbG93LlxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiBzaWduLWluIHN1Y2NlZWRlZCwgcmV0dXJucyB0aGUgc2lnbmVkIGluIHVzZXIuIElmIHNpZ24taW4gd2FzIHVuc3VjY2Vzc2Z1bCwgZmFpbHMgd2l0aCBhblxuICogZXJyb3IuIElmIG5vIHJlZGlyZWN0IG9wZXJhdGlvbiB3YXMgY2FsbGVkLCByZXR1cm5zIGBudWxsYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIC8vIFlvdSBjYW4gYWRkIGFkZGl0aW9uYWwgc2NvcGVzIHRvIHRoZSBwcm92aWRlcjpcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCd1c2VyX2JpcnRoZGF5Jyk7XG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBpZiAocmVzdWx0KSB7XG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBwcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChhdXRoLCByZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiB9XG4gKiAvLyBBcyB0aGlzIEFQSSBjYW4gYmUgdXNlZCBmb3Igc2lnbi1pbiwgbGlua2luZyBhbmQgcmVhdXRoZW50aWNhdGlvbixcbiAqIC8vIGNoZWNrIHRoZSBvcGVyYXRpb25UeXBlIHRvIGRldGVybWluZSB3aGF0IHRyaWdnZXJlZCB0aGlzIHJlZGlyZWN0XG4gKiAvLyBvcGVyYXRpb24uXG4gKiBjb25zdCBvcGVyYXRpb25UeXBlID0gcmVzdWx0Lm9wZXJhdGlvblR5cGU7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gcmVzb2x2ZXIgLSBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgUG9wdXBSZWRpcmVjdFJlc29sdmVyfSwgb3B0aW9uYWxcbiAqIGlmIGFscmVhZHkgc3VwcGxpZWQgdG8ge0BsaW5rIGluaXRpYWxpemVBdXRofSBvciBwcm92aWRlZCBieSB7QGxpbmsgZ2V0QXV0aH0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVkaXJlY3RSZXN1bHQoXG4gIGF1dGg6IEF1dGgsXG4gIHJlc29sdmVyPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsIHwgbnVsbD4ge1xuICBhd2FpdCBfY2FzdEF1dGgoYXV0aCkuX2luaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgcmV0dXJuIF9nZXRSZWRpcmVjdFJlc3VsdChhdXRoLCByZXNvbHZlciwgZmFsc2UpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX2dldFJlZGlyZWN0UmVzdWx0KFxuICBhdXRoOiBBdXRoLFxuICByZXNvbHZlckV4dGVybj86IFBvcHVwUmVkaXJlY3RSZXNvbHZlcixcbiAgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2Vcbik6IFByb21pc2U8VXNlckNyZWRlbnRpYWwgfCBudWxsPiB7XG4gIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgY29uc3QgcmVzb2x2ZXIgPSBfd2l0aERlZmF1bHRSZXNvbHZlcihhdXRoSW50ZXJuYWwsIHJlc29sdmVyRXh0ZXJuKTtcbiAgY29uc3QgYWN0aW9uID0gbmV3IFJlZGlyZWN0QWN0aW9uKGF1dGhJbnRlcm5hbCwgcmVzb2x2ZXIsIGJ5cGFzc0F1dGhTdGF0ZSk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdGlvbi5leGVjdXRlKCk7XG5cbiAgaWYgKHJlc3VsdCAmJiAhYnlwYXNzQXV0aFN0YXRlKSB7XG4gICAgZGVsZXRlIHJlc3VsdC51c2VyLl9yZWRpcmVjdEV2ZW50SWQ7XG4gICAgYXdhaXQgYXV0aEludGVybmFsLl9wZXJzaXN0VXNlcklmQ3VycmVudChyZXN1bHQudXNlciBhcyBVc2VySW50ZXJuYWwpO1xuICAgIGF3YWl0IGF1dGhJbnRlcm5hbC5fc2V0UmVkaXJlY3RVc2VyKG51bGwsIHJlc29sdmVyRXh0ZXJuKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVVc2VyRm9yUmVkaXJlY3QodXNlcjogVXNlckludGVybmFsKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgZXZlbnRJZCA9IF9nZW5lcmF0ZUV2ZW50SWQoYCR7dXNlci51aWR9Ojo6YCk7XG4gIHVzZXIuX3JlZGlyZWN0RXZlbnRJZCA9IGV2ZW50SWQ7XG4gIGF3YWl0IHVzZXIuYXV0aC5fc2V0UmVkaXJlY3RVc2VyKHVzZXIpO1xuICBhd2FpdCB1c2VyLmF1dGguX3BlcnNpc3RVc2VySWZDdXJyZW50KHVzZXIpO1xuICByZXR1cm4gZXZlbnRJZDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEF1dGhFdmVudCxcbiAgQXV0aEV2ZW50Q29uc3VtZXIsXG4gIEF1dGhFdmVudFR5cGUsXG4gIEV2ZW50TWFuYWdlclxufSBmcm9tICcuLi8uLi9tb2RlbC9wb3B1cF9yZWRpcmVjdCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgX2NyZWF0ZUVycm9yIH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuXG4vLyBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc3RvcmUgdGhlIFVJRHMgb2Ygc2VlbiBldmVudHM7IHRoaXMgaXNcbi8vIHNldCB0byAxMCBtaW4gYnkgZGVmYXVsdFxuY29uc3QgRVZFTlRfRFVQTElDQVRJT05fQ0FDSEVfRFVSQVRJT05fTVMgPSAxMCAqIDYwICogMTAwMDtcblxuZXhwb3J0IGNsYXNzIEF1dGhFdmVudE1hbmFnZXIgaW1wbGVtZW50cyBFdmVudE1hbmFnZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGNhY2hlZEV2ZW50VWlkczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29uc3VtZXJzOiBTZXQ8QXV0aEV2ZW50Q29uc3VtZXI+ID0gbmV3IFNldCgpO1xuICBwcm90ZWN0ZWQgcXVldWVkUmVkaXJlY3RFdmVudDogQXV0aEV2ZW50IHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBoYXNIYW5kbGVkUG90ZW50aWFsUmVkaXJlY3QgPSBmYWxzZTtcbiAgcHJpdmF0ZSBsYXN0UHJvY2Vzc2VkRXZlbnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGF1dGg6IEF1dGhJbnRlcm5hbCkge31cblxuICByZWdpc3RlckNvbnN1bWVyKGF1dGhFdmVudENvbnN1bWVyOiBBdXRoRXZlbnRDb25zdW1lcik6IHZvaWQge1xuICAgIHRoaXMuY29uc3VtZXJzLmFkZChhdXRoRXZlbnRDb25zdW1lcik7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnF1ZXVlZFJlZGlyZWN0RXZlbnQgJiZcbiAgICAgIHRoaXMuaXNFdmVudEZvckNvbnN1bWVyKHRoaXMucXVldWVkUmVkaXJlY3RFdmVudCwgYXV0aEV2ZW50Q29uc3VtZXIpXG4gICAgKSB7XG4gICAgICB0aGlzLnNlbmRUb0NvbnN1bWVyKHRoaXMucXVldWVkUmVkaXJlY3RFdmVudCwgYXV0aEV2ZW50Q29uc3VtZXIpO1xuICAgICAgdGhpcy5zYXZlRXZlbnRUb0NhY2hlKHRoaXMucXVldWVkUmVkaXJlY3RFdmVudCk7XG4gICAgICB0aGlzLnF1ZXVlZFJlZGlyZWN0RXZlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHVucmVnaXN0ZXJDb25zdW1lcihhdXRoRXZlbnRDb25zdW1lcjogQXV0aEV2ZW50Q29uc3VtZXIpOiB2b2lkIHtcbiAgICB0aGlzLmNvbnN1bWVycy5kZWxldGUoYXV0aEV2ZW50Q29uc3VtZXIpO1xuICB9XG5cbiAgb25FdmVudChldmVudDogQXV0aEV2ZW50KTogYm9vbGVhbiB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gaGFuZGxlZFxuICAgIGlmICh0aGlzLmhhc0V2ZW50QmVlbkhhbmRsZWQoZXZlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnN1bWVycy5mb3JFYWNoKGNvbnN1bWVyID0+IHtcbiAgICAgIGlmICh0aGlzLmlzRXZlbnRGb3JDb25zdW1lcihldmVudCwgY29uc3VtZXIpKSB7XG4gICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbmRUb0NvbnN1bWVyKGV2ZW50LCBjb25zdW1lcik7XG4gICAgICAgIHRoaXMuc2F2ZUV2ZW50VG9DYWNoZShldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5oYXNIYW5kbGVkUG90ZW50aWFsUmVkaXJlY3QgfHwgIWlzUmVkaXJlY3RFdmVudChldmVudCkpIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgc2VlbiBhIHJlZGlyZWN0IGJlZm9yZSwgb3IgdGhpcyBpcyBhIHBvcHVwIGV2ZW50LFxuICAgICAgLy8gYmFpbCBub3dcbiAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgIH1cblxuICAgIHRoaXMuaGFzSGFuZGxlZFBvdGVudGlhbFJlZGlyZWN0ID0gdHJ1ZTtcblxuICAgIC8vIElmIHRoZSByZWRpcmVjdCB3YXNuJ3QgaGFuZGxlZCwgaGFuZyBvbiB0byBpdFxuICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgdGhpcy5xdWV1ZWRSZWRpcmVjdEV2ZW50ID0gZXZlbnQ7XG4gICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlZDtcbiAgfVxuXG4gIHByaXZhdGUgc2VuZFRvQ29uc3VtZXIoZXZlbnQ6IEF1dGhFdmVudCwgY29uc3VtZXI6IEF1dGhFdmVudENvbnN1bWVyKTogdm9pZCB7XG4gICAgaWYgKGV2ZW50LmVycm9yICYmICFpc051bGxSZWRpcmVjdEV2ZW50KGV2ZW50KSkge1xuICAgICAgY29uc3QgY29kZSA9XG4gICAgICAgIChldmVudC5lcnJvci5jb2RlPy5zcGxpdCgnYXV0aC8nKVsxXSBhcyBBdXRoRXJyb3JDb2RlKSB8fFxuICAgICAgICBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SO1xuICAgICAgY29uc3VtZXIub25FcnJvcihfY3JlYXRlRXJyb3IodGhpcy5hdXRoLCBjb2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN1bWVyLm9uQXV0aEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzRXZlbnRGb3JDb25zdW1lcihcbiAgICBldmVudDogQXV0aEV2ZW50LFxuICAgIGNvbnN1bWVyOiBBdXRoRXZlbnRDb25zdW1lclxuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBldmVudElkTWF0Y2hlcyA9XG4gICAgICBjb25zdW1lci5ldmVudElkID09PSBudWxsIHx8XG4gICAgICAoISFldmVudC5ldmVudElkICYmIGV2ZW50LmV2ZW50SWQgPT09IGNvbnN1bWVyLmV2ZW50SWQpO1xuICAgIHJldHVybiBjb25zdW1lci5maWx0ZXIuaW5jbHVkZXMoZXZlbnQudHlwZSkgJiYgZXZlbnRJZE1hdGNoZXM7XG4gIH1cblxuICBwcml2YXRlIGhhc0V2ZW50QmVlbkhhbmRsZWQoZXZlbnQ6IEF1dGhFdmVudCk6IGJvb2xlYW4ge1xuICAgIGlmIChcbiAgICAgIERhdGUubm93KCkgLSB0aGlzLmxhc3RQcm9jZXNzZWRFdmVudFRpbWUgPj1cbiAgICAgIEVWRU5UX0RVUExJQ0FUSU9OX0NBQ0hFX0RVUkFUSU9OX01TXG4gICAgKSB7XG4gICAgICB0aGlzLmNhY2hlZEV2ZW50VWlkcy5jbGVhcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNhY2hlZEV2ZW50VWlkcy5oYXMoZXZlbnRVaWQoZXZlbnQpKTtcbiAgfVxuXG4gIHByaXZhdGUgc2F2ZUV2ZW50VG9DYWNoZShldmVudDogQXV0aEV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5jYWNoZWRFdmVudFVpZHMuYWRkKGV2ZW50VWlkKGV2ZW50KSk7XG4gICAgdGhpcy5sYXN0UHJvY2Vzc2VkRXZlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFVpZChlOiBBdXRoRXZlbnQpOiBzdHJpbmcge1xuICByZXR1cm4gW2UudHlwZSwgZS5ldmVudElkLCBlLnNlc3Npb25JZCwgZS50ZW5hbnRJZF0uZmlsdGVyKHYgPT4gdikuam9pbignLScpO1xufVxuXG5mdW5jdGlvbiBpc051bGxSZWRpcmVjdEV2ZW50KHsgdHlwZSwgZXJyb3IgfTogQXV0aEV2ZW50KTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgdHlwZSA9PT0gQXV0aEV2ZW50VHlwZS5VTktOT1dOICYmXG4gICAgZXJyb3I/LmNvZGUgPT09IGBhdXRoLyR7QXV0aEVycm9yQ29kZS5OT19BVVRIX0VWRU5UfWBcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNSZWRpcmVjdEV2ZW50KGV2ZW50OiBBdXRoRXZlbnQpOiBib29sZWFuIHtcbiAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgY2FzZSBBdXRoRXZlbnRUeXBlLlNJR05fSU5fVklBX1JFRElSRUNUOlxuICAgIGNhc2UgQXV0aEV2ZW50VHlwZS5MSU5LX1ZJQV9SRURJUkVDVDpcbiAgICBjYXNlIEF1dGhFdmVudFR5cGUuUkVBVVRIX1ZJQV9SRURJUkVDVDpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgQXV0aEV2ZW50VHlwZS5VTktOT1dOOlxuICAgICAgcmV0dXJuIGlzTnVsbFJlZGlyZWN0RXZlbnQoZXZlbnQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IF9wZXJmb3JtQXBpUmVxdWVzdCwgRW5kcG9pbnQsIEh0dHBNZXRob2QgfSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBHZXRQcm9qZWN0Q29uZmlnUmVxdWVzdCB7XG4gIGFuZHJvaWRQYWNrYWdlTmFtZT86IHN0cmluZztcbiAgaW9zQnVuZGxlSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0UHJvamVjdENvbmZpZ1Jlc3BvbnNlIHtcbiAgYXV0aG9yaXplZERvbWFpbnM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX2dldFByb2plY3RDb25maWcoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IEdldFByb2plY3RDb25maWdSZXF1ZXN0ID0ge31cbik6IFByb21pc2U8R2V0UHJvamVjdENvbmZpZ1Jlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8R2V0UHJvamVjdENvbmZpZ1JlcXVlc3QsIEdldFByb2plY3RDb25maWdSZXNwb25zZT4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLkdFVCxcbiAgICBFbmRwb2ludC5HRVRfUFJPSkVDVF9DT05GSUcsXG4gICAgcmVxdWVzdFxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgX2dldFByb2plY3RDb25maWcgfSBmcm9tICcuLi8uLi9hcGkvcHJvamVjdF9jb25maWcvZ2V0X3Byb2plY3RfY29uZmlnJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBfZmFpbCB9IGZyb20gJy4vYXNzZXJ0JztcbmltcG9ydCB7IF9nZXRDdXJyZW50VXJsIH0gZnJvbSAnLi9sb2NhdGlvbic7XG5cbmNvbnN0IElQX0FERFJFU1NfUkVHRVggPSAvXlxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfVxcLlxcZHsxLDN9JC87XG5jb25zdCBIVFRQX1JFR0VYID0gL15odHRwcz8vO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3ZhbGlkYXRlT3JpZ2luKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBTa2lwIG9yaWdpbiB2YWxpZGF0aW9uIGlmIHdlIGFyZSBpbiBhbiBlbXVsYXRlZCBlbnZpcm9ubWVudFxuICBpZiAoYXV0aC5jb25maWcuZW11bGF0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7IGF1dGhvcml6ZWREb21haW5zIH0gPSBhd2FpdCBfZ2V0UHJvamVjdENvbmZpZyhhdXRoKTtcblxuICBmb3IgKGNvbnN0IGRvbWFpbiBvZiBhdXRob3JpemVkRG9tYWlucykge1xuICAgIHRyeSB7XG4gICAgICBpZiAobWF0Y2hEb21haW4oZG9tYWluKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZXJlJ3MgYSBVUkwgZXJyb3I7IGp1c3QgY29udGludWUgc2VhcmNoaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gSW4gdGhlIG9sZCBTREssIHRoaXMgZXJyb3IgYWxzbyBwcm92aWRlcyBoZWxwZnVsIG1lc3NhZ2VzLlxuICBfZmFpbChhdXRoLCBBdXRoRXJyb3JDb2RlLklOVkFMSURfT1JJR0lOKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hEb21haW4oZXhwZWN0ZWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBjdXJyZW50VXJsID0gX2dldEN1cnJlbnRVcmwoKTtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUgfSA9IG5ldyBVUkwoY3VycmVudFVybCk7XG4gIGlmIChleHBlY3RlZC5zdGFydHNXaXRoKCdjaHJvbWUtZXh0ZW5zaW9uOi8vJykpIHtcbiAgICBjb25zdCBjZVVybCA9IG5ldyBVUkwoZXhwZWN0ZWQpO1xuXG4gICAgaWYgKGNlVXJsLmhvc3RuYW1lID09PSAnJyAmJiBob3N0bmFtZSA9PT0gJycpIHtcbiAgICAgIC8vIEZvciBzb21lIHJlYXNvbiB3ZSdyZSBub3QgcGFyc2luZyBjaHJvbWUgVVJMcyBwcm9wZXJseVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgcHJvdG9jb2wgPT09ICdjaHJvbWUtZXh0ZW5zaW9uOicgJiZcbiAgICAgICAgZXhwZWN0ZWQucmVwbGFjZSgnY2hyb21lLWV4dGVuc2lvbjovLycsICcnKSA9PT1cbiAgICAgICAgICBjdXJyZW50VXJsLnJlcGxhY2UoJ2Nocm9tZS1leHRlbnNpb246Ly8nLCAnJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3RvY29sID09PSAnY2hyb21lLWV4dGVuc2lvbjonICYmIGNlVXJsLmhvc3RuYW1lID09PSBob3N0bmFtZTtcbiAgfVxuXG4gIGlmICghSFRUUF9SRUdFWC50ZXN0KHByb3RvY29sKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChJUF9BRERSRVNTX1JFR0VYLnRlc3QoZXhwZWN0ZWQpKSB7XG4gICAgLy8gVGhlIGRvbWFpbiBoYXMgdG8gYmUgZXhhY3RseSBlcXVhbCB0byB0aGUgcGF0dGVybiwgYXMgYW4gSVAgZG9tYWluIHdpbGxcbiAgICAvLyBvbmx5IGNvbnRhaW4gdGhlIElQLCBubyBleHRyYSBjaGFyYWN0ZXIuXG4gICAgcmV0dXJuIGhvc3RuYW1lID09PSBleHBlY3RlZDtcbiAgfVxuXG4gIC8vIERvdHMgaW4gcGF0dGVybiBzaG91bGQgYmUgZXNjYXBlZC5cbiAgY29uc3QgZXNjYXBlZERvbWFpblBhdHRlcm4gPSBleHBlY3RlZC5yZXBsYWNlKC9cXC4vZywgJ1xcXFwuJyk7XG4gIC8vIE5vbiBpcCBhZGRyZXNzIGRvbWFpbnMuXG4gIC8vIGRvbWFpbi5jb20gPSAqLmRvbWFpbi5jb20gT1IgZG9tYWluLmNvbVxuICBjb25zdCByZSA9IG5ldyBSZWdFeHAoXG4gICAgJ14oLitcXFxcLicgKyBlc2NhcGVkRG9tYWluUGF0dGVybiArICd8JyArIGVzY2FwZWREb21haW5QYXR0ZXJuICsgJykkJyxcbiAgICAnaSdcbiAgKTtcbiAgcmV0dXJuIHJlLnRlc3QoaG9zdG5hbWUpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi8uLi9jb3JlL2Vycm9ycyc7XG5pbXBvcnQgeyBfY3JlYXRlRXJyb3IgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IERlbGF5IH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2RlbGF5JztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgX3dpbmRvdyB9IGZyb20gJy4uL2F1dGhfd2luZG93JztcbmltcG9ydCAqIGFzIGpzIGZyb20gJy4uL2xvYWRfanMnO1xuXG5jb25zdCBORVRXT1JLX1RJTUVPVVQgPSBuZXcgRGVsYXkoMzAwMDAsIDYwMDAwKTtcblxuLyoqXG4gKiBSZXNldCB1bmxhb2RlZCBHQXBpIG1vZHVsZXMuIElmIGdhcGkubG9hZCBmYWlscyBkdWUgdG8gYSBuZXR3b3JrIGVycm9yLFxuICogaXQgd2lsbCBzdG9wIHdvcmtpbmcgYWZ0ZXIgYSByZXRyaWFsLiBUaGlzIGlzIGEgaGFjayB0byBmaXggdGhpcyBpc3N1ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRVbmxvYWRlZEdhcGlNb2R1bGVzKCk6IHZvaWQge1xuICAvLyBDbGVhciBsYXN0IGZhaWxlZCBnYXBpLmxvYWQgc3RhdGUgdG8gZm9yY2UgbmV4dCBnYXBpLmxvYWQgdG8gZmlyc3RcbiAgLy8gbG9hZCB0aGUgZmFpbGVkIGdhcGkuaWZyYW1lcyBtb2R1bGUuXG4gIC8vIEdldCBnYXBpeC5iZWFjb24gY29udGV4dC5cbiAgY29uc3QgYmVhY29uID0gX3dpbmRvdygpLl9fX2pzbDtcbiAgLy8gR2V0IGN1cnJlbnQgaGludC5cbiAgaWYgKGJlYWNvbj8uSCkge1xuICAgIC8vIEdldCBnYXBpIGhpbnQuXG4gICAgZm9yIChjb25zdCBoaW50IG9mIE9iamVjdC5rZXlzKGJlYWNvbi5IKSkge1xuICAgICAgLy8gUmVxdWVzdGVkIG1vZHVsZXMuXG4gICAgICBiZWFjb24uSFtoaW50XS5yID0gYmVhY29uLkhbaGludF0uciB8fCBbXTtcbiAgICAgIC8vIExvYWRlZCBtb2R1bGVzLlxuICAgICAgYmVhY29uLkhbaGludF0uTCA9IGJlYWNvbi5IW2hpbnRdLkwgfHwgW107XG4gICAgICAvLyBTZXQgcmVxdWVzdGVkIG1vZHVsZXMgdG8gYSBjb3B5IG9mIHRoZSBsb2FkZWQgbW9kdWxlcy5cbiAgICAgIGJlYWNvbi5IW2hpbnRdLnIgPSBbLi4uYmVhY29uLkhbaGludF0uTF07XG4gICAgICAvLyBDbGVhciBwZW5kaW5nIGNhbGxiYWNrcy5cbiAgICAgIGlmIChiZWFjb24uQ1ApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiZWFjb24uQ1AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBSZW1vdmUgYWxsIGZhaWxlZCBwZW5kaW5nIGNhbGxiYWNrcy5cbiAgICAgICAgICBiZWFjb24uQ1BbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvYWRHYXBpKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8Z2FwaS5pZnJhbWVzLkNvbnRleHQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPGdhcGkuaWZyYW1lcy5Db250ZXh0PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gRnVuY3Rpb24gdG8gcnVuIHdoZW4gZ2FwaS5sb2FkIGlzIHJlYWR5LlxuICAgIGZ1bmN0aW9uIGxvYWRHYXBpSWZyYW1lKCk6IHZvaWQge1xuICAgICAgLy8gVGhlIGRldmVsb3BlciBtYXkgaGF2ZSB0cmllZCB0byBwcmV2aW91c2x5IHJ1biBnYXBpLmxvYWQgYW5kIGZhaWxlZC5cbiAgICAgIC8vIFJ1biB0aGlzIHRvIGZpeCB0aGF0LlxuICAgICAgcmVzZXRVbmxvYWRlZEdhcGlNb2R1bGVzKCk7XG4gICAgICBnYXBpLmxvYWQoJ2dhcGkuaWZyYW1lcycsIHtcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGdhcGkuaWZyYW1lcy5nZXRDb250ZXh0KCkpO1xuICAgICAgICB9LFxuICAgICAgICBvbnRpbWVvdXQ6ICgpID0+IHtcbiAgICAgICAgICAvLyBUaGUgYWJvdmUgcmVzZXQgbWF5IGJlIHN1ZmZpY2llbnQsIGJ1dCBoYXZpbmcgdGhpcyByZXNldCBhZnRlclxuICAgICAgICAgIC8vIGZhaWx1cmUgZW5zdXJlcyB0aGF0IGlmIHRoZSBkZXZlbG9wZXIgY2FsbHMgZ2FwaS5sb2FkIGFmdGVyIHRoZVxuICAgICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgcmUtZXN0YWJsaXNoZWQgYW5kIGJlZm9yZSBhbm90aGVyIGF0dGVtcHQgdG8gZW1iZWRcbiAgICAgICAgICAvLyB0aGUgaWZyYW1lLCBpdCB3b3VsZCB3b3JrIGFuZCB3b3VsZCBub3QgYmUgYnJva2VuIGJlY2F1c2Ugb2Ygb3VyXG4gICAgICAgICAgLy8gZmFpbGVkIGF0dGVtcHQuXG4gICAgICAgICAgLy8gVGltZW91dCB3aGVuIGdhcGkuaWZyYW1lcy5JZnJhbWUgbm90IGxvYWRlZC5cbiAgICAgICAgICByZXNldFVubG9hZGVkR2FwaU1vZHVsZXMoKTtcbiAgICAgICAgICByZWplY3QoX2NyZWF0ZUVycm9yKGF1dGgsIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCkpO1xuICAgICAgICB9LFxuICAgICAgICB0aW1lb3V0OiBORVRXT1JLX1RJTUVPVVQuZ2V0KClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChfd2luZG93KCkuZ2FwaT8uaWZyYW1lcz8uSWZyYW1lKSB7XG4gICAgICAvLyBJZiBnYXBpLmlmcmFtZXMuSWZyYW1lIGF2YWlsYWJsZSwgcmVzb2x2ZS5cbiAgICAgIHJlc29sdmUoZ2FwaS5pZnJhbWVzLmdldENvbnRleHQoKSk7XG4gICAgfSBlbHNlIGlmICghIV93aW5kb3coKS5nYXBpPy5sb2FkKSB7XG4gICAgICAvLyBHYXBpIGxvYWRlciByZWFkeSwgbG9hZCBnYXBpLmlmcmFtZXMuXG4gICAgICBsb2FkR2FwaUlmcmFtZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgaWZyYW1lIGNhbGxiYWNrIHdoZW4gdGhpcyBpcyBjYWxsZWQgc28gYXMgbm90IHRvIG92ZXJ3cml0ZVxuICAgICAgLy8gYW55IHByZXZpb3VzIGRlZmluZWQgY2FsbGJhY2suIFRoaXMgaGFwcGVucyBpZiB0aGlzIG1ldGhvZCBpcyBjYWxsZWRcbiAgICAgIC8vIG11bHRpcGxlIHRpbWVzIGluIHBhcmFsbGVsIGFuZCBjb3VsZCByZXN1bHQgaW4gdGhlIGxhdGVyIGNhbGxiYWNrXG4gICAgICAvLyBvdmVyd3JpdGluZyB0aGUgcHJldmlvdXMgb25lLiBUaGlzIHdvdWxkIGVuZCB1cCB3aXRoIGEgaWZyYW1lXG4gICAgICAvLyB0aW1lb3V0LlxuICAgICAgY29uc3QgY2JOYW1lID0ganMuX2dlbmVyYXRlQ2FsbGJhY2tOYW1lKCdpZnJhbWVmY2InKTtcbiAgICAgIC8vIEdBcGkgbG9hZGVyIG5vdCBhdmFpbGFibGUsIGR5bmFtaWNhbGx5IGxvYWQgcGxhdGZvcm0uanMuXG4gICAgICBfd2luZG93KClbY2JOYW1lXSA9ICgpID0+IHtcbiAgICAgICAgLy8gR0FwaSBsb2FkZXIgc2hvdWxkIGJlIHJlYWR5LlxuICAgICAgICBpZiAoISFnYXBpLmxvYWQpIHtcbiAgICAgICAgICBsb2FkR2FwaUlmcmFtZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEdhcGkgbG9hZGVyIGZhaWxlZCwgdGhyb3cgZXJyb3IuXG4gICAgICAgICAgcmVqZWN0KF9jcmVhdGVFcnJvcihhdXRoLCBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8vIExvYWQgR0FwaSBsb2FkZXIuXG4gICAgICByZXR1cm4ganNcbiAgICAgICAgLl9sb2FkSlMoYGh0dHBzOi8vYXBpcy5nb29nbGUuY29tL2pzL2FwaS5qcz9vbmxvYWQ9JHtjYk5hbWV9YClcbiAgICAgICAgLmNhdGNoKGUgPT4gcmVqZWN0KGUpKTtcbiAgICB9XG4gIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAvLyBSZXNldCBjYWNoZWQgcHJvbWlzZSB0byBhbGxvdyBmb3IgcmV0cmlhbC5cbiAgICBjYWNoZWRHQXBpTG9hZGVyID0gbnVsbDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG59XG5cbmxldCBjYWNoZWRHQXBpTG9hZGVyOiBQcm9taXNlPGdhcGkuaWZyYW1lcy5Db250ZXh0PiB8IG51bGwgPSBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIF9sb2FkR2FwaShhdXRoOiBBdXRoSW50ZXJuYWwpOiBQcm9taXNlPGdhcGkuaWZyYW1lcy5Db250ZXh0PiB7XG4gIGNhY2hlZEdBcGlMb2FkZXIgPSBjYWNoZWRHQXBpTG9hZGVyIHx8IGxvYWRHYXBpKGF1dGgpO1xuICByZXR1cm4gY2FjaGVkR0FwaUxvYWRlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZXNldExvYWRlcigpOiB2b2lkIHtcbiAgY2FjaGVkR0FwaUxvYWRlciA9IG51bGw7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgU0RLX1ZFUlNJT04gfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IHF1ZXJ5c3RyaW5nIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgRGVmYXVsdENvbmZpZyB9IGZyb20gJy4uLy4uLy4uL2ludGVybmFsJztcblxuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQsIF9jcmVhdGVFcnJvciB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgRGVsYXkgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvZGVsYXknO1xuaW1wb3J0IHsgX2VtdWxhdG9yVXJsIH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2VtdWxhdG9yJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgX3dpbmRvdyB9IGZyb20gJy4uL2F1dGhfd2luZG93JztcbmltcG9ydCAqIGFzIGdhcGlMb2FkZXIgZnJvbSAnLi9nYXBpJztcblxuY29uc3QgUElOR19USU1FT1VUID0gbmV3IERlbGF5KDUwMDAsIDE1MDAwKTtcbmNvbnN0IElGUkFNRV9QQVRIID0gJ19fL2F1dGgvaWZyYW1lJztcbmNvbnN0IEVNVUxBVEVEX0lGUkFNRV9QQVRIID0gJ2VtdWxhdG9yL2F1dGgvaWZyYW1lJztcblxuY29uc3QgSUZSQU1FX0FUVFJJQlVURVMgPSB7XG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAnLTEwMHB4JyxcbiAgICB3aWR0aDogJzFweCcsXG4gICAgaGVpZ2h0OiAnMXB4J1xuICB9LFxuICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXG4gIHRhYmluZGV4OiAnLTEnXG59O1xuXG4vLyBNYXAgZnJvbSBhcGlIb3N0IHRvIGVuZHBvaW50IElEIGZvciBwYXNzaW5nIGludG8gaWZyYW1lLiBJbiBjdXJyZW50IFNESywgYXBpSG9zdCBjYW4gYmUgc2V0IHRvXG4vLyBhbnl0aGluZyAobm90IGZyb20gYSBsaXN0IG9mIGVuZHBvaW50cyB3aXRoIElEcyBhcyBpbiBsZWdhY3kpLCBzbyB0aGlzIGlzIHRoZSBjbG9zZXN0IHdlIGNhbiBnZXQuXG5jb25zdCBFSURfRlJPTV9BUElIT1NUID0gbmV3IE1hcChbXG4gIFtEZWZhdWx0Q29uZmlnLkFQSV9IT1NULCAncCddLCAvLyBwcm9kdWN0aW9uXG4gIFsnc3RhZ2luZy1pZGVudGl0eXRvb2xraXQuc2FuZGJveC5nb29nbGVhcGlzLmNvbScsICdzJ10sIC8vIHN0YWdpbmdcbiAgWyd0ZXN0LWlkZW50aXR5dG9vbGtpdC5zYW5kYm94Lmdvb2dsZWFwaXMuY29tJywgJ3QnXSAvLyB0ZXN0XG5dKTtcblxuZnVuY3Rpb24gZ2V0SWZyYW1lVXJsKGF1dGg6IEF1dGhJbnRlcm5hbCk6IHN0cmluZyB7XG4gIGNvbnN0IGNvbmZpZyA9IGF1dGguY29uZmlnO1xuICBfYXNzZXJ0KGNvbmZpZy5hdXRoRG9tYWluLCBhdXRoLCBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQVVUSF9ET01BSU4pO1xuICBjb25zdCB1cmwgPSBjb25maWcuZW11bGF0b3JcbiAgICA/IF9lbXVsYXRvclVybChjb25maWcsIEVNVUxBVEVEX0lGUkFNRV9QQVRIKVxuICAgIDogYGh0dHBzOi8vJHthdXRoLmNvbmZpZy5hdXRoRG9tYWlufS8ke0lGUkFNRV9QQVRIfWA7XG5cbiAgY29uc3QgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgIGFwaUtleTogY29uZmlnLmFwaUtleSxcbiAgICBhcHBOYW1lOiBhdXRoLm5hbWUsXG4gICAgdjogU0RLX1ZFUlNJT05cbiAgfTtcbiAgY29uc3QgZWlkID0gRUlEX0ZST01fQVBJSE9TVC5nZXQoYXV0aC5jb25maWcuYXBpSG9zdCk7XG4gIGlmIChlaWQpIHtcbiAgICBwYXJhbXMuZWlkID0gZWlkO1xuICB9XG4gIGNvbnN0IGZyYW1ld29ya3MgPSBhdXRoLl9nZXRGcmFtZXdvcmtzKCk7XG4gIGlmIChmcmFtZXdvcmtzLmxlbmd0aCkge1xuICAgIHBhcmFtcy5mdyA9IGZyYW1ld29ya3Muam9pbignLCcpO1xuICB9XG4gIHJldHVybiBgJHt1cmx9PyR7cXVlcnlzdHJpbmcocGFyYW1zKS5zbGljZSgxKX1gO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX29wZW5JZnJhbWUoXG4gIGF1dGg6IEF1dGhJbnRlcm5hbFxuKTogUHJvbWlzZTxnYXBpLmlmcmFtZXMuSWZyYW1lPiB7XG4gIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBnYXBpTG9hZGVyLl9sb2FkR2FwaShhdXRoKTtcbiAgY29uc3QgZ2FwaSA9IF93aW5kb3coKS5nYXBpO1xuICBfYXNzZXJ0KGdhcGksIGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICByZXR1cm4gY29udGV4dC5vcGVuKFxuICAgIHtcbiAgICAgIHdoZXJlOiBkb2N1bWVudC5ib2R5LFxuICAgICAgdXJsOiBnZXRJZnJhbWVVcmwoYXV0aCksXG4gICAgICBtZXNzYWdlSGFuZGxlcnNGaWx0ZXI6IGdhcGkuaWZyYW1lcy5DUk9TU19PUklHSU5fSUZSQU1FU19GSUxURVIsXG4gICAgICBhdHRyaWJ1dGVzOiBJRlJBTUVfQVRUUklCVVRFUyxcbiAgICAgIGRvbnRjbGVhcjogdHJ1ZVxuICAgIH0sXG4gICAgKGlmcmFtZTogZ2FwaS5pZnJhbWVzLklmcmFtZSkgPT5cbiAgICAgIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgYXdhaXQgaWZyYW1lLnJlc3R5bGUoe1xuICAgICAgICAgIC8vIFByZXZlbnQgaWZyYW1lIGZyb20gY2xvc2luZyBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgc2V0SGlkZU9uTGVhdmU6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG5ldHdvcmtFcnJvciA9IF9jcmVhdGVFcnJvcihcbiAgICAgICAgICBhdXRoLFxuICAgICAgICAgIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRFxuICAgICAgICApO1xuICAgICAgICAvLyBDb25maXJtIGlmcmFtZSBpcyBjb3JyZWN0bHkgbG9hZGVkLlxuICAgICAgICAvLyBUbyBmYWxsYmFjayBvbiBmYWlsdXJlLCBzZXQgYSB0aW1lb3V0LlxuICAgICAgICBjb25zdCBuZXR3b3JrRXJyb3JUaW1lciA9IF93aW5kb3coKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZWplY3QobmV0d29ya0Vycm9yKTtcbiAgICAgICAgfSwgUElOR19USU1FT1VULmdldCgpKTtcbiAgICAgICAgLy8gQ2xlYXIgdGltZXIgYW5kIHJlc29sdmUgcGVuZGluZyBpZnJhbWUgcmVhZHkgcHJvbWlzZS5cbiAgICAgICAgZnVuY3Rpb24gY2xlYXJUaW1lckFuZFJlc29sdmUoKTogdm9pZCB7XG4gICAgICAgICAgX3dpbmRvdygpLmNsZWFyVGltZW91dChuZXR3b3JrRXJyb3JUaW1lcik7XG4gICAgICAgICAgcmVzb2x2ZShpZnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgcmV0dXJucyBhbiBJVGhlbmFibGUuIEhvd2V2ZXIgdGhlIHJlamVjdCBwYXJ0IGRvZXMgbm90IGNhbGxcbiAgICAgICAgLy8gd2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQuXG4gICAgICAgIGlmcmFtZS5waW5nKGNsZWFyVGltZXJBbmRSZXNvbHZlKS50aGVuKGNsZWFyVGltZXJBbmRSZXNvbHZlLCAoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldHdvcmtFcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBnZXRVQSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7XG4gIF9pc0Nocm9tZUlPUyxcbiAgX2lzRmlyZWZveCxcbiAgX2lzSU9TU3RhbmRhbG9uZVxufSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvYnJvd3Nlcic7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcblxuY29uc3QgQkFTRV9QT1BVUF9PUFRJT05TID0ge1xuICBsb2NhdGlvbjogJ3llcycsXG4gIHJlc2l6YWJsZTogJ3llcycsXG4gIHN0YXR1c2JhcjogJ3llcycsXG4gIHRvb2xiYXI6ICdubydcbn07XG5cbmNvbnN0IERFRkFVTFRfV0lEVEggPSA1MDA7XG5jb25zdCBERUZBVUxUX0hFSUdIVCA9IDYwMDtcbmNvbnN0IFRBUkdFVF9CTEFOSyA9ICdfYmxhbmsnO1xuXG5jb25zdCBGSVJFRk9YX0VNUFRZX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0JztcblxuZXhwb3J0IGNsYXNzIEF1dGhQb3B1cCB7XG4gIGFzc29jaWF0ZWRFdmVudDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgd2luZG93OiBXaW5kb3cgfCBudWxsKSB7fVxuXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLndpbmRvdykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy53aW5kb3cuY2xvc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfb3BlbihcbiAgYXV0aDogQXV0aEludGVybmFsLFxuICB1cmw/OiBzdHJpbmcsXG4gIG5hbWU/OiBzdHJpbmcsXG4gIHdpZHRoID0gREVGQVVMVF9XSURUSCxcbiAgaGVpZ2h0ID0gREVGQVVMVF9IRUlHSFRcbik6IEF1dGhQb3B1cCB7XG4gIGNvbnN0IHRvcCA9IE1hdGgubWF4KCh3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0IC0gaGVpZ2h0KSAvIDIsIDApLnRvU3RyaW5nKCk7XG4gIGNvbnN0IGxlZnQgPSBNYXRoLm1heCgod2luZG93LnNjcmVlbi5hdmFpbFdpZHRoIC0gd2lkdGgpIC8gMiwgMCkudG9TdHJpbmcoKTtcbiAgbGV0IHRhcmdldCA9ICcnO1xuXG4gIGNvbnN0IG9wdGlvbnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgLi4uQkFTRV9QT1BVUF9PUFRJT05TLFxuICAgIHdpZHRoOiB3aWR0aC50b1N0cmluZygpLFxuICAgIGhlaWdodDogaGVpZ2h0LnRvU3RyaW5nKCksXG4gICAgdG9wLFxuICAgIGxlZnRcbiAgfTtcblxuICAvLyBDaHJvbWUgaU9TIDcgYW5kIDggaXMgcmV0dXJuaW5nIGFuIHVuZGVmaW5lZCBwb3B1cCB3aW4gd2hlbiB0YXJnZXQgaXNcbiAgLy8gc3BlY2lmaWVkLCBldmVuIHRob3VnaCB0aGUgcG9wdXAgaXMgbm90IG5lY2Vzc2FyaWx5IGJsb2NrZWQuXG4gIGNvbnN0IHVhID0gZ2V0VUEoKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChuYW1lKSB7XG4gICAgdGFyZ2V0ID0gX2lzQ2hyb21lSU9TKHVhKSA/IFRBUkdFVF9CTEFOSyA6IG5hbWU7XG4gIH1cblxuICBpZiAoX2lzRmlyZWZveCh1YSkpIHtcbiAgICAvLyBGaXJlZm94IGNvbXBsYWlucyB3aGVuIGludmFsaWQgVVJMcyBhcmUgcG9wcGVkIG91dC4gSGFja3kgd2F5IHRvIGJ5cGFzcy5cbiAgICB1cmwgPSB1cmwgfHwgRklSRUZPWF9FTVBUWV9VUkw7XG4gICAgLy8gRmlyZWZveCBkaXNhYmxlcyBieSBkZWZhdWx0IHNjcm9sbGluZyBvbiBwb3B1cCB3aW5kb3dzLCB3aGljaCBjYW4gY3JlYXRlXG4gICAgLy8gaXNzdWVzIHdoZW4gdGhlIHVzZXIgaGFzIG1hbnkgR29vZ2xlIGFjY291bnRzLCBmb3IgaW5zdGFuY2UuXG4gICAgb3B0aW9ucy5zY3JvbGxiYXJzID0gJ3llcyc7XG4gIH1cblxuICBjb25zdCBvcHRpb25zU3RyaW5nID0gT2JqZWN0LmVudHJpZXMob3B0aW9ucykucmVkdWNlKFxuICAgIChhY2N1bSwgW2tleSwgdmFsdWVdKSA9PiBgJHthY2N1bX0ke2tleX09JHt2YWx1ZX0sYCxcbiAgICAnJ1xuICApO1xuXG4gIGlmIChfaXNJT1NTdGFuZGFsb25lKHVhKSAmJiB0YXJnZXQgIT09ICdfc2VsZicpIHtcbiAgICBvcGVuQXNOZXdXaW5kb3dJT1ModXJsIHx8ICcnLCB0YXJnZXQpO1xuICAgIHJldHVybiBuZXcgQXV0aFBvcHVwKG51bGwpO1xuICB9XG5cbiAgLy8gYWJvdXQ6YmxhbmsgZ2V0dGluZyBzYW5pdGl6ZWQgY2F1c2luZyBicm93c2VycyBsaWtlIElFL0VkZ2UgdG8gZGlzcGxheVxuICAvLyBicmllZiBlcnJvciBtZXNzYWdlIGJlZm9yZSByZWRpcmVjdGluZyB0byBoYW5kbGVyLlxuICBjb25zdCBuZXdXaW4gPSB3aW5kb3cub3Blbih1cmwgfHwgJycsIHRhcmdldCwgb3B0aW9uc1N0cmluZyk7XG4gIF9hc3NlcnQobmV3V2luLCBhdXRoLCBBdXRoRXJyb3JDb2RlLlBPUFVQX0JMT0NLRUQpO1xuXG4gIC8vIEZsYWt5IG9uIElFIGVkZ2UsIGVuY2Fwc3VsYXRlIHdpdGggYSB0cnkgYW5kIGNhdGNoLlxuICB0cnkge1xuICAgIG5ld1dpbi5mb2N1cygpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHJldHVybiBuZXcgQXV0aFBvcHVwKG5ld1dpbik7XG59XG5cbmZ1bmN0aW9uIG9wZW5Bc05ld1dpbmRvd0lPUyh1cmw6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGVsLmhyZWYgPSB1cmw7XG4gIGVsLnRhcmdldCA9IHRhcmdldDtcbiAgY29uc3QgY2xpY2sgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xuICBjbGljay5pbml0TW91c2VFdmVudChcbiAgICAnY2xpY2snLFxuICAgIHRydWUsXG4gICAgdHJ1ZSxcbiAgICB3aW5kb3csXG4gICAgMSxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIGZhbHNlLFxuICAgIGZhbHNlLFxuICAgIGZhbHNlLFxuICAgIGZhbHNlLFxuICAgIDEsXG4gICAgbnVsbFxuICApO1xuICBlbC5kaXNwYXRjaEV2ZW50KGNsaWNrKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFNES19WRVJTSU9OIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBBdXRoUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgQXBpS2V5LCBBcHBOYW1lLCBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IEF1dGhFdmVudFR5cGUgfSBmcm9tICcuLi8uLi9tb2RlbC9wb3B1cF9yZWRpcmVjdCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuL2Fzc2VydCc7XG5pbXBvcnQgeyBpc0VtcHR5LCBxdWVyeXN0cmluZyB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IF9lbXVsYXRvclVybCB9IGZyb20gJy4vZW11bGF0b3InO1xuaW1wb3J0IHsgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2ZlZGVyYXRlZCc7XG5pbXBvcnQgeyBCYXNlT0F1dGhQcm92aWRlciB9IGZyb20gJy4uL3Byb3ZpZGVycy9vYXV0aCc7XG5cbi8qKlxuICogVVJMIGZvciBBdXRoZW50aWNhdGlvbiB3aWRnZXQgd2hpY2ggd2lsbCBpbml0aWF0ZSB0aGUgT0F1dGggaGFuZHNoYWtlXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFdJREdFVF9QQVRIID0gJ19fL2F1dGgvaGFuZGxlcic7XG5cbi8qKlxuICogVVJMIGZvciBlbXVsYXRlZCBlbnZpcm9ubWVudFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBFTVVMQVRPUl9XSURHRVRfUEFUSCA9ICdlbXVsYXRvci9hdXRoL2hhbmRsZXInO1xuXG4vKipcbiAqIEZyYWdtZW50IG5hbWUgZm9yIHRoZSBBcHAgQ2hlY2sgdG9rZW4gdGhhdCBnZXRzIHBhc3NlZCB0byB0aGUgd2lkZ2V0XG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEZJUkVCQVNFX0FQUF9DSEVDS19GUkFHTUVOVF9JRCA9IGVuY29kZVVSSUNvbXBvbmVudCgnZmFjJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWRlZmluaXRpb25zXG50eXBlIFdpZGdldFBhcmFtcyA9IHtcbiAgYXBpS2V5OiBBcGlLZXk7XG4gIGFwcE5hbWU6IEFwcE5hbWU7XG4gIGF1dGhUeXBlOiBBdXRoRXZlbnRUeXBlO1xuICByZWRpcmVjdFVybD86IHN0cmluZztcbiAgdjogc3RyaW5nO1xuICBwcm92aWRlcklkPzogc3RyaW5nO1xuICBzY29wZXM/OiBzdHJpbmc7XG4gIGN1c3RvbVBhcmFtZXRlcnM/OiBzdHJpbmc7XG4gIGV2ZW50SWQ/OiBzdHJpbmc7XG4gIHRpZD86IHN0cmluZztcbn0gJiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX2dldFJlZGlyZWN0VXJsKFxuICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gIGF1dGhUeXBlOiBBdXRoRXZlbnRUeXBlLFxuICByZWRpcmVjdFVybD86IHN0cmluZyxcbiAgZXZlbnRJZD86IHN0cmluZyxcbiAgYWRkaXRpb25hbFBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIF9hc3NlcnQoYXV0aC5jb25maWcuYXV0aERvbWFpbiwgYXV0aCwgQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FVVEhfRE9NQUlOKTtcbiAgX2Fzc2VydChhdXRoLmNvbmZpZy5hcGlLZXksIGF1dGgsIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BUElfS0VZKTtcblxuICBjb25zdCBwYXJhbXM6IFdpZGdldFBhcmFtcyA9IHtcbiAgICBhcGlLZXk6IGF1dGguY29uZmlnLmFwaUtleSxcbiAgICBhcHBOYW1lOiBhdXRoLm5hbWUsXG4gICAgYXV0aFR5cGUsXG4gICAgcmVkaXJlY3RVcmwsXG4gICAgdjogU0RLX1ZFUlNJT04sXG4gICAgZXZlbnRJZFxuICB9O1xuXG4gIGlmIChwcm92aWRlciBpbnN0YW5jZW9mIEZlZGVyYXRlZEF1dGhQcm92aWRlcikge1xuICAgIHByb3ZpZGVyLnNldERlZmF1bHRMYW5ndWFnZShhdXRoLmxhbmd1YWdlQ29kZSk7XG4gICAgcGFyYW1zLnByb3ZpZGVySWQgPSBwcm92aWRlci5wcm92aWRlcklkIHx8ICcnO1xuICAgIGlmICghaXNFbXB0eShwcm92aWRlci5nZXRDdXN0b21QYXJhbWV0ZXJzKCkpKSB7XG4gICAgICBwYXJhbXMuY3VzdG9tUGFyYW1ldGVycyA9IEpTT04uc3RyaW5naWZ5KHByb3ZpZGVyLmdldEN1c3RvbVBhcmFtZXRlcnMoKSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBzZXQgYWRkaXRpb25hbFBhcmFtcyBmcm9tIHRoZSBwcm92aWRlciBhcyB3ZWxsP1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFkZGl0aW9uYWxQYXJhbXMgfHwge30pKSB7XG4gICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm92aWRlciBpbnN0YW5jZW9mIEJhc2VPQXV0aFByb3ZpZGVyKSB7XG4gICAgY29uc3Qgc2NvcGVzID0gcHJvdmlkZXIuZ2V0U2NvcGVzKCkuZmlsdGVyKHNjb3BlID0+IHNjb3BlICE9PSAnJyk7XG4gICAgaWYgKHNjb3Blcy5sZW5ndGggPiAwKSB7XG4gICAgICBwYXJhbXMuc2NvcGVzID0gc2NvcGVzLmpvaW4oJywnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYXV0aC50ZW5hbnRJZCkge1xuICAgIHBhcmFtcy50aWQgPSBhdXRoLnRlbmFudElkO1xuICB9XG5cbiAgLy8gVE9ETzogbWF5YmUgc2V0IGVpZCBhcyBlbmRpcG9pbnRJZFxuICAvLyBUT0RPOiBtYXliZSBzZXQgZncgYXMgRnJhbWV3b3Jrcy5qb2luKFwiLFwiKVxuXG4gIGNvbnN0IHBhcmFtc0RpY3QgPSBwYXJhbXMgYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPjtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyYW1zRGljdCkpIHtcbiAgICBpZiAocGFyYW1zRGljdFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBwYXJhbXNEaWN0W2tleV07XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0cyB0aGUgQXBwIENoZWNrIHRva2VuIHRvIHBhc3MgdG8gdGhlIHdpZGdldFxuICBjb25zdCBhcHBDaGVja1Rva2VuID0gYXdhaXQgYXV0aC5fZ2V0QXBwQ2hlY2tUb2tlbigpO1xuICBjb25zdCBhcHBDaGVja1Rva2VuRnJhZ21lbnQgPSBhcHBDaGVja1Rva2VuXG4gICAgPyBgIyR7RklSRUJBU0VfQVBQX0NIRUNLX0ZSQUdNRU5UX0lEfT0ke2VuY29kZVVSSUNvbXBvbmVudChhcHBDaGVja1Rva2VuKX1gXG4gICAgOiAnJztcblxuICAvLyBTdGFydCBhdCBpbmRleCAxIHRvIHNraXAgdGhlIGxlYWRpbmcgJyYnIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgcmV0dXJuIGAke2dldEhhbmRsZXJCYXNlKGF1dGgpfT8ke3F1ZXJ5c3RyaW5nKHBhcmFtc0RpY3QpLnNsaWNlKFxuICAgIDFcbiAgKX0ke2FwcENoZWNrVG9rZW5GcmFnbWVudH1gO1xufVxuXG5mdW5jdGlvbiBnZXRIYW5kbGVyQmFzZSh7IGNvbmZpZyB9OiBBdXRoSW50ZXJuYWwpOiBzdHJpbmcge1xuICBpZiAoIWNvbmZpZy5lbXVsYXRvcikge1xuICAgIHJldHVybiBgaHR0cHM6Ly8ke2NvbmZpZy5hdXRoRG9tYWlufS8ke1dJREdFVF9QQVRIfWA7XG4gIH1cblxuICByZXR1cm4gX2VtdWxhdG9yVXJsKGNvbmZpZywgRU1VTEFUT1JfV0lER0VUX1BBVEgpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aFByb3ZpZGVyLCBQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgfSBmcm9tICcuLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBBdXRoRXZlbnRNYW5hZ2VyIH0gZnJvbSAnLi4vY29yZS9hdXRoL2F1dGhfZXZlbnRfbWFuYWdlcic7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCwgZGVidWdBc3NlcnQsIF9mYWlsIH0gZnJvbSAnLi4vY29yZS91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBfZ2VuZXJhdGVFdmVudElkIH0gZnJvbSAnLi4vY29yZS91dGlsL2V2ZW50X2lkJztcbmltcG9ydCB7IF9nZXRDdXJyZW50VXJsIH0gZnJvbSAnLi4vY29yZS91dGlsL2xvY2F0aW9uJztcbmltcG9ydCB7IF92YWxpZGF0ZU9yaWdpbiB9IGZyb20gJy4uL2NvcmUvdXRpbC92YWxpZGF0ZV9vcmlnaW4nO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQge1xuICBBdXRoRXZlbnRUeXBlLFxuICBFdmVudE1hbmFnZXIsXG4gIEdhcGlBdXRoRXZlbnQsXG4gIEdhcGlPdXRjb21lLFxuICBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJJbnRlcm5hbFxufSBmcm9tICcuLi9tb2RlbC9wb3B1cF9yZWRpcmVjdCc7XG5pbXBvcnQgeyBfc2V0V2luZG93TG9jYXRpb24gfSBmcm9tICcuL2F1dGhfd2luZG93JztcbmltcG9ydCB7IF9vcGVuSWZyYW1lIH0gZnJvbSAnLi9pZnJhbWUvaWZyYW1lJztcbmltcG9ydCB7IGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UgfSBmcm9tICcuL3BlcnNpc3RlbmNlL3Nlc3Npb25fc3RvcmFnZSc7XG5pbXBvcnQgeyBfb3BlbiwgQXV0aFBvcHVwIH0gZnJvbSAnLi91dGlsL3BvcHVwJztcbmltcG9ydCB7IF9nZXRSZWRpcmVjdFJlc3VsdCB9IGZyb20gJy4vc3RyYXRlZ2llcy9yZWRpcmVjdCc7XG5pbXBvcnQgeyBfZ2V0UmVkaXJlY3RVcmwgfSBmcm9tICcuLi9jb3JlL3V0aWwvaGFuZGxlcic7XG5pbXBvcnQgeyBfaXNJT1MsIF9pc01vYmlsZUJyb3dzZXIsIF9pc1NhZmFyaSB9IGZyb20gJy4uL2NvcmUvdXRpbC9icm93c2VyJztcbmltcG9ydCB7IF9vdmVycmlkZVJlZGlyZWN0UmVzdWx0IH0gZnJvbSAnLi4vY29yZS9zdHJhdGVnaWVzL3JlZGlyZWN0JztcblxuLyoqXG4gKiBUaGUgc3BlY2lhbCB3ZWIgc3RvcmFnZSBldmVudFxuICpcbiAqL1xuY29uc3QgV0VCX1NUT1JBR0VfU1VQUE9SVF9LRVkgPSAnd2ViU3RvcmFnZVN1cHBvcnQnO1xuXG5pbnRlcmZhY2UgV2ViU3RvcmFnZVN1cHBvcnRNZXNzYWdlIGV4dGVuZHMgZ2FwaS5pZnJhbWVzLk1lc3NhZ2Uge1xuICBbaW5kZXg6IG51bWJlcl06IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+O1xufVxuXG5pbnRlcmZhY2UgTWFuYWdlck9yUHJvbWlzZSB7XG4gIG1hbmFnZXI/OiBFdmVudE1hbmFnZXI7XG4gIHByb21pc2U/OiBQcm9taXNlPEV2ZW50TWFuYWdlcj47XG59XG5cbmNsYXNzIEJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgaW1wbGVtZW50cyBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJJbnRlcm5hbCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRNYW5hZ2VyczogUmVjb3JkPHN0cmluZywgTWFuYWdlck9yUHJvbWlzZT4gPSB7fTtcbiAgcHJpdmF0ZSByZWFkb25seSBpZnJhbWVzOiBSZWNvcmQ8c3RyaW5nLCBnYXBpLmlmcmFtZXMuSWZyYW1lPiA9IHt9O1xuICBwcml2YXRlIHJlYWRvbmx5IG9yaWdpblZhbGlkYXRpb25Qcm9taXNlczogUmVjb3JkPHN0cmluZywgUHJvbWlzZTx2b2lkPj4gPSB7fTtcblxuICByZWFkb25seSBfcmVkaXJlY3RQZXJzaXN0ZW5jZSA9IGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2U7XG5cbiAgLy8gV3JhcHBpbmcgaW4gYXN5bmMgZXZlbiB0aG91Z2ggd2UgZG9uJ3QgYXdhaXQgYW55d2hlcmUgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBzdXJlIGVycm9ycyBhcmUgcmFpc2VkIGFzIHByb21pc2UgcmVqZWN0aW9uc1xuICBhc3luYyBfb3BlblBvcHVwKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBwcm92aWRlcjogQXV0aFByb3ZpZGVyLFxuICAgIGF1dGhUeXBlOiBBdXRoRXZlbnRUeXBlLFxuICAgIGV2ZW50SWQ/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxBdXRoUG9wdXA+IHtcbiAgICBkZWJ1Z0Fzc2VydChcbiAgICAgIHRoaXMuZXZlbnRNYW5hZ2Vyc1thdXRoLl9rZXkoKV0/Lm1hbmFnZXIsXG4gICAgICAnX2luaXRpYWxpemUoKSBub3QgY2FsbGVkIGJlZm9yZSBfb3BlblBvcHVwKCknXG4gICAgKTtcblxuICAgIGNvbnN0IHVybCA9IGF3YWl0IF9nZXRSZWRpcmVjdFVybChcbiAgICAgIGF1dGgsXG4gICAgICBwcm92aWRlcixcbiAgICAgIGF1dGhUeXBlLFxuICAgICAgX2dldEN1cnJlbnRVcmwoKSxcbiAgICAgIGV2ZW50SWRcbiAgICApO1xuICAgIHJldHVybiBfb3BlbihhdXRoLCB1cmwsIF9nZW5lcmF0ZUV2ZW50SWQoKSk7XG4gIH1cblxuICBhc3luYyBfb3BlblJlZGlyZWN0KFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBwcm92aWRlcjogQXV0aFByb3ZpZGVyLFxuICAgIGF1dGhUeXBlOiBBdXRoRXZlbnRUeXBlLFxuICAgIGV2ZW50SWQ/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxuZXZlcj4ge1xuICAgIGF3YWl0IHRoaXMuX29yaWdpblZhbGlkYXRpb24oYXV0aCk7XG4gICAgY29uc3QgdXJsID0gYXdhaXQgX2dldFJlZGlyZWN0VXJsKFxuICAgICAgYXV0aCxcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgYXV0aFR5cGUsXG4gICAgICBfZ2V0Q3VycmVudFVybCgpLFxuICAgICAgZXZlbnRJZFxuICAgICk7XG4gICAgX3NldFdpbmRvd0xvY2F0aW9uKHVybCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KTtcbiAgfVxuXG4gIF9pbml0aWFsaXplKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8RXZlbnRNYW5hZ2VyPiB7XG4gICAgY29uc3Qga2V5ID0gYXV0aC5fa2V5KCk7XG4gICAgaWYgKHRoaXMuZXZlbnRNYW5hZ2Vyc1trZXldKSB7XG4gICAgICBjb25zdCB7IG1hbmFnZXIsIHByb21pc2UgfSA9IHRoaXMuZXZlbnRNYW5hZ2Vyc1trZXldO1xuICAgICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYW5hZ2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnQXNzZXJ0KHByb21pc2UsICdJZiBtYW5hZ2VyIGlzIG5vdCBzZXQsIHByb21pc2Ugc2hvdWxkIGJlJyk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmluaXRBbmRHZXRNYW5hZ2VyKGF1dGgpO1xuICAgIHRoaXMuZXZlbnRNYW5hZ2Vyc1trZXldID0geyBwcm9taXNlIH07XG5cbiAgICAvLyBJZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCwgdGhlIGtleSBzaG91bGQgYmUgcmVtb3ZlZCBzbyB0aGF0IHRoZVxuICAgIC8vIG9wZXJhdGlvbiBjYW4gYmUgcmV0cmllZCBsYXRlci5cbiAgICBwcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50TWFuYWdlcnNba2V5XTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbml0QW5kR2V0TWFuYWdlcihhdXRoOiBBdXRoSW50ZXJuYWwpOiBQcm9taXNlPEV2ZW50TWFuYWdlcj4ge1xuICAgIGNvbnN0IGlmcmFtZSA9IGF3YWl0IF9vcGVuSWZyYW1lKGF1dGgpO1xuICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQXV0aEV2ZW50TWFuYWdlcihhdXRoKTtcbiAgICBpZnJhbWUucmVnaXN0ZXI8R2FwaUF1dGhFdmVudD4oXG4gICAgICAnYXV0aEV2ZW50JyxcbiAgICAgIChpZnJhbWVFdmVudDogR2FwaUF1dGhFdmVudCB8IG51bGwpID0+IHtcbiAgICAgICAgX2Fzc2VydChpZnJhbWVFdmVudD8uYXV0aEV2ZW50LCBhdXRoLCBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSF9FVkVOVCk7XG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIHNwbGl0dGluZyByZWRpcmVjdCBhbmQgcG9wdXAgZXZlbnRzIGVhcmxpZXIgb25cblxuICAgICAgICBjb25zdCBoYW5kbGVkID0gbWFuYWdlci5vbkV2ZW50KGlmcmFtZUV2ZW50LmF1dGhFdmVudCk7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogaGFuZGxlZCA/IEdhcGlPdXRjb21lLkFDSyA6IEdhcGlPdXRjb21lLkVSUk9SIH07XG4gICAgICB9LFxuICAgICAgZ2FwaS5pZnJhbWVzLkNST1NTX09SSUdJTl9JRlJBTUVTX0ZJTFRFUlxuICAgICk7XG5cbiAgICB0aGlzLmV2ZW50TWFuYWdlcnNbYXV0aC5fa2V5KCldID0geyBtYW5hZ2VyIH07XG4gICAgdGhpcy5pZnJhbWVzW2F1dGguX2tleSgpXSA9IGlmcmFtZTtcbiAgICByZXR1cm4gbWFuYWdlcjtcbiAgfVxuXG4gIF9pc0lmcmFtZVdlYlN0b3JhZ2VTdXBwb3J0ZWQoXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGNiOiAoc3VwcG9ydGVkOiBib29sZWFuKSA9PiB1bmtub3duXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGlmcmFtZSA9IHRoaXMuaWZyYW1lc1thdXRoLl9rZXkoKV07XG4gICAgaWZyYW1lLnNlbmQ8Z2FwaS5pZnJhbWVzLk1lc3NhZ2UsIFdlYlN0b3JhZ2VTdXBwb3J0TWVzc2FnZT4oXG4gICAgICBXRUJfU1RPUkFHRV9TVVBQT1JUX0tFWSxcbiAgICAgIHsgdHlwZTogV0VCX1NUT1JBR0VfU1VQUE9SVF9LRVkgfSxcbiAgICAgIHJlc3VsdCA9PiB7XG4gICAgICAgIGNvbnN0IGlzU3VwcG9ydGVkID0gcmVzdWx0Py5bMF0/LltXRUJfU1RPUkFHRV9TVVBQT1JUX0tFWV07XG4gICAgICAgIGlmIChpc1N1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2IoISFpc1N1cHBvcnRlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBfZmFpbChhdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICAgIH0sXG4gICAgICBnYXBpLmlmcmFtZXMuQ1JPU1NfT1JJR0lOX0lGUkFNRVNfRklMVEVSXG4gICAgKTtcbiAgfVxuXG4gIF9vcmlnaW5WYWxpZGF0aW9uKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGtleSA9IGF1dGguX2tleSgpO1xuICAgIGlmICghdGhpcy5vcmlnaW5WYWxpZGF0aW9uUHJvbWlzZXNba2V5XSkge1xuICAgICAgdGhpcy5vcmlnaW5WYWxpZGF0aW9uUHJvbWlzZXNba2V5XSA9IF92YWxpZGF0ZU9yaWdpbihhdXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5vcmlnaW5WYWxpZGF0aW9uUHJvbWlzZXNba2V5XTtcbiAgfVxuXG4gIGdldCBfc2hvdWxkSW5pdFByb2FjdGl2ZWx5KCk6IGJvb2xlYW4ge1xuICAgIC8vIE1vYmlsZSBicm93c2VycyBhbmQgU2FmYXJpIG5lZWQgdG8gb3B0aW1pc3RpY2FsbHkgaW5pdGlhbGl6ZVxuICAgIHJldHVybiBfaXNNb2JpbGVCcm93c2VyKCkgfHwgX2lzU2FmYXJpKCkgfHwgX2lzSU9TKCk7XG4gIH1cblxuICBfY29tcGxldGVSZWRpcmVjdEZuID0gX2dldFJlZGlyZWN0UmVzdWx0O1xuXG4gIF9vdmVycmlkZVJlZGlyZWN0UmVzdWx0ID0gX292ZXJyaWRlUmVkaXJlY3RSZXN1bHQ7XG59XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFBvcHVwUmVkaXJlY3RSZXNvbHZlcn0gc3VpdGFibGUgZm9yIGJyb3dzZXJcbiAqIGJhc2VkIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyOiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPVxuICBCcm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEZhY3RvcklkLCBNdWx0aUZhY3RvckFzc2VydGlvbiB9IGZyb20gJy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBkZWJ1Z0ZhaWwgfSBmcm9tICcuLi9jb3JlL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwsIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUgfSBmcm9tICcuL21mYV9zZXNzaW9uJztcbmltcG9ydCB7IEZpbmFsaXplTWZhUmVzcG9uc2UgfSBmcm9tICcuLi9hcGkvYXV0aGVudGljYXRpb24vbWZhJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uL21vZGVsL2F1dGgnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIGltcGxlbWVudHMgTXVsdGlGYWN0b3JBc3NlcnRpb24ge1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IocmVhZG9ubHkgZmFjdG9ySWQ6IEZhY3RvcklkKSB7fVxuXG4gIF9wcm9jZXNzKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBzZXNzaW9uOiBNdWx0aUZhY3RvclNlc3Npb25JbXBsLFxuICAgIGRpc3BsYXlOYW1lPzogc3RyaW5nIHwgbnVsbFxuICApOiBQcm9taXNlPEZpbmFsaXplTWZhUmVzcG9uc2U+IHtcbiAgICBzd2l0Y2ggKHNlc3Npb24udHlwZSkge1xuICAgICAgY2FzZSBNdWx0aUZhY3RvclNlc3Npb25UeXBlLkVOUk9MTDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplRW5yb2xsKGF1dGgsIHNlc3Npb24uY3JlZGVudGlhbCwgZGlzcGxheU5hbWUpO1xuICAgICAgY2FzZSBNdWx0aUZhY3RvclNlc3Npb25UeXBlLlNJR05fSU46XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVNpZ25JbihhdXRoLCBzZXNzaW9uLmNyZWRlbnRpYWwpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgndW5leHBlY3RlZCBNdWx0aUZhY3RvclNlc3Npb25UeXBlJyk7XG4gICAgfVxuICB9XG5cbiAgYWJzdHJhY3QgX2ZpbmFsaXplRW5yb2xsKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBpZFRva2VuOiBzdHJpbmcsXG4gICAgZGlzcGxheU5hbWU/OiBzdHJpbmcgfCBudWxsXG4gICk6IFByb21pc2U8RmluYWxpemVNZmFSZXNwb25zZT47XG4gIGFic3RyYWN0IF9maW5hbGl6ZVNpZ25JbihcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgbWZhUGVuZGluZ0NyZWRlbnRpYWw6IHN0cmluZ1xuICApOiBQcm9taXNlPEZpbmFsaXplTWZhUmVzcG9uc2U+O1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7XG4gIEZhY3RvcklkLFxuICBQaG9uZU11bHRpRmFjdG9yQXNzZXJ0aW9uXG59IGZyb20gJy4uLy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCB9IGZyb20gJy4uLy4uLy4uL21mYS9tZmFfYXNzZXJ0aW9uJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgZmluYWxpemVFbnJvbGxQaG9uZU1mYSB9IGZyb20gJy4uLy4uLy4uL2FwaS9hY2NvdW50X21hbmFnZW1lbnQvbWZhJztcbmltcG9ydCB7IFBob25lQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuLi8uLi8uLi9jb3JlL2NyZWRlbnRpYWxzL3Bob25lJztcbmltcG9ydCB7XG4gIGZpbmFsaXplU2lnbkluUGhvbmVNZmEsXG4gIEZpbmFsaXplTWZhUmVzcG9uc2Vcbn0gZnJvbSAnLi4vLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL21mYSc7XG5cbi8qKlxuICoge0Bpbmhlcml0ZG9jIFBob25lTXVsdGlGYWN0b3JBc3NlcnRpb259XG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUGhvbmVNdWx0aUZhY3RvckFzc2VydGlvbkltcGxcbiAgZXh0ZW5kcyBNdWx0aUZhY3RvckFzc2VydGlvbkltcGxcbiAgaW1wbGVtZW50cyBQaG9uZU11bHRpRmFjdG9yQXNzZXJ0aW9uXG57XG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjcmVkZW50aWFsOiBQaG9uZUF1dGhDcmVkZW50aWFsKSB7XG4gICAgc3VwZXIoRmFjdG9ySWQuUEhPTkUpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21DcmVkZW50aWFsKFxuICAgIGNyZWRlbnRpYWw6IFBob25lQXV0aENyZWRlbnRpYWxcbiAgKTogUGhvbmVNdWx0aUZhY3RvckFzc2VydGlvbkltcGwge1xuICAgIHJldHVybiBuZXcgUGhvbmVNdWx0aUZhY3RvckFzc2VydGlvbkltcGwoY3JlZGVudGlhbCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9maW5hbGl6ZUVucm9sbChcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgaWRUb2tlbjogc3RyaW5nLFxuICAgIGRpc3BsYXlOYW1lPzogc3RyaW5nIHwgbnVsbFxuICApOiBQcm9taXNlPEZpbmFsaXplTWZhUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gZmluYWxpemVFbnJvbGxQaG9uZU1mYShhdXRoLCB7XG4gICAgICBpZFRva2VuLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICBwaG9uZVZlcmlmaWNhdGlvbkluZm86IHRoaXMuY3JlZGVudGlhbC5fbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZmluYWxpemVTaWduSW4oXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIG1mYVBlbmRpbmdDcmVkZW50aWFsOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxGaW5hbGl6ZU1mYVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGZpbmFsaXplU2lnbkluUGhvbmVNZmEoYXV0aCwge1xuICAgICAgbWZhUGVuZGluZ0NyZWRlbnRpYWwsXG4gICAgICBwaG9uZVZlcmlmaWNhdGlvbkluZm86IHRoaXMuY3JlZGVudGlhbC5fbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYSB7QGxpbmsgUGhvbmVNdWx0aUZhY3RvckFzc2VydGlvbn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUGhvbmVNdWx0aUZhY3RvckdlbmVyYXRvciB7XG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIHtAbGluayBQaG9uZU11bHRpRmFjdG9yQXNzZXJ0aW9ufSB0byBjb25maXJtIG93bmVyc2hpcCBvZiB0aGUgcGhvbmUgc2Vjb25kIGZhY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHBob25lQXV0aENyZWRlbnRpYWwgLSBBIGNyZWRlbnRpYWwgcHJvdmlkZWQgYnkge0BsaW5rIFBob25lQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWx9LlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBQaG9uZU11bHRpRmFjdG9yQXNzZXJ0aW9ufSB3aGljaCBjYW4gYmUgdXNlZCB3aXRoXG4gICAqIHtAbGluayBNdWx0aUZhY3RvclJlc29sdmVyLnJlc29sdmVTaWduSW59XG4gICAqL1xuICBzdGF0aWMgYXNzZXJ0aW9uKGNyZWRlbnRpYWw6IFBob25lQXV0aENyZWRlbnRpYWwpOiBQaG9uZU11bHRpRmFjdG9yQXNzZXJ0aW9uIHtcbiAgICByZXR1cm4gUGhvbmVNdWx0aUZhY3RvckFzc2VydGlvbkltcGwuX2Zyb21DcmVkZW50aWFsKGNyZWRlbnRpYWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBwaG9uZSBzZWNvbmQgZmFjdG9yOiBgcGhvbmVgLlxuICAgKi9cbiAgc3RhdGljIEZBQ1RPUl9JRCA9ICdwaG9uZSc7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHtcbiAgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uLFxuICBNdWx0aUZhY3RvclNlc3Npb24sXG4gIEZhY3RvcklkXG59IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7XG4gIGZpbmFsaXplRW5yb2xsVG90cE1mYSxcbiAgc3RhcnRFbnJvbGxUb3RwTWZhLFxuICBTdGFydFRvdHBNZmFFbnJvbGxtZW50UmVzcG9uc2UsXG4gIFRvdHBWZXJpZmljYXRpb25JbmZvXG59IGZyb20gJy4uLy4uL2FwaS9hY2NvdW50X21hbmFnZW1lbnQvbWZhJztcbmltcG9ydCB7XG4gIEZpbmFsaXplTWZhUmVzcG9uc2UsXG4gIGZpbmFsaXplU2lnbkluVG90cE1mYVxufSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vbWZhJztcbmltcG9ydCB7IE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCB9IGZyb20gJy4uLy4uL21mYS9tZmFfYXNzZXJ0aW9uJztcbmltcG9ydCB7IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwgfSBmcm9tICcuLi9tZmFfc2Vzc2lvbic7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yIHtcbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gdG8gY29uZmlybSBvd25lcnNoaXAgb2ZcbiAgICogdGhlIFRPVFAgKHRpbWUtYmFzZWQgb25lLXRpbWUgcGFzc3dvcmQpIHNlY29uZCBmYWN0b3IuXG4gICAqIFRoaXMgYXNzZXJ0aW9uIGlzIHVzZWQgdG8gY29tcGxldGUgZW5yb2xsbWVudCBpbiBUT1RQIHNlY29uZCBmYWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBzZWNyZXQgQSB7QGxpbmsgVG90cFNlY3JldH0gY29udGFpbmluZyB0aGUgc2hhcmVkIHNlY3JldCBrZXkgYW5kIG90aGVyIFRPVFAgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIG9uZVRpbWVQYXNzd29yZCBPbmUtdGltZSBwYXNzd29yZCBmcm9tIFRPVFAgQXBwLlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb259IHdoaWNoIGNhbiBiZSB1c2VkIHdpdGhcbiAgICoge0BsaW5rIE11bHRpRmFjdG9yVXNlci5lbnJvbGx9LlxuICAgKi9cbiAgc3RhdGljIGFzc2VydGlvbkZvckVucm9sbG1lbnQoXG4gICAgc2VjcmV0OiBUb3RwU2VjcmV0LFxuICAgIG9uZVRpbWVQYXNzd29yZDogc3RyaW5nXG4gICk6IFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbiB7XG4gICAgcmV0dXJuIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwuX2Zyb21TZWNyZXQoc2VjcmV0LCBvbmVUaW1lUGFzc3dvcmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gdG8gY29uZmlybSBvd25lcnNoaXAgb2YgdGhlIFRPVFAgc2Vjb25kIGZhY3Rvci5cbiAgICogVGhpcyBhc3NlcnRpb24gaXMgdXNlZCB0byBjb21wbGV0ZSBzaWduSW4gd2l0aCBUT1RQIGFzIHRoZSBzZWNvbmQgZmFjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gZW5yb2xsbWVudElkIGlkZW50aWZpZXMgdGhlIGVucm9sbGVkIFRPVFAgc2Vjb25kIGZhY3Rvci5cbiAgICogQHBhcmFtIG9uZVRpbWVQYXNzd29yZCBPbmUtdGltZSBwYXNzd29yZCBmcm9tIFRPVFAgQXBwLlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb259IHdoaWNoIGNhbiBiZSB1c2VkIHdpdGhcbiAgICoge0BsaW5rIE11bHRpRmFjdG9yUmVzb2x2ZXIucmVzb2x2ZVNpZ25Jbn0uXG4gICAqL1xuICBzdGF0aWMgYXNzZXJ0aW9uRm9yU2lnbkluKFxuICAgIGVucm9sbG1lbnRJZDogc3RyaW5nLFxuICAgIG9uZVRpbWVQYXNzd29yZDogc3RyaW5nXG4gICk6IFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbiB7XG4gICAgcmV0dXJuIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwuX2Zyb21FbnJvbGxtZW50SWQoXG4gICAgICBlbnJvbGxtZW50SWQsXG4gICAgICBvbmVUaW1lUGFzc3dvcmRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRvIHtAbGluayBUb3RwU2VjcmV0fSB3aGljaCBjb250YWlucyB0aGUgVE9UUCBzaGFyZWQgc2VjcmV0IGtleSBhbmQgb3RoZXIgcGFyYW1ldGVycy5cbiAgICogQ3JlYXRlcyBhIFRPVFAgc2VjcmV0IGFzIHBhcnQgb2YgZW5yb2xsaW5nIGEgVE9UUCBzZWNvbmQgZmFjdG9yLlxuICAgKiBVc2VkIGZvciBnZW5lcmF0aW5nIGEgUVIgY29kZSBVUkwgb3IgaW5wdXR0aW5nIGludG8gYSBUT1RQIGFwcC5cbiAgICogVGhpcyBtZXRob2QgdXNlcyB0aGUgYXV0aCBpbnN0YW5jZSBjb3JyZXNwb25kaW5nIHRvIHRoZSB1c2VyIGluIHRoZSBtdWx0aUZhY3RvclNlc3Npb24uXG4gICAqXG4gICAqIEBwYXJhbSBzZXNzaW9uIFRoZSB7QGxpbmsgTXVsdGlGYWN0b3JTZXNzaW9ufSB0aGF0IHRoZSB1c2VyIGlzIHBhcnQgb2YuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0byB7QGxpbmsgVG90cFNlY3JldH0uXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVTZWNyZXQoXG4gICAgc2Vzc2lvbjogTXVsdGlGYWN0b3JTZXNzaW9uXG4gICk6IFByb21pc2U8VG90cFNlY3JldD4ge1xuICAgIGNvbnN0IG1mYVNlc3Npb24gPSBzZXNzaW9uIGFzIE11bHRpRmFjdG9yU2Vzc2lvbkltcGw7XG4gICAgX2Fzc2VydChcbiAgICAgIHR5cGVvZiBtZmFTZXNzaW9uLmF1dGggIT09ICd1bmRlZmluZWQnLFxuICAgICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUlxuICAgICk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdGFydEVucm9sbFRvdHBNZmEobWZhU2Vzc2lvbi5hdXRoLCB7XG4gICAgICBpZFRva2VuOiBtZmFTZXNzaW9uLmNyZWRlbnRpYWwsXG4gICAgICB0b3RwRW5yb2xsbWVudEluZm86IHt9XG4gICAgfSk7XG4gICAgcmV0dXJuIFRvdHBTZWNyZXQuX2Zyb21TdGFydFRvdHBNZmFFbnJvbGxtZW50UmVzcG9uc2UoXG4gICAgICByZXNwb25zZSxcbiAgICAgIG1mYVNlc3Npb24uYXV0aFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIgb2YgdGhlIFRPVFAgc2Vjb25kIGZhY3RvcjogYHRvdHBgLlxuICAgKi9cbiAgc3RhdGljIEZBQ1RPUl9JRDogJ3RvdHAnID0gRmFjdG9ySWQuVE9UUDtcbn1cblxuZXhwb3J0IGNsYXNzIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGxcbiAgZXh0ZW5kcyBNdWx0aUZhY3RvckFzc2VydGlvbkltcGxcbiAgaW1wbGVtZW50cyBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25cbntcbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgb3RwOiBzdHJpbmcsXG4gICAgcmVhZG9ubHkgZW5yb2xsbWVudElkPzogc3RyaW5nLFxuICAgIHJlYWRvbmx5IHNlY3JldD86IFRvdHBTZWNyZXRcbiAgKSB7XG4gICAgc3VwZXIoRmFjdG9ySWQuVE9UUCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZnJvbVNlY3JldChcbiAgICBzZWNyZXQ6IFRvdHBTZWNyZXQsXG4gICAgb3RwOiBzdHJpbmdcbiAgKTogVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCB7XG4gICAgcmV0dXJuIG5ldyBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsKG90cCwgdW5kZWZpbmVkLCBzZWNyZXQpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21FbnJvbGxtZW50SWQoXG4gICAgZW5yb2xsbWVudElkOiBzdHJpbmcsXG4gICAgb3RwOiBzdHJpbmdcbiAgKTogVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCB7XG4gICAgcmV0dXJuIG5ldyBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsKG90cCwgZW5yb2xsbWVudElkKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgX2ZpbmFsaXplRW5yb2xsKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBpZFRva2VuOiBzdHJpbmcsXG4gICAgZGlzcGxheU5hbWU/OiBzdHJpbmcgfCBudWxsXG4gICk6IFByb21pc2U8RmluYWxpemVNZmFSZXNwb25zZT4ge1xuICAgIF9hc3NlcnQoXG4gICAgICB0eXBlb2YgdGhpcy5zZWNyZXQgIT09ICd1bmRlZmluZWQnLFxuICAgICAgYXV0aCxcbiAgICAgIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1JcbiAgICApO1xuICAgIHJldHVybiBmaW5hbGl6ZUVucm9sbFRvdHBNZmEoYXV0aCwge1xuICAgICAgaWRUb2tlbixcbiAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgdG90cFZlcmlmaWNhdGlvbkluZm86IHRoaXMuc2VjcmV0Ll9tYWtlVG90cFZlcmlmaWNhdGlvbkluZm8odGhpcy5vdHApXG4gICAgfSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIF9maW5hbGl6ZVNpZ25JbihcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgbWZhUGVuZGluZ0NyZWRlbnRpYWw6IHN0cmluZ1xuICApOiBQcm9taXNlPEZpbmFsaXplTWZhUmVzcG9uc2U+IHtcbiAgICBfYXNzZXJ0KFxuICAgICAgdGhpcy5lbnJvbGxtZW50SWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm90cCAhPT0gdW5kZWZpbmVkLFxuICAgICAgYXV0aCxcbiAgICAgIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1JcbiAgICApO1xuICAgIGNvbnN0IHRvdHBWZXJpZmljYXRpb25JbmZvID0geyB2ZXJpZmljYXRpb25Db2RlOiB0aGlzLm90cCB9O1xuICAgIHJldHVybiBmaW5hbGl6ZVNpZ25JblRvdHBNZmEoYXV0aCwge1xuICAgICAgbWZhUGVuZGluZ0NyZWRlbnRpYWwsXG4gICAgICBtZmFFbnJvbGxtZW50SWQ6IHRoaXMuZW5yb2xsbWVudElkLFxuICAgICAgdG90cFZlcmlmaWNhdGlvbkluZm9cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0uXG4gKlxuICogU3RvcmVzIHRoZSBzaGFyZWQgc2VjcmV0IGtleSBhbmQgb3RoZXIgcGFyYW1ldGVycyB0byBnZW5lcmF0ZSB0aW1lLWJhc2VkIE9UUHMuXG4gKiBJbXBsZW1lbnRzIG1ldGhvZHMgdG8gcmV0cmlldmUgdGhlIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBnZW5lcmF0ZSBhIFFSIGNvZGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVG90cFNlY3JldCB7XG4gIC8qKlxuICAgKiBTaGFyZWQgc2VjcmV0IGtleS9zZWVkIHVzZWQgZm9yIGVucm9sbGluZyBpbiBUT1RQIE1GQSBhbmQgZ2VuZXJhdGluZyBPVFBzLlxuICAgKi9cbiAgcmVhZG9ubHkgc2VjcmV0S2V5OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBIYXNoaW5nIGFsZ29yaXRobSB1c2VkLlxuICAgKi9cbiAgcmVhZG9ubHkgaGFzaGluZ0FsZ29yaXRobTogc3RyaW5nO1xuICAvKipcbiAgICogTGVuZ3RoIG9mIHRoZSBvbmUtdGltZSBwYXNzd29yZHMgdG8gYmUgZ2VuZXJhdGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgY29kZUxlbmd0aDogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIGludGVydmFsIChpbiBzZWNvbmRzKSB3aGVuIHRoZSBPVFAgY29kZXMgc2hvdWxkIGNoYW5nZS5cbiAgICovXG4gIHJlYWRvbmx5IGNvZGVJbnRlcnZhbFNlY29uZHM6IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoZSB0aW1lc3RhbXAgKFVUQyBzdHJpbmcpIGJ5IHdoaWNoIFRPVFAgZW5yb2xsbWVudCBzaG91bGQgYmUgY29tcGxldGVkLlxuICAgKi9cbiAgLy8gVGhpcyBjYW4gYmUgdXNlZCBieSBjYWxsZXJzIHRvIHNob3cgYSBjb3VudGRvd24gb2Ygd2hlbiB0byBlbnRlciBPVFAgY29kZSBieS5cbiAgcmVhZG9ubHkgZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZTogc3RyaW5nO1xuXG4gIC8vIFRoZSBwdWJsaWMgbWVtYmVycyBhcmUgZGVjbGFyZWQgb3V0c2lkZSB0aGUgY29uc3RydWN0b3Igc28gdGhlIGRvY3MgY2FuIGJlIGdlbmVyYXRlZC5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBzZWNyZXRLZXk6IHN0cmluZyxcbiAgICBoYXNoaW5nQWxnb3JpdGhtOiBzdHJpbmcsXG4gICAgY29kZUxlbmd0aDogbnVtYmVyLFxuICAgIGNvZGVJbnRlcnZhbFNlY29uZHM6IG51bWJlcixcbiAgICBlbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZXNzaW9uSW5mbzogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXV0aDogQXV0aEludGVybmFsXG4gICkge1xuICAgIHRoaXMuc2VjcmV0S2V5ID0gc2VjcmV0S2V5O1xuICAgIHRoaXMuaGFzaGluZ0FsZ29yaXRobSA9IGhhc2hpbmdBbGdvcml0aG07XG4gICAgdGhpcy5jb2RlTGVuZ3RoID0gY29kZUxlbmd0aDtcbiAgICB0aGlzLmNvZGVJbnRlcnZhbFNlY29uZHMgPSBjb2RlSW50ZXJ2YWxTZWNvbmRzO1xuICAgIHRoaXMuZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZSA9IGVucm9sbG1lbnRDb21wbGV0aW9uRGVhZGxpbmU7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZnJvbVN0YXJ0VG90cE1mYUVucm9sbG1lbnRSZXNwb25zZShcbiAgICByZXNwb25zZTogU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlLFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbFxuICApOiBUb3RwU2VjcmV0IHtcbiAgICByZXR1cm4gbmV3IFRvdHBTZWNyZXQoXG4gICAgICByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uc2hhcmVkU2VjcmV0S2V5LFxuICAgICAgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLmhhc2hpbmdBbGdvcml0aG0sXG4gICAgICByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8udmVyaWZpY2F0aW9uQ29kZUxlbmd0aCxcbiAgICAgIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5wZXJpb2RTZWMsXG4gICAgICBuZXcgRGF0ZShyZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uZmluYWxpemVFbnJvbGxtZW50VGltZSkudG9VVENTdHJpbmcoKSxcbiAgICAgIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5zZXNzaW9uSW5mbyxcbiAgICAgIGF1dGhcbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfbWFrZVRvdHBWZXJpZmljYXRpb25JbmZvKG90cDogc3RyaW5nKTogVG90cFZlcmlmaWNhdGlvbkluZm8ge1xuICAgIHJldHVybiB7IHNlc3Npb25JbmZvOiB0aGlzLnNlc3Npb25JbmZvLCB2ZXJpZmljYXRpb25Db2RlOiBvdHAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgUVIgY29kZSBVUkwgYXMgZGVzY3JpYmVkIGluXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvZ29vZ2xlLWF1dGhlbnRpY2F0b3Ivd2lraS9LZXktVXJpLUZvcm1hdFxuICAgKiBUaGlzIGNhbiBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgYXMgYSBRUiBjb2RlIHRvIGJlIHNjYW5uZWQgaW50byBhIFRPVFAgYXBwIGxpa2UgR29vZ2xlIEF1dGhlbnRpY2F0b3IuXG4gICAqIElmIHRoZSBvcHRpb25hbCBwYXJhbWV0ZXJzIGFyZSB1bnNwZWNpZmllZCwgYW4gYWNjb3VudE5hbWUgb2YgPHVzZXJFbWFpbD4gYW5kIGlzc3VlciBvZiA8ZmlyZWJhc2VBcHBOYW1lPiBhcmUgdXNlZC5cbiAgICpcbiAgICogQHBhcmFtIGFjY291bnROYW1lIHRoZSBuYW1lIG9mIHRoZSBhY2NvdW50L2FwcCBhbG9uZyB3aXRoIGEgdXNlciBpZGVudGlmaWVyLlxuICAgKiBAcGFyYW0gaXNzdWVyIGlzc3VlciBvZiB0aGUgVE9UUCAobGlrZWx5IHRoZSBhcHAgbmFtZSkuXG4gICAqIEByZXR1cm5zIEEgUVIgY29kZSBVUkwgc3RyaW5nLlxuICAgKi9cbiAgZ2VuZXJhdGVRckNvZGVVcmwoYWNjb3VudE5hbWU/OiBzdHJpbmcsIGlzc3Vlcj86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IHVzZURlZmF1bHRzID0gZmFsc2U7XG4gICAgaWYgKF9pc0VtcHR5U3RyaW5nKGFjY291bnROYW1lKSB8fCBfaXNFbXB0eVN0cmluZyhpc3N1ZXIpKSB7XG4gICAgICB1c2VEZWZhdWx0cyA9IHRydWU7XG4gICAgfVxuICAgIGlmICh1c2VEZWZhdWx0cykge1xuICAgICAgaWYgKF9pc0VtcHR5U3RyaW5nKGFjY291bnROYW1lKSkge1xuICAgICAgICBhY2NvdW50TmFtZSA9IHRoaXMuYXV0aC5jdXJyZW50VXNlcj8uZW1haWwgfHwgJ3Vua25vd251c2VyJztcbiAgICAgIH1cbiAgICAgIGlmIChfaXNFbXB0eVN0cmluZyhpc3N1ZXIpKSB7XG4gICAgICAgIGlzc3VlciA9IHRoaXMuYXV0aC5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYG90cGF1dGg6Ly90b3RwLyR7aXNzdWVyfToke2FjY291bnROYW1lfT9zZWNyZXQ9JHt0aGlzLnNlY3JldEtleX0maXNzdWVyPSR7aXNzdWVyfSZhbGdvcml0aG09JHt0aGlzLmhhc2hpbmdBbGdvcml0aG19JmRpZ2l0cz0ke3RoaXMuY29kZUxlbmd0aH1gO1xuICB9XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIF9pc0VtcHR5U3RyaW5nKGlucHV0Pzogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnIHx8IGlucHV0Py5sZW5ndGggPT09IDA7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBVbnN1YnNjcmliZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IEZpcmViYXNlQXV0aEludGVybmFsIH0gZnJvbSAnQGZpcmViYXNlL2F1dGgtaW50ZXJvcC10eXBlcyc7XG5cbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmludGVyZmFjZSBUb2tlbkxpc3RlbmVyIHtcbiAgKHRvazogc3RyaW5nIHwgbnVsbCk6IHVua25vd247XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoSW50ZXJvcCBpbXBsZW1lbnRzIEZpcmViYXNlQXV0aEludGVybmFsIHtcbiAgcHJpdmF0ZSByZWFkb25seSBpbnRlcm5hbExpc3RlbmVyczogTWFwPFRva2VuTGlzdGVuZXIsIFVuc3Vic2NyaWJlPiA9XG4gICAgbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXV0aDogQXV0aEludGVybmFsKSB7fVxuXG4gIGdldFVpZCgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XG4gICAgcmV0dXJuIHRoaXMuYXV0aC5jdXJyZW50VXNlcj8udWlkIHx8IG51bGw7XG4gIH1cblxuICBhc3luYyBnZXRUb2tlbihcbiAgICBmb3JjZVJlZnJlc2g/OiBib29sZWFuXG4gICk6IFByb21pc2U8eyBhY2Nlc3NUb2tlbjogc3RyaW5nIH0gfCBudWxsPiB7XG4gICAgdGhpcy5hc3NlcnRBdXRoQ29uZmlndXJlZCgpO1xuICAgIGF3YWl0IHRoaXMuYXV0aC5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgIGlmICghdGhpcy5hdXRoLmN1cnJlbnRVc2VyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMuYXV0aC5jdXJyZW50VXNlci5nZXRJZFRva2VuKGZvcmNlUmVmcmVzaCk7XG4gICAgcmV0dXJuIHsgYWNjZXNzVG9rZW4gfTtcbiAgfVxuXG4gIGFkZEF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyOiBUb2tlbkxpc3RlbmVyKTogdm9pZCB7XG4gICAgdGhpcy5hc3NlcnRBdXRoQ29uZmlndXJlZCgpO1xuICAgIGlmICh0aGlzLmludGVybmFsTGlzdGVuZXJzLmhhcyhsaXN0ZW5lcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuYXV0aC5vbklkVG9rZW5DaGFuZ2VkKHVzZXIgPT4ge1xuICAgICAgbGlzdGVuZXIoXG4gICAgICAgICh1c2VyIGFzIFVzZXJJbnRlcm5hbCB8IG51bGwpPy5zdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW4gfHwgbnVsbFxuICAgICAgKTtcbiAgICB9KTtcbiAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzLnNldChsaXN0ZW5lciwgdW5zdWJzY3JpYmUpO1xuICAgIHRoaXMudXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpO1xuICB9XG5cbiAgcmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXI6IFRva2VuTGlzdGVuZXIpOiB2b2lkIHtcbiAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLmludGVybmFsTGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XG4gICAgaWYgKCF1bnN1YnNjcmliZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB1bnN1YnNjcmliZSgpO1xuICAgIHRoaXMudXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3NlcnRBdXRoQ29uZmlndXJlZCgpOiB2b2lkIHtcbiAgICBfYXNzZXJ0KFxuICAgICAgdGhpcy5hdXRoLl9pbml0aWFsaXphdGlvblByb21pc2UsXG4gICAgICBBdXRoRXJyb3JDb2RlLkRFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVByb2FjdGl2ZVJlZnJlc2goKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuc2l6ZSA+IDApIHtcbiAgICAgIHRoaXMuYXV0aC5fc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXV0aC5fc3RvcFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IF9yZWdpc3RlckNvbXBvbmVudCwgcmVnaXN0ZXJWZXJzaW9uIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIENvbXBvbmVudFR5cGUsXG4gIEluc3RhbnRpYXRpb25Nb2RlXG59IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBuYW1lLCB2ZXJzaW9uIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZS5qc29uJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IF9nZXRDbGllbnRWZXJzaW9uLCBDbGllbnRQbGF0Zm9ybSB9IGZyb20gJy4uL3V0aWwvdmVyc2lvbic7XG5pbXBvcnQgeyBfY2FzdEF1dGgsIEF1dGhJbXBsLCBEZWZhdWx0Q29uZmlnIH0gZnJvbSAnLi9hdXRoX2ltcGwnO1xuaW1wb3J0IHsgQXV0aEludGVyb3AgfSBmcm9tICcuL2ZpcmViYXNlX2ludGVybmFsJztcbmltcG9ydCB7IENvbmZpZ0ludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBEZXBlbmRlbmNpZXMgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgX2luaXRpYWxpemVBdXRoSW5zdGFuY2UgfSBmcm9tICcuL2luaXRpYWxpemUnO1xuXG5leHBvcnQgY29uc3QgZW51bSBfQ29tcG9uZW50TmFtZSB7XG4gIEFVVEggPSAnYXV0aCcsXG4gIEFVVEhfSU5URVJOQUwgPSAnYXV0aC1pbnRlcm5hbCdcbn1cblxuZnVuY3Rpb24gZ2V0VmVyc2lvbkZvclBsYXRmb3JtKFxuICBjbGllbnRQbGF0Zm9ybTogQ2xpZW50UGxhdGZvcm1cbik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHN3aXRjaCAoY2xpZW50UGxhdGZvcm0pIHtcbiAgICBjYXNlIENsaWVudFBsYXRmb3JtLk5PREU6XG4gICAgICByZXR1cm4gJ25vZGUnO1xuICAgIGNhc2UgQ2xpZW50UGxhdGZvcm0uUkVBQ1RfTkFUSVZFOlxuICAgICAgcmV0dXJuICdybic7XG4gICAgY2FzZSBDbGllbnRQbGF0Zm9ybS5XT1JLRVI6XG4gICAgICByZXR1cm4gJ3dlYndvcmtlcic7XG4gICAgY2FzZSBDbGllbnRQbGF0Zm9ybS5DT1JET1ZBOlxuICAgICAgcmV0dXJuICdjb3Jkb3ZhJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJBdXRoKGNsaWVudFBsYXRmb3JtOiBDbGllbnRQbGF0Zm9ybSk6IHZvaWQge1xuICBfcmVnaXN0ZXJDb21wb25lbnQoXG4gICAgbmV3IENvbXBvbmVudChcbiAgICAgIF9Db21wb25lbnROYW1lLkFVVEgsXG4gICAgICAoY29udGFpbmVyLCB7IG9wdGlvbnM6IGRlcHMgfTogeyBvcHRpb25zPzogRGVwZW5kZW5jaWVzIH0pID0+IHtcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKSE7XG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlciA9XG4gICAgICAgICAgY29udGFpbmVyLmdldFByb3ZpZGVyPCdoZWFydGJlYXQnPignaGVhcnRiZWF0Jyk7XG4gICAgICAgIGNvbnN0IGFwcENoZWNrU2VydmljZVByb3ZpZGVyID1cbiAgICAgICAgICBjb250YWluZXIuZ2V0UHJvdmlkZXI8J2FwcC1jaGVjay1pbnRlcm5hbCc+KCdhcHAtY2hlY2staW50ZXJuYWwnKTtcbiAgICAgICAgY29uc3QgeyBhcGlLZXksIGF1dGhEb21haW4gfSA9IGFwcC5vcHRpb25zO1xuXG4gICAgICAgIF9hc3NlcnQoXG4gICAgICAgICAgYXBpS2V5ICYmICFhcGlLZXkuaW5jbHVkZXMoJzonKSxcbiAgICAgICAgICBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBJX0tFWSxcbiAgICAgICAgICB7IGFwcE5hbWU6IGFwcC5uYW1lIH1cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBjb25maWc6IENvbmZpZ0ludGVybmFsID0ge1xuICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICBhdXRoRG9tYWluLFxuICAgICAgICAgIGNsaWVudFBsYXRmb3JtLFxuICAgICAgICAgIGFwaUhvc3Q6IERlZmF1bHRDb25maWcuQVBJX0hPU1QsXG4gICAgICAgICAgdG9rZW5BcGlIb3N0OiBEZWZhdWx0Q29uZmlnLlRPS0VOX0FQSV9IT1NULFxuICAgICAgICAgIGFwaVNjaGVtZTogRGVmYXVsdENvbmZpZy5BUElfU0NIRU1FLFxuICAgICAgICAgIHNka0NsaWVudFZlcnNpb246IF9nZXRDbGllbnRWZXJzaW9uKGNsaWVudFBsYXRmb3JtKVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGF1dGhJbnN0YW5jZSA9IG5ldyBBdXRoSW1wbChcbiAgICAgICAgICBhcHAsXG4gICAgICAgICAgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyLFxuICAgICAgICAgIGFwcENoZWNrU2VydmljZVByb3ZpZGVyLFxuICAgICAgICAgIGNvbmZpZ1xuICAgICAgICApO1xuICAgICAgICBfaW5pdGlhbGl6ZUF1dGhJbnN0YW5jZShhdXRoSW5zdGFuY2UsIGRlcHMpO1xuXG4gICAgICAgIHJldHVybiBhdXRoSW5zdGFuY2U7XG4gICAgICB9LFxuICAgICAgQ29tcG9uZW50VHlwZS5QVUJMSUNcbiAgICApXG4gICAgICAvKipcbiAgICAgICAqIEF1dGggY2FuIG9ubHkgYmUgaW5pdGlhbGl6ZWQgYnkgZXhwbGljaXRseSBjYWxsaW5nIGdldEF1dGgoKSBvciBpbml0aWFsaXplQXV0aCgpXG4gICAgICAgKiBGb3Igd2h5IHdlIGRvIHRoaXMsIFNlZSBnby9maXJlYmFzZS1uZXh0LWF1dGgtaW5pdFxuICAgICAgICovXG4gICAgICAuc2V0SW5zdGFudGlhdGlvbk1vZGUoSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVQpXG4gICAgICAvKipcbiAgICAgICAqIEJlY2F1c2UgYWxsIGZpcmViYXNlIHByb2R1Y3RzIHRoYXQgZGVwZW5kIG9uIGF1dGggZGVwZW5kIG9uIGF1dGgtaW50ZXJuYWwgZGlyZWN0bHksXG4gICAgICAgKiB3ZSBuZWVkIHRvIGluaXRpYWxpemUgYXV0aC1pbnRlcm5hbCBhZnRlciBhdXRoIGlzIGluaXRpYWxpemVkIHRvIG1ha2UgaXQgYXZhaWxhYmxlIHRvIG90aGVyIGZpcmViYXNlIHByb2R1Y3RzLlxuICAgICAgICovXG4gICAgICAuc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soXG4gICAgICAgIChjb250YWluZXIsIF9pbnN0YW5jZUlkZW50aWZpZXIsIF9pbnN0YW5jZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGF1dGhJbnRlcm5hbFByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKFxuICAgICAgICAgICAgX0NvbXBvbmVudE5hbWUuQVVUSF9JTlRFUk5BTFxuICAgICAgICAgICk7XG4gICAgICAgICAgYXV0aEludGVybmFsUHJvdmlkZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICApXG4gICk7XG5cbiAgX3JlZ2lzdGVyQ29tcG9uZW50KFxuICAgIG5ldyBDb21wb25lbnQoXG4gICAgICBfQ29tcG9uZW50TmFtZS5BVVRIX0lOVEVSTkFMLFxuICAgICAgY29udGFpbmVyID0+IHtcbiAgICAgICAgY29uc3QgYXV0aCA9IF9jYXN0QXV0aChcbiAgICAgICAgICBjb250YWluZXIuZ2V0UHJvdmlkZXIoX0NvbXBvbmVudE5hbWUuQVVUSCkuZ2V0SW1tZWRpYXRlKCkhXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAoYXV0aCA9PiBuZXcgQXV0aEludGVyb3AoYXV0aCkpKGF1dGgpO1xuICAgICAgfSxcbiAgICAgIENvbXBvbmVudFR5cGUuUFJJVkFURVxuICAgICkuc2V0SW5zdGFudGlhdGlvbk1vZGUoSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVQpXG4gICk7XG5cbiAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sIGdldFZlcnNpb25Gb3JQbGF0Zm9ybShjbGllbnRQbGF0Zm9ybSkpO1xuICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxuICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ19fQlVJTERfVEFSR0VUX18nKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZpcmViYXNlQXBwLCBnZXRBcHAsIF9nZXRQcm92aWRlciB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuXG5pbXBvcnQge1xuICBpbml0aWFsaXplQXV0aCxcbiAgYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZCxcbiAgb25JZFRva2VuQ2hhbmdlZCxcbiAgY29ubmVjdEF1dGhFbXVsYXRvclxufSBmcm9tICcuLic7XG5pbXBvcnQgeyByZWdpc3RlckF1dGggfSBmcm9tICcuLi9jb3JlL2F1dGgvcmVnaXN0ZXInO1xuaW1wb3J0IHsgQ2xpZW50UGxhdGZvcm0gfSBmcm9tICcuLi9jb3JlL3V0aWwvdmVyc2lvbic7XG5pbXBvcnQgeyBicm93c2VyTG9jYWxQZXJzaXN0ZW5jZSB9IGZyb20gJy4vcGVyc2lzdGVuY2UvbG9jYWxfc3RvcmFnZSc7XG5pbXBvcnQgeyBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlIH0gZnJvbSAnLi9wZXJzaXN0ZW5jZS9zZXNzaW9uX3N0b3JhZ2UnO1xuaW1wb3J0IHsgaW5kZXhlZERCTG9jYWxQZXJzaXN0ZW5jZSB9IGZyb20gJy4vcGVyc2lzdGVuY2UvaW5kZXhlZF9kYic7XG5pbXBvcnQgeyBicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyIH0gZnJvbSAnLi9wb3B1cF9yZWRpcmVjdCc7XG5pbXBvcnQgeyBBdXRoLCBVc2VyIH0gZnJvbSAnLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IGdldERlZmF1bHRFbXVsYXRvckhvc3QsIGdldEV4cGVyaW1lbnRhbFNldHRpbmcgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmNvbnN0IERFRkFVTFRfSURfVE9LRU5fTUFYX0FHRSA9IDUgKiA2MDtcbmNvbnN0IGF1dGhJZFRva2VuTWF4QWdlID1cbiAgZ2V0RXhwZXJpbWVudGFsU2V0dGluZygnYXV0aElkVG9rZW5NYXhBZ2UnKSB8fCBERUZBVUxUX0lEX1RPS0VOX01BWF9BR0U7XG5cbmxldCBsYXN0UG9zdGVkSWRUb2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCA9IG51bGw7XG5cbmNvbnN0IG1pbnRDb29raWVGYWN0b3J5ID0gKHVybDogc3RyaW5nKSA9PiBhc3luYyAodXNlcjogVXNlciB8IG51bGwpID0+IHtcbiAgY29uc3QgaWRUb2tlblJlc3VsdCA9IHVzZXIgJiYgKGF3YWl0IHVzZXIuZ2V0SWRUb2tlblJlc3VsdCgpKTtcbiAgY29uc3QgaWRUb2tlbkFnZSA9XG4gICAgaWRUb2tlblJlc3VsdCAmJlxuICAgIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIERhdGUucGFyc2UoaWRUb2tlblJlc3VsdC5pc3N1ZWRBdFRpbWUpKSAvIDFfMDAwO1xuICBpZiAoaWRUb2tlbkFnZSAmJiBpZFRva2VuQWdlID4gYXV0aElkVG9rZW5NYXhBZ2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU3BlY2lmaWNhbGx5IHRyaXAgbnVsbCA9PiB1bmRlZmluZWQgd2hlbiBsb2dnZWQgb3V0LCB0byBkZWxldGUgYW55IGV4aXN0aW5nIGNvb2tpZVxuICBjb25zdCBpZFRva2VuID0gaWRUb2tlblJlc3VsdD8udG9rZW47XG4gIGlmIChsYXN0UG9zdGVkSWRUb2tlbiA9PT0gaWRUb2tlbikge1xuICAgIHJldHVybjtcbiAgfVxuICBsYXN0UG9zdGVkSWRUb2tlbiA9IGlkVG9rZW47XG4gIGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogaWRUb2tlbiA/ICdQT1NUJyA6ICdERUxFVEUnLFxuICAgIGhlYWRlcnM6IGlkVG9rZW5cbiAgICAgID8ge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2lkVG9rZW59YFxuICAgICAgICB9XG4gICAgICA6IHt9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBBdXRoIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9LlxuICogSWYgbm8gaW5zdGFuY2UgZXhpc3RzLCBpbml0aWFsaXplcyBhbiBBdXRoIGluc3RhbmNlIHdpdGggcGxhdGZvcm0tc3BlY2lmaWMgZGVmYXVsdCBkZXBlbmRlbmNpZXMuXG4gKlxuICogQHBhcmFtIGFwcCAtIFRoZSBGaXJlYmFzZSBBcHAuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXV0aChhcHA6IEZpcmViYXNlQXBwID0gZ2V0QXBwKCkpOiBBdXRoIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnYXV0aCcpO1xuXG4gIGlmIChwcm92aWRlci5pc0luaXRpYWxpemVkKCkpIHtcbiAgICByZXR1cm4gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKCk7XG4gIH1cblxuICBjb25zdCBhdXRoID0gaW5pdGlhbGl6ZUF1dGgoYXBwLCB7XG4gICAgcG9wdXBSZWRpcmVjdFJlc29sdmVyOiBicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyLFxuICAgIHBlcnNpc3RlbmNlOiBbXG4gICAgICBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlLFxuICAgICAgYnJvd3NlckxvY2FsUGVyc2lzdGVuY2UsXG4gICAgICBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlXG4gICAgXVxuICB9KTtcblxuICBjb25zdCBhdXRoVG9rZW5TeW5jVXJsID0gZ2V0RXhwZXJpbWVudGFsU2V0dGluZygnYXV0aFRva2VuU3luY1VSTCcpO1xuICBpZiAoYXV0aFRva2VuU3luY1VybCkge1xuICAgIGNvbnN0IG1pbnRDb29raWUgPSBtaW50Q29va2llRmFjdG9yeShhdXRoVG9rZW5TeW5jVXJsKTtcbiAgICBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkKGF1dGgsIG1pbnRDb29raWUsICgpID0+XG4gICAgICBtaW50Q29va2llKGF1dGguY3VycmVudFVzZXIpXG4gICAgKTtcbiAgICBvbklkVG9rZW5DaGFuZ2VkKGF1dGgsIHVzZXIgPT4gbWludENvb2tpZSh1c2VyKSk7XG4gIH1cblxuICBjb25zdCBhdXRoRW11bGF0b3JIb3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCgnYXV0aCcpO1xuICBpZiAoYXV0aEVtdWxhdG9ySG9zdCkge1xuICAgIGNvbm5lY3RBdXRoRW11bGF0b3IoYXV0aCwgYGh0dHA6Ly8ke2F1dGhFbXVsYXRvckhvc3R9YCk7XG4gIH1cblxuICByZXR1cm4gYXV0aDtcbn1cblxucmVnaXN0ZXJBdXRoKENsaWVudFBsYXRmb3JtLkJST1dTRVIpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgbmFtZSwgdmVyc2lvbiB9IGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5cbnJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnYXBwJyk7XG5leHBvcnQgKiBmcm9tICdAZmlyZWJhc2UvYXBwJztcbiIsImltcG9ydCB7RHJvcGJveCwgRHJvcGJveEF1dGh9IGZyb20gJ2Ryb3Bib3gnXG5pbXBvcnQge1V0aWxzfSBmcm9tICdzdHVmZidcbmltcG9ydCB7dHlwZSBBdXRoLCB0eXBlIFVzZXIsIGdldEF1dGgsIHNpZ25JbldpdGhDdXN0b21Ub2tlbn0gZnJvbSAnZmlyZWJhc2UvYXV0aCdcbmltcG9ydCB7dHlwZSBGaXJlYmFzZUFwcCwgaW5pdGlhbGl6ZUFwcH0gZnJvbSAnZmlyZWJhc2UvYXBwJ1xuXG4vLyBjb25zdCBkYiA9IHJlcXVpcmUoJ2Ryb3Bib3gnKVxuY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XG5cdGFwaUtleTogJ0FJemFTeUR3dGNQalFNajNKQXk5ZDd3d2ppYjE5ZXl3dkdmZFYzQScsXG5cdGF1dGhEb21haW46ICdzcGx1bmdlLTM5MDExMC5maXJlYmFzZWFwcC5jb20nLFxuXHRwcm9qZWN0SWQ6ICdzcGx1bmdlLTM5MDExMCcsXG5cdHN0b3JhZ2VCdWNrZXQ6ICdzcGx1bmdlLTM5MDExMC5hcHBzcG90LmNvbScsXG5cdG1lc3NhZ2luZ1NlbmRlcklkOiAnMTA0MTU0MjczNjg5NScsXG5cdGFwcElkOiAnMToxMDQxNTQyNzM2ODk1OndlYjo2NjNiOWM1YWIzOGY4Mjk1ZWI5NWNhJyxcbn1cblxubGV0IGZpcmViYXNlX2FwcDogRmlyZWJhc2VBcHBcbmxldCBmaXJlYmFzZV9hdXRoOiBBdXRoXG5mdW5jdGlvbiBnZXRDdXJyZW50VXNlcihhdXRoOiBBdXRoKTogUHJvbWlzZTxVc2VyIHwgbnVsbD4ge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGNvbnN0IHVuc3Vic2NyaWJlID0gYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZWQoKHVzZXIpID0+IHtcblx0XHRcdHVuc3Vic2NyaWJlKClcblx0XHRcdHJlc29sdmUodXNlcilcblx0XHR9LCByZWplY3QpXG5cdH0pXG59XG5cbmV4cG9ydCBjbGFzcyBEcm9wYm94QXV0aGVyIHtcblx0Q0xJRU5UX0lEOiBzdHJpbmcgPSAnanhweWh2MmNxb3p1YjBjJ1xuXHRSRURJUkVDVF9VUkk6IHN0cmluZyA9ICdodHRwOi8vbG9jYWxob3N0OjgwODAvJ1xuXHQvLyBAdHMtaWdub3JlXG5cdGRieDogRHJvcGJveFxuXHQvLyBAdHMtaWdub3JlXG5cdGRieEF1dGg6IERyb3Bib3hBdXRoXG5cdGF1dGhlZDogYm9vbGVhbiA9IGZhbHNlXG5cdC8vIEB0cy1pZ25vcmVcblx0ZmlyZWJhc2VfdXNlcjogVXNlciB8IG51bGxcblxuXHRhc3luYyBpbml0KCkge1xuXHRcdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuXHRcdFx0dGhpcy5SRURJUkVDVF9VUkkgPSAnaHR0cHM6Ly93cmlnaHR3cml0ZXIuZ2l0aHViLmlvL3NwbHVuZ2UvJ1xuXHRcdH1cblx0XHQvLyBjb25zb2xlLmxvZyhkYilcblx0XHRmaXJlYmFzZV9hcHAgPSBpbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKVxuXHRcdGZpcmViYXNlX2F1dGggPSBnZXRBdXRoKGZpcmViYXNlX2FwcClcblx0XHR0aGlzLmZpcmViYXNlX3VzZXIgPSBhd2FpdCBnZXRDdXJyZW50VXNlcihmaXJlYmFzZV9hdXRoKVxuXHRcdC8vIGZpcmViYXNlX2F1dGgub25BdXRoU3RhdGVDaGFuZ2VkKHVzZXIgPT57XG5cblx0XHQvLyB9KVxuXHRcdHRoaXMuZGJ4QXV0aCA9IG5ldyBEcm9wYm94QXV0aCh7XG5cdFx0XHRjbGllbnRJZDogdGhpcy5DTElFTlRfSUQsXG5cdFx0fSlcblxuXHRcdGlmICh0aGlzLmZpcmViYXNlX3VzZXIpIHtcblx0XHRcdGNvbnN0IGlkX3Rva2VuID0gYXdhaXQgZmlyZWJhc2VfYXV0aC5jdXJyZW50VXNlcj8uZ2V0SWRUb2tlbih0cnVlKVxuXG5cdFx0XHRsZXQgcmVzID0gYXdhaXQgKFxuXHRcdFx0XHRhd2FpdCBmZXRjaCgnaHR0cHM6Ly91cy1jZW50cmFsMS1zcGx1bmdlLTM5MDExMC5jbG91ZGZ1bmN0aW9ucy5uZXQvZ2V0RHJvcGJveENvZGUnICsgYD9pZF90b2tlbj0ke2lkX3Rva2VufWApXG5cdFx0XHQpLmpzb24oKVxuXG5cdFx0XHRjb25zdCBhY2Nlc3NfdG9rZW4gPSByZXMudG9rZW5cblx0XHRcdHRoaXMuZGJ4QXV0aC5zZXRBY2Nlc3NUb2tlbihhY2Nlc3NfdG9rZW4pXG5cblx0XHRcdC8vIHRoaXMuZGJ4QXV0aC5zZXRSZWZyZXNoVG9rZW4ocmVzLnRva2VuKVxuXHRcdFx0dGhpcy5kYnggPSBuZXcgRHJvcGJveCh7XG5cdFx0XHRcdGF1dGg6IHRoaXMuZGJ4QXV0aCxcblx0XHRcdH0pXG5cdFx0XHRsZXQgZmlsZXMgPSBhd2FpdCB0aGlzLmRieC5maWxlc0xpc3RGb2xkZXIoe1xuXHRcdFx0XHRwYXRoOiAnJyxcblx0XHRcdH0pXG5cdFx0XHR0aGlzLmF1dGhlZCA9IHRydWVcblx0XHR9XG5cdH1cblxuXHRjb25zdHJ1Y3RvcigpIHt9XG5cblx0cGFyc2VRdWVyeVN0cmluZyhzdHIpIHtcblx0XHRjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cblx0XHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiByZXRcblx0XHR9XG5cblx0XHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJylcblxuXHRcdGlmICghc3RyKSB7XG5cdFx0XHRyZXR1cm4gcmV0XG5cdFx0fVxuXG5cdFx0c3RyLnNwbGl0KCcmJykuZm9yRWFjaCgocGFyYW0pID0+IHtcblx0XHRcdGNvbnN0IHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKVxuXHRcdFx0Ly8gRmlyZWZveCAocHJlIDQwKSBkZWNvZGVzIGAlM0RgIHRvIGA9YFxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvcHVsbC8zN1xuXHRcdFx0bGV0IGtleSA9IHBhcnRzLnNoaWZ0KClcblx0XHRcdGxldCB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHMuam9pbignPScpIDogdW5kZWZpbmVkXG5cblx0XHRcdGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpXG5cblx0XHRcdC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG5cdFx0XHQvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG5cdFx0XHR2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKVxuXG5cdFx0XHRpZiAocmV0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXRba2V5XSA9IHZhbFxuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xuXHRcdFx0XHRyZXRba2V5XS5wdXNoKHZhbClcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldFtrZXldID0gW3JldFtrZXldLCB2YWxdXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHJldHVybiByZXRcblx0fVxuXHRhc3luYyBkb0F1dGgoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHVybF9yZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuXHRcdFx0XHQnaHR0cHM6Ly91cy1jZW50cmFsMS1zcGx1bmdlLTM5MDExMC5jbG91ZGZ1bmN0aW9ucy5uZXQvZ2V0QXV0aGVudGljYXRpb25VcmwnICsgYD91cmw9JHt3aW5kb3cubG9jYXRpb24uaHJlZn1gLFxuXHRcdFx0KVxuXHRcdFx0bGV0IHVybCA9IGF3YWl0IHVybF9yZXNwb25zZS5qc29uKClcblx0XHRcdHVybCA9IHVybFsnYXV0aF91cmwnXVxuXHRcdFx0d2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmxcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihlcnJvcilcblx0XHR9XG5cdH1cblxuXHRhc3luYyB0cnlfaW5pdF9kcm9wYm94KCkge1xuXHRcdGxldCBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcblx0XHRjb25zdCBnZXRDb2RlRnJvbVVybCA9ICgpID0+IHtcblx0XHRcdGNvZGUgPSB0aGlzLnBhcnNlUXVlcnlTdHJpbmcod2luZG93LmxvY2F0aW9uLnNlYXJjaCkuY29kZVxuXHRcdFx0cmV0dXJuIGNvZGVcblx0XHR9XG5cdFx0Y29uc3QgaGFzUmVkaXJlY3RlZEZyb21BdXRoID0gKCkgPT4ge1xuXHRcdFx0cmV0dXJuICEhZ2V0Q29kZUZyb21VcmwoKVxuXHRcdH1cblx0XHRsZXQgcmVkaXJlY3RlZEZyb21BdXRoID0gaGFzUmVkaXJlY3RlZEZyb21BdXRoKClcblx0XHRpZiAocmVkaXJlY3RlZEZyb21BdXRoKSB7XG5cdFx0XHRjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuXG5cdFx0XHRjb25zdCBib2R5ID0ge31cblxuXHRcdFx0Zm9yIChsZXQga2V5IG9mIHVybC5zZWFyY2hQYXJhbXMua2V5cygpKSB7XG5cdFx0XHRcdGlmICh1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChrZXkpLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRib2R5W2tleV0gPSB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChrZXkpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ym9keVtrZXldID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUgJiZcblx0XHRcdFx0d2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFxuXHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0JycsXG5cdFx0XHRcdFx0d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICtcblx0XHRcdFx0XHRcdHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gucmVwbGFjZSgvWz8mXWNvZGU9W14mXSsvLCAnJykucmVwbGFjZSgvXiYvLCAnPycpICtcblx0XHRcdFx0XHRcdHdpbmRvdy5sb2NhdGlvbi5oYXNoLFxuXHRcdFx0XHQpXG5cdFx0XHRib2R5WydyZWRpcmVjdF91cmwnXSA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG5cblx0XHRcdGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKFxuXHRcdFx0XHQnaHR0cHM6Ly91cy1jZW50cmFsMS1zcGx1bmdlLTM5MDExMC5jbG91ZGZ1bmN0aW9ucy5uZXQvZXhjaGFuZ2VEcm9wYm94Q29kZScgK1xuXHRcdFx0XHRcdGA/cmVkaXJlY3RfdXJsPSR7d2luZG93LmxvY2F0aW9uLmhyZWZ9YCArXG5cdFx0XHRcdFx0YCZjb2RlPSR7Ym9keVsnY29kZSddfWAsXG5cdFx0XHQpXG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKVxuXHRcdFx0c2lnbkluV2l0aEN1c3RvbVRva2VuKGZpcmViYXNlX2F1dGgsIGRhdGEudG9rZW4pXG5cdFx0fVxuXG5cdFx0cmV0dXJuXG5cdH1cbn1cbiIsIjxzdmVsdGU6b3B0aW9ucyBhY2Nlc3NvcnMgLz5cblxuPGRpdiBjbGFzcz1cImtub2ItY29udGFpbmVyXCI+XG5cdDxkaXZcblx0XHRjbGFzcz1cImtub2JcIlxuXHRcdHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBcblx0XHRvbjpjbGljaz17YXN5bmMgKCkgPT4ge1xuXHRcdFx0Ly8gZ2FsbGVyeV9vcGVuID0gIWdhbGxlcnlfb3BlblxuXHRcdFx0Z2FsbGVyeV9vcGVuLnNldCh0cnVlKVxuXHRcdFx0bGV0IFtfY2FudmFzX2ltYWdlLCBibG9iXSA9IGF3YWl0IGdldF9jdXJyZW50X2NhbnZhc19hc19pbWFnZSgpXG5cdFx0XHRjYW52YXNfaW1hZ2UgPSBfY2FudmFzX2ltYWdlXG5cdFx0XHRjYW52YXNfaW1hZ2Vfc3JjID0gY2FudmFzX2ltYWdlLnNyY1xuXHRcdFx0Y2FudmFzX2ltYWdlX2Jsb2IgPSBibG9iXG5cdFx0XHRjb25zb2xlLmxvZyhjYW52YXNfaW1hZ2Uuc3JjKVxuXHRcdH19PlxuXHRcdHtAaHRtbCBzb2x2ZUljb259XG5cdDwvZGl2PlxuXHR7I2lmICRnYWxsZXJ5X29wZW59XG5cdFx0PGRpdiBpZD1cImdhbGxlcnktY29udGFpbmVyLW91dGVyXCI+XG5cdFx0XHQ8ZGl2IGlkPVwiZ2FsbGVyeS1jb250YWluZXJcIj5cblx0XHRcdFx0PGRpdiBpZD1cInRvcC1iYXJcIj5cblx0XHRcdFx0XHQ8ZGl2IGlkPVwicHJvamVjdC10aXRsZVwiPlByb2plY3Q8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHRpZD1cImJhY2stYnV0dG9uXCJcblx0XHRcdFx0XHRcdHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBcblx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdC8vIGdhbGxlcnlfb3BlbiA9ICFnYWxsZXJ5X29wZW5cblx0XHRcdFx0XHRcdFx0Z2FsbGVyeV9vcGVuLnNldChmYWxzZSlcblx0XHRcdFx0XHRcdH19PlxuXHRcdFx0XHRcdFx0e0BodG1sIGZvcmJpZEljb259XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8ZGl2IGlkPVwiY3VycmVudC1wcm9qZWN0XCI+XG5cdFx0XHRcdFx0PGltZyBzcmM9e2NhbnZhc19pbWFnZV9zcmN9IGlkPVwiY2FudmFzLXByZXZpZXctaW1nXCIgYWx0PVwiXCIgLz5cblx0XHRcdFx0XHQ8ZGl2IGlkPVwicHJvamVjdC1vcHRpb25zXCI+XG5cdFx0XHRcdFx0XHQ8ZGl2IGlkPVwicHJvamVjdC1zYXZlLWJ1dHRvblwiIHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBvbjpjbGljaz17c2F2ZV90b19kcm9wYm94fT5cblx0XHRcdFx0XHRcdFx0PGRpdiBpZD1cInByb2plY3Qtc2F2ZS1idXR0b24tdGl0bGVcIj5TYXZlIHRvIGRyb3Bib3g8L2Rpdj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImljb25cIiBzdHlsZT1cInRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwwLjJyZW0pO1wiPlxuXHRcdFx0XHRcdFx0XHRcdHtAaHRtbCBjYXB0dXJlSWNvbn1cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDwhLS0gPGRpdiBpZD1cInByb2plY3Qtc2F2ZS1idXR0b25cIiBvbjpjbGljaz17KCk9Pntcblx0XHRcdFx0XHRcdFx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Byb2plY3QnLCBKU09OLnN0cmluZ2lmeShwcm9qZWN0KSlcblx0XHRcdFx0XHRcdH19PlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGlkPVwicHJvamVjdC1zYXZlLWJ1dHRvbi10aXRsZVwiPlNhdmUgdG8gbG9jYWxTdG9yYWdlPC9kaXY+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJpY29uXCIgc3R5bGU9XCJ0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwcHgsMC4ycmVtKTtcIj5cblx0XHRcdFx0XHRcdFx0XHR7QGh0bWwgY2FwdHVyZUljb259XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9kaXY+IC0tPlxuXHRcdFx0XHRcdFx0PGRpdiBpZD1cInByb2plY3Qtc2F2ZS1idXR0b25cIiBvbjpjbGljaz17ZG93bmxvYWRfaW1hZ2V9IHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiA+XG5cdFx0XHRcdFx0XHRcdDxkaXYgaWQ9XCJwcm9qZWN0LXNhdmUtYnV0dG9uLXRpdGxlXCI+RG93bmxvYWQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImljb25cIiBzdHlsZT1cInRyYW5zZm9ybTogc2NhbGUoMS4zNCk7XCI+XG5cdFx0XHRcdFx0XHRcdFx0e0BodG1sIGRvd25sb2FkSWNvbn1cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDxkaXYgaWQ9XCJwcm9qZWN0LXNhdmUtYnV0dG9uXCIgY2xhc3M9XCJkYXRlXCI+XG5cdFx0XHRcdFx0XHRcdDxkaXYgaWQ9XCJwcm9qZWN0LXNhdmUtYnV0dG9uLXRpdGxlXCI+e2Zvcm1hdF90aW1lKGN1cnJlbnRfcHJvamVjdC5pZCl9PC9kaXY+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdFx0XHRcdFx0e0BodG1sIHRpbWVJY29ufVxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8ZGl2IGlkPVwib3B0aW9ucy1iYXJcIj5cblx0XHRcdFx0XHQ8ZGl2IGlkPVwiYnV0dG9uXCIgb246Y2xpY2s9e2FzeW5jICgpID0+IHsgXG5cdFx0XHRcdFx0XHRsZXQgc2FmZSA9IGF3YWl0IGlzX3NhZmVfdG9fc3dpdGNoX3RvX25ld19wcm9qZWN0KClcblx0XHRcdFx0XHRcdHNhZmUgPSBzYWZlID8gc2FmZSA6IGNvbmZpcm0oJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBjcmVhdGUgYW5vdGhlciBwcm9qZWN0PyBUaGlzIG9uZSBpcyBub3Qgc2F2ZWQuJylcblx0XHRcdFx0XHRcdGlmKHNhZmUpe1xuXHRcdFx0XHRcdFx0XHRuZXdfcHJvamVjdCgpXG5cdFx0XHRcdFx0XHRcdC8vIGdhbGxlcnlfb3BlbiA9IGZhbHNlXG5cdFx0XHRcdFx0XHRcdGdhbGxlcnlfb3Blbi5zZXQoZmFsc2UpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBcblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdFx0XHROZXcgZmlsZVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHR7QGh0bWwgbGF1bmNoSWNvbn1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGlkPVwiYnV0dG9uXCIgb246Y2xpY2s9e2FzeW5jICgpID0+IHsgXG5cdFx0XHRcdFx0XHRzaXplX21vZGFsX29wZW5lZCA9IHRydWVcblx0XHRcdFx0XHRcdHJlc2l6ZV93aWRnZXRfY2FudmFzX3NpemVbMF0gPSBjdXJyZW50X3Byb2plY3QuY2FudmFzUmVzWzBdXG5cdFx0XHRcdFx0XHRyZXNpemVfd2lkZ2V0X2NhbnZhc19zaXplWzFdID0gY3VycmVudF9wcm9qZWN0LmNhbnZhc1Jlc1sxXVxuXHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0cm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIFxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxkaXYgZHJhZ2dhYmxlPVwiZmFsc2VcIj5cblx0XHRcdFx0XHRcdFx0UmVzaXplXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdHtAaHRtbCByZXNpemVJY29ufVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgaWQ9XCJzaXplLW1vZGFsXCIgc3R5bGU9e3NpemVfbW9kYWxfb3BlbmVkID8gXCJcIiA6IFwiZGlzcGxheTogbm9uZTtcIn0+XG5cdFx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHRcdGlkPVwiYmFjay1idXR0b25cIlxuXHRcdFx0XHRcdFx0XHRyb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgXG5cdFx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0c2l6ZV9tb2RhbF9vcGVuZWQgPSBmYWxzZVxuXHRcdFx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdFx0XHRzdHlsZT0nbWFyZ2luLWJvdHRvbTogMC40NXJlbTsnXG5cdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0e0BodG1sIGZvcmJpZEljb259XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDxkaXYgc3R5bGU9J21hcmdpbi1ib3R0b206IDFyZW07Jz5cblx0XHRcdFx0XHRcdFx0UmVzaXplIGNhbnZhc1xuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8ZGl2IHN0eWxlPSdtYXJnaW4tYm90dG9tOiAxcmVtOyc+XG5cdFx0XHRcdFx0XHRcdHtyZXNpemVfd2lkZ2V0X2NhbnZhc19zaXplWzBdfSB4IHtyZXNpemVfd2lkZ2V0X2NhbnZhc19zaXplWzFdfVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8ZGl2IHN0eWxlPXtgXG5cdFx0XHRcdFx0XHRcdGJhY2tncm91bmQ6IHdoaXRlO1xuXHRcdFx0XHRcdFx0XHR3aWR0aDogMTByZW07XG5cdFx0XHRcdFx0XHRcdGFzcGVjdC1yYXRpbzogMS8ke3Jlc2l6ZV93aWRnZXRfY2FudmFzX3NpemVbMV0vcmVzaXplX3dpZGdldF9jYW52YXNfc2l6ZVswXX1cblx0XHRcdFx0XHRcdGB9IG9uOnBvaW50ZXJkb3duPXtyZXNpemVfd2lkZ2V0X3BvaW50ZXJfZG93bn0gPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHRcdHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBcblx0XHRcdFx0XHRcdFx0aWQ9XCJiYWNrLWJ1dHRvblwiXG5cdFx0XHRcdFx0XHRcdGNsYXNzPVwib2stYnV0dG9uXCJcblx0XHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRyZXNpemVfcHJvamVjdChyZXNpemVfd2lkZ2V0X2NhbnZhc19zaXplKVxuXHRcdFx0XHRcdFx0XHRcdHNpemVfbW9kYWxfb3BlbmVkID0gZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHQvLyBnYWxsZXJ5X29wZW4gPSBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdGdhbGxlcnlfb3Blbi5zZXQoZmFsc2UpXG5cdFx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRcdHN0eWxlPSdtYXJnaW4tdG9wOiAxLjE0cmVtOydcblx0XHRcdFx0XHRcdFx0ID5cblx0XHRcdFx0XHRcdFx0e0BodG1sIG9rSWNvbn1cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PCEtLSA8YnV0dG9uIG9uOmNsaWNrPXthc3luYygpPT5hd2FpdCBsb2dfaW50b19kcm9wYm94KCl9IGNsYXNzOmhpZGU9e2F1dGhlZH0gPiAtLT5cblx0XHRcdFx0PGJ1dHRvbiBpZD1cImRiLWxvZ2luLWJ1dHRvblwiIG9uOmNsaWNrPXthc3luYygpPT5hd2FpdCBsb2dfaW50b19kcm9wYm94KCl9IGNsYXNzOmhpZGU9e2F1dGhlZH0gPlxuXHRcdFx0XHRcdExPRyBJTlRPIERST1BCT1hcblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdDxkaXYgaWQ9XCJnYWxsZXJ5LWVsZW1lbnRzXCI+XG5cdFx0XHRcdFx0eyNlYWNoIGdhbGxlcnlfZWxlbWVudHMgYXMgZWxlbWVudCwgaX1cblx0XHRcdFx0XHRcdDxkaXYgaWQ9XCJlbGVtZW50XCIgb246Y2xpY2s9e2FzeW5jICgpPT57XG5cdFx0XHRcdFx0XHRcdGxldCBzYWZlID0gYXdhaXQgaXNfc2FmZV90b19zd2l0Y2hfdG9fbmV3X3Byb2plY3QoKVxuXHRcdFx0XHRcdFx0XHRzYWZlID0gc2FmZSA/IHNhZmUgOiBjb25maXJtKCdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gc3dpdGNoIHRvIGFub3RoZXIgcHJvamVjdD8gVGhpcyBvbmUgaXMgbm90IHNhdmVkLicpXG5cdFx0XHRcdFx0XHRcdGlmKHNhZmUpe1xuXHRcdFx0XHRcdFx0XHRcdGxldCBwcm9qID0gYXdhaXQgZGJ4LmZpbGVzRG93bmxvYWQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0cGF0aDogJy8nICsgZWxlbWVudC5uYW1lICsgJy5qc29uJ1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRcdFx0XHRsZXQgYmluYXJ5ID0gYXdhaXQgcHJvai5yZXN1bHQuZmlsZUJsb2IudGV4dCgpXG5cdFx0XHRcdFx0XHRcdFx0bGV0IGJpbmFyeV9qc29uID0gSlNPTi5wYXJzZShiaW5hcnkpXG5cdFx0XHRcdFx0XHRcdFx0bG9hZF9wcm9qZWN0KGJpbmFyeV9qc29uKVxuXHRcdFx0XHRcdFx0XHRcdC8vIGdhbGxlcnlfb3BlbiA9IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0Z2FsbGVyeV9vcGVuLnNldChmYWxzZSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fX0gXG5cdFx0XHRcdFx0XHRyb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgXG5cdFx0XHRcdFx0XHRzdHlsZT17IE51bWJlcihlbGVtZW50Lm5hbWUpID09PSBjdXJyZW50X3Byb2plY3QuaWQgPyBcImJvcmRlcjogMC4xcmVtIHNvbGlkIHdoaXRlO1wiIDogXCJcIn1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PCEtLSB7ZWxlbWVudC5uYW1lfSAtLT5cblx0XHRcdFx0XHRcdFx0PGRpdiBpZD1cImVsZW1lbnQtbmFtZVwiPlxuXHRcdFx0XHRcdFx0XHRcdHtmb3JtYXRfdGltZShlbGVtZW50Lm5hbWUpfVxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0PGltZyBkcmFnZ2FibGU9XCJmYWxzZVwiIHNyYz17ZWxlbWVudC5pbWFnZV9zcmN9IGlkPVwiY2FudmFzLXByZXZpZXctaW1nXCIgYWx0PVwiXCIgLz5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0ey9pZn1cbjwvZGl2PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHQvLyBAdHMtaWdub3JlXG5cdGltcG9ydCBzb2x2ZUljb24gZnJvbSAnLy4uL3B1YmxpYy9zb2x2ZS5zdmcnXG5cdC8vIEB0cy1pZ25vcmVcblx0aW1wb3J0IGxhdW5jaEljb24gZnJvbSAnLy4uL3B1YmxpYy9sYXVuY2guc3ZnJ1xuXHQvLyBAdHMtaWdub3JlXG5cdGltcG9ydCByZXNpemVJY29uIGZyb20gJy8uLi9wdWJsaWMvcmVzaXplLnN2Zydcblx0Ly8gQHRzLWlnbm9yZVxuXHRpbXBvcnQgZm9yYmlkSWNvbiBmcm9tICcvLi4vcHVibGljL2ZvcmJpZC5zdmcnXG5cdC8vIEB0cy1pZ25vcmVcblx0aW1wb3J0IG9rSWNvbiBmcm9tICcvLi4vcHVibGljL29rLnN2Zydcblx0Ly8gQHRzLWlnbm9yZVxuXHRpbXBvcnQgY2FwdHVyZUljb24gZnJvbSAnLy4uL3B1YmxpYy9jYXB0dXJlLnN2Zydcblx0Ly8gQHRzLWlnbm9yZVxuXHRpbXBvcnQgZG93bmxvYWRJY29uIGZyb20gJy8uLi9wdWJsaWMvZG93bmxvYWQuc3ZnJ1xuXHQvLyBAdHMtaWdub3JlXG5cdGltcG9ydCB0aW1lSWNvbiBmcm9tICcvLi4vcHVibGljL3RpbWUuc3ZnJ1xuXHRpbXBvcnQge0Ryb3Bib3gsIERyb3Bib3hBdXRofSBmcm9tICdkcm9wYm94J1xuXHRpbXBvcnQgdHlwZSB7UHJvamVjdH0gZnJvbSAnc3R1ZmYnXG5cdGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnXG5cdGltcG9ydCB7IERyb3Bib3hBdXRoZXIgfSBmcm9tICdkcm9wYm94X2F1dGgnXG5cdGltcG9ydCB7ZmxvYXRpbmdfbW9kYWxfbWVzc2FnZX0gZnJvbSAnc3RvcmUnXG5cdGltcG9ydCB7Z2FsbGVyeV9vcGVufSBmcm9tICdzdG9yZSdcblxuXHRleHBvcnQgbGV0IGN1cnJlbnRfcHJvamVjdDogUHJvamVjdFxuXHRleHBvcnQgbGV0IGdldF9jdXJyZW50X2NhbnZhc19hc19pbWFnZTogKCkgPT4gUHJvbWlzZTxbSFRNTEltYWdlRWxlbWVudCwgQmxvYl0+XG5cdGV4cG9ydCBsZXQgcmVzaXplX3Byb2plY3Q6IChuZXdfc2l6ZTogbnVtYmVyW10pID0+IHZvaWRcblx0ZXhwb3J0IGxldCBuZXdfcHJvamVjdDogKCkgPT4gdm9pZFxuXHRleHBvcnQgbGV0IGxvYWRfcHJvamVjdDogKHByb2plY3Q6IFByb2plY3QpID0+IHZvaWRcblx0ZXhwb3J0IGxldCBwcm9qZWN0X2hhc19iZWVuX21vZGlmaWVkOiBib29sZWFuXG5cblx0Y29uc3QgZm9ybWF0X3RpbWUgPSAodDogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nID0+e1xuXHRcdHJldHVybiBuZXcgRGF0ZShOdW1iZXIodCkpLnRvTG9jYWxlU3RyaW5nKCdlbi1HQicsIHtcblx0XHRcdGhvdXJDeWNsZTogJ2gyMycsXG5cdFx0XHRkYXk6IFwiMi1kaWdpdFwiLFxuXHRcdFx0bW9udGg6IFwiMi1kaWdpdFwiLFxuXHRcdFx0eWVhcjogXCJudW1lcmljXCIsXG5cdFx0XHRob3VyOiBcIjItZGlnaXRcIixcblx0XHRcdG1pbnV0ZTogXCIyLWRpZ2l0XCJcblx0XHR9KS5yZXBsYWNlKCcsJywnJylcblx0fVxuXG5cdC8vIGxldCBnYWxsZXJ5X29wZW4gPSBmYWxzZVxuXHRsZXQgc2l6ZV9tb2RhbF9vcGVuZWQgPSBmYWxzZVxuXG5cdGxldCBjYW52YXNfaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcblx0bGV0IGNhbnZhc19pbWFnZV9ibG9iOiBCbG9iIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG5cdGxldCBjYW52YXNfaW1hZ2Vfc3JjOiBzdHJpbmcgPSAnJ1xuXHRcblxuXG5cdGNsYXNzIEVsZW1lbnQge1xuXHRcdG5hbWU6IHN0cmluZ1xuXHRcdGltYWdlX3NyYzogc3RyaW5nXG5cdFx0Y29uc3RydWN0b3IobmFtZTogc3RyaW5nLCBpbWFnZV9zcmM6IHN0cmluZykge1xuXHRcdFx0dGhpcy5uYW1lID0gbmFtZVxuXHRcdFx0dGhpcy5pbWFnZV9zcmMgPSBpbWFnZV9zcmNcblx0XHR9XG5cdH1cblx0XG5cdGxldCBkYng6IERyb3Bib3hcblx0Y29uc3QgZGJ4X2F1dGhlciA9IG5ldyBEcm9wYm94QXV0aGVyKClcblx0XG5cblx0bGV0IGF1dGhlZCA9IGZhbHNlXG5cdGxldCBnYWxsZXJ5X2VsZW1lbnRzOiBFbGVtZW50W10gPSBbXVxuXG5cdGNvbnN0IGxvZ19pbnRvX2Ryb3Bib3ggPSBhc3luYyAoKT0+IHtcblx0XHRhd2FpdCBkYnhfYXV0aGVyLmRvQXV0aCgpXG5cdH1cblx0XG5cdGV4cG9ydCBjb25zdCBpc19zYWZlX3RvX3N3aXRjaF90b19uZXdfcHJvamVjdCA9IGFzeW5jICgpOiBQcm9taXNlPGJvb2xlYW4+ID0+e1xuXHRcdGxldCBwcm9qZWN0X2lzX3NhdmVkX3RvX2Ryb3Bib3ggPSBmYWxzZVxuXG5cdFx0aWYoIWRieF9hdXRoZXIuYXV0aGVkKXtcblx0XHRcdHByb2plY3RfaXNfc2F2ZWRfdG9fZHJvcGJveCA9IHRydWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IHJlc3BvbnNlID0gYXdhaXQgZGJ4LmZpbGVzTGlzdEZvbGRlcih7cGF0aDogJyd9KVxuXHRcdFx0Zm9yIChsZXQgZWxlbWVudCBvZiByZXNwb25zZS5yZXN1bHQuZW50cmllcykge1xuXHRcdFx0XHRsZXQgcHJval9uYW1lID0gTnVtYmVyKGVsZW1lbnQubmFtZS5zbGljZSgwLC01KSlcblx0XHRcdFx0aWYocHJval9uYW1lID09PSBjdXJyZW50X3Byb2plY3QuaWQpe1xuXHRcdFx0XHRcdHByb2plY3RfaXNfc2F2ZWRfdG9fZHJvcGJveCA9IHRydWVcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYocHJvamVjdF9oYXNfYmVlbl9tb2RpZmllZCB8fCAhcHJvamVjdF9pc19zYXZlZF90b19kcm9wYm94KXtcblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0fVxuXG5cdGNvbnN0IGRvd25sb2FkX2ltYWdlID0gYXN5bmMgKCk9Pntcblx0XHRjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdGxpbmsuaHJlZiA9IChjYW52YXNfaW1hZ2UgYXMgSFRNTEltYWdlRWxlbWVudCkuc3JjXG5cdFx0bGluay5kb3dubG9hZCA9IGN1cnJlbnRfcHJvamVjdC5pZCArICcucG5nJztcblx0XHRsaW5rLmNsaWNrKCk7XG5cdH1cblx0Y29uc3QgcmVmZXRjaF9jYW52YXNlcyA9IGFzeW5jICgpID0+IHtcblx0XHRsZXQgcmVzcG9uc2UgPSBhd2FpdCBkYnguZmlsZXNMaXN0Rm9sZGVyKHtwYXRoOiAnJ30pXG5cdFx0Y29uc29sZS5sb2cocmVzcG9uc2UpXG5cdFx0Z2FsbGVyeV9lbGVtZW50cyA9IFtdXG5cdFx0Zm9yIChsZXQgZWxlbWVudCBvZiByZXNwb25zZS5yZXN1bHQuZW50cmllcykge1xuXHRcdFx0aWYoZWxlbWVudC5uYW1lLmVuZHNXaXRoKFwiLmpzb25cIikpe1xuXHRcdFx0XHRsZXQgcHJval9uYW1lID0gZWxlbWVudC5uYW1lLnNsaWNlKDAsLTUpXG5cdFx0XHRcdGxldCBpbWFnZSA9IGF3YWl0IGRieC5maWxlc0Rvd25sb2FkKHtcblx0XHRcdFx0XHRwYXRoOiAnLycgKyBwcm9qX25hbWUgKyAnLnBuZydcblx0XHRcdFx0fSlcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRsZXQgYmluYXJ5OiBCbG9iID0gaW1hZ2UucmVzdWx0LmZpbGVCbG9iXG5cdFx0XHRcdGNvbnN0IGJsb2JUb0RhdGFVUkwgPSAoYmxvYjogQmxvYik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdFx0XHRcdHJlYWRlci5vbmxvYWQgPSBfZSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQgYXMgc3RyaW5nKTtcblx0XHRcdFx0XHRcdHJlYWRlci5vbmVycm9yID0gX2UgPT4gcmVqZWN0KHJlYWRlci5lcnJvcik7XG5cdFx0XHRcdFx0XHRyZWFkZXIub25hYm9ydCA9IF9lID0+IHJlamVjdChuZXcgRXJyb3IoXCJSZWFkIGFib3J0ZWRcIikpO1xuXHRcdFx0XHRcdFx0cmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXG5cdFx0XHRcdC8vIFx0XHRhd2FpdCBibG9iVG9EYXRhVVJMKGJpbmFyeSlcblx0XHRcdFx0Ly8gKVxuXHRcdFx0XHQvLyBnYWxsZXJ5X2VsZW1lbnRzLnB1c2gobmV3IEVsZW1lbnQoXG5cdFx0XHRcdC8vIFx0cHJval9uYW1lLFxuXHRcdFx0XHQvLyBcdGF3YWl0IGJsb2JUb0RhdGFVUkwoYmluYXJ5KVxuXHRcdFx0XHQvLyApKVxuXHRcdFx0XHRnYWxsZXJ5X2VsZW1lbnRzID0gWy4uLiBnYWxsZXJ5X2VsZW1lbnRzLCBuZXcgRWxlbWVudChcblx0XHRcdFx0XHRwcm9qX25hbWUsXG5cdFx0XHRcdFx0YXdhaXQgYmxvYlRvRGF0YVVSTChiaW5hcnkpXG5cdFx0XHRcdCldXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGNvbnN0IHNhdmVfdG9fZHJvcGJveCA9IGFzeW5jICgpPT57XG5cdFx0ZmxvYXRpbmdfbW9kYWxfbWVzc2FnZS5zZXQoXCJTdGFydGluZyB1cGxvYWQgdG8gZHJvcGJveC5cIilcblx0XHRsZXQgciA9IGF3YWl0IGRieC5maWxlc1VwbG9hZCh7XG5cdFx0XHRwYXRoOiAnLycgKyBjdXJyZW50X3Byb2plY3QuaWQgKyAnLmpzb24nLFxuXHRcdFx0Y29udGVudHM6IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRfcHJvamVjdCksXG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRtb2RlOiBcIm92ZXJ3cml0ZVwiXG5cdFx0fSlcblx0XHRyID0gYXdhaXQgZGJ4LmZpbGVzVXBsb2FkKHtcblx0XHRcdHBhdGg6ICcvJyArIGN1cnJlbnRfcHJvamVjdC5pZCArICcucG5nJyxcblx0XHRcdGNvbnRlbnRzOiBhd2FpdCAoYXdhaXQgZmV0Y2goKChjYW52YXNfaW1hZ2UgYXMgSFRNTEltYWdlRWxlbWVudCkuc3JjKSkpLmJsb2IoKSxcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdG1vZGU6IFwib3ZlcndyaXRlXCJcblx0XHR9KVxuXHRcdGZsb2F0aW5nX21vZGFsX21lc3NhZ2Uuc2V0KFwiVXBsb2FkIHRvIGRyb3Bib3ggc3VjY2VzZnVsLlwiKVxuXHRcdHByb2plY3RfaGFzX2JlZW5fbW9kaWZpZWQgPSBmYWxzZVxuXHRcdGF3YWl0IHJlZmV0Y2hfY2FudmFzZXMoKVxuXHR9XG5cblx0Y29uc3QgcmVzaXplX3dpZGdldF9waXhlbF9yYW5nZSA9IDIwMFxuXHRjb25zdCBtaW4gPSAwXG5cdGNvbnN0IG1heCA9IDRcblxuXHRsZXQgcmVzaXplX3dpZGdldF9jYW52YXNfc2l6ZSA9IFswLDBdXG5cdGxldCByZXNpemVfd2lkZ2V0X3N0YXJ0X3kgPSAwXG5cdGxldCByZXNpemVfd2RpZ2V0X3N0YXJ0X3ZhbHVlID0gWzAsIDBdXG5cdGxldCByZXNpemVfd2lkZ2V0X3N0YXJ0X3ggPSAwXG5cblx0JDogdmFsdWVSYW5nZSA9IG1heCAtIG1pblxuXG5cdGZ1bmN0aW9uIHJlc2l6ZV93aWRnZXRfcG9pbnRlcl9tb3ZlKHtjbGllbnRYLCBjbGllbnRZfSkge1xuXHRcdGxldCB2YWx1ZURpZmZZID0gKHZhbHVlUmFuZ2UgKiAocmVzaXplX3dpZGdldF9zdGFydF95IC0gY2xpZW50WSkpIC8gcmVzaXplX3dpZGdldF9waXhlbF9yYW5nZVxuXHRcdGxldCB2YWx1ZURpZmZYID0gKHZhbHVlUmFuZ2UgKiAocmVzaXplX3dpZGdldF9zdGFydF94IC0gY2xpZW50WCkpIC8gcmVzaXplX3dpZGdldF9waXhlbF9yYW5nZVxuXG5cdFx0cmVzaXplX3dpZGdldF9jYW52YXNfc2l6ZVswXSA9IHJlc2l6ZV93ZGlnZXRfc3RhcnRfdmFsdWVbMF0gLSB2YWx1ZURpZmZYKjEwMDBcblx0XHRyZXNpemVfd2lkZ2V0X2NhbnZhc19zaXplWzFdID0gcmVzaXplX3dkaWdldF9zdGFydF92YWx1ZVsxXSArIHZhbHVlRGlmZlkqMTAwMFxuXHRcdC8vIGJydXNoX3N6WzBdID0gY2xhbXAoc3RhcnRWYWx1ZVswXSAtIHZhbHVlRGlmZlgsIG1pbiwgbWF4KVxuXHRcdC8vIGJydXNoX3N6WzFdID0gY2xhbXAoc3RhcnRWYWx1ZVsxXSArIHZhbHVlRGlmZlksIG1pbiwgbWF4KVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzaXplX3dpZGdldF9wb2ludGVyX2Rvd24oZTogUG9pbnRlckV2ZW50KSB7XG5cdFx0bGV0IHtjbGllbnRYLCBjbGllbnRZfSA9IGVcblx0XHQvLyBjb25zb2xlLmxvZyh7IGNsaWVudFkgfSk7XG5cdFx0Y29uc29sZS5sb2coJ2Rvd24nKVxuXG5cdFx0cmVzaXplX3dpZGdldF9zdGFydF95ID0gY2xpZW50WVxuXHRcdHJlc2l6ZV93aWRnZXRfc3RhcnRfeCA9IGNsaWVudFhcblx0XHRyZXNpemVfd2RpZ2V0X3N0YXJ0X3ZhbHVlID0gWy4uLnJlc2l6ZV93aWRnZXRfY2FudmFzX3NpemVdXG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCByZXNpemVfd2lkZ2V0X3BvaW50ZXJfbW92ZSlcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcmVzaXplX3dpZGdldF9wb2ludGVyX3VwKVxuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKClcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2l6ZV93aWRnZXRfcG9pbnRlcl91cCgpIHtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCByZXNpemVfd2lkZ2V0X3BvaW50ZXJfbW92ZSlcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcmVzaXplX3dpZGdldF9wb2ludGVyX3VwKVxuXHR9XG5cblx0b25Nb3VudChhc3luYyAoKSA9PiB7XG5cdFx0YXdhaXQgZGJ4X2F1dGhlci5pbml0KClcblx0XHRhd2FpdCBkYnhfYXV0aGVyLnRyeV9pbml0X2Ryb3Bib3goKVxuXHRcdGF1dGhlZCA9IGRieF9hdXRoZXIuYXV0aGVkXG5cdFx0ZGJ4ID0gZGJ4X2F1dGhlci5kYnhcblx0XHRpZihhdXRoZWQpe1xuXHRcdFx0cmVmZXRjaF9jYW52YXNlcygpXG5cdFx0fVxuXHR9KVxuXG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cblx0KiB7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cdFx0LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcblx0fVxuXHQjY2FudmFzLXByZXZpZXctaW1nIHtcblx0XHQvKiBtYXgtd2lkdGg6IDEycmVtOyAqL1xuXHRcdGhlaWdodDogMTJyZW07XG5cdFx0LyogbWF4LXdpZHRoOiA1cmVtOyAqL1xuXHRcdC8qIGFzcGVjdC1yYXRpbzp1bnNldDsgKi9cblx0fVxuXHQuaGlkZXtcblx0XHRkaXNwbGF5OiBub25lO1xuXHR9XG5cdDpnbG9iYWwoI2dhbGxlcnktY29udGFpbmVyOjotd2Via2l0LXNjcm9sbGJhcil7XG5cdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdH1cblx0Omdsb2JhbCgjZ2FsbGVyeS1jb250YWluZXI6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrKXtcblx0XHRiYWNrZ3JvdW5kOiBncmV5O1xuXHR9XG5cdDpnbG9iYWwoI2dhbGxlcnktY29udGFpbmVyOjotd2Via2l0LXNjcm9sbGJhci10aHVtYil7XG5cdFx0YmFja2dyb3VuZDogd2hpdGU7IFxuXHR9XG5cdCNkYi1sb2dpbi1idXR0b257XG4gICAgZm9udC1zaXplOiAzcmVtO1xuICAgIGJvcmRlci1yYWRpdXM6IDBweDtcbiAgICBtYXJnaW4tYm90dG9tOiAycmVtO1xuXHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHQmOmFjdGl2ZXtcblx0XHRcdGZpbHRlcjogaW52ZXJ0KDEpO1xuXHRcdH1cblx0fVxuXHQjc2l6ZS1tb2RhbCB7XG5cdFx0cG9zaXRpb246IGZpeGVkO1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdHdpZHRoOiAxMDB2dztcblx0XHRoZWlnaHQ6IDEwMHZoO1xuXHRcdGxlZnQ6IDA7XG5cdFx0dG9wOiAwO1xuXHRcdHotaW5kZXg6IDEwMTtcblx0XHRiYWNrZ3JvdW5kOiBibGFjaztcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0fVxuXHQjZ2FsbGVyeS1jb250YWluZXItb3V0ZXIge1xuXHRcdHBvc2l0aW9uOiBmaXhlZDtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHR3aWR0aDogMTAwdnc7XG5cdFx0aGVpZ2h0OiAxMDB2aDtcblx0XHRsZWZ0OiAwO1xuXHRcdHRvcDogMDtcblx0XHR6LWluZGV4OiAxMDA7XG5cdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdFx0I2dhbGxlcnktY29udGFpbmVyIHtcblx0XHRcdC8vIHNjcm9sbGJhci1jb2xvcjogIzY5NjlkZCAjZTBlMGUwO1xuXHRcdFx0Ly8gc2Nyb2xsYmFyLXdpZHRoOiB0aGluO1xuXHRcdFx0b3ZlcmZsb3cteTogb3ZlcmxheTtcblx0XHRcdHNjcm9sbGJhci1ndXR0ZXI6IHN0YWJsZSBib3RoLWVkZ2VzO1xuXHRcdFx0bWFyZ2luLXRvcDogMXJlbTtcblx0XHRcdC8vIG92ZXJmbG93OiBzY3JvbGw7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHRtYXgtd2lkdGg6IDQwcmVtO1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0XHQjdG9wLWJhciB7XG5cdFx0XHRcdCNwcm9qZWN0LXRpdGxlIHtcblx0XHRcdFx0XHRtYXJnaW4tbGVmdDogMC41cmVtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1hcmdpbi1ib3R0b206IDFyZW07XG5cdFx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0XHRmb250LXNpemU6IDJyZW07XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcblx0XHRcdH1cblx0XHRcdCNvcHRpb25zLWJhciB7XG5cdFx0XHRcdCoge1xuXHRcdFx0XHRcdGZvbnQtc2l6ZTogMC45NXJlbTtcblx0XHRcdFx0XHQ6Z2xvYmFsKHN2Zyl7XG5cdFx0XHRcdFx0XHRmaWxsOiB3aGl0ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0I2J1dHRvbntcblx0XHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdFx0XHRwYWRkaW5nOiAwcmVtIDAuMnJlbTtcblx0XHRcdFx0XHQ6Z2xvYmFsKHN2Zyl7XG5cdFx0XHRcdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCY6YWN0aXZle1xuXHRcdFx0XHRcdFx0ZmlsdGVyOiBpbnZlcnQoMSk7XG5cdFx0XHRcdFx0XHRiYWNrZ3JvdW5kOiBibGFjaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogMXJlbTtcblx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRcdGZvbnQtc2l6ZTogMnJlbTtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdFx0fVxuXHRcdFx0Lm9rLWJ1dHRvbiA6Z2xvYmFsKHN2Zykge1xuXHRcdFx0XHR0cmFuc2Zvcm06IHNjYWxlKDAuOTYpICFpbXBvcnRhbnQ7IFxuXHRcdFx0fVxuXHRcdFx0I2JhY2stYnV0dG9uID4gOmdsb2JhbChzdmcpIHtcblx0XHRcdFx0JjphY3RpdmV7XG5cdFx0XHRcdFx0ZmlsdGVyOiBpbnZlcnQoMSk7XG5cdFx0XHRcdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJhbnNmb3JtOiBzY2FsZSgxLjUpIHRyYW5zbGF0ZSgwLjJyZW0sIDBweCk7XG5cdFx0XHRcdGZpbGw6IHdoaXRlO1xuXHRcdFx0XHR3aWR0aDogM3JlbTtcblx0XHRcdFx0YXNwZWN0LXJhdGlvOiAxLzE7XG5cdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdH1cblx0XHRcdCNnYWxsZXJ5LWVsZW1lbnRzIHtcblx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRcdGRpc3BsYXk6IGdyaWQ7XG5cdFx0XHRcdGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDMsIDFmcik7XG5cdFx0XHRcdGdhcDogMTBweDtcblx0XHRcdFx0Z3JpZC1hdXRvLXJvd3M6IG1pbm1heCgxMDBweCwgYXV0byk7XG5cdFx0XHRcdCNlbGVtZW50e1xuXHRcdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdFx0XHQvLyBwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRcdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblx0XHRcdFx0XHQjZWxlbWVudC1uYW1le1xuXHRcdFx0XHRcdFx0bWFyZ2luLWJvdHRvbTogMC41cmVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQmOmFjdGl2ZXtcblx0XHRcdFx0XHRcdGJhY2tncm91bmQ6IHdoaXRlO1xuXHRcdFx0XHRcdFx0Kntcblx0XHRcdFx0XHRcdFx0Y29sb3I6IGJsYWNrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0I2N1cnJlbnQtcHJvamVjdCB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcblx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRcdG1hcmdpbi1ib3R0b206IDFyZW07XG5cblx0XHRcdFx0I3Byb2plY3Qtb3B0aW9ucyB7XG5cdFx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0XHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcblx0XHRcdFx0XHQqIHtcblx0XHRcdFx0XHRcdGZvbnQtc2l6ZTogMS4zcmVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCNwcm9qZWN0LXNhdmUtYnV0dG9uLXRpdGxlIHtcblx0XHRcdFx0XHRcdC8vIG1hcmdpbjogYXV0bztcblx0XHRcdFx0XHRcdG1hcmdpbi1yaWdodDogMC41cmVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQjcHJvamVjdC1zYXZlLWJ1dHRvbiB7XG5cdFx0XHRcdFx0XHQmOmFjdGl2ZXtcblx0XHRcdFx0XHRcdFx0ZmlsdGVyOiBpbnZlcnQoMSk7XG5cdFx0XHRcdFx0XHRcdGJhY2tncm91bmQ6IGJsYWNrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Lmljb24ge1xuXHRcdFx0XHRcdFx0XHR3aWR0aDogMnJlbTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hcmdpbi1yaWdodDogMS41cmVtO1xuXHRcdFx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcblx0XHRcdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogcm93O1xuXHRcdFx0XHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRcdFx0XHRcdGhlaWdodDogMnJlbTtcblx0XHRcdFx0XHRcdG1heC13aWR0aDogMzByZW07XG5cdFx0XHRcdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdFx0XHRcdCoge1xuXHRcdFx0XHRcdFx0XHRmb250LXNpemU6IDEuMHJlbTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vICYuZGF0ZXtcblx0XHRcdFx0XHRcdC8vIFx0KiB7XG5cdFx0XHRcdFx0XHQvLyBcdFx0Zm9udC1zaXplOiAwLjZyZW07XG5cdFx0XHRcdFx0XHQvLyBcdH1cblx0XHRcdFx0XHRcdC8vIH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0I3Byb2plY3Qtc2F2ZS1idXR0b24gOmdsb2JhbChzdmcpIHtcblx0XHRcdFx0XHRcdC8vIG1hcmdpbi1yaWdodDogMHJlbTtcblx0XHRcdFx0XHRcdGFzcGVjdC1yYXRpbzogMS8xO1xuXHRcdFx0XHRcdFx0ZmlsbDogd2hpdGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG4gIC8vIEBpbXBvcnQgXCIvLi4vc3R5bGVzL2ljb24uc2Nzc1wiIHNjb3BlZDsgXG5cdC5rbm9iLWNvbnRhaW5lciB7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHQtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Lyogd2lkdGg6IDQwcHg7XG4gICAgaGVpZ2h0OiA0MHB4OyAqL1xuXHRcdGFzcGVjdC1yYXRpbzogMS8xO1xuXHRcdG1heC1oZWlnaHQ6IDUwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdG1hcmdpbi1yaWdodDogMXJlbTtcblx0XHRwb2ludGVyLWV2ZW50czogYWxsO1xuXHRcdHVzZXItc2VsZWN0OiBub25lO1xuXHRcdG1hcmdpbi1ib3R0b206IGF1dG87XG5cdFx0bWFyZ2luLXRvcDogYXV0bztcbiAgICBtYXJnaW4tcmlnaHQ6IDByZW07XG5cdH1cblxuXHQua25vYiB7XG5cdFx0JjphY3RpdmUge1xuXHRcdFx0ZmlsdGVyOiBpbnZlcnQoMSk7XG5cdFx0XHRiYWNrZ3JvdW5kOiBibGFjaztcblx0XHR9XG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdGFzcGVjdC1yYXRpbzogMS8xO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHQvKiBoZWlnaHQ6IDgwJTsgKi9cblx0XHRwYWRkaW5nOiAwO1xuXHRcdGNvbG9yOiB2YXIoLS10ZXh0LWNvbG9yKTtcblx0XHR0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xuXHR9XG5cblx0Lmtub2IgOmdsb2JhbChzdmcpIHtcblx0XHRmaWxsOiB3aGl0ZTtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdH1cbjwvc3R5bGU+XG5cblxuXHRcdDwhLS0gY29uc3QgZGF0YVVSTFRvQmxvYiA9IGFzeW5jIChkYXRhVVJMKSA9PiB7XG5cdFx0XHRsZXQgQkFTRTY0X01BUktFUiA9ICc7YmFzZTY0LCc7XG5cblx0XHRcdGlmIChkYXRhVVJMLmluZGV4T2YoQkFTRTY0X01BUktFUikgPT0gLTEpIHtcblx0XHRcdFx0XHRsZXQgcGFydHMgPSBkYXRhVVJMLnNwbGl0KCcsJyk7XG5cdFx0XHRcdFx0bGV0IGNvbnRlbnRUeXBlID0gcGFydHNbMF0uc3BsaXQoJzonKVsxXTtcblx0XHRcdFx0XHRsZXQgcmF3ID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzWzFdKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgQmxvYihbcmF3XSwge3R5cGU6IGNvbnRlbnRUeXBlfSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBwYXJ0cyA9IGRhdGFVUkwuc3BsaXQoQkFTRTY0X01BUktFUik7XG5cdFx0XHRsZXQgY29udGVudFR5cGUgPSBwYXJ0c1swXS5zcGxpdCgnOicpWzFdO1xuXHRcdFx0bGV0IHJhdyA9IHdpbmRvdy5hdG9iKHBhcnRzWzFdKTtcblx0XHRcdGxldCByYXdMZW5ndGggPSByYXcubGVuZ3RoO1xuXG5cdFx0XHRsZXQgdUludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KHJhd0xlbmd0aCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmF3TGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHR1SW50OEFycmF5W2ldID0gcmF3LmNoYXJDb2RlQXQoaSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUT0RPOiBSRVBMQUNFIFdJVEggVEhJUz8/XG5cdFx0XHRjb25zdCBibG9iID0gYXdhaXQgKGF3YWl0IGZldGNoKGRhdGFVUkwpKS5ibG9iKCk7IFxuXHRcdFx0cmV0dXJuIGJsb2Jcblx0XHRcdC8vIGFkZCBjb25uZWN0LXNyYyBkYXRhOiB0byB5b3VyIENvbnRlbnQtU2VjdXJpdHktUG9saWN5XG5cblx0XHRcdHJldHVybiBuZXcgQmxvYihbdUludDhBcnJheV0sIHt0eXBlOiBjb250ZW50VHlwZX0pO1xuXHRcdH0gLS0+IiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQge2Zsb2F0aW5nX21vZGFsX21lc3NhZ2V9IGZyb20gXCJzdG9yZVwiXG4gIGxldCBzZWNvbmRzX3NpbmNlX21vZGFsOiBudW1iZXIgPSAwXG5cbiAgbGV0IGRpc3BsYXllZF9tZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgXG4gIGNvbnN0IGRpc3BsYXlfdGltZSA9IDFcbiAgY29uc3QgZmFkZV9pbl90ID0gMC4yXG4gIGNvbnN0IGZhZGVfb3V0X3QgPSAxXG4gIFxuICBsZXQgZmFkaW5nX2luID0gdHJ1ZVxuXG4gIGxldCBvcGFjaXR5ID0gMFxuICBcbiAgZmxvYXRpbmdfbW9kYWxfbWVzc2FnZS5zdWJzY3JpYmUobWVzc2FnZT0+e1xuICAgIGlmKG1lc3NhZ2Upe1xuICAgICAgZGlzcGxheWVkX21lc3NhZ2UgPSBtZXNzYWdlXG4gICAgICBvcGFjaXR5ID0gMVxuICAgICAgZmFkaW5nX2luID0gdHJ1ZVxuICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICBvcGFjaXR5ID0gMFxuICAgICAgICBmYWRpbmdfaW4gPSBmYWxzZVxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgZGlzcGxheWVkX21lc3NhZ2UgPSB1bmRlZmluZWRcbiAgICAgICAgfSwgZmFkZV9vdXRfdCAqIDEwMDApXG4gICAgICB9LCBkaXNwbGF5X3RpbWUgKiAxMDAwKVxuICAgICAgZmxvYXRpbmdfbW9kYWxfbWVzc2FnZS5zZXQodW5kZWZpbmVkKVxuICAgIH1cbiAgfSlcbjwvc2NyaXB0PlxuXG5cbjwhLS0geyNpZiBkaXNwbGF5ZWRfbWVzc2FnZX0gLS0+XG4gIDxkaXYgaWQ9XCJmbG9hdGluZy1tb2RhbFwiPlxuICAgPGRpdiBpZD1cInRleHRcIiBzdHlsZT17XG4gICAgYG9wYWNpdHk6ICR7b3BhY2l0eX07XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAke2ZhZGluZ19pbiA/IGZhZGVfaW5fdCA6IGZhZGVfb3V0X3R9cztgXG4gIH0gPlxuICAgIHtkaXNwbGF5ZWRfbWVzc2FnZX1cbiAgIDwvZGl2PlxuICA8L2Rpdj5cbjwhLS0gey9pZn0gLS0+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAqe1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG4gIC5mYWRlLWluIHtcbiAgICBcbiAgfVxuICAjZmxvYXRpbmctbW9kYWwge1xuXHRcdHBvc2l0aW9uOiBmaXhlZDtcblx0XHR3aWR0aDogZml0LWNvbnRlbnQ7XG5cdFx0aGVpZ2h0OiBmaXQtY29udGVudDtcbiAgICB0b3A6IDUwJTtcbiAgICBsZWZ0OiA1MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG5cdFx0ei1pbmRleDogMTAwO1xuICAgICN0ZXh0e1xuICAgICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDAuM3JlbSkgaW52ZXJ0KDAuMyk7XG4gICAgICBwYWRkaW5nOiAxcmVtO1xuICAgICAgYm9yZGVyLXJhZGl1czogMC41cmVtO1xuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgfVxuICB9XG48L3N0eWxlPiIsIjxzdmVsdGU6b3B0aW9ucyBhY2Nlc3NvcnMgLz5cblxuPGRpdiBiaW5kOnRoaXM9e3BpY2tlckVsZW1lbnR9IG9uOnBvaW50ZXJkb3duPXtwb2ludGVyRG93bn0gY2xhc3M9XCJrbm9iLWNvbnRhaW5lclwiPlxuXHQ8ZGl2IGNsYXNzPVwia25vYlwiIGNsYXNzOnBpY2tpbmc9e3BpY2tpbmd9PlxuXHRcdHtAaHRtbCBwaWNrSWNvbn1cblx0PC9kaXY+XG48L2Rpdj5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0Ly8gQHRzLWlnbm9yZVxuXHRpbXBvcnQgcGlja0ljb24gZnJvbSAnLy4uL3B1YmxpYy9wbHVnLnN2ZydcblxuXHRleHBvcnQgbGV0IHBpY2tfZnJvbV9jYW52YXM6ICgpID0+IG51bWJlcltdXG4gIFxuICBsZXQgcGlja2VyRWxlbWVudDogSFRNTEVsZW1lbnRcbiAgXG4gIGV4cG9ydCBsZXQgcGlja2luZyA9IGZhbHNlXG4gIGxldCBwaWNrZWRfY29sID0gWzAsMCwwXVxuICBleHBvcnQgbGV0IGp1c3RfZmluaXNoZWRfcGljayA9IGZhbHNlXG5cblx0ZnVuY3Rpb24gcG9pbnRlck1vdmUoeyBjbGllbnRYLCBjbGllbnRZIH0pIHtcbiAgIHBpY2tfZnJvbV9jYW52YXMoKVxuXG4gICAgLy8gcGlja2VkX2NvbCA9IFsuLi5jXVxuICAgIC8vIHBpY2tlZF9jb2xbMF0gPSBjWzBdLzI1NVxuICAgIC8vIHBpY2tlZF9jb2xbMV0gPSBjWzFdLzI1NVxuICAgIC8vIHBpY2tlZF9jb2xbMl0gPSBjWzJdLzI1NVxuXHRcdC8vIGxldCB2YWx1ZURpZmYgPSB2YWx1ZVJhbmdlICogKHN0YXJ0WSAtIGNsaWVudFkpIC8gcGl4ZWxSYW5nZTtcblx0XHQvLyB2YWx1ZURpZmYgLT0gdmFsdWVSYW5nZSAqIChzdGFydFggLSBjbGllbnRYKSAvIHBpeGVsUmFuZ2U7XG5cdFx0Ly8gdmFsdWUgPSBjbGFtcChzdGFydFZhbHVlICsgdmFsdWVEaWZmLCBtaW4sIG1heClcblx0fVxuXHRjb25zdCBwb2ludGVyVXAgPSAoKSA9PiB7XG4gICAgcGlja2luZyA9IGZhbHNlXG4gICAganVzdF9maW5pc2hlZF9waWNrID0gdHJ1ZVxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHBvaW50ZXJNb3ZlKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcG9pbnRlclVwKTtcblx0fVxuXHRcblx0Y29uc3QgcG9pbnRlckRvd24gPSAoZTogUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgcGlja2luZyA9IHRydWVcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBwb2ludGVyTW92ZSk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHBvaW50ZXJVcCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKSBcblx0fVxuXHRcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cdC5waWNraW5ne1xuXHRcdGZpbHRlcjogaW52ZXJ0KCk7XG5cdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdH1cblx0KiB7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cdFx0LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcblx0fVxuXG4gIEBpbXBvcnQgXCIvLi4vc3R5bGVzL2ljb24uc2Nzc1wiIHNjb3BlZDsgXG48L3N0eWxlPlxuIiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48ZGl2IGNsYXNzPVwia25vYi1jb250YWluZXItY29udGFpbmVyXCI+XG5cdDxpbWdcblx0XHRzcmM9e3NlbGVjdGVkX2JydXNoX3RleHR1cmUgPyBzZWxlY3RlZF9icnVzaF90ZXh0dXJlLnBhdGggOiAnJ31cblx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0ZHJvcGRvd25fdG9nZ2xlZCA9ICFkcm9wZG93bl90b2dnbGVkXG5cdFx0fX0gLz5cblx0eyNpZiBkcm9wZG93bl90b2dnbGVkfVxuXHRcdDxkaXYgaWQ9XCJkcm9wZG93blwiPlxuXHRcdFx0eyNlYWNoIGJydXNoX3RleHR1cmVzIGFzIHRleHR1cmUsIGl9XG5cdFx0XHRcdHsjaWYgdGV4dHVyZSAhPT0gc2VsZWN0ZWRfYnJ1c2hfdGV4dHVyZX1cblx0XHRcdFx0XHQ8aW1nXG5cdFx0XHRcdFx0XHRzcmM9e3RleHR1cmUucGF0aH1cblx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVkX2JydXNoX3RleHR1cmUgPSB0ZXh0dXJlXG5cdFx0XHRcdFx0XHRcdGRyb3Bkb3duX3RvZ2dsZWQgPSBmYWxzZVxuXHRcdFx0XHRcdFx0fX0gLz5cblx0XHRcdFx0ey9pZn1cblx0XHRcdHsvZWFjaH1cblx0XHQ8L2Rpdj5cblx0ey9pZn1cbjwvZGl2PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge0JydXNoVHlwZX0gZnJvbSAnYnJ1c2hfc3Ryb2tlJ1xuXHRpbXBvcnQgdHlwZSB7QnJ1c2hUZXh0dXJlfSBmcm9tICdzdHVmZidcblx0aW1wb3J0IHtvbk1vdW50fSBmcm9tICdzdmVsdGUnXG5cblx0ZXhwb3J0IGxldCBicnVzaF90ZXh0dXJlczogQXJyYXk8QnJ1c2hUZXh0dXJlPlxuXHRleHBvcnQgbGV0IHNlbGVjdGVkX2JydXNoX3RleHR1cmU6IEJydXNoVGV4dHVyZVxuXG5cdGxldCBkcm9wZG93bl90b2dnbGVkID0gZmFsc2VcblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuXHQqIHtcblx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblx0XHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHR9XG5cdGltZyB7XG5cdFx0JjphY3RpdmUge1xuXHRcdFx0ZmlsdGVyOiBpbnZlcnQoMSk7XG5cdFx0XHRiYWNrZ3JvdW5kOiBibGFjaztcblx0XHR9XG5cdFx0Ly8gcG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdH1cblx0Lmtub2ItY29udGFpbmVyLWNvbnRhaW5lciB7XG5cdFx0ei1pbmRleDogOTk7XG5cdFx0YXNwZWN0LXJhdGlvOiAxLzE7XG5cdFx0bWF4LWhlaWdodDogNTAlO1xuXHRcdG1hcmdpbi1ib3R0b206IGF1dG87XG5cdFx0bWFyZ2luLXRvcDogYXV0bztcblx0XHRtYXJnaW4tcmlnaHQ6IDEuNXJlbTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0cG9pbnRlci1ldmVudHM6IGFsbDtcblx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0bWluLXdpZHRoOiA3cmVtO1xuXG5cdFx0Ym9yZGVyOiAxcHggc29saWQgd2hpdGU7XG5cdFx0bWluLXdpZHRoOiAwcHg7XG5cdFx0YXNwZWN0LXJhdGlvOiAxLzE7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdCNkcm9wZG93biB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdHBvc2l0aW9uOiBzdGF0aWM7XG5cdFx0XHRoZWlnaHQ6IHVuc2V0O1xuXHRcdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdFx0XHQvLyB0b3A6IDg4cHg7XG5cdFx0XHQ+IGltZyB7XG5cdFx0XHRcdHotaW5kZXg6IDEwMDAwMDAwO1xuXHRcdFx0XHRhc3BlY3QtcmF0aW86IDEvMTtcblx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRcdC8vIHBvc2l0aW9uOiBzdGF0aWM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdD4gaW1nIHtcblx0XHRcdGFzcGVjdC1yYXRpbzogMS8xO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cbiIsIjxzdmVsdGU6b3B0aW9ucyBhY2Nlc3NvcnMgLz5cblxuPGRpdiBjbGFzcz1cImtub2ItY29udGFpbmVyLWNvbnRhaW5lclwiPlxuXHR7I2lmICFkcm9wZG93bl90b2dnbGVkfVxuXHQ8ZGl2IG9uOmNsaWNrPXsoKT0+e1xuXHRcdGRyb3Bkb3duX3RvZ2dsZWQgPSB0cnVlXG5cdH19PntCbGVuZGluZ0NvbG91clNwYWNlW3NlbGVjdGVkX2NvbG91cl9zcGFjZV19PC9kaXY+XG5cdHsvaWZ9XG5cdHsjaWYgZHJvcGRvd25fdG9nZ2xlZH1cblx0XHQ8ZGl2IGlkPVwiZHJvcGRvd25cIj5cblx0XHRcdHsjZWFjaCBPYmplY3Qua2V5cyhCbGVuZGluZ0NvbG91clNwYWNlKSBhcyBjb2xvdXJfc3BhY2UsIGl9XG5cdFx0XHRcdHsjaWYgaXNOYU4oQmxlbmRpbmdDb2xvdXJTcGFjZVtjb2xvdXJfc3BhY2VdKX1cblx0XHRcdFx0XHQ8ZGl2IHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBvbjpjbGljaz17KCk9Pntcblx0XHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRcdHNlbGVjdGVkX2NvbG91cl9zcGFjZSA9IGNvbG91cl9zcGFjZVxuXHRcdFx0XHRcdFx0ZHJvcGRvd25fdG9nZ2xlZCA9IGZhbHNlXG5cdFx0XHRcdFx0fX0gc3R5bGU9IHtcblx0XHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRcdGNvbG91cl9zcGFjZSAgPT09IHNlbGVjdGVkX2NvbG91cl9zcGFjZSA/ICBcImJhY2tncm91bmQ6IGJsYWNrOyBmaWx0ZXI6IGludmVydCgxKTtcIiA6IFwiXCJcblx0XHRcdFx0XHR9PlxuXHRcdFx0XHRcdFx0e0JsZW5kaW5nQ29sb3VyU3BhY2VbY29sb3VyX3NwYWNlXX1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0ey9pZn1cblx0XHRcdHsvZWFjaH1cblx0XHQ8L2Rpdj5cblx0ey9pZn1cbjwvZGl2PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge0JsZW5kaW5nQ29sb3VyU3BhY2UsIEJydXNoVHlwZX0gZnJvbSAnYnJ1c2hfc3Ryb2tlJ1xuXG5cdGV4cG9ydCBsZXQgc2VsZWN0ZWRfY29sb3VyX3NwYWNlOiBCbGVuZGluZ0NvbG91clNwYWNlXG5cblx0bGV0IGRyb3Bkb3duX3RvZ2dsZWQgPSBmYWxzZVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuXHQqIHtcblx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblx0XHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHR9XG5cdGRpdiB7XG5cdFx0JjphY3RpdmUge1xuXHRcdFx0ZmlsdGVyOiBpbnZlcnQoMSk7XG5cdFx0XHRiYWNrZ3JvdW5kOiBibGFjaztcblx0XHR9XG5cdFx0Ly8gcG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdH1cblx0Lmtub2ItY29udGFpbmVyLWNvbnRhaW5lciB7XG5cdFx0ei1pbmRleDogOTk7XG5cdFx0bWFyZ2luLWJvdHRvbTogYXV0bztcblx0XHRtYXJnaW4tdG9wOiBhdXRvO1xuXHRcdG1hcmdpbi1yaWdodDogMS41cmVtO1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRwb2ludGVyLWV2ZW50czogYWxsO1xuXHRcdHVzZXItc2VsZWN0OiBub25lO1xuXHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRtaW4td2lkdGg6IDdyZW07XG5cblx0XHRib3JkZXI6IDFweCBzb2xpZCB3aGl0ZTtcblx0XHRtaW4td2lkdGg6IDBweDtcblx0XHQjZHJvcGRvd24ge1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRwb3NpdGlvbjogc3RhdGljO1xuXHRcdFx0aGVpZ2h0OiB1bnNldDtcblx0XHRcdGJhY2tncm91bmQ6IGJsYWNrO1xuXHRcdFx0Ly8gdG9wOiA4OHB4O1xuXHRcdFx0PiBkaXYge1xuXHRcdFx0XHRib3JkZXI6IDFweCBzb2xpZCB3aGl0ZTtcblx0XHRcdFx0ei1pbmRleDogMTAwMDAwMDA7XG5cdFx0XHRcdC8vIGFzcGVjdC1yYXRpbzogMS8xO1xuXHRcdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdFx0Ly8gcG9zaXRpb246IHN0YXRpYztcblx0XHRcdH1cblx0XHR9XG5cdFx0PiBkaXYge1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cbiIsIjxzdmVsdGU6b3B0aW9ucyBhY2Nlc3NvcnMgLz5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgbWluIH0gZnJvbSAnd21hdGgnXG5cdGltcG9ydCBTZW1pTW9kYWwgZnJvbSAnLi9TZW1pTW9kYWwuc3ZlbHRlJ1xuXHRpbXBvcnQge29uTW91bnR9IGZyb20gJ3N2ZWx0ZSdcblxuXHRleHBvcnQgbGV0IGNvbG91cjogbnVtYmVyW11cblxuICBsZXQgY29sb3VyX2lkeCA9IDBcblxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgbGV0IGVsZW1lbnRzOiBIVE1MRGl2RWxlbWVudFtdID0gWzAsMCwwXVxuICAvLyBAdHMtaWdub3JlXG4gIGxldCBpbm5lcnM6IEhUTUxEaXZFbGVtZW50W10gPSBbMCwwLDBdXG5cblx0bGV0IHN0YXJ0WSA9IDBcbiAgbGV0IHN0YXJ0WCA9IDA7XG4gIGxldCBzdGFydFZhbHVlID0gMFxuXHRcblx0Y29uc3QgY2xhbXAgPSAobnVtLCBtaW4sIG1heCkgPT4ge1xuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG51bSwgbWF4KSk7XG5cdH1cblxuICBcbiAgY29uc3QgdXBkYXRlX3N0eWxlID0gKGlkeDogbnVtYmVyKSA9PntcbiAgICBpbm5lcnNbaWR4XS5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGVYKCR7Y29sb3VyW2lkeF19KWBcbiAgfVxuXHRcblx0Y29uc3QgcG9pbnRlck1vdmUgPSAoeyBjbGllbnRYLCBjbGllbnRZIH0pID0+IHtcblx0XHQvLyBsZXQgc2NhbGUgPSAyLi9taW4oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSBcblx0XHRsZXQgc2NhbGUgPSAxLi9lbGVtZW50c1tjb2xvdXJfaWR4XS5jbGllbnRXaWR0aFxuXG5cblx0XHRsZXQgdmFsdWVEaWZmID0gLShzdGFydFggLSBjbGllbnRYKSAqc2NhbGU7XG5cdFx0Y29sb3VyW2NvbG91cl9pZHhdID0gY2xhbXAoc3RhcnRWYWx1ZSArIHZhbHVlRGlmZiwgMCwgMSlcbiAgICB1cGRhdGVfc3R5bGUoY29sb3VyX2lkeClcblx0fVxuXHRcblx0Y29uc3QgcG9pbnRlckRvd24gPSAoZTogUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgbGV0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZVxuXHRcdHN0YXJ0WSA9IGNsaWVudFk7XG5cdFx0c3RhcnRYID0gY2xpZW50WDtcblx0XHRzdGFydFZhbHVlID0gY29sb3VyW2NvbG91cl9pZHhdO1xuICAgIHVwZGF0ZV9zdHlsZShjb2xvdXJfaWR4KVxuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgcG9pbnRlck1vdmUpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBwb2ludGVyVXApO1xuXHR9XG5cdFxuXHRjb25zdCBwb2ludGVyVXAgPSAoKSA9PiB7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgcG9pbnRlck1vdmUpO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBwb2ludGVyVXApO1xuXHR9XG4gIFxuICBvbk1vdW50KCgpPT57XG4gICAgdXBkYXRlX3N0eWxlKDApXG4gICAgdXBkYXRlX3N0eWxlKDEpXG4gICAgdXBkYXRlX3N0eWxlKDIpXG4gIH0pXG4gIFxuPC9zY3JpcHQ+XG5cblxuPGRpdiBkcmFnZ2FibGU9XCJmYWxzZVwiIGNsYXNzPSdrbm9iLWNvbnRhaW5lci1jb250YWluZXInPlxuXG4gIDwhLS0geyN9IC0tPlxuICB7I2VhY2ggY29sb3VyIGFzIGNvbF9lbGVtZW50LCBpfVxuICAgIHsjaWYgaSAhPT0gM31cbiAgICAgIDxkaXYgY2xhc3M9J2tub2ItY29udGFpbmVyJ1xuICAgICAgICBvbjpwb2ludGVyZG93bj17KGUpPT57XG4gICAgICAgICAgY29sb3VyX2lkeCA9IGlcbiAgICAgICAgICBwb2ludGVyRG93bihlKVxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCkgXG4gICAgICAgIH19XG4gICAgICAgIGJpbmQ6dGhpcz17ZWxlbWVudHNbaV19XG4gICAgICA+XG4gICAgICAgICA8ZGl2IGNsYXNzPSdpbm5lcicgXG4gICAgICAgICAgc3R5bGU9e1xuICAgICAgICAgICAgaSA9PT0gMCA/IFwiYmFja2dyb3VuZDogcmdiYSgyNTUsMCwwLDEpO1wiIDogaSA9PT0gMSA/IFwiYmFja2dyb3VuZDogcmdiYSgwLDI1NSwwLDEpO1wiIDogXCJiYWNrZ3JvdW5kOiByZ2JhKDAsMCwyNTUsMSk7XCJcbiAgICAgICAgICAgfVxuICAgICAgICAgICBiaW5kOnRoaXM9e2lubmVyc1tpXX1cbiAgICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuICB7L2VhY2h9XG48L2Rpdj5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4gICp7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O1xuICB9XG4gIC5rbm9iLWNvbnRhaW5lci1jb250YWluZXJ7XG4gICAgbWF4LWhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xuICAgIG1hcmdpbi1sZWZ0OiAwcHg7XG4gICAgbWFyZ2luLXJpZ2h0OiAwcHg7XG4gICAgYXNwZWN0LXJhdGlvOiAyLzE7XG4gICAgLyogbWF4LWhlaWdodDogNTAlOyAqL1xuICAgIGhlaWdodDogMTAwJTtcbiAgICAvKiBtYXJnaW4tdG9wOiAwLjVyZW07ICovXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgfVxuICAua25vYi1jb250YWluZXJ7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1hcmdpbi1yaWdodDogYXV0bztcbiAgICAuaW5uZXJ7XG4gICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0O1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBcbiAgICB9XG4gICAgXG4gIH1cbjwvc3R5bGU+IiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBtb2QgfSBmcm9tIFwiQDBiNXZyL2V4cGVyaW1lbnRhbFwiXG5cdGltcG9ydCBjaHJvbWEgZnJvbSBcImNocm9tYS1qc1wiXG5cdGltcG9ydCB7IG1pbiB9IGZyb20gXCJ3bWF0aFwiXG5cblx0ZXhwb3J0IGxldCBjb2xvdXI6IEFycmF5PG51bWJlcj47XG5cdC8vIGV4cG9ydCBsZXQgY29sb3VyX3I6IG51bWJlcjtcblx0Ly8gZXhwb3J0IGxldCBjb2xvdXJfZzogbnVtYmVyO1xuXHQvLyBleHBvcnQgbGV0IGNvbG91cl9iOiBudW1iZXI7XG5cdC8vIGV4cG9ydCBsZXQganVzdF9maW5pc2hlZF9waWNrOiBib29sZWFuXG5cdFxuXHQvLyAkOiB2YWx1ZVJhbmdlID0gbWF4IC0gbWluO1xuXHQvLyAkOiByb3RhdGlvbiA9IHN0YXJ0Um90YXRpb24gKyAodmFsdWUgLSBtaW4pIC8gdmFsdWVSYW5nZSAqIHJvdFJhbmdlO1xuICBcblxuXG5cbiAgbGV0IGNvbnRhaW5lclxuXG5cdC8vIG9uTW91bnQoKCkgPT4ge1xuICAvLyAgIC8vIEB0cy1pZ25vcmVcbiAgLy8gICB3aW5kb3cuY29udGFpbmVyID0gY29udGFpbmVyXG5cdC8vIH0pXG5cbiAgY29uc3QgcmVfcmVuZGVyX2NvbG91ciA9IChjb2xvdXJfciwgY29sb3VyX2csIGNvbG91cl9iKT0+e1xuICAgIGlmKGNvbnRhaW5lcil7XG4gICAgICBjb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoJy0tY29sb3InLCBgcmdiYSgke1xuICAgICAgMjU1ICogTWF0aC5wb3coY29sb3VyX3IsIDAuNDU0NTQ1NDU0NTQ1NDU0NTQ1NDUpfSwgJHtcbiAgICAgIDI1NSAqIE1hdGgucG93KGNvbG91cl9nLCAwLjQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1KX0sICR7XG4gICAgICAyNTUgKiBNYXRoLnBvdyhjb2xvdXJfYiwgMC40NTQ1NDU0NTQ1NDU0NTQ1NDU0NSl9LCAke1xuICAgICAgMjU1ICogTWF0aC5wb3coMS4wLCAwLjQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1KX0pYClcbiAgICB9XG4gIH1cblxuXHRleHBvcnQgbGV0IHVwZGF0ZV9kaXNwbGF5ID0gKGNvbG91cl9yLCBjb2xvdXJfZywgY29sb3VyX2IpPT57cmVfcmVuZGVyX2NvbG91cihjb2xvdXJfciwgY29sb3VyX2csIGNvbG91cl9iKX1cbiAgXG5cdC8vICQ6IGNvbCA9IGByZ2JhKCR7Y29sb3VyWzBdfSwgJHtjb2xvdXJbMV19LCAke2NvbG91clsyXX0sICR7Y29sb3VyWzNdfSlgO1xuXHQkOiByZV9yZW5kZXJfY29sb3VyKGNvbG91clswXSwgY29sb3VyWzFdLCBjb2xvdXJbMl0pO1xuXHQvLyAkOiBpZih1cGRhdGVfZGlzcGxheSkge3JlX3JlbmRlcl9jb2xvdXIoY29sb3VyX3IsIGNvbG91cl9nLCBjb2xvdXJfYik7IHVwZGF0ZV9kaXNwbGF5ID0gZmFsc2V9XG5cblx0Ly8gY29uc3QgcGl4ZWxSYW5nZSA9IDIwMFxuXHQvLyBsZXQgdmFsdWUgPSBbMCwgMF1cblx0Ly8gY29uc3QgbWluID0gMFxuXHQvLyBjb25zdCBtYXggPSA0XG5cblx0ZXhwb3J0IGxldCBkcmFnZ2luZzogYm9vbGVhbiA9IGZhbHNlXG5cdGV4cG9ydCBsZXQgc3RvcHBlZF9kcmFnZ2luZzogYm9vbGVhbiA9IGZhbHNlXG5cblx0Ly8gbGV0IHN0YXJ0WSA9IDBcblx0bGV0IHN0YXJ0VmFsdWUgPSBbMCwgMF1cblx0Ly8gbGV0IHN0YXJ0WCA9IDBcblx0XG5cdGxldCBwcmV2WCA9IDBcblx0bGV0IHByZXZZID0gMFxuXG5cdGNvbnN0IHZhbHVlUmFuZ2UgPSA0XG5cdC8vICQ6IHJvdGF0aW9uID0gc3RhcnRSb3RhdGlvbiArICh2YWx1ZSAtIG1pbikgLyB2YWx1ZVJhbmdlICogcm90UmFuZ2U7XG5cblx0ZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG51bSwgbWF4KSlcblx0fVxuXHRjb25zdCBjaHJvbWFfZ2wgPSAoY29sOiBudW1iZXJbXSkgPT4ge1xuXHRcdHJldHVybiBjaHJvbWEuZ2woY29sWzBdLCBjb2xbMV0sIGNvbFsyXSlcblx0fVxuXHRjb25zdCBjaHJvbWFfb2tsY2ggPSAoY29sOiBudW1iZXJbXSkgPT4ge1xuXHRcdHJldHVybiBjaHJvbWEub2tsY2goY29sWzBdLCBjb2xbMV0sIGNvbFsyXSlcblx0fVxuXG5cdGNvbnN0IHBvaW50ZXJNb3ZlID0gKHtjbGllbnRYLCBjbGllbnRZfSkgPT4ge1xuXHRcdGNvbnN0IHZhbHVlRGlmZlkgPSAtKGNsaWVudFkgLSBwcmV2WSlcblx0XHRjb25zdCB2YWx1ZURpZmZYID0gY2xpZW50WCAtIHByZXZYXG5cdFx0XG5cdFx0cHJldlggPSBjbGllbnRYXG5cdFx0cHJldlkgPSBjbGllbnRZXG5cblxuICAgIGxldCBjb2wgPSBjaHJvbWFfZ2woY29sb3VyKS5va2xjaCgpXG5cdFx0XG5cdFx0bGV0IHNjYWxlID0gMS4vbWluKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgXG5cbiAgICBjb2xbMF0gKz0gdmFsdWVEaWZmWSozLjAqc2NhbGVcbiAgICBjb2xbMl0gKz0gdmFsdWVEaWZmWCozNjAqMy4wKnNjYWxlXG4gICAgY29sWzBdID0gY2xhbXAoY29sWzBdLCAwLCAxKVxuICAgIGNvbFsxXSA9IGNsYW1wKGNvbFsxXSwgMCwgMSlcbiAgICBjb2xbMl0gPSBtb2QoY29sWzJdLCAzNjApXG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29sID0gY2hyb21hX29rbGNoKGNvbCkuZ2woKVxuICAgIGNvbG91clswXSA9IGNvbFswXVxuICAgIGNvbG91clsxXSA9IGNvbFsxXVxuICAgIGNvbG91clsyXSA9IGNvbFsyXVxuXHR9XG5cblx0ZnVuY3Rpb24gcG9pbnRlckRvd24oZTogUG9pbnRlckV2ZW50KSB7XG5cdFx0ZHJhZ2dpbmcgPSB0cnVlXG5cdFx0Y29uc3Qge2NsaWVudFgsIGNsaWVudFl9ID0gZVxuXHRcdHByZXZZID0gY2xpZW50WVxuXHRcdHByZXZYID0gY2xpZW50WFxuXHRcdHN0YXJ0VmFsdWUgPSBbY29sb3VyWzBdLCBjb2xvdXJbMV0sIGNvbG91clsyXSwgMV1cblxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHBvaW50ZXJNb3ZlKVxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBwb2ludGVyVXApXG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKVxuXHR9XG5cblx0ZnVuY3Rpb24gcG9pbnRlclVwKCkge1xuXHRcdGRyYWdnaW5nID0gZmFsc2Vcblx0XHRzdG9wcGVkX2RyYWdnaW5nID0gdHJ1ZVxuXHRcdGNvbnNvbGUubG9nKCd1cCcpXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgcG9pbnRlck1vdmUpXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHBvaW50ZXJVcClcblx0fVxuXHRcbjwvc2NyaXB0PlxuXG48ZGl2IGRyYWdnYWJsZT1cImZhbHNlXCIgY2xhc3M9J2tub2ItY29udGFpbmVyJyBiaW5kOnRoaXM9e2NvbnRhaW5lcn0gb246cG9pbnRlcmRvd249e3BvaW50ZXJEb3dufSA+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAua25vYi1jb250YWluZXJ7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgJjpob3ZlcntcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG4gICAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XG4gICAgYXNwZWN0LXJhdGlvOiAyLzE7XG4gICAgLyogbWF4LWhlaWdodDogMTAwJTsgKi9cbiAgICAvKiBoZWlnaHQ6IDEwMCU7ICovXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvcik7XG5cdFx0d2lkdGg6IDE0cmVtO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBtYXgtaGVpZ2h0OiAxMDAlICFpbXBvcnRhbnQ7XG4gIH0gIFxuPC9zdHlsZT4iLCI8c3ZlbHRlOm9wdGlvbnMgYWNjZXNzb3JzIC8+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7Z2FsbGVyeV9vcGVufSBmcm9tICdzdG9yZSdcblx0Ly8gaW1wb3J0IEtub2IgZnJvbSBcIi4vS25vYi5zdmVsdGVcIlxuPC9zY3JpcHQ+XG5cblxuPGRpdiBpZD0nZm91ci1pY29ucycgc3R5bGU9eyRnYWxsZXJ5X29wZW4/ICBcImRpc3BsYXk6IGNvbnRlbnRzO1wiIDogXCJcIn0+XG4gIDxzbG90Pjwvc2xvdD5cbjwvZGl2PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbiAgI2ZvdXItaWNvbnN7XG4gICAgLy8gd2lkdGg6IDEwMCU7XG4gICAgbWF4LWhlaWdodDogdW5zZXQgIWltcG9ydGFudDtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYXNwZWN0LXJhdGlvOiAxLzE7XG4gICAgZGlzcGxheTogZ3JpZDtcbiAgICAvLyBoZWlnaHQ6IDEwMCU7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAyZnIgMWZyO1xuICAgIGdyaWQtdGVtcGxhdGUtcm93czogMWZyIDFmcjtcbiAgICB3aWR0aDogNXJlbTtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNyk7XG4gICAgdHJhbnNmb3JtLW9yaWdpbjogdG9wO1xuICAgIC8vIHBhZGRpbmc6IDByZW0gMXJlbTtcbiAgICAvLyBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIC8vID4gKjpsYXN0LW9mLXR5cGUge1xuICAgIC8vICAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gICAgLy8gICBtYXJnaW4tcmlnaHQ6IDBweDtcbiAgICAvLyB9XG4gICAgPjpnbG9iYWwoZGl2Om5vdCg6Zmlyc3Qtb2YtdHlwZSkpe1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgbWF4LWhlaWdodDogdW5zZXQ7XG4gICAgICBtYXJnaW46IDA7XG4gICAgfVxuICAgID46Z2xvYmFsKGRpdjpmaXJzdC1vZi10eXBlKXtcbiAgICAgIGdyaWQtY29sdW1uOiAxIC8gLTE7XG4gICAgfVxuICB9XG48L3N0eWxlPiIsImltcG9ydCB7bWluLCBzcXJ0fSBmcm9tICd3bWF0aCdcblxuaW50ZXJmYWNlIGtleVN0YXRlIHtcblx0ZG93bjogYm9vbGVhblxuXHRqdXN0X3ByZXNzZWQ6IGJvb2xlYW5cblx0anVzdF91bnByZXNzZWQ6IGJvb2xlYW5cbn1cblxudHlwZSBCdG5Db2RlID1cblx0fCAnS2V5QSdcblx0fCAnS2V5Qidcblx0fCAnS2V5Qydcblx0fCAnS2V5RCdcblx0fCAnS2V5RSdcblx0fCAnS2V5Ridcblx0fCAnS2V5Rydcblx0fCAnS2V5SCdcblx0fCAnS2V5SSdcblx0fCAnS2V5Sidcblx0fCAnS2V5Sydcblx0fCAnS2V5TCdcblx0fCAnS2V5TSdcblx0fCAnS2V5Tidcblx0fCAnS2V5Tydcblx0fCAnS2V5UCdcblx0fCAnS2V5USdcblx0fCAnS2V5Uidcblx0fCAnS2V5Uydcblx0fCAnS2V5VCdcblx0fCAnS2V5VSdcblx0fCAnS2V5SSdcblx0fCAnS2V5Vidcblx0fCAnS2V5Vydcblx0fCAnS2V5WCdcblx0fCAnS2V5WSdcblx0fCAnS2V5Widcblx0fCAnRGlnaXQxJ1xuXHR8ICdEaWdpdDInXG5cdHwgJ0RpZ2l0Mydcblx0fCAnRGlnaXQ0J1xuXHR8ICdEaWdpdDUnXG5cdHwgJ0RpZ2l0Nidcblx0fCAnRGlnaXQ3J1xuXHR8ICdEaWdpdDgnXG5cdHwgJ0RpZ2l0OSdcblx0fCAnRGlnaXQwJ1xuXHR8ICdDb250cm9sTGVmdCdcblx0fCAnQWx0TGVmdCdcblx0fCAnU2hpZnRMZWZ0J1xuXHR8ICdTcGFjZSdcblxuZXhwb3J0IGNsYXNzIElPIHtcblx0cHJpdmF0ZSBrZXlzID0gbmV3IE1hcDxCdG5Db2RlLCBrZXlTdGF0ZT4oKVxuXG5cdC8vIHRvdWNoX3Bvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoOClcblx0Ly8gdG91Y2hfcG9zaXRpb25zX2NudCA9IDBcblx0dG91Y2hlczoge1trZXk6IG51bWJlcl06IG51bWJlcltdfSA9IHt9XG5cdHR3b19maW5nZXJfcGluY2hfcHJldiA9IGZhbHNlXG5cdHR3b19maW5nZXJfcGluY2ggPSBmYWxzZVxuXHRqdXN0X2ZpbmlzaGVkX3BpbmNoID0gZmFsc2Vcblx0anVzdF9zdGFydGVkX3BpbmNoID0gZmFsc2Vcblx0dG91Y2hlc19zdGFydGluZ19wb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KDQpXG5cdHRvdWNoZXNfc3RhcnRpbmdfbWlkX3BvaW50ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuXHR0b3VjaGVzX3N0YXJ0aW5nX2xlbmd0aCA9IDBcblx0dG91Y2hlc19taWRfcG9pbnRfcHJldiA9IG5ldyBGbG9hdDMyQXJyYXkoMilcblx0cGluY2hfcG9zID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuXHRwaW5jaF96b29tID0gMFxuXG5cdC8vIG1vdXNlX3BvczogQXJyYXk8bnVtYmVyPiA9IFswLCAwXVxuXHRtb3VzZV9wb3M6IEZsb2F0MzJBcnJheSA9IEZsb2F0MzJBcnJheS5mcm9tKFswLCAwXSlcblx0ZGVsdGFfbW91c2VfcG9zOiBGbG9hdDMyQXJyYXkgPSBGbG9hdDMyQXJyYXkuZnJvbShbMCwgMF0pXG5cdG1vdXNlX3Bvc19wcmV2OiBGbG9hdDMyQXJyYXkgPSBGbG9hdDMyQXJyYXkuZnJvbShbMCwgMF0pXG5cdG1vdXNlX2Rvd246IGJvb2xlYW4gPSBmYWxzZVxuXG5cdHByaXZhdGUgX21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZSA9IG5ldyBGbG9hdDMyQXJyYXkoNTApXG5cdHByaXZhdGUgX21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZV9iID0gbmV3IEZsb2F0MzJBcnJheSg1MClcblx0X21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZV9jbnQgPSAwXG5cdF9tb3VzZV9wb3NpdGlvbnNfZHVyaW5nX2xhc3RfZnJhbWVfY250X2IgPSAwXG5cdG1vdXNlX3Bvc2l0aW9uc19hcnJfaWR4ID0gMFxuXG5cdGdldCBtb3VzZV9wb3NpdGlvbnNfZHVyaW5nX2xhc3RfZnJhbWUoKTogRmxvYXQzMkFycmF5IHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZV9wb3NpdGlvbnNfYXJyX2lkeCA9PT0gMFxuXHRcdFx0PyB0aGlzLl9tb3VzZV9wb3NpdGlvbnNfZHVyaW5nX2xhc3RfZnJhbWVcblx0XHRcdDogdGhpcy5fbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2Jcblx0fVxuXHRnZXQgbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2NudCgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlX3Bvc2l0aW9uc19hcnJfaWR4ID09PSAwXG5cdFx0XHQ/IHRoaXMuX21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZV9jbnRcblx0XHRcdDogdGhpcy5fbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2NudF9iXG5cdH1cblxuXHRwb2ludGVyVHlwZTogc3RyaW5nID0gJ21vdXNlJ1xuXG5cdG1vdXNlX2Rvd25fcHJldiA9IGZhbHNlXG5cdG1vdXNlX2p1c3RfdW5wcmVzc2VkID0gZmFsc2Vcblx0bW91c2VfanVzdF9wcmVzc2VkID0gZmFsc2Vcblx0bW91c2VfanVzdF9tb3ZlZCA9IGZhbHNlXG5cblx0bW1iX2p1c3RfdW5wcmVzc2VkID0gZmFsc2Vcblx0bW1iX2p1c3RfcHJlc3NlZCA9IGZhbHNlXG5cdG1tYl9kb3duID0gZmFsc2VcblxuXHRtb3VzZV93aGVlbDogbnVtYmVyID0gMFxuXG5cdHByZXNzdXJlOiBudW1iZXIgPSAwLjBcblxuXHR0aWx0OiBudW1iZXJbXSA9IFswLCAwXVxuXG5cdHRpY2soKSB7XG5cdFx0dGhpcy5kZWx0YV9tb3VzZV9wb3NbMF0gPSB0aGlzLm1vdXNlX3Bvc1swXSAtIHRoaXMubW91c2VfcG9zX3ByZXZbMF1cblx0XHR0aGlzLmRlbHRhX21vdXNlX3Bvc1sxXSA9IHRoaXMubW91c2VfcG9zWzFdIC0gdGhpcy5tb3VzZV9wb3NfcHJldlsxXVxuXHRcdHRoaXMubW91c2VfcG9zX3ByZXZbMF0gPSB0aGlzLm1vdXNlX3Bvc1swXVxuXHRcdHRoaXMubW91c2VfcG9zX3ByZXZbMV0gPSB0aGlzLm1vdXNlX3Bvc1sxXVxuXG5cdFx0aWYgKHRoaXMubW91c2VfcG9zaXRpb25zX2Fycl9pZHggPT09IDApIHtcblx0XHRcdHRoaXMuX21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZV9jbnQgPSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZV9jbnRfYiA9IDBcblx0XHR9XG5cdFx0dGhpcy5tb3VzZV9wb3NpdGlvbnNfYXJyX2lkeCA9IDEgLSB0aGlzLm1vdXNlX3Bvc2l0aW9uc19hcnJfaWR4XG5cblx0XHRpZiAodGhpcy50d29fZmluZ2VyX3BpbmNoID09PSBmYWxzZSAmJiB0aGlzLnR3b19maW5nZXJfcGluY2hfcHJldiA9PT0gdHJ1ZSkge1xuXHRcdFx0dGhpcy5qdXN0X2ZpbmlzaGVkX3BpbmNoID0gdHJ1ZVxuXHRcdH0gZWxzZSBpZiAodGhpcy50d29fZmluZ2VyX3BpbmNoID09PSB0cnVlICYmIHRoaXMudHdvX2Zpbmdlcl9waW5jaF9wcmV2ID09PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5qdXN0X3N0YXJ0ZWRfcGluY2ggPSB0cnVlXG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMubW91c2VfZG93biAhPT0gdGhpcy5tb3VzZV9kb3duX3ByZXYpIHtcblx0XHRcdGlmICh0aGlzLm1vdXNlX2Rvd24pIHtcblx0XHRcdFx0Ly8gdGhpcy5tb3VzZV9wcmVzc2VkID0gdHJ1ZVxuXHRcdFx0XHR0aGlzLm1vdXNlX2p1c3RfcHJlc3NlZCA9IHRydWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHRoaXMubW91c2VfcHJlc3NlZCA9IGZhbHNlXG5cdFx0XHRcdHRoaXMubW91c2VfanVzdF91bnByZXNzZWQgPSB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHRpY2tfZW5kKCkge1xuXHRcdHRoaXMubW91c2VfanVzdF9wcmVzc2VkID0gZmFsc2Vcblx0XHR0aGlzLm1vdXNlX2p1c3RfdW5wcmVzc2VkID0gZmFsc2Vcblx0XHR0aGlzLm1vdXNlX2p1c3RfbW92ZWQgPSBmYWxzZVxuXHRcdHRoaXMubW91c2VfZG93bl9wcmV2ID0gdGhpcy5tb3VzZV9kb3duXG5cdFx0dGhpcy5tbWJfanVzdF91bnByZXNzZWQgPSBmYWxzZVxuXHRcdHRoaXMubW1iX2p1c3RfcHJlc3NlZCA9IGZhbHNlXG5cdFx0dGhpcy5tb3VzZV93aGVlbCA9IDBcblx0XHR0aGlzLnR3b19maW5nZXJfcGluY2hfcHJldiA9IHRoaXMudHdvX2Zpbmdlcl9waW5jaFxuXHRcdHRoaXMuanVzdF9maW5pc2hlZF9waW5jaCA9IGZhbHNlXG5cdFx0dGhpcy5qdXN0X3N0YXJ0ZWRfcGluY2ggPSBmYWxzZVxuXHRcdE9iamVjdC52YWx1ZXModGhpcy5rZXlzKS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRcdGtleS5qdXN0X3VucHJlc3NlZCA9IGZhbHNlXG5cdFx0XHRrZXkuanVzdF9wcmVzc2VkID0gZmFsc2Vcblx0XHR9KVxuXHR9XG5cdHB1YmxpYyBnZXRLZXkoY29kZTogQnRuQ29kZSk6IGtleVN0YXRlIHtcblx0XHRsZXQga2V5ID0gdGhpcy5rZXlzW2NvZGVdXG5cdFx0aWYgKGtleSkge1xuXHRcdFx0cmV0dXJuIGtleVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4ge2Rvd246IGZhbHNlLCBqdXN0X3ByZXNzZWQ6IGZhbHNlLCBqdXN0X3VucHJlc3NlZDogZmFsc2V9XG5cdFx0fVxuXHR9XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcblx0XHRcdHRoaXMua2V5c1tldmVudC5jb2RlXSA9IHtkb3duOiB0cnVlLCBqdXN0X3ByZXNzZWQ6IHRydWUsIGp1c3RfdW5wcmVzc2VkOiBmYWxzZX1cblx0XHRcdGlmIChldmVudC5jb2RlID09PSAnQWx0TGVmdCcpIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHR9KVxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldmVudCkgPT4ge1xuXHRcdFx0bGV0IGp1c3RfdW5wcmVzc2VkID0gZmFsc2Vcblx0XHRcdGlmICh0aGlzLmdldEtleShldmVudC5jb2RlIGFzIEJ0bkNvZGUpLmRvd24pIGp1c3RfdW5wcmVzc2VkID0gdHJ1ZVxuXHRcdFx0dGhpcy5rZXlzW2V2ZW50LmNvZGVdID0ge2Rvd246IGZhbHNlLCBqdXN0X3ByZXNzZWQ6IGZhbHNlLCBqdXN0X3VucHJlc3NlZDoganVzdF91bnByZXNzZWR9XG5cdFx0fSlcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCAoZSkgPT4ge1xuXHRcdFx0dGhpcy5tb3VzZV93aGVlbCA9IGUuZGVsdGFZIDwgMCA/IDEgOiBlLmRlbHRhWSA+IDAgPyAtMSA6IDBcblx0XHR9KVxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKGUpID0+IHtcblx0XHRcdGlmIChlLmJ1dHRvbiA9PT0gMSkge1xuXHRcdFx0XHR0aGlzLm1tYl9kb3duID0gZmFsc2Vcblx0XHRcdFx0dGhpcy5tbWJfanVzdF91bnByZXNzZWQgPSB0cnVlXG5cdFx0XHR9XG5cdFx0fSlcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGUpID0+IHtcblx0XHRcdGlmIChlLmJ1dHRvbiA9PT0gMSkge1xuXHRcdFx0XHR0aGlzLm1tYl9kb3duID0gdHJ1ZVxuXHRcdFx0XHR0aGlzLm1tYl9qdXN0X3ByZXNzZWQgPSB0cnVlXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4ge1xuXHRcdFx0bGV0IGxfYWx0ID0gdGhpcy5nZXRLZXkoJ0FsdExlZnQnKVxuXHRcdFx0aWYgKGxfYWx0LmRvd24pIHtcblx0XHRcdFx0bF9hbHQuanVzdF91bnByZXNzZWQgPSB0cnVlXG5cdFx0XHRcdGxfYWx0LmRvd24gPSBmYWxzZVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHQvLyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCAoZSkgPT4ge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCAoZSkgPT4ge1xuXHRcdFx0ZnVuY3Rpb24gZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCB0YXJnZXQpIHtcblx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0IHx8IGV2ZW50LnRhcmdldFxuXHRcdFx0XHR2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0eDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcblx0XHRcdFx0XHR5OiBldmVudC5jbGllbnRZIC0gcmVjdC50b3AsXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIGdldE5vUGFkZGluZ05vQm9yZGVyQ2FudmFzUmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCB0YXJnZXQpIHtcblx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0IHx8IGV2ZW50LnRhcmdldFxuXHRcdFx0XHR2YXIgcG9zID0gZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCB0YXJnZXQpXG5cblx0XHRcdFx0cG9zLnggPSAocG9zLnggKiB0YXJnZXQud2lkdGgpIC8gdGFyZ2V0LmNsaWVudFdpZHRoXG5cdFx0XHRcdHBvcy55ID0gKHBvcy55ICogdGFyZ2V0LmhlaWdodCkgLyB0YXJnZXQuY2xpZW50SGVpZ2h0XG5cblx0XHRcdFx0cmV0dXJuIHBvc1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgKGUucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhlKVxuXHRcdFx0bGV0IGdsID0gd2luZG93LmdsXG5cdFx0XHRjb25zdCBwb3MgPSBnZXROb1BhZGRpbmdOb0JvcmRlckNhbnZhc1JlbGF0aXZlTW91c2VQb3NpdGlvbihlLCBnbC5jYW52YXMpXG5cblx0XHRcdGNvbnN0IHggPSAocG9zLnggLyBnbC5jYW52YXMud2lkdGgpICogMiAtIDFcblx0XHRcdGNvbnN0IHkgPSAocG9zLnkgLyBnbC5jYW52YXMuaGVpZ2h0KSAqIC0yICsgMVxuXG5cdFx0XHQvLyB0aGlzLm1vdXNlX3BvcyA9IFt4LCB5XVxuXHRcdFx0dGhpcy5tb3VzZV9wb3NbMF0gPSB4XG5cdFx0XHR0aGlzLm1vdXNlX3Bvc1sxXSA9IHlcblxuXHRcdFx0Y29uc3QgaXNfYmFjayA9IHRoaXMubW91c2VfcG9zaXRpb25zX2Fycl9pZHggPT09IDBcblx0XHRcdGNvbnN0IHBvc2l0aW9ucyA9IGlzX2JhY2sgPyB0aGlzLl9tb3VzZV9wb3NpdGlvbnNfZHVyaW5nX2xhc3RfZnJhbWVfYiA6IHRoaXMuX21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZVxuXHRcdFx0Y29uc3QgaWR4ID0gaXNfYmFjayA/IHRoaXMuX21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZV9jbnRfYiA6IHRoaXMuX21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZV9jbnRcblx0XHRcdHBvc2l0aW9uc1tpZHggKiAyXSA9IHhcblx0XHRcdHBvc2l0aW9uc1tpZHggKiAyICsgMV0gPSB5XG5cdFx0XHRpZiAoaXNfYmFjaykgdGhpcy5fbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2NudF9iKytcblx0XHRcdGVsc2UgdGhpcy5fbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2NudCsrXG5cblx0XHRcdHRoaXMucHJlc3N1cmUgPSBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnID8gMSA6IGUucHJlc3N1cmUgPz8gdGhpcy5wcmVzc3VyZVxuXHRcdFx0dGhpcy5tb3VzZV9qdXN0X21vdmVkID0gdHJ1ZVxuXG5cdFx0XHR0aGlzLnRpbHRbMF0gPSBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnID8gMCA6IGUuYWx0aXR1ZGVBbmdsZSA/PyB0aGlzLnRpbHRbMF1cblx0XHRcdHRoaXMudGlsdFsxXSA9IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgPyAwIDogZS5hemltdXRoQW5nbGUgPz8gdGhpcy50aWx0WzFdXG5cdFx0XHQvLyB9XG5cdFx0fSlcblxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKGUpID0+IHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZS50YXJnZXRUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHRvdWNoID0gZS50YXJnZXRUb3VjaGVzW2ldXG5cdFx0XHRcdGNvbnN0IHRvdWNoX2lkID0gdG91Y2guaWRlbnRpZmllclxuXHRcdFx0XHR0aGlzLnRvdWNoZXNbdG91Y2hfaWRdID0gW3RvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFldXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdGNvbnN0IGxlbmd0aCA9IChheDogbnVtYmVyLCBheTogbnVtYmVyLCBieDogbnVtYmVyLCBieTogbnVtYmVyKTogbnVtYmVyID0+IHtcblx0XHRcdHJldHVybiBzcXJ0KChheCAtIGJ4KSAqIChheCAtIGJ4KSArIChheSAtIGJ5KSAqIChheSAtIGJ5KSlcblx0XHR9XG5cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgKGUpID0+IHtcblx0XHRcdGlmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdGlmICh0aGlzLnR3b19maW5nZXJfcGluY2ggPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Ly8gYmVnaW4gcGluY2hcblx0XHRcdFx0XHR0aGlzLnRvdWNoZXNfc3RhcnRpbmdfcG9zaXRpb25zWzBdID0gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFhcblx0XHRcdFx0XHR0aGlzLnRvdWNoZXNfc3RhcnRpbmdfcG9zaXRpb25zWzFdID0gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFlcblx0XHRcdFx0XHR0aGlzLnRvdWNoZXNfc3RhcnRpbmdfcG9zaXRpb25zWzJdID0gZS50YXJnZXRUb3VjaGVzWzFdLmNsaWVudFhcblx0XHRcdFx0XHR0aGlzLnRvdWNoZXNfc3RhcnRpbmdfcG9zaXRpb25zWzNdID0gZS50YXJnZXRUb3VjaGVzWzFdLmNsaWVudFlcblx0XHRcdFx0XHR0aGlzLnRvdWNoZXNfc3RhcnRpbmdfbWlkX3BvaW50WzBdID0gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFggKiAwLjUgKyBlLnRhcmdldFRvdWNoZXNbMV0uY2xpZW50WCAqIDAuNVxuXHRcdFx0XHRcdHRoaXMudG91Y2hlc19zdGFydGluZ19taWRfcG9pbnRbMV0gPSBlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WSAqIDAuNSArIGUudGFyZ2V0VG91Y2hlc1sxXS5jbGllbnRZICogMC41XG5cdFx0XHRcdFx0dGhpcy5waW5jaF96b29tID0gMFxuXHRcdFx0XHRcdHRoaXMudG91Y2hlc19zdGFydGluZ19sZW5ndGggPSBsZW5ndGgoXG5cdFx0XHRcdFx0XHRlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WCxcblx0XHRcdFx0XHRcdGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZLFxuXHRcdFx0XHRcdFx0ZS50YXJnZXRUb3VjaGVzWzFdLmNsaWVudFgsXG5cdFx0XHRcdFx0XHRlLnRhcmdldFRvdWNoZXNbMV0uY2xpZW50WSxcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0dGhpcy50b3VjaGVzX21pZF9wb2ludF9wcmV2WzBdID0gdGhpcy50b3VjaGVzX3N0YXJ0aW5nX21pZF9wb2ludFswXVxuXHRcdFx0XHRcdHRoaXMudG91Y2hlc19taWRfcG9pbnRfcHJldlsxXSA9IHRoaXMudG91Y2hlc19zdGFydGluZ19taWRfcG9pbnRbMV1cblx0XHRcdFx0XHR0aGlzLnBpbmNoX3Bvc1swXSA9IDBcblx0XHRcdFx0XHR0aGlzLnBpbmNoX3Bvc1sxXSA9IDBcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnR3b19maW5nZXJfcGluY2ggPSB0cnVlXG5cdFx0XHRcdGNvbnN0IG1pZF9wb2ludF94ID0gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFggKiAwLjUgKyBlLnRhcmdldFRvdWNoZXNbMV0uY2xpZW50WCAqIDAuNVxuXHRcdFx0XHRjb25zdCBtaWRfcG9pbnRfeSA9IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZICogMC41ICsgZS50YXJnZXRUb3VjaGVzWzFdLmNsaWVudFkgKiAwLjVcblxuXHRcdFx0XHRjb25zdCBsZW4gPSBsZW5ndGgoXG5cdFx0XHRcdFx0ZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFgsXG5cdFx0XHRcdFx0ZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFksXG5cdFx0XHRcdFx0ZS50YXJnZXRUb3VjaGVzWzFdLmNsaWVudFgsXG5cdFx0XHRcdFx0ZS50YXJnZXRUb3VjaGVzWzFdLmNsaWVudFksXG5cdFx0XHRcdClcblx0XHRcdFx0Y29uc3QgcmVzID0gbWluKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpXG5cdFx0XHRcdHRoaXMucGluY2hfem9vbSA9ICgobGVuIC0gdGhpcy50b3VjaGVzX3N0YXJ0aW5nX2xlbmd0aCkgLyByZXMpICogNFxuXG5cdFx0XHRcdHRoaXMucGluY2hfcG9zWzBdICs9ICgoKG1pZF9wb2ludF94IC0gdGhpcy50b3VjaGVzX21pZF9wb2ludF9wcmV2WzBdKSAvIHJlcykgKiAyKSAvIHdpbmRvdy56b29tWzBdXG5cdFx0XHRcdHRoaXMucGluY2hfcG9zWzFdICs9ICgoKG1pZF9wb2ludF95IC0gdGhpcy50b3VjaGVzX21pZF9wb2ludF9wcmV2WzFdKSAvIHJlcykgKiAyKSAvIHdpbmRvdy56b29tWzBdXG5cdFx0XHRcdHRoaXMudG91Y2hlc19taWRfcG9pbnRfcHJldlswXSA9IG1pZF9wb2ludF94XG5cdFx0XHRcdHRoaXMudG91Y2hlc19taWRfcG9pbnRfcHJldlsxXSA9IG1pZF9wb2ludF95XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy50d29fZmluZ2VyX3BpbmNoID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0dGhpcy50d29fZmluZ2VyX3BpbmNoID0gZmFsc2Vcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRjb25zdCB0b3VjaF9lbmQgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuXHRcdFx0Zm9yIChjb25zdCBpZCBpbiBPYmplY3Qua2V5cyh0aGlzLnRvdWNoZXMpKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLnRvdWNoZXNbaWRdXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnR3b19maW5nZXJfcGluY2ggPSBmYWxzZVxuXHRcdH1cblxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIChlKSA9PiB7XG5cdFx0XHR0b3VjaF9lbmQoZSlcblx0XHR9KVxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIChlKSA9PiB7XG5cdFx0XHR0b3VjaF9lbmQoZSlcblx0XHR9KVxuXG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgKGUpID0+IHtcblx0XHRcdHRoaXMucG9pbnRlclR5cGUgPSBlLnBvaW50ZXJUeXBlXG5cdFx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyAmJiBlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuXG5cdFx0XHR0aGlzLm1vdXNlX2Rvd24gPSB0cnVlXG5cdFx0fSlcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsICgpID0+IHtcblx0XHRcdHRoaXMubW91c2VfZG93biA9IGZhbHNlXG5cdFx0fSlcblx0fVxufVxuIiwiaW1wb3J0IHtwYXVzZV9vbl9nbF9lcnJvcn0gZnJvbSAnZ2xfdXRpbHMnXG5pbXBvcnQge3R5cGUgQXR0cmliUG9pbnRlclBhcmFtc30gZnJvbSAnLi9UaGluZydcblxuZXhwb3J0IGNsYXNzIFVCTyB7XG5cdC8vIGJ1ZmY6IFdlYkdMQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCkgYXMgV2ViR0xCdWZmZXJcblx0YnVmZjogVmVydGV4QnVmZmVyXG5cdHVuaWZvcm1zOiAobnVtYmVyIHwgc3RyaW5nKVtdID0gW11cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0Ly8gZ2wuYmluZEJ1ZmZlcihnbC5VTklGT1JNX0JVRkZFUiwgdGhpcy5idWZmKVxuXHRcdC8vIGdsLmJ1ZmZlckRhdGEoZ2wuVU5JRk9STV9CVUZGRVIsIDMyICogNCwgZ2wuRFlOQU1JQ19EUkFXKVxuXHRcdC8vIHRoaXMuYnVmZiA9IG5ldyBWZXJ0ZXhCdWZmZXIoMCwgZ2wuRkxPQVQsIDMyICogNCAqIDQgKiA0LCBnbC5VTklGT1JNX0JVRkZFUilcblx0XHR0aGlzLmJ1ZmYgPSBuZXcgVmVydGV4QnVmZmVyKDAsIGdsLkZMT0FULCA5NiwgZ2wuVU5JRk9STV9CVUZGRVIpXG5cdFx0Z2wuYmluZEJ1ZmZlckJhc2UoZ2wuVU5JRk9STV9CVUZGRVIsIDAsIHRoaXMuYnVmZi5idWZmKVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBWZXJ0ZXhCdWZmZXIge1xuXHRidWZmOiBXZWJHTEJ1ZmZlclxuXG5cdGNwdV9idWZmOiBGbG9hdDMyQXJyYXkgfCBJbnQzMkFycmF5IHwgVWludDMyQXJyYXlcblx0dHlwZTogbnVtYmVyXG5cdHVzYWdlOiBudW1iZXJcblxuXHRzdHJpZGU6IG51bWJlclxuXHRzaW5nbGVfdmVydF9zejogbnVtYmVyXG5cdHN6OiBudW1iZXJcblx0bWF4X3N6OiBudW1iZXJcblxuXHRjb25zdHJ1Y3RvcihzaW5nbGVfdmVydF9zejogbnVtYmVyLCB0eXBlOiBudW1iZXIgPSBnbC5GTE9BVCwgbWF4X3NpemU6IG51bWJlciA9IDEwMDAwMDAwLCB1c2FnZTogbnVtYmVyID0gZ2wuQVJSQVlfQlVGRkVSKSB7XG5cdFx0dGhpcy5idWZmID0gZ2wuY3JlYXRlQnVmZmVyKCkgYXMgV2ViR0xCdWZmZXJcblx0XHR0aGlzLnVzYWdlID0gdXNhZ2Vcblx0XHRnbC5iaW5kQnVmZmVyKHVzYWdlLCB0aGlzLmJ1ZmYpXG5cdFx0dGhpcy50eXBlID0gdHlwZVxuXG5cdFx0dGhpcy5zaW5nbGVfdmVydF9zeiA9IHNpbmdsZV92ZXJ0X3N6XG5cdFx0dGhpcy5tYXhfc3ogPSBtYXhfc2l6ZVxuXHRcdHRoaXMuc3RyaWRlID0gMFxuXG5cdFx0aWYgKHR5cGUgPT09IGdsLkZMT0FUKSB7XG5cdFx0XHR0aGlzLmNwdV9idWZmID0gbmV3IEZsb2F0MzJBcnJheShtYXhfc2l6ZSlcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IGdsLklOVCkge1xuXHRcdFx0dGhpcy5jcHVfYnVmZiA9IG5ldyBJbnQzMkFycmF5KG1heF9zaXplKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNwdV9idWZmID0gbmV3IFVpbnQzMkFycmF5KG1heF9zaXplKVxuXHRcdH1cblxuXHRcdC8vIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNwdV9idWZmLCBnbC5EWU5BTUlDX0RSQVcpXG5cdFx0Ly8gZ2wuYnVmZmVyRGF0YSh1c2FnZSwgdGhpcy5jcHVfYnVmZi5sZW5ndGggKiB0aGlzLmNwdV9idWZmLkJZVEVTX1BFUl9FTEVNRU5ULCBnbC5EWU5BTUlDX0RSQVcpXG5cdFx0Z2wuYnVmZmVyRGF0YSh1c2FnZSwgdGhpcy5jcHVfYnVmZi5ieXRlTGVuZ3RoLCBnbC5EWU5BTUlDX0RSQVcpXG5cdFx0dGhpcy5zeiA9IDBcblx0fVxuXG5cdGJpbmRUb0F0dHJpYihpZHg6IG51bWJlciwgcGFyYW1zOiBBdHRyaWJQb2ludGVyUGFyYW1zIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHBhcmFtcykge1xuXHRcdFx0Z2wuYmluZEJ1ZmZlcih0aGlzLnVzYWdlLCB0aGlzLmJ1ZmYpXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuXHRcdFx0XHRpZHgsXG5cdFx0XHRcdHBhcmFtcy52ZXJ0X3N6ID8/IHRoaXMuc2luZ2xlX3ZlcnRfc3osXG5cdFx0XHRcdHBhcmFtcy50eXBlID8/IHRoaXMudHlwZSxcblx0XHRcdFx0ZmFsc2UsXG5cdFx0XHRcdHBhcmFtcy5zdHJpZGUgPz8gdGhpcy5zdHJpZGUsXG5cdFx0XHRcdHBhcmFtcy5vZmZzZXQgPz8gMCxcblx0XHRcdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2wuYmluZEJ1ZmZlcih0aGlzLnVzYWdlLCB0aGlzLmJ1ZmYpXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGlkeCwgdGhpcy5zaW5nbGVfdmVydF9zeiwgdGhpcy50eXBlLCBmYWxzZSwgdGhpcy5zdHJpZGUsIDApXG5cdFx0fVxuXHR9XG5cdHB1c2hfdmVydCh2ZXJ0OiBudW1iZXJbXSkge1xuXHRcdGlmICh2ZXJ0Lmxlbmd0aCAhPT0gdGhpcy5zaW5nbGVfdmVydF9zeikge1xuXHRcdFx0Ly8gZGVidWdnZXJcblx0XHR9XG5cdFx0Zm9yIChsZXQgdiBvZiB2ZXJ0KSB7XG5cdFx0XHR0aGlzLmNwdV9idWZmW3RoaXMuc3orK10gPSB2XG5cdFx0fVxuXHR9XG5cdHVwbG9hZF9leHRlcm5hbF9hcnJheShpbnB1dF9idWZmOiBudW1iZXJbXSB8IEZsb2F0MzJBcnJheSkge1xuXHRcdGlmIChpbnB1dF9idWZmIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGdsLmJpbmRCdWZmZXIodGhpcy51c2FnZSwgdGhpcy5idWZmKVxuXHRcdFx0bGV0IF9idWZmID0gRmxvYXQzMkFycmF5LmZyb20oaW5wdXRfYnVmZilcblx0XHRcdHRoaXMuc3ogPSBfYnVmZi5sZW5ndGhcblx0XHRcdC8vIGNvbnN0IHN6X2luX2J5dGVzID0gX2J1ZmYubGVuZ3RoICogX2J1ZmYuQllURVNfUEVSX0VMRU1FTlRcblx0XHRcdGNvbnN0IHN6X2luX2J5dGVzID0gX2J1ZmYuYnl0ZUxlbmd0aFxuXG5cdFx0XHQvLyBjb25zb2xlLmxvZygnQkVHSU4gQlVGRiBQUklOVCcpXG5cdFx0XHQvLyBjb25zb2xlLmxvZyhfYnVmZilcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdsZW4nKVxuXHRcdFx0Ly8gY29uc29sZS5sb2coX2J1ZmYubGVuZ3RoKVxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ3N6IGJ5ZXMnKVxuXHRcdFx0Ly8gY29uc29sZS5sb2coc3pfaW5fYnl0ZXMpXG5cdFx0XHQvLyBpZiAoX2J1ZmYubGVuZ3RoID4gMCkgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIF9idWZmLCBnbC5EWU5BTUlDX0RSQVcsIDAsIHN6X2luX2J5dGVzKVxuXHRcdFx0Ly8gaWYgKF9idWZmLmxlbmd0aCA+IDApIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBfYnVmZiwgZ2wuRFlOQU1JQ19EUkFXLCAwKVxuXHRcdFx0Ly8gaWYgKF9idWZmLmxlbmd0aCA+IDApIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBfYnVmZiwgZ2wuRFlOQU1JQ19EUkFXLCAwLCBzel9pbl9ieXRlcylcblx0XHRcdC8vIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBfYnVmZiwgZ2wuRFlOQU1JQ19EUkFXLCAwLCBzel9pbl9ieXRlcylcblxuXHRcdFx0Ly8gZ2wuYnVmZmVyU3ViRGF0YSh0aGlzLnVzYWdlLCAwLCBfYnVmZiwgMCwgc3pfaW5fYnl0ZXMpXG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKHRoaXMudXNhZ2UsIDAsIF9idWZmKVxuXHRcdFx0cGF1c2Vfb25fZ2xfZXJyb3IoKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRnbC5iaW5kQnVmZmVyKHRoaXMudXNhZ2UsIHRoaXMuYnVmZilcblx0XHRcdC8vIGNvbnN0IHN6X2luX2J5dGVzID0gaW5wdXRfYnVmZi5sZW5ndGggKiBpbnB1dF9idWZmLkJZVEVTX1BFUl9FTEVNRU5UXG5cdFx0XHRjb25zdCBzel9pbl9ieXRlcyA9IGlucHV0X2J1ZmYuYnl0ZUxlbmd0aFxuXHRcdFx0Ly8gZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGlucHV0X2J1ZmYsIGdsLkRZTkFNSUNfRFJBVywgMCwgc3pfaW5fYnl0ZXMpXG5cdFx0XHQvLyBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgaW5wdXRfYnVmZiwgMCwgc3pfaW5fYnl0ZXMpXG5cdFx0XHQvLyBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgc3pfaW5fYnl0ZXMsIGdsLkRZTkFNSUNfRFJBVylcblx0XHRcdC8vIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCBpbnB1dF9idWZmLCAwLCBzel9pbl9ieXRlcylcblx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEodGhpcy51c2FnZSwgMCwgaW5wdXRfYnVmZilcblxuXHRcdFx0Ly8gZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsMCwgaW5wdXRfYnVmZi5idWZmZXIsIGdsLkRZTkFNSUNfRFJBVylcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdC8vIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBpbnB1dF9idWZmLmJ1ZmZlciwgZ2wuRFlOQU1JQ19EUkFXKVxuXHRcdFx0cGF1c2Vfb25fZ2xfZXJyb3IoKVxuXHRcdH1cblx0fVxuXHR1cGxvYWQoKSB7XG5cdFx0Z2wuYmluZEJ1ZmZlcih0aGlzLnVzYWdlLCB0aGlzLmJ1ZmYpXG5cdFx0Y29uc3Qgc3pfaW5fYnl0ZXMgPSB0aGlzLnN6ICogdGhpcy5jcHVfYnVmZi5CWVRFU19QRVJfRUxFTUVOVFxuXHRcdC8vIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNwdV9idWZmLCBnbC5EWU5BTUlDX0RSQVcsIDAsIHN6X2luX2J5dGVzKVxuXHRcdGdsLmJ1ZmZlclN1YkRhdGEodGhpcy51c2FnZSwgMCwgdGhpcy5jcHVfYnVmZiwgMCwgc3pfaW5fYnl0ZXMpXG5cdFx0cGF1c2Vfb25fZ2xfZXJyb3IoKVxuXHR9XG59XG4iLCJpbXBvcnQge1RleHR1cmV9IGZyb20gJy4vVGV4dHVyZSdcblxuZXhwb3J0IGNsYXNzIFNoYWRlclByb2dyYW0ge1xuXHRwcm9ncmFtOiBXZWJHTFByb2dyYW1cblx0bG9hZFNoYWRlcih0eXBlOiBudW1iZXIsIHNvdXJjZTogc3RyaW5nKSB7XG5cdFx0c291cmNlID0gc291cmNlLnJlcGxhY2VBbGwoJ2V4cG9ydCBkZWZhdWx0IFwiJywgYGApXG5cdFx0c291cmNlID0gc291cmNlLnJlcGxhY2VBbGwoJ1wiOycsIGBgKVxuXHRcdHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlQWxsKCdcIicsIGBgKVxuXHRcdHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlQWxsKFxuXHRcdFx0YFxcXFxuYCxcblx0XHRcdGBcblx0XHRgLFxuXHRcdClcblx0XHRzb3VyY2UgPSBzb3VyY2UucmVwbGFjZShcblx0XHRcdC8oLiopKCN2ZXJzaW9uIDMwMCBlcylbXFx0XFxzXSovZyxcblx0XHRcdGAkMlxuXHRcdFx0YCxcblx0XHQpXG5cdFx0c291cmNlID0gc291cmNlLnJlcGxhY2VBbGwoXG5cdFx0XHQvKCNkZWZpbmUgLispW1xcdFxcc10qL2csXG5cdFx0XHRgXG5cdFx0JDFcblx0XHRgLFxuXHRcdClcblx0XHRzb3VyY2UgPSBzb3VyY2UucmVwbGFjZUFsbChcblx0XHRcdC9cdCtwcmVjaXNpb24gaGlnaHAgZmxvYXQ7L2dtLFxuXHRcdFx0YHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblx0XHRcdGAsXG5cdFx0KVxuXHRcdHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlQWxsKGBcXFxcdGAsIGBcdGApXG5cdFx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpIGFzIFdlYkdMU2hhZGVyXG5cblx0XHRnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpXG5cdFx0Z2wuY29tcGlsZVNoYWRlcihzaGFkZXIpXG5cdFx0aWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEFuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgc2hhZGVyczogJHtnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcil9YClcblx0XHRcdGNvbnNvbGUuZXJyb3Ioc291cmNlKVxuXHRcdH1cblx0XHRyZXR1cm4gc2hhZGVyXG5cdH1cblx0Y29uc3RydWN0b3IodnMsIGZzKSB7XG5cdFx0Y29uc3QgdmVydGV4U2hhZGVyID0gdGhpcy5sb2FkU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIsIHZzKVxuXHRcdGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5sb2FkU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUiwgZnMpXG5cblx0XHRjb25zdCBzaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpIGFzIFdlYkdMUHJvZ3JhbVxuXHRcdGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIGZyYWdtZW50U2hhZGVyKVxuXHRcdGdsLmxpbmtQcm9ncmFtKHNoYWRlclByb2dyYW0pXG5cblx0XHRpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBVbmFibGUgdG8gaW5pdGlhbGl6ZSB0aGUgc2hhZGVyIHByb2dyYW06ICR7Z2wuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyUHJvZ3JhbSl9YClcblx0XHRcdGNvbnNvbGUuZXJyb3IodnMpXG5cdFx0XHRjb25zb2xlLmVycm9yKGZzKVxuXHRcdH1cblxuXHRcdHRoaXMucHJvZ3JhbSA9IHNoYWRlclByb2dyYW1cblx0XHRnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSlcblx0XHRnbC51bmlmb3JtQmxvY2tCaW5kaW5nKHRoaXMucHJvZ3JhbSwgMCwgMClcblx0fVxuXHR1c2UoKSB7XG5cdFx0Z2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pXG5cdH1cblx0c2V0VW5pZm9ybVZlYyhuYW1lOiBzdHJpbmcsIHZlYzogbnVtYmVyW10pIHtcblx0XHRpZiAodmVjLmxlbmd0aCA9PSAyKSBnbC51bmlmb3JtMmZ2KGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpLCB2ZWMpXG5cdFx0ZWxzZSBpZiAodmVjLmxlbmd0aCA9PSAzKSBnbC51bmlmb3JtM2Z2KGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpLCB2ZWMpXG5cdFx0ZWxzZSBpZiAodmVjLmxlbmd0aCA9PSA0KSBnbC51bmlmb3JtNGZ2KGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpLCB2ZWMpXG5cdH1cblx0c2V0VW5pZm9ybUZsb2F0KG5hbWU6IHN0cmluZywgdmFsdWU6IG51bWJlcikge1xuXHRcdGdsLnVuaWZvcm0xZihnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKSwgdmFsdWUpXG5cdH1cblx0c2V0VW5pZm9ybUludChuYW1lOiBzdHJpbmcsIHZhbHVlOiBudW1iZXIpIHtcblx0XHRnbC51bmlmb3JtMWkoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSksIHZhbHVlKVxuXHR9XG5cdHNldFVuaWZvcm1UZXh0dXJlKG5hbWU6IHN0cmluZywgdGV4dHVyZTogVGV4dHVyZSwgYmluZGluZzogbnVtYmVyID0gMCkge1xuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBiaW5kaW5nKVxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUudGV4KVxuXHRcdGdsLnVuaWZvcm0xaShnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKSwgYmluZGluZylcblx0fVxufVxuIiwiaW1wb3J0IHtWZXJ0ZXhCdWZmZXJ9IGZyb20gJy4vQnVmZmVyJ1xuaW1wb3J0IHtTaGFkZXJQcm9ncmFtfSBmcm9tICcuL1NoYWRlclByb2dyYW0nXG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVmZkJpbmRpbmcge1xuXHRidWZmOiBWZXJ0ZXhCdWZmZXJcblx0cGFyYW1zPzogQXR0cmliUG9pbnRlclBhcmFtc1xufVxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJQb2ludGVyUGFyYW1zIHtcblx0dmVydF9zej86IG51bWJlclxuXHRzdHJpZGU/OiBudW1iZXJcblx0dHlwZT86IG51bWJlclxuXHRvZmZzZXQ/OiBudW1iZXJcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRHJhd1BhcmFtcyB7XG5cdHByaW1fdHlwZT86IG51bWJlclxuXHRkcmF3X2NudD86IG51bWJlclxufVxuXG5leHBvcnQgY2xhc3MgVGhpbmcge1xuXHR2YW86IFdlYkdMVmVydGV4QXJyYXlPYmplY3Rcblx0YnVmZnM6IFZlcnRleEJ1ZmZlcltdXG5cdHNoYWRlcjogU2hhZGVyUHJvZ3JhbVxuXHRwcmltX3R5cGU6IG51bWJlclxuXG5cdGNvbnN0cnVjdG9yKGJ1ZmZzOiBWZXJ0ZXhCdWZmZXJbXSwgcHJpbV90eXBlOiBudW1iZXIgPSBnbC5UUklBTkdMRVMsIHNoYWRlcjogU2hhZGVyUHJvZ3JhbSkge1xuXHRcdHRoaXMucHJpbV90eXBlID0gcHJpbV90eXBlXG5cdFx0dGhpcy5zaGFkZXIgPSBzaGFkZXJcblx0XHR0aGlzLnZhbyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCkgYXMgV2ViR0xWZXJ0ZXhBcnJheU9iamVjdFxuXHRcdHRoaXMuYnVmZnMgPSBbLi4uYnVmZnNdXG5cdFx0Z2wuYmluZFZlcnRleEFycmF5KHRoaXMudmFvKVxuXHRcdGxldCBpID0gMFxuXHRcdGZvciAobGV0IGJ1ZmYgb2YgdGhpcy5idWZmcykge1xuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSlcblx0XHRcdGJ1ZmYuYmluZFRvQXR0cmliKGkpXG5cdFx0XHRpKytcblx0XHR9XG5cdH1cblx0c3RhdGljIGRyYXdfZXh0ZXJuYWxfYnVmZnNfYW5kX3NoYWRlcihidWZmczogQnVmZkJpbmRpbmdbXSwgc2hhZGVyOiBTaGFkZXJQcm9ncmFtLCBwYXJhbXM6IERyYXdQYXJhbXMpIHtcblx0XHRzaGFkZXIudXNlKClcblx0XHQvLyBnbC5iaW5kVmVydGV4QXJyYXkoZ2wuZGVmYXVsdFZhbylcblx0XHQvLyBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoMClcblx0XHQvLyBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoMSlcblx0XHRsZXQgaSA9IDBcblx0XHQvLyBmb3IgKGxldCBidWZmIG9mIGJ1ZmZzKSB7XG5cdFx0Ly8gXHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpKVxuXHRcdC8vIFx0YnVmZi5idWZmLmJpbmRUb0F0dHJpYihpLCBidWZmLnBhcmFtcyA/PyB1bmRlZmluZWQpXG5cdFx0Ly8gXHRpKytcblx0XHQvLyB9XG5cdFx0cGFyYW1zLnByaW1fdHlwZSA9IHBhcmFtcy5wcmltX3R5cGUgPz8gZ2wuVFJJQU5HTEVTXG5cdFx0cGFyYW1zLmRyYXdfY250ID0gcGFyYW1zLmRyYXdfY250ID8/IGJ1ZmZzWzBdLmJ1ZmYuc3ogLyBidWZmc1swXS5idWZmLnNpbmdsZV92ZXJ0X3N6XG5cblx0XHRpZiAocGFyYW1zLnByaW1fdHlwZSA9PT0gZ2wuVFJJQU5HTEVTKSB7XG5cdFx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgcGFyYW1zLmRyYXdfY250KVxuXHRcdFx0Y29uc29sZS5sb2coJ0RSRVcnKVxuXHRcdFx0Y29uc29sZS5sb2cocGFyYW1zLmRyYXdfY250KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbGVydCgnYmxlZXAgYmxvb3AgZXJycm9ycnInKVxuXHRcdH1cblx0fVxuXG5cdHVwbG9hZF9hbGxfYnVmZnMoKSB7XG5cdFx0Zm9yIChsZXQgYnVmZiBvZiB0aGlzLmJ1ZmZzKSB7XG5cdFx0XHRidWZmLnVwbG9hZCgpXG5cdFx0fVxuXHR9XG5cdGRyYXdfd2l0aF9leHRlcm5hbF9zaGFkZXIoc2hhZGVyOiBTaGFkZXJQcm9ncmFtKSB7XG5cdFx0c2hhZGVyLnVzZSgpXG5cdFx0aWYgKHRoaXMucHJpbV90eXBlID09PSBnbC5UUklBTkdMRVMpIHtcblx0XHRcdGxldCBkcmF3X2NudCA9IHRoaXMuYnVmZnNbMF0uc3ogLyB0aGlzLmJ1ZmZzWzBdLnNpbmdsZV92ZXJ0X3N6XG5cdFx0XHRnbC5kcmF3QXJyYXlzKHRoaXMucHJpbV90eXBlLCAwLCBkcmF3X2NudClcblx0XHR9IGVsc2Uge1xuXHRcdFx0YWxlcnQoJ2JsZWVwIGJsb29wIGVycnJvcnJyJylcblx0XHR9XG5cdFx0Ly8gZ2wuYmluZFZlcnRleEFycmF5KGdsLmRlZmF1bHRWYW8pXG5cdH1cblxuXHRkcmF3KG9mZnM6IG51bWJlciA9IDApIHtcblx0XHR0aGlzLmRyYXdfd2l0aF9leHRlcm5hbF9zaGFkZXIodGhpcy5zaGFkZXIpXG5cdH1cbn1cbiIsImltcG9ydCB7VXRpbHN9IGZyb20gJ3N0dWZmJ1xuaW1wb3J0IHtCcnVzaFN0cm9rZSwgQnJ1c2hUeXBlfSBmcm9tICdicnVzaF9zdHJva2UnXG5pbXBvcnQge2NvcywgZmxvb3IsIHNpbn0gZnJvbSAnd21hdGgnXG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCdcbmltcG9ydCBsaWJ0ZXNzIGZyb20gJ2xpYnRlc3MnXG5pbXBvcnQge0ZyYW1lYnVmZmVyfSBmcm9tICdnbC9GcmFtZWJ1ZmZlcidcbmltcG9ydCB7VGV4dHVyZX0gZnJvbSAnZ2wvVGV4dHVyZSdcbmltcG9ydCB7VGhpbmd9IGZyb20gJ2dsL1RoaW5nJ1xuY29uc3QgdGVzc3kgPSAoZnVuY3Rpb24gaW5pdFRlc3NlbGF0b3IoKSB7XG5cdC8vIGZ1bmN0aW9uIGNhbGxlZCBmb3IgZWFjaCB2ZXJ0ZXggb2YgdGVzc2VsYXRvciBvdXRwdXRcblx0ZnVuY3Rpb24gdmVydGV4Q2FsbGJhY2soZGF0YSwgcG9seVZlcnRBcnJheSkge1xuXHRcdC8vIGNvbnNvbGUubG9nKGRhdGFbMF0sIGRhdGFbMV0pO1xuXHRcdHBvbHlWZXJ0QXJyYXlbcG9seVZlcnRBcnJheS5sZW5ndGhdID0gZGF0YVswXVxuXHRcdHBvbHlWZXJ0QXJyYXlbcG9seVZlcnRBcnJheS5sZW5ndGhdID0gZGF0YVsxXVxuXHR9XG5cdGZ1bmN0aW9uIGJlZ2luY2FsbGJhY2sodHlwZSkge1xuXHRcdGlmICh0eXBlICE9PSBsaWJ0ZXNzLnByaW1pdGl2ZVR5cGUuR0xfVFJJQU5HTEVTKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnZXhwZWN0ZWQgVFJJQU5HTEVTIGJ1dCBnb3QgdHlwZTogJyArIHR5cGUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGVycm9yY2FsbGJhY2soZXJybm8pIHtcblx0XHRjb25zb2xlLmxvZygnZXJyb3IgY2FsbGJhY2snKVxuXHRcdGNvbnNvbGUubG9nKCdlcnJvciBudW1iZXI6ICcgKyBlcnJubylcblx0fVxuXHQvLyBjYWxsYmFjayBmb3Igd2hlbiBzZWdtZW50cyBpbnRlcnNlY3QgYW5kIG11c3QgYmUgc3BsaXRcblx0ZnVuY3Rpb24gY29tYmluZWNhbGxiYWNrKGNvb3JkcywgZGF0YSwgd2VpZ2h0KSB7XG5cdFx0Ly8gY29uc29sZS5sb2coJ2NvbWJpbmUgY2FsbGJhY2snKTtcblx0XHRyZXR1cm4gW2Nvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl1dXG5cdH1cblx0ZnVuY3Rpb24gZWRnZUNhbGxiYWNrKGZsYWcpIHtcblx0XHQvLyBkb24ndCByZWFsbHkgY2FyZSBhYm91dCB0aGUgZmxhZywgYnV0IG5lZWQgbm8tc3RyaXAvbm8tZmFuIGJlaGF2aW9yXG5cdFx0Ly8gY29uc29sZS5sb2coJ2VkZ2UgZmxhZzogJyArIGZsYWcpO1xuXHR9XG5cblx0Y29uc3QgdGVzc3kgPSBuZXcgbGlidGVzcy5HbHVUZXNzZWxhdG9yKClcblx0Ly8gdGVzc3kuZ2x1VGVzc1Byb3BlcnR5KGxpYnRlc3MuZ2x1RW51bS5HTFVfVEVTU19XSU5ESU5HX1JVTEUsIGxpYnRlc3Mud2luZGluZ1J1bGUuR0xVX1RFU1NfV0lORElOR19QT1NJVElWRSk7XG5cdHRlc3N5LmdsdVRlc3NDYWxsYmFjayhsaWJ0ZXNzLmdsdUVudW0uR0xVX1RFU1NfVkVSVEVYX0RBVEEsIHZlcnRleENhbGxiYWNrKVxuXHR0ZXNzeS5nbHVUZXNzQ2FsbGJhY2sobGlidGVzcy5nbHVFbnVtLkdMVV9URVNTX0JFR0lOLCBiZWdpbmNhbGxiYWNrKVxuXHR0ZXNzeS5nbHVUZXNzQ2FsbGJhY2sobGlidGVzcy5nbHVFbnVtLkdMVV9URVNTX0VSUk9SLCBlcnJvcmNhbGxiYWNrKVxuXHR0ZXNzeS5nbHVUZXNzQ2FsbGJhY2sobGlidGVzcy5nbHVFbnVtLkdMVV9URVNTX0NPTUJJTkUsIGNvbWJpbmVjYWxsYmFjaylcblx0dGVzc3kuZ2x1VGVzc0NhbGxiYWNrKGxpYnRlc3MuZ2x1RW51bS5HTFVfVEVTU19FREdFX0ZMQUcsIGVkZ2VDYWxsYmFjaylcblxuXHRyZXR1cm4gdGVzc3lcbn0pKClcblxuZnVuY3Rpb24gdHJpYW5ndWxhdGUoY29udG91cnMpIHtcblx0Ly8gbGlidGVzcyB3aWxsIHRha2UgM2QgdmVydHMgYW5kIGZsYXR0ZW4gdG8gYSBwbGFuZSBmb3IgdGVzc2VsYXRpb25cblx0Ly8gc2luY2Ugb25seSBkb2luZyAyZCB0ZXNzZWxhdGlvbiBoZXJlLCBwcm92aWRlIHo9MSBub3JtYWwgdG8gc2tpcFxuXHQvLyBpdGVyYXRpbmcgb3ZlciB2ZXJ0cyBvbmx5IHRvIGdldCB0aGUgc2FtZSBhbnN3ZXIuXG5cdC8vIGNvbW1lbnQgb3V0IHRvIHRlc3Qgbm9ybWFsLWdlbmVyYXRpb24gY29kZVxuXHR0ZXNzeS5nbHVUZXNzTm9ybWFsKDAsIDAsIDEpXG5cblx0Y29uc3QgdHJpYW5nbGVWZXJ0cyA9IFtdXG5cdHRlc3N5LmdsdVRlc3NCZWdpblBvbHlnb24odHJpYW5nbGVWZXJ0cylcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRvdXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGVzc3kuZ2x1VGVzc0JlZ2luQ29udG91cigpXG5cdFx0bGV0IGNvbnRvdXIgPSBjb250b3Vyc1tpXVxuXHRcdGZvciAobGV0IGogPSAwOyBqIDwgY29udG91ci5sZW5ndGg7IGogKz0gMikge1xuXHRcdFx0Y29uc3QgY29vcmRzID0gW2NvbnRvdXJbal0sIGNvbnRvdXJbaiArIDFdLCAwXVxuXHRcdFx0dGVzc3kuZ2x1VGVzc1ZlcnRleChjb29yZHMsIGNvb3Jkcylcblx0XHR9XG5cdFx0dGVzc3kuZ2x1VGVzc0VuZENvbnRvdXIoKVxuXHR9XG5cblx0Ly8gZmluaXNoIHBvbHlnb24gKGFuZCB0aW1lIHRyaWFuZ3VsYXRpb24gcHJvY2Vzcylcblx0Ly8gY29uc3Qgc3RhcnRUaW1lID0gd2luZG93Lm5vd2lzaCgpXG5cdHRlc3N5LmdsdVRlc3NFbmRQb2x5Z29uKClcblx0Ly8gY29uc3QgZW5kVGltZSA9IHdpbmRvdy5ub3dpc2goKVxuXHQvLyBjb25zb2xlLmxvZygndGVzc2VsYXRpb24gdGltZTogJyArIChlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0ZpeGVkKDIpICsgJ21zJylcblxuXHRyZXR1cm4gdHJpYW5nbGVWZXJ0c1xufVxuXG5jb25zdCBnZXRfc3ViYXJyYXkgPSAoYXJyOiBGbG9hdDMyQXJyYXksIG9mZnNfYmVnaW46IG51bWJlciwgb2Zmc19lbmQ6IG51bWJlcik6IFtGbG9hdDMyQXJyYXksIG51bWJlcl0gPT4ge1xuXHRyZXR1cm4gW2Fyci5zdWJhcnJheShvZmZzX2JlZ2luLCBvZmZzX2VuZCksIG9mZnNfZW5kIC0gMV1cbn1cblxuY29uc3QgZ2V0X2NpcmNfcG9zX2Zyb21fYW5nID0gKGE6IG51bWJlcikgPT4ge1xuXHRjb25zdCBjID0gY29zKC1hKVxuXHRjb25zdCBzID0gc2luKC1hKVxuXHRyZXR1cm4gW2MsIHNdXG59XG5cbmxldCBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dFxuZXhwb3J0IGNsYXNzIERyYXdlciB7XG5cdGNhbnZhc190ZXg6IFRleHR1cmVcblx0ZGVmYXVsdF9mcmFtZWJ1ZmZlcjogRnJhbWVidWZmZXJcblx0Ly8gQHRzLWlnbm9yZVxuXHRicnVzaF9idWZmZXI6IFRoaW5nXG5cdHpvb206IG51bWJlciA9IDBcblx0cGFubmluZzogbnVtYmVyW10gPSBbMCwgMF1cblx0dDogbnVtYmVyID0gMFxuXHRpZHg6IG51bWJlciA9IDBcblx0dGVtcF9hcnJheV9hOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDFfMDAwXzAwKVxuXHR0ZW1wX2FycmF5X2I6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMV8wMDBfMDApXG5cblx0cmVjb3JkZWRfZHJhd2NhbGxzOiBudW1iZXJbXSA9IFtdXG5cblx0Y29uc3RydWN0b3IoX2dsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LCBjYW52YXNfdGV4OiBUZXh0dXJlLCBkZWZhdWx0X2ZyYW1lYnVmZmVyOiBGcmFtZWJ1ZmZlcikge1xuXHRcdHRoaXMuY2FudmFzX3RleCA9IGNhbnZhc190ZXhcblx0XHR0aGlzLmRlZmF1bHRfZnJhbWVidWZmZXIgPSBkZWZhdWx0X2ZyYW1lYnVmZmVyXG5cdFx0Z2wgPSBfZ2xcblx0fVxuXG5cdHJlc2V0KCkge1xuXHRcdHRoaXMuaWR4ID0gMFxuXHRcdHRoaXMucmVjb3JkZWRfZHJhd2NhbGxzLmxlbmd0aCA9IDBcblx0XHQvLyB0aGlzLnJlY29yZGVkX2RyYXdjYWxscyA9IFtdXG5cdFx0dGhpcy5icnVzaF9idWZmZXIuYnVmZnNbMF0uc3ogPSAwXG5cdFx0dGhpcy5icnVzaF9idWZmZXIuYnVmZnNbMV0uc3ogPSAwXG5cdH1cblxuXHRmaWxsX2J1ZmZfZm9yX2Jsb2JfYnJ1c2goc3Ryb2tlOiBCcnVzaFN0cm9rZSkge1xuXHRcdGNvbnN0IGJydXNoX2J1ZmZlciA9IHRoaXMuYnJ1c2hfYnVmZmVyXG5cdFx0Y29uc3QgaXRlcnMgPSBzdHJva2UucG9zaXRpb25zLmxlbmd0aCAvIDIgLSAxXG5cdFx0Ly8gbGV0IGFzcGVjdF9jb3JyZWN0aW9uID0gVXRpbHMuc2NyZWVuX05EQ190b19jYW52YXNfTkRDKFxuXHRcdC8vIFx0WzEsIDFdLFxuXHRcdC8vIFx0dGhpcy5kZWZhdWx0X2ZyYW1lYnVmZmVyLnRleHR1cmVzWzBdLFxuXHRcdC8vIFx0dGhpcy5jYW52YXNfdGV4LFxuXHRcdC8vIFx0MSxcblx0XHQvLyBcdFswLCAwXSxcblx0XHQvLyApXG5cdFx0Ly8gYXNwZWN0X2NvcnJlY3Rpb25bMF0gPSBhc3BlY3RfY29ycmVjdGlvblswXVxuXHRcdC8vIGFzcGVjdF9jb3JyZWN0aW9uWzFdID0gYXNwZWN0X2NvcnJlY3Rpb25bMV1cblxuXHRcdGxldCBhc3BlY3RfY29ycmVjdGlvbiA9IFswLCAwXVxuXHRcdGlmICh0aGlzLmNhbnZhc190ZXgucmVzWzBdID4gdGhpcy5jYW52YXNfdGV4LnJlc1sxXSkge1xuXHRcdFx0YXNwZWN0X2NvcnJlY3Rpb25bMF0gPSB0aGlzLmNhbnZhc190ZXgucmVzWzFdIC8gdGhpcy5jYW52YXNfdGV4LnJlc1swXVxuXHRcdFx0YXNwZWN0X2NvcnJlY3Rpb25bMV0gPSAxXG5cdFx0fSBlbHNlIHtcblx0XHRcdGFzcGVjdF9jb3JyZWN0aW9uWzBdID0gMVxuXHRcdFx0YXNwZWN0X2NvcnJlY3Rpb25bMV0gPSB0aGlzLmNhbnZhc190ZXgucmVzWzBdIC8gdGhpcy5jYW52YXNfdGV4LnJlc1sxXVxuXHRcdH1cblxuXHRcdGNvbnN0IGFkZF9hbmdfdG9fcG9zID0gKFxuXHRcdFx0cG9zOiBudW1iZXJbXSxcblx0XHRcdGFuZ194OiBudW1iZXJbXSxcblx0XHRcdGFuZ195OiBudW1iZXJbXSxcblx0XHRcdHBvc2l0aXZlOiBib29sZWFuLFxuXHRcdFx0c3pfeDogbnVtYmVyLFxuXHRcdFx0c3pfeTogbnVtYmVyLFxuXHRcdCk6IG51bWJlcltdID0+IHtcblx0XHRcdGlmIChwb3NpdGl2ZSkge1xuXHRcdFx0XHRwb3NbMF0gKz0gYW5nX3hbMF0gKiBzel94ICogYXNwZWN0X2NvcnJlY3Rpb25bMF1cblx0XHRcdFx0cG9zWzFdICs9IGFuZ194WzFdICogc3pfeCAqIGFzcGVjdF9jb3JyZWN0aW9uWzFdXG5cdFx0XHRcdHBvc1swXSArPSBhbmdfeVswXSAqIHN6X3kgKiBhc3BlY3RfY29ycmVjdGlvblswXVxuXHRcdFx0XHRwb3NbMV0gKz0gYW5nX3lbMV0gKiBzel95ICogYXNwZWN0X2NvcnJlY3Rpb25bMV1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc1swXSAtPSBhbmdfeFswXSAqIHN6X3ggKiBhc3BlY3RfY29ycmVjdGlvblswXVxuXHRcdFx0XHRwb3NbMV0gLT0gYW5nX3hbMV0gKiBzel94ICogYXNwZWN0X2NvcnJlY3Rpb25bMV1cblx0XHRcdFx0cG9zWzBdICs9IGFuZ195WzBdICogc3pfeSAqIGFzcGVjdF9jb3JyZWN0aW9uWzBdXG5cdFx0XHRcdHBvc1sxXSArPSBhbmdfeVsxXSAqIHN6X3kgKiBhc3BlY3RfY29ycmVjdGlvblsxXVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBvc1xuXHRcdH1cblxuXHRcdGxldCBpZHggPSBicnVzaF9idWZmZXIuYnVmZnNbMF0uc3pcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcblx0XHRcdGxldCBzel94ID0gc3Ryb2tlLnNpemVzW2kgKiAyXSAvIDJcblx0XHRcdGxldCBzel95ID0gc3Ryb2tlLnNpemVzW2kgKiAyICsgMV0gLyAyXG5cdFx0XHQvLyBsZXQgbmV4dF9zeiA9IGJydXNoX3N0cm9rZS5zaXplc1tpICogMiArIDJdXG5cblx0XHRcdGxldCBhbmdfeCA9IGdldF9jaXJjX3Bvc19mcm9tX2FuZyhzdHJva2Uucm90YXRpb25zW2kgKiAyICsgMV0pXG5cdFx0XHRsZXQgYW5nX3kgPSBbYW5nX3hbMV0sIC1hbmdfeFswXV1cblx0XHRcdC8vIGxldCBuZXh0X2FuZyA9IGdldF9jaXJjX3Bvc19mcm9tX2FuZyhicnVzaF9zdHJva2Uucm90YXRpb25zW2kgKiAyICsgM10pXG5cdFx0XHQvLyBsZXQgbmV4dF9hbmdfYiA9IFtjdXJyX2FuZ1sxXSwtY3Vycl9hbmdbMF1dXG5cblx0XHRcdGxldCBjdXJyX3BvcyA9IFtzdHJva2UucG9zaXRpb25zW2kgKiAyXSwgc3Ryb2tlLnBvc2l0aW9uc1tpICogMiArIDFdXVxuXHRcdFx0Ly8gY3Vycl9wb3NbMF0gKz0gb2Zmc194XG5cdFx0XHQvLyBjdXJyX3Bvc1sxXSArPSBvZmZzX3lcblx0XHRcdC8vIGxldCBuZXh0X3BvcyA9IFticnVzaF9zdHJva2UucG9zaXRpb25zW2kgKiAyICsgMl0sIGJydXNoX3N0cm9rZS5wb3NpdGlvbnNbaSAqIDIgKyAzXV1cblxuXHRcdFx0bGV0IGN1cnJfcG9zX2xlZnQgPSBhZGRfYW5nX3RvX3BvcyhbLi4uY3Vycl9wb3NdLCBhbmdfeCwgYW5nX3ksIHRydWUsIHN6X3gsIHN6X3kpXG5cdFx0XHRsZXQgY3Vycl9wb3NfcmlnaHQgPSBhZGRfYW5nX3RvX3BvcyhbLi4uY3Vycl9wb3NdLCBhbmdfeCwgYW5nX3ksIGZhbHNlLCBzel94LCBzel95KVxuXG5cdFx0XHRsZXQgbmV4dF9wb3NfbGVmdCA9IFsuLi5jdXJyX3Bvc19sZWZ0XVxuXHRcdFx0bGV0IG5leHRfcG9zX3JpZ2h0ID0gWy4uLmN1cnJfcG9zX3JpZ2h0XVxuXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLSBPRkZTXG5cdFx0XHRuZXh0X3Bvc19sZWZ0WzBdIC09IGFuZ195WzBdICogc3pfeSAqIGFzcGVjdF9jb3JyZWN0aW9uWzBdICogMlxuXHRcdFx0bmV4dF9wb3NfbGVmdFsxXSAtPSBhbmdfeVsxXSAqIHN6X3kgKiBhc3BlY3RfY29ycmVjdGlvblsxXSAqIDJcblx0XHRcdG5leHRfcG9zX3JpZ2h0WzBdIC09IGFuZ195WzBdICogc3pfeSAqIGFzcGVjdF9jb3JyZWN0aW9uWzBdICogMlxuXHRcdFx0bmV4dF9wb3NfcmlnaHRbMV0gLT0gYW5nX3lbMV0gKiBzel95ICogYXNwZWN0X2NvcnJlY3Rpb25bMV0gKiAyXG5cdFx0XHQvLyBwb3NbMV0gKz0gKGFuZ19vZmZzX2JbMV0gKiBhbXRfYikgLyBhc3BlY3RfY29ycmVjdGlvblsxXVxuXG5cdFx0XHRsZXQgY3Vycl9jb2wgPSBbc3Ryb2tlLmNvbG91cnNbaSAqIDNdLCBzdHJva2UuY29sb3Vyc1tpICogMyArIDFdLCBzdHJva2UuY29sb3Vyc1tpICogMyArIDJdXVxuXHRcdFx0bGV0IGN1cnJfb3BhY2l0eSA9IHN0cm9rZS5vcGFjaXRpZXNbaV1cblxuXHRcdFx0Y29uc3QgY3Vycl92ID0gaSAvIGl0ZXJzXG5cdFx0XHRjb25zdCBuZXh0X3YgPSAoaSArIDEpIC8gaXRlcnNcblxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnB1c2hfdmVydChbLi4uY3Vycl9wb3NfbGVmdCwgMCwgY3Vycl92XSlcblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1sxXS5wdXNoX3ZlcnQoWy4uLmN1cnJfY29sLCBjdXJyX29wYWNpdHldKVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Bvc19sZWZ0WzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gY3Vycl9wb3NfbGVmdFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDBcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAwXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9vcGFjaXR5XG5cblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS5wdXNoX3ZlcnQoWy4uLmN1cnJfcG9zX3JpZ2h0LCAxLCBjdXJyX3ZdKVxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLnB1c2hfdmVydChbLi4uY3Vycl9jb2wsIGN1cnJfb3BhY2l0eV0pXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IGN1cnJfcG9zX3JpZ2h0WzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gY3Vycl9wb3NfcmlnaHRbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAxXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMl1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMFxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfb3BhY2l0eVxuXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMF0ucHVzaF92ZXJ0KFsuLi5uZXh0X3Bvc19sZWZ0LCAwLCBuZXh0X3ZdKVxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLnB1c2hfdmVydChbLi4uY3Vycl9jb2wsIGN1cnJfb3BhY2l0eV0pXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IG5leHRfcG9zX2xlZnRbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBuZXh0X3Bvc19sZWZ0WzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMFxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzJdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDFcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX29wYWNpdHlcblxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnB1c2hfdmVydChbLi4uY3Vycl9wb3NfcmlnaHQsIDEsIGN1cnJfdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFsuLi5jdXJyX2NvbCwgY3Vycl9vcGFjaXR5XSlcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gY3Vycl9wb3NfcmlnaHRbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Bvc19yaWdodFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDFcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAwXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9vcGFjaXR5XG5cblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS5wdXNoX3ZlcnQoWy4uLm5leHRfcG9zX2xlZnQsIDAsIG5leHRfdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFsuLi5jdXJyX2NvbCwgY3Vycl9vcGFjaXR5XSlcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gbmV4dF9wb3NfbGVmdFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IG5leHRfcG9zX2xlZnRbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAwXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMl1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfb3BhY2l0eVxuXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMF0ucHVzaF92ZXJ0KFsuLi5uZXh0X3Bvc19yaWdodCwgMSwgbmV4dF92XSlcblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1sxXS5wdXNoX3ZlcnQoWy4uLmN1cnJfY29sLCBjdXJyX29wYWNpdHldKVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBuZXh0X3Bvc19yaWdodFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IG5leHRfcG9zX3JpZ2h0WzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzJdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDFcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX29wYWNpdHlcblx0XHR9XG5cdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnN6ICs9IGl0ZXJzICogNiAqIDRcblx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uc3ogKz0gaXRlcnMgKiA2ICogNFxuXHRcdHRoaXMucmVjb3JkZWRfZHJhd2NhbGxzLnB1c2godGhpcy5icnVzaF9idWZmZXIuYnVmZnNbMF0uc3opXG5cdH1cblxuXHRmaWxsX2J1ZmZfZm9yX2xvbmdfYnJ1c2goc3Ryb2tlOiBCcnVzaFN0cm9rZSkge1xuXHRcdGNvbnN0IGJydXNoX2J1ZmZlciA9IHRoaXMuYnJ1c2hfYnVmZmVyXG5cdFx0Y29uc3QgaXRlcnMgPSBzdHJva2UucG9zaXRpb25zLmxlbmd0aCAvIDIgLSAxXG5cdFx0bGV0IGFzcGVjdF9jb3JyZWN0aW9uID0gWzAsIDBdXG5cdFx0aWYgKHRoaXMuY2FudmFzX3RleC5yZXNbMF0gPiB0aGlzLmNhbnZhc190ZXgucmVzWzFdKSB7XG5cdFx0XHRhc3BlY3RfY29ycmVjdGlvblswXSA9IHRoaXMuY2FudmFzX3RleC5yZXNbMV0gLyB0aGlzLmNhbnZhc190ZXgucmVzWzBdXG5cdFx0XHRhc3BlY3RfY29ycmVjdGlvblsxXSA9IDFcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXNwZWN0X2NvcnJlY3Rpb25bMF0gPSAxXG5cdFx0XHRhc3BlY3RfY29ycmVjdGlvblsxXSA9IHRoaXMuY2FudmFzX3RleC5yZXNbMF0gLyB0aGlzLmNhbnZhc190ZXgucmVzWzFdXG5cdFx0fVxuXG5cdFx0Y29uc3QgYWRkX2FuZ190b19wb3MgPSAoXG5cdFx0XHRwb3M6IG51bWJlcltdLFxuXHRcdFx0YW5nX29mZnM6IG51bWJlcltdLFxuXHRcdFx0cG9zaXRpdmU6IGJvb2xlYW4sXG5cdFx0XHRhbXQ6IG51bWJlcixcblx0XHRcdGFzcGVjdF9jb3JyZWN0aW9uOiBudW1iZXJbXSxcblx0XHQpOiBudW1iZXJbXSA9PiB7XG5cdFx0XHRpZiAocG9zaXRpdmUpIHtcblx0XHRcdFx0cG9zWzBdICs9IGFuZ19vZmZzWzBdICogYW10ICogYXNwZWN0X2NvcnJlY3Rpb25bMF1cblx0XHRcdFx0cG9zWzFdICs9IGFuZ19vZmZzWzFdICogYW10ICogYXNwZWN0X2NvcnJlY3Rpb25bMV1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc1swXSAtPSBhbmdfb2Zmc1swXSAqIGFtdCAqIGFzcGVjdF9jb3JyZWN0aW9uWzBdXG5cdFx0XHRcdHBvc1sxXSAtPSBhbmdfb2Zmc1sxXSAqIGFtdCAqIGFzcGVjdF9jb3JyZWN0aW9uWzFdXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcG9zXG5cdFx0fVxuXG5cdFx0bGV0IGlkeCA9IGJydXNoX2J1ZmZlci5idWZmc1swXS5zelxuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG5cdFx0XHQvLyAjZGVmaW5lIHJvdChhKSBtYXQyKGNvcyhhKSwtc2luKGEpLHNpbihhKSxjb3MoYSkpXG5cdFx0XHQvLyBicnVzaF9zdHJva2UuXG5cdFx0XHRsZXQgY3Vycl9zeiA9IHN0cm9rZS5zaXplc1tpICogMl1cblx0XHRcdGxldCBuZXh0X3N6ID0gc3Ryb2tlLnNpemVzW2kgKiAyICsgMl1cblxuXHRcdFx0bGV0IGN1cnJfYW5nID0gZ2V0X2NpcmNfcG9zX2Zyb21fYW5nKHN0cm9rZS5yb3RhdGlvbnNbaSAqIDIgKyAxXSlcblx0XHRcdGxldCBuZXh0X2FuZyA9IGdldF9jaXJjX3Bvc19mcm9tX2FuZyhzdHJva2Uucm90YXRpb25zW2kgKiAyICsgM10pXG5cblx0XHRcdGxldCBjdXJyX3BvcyA9IFtzdHJva2UucG9zaXRpb25zW2kgKiAyXSwgc3Ryb2tlLnBvc2l0aW9uc1tpICogMiArIDFdXVxuXHRcdFx0bGV0IG5leHRfcG9zID0gW3N0cm9rZS5wb3NpdGlvbnNbaSAqIDIgKyAyXSwgc3Ryb2tlLnBvc2l0aW9uc1tpICogMiArIDNdXVxuXG5cdFx0XHRsZXQgY3Vycl9wb3NfbGVmdCA9IGFkZF9hbmdfdG9fcG9zKFsuLi5jdXJyX3Bvc10sIGN1cnJfYW5nLCB0cnVlLCBjdXJyX3N6LCBhc3BlY3RfY29ycmVjdGlvbilcblx0XHRcdGxldCBjdXJyX3Bvc19yaWdodCA9IGFkZF9hbmdfdG9fcG9zKFsuLi5jdXJyX3Bvc10sIGN1cnJfYW5nLCBmYWxzZSwgY3Vycl9zeiwgYXNwZWN0X2NvcnJlY3Rpb24pXG5cblx0XHRcdGxldCBuZXh0X3Bvc19sZWZ0ID0gYWRkX2FuZ190b19wb3MoWy4uLm5leHRfcG9zXSwgbmV4dF9hbmcsIHRydWUsIG5leHRfc3osIGFzcGVjdF9jb3JyZWN0aW9uKVxuXHRcdFx0bGV0IG5leHRfcG9zX3JpZ2h0ID0gYWRkX2FuZ190b19wb3MoWy4uLm5leHRfcG9zXSwgbmV4dF9hbmcsIGZhbHNlLCBuZXh0X3N6LCBhc3BlY3RfY29ycmVjdGlvbilcblxuXHRcdFx0bGV0IGN1cnJfY29sID0gW3N0cm9rZS5jb2xvdXJzW2kgKiAzXSwgc3Ryb2tlLmNvbG91cnNbaSAqIDMgKyAxXSwgc3Ryb2tlLmNvbG91cnNbaSAqIDMgKyAyXV1cblx0XHRcdGxldCBjdXJyX29wYWNpdHkgPSBzdHJva2Uub3BhY2l0aWVzW2ldXG5cblx0XHRcdGxldCBuZXh0X2NvbCA9IFtzdHJva2UuY29sb3Vyc1tpICogMyArIDNdLCBzdHJva2UuY29sb3Vyc1tpICogMyArIDRdLCBzdHJva2UuY29sb3Vyc1tpICogMyArIDVdXVxuXHRcdFx0bGV0IG5leHRfb3BhY2l0eSA9IHN0cm9rZS5vcGFjaXRpZXNbaSArIDFdXG5cblx0XHRcdGNvbnN0IGN1cnJfdiA9IGkgLyBpdGVyc1xuXHRcdFx0Y29uc3QgbmV4dF92ID0gKGkgKyAxKSAvIGl0ZXJzXG5cblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS5wdXNoX3ZlcnQoWy4uLmN1cnJfcG9zX2xlZnQsIDAsIGN1cnJfdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFsuLi5jdXJyX2NvbCwgY3Vycl9vcGFjaXR5XSlcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gY3Vycl9wb3NfbGVmdFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IGN1cnJfcG9zX2xlZnRbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAwXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMl1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gY3Vycl92XG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9vcGFjaXR5XG5cblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS5wdXNoX3ZlcnQoWy4uLmN1cnJfcG9zX3JpZ2h0LCAxLCBjdXJyX3ZdKVxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLnB1c2hfdmVydChbLi4uY3Vycl9jb2wsIGN1cnJfb3BhY2l0eV0pXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IGN1cnJfcG9zX3JpZ2h0WzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gY3Vycl9wb3NfcmlnaHRbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAxXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMl1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gY3Vycl92XG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9vcGFjaXR5XG5cblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS5wdXNoX3ZlcnQoWy4uLm5leHRfcG9zX2xlZnQsIDAsIG5leHRfdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFsuLi5uZXh0X2NvbCwgbmV4dF9vcGFjaXR5XSlcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gbmV4dF9wb3NfbGVmdFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IG5leHRfY29sWzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IG5leHRfcG9zX2xlZnRbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBuZXh0X2NvbFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAwXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gbmV4dF9jb2xbMl1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gbmV4dF92XG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gbmV4dF9vcGFjaXR5XG5cblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS5wdXNoX3ZlcnQoWy4uLmN1cnJfcG9zX3JpZ2h0LCAxLCBjdXJyX3ZdKVxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLnB1c2hfdmVydChbLi4uY3Vycl9jb2wsIGN1cnJfb3BhY2l0eV0pXG5cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gY3Vycl9wb3NfcmlnaHRbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Bvc19yaWdodFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDFcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Zcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX29wYWNpdHlcblxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnB1c2hfdmVydChbLi4ubmV4dF9wb3NfbGVmdCwgMCwgbmV4dF92XSlcblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1sxXS5wdXNoX3ZlcnQoWy4uLm5leHRfY29sLCBuZXh0X29wYWNpdHldKVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBuZXh0X3Bvc19sZWZ0WzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gbmV4dF9jb2xbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gbmV4dF9wb3NfbGVmdFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IG5leHRfY29sWzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDBcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBuZXh0X2NvbFsyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBuZXh0X3Zcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBuZXh0X29wYWNpdHlcblxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnB1c2hfdmVydChbLi4ubmV4dF9wb3NfcmlnaHQsIDEsIG5leHRfdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFsuLi5uZXh0X2NvbCwgbmV4dF9vcGFjaXR5XSlcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gbmV4dF9wb3NfcmlnaHRbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBuZXh0X2NvbFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBuZXh0X3Bvc19yaWdodFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IG5leHRfY29sWzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDFcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBuZXh0X2NvbFsyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBuZXh0X3Zcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBuZXh0X29wYWNpdHlcblx0XHR9XG5cdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnN6ICs9IGl0ZXJzICogNiAqIDRcblx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uc3ogKz0gaXRlcnMgKiA2ICogNFxuXHRcdHRoaXMucmVjb3JkZWRfZHJhd2NhbGxzLnB1c2godGhpcy5icnVzaF9idWZmZXIuYnVmZnNbMF0uc3opXG5cdH1cblx0ZmlsbF9idWZmX2Zvcl90cmlhbmd1bGF0ZWRfYnJ1c2goc3Ryb2tlOiBCcnVzaFN0cm9rZSkge1xuXHRcdGNvbnN0IGJydXNoX2J1ZmZlciA9IHRoaXMuYnJ1c2hfYnVmZmVyXG5cdFx0Y29uc3Qge2NvbG91cnMsIG9wYWNpdGllcywgcG9zaXRpb25zfSA9IHN0cm9rZVxuXHRcdC8vIGxldCBwb3NpdGlvbnMgPSBbLi4uc3Ryb2tlLnBvc2l0aW9uc11cblx0XHQvLyBjb25zdCBbbmV3X3RyaWFuZ2xlcywgb2Zmc10gPSBnZXRfc3ViYXJyYXkodGhpcy50ZW1wX2FycmF5X2EsIDAsIHBvc2l0aW9ucy5sZW5ndGggKiAzKVxuXHRcdC8vIGNvbnN0IFtuZXdfY29sc10gPSBnZXRfc3ViYXJyYXkodGhpcy50ZW1wX2FycmF5X2EsIG9mZnMsIG9mZnMgKyAocG9zaXRpb25zLmxlbmd0aCAvIDIpICogMyAqIDQpXG5cdFx0Y29uc3QgaXRlcnMgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMiAtIDFcblx0XHRsZXQgaWR4ID0gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnN6XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG5cdFx0XHRsZXQgdSA9IDBcblx0XHRcdGxldCB2ID0gMFxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLnB1c2hfdmVydChbLi4uY3Vycl9jb2wsIGN1cnJfb3BhY2l0eV0pXG5cblx0XHRcdC8vIG5ld190cmlhbmdsZXNbaSAqIDMgKiAyXSA9IHBvc2l0aW9uc1swXVxuXHRcdFx0Ly8gbmV3X3RyaWFuZ2xlc1tpICogMyAqIDIgKyAxXSA9IHBvc2l0aW9uc1swICsgMV1cblx0XHRcdC8vIG5ld19jb2xzW2kgKiAzICogNF0gPSBzdHJva2UuY29sb3Vyc1swXVxuXHRcdFx0Ly8gbmV3X2NvbHNbaSAqIDMgKiA0ICsgMV0gPSBzdHJva2UuY29sb3Vyc1sxXVxuXHRcdFx0Ly8gbmV3X2NvbHNbaSAqIDMgKiA0ICsgMl0gPSBzdHJva2UuY29sb3Vyc1syXVxuXHRcdFx0Ly8gbmV3X2NvbHNbaSAqIDMgKiA0ICsgM10gPSBzdHJva2Uub3BhY2l0aWVzWzBdXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMF0ucHVzaF92ZXJ0KFtwb3NpdGlvbnNbMF0sIHBvc2l0aW9uc1sxXSwgdSwgdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFtjb2xvdXJzWzBdLCBjb2xvdXJzWzFdLCBjb2xvdXJzWzJdLCBvcGFjaXRpZXNbMV1dKVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBwb3NpdGlvbnNbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjb2xvdXJzWzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IHBvc2l0aW9uc1sxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGNvbG91cnNbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gaSAvIChpdGVycyArIDEpXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY29sb3Vyc1syXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAwXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gb3BhY2l0aWVzWzFdXG5cblx0XHRcdC8vIG5ld190cmlhbmdsZXNbaSAqIDMgKiAyICsgMl0gPSBwb3NpdGlvbnNbaSAqIDJdXG5cdFx0XHQvLyBuZXdfdHJpYW5nbGVzW2kgKiAzICogMiArIDNdID0gcG9zaXRpb25zW2kgKiAyICsgMV1cblx0XHRcdC8vIG5ld19jb2xzW2kgKiAzICogNCArIDRdID0gc3Ryb2tlLmNvbG91cnNbaSAqIDNdXG5cdFx0XHQvLyBuZXdfY29sc1tpICogMyAqIDQgKyA1XSA9IHN0cm9rZS5jb2xvdXJzW2kgKiAzICsgMV1cblx0XHRcdC8vIG5ld19jb2xzW2kgKiAzICogNCArIDZdID0gc3Ryb2tlLmNvbG91cnNbaSAqIDMgKyAyXVxuXHRcdFx0Ly8gbmV3X2NvbHNbaSAqIDMgKiA0ICsgN10gPSBzdHJva2Uub3BhY2l0aWVzW2ldXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMF0ucHVzaF92ZXJ0KFtwb3NpdGlvbnNbaSAqIDJdLCBwb3NpdGlvbnNbaSAqIDIgKyAxXSwgdSwgdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFtjb2xvdXJzW2kgKiAzXSwgY29sb3Vyc1tpICogMyArIDFdLCBjb2xvdXJzW2kgKiAzICsgMl0sIG9wYWNpdGllc1tpXV0pXG5cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gcG9zaXRpb25zW2kgKiAyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGNvbG91cnNbaSAqIDNdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IHBvc2l0aW9uc1tpICogMiArIDFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY29sb3Vyc1tpICogMyArIDFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IGkgLyAoaXRlcnMgKyAxKVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGNvbG91cnNbaSAqIDMgKyAyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAxXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gb3BhY2l0aWVzW2ldXG5cblx0XHRcdC8vIG5ld190cmlhbmdsZXNbaSAqIDMgKiAyICsgNF0gPSBwb3NpdGlvbnNbaSAqIDIgKyAyXVxuXHRcdFx0Ly8gbmV3X3RyaWFuZ2xlc1tpICogMyAqIDIgKyA1XSA9IHBvc2l0aW9uc1tpICogMiArIDNdXG5cdFx0XHQvLyBuZXdfY29sc1tpICogMyAqIDQgKyA4XSA9IHN0cm9rZS5jb2xvdXJzW2kgKiAzICsgM11cblx0XHRcdC8vIG5ld19jb2xzW2kgKiAzICogNCArIDldID0gc3Ryb2tlLmNvbG91cnNbaSAqIDMgKyA0XVxuXHRcdFx0Ly8gbmV3X2NvbHNbaSAqIDMgKiA0ICsgMTBdID0gc3Ryb2tlLmNvbG91cnNbaSAqIDMgKyA1XVxuXHRcdFx0Ly8gbmV3X2NvbHNbaSAqIDMgKiA0ICsgMTFdID0gc3Ryb2tlLm9wYWNpdGllc1tpICsgMV1cblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS5wdXNoX3ZlcnQoW3Bvc2l0aW9uc1tpICogMiArIDJdLCBwb3NpdGlvbnNbaSAqIDIgKyAzXSwgdSwgdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFtjb2xvdXJzW2kgKiAzICsgM10sIGNvbG91cnNbaSAqIDMgKyA0XSwgY29sb3Vyc1tpICogMyArIDVdLCBvcGFjaXRpZXNbaSArIDFdXSlcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gcG9zaXRpb25zW2kgKiAyICsgMl1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjb2xvdXJzW2kgKiAzICsgM11cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gcG9zaXRpb25zW2kgKiAyICsgM11cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjb2xvdXJzW2kgKiAzICsgNF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gKGkgKyAxKSAvIChpdGVycyArIDEpXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY29sb3Vyc1tpICogMyArIDVdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDFcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBvcGFjaXRpZXNbaSArIDFdXG5cdFx0fVxuXHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5zeiArPSBpdGVycyAqIDMgKiA0XG5cdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLnN6ICs9IGl0ZXJzICogMyAqIDRcblx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMF0udXBsb2FkX2V4dGVybmFsX2FycmF5KG5ld190cmlhbmdsZXMpXG5cdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLnVwbG9hZF9leHRlcm5hbF9hcnJheShuZXdfY29scylcblx0XHR0aGlzLnJlY29yZGVkX2RyYXdjYWxscy5wdXNoKHRoaXMuYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnN6KVxuXHR9XG5cblx0cHVzaF9hbnlfc3Ryb2tlKHN0cm9rZTogQnJ1c2hTdHJva2UpIHtcblx0XHQvLyBjb25zb2xlLmxvZygnU1RBUlQgUFVTSElORycpXG5cdFx0Ly8gY29uc29sZS50aW1lKCdTSU5HTEUgU1RST0tFJylcblx0XHRpZiAoc3Ryb2tlLmJydXNoX3R5cGUgPT09IEJydXNoVHlwZS5CbG9icykge1xuXHRcdFx0dGhpcy5maWxsX2J1ZmZfZm9yX2Jsb2JfYnJ1c2goc3Ryb2tlKVxuXHRcdH0gZWxzZSBpZiAoc3Ryb2tlLmJydXNoX3R5cGUgPT09IEJydXNoVHlwZS5Mb25nKSB7XG5cdFx0XHR0aGlzLmZpbGxfYnVmZl9mb3JfbG9uZ19icnVzaChzdHJva2UpXG5cdFx0fSBlbHNlIGlmIChzdHJva2UuYnJ1c2hfdHlwZSA9PT0gQnJ1c2hUeXBlLlRyaSkge1xuXHRcdFx0dGhpcy5maWxsX2J1ZmZfZm9yX3RyaWFuZ3VsYXRlZF9icnVzaChzdHJva2UpXG5cdFx0fVxuXHRcdC8vIGNvbnNvbGUudGltZUVuZCgnU0lOR0xFIFNUUk9LRScpXG5cdH1cblx0ZHJhd19zdHJva2VfaWR4KGlkeDogbnVtYmVyKSB7XG5cdFx0bGV0IGRyYXdfc3RhcnQgPSBpZHggPT09IDAgPyAwIDogdGhpcy5yZWNvcmRlZF9kcmF3Y2FsbHNbaWR4IC0gMV1cblx0XHRsZXQgZHJhd19jbnQgPSBpZHggPT09IDAgPyB0aGlzLnJlY29yZGVkX2RyYXdjYWxsc1swXSA6IHRoaXMucmVjb3JkZWRfZHJhd2NhbGxzW2lkeF0gLSB0aGlzLnJlY29yZGVkX2RyYXdjYWxsc1tpZHggLSAxXVxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCBkcmF3X3N0YXJ0IC8gNCwgZHJhd19jbnQgLyA0KVxuXHR9XG5cblx0ZHJhd19hbnlfc3Ryb2tlKHN0cm9rZTogQnJ1c2hTdHJva2UsIHQ6IG51bWJlciwgYnJ1c2hfYnVmZmVyOiBUaGluZywgem9vbTogbnVtYmVyLCBwYW5uaW5nOiBudW1iZXJbXSkge1xuXHRcdHRoaXMuYnJ1c2hfYnVmZmVyID0gYnJ1c2hfYnVmZmVyXG5cdFx0Y29uc29sZS5sb2coJ1NUQVJUIERSQVdJTkcnKVxuXHRcdHRoaXMudCA9IHRcblx0XHR0aGlzLnpvb20gPSB6b29tXG5cdFx0dGhpcy5wYW5uaW5nID0gWy4uLnBhbm5pbmddXG5cblx0XHRicnVzaF9idWZmZXIuZHJhdygpXG5cdH1cbn1cblxuLy8gZHJhd19ibG9ic19zdHJva2UoXG4vLyBcdF9jb2w6IG51bWJlcltdLFxuLy8gXHRfb3BhY2l0eTogbnVtYmVyLFxuLy8gXHRfcG9zOiBudW1iZXJbXSxcbi8vIFx0X3JvdDogbnVtYmVyW10sXG4vLyBcdF9zejogbnVtYmVyW10sXG4vLyBcdF90ZXhfbGNoX2R5bmFtaWNzOiBudW1iZXJbXSxcbi8vIFx0X3RleF9zdHJldGNoOiBudW1iZXJbXSxcbi8vICkge1xuLy8gXHRsZXQgZHJhd19ibG9ic19zdHJva2VfcHJvZ3JhbSA9IHRoaXMuZHJhd19ibG9ic19zdHJva2VfcHJvZ3JhbVxuLy8gXHRsZXQgc2V0X3NoYXJlZF91bmlmb3JtcyA9IHRoaXMuc2V0X3NoYXJlZF91bmlmb3Jtc1xuLy8gXHRkcmF3X2Jsb2JzX3N0cm9rZV9wcm9ncmFtLnVzZSgpXG4vLyBcdHNldF9zaGFyZWRfdW5pZm9ybXMoZHJhd19ibG9ic19zdHJva2VfcHJvZ3JhbSwgX2NvbCwgdGhpcy50KVxuXG4vLyBcdGRyYXdfYmxvYnNfc3Ryb2tlX3Byb2dyYW0uc2V0VW5pZm9ybUZsb2F0KCdzdHJva2Vfb3BhY2l0eScsIF9vcGFjaXR5KVxuLy8gXHRkcmF3X2Jsb2JzX3N0cm9rZV9wcm9ncmFtLnNldFVuaWZvcm1WZWMoJ3RleF9sY2hfZHluYW1pY3MnLCBbXG4vLyBcdFx0X3RleF9sY2hfZHluYW1pY3NbMF0sXG4vLyBcdFx0X3RleF9sY2hfZHluYW1pY3NbMV0sXG4vLyBcdFx0X3RleF9sY2hfZHluYW1pY3NbMl0sXG4vLyBcdF0pXG4vLyBcdGRyYXdfYmxvYnNfc3Ryb2tlX3Byb2dyYW0uc2V0VW5pZm9ybVZlYygndGV4X3N0cmV0Y2gnLCBbX3RleF9zdHJldGNoWzBdLCBfdGV4X3N0cmV0Y2hbMV1dKVxuXG4vLyBcdGNvbnN0IHB1c2hfd2l0aF9vZmZzID0gKHZhbHM6IG51bWJlcltdLCBvZmZzOiBudW1iZXIpID0+IHtcbi8vIFx0XHR2YWxzLmZvckVhY2goKHYsIGkpID0+IHtcbi8vIFx0XHRcdHdpbmRvdy51Ym8uYnVmZi5jcHVfYnVmZltvZmZzICsgaV0gPSB2XG4vLyBcdFx0fSlcbi8vIFx0fVxuXG4vLyBcdHB1c2hfd2l0aF9vZmZzKF9jb2wsIDApXG4vLyBcdHB1c2hfd2l0aF9vZmZzKF9wb3MsIDgpXG4vLyBcdHB1c2hfd2l0aF9vZmZzKF9zeiwgMTQpXG4vLyBcdHB1c2hfd2l0aF9vZmZzKF9yb3QsIDE2KVxuLy8gXHRwdXNoX3dpdGhfb2ZmcyhbX29wYWNpdHldLCAyMSlcblxuLy8gXHR3aW5kb3cudWJvLmJ1ZmYudXBsb2FkKClcbi8vIFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNClcbi8vIH1cbiIsIjxtYWluPlxuXHQ8ZGl2IGlkPVwiYmFyLWNvbnRhaW5lclwiPlxuXHRcdDxkaXYgaWQ9XCJiYXJcIj5cblx0XHRcdDwhLS0gPEtub2IgYmluZDp2YWx1ZT17c3Ryb2tlX2NvbFswXX0gdGl0bGU9eydSJ30gLz5cblx0XHRcdDxLbm9iIGJpbmQ6dmFsdWU9e3N0cm9rZV9jb2xbMV19IHRpdGxlPXsnRyd9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtzdHJva2VfY29sWzJdfSB0aXRsZT17J0InfSAvPiAtLT5cblxuXHRcdFx0PFJHQlNsaWRlcnMgYmluZDpjb2xvdXI9e3N0cm9rZV9jb2x9IC8+XG5cdFx0XHQ8Q29sb3VyRGlzcGxheSBcblx0XHRcdFx0YmluZDpjb2xvdXI9e3N0cm9rZV9jb2x9IFxuXHRcdFx0XHRiaW5kOnVwZGF0ZV9kaXNwbGF5PXt0cmlnZ2VyX2NvbG91cl9kaXNwbGF5X3VwZGF0ZX0gLz5cblxuXHRcdFx0PEtub2IgYmluZDp0aGlzPXtjaGFvc0tub2J9IGJpbmQ6dmFsdWU9e2N1cnJfYnJ1c2guY2hhb3N9IHRpdGxlPXsnQ2hhb3MnfSB0cmlnZ2VyTW9kYWw9e29wZW5Nb2RhbH0gbW9kYWw9e2NoYW9zU2VtaU1vZGFsfSAvPlxuXHRcdFx0PEJydXNoU2l6ZVdpZGdldFxuXHRcdFx0XHRiaW5kOmJydXNoX3N6PXticnVzaF9zen1cblx0XHRcdFx0YmluZDpkcmFnZ2luZz17YnJ1c2hTaXplV2lkZ2V0RHJhZ2dpbmd9XG5cdFx0XHRcdGJpbmQ6c3RvcHBlZF9kcmFnZ2luZz17YnJ1c2hTaXplV2lkZ2V0U3RvcHBlZERyYWdnaW5nfSAvPlxuXHRcdFx0PEtub2Jcblx0XHRcdFx0YmluZDp0aGlzPXtkeW5hbWljc0tub2J9XG5cdFx0XHRcdGJpbmQ6dmFsdWU9e2N1cnJfYnJ1c2guZHluYW1pY3N9XG5cdFx0XHRcdHRpdGxlPXsnRHluYW1pY3MnfVxuXHRcdFx0XHR0cmlnZ2VyTW9kYWw9e29wZW5Nb2RhbH1cblx0XHRcdFx0bW9kYWw9e2R5bmFtaWNzU2VtaU1vZGFsfSAvPlxuXHRcdFx0PEtub2Jcblx0XHRcdFx0YmluZDp0aGlzPXt0ZXhEeW5hbWljc0tub2J9XG5cdFx0XHRcdGJpbmQ6dmFsdWU9e2N1cnJfYnJ1c2gudGV4X2R5bmFtaWNzfVxuXHRcdFx0XHR0aXRsZT17J1RleCd9XG5cdFx0XHRcdHRyaWdnZXJNb2RhbD17b3Blbk1vZGFsfVxuXHRcdFx0XHRtb2RhbD17dGV4RHluYW1pY3NTZW1pTW9kYWx9IC8+XG5cdFx0XHQ8IS0tIDxCcnVzaFR5cGVXaWRnZXQgYmluZDpzZWxlY3RlZF9icnVzaF90eXBlPXtjdXJyX2JydXNoLnNlbGVjdGVkX2JydXNoX3R5cGV9IC8+IC0tPlxuXHRcdFx0PEJydXNoVHlwZVdpZGdldCBiaW5kOmN1cnJfYnJ1c2g9e2N1cnJfYnJ1c2h9IC8+XG5cdFx0XHQ8QnJ1c2hQcmVzZXRXaWRnZXQgYmluZDpicnVzaF9wcmVzZXRzPXticnVzaF9wcmVzZXRzfSBiaW5kOnNlbGVjdGVkX2JydXNoX3ByZXNldD17Y3Vycl9icnVzaH0gLz5cblx0XHRcdDxGb3VySWNvbnNXaWRnZXQ+XG5cdFx0XHRcdDxVbmRvUmVkb1dpZGdldFxuXHRcdFx0XHRcdHVuZG89eygpID0+IHtcblx0XHRcdFx0XHRcdHVuZG9fcGVuZGluZyA9IHRydWVcblx0XHRcdFx0XHRcdGZsb2F0aW5nX21vZGFsX21lc3NhZ2Uuc2V0KFwidW5kb1wiKVxuXHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0cmVkbz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0cmVkb19wZW5kaW5nID0gdHJ1ZVxuXHRcdFx0XHRcdH19IC8+XG5cdFx0XHRcdDxHYWxsZXJ5V2lkZ2V0XG5cdFx0XHRcdFx0YmluZDpjdXJyZW50X3Byb2plY3Q9e3Byb2plY3R9XG5cdFx0XHRcdFx0Z2V0X2N1cnJlbnRfY2FudmFzX2FzX2ltYWdlPXthc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgW2ltZywgYmxvYl0gPSBhd2FpdCBjYW52YXNfcmVhZF90ZXgucmVhZF9iYWNrX2ltYWdlKHRydWUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gW2ltZywgYmxvYl1cblx0XHRcdFx0XHR9fSBcblx0XHRcdFx0XHRuZXdfcHJvamVjdD17KCk9PnsgXG5cdFx0XHRcdFx0XHRuZXdfcHJvamVjdF9wZW5kaW5nID0gdHJ1ZSBcblx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdGxvYWRfcHJvamVjdD17KHByb2plY3QpPT57IFxuXHRcdFx0XHRcdFx0cHJvamVjdF9wZW5kaW5nX2xvYWQgPSBwcm9qZWN0XG5cdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRiaW5kOnJlc2l6ZV9wcm9qZWN0PXtyZXNpemVfcHJvamVjdH1cblx0XHRcdFx0XHRiaW5kOnByb2plY3RfaGFzX2JlZW5fbW9kaWZpZWQ9e3Byb2plY3RfaGFzX2JlZW5fbW9kaWZpZWR9XG5cdFx0XHRcdFx0YmluZDppc19zYWZlX3RvX3N3aXRjaF90b19uZXdfcHJvamVjdD17aXNfc2FmZV90b19zd2l0Y2hfdG9fbmV3X3Byb2plY3R9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PFBpY2tDb2xvdXJXaWRnZXRcblx0XHRcdFx0XHRwaWNrX2Zyb21fY2FudmFzPXsoKSA9PiBwaWNrX2Zyb21fY2FudmFzKCl9XG5cdFx0XHRcdFx0YmluZDpwaWNraW5nPXtwaWNraW5nfVxuXHRcdFx0XHRcdGJpbmQ6anVzdF9maW5pc2hlZF9waWNrPXtqdXN0X2ZpbmlzaGVkX3BpY2t9IC8+XG5cdFx0XHQ8L0ZvdXJJY29uc1dpZGdldD5cblx0XHRcdDxCbGVuZGluZ0NvbG91clNwYWNlV2lkZ2V0IGJpbmQ6c2VsZWN0ZWRfY29sb3VyX3NwYWNlPXtibGVuZGluZ19jb2xvdXJfc3BhY2V9Lz5cblx0XHRcdDxGbG9hdGluZ01vZGFsIC8+XG5cdFx0PC9kaXY+XG5cdFx0PFNlbWlNb2RhbCBiaW5kOnRoaXM9e2NoYW9zU2VtaU1vZGFsfSBrbm9iPXtjaGFvc0tub2J9PlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC5jaGFvc19sY2hbMF19IHRpdGxlPXsnQ2hhb3MgTCd9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLmNoYW9zX2xjaFsxXX0gdGl0bGU9eydDaGFvcyBDJ30gLz5cblx0XHRcdDxLbm9iIGJpbmQ6dmFsdWU9e2N1cnJfYnJ1c2guY2hhb3NfbGNoWzJdfSB0aXRsZT17J0NoYW9zIEgnfSAvPlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC5jaGFvc19zcGVlZH0gdGl0bGU9eydDaGFvcyBTcGVlZCd9IC8+XG5cdFx0PC9TZW1pTW9kYWw+XG5cdFx0PFNlbWlNb2RhbCBiaW5kOnRoaXM9e2R5bmFtaWNzU2VtaU1vZGFsfSBrbm9iPXtkeW5hbWljc0tub2J9PlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC5zdHJva2Vfb3BhY2l0eV9keW5hbWljc1swXX0gdGl0bGU9eydPcGFjaXR5IG1pbid9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLnN0cm9rZV9vcGFjaXR5X2R5bmFtaWNzWzFdfSB0aXRsZT17J09wYWNpdHkgbWF4J30gLz5cblx0XHRcdDxLbm9iIGJpbmQ6dmFsdWU9e2N1cnJfYnJ1c2guc3Ryb2tlX3NpemVfZHluYW1pY3NbMF19IHRpdGxlPXsnU2l6ZSBtaW4nfSAvPlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC5zdHJva2Vfc2l6ZV9keW5hbWljc1sxXX0gdGl0bGU9eydTaXplIG1heCd9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLnJvdF9qaXR0ZXJ9IHRpdGxlPXsnUm90IGppdHQnfSAvPlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC5wb3Nfaml0dGVyfSB0aXRsZT17J1BvcyBqaXR0J30gLz5cblx0XHQ8L1NlbWlNb2RhbD5cblx0XHQ8U2VtaU1vZGFsIGJpbmQ6dGhpcz17dGV4RHluYW1pY3NTZW1pTW9kYWx9IGtub2I9e3RleER5bmFtaWNzS25vYn0+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLnRleF9zdHJldGNoWzBdfSB0aXRsZT17J1N0cmV0Y2ggWCd9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLnRleF9zdHJldGNoWzFdfSB0aXRsZT17J1N0cmV0Y2ggWSd9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLnRleF9sY2hfZHluYW1pY3NbMF19IHRpdGxlPXsnVGV4IFYnfSAvPlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC50ZXhfbGNoX2R5bmFtaWNzWzFdfSB0aXRsZT17J1RleCBTJ30gLz5cblx0XHRcdDxLbm9iIGJpbmQ6dmFsdWU9e2N1cnJfYnJ1c2gudGV4X2xjaF9keW5hbWljc1syXX0gdGl0bGU9eydUZXggSCd9IC8+XG5cdFx0XHQ8VGV4dHVyZVdpZGdldCBiaW5kOmJydXNoX3RleHR1cmVzPXticnVzaF90ZXh0dXJlc30gYmluZDpzZWxlY3RlZF9icnVzaF90ZXh0dXJlPXtjdXJyX2JydXNoLnNlbGVjdGVkX2JydXNoX3RleHR1cmV9IC8+XG5cdFx0PC9TZW1pTW9kYWw+XG5cdDwvZGl2PlxuXHQ8Y2FudmFzIGlkPVwiY2FudmFzXCIgYmluZDp0aGlzPXtjYW52YXNFbGVtZW50fSAvPlxuPC9tYWluPlxuXG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdC8vIGltcG9ydCB0eXBlIG1vbmFjbyBmcm9tICdtb25hY28tZWRpdG9yJztcblx0aW1wb3J0IHtvbk1vdW50fSBmcm9tICdzdmVsdGUnXG5cdGltcG9ydCB7b25EZXN0cm95fSBmcm9tICdzdmVsdGUnXG5cdGltcG9ydCB7ZmxvYXRpbmdfbW9kYWxfbWVzc2FnZX0gZnJvbSAnc3RvcmUnXG5cblx0aW1wb3J0IHtyZXNpemVJZk5lZWRlZCBhcyByZXNpemVEZWZhdWx0RnJhbWVidWZmZXJJZk5lZWRlZCwgcHJpbnRfb25fZ2xfZXJyb3IsIGluaXRfZ2xfZXJyb3JfaGFuZGxpbmcsIGNvcHlfZmJfdG9fdGV4dHVyZSwgY29weV9mYl90b19mYn0gZnJvbSAnZ2xfdXRpbHMnXG5cblx0aW1wb3J0IEtub2IgZnJvbSAnLi9Lbm9iLnN2ZWx0ZSdcblx0aW1wb3J0IEJydXNoU2l6ZVdpZGdldCBmcm9tICcuL0JydXNoU2l6ZVdpZGdldC5zdmVsdGUnXG5cdGltcG9ydCBCcnVzaFR5cGVXaWRnZXQgZnJvbSAnLi9CcnVzaFR5cGVXaWRnZXQuc3ZlbHRlJ1xuXHRpbXBvcnQgQnJ1c2hQcmVzZXRXaWRnZXQgZnJvbSAnLi9CcnVzaFByZXNldFdpZGdldC5zdmVsdGUnXG5cdGltcG9ydCBVbmRvUmVkb1dpZGdldCBmcm9tICcuL1VuZG9SZWRvV2lkZ2V0LnN2ZWx0ZSdcblx0aW1wb3J0IEdhbGxlcnlXaWRnZXQgZnJvbSAnLi9HYWxsZXJ5V2lkZ2V0LnN2ZWx0ZSdcblx0aW1wb3J0IEZsb2F0aW5nTW9kYWwgZnJvbSAnLi9GbG9hdGluZ01vZGFsLnN2ZWx0ZSdcblx0aW1wb3J0IFBpY2tDb2xvdXJXaWRnZXQgZnJvbSAnLi9QaWNrQ29sb3VyV2lkZ2V0LnN2ZWx0ZSdcblx0aW1wb3J0IFRleHR1cmVXaWRnZXQgZnJvbSAnLi9UZXh0dXJlV2lkZ2V0LnN2ZWx0ZSdcblx0aW1wb3J0IEJsZW5kaW5nQ29sb3VyU3BhY2VXaWRnZXQgZnJvbSAnLi9CbGVuZGluZ0NvbG91clNwYWNlV2lkZ2V0LnN2ZWx0ZSdcblxuXHRpbXBvcnQgUkdCU2xpZGVycyBmcm9tICcuL1JHQlNsaWRlcnMuc3ZlbHRlJ1xuXHRpbXBvcnQgQ29sb3VyRGlzcGxheSBmcm9tICcuL0NvbG91ckRpc3BsYXkuc3ZlbHRlJ1xuXHRpbXBvcnQgU2VtaU1vZGFsIGZyb20gJy4vU2VtaU1vZGFsLnN2ZWx0ZSdcblx0aW1wb3J0IEZvdXJJY29uc1dpZGdldCBmcm9tICcuL0ZvdXJJY29uc1dpZGdldC5zdmVsdGUnXG5cdGltcG9ydCB7SU99IGZyb20gJ0lPJ1xuXHRpbXBvcnQgY2hyb21hIGZyb20gJ2Nocm9tYS1qcydcblx0aW1wb3J0IHtIYXNoLCBhYnMsIGNvcywgZmxvb3IsIHBvdywgc2luLCB0YXUsIHRyaSwgbWl4LCBtYXgsIGxvZzJ9IGZyb20gJ3dtYXRoJ1xuXHRpbXBvcnQge2NsYW1wLCBsZXJwLCBtb2QsIHNtb290aGVzdHN0ZXAsIHNtb290aHN0ZXB9IGZyb20gJ0AwYjV2ci9leHBlcmltZW50YWwnXG5cdGltcG9ydCB7QnJ1c2hUZXh0dXJlLCBQcm9qZWN0LCBVdGlsc30gZnJvbSAnc3R1ZmYnXG5cdGltcG9ydCB7QmxlbmRpbmdDb2xvdXJTcGFjZSwgQnJ1c2hQcmVzZXQsIEJydXNoU3Ryb2tlLCBCcnVzaFR5cGUsIERyYXdQYXJhbXN9IGZyb20gJ2JydXNoX3N0cm9rZSdcblx0aW1wb3J0IHtEcmF3ZXJ9IGZyb20gJ2RyYXdlcidcblx0aW1wb3J0IHsgRnJhbWVidWZmZXIgfSBmcm9tICdnbC9GcmFtZWJ1ZmZlcidcblx0aW1wb3J0IHsgVmVydGV4QnVmZmVyLCBVQk8gfSBmcm9tICdnbC9CdWZmZXInXG5cdGltcG9ydCB7IFRleHR1cmUgfSBmcm9tICdnbC9UZXh0dXJlJ1xuXHRpbXBvcnQgeyBTaGFkZXJQcm9ncmFtIH0gZnJvbSAnZ2wvU2hhZGVyUHJvZ3JhbSdcblx0aW1wb3J0IHsgVGhpbmcgfSBmcm9tICdnbC9UaGluZydcblxuXHQvLyBJbml0XG5cdGNvbnN0IHVuZG9fY2FjaGVfc3RlcHMgPSAyNVxuXHRsZXQgaGFzaCA9IG5ldyBIYXNoKClcblx0bGV0IGlvOiBJT1xuXHRsZXQgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRcblx0bGV0IHpvb20gPSBGbG9hdDMyQXJyYXkuZnJvbShbMV0pXG5cdHdpbmRvdy56b29tID0gem9vbVxuXHRsZXQgZGVzaXJlZF96b29tID0gMVxuXHRsZXQgcGFubmluZ190ZW1wX3BpbmNoOiBudW1iZXJbXSA9IFswLCAwXVxuXHRsZXQgcGFubmluZzogbnVtYmVyW10gPSBbMCwgMF1cblx0bGV0IHVzZXJBZ2VudFJlczogQXJyYXk8bnVtYmVyPiA9IFswLCAwXVxuXHRsZXQgZGVmYXVsdF9mcmFtZWJ1ZmZlcjogRnJhbWVidWZmZXJcblxuXHQvLyBFbGVtZW50c1xuXHRsZXQgY2FudmFzRWxlbWVudDogSFRNTENhbnZhc0VsZW1lbnRcblx0bGV0IGNoYW9zU2VtaU1vZGFsOiBTZW1pTW9kYWxcblx0bGV0IGR5bmFtaWNzU2VtaU1vZGFsOiBTZW1pTW9kYWxcblx0bGV0IHRleER5bmFtaWNzU2VtaU1vZGFsOiBTZW1pTW9kYWxcblx0bGV0IG1vZGFsczogU2VtaU1vZGFsW10gPSBbXVxuXHRsZXQgYnJ1c2hTaXplV2lkZ2V0RHJhZ2dpbmc6IGJvb2xlYW5cblx0bGV0IGJydXNoU2l6ZVdpZGdldFN0b3BwZWREcmFnZ2luZzogYm9vbGVhblxuXHRsZXQgY2hhb3NLbm9iOiBLbm9iXG5cdGxldCBkeW5hbWljc0tub2I6IEtub2Jcblx0bGV0IHRleER5bmFtaWNzS25vYjogS25vYlxuXG5cdC8vIERyYXdpbmcgcGFyYW1zXG5cdGxldCBzdHJva2VfY29sOiBBcnJheTxudW1iZXI+ID0gWzAuNSwgMC40LCAwLjMsIDFdXG5cdGxldCBzdHJva2Vfb3BhY2l0eSA9IDBcblx0bGV0IGJydXNoX3JvdDogbnVtYmVyW10gPSBbMCwgMF1cblx0bGV0IGJydXNoX3Bvc19uZGNfc2NyZWVuOiBudW1iZXJbXSA9IFswLCAwXVxuXHRsZXQgYnJ1c2hfcG9zX25kY19jYW52YXM6IG51bWJlcltdID0gWzAsIDBdXG5cdGxldCBicnVzaF9zejogbnVtYmVyW10gPSBbMSwgMC4yXVxuXHRcblx0XG5cdGxldCBicnVzaF9wcmVzZXRzOiBCcnVzaFByZXNldFtdID0gW11cblx0Zm9yKGxldCBpID0gMDsgaSA8IDY7IGkrKyl7XG5cdFx0YnJ1c2hfcHJlc2V0cy5wdXNoKG5ldyBCcnVzaFByZXNldCgpKVxuXHR9XG5cdGxldCBjdXJyX2JydXNoOiBCcnVzaFByZXNldCA9IGJydXNoX3ByZXNldHNbMF1cblxuXHRsZXQgYmxlbmRpbmdfY29sb3VyX3NwYWNlID0gQmxlbmRpbmdDb2xvdXJTcGFjZS5Pa0xDSFxuXG5cdGxldCBicnVzaF90ZXh0dXJlczogQXJyYXk8QnJ1c2hUZXh0dXJlPiA9IFtdXG5cblx0bGV0IG5ld19wcm9qZWN0X3BlbmRpbmc6IGJvb2xlYW4gPSBmYWxzZVxuXHRsZXQgdW5kb19wZW5kaW5nOiBib29sZWFuID0gZmFsc2Vcblx0bGV0IHJlZG9fcGVuZGluZzogYm9vbGVhbiA9IGZhbHNlXG5cdGxldCBwaWNraW5nOiBib29sZWFuXG5cdGxldCBqdXN0X2ZpbmlzaGVkX3BpY2s6IGJvb2xlYW5cblx0bGV0IHBpY2tlZF9jb2w6IG51bWJlcltdID0gWzAsIDAsIDBdXG5cblx0bGV0IHByb2plY3QgPSBuZXcgUHJvamVjdCgpXG5cdGxldCBwcm9qZWN0X3BlbmRpbmdfbG9hZDogUHJvamVjdFxuXHRsZXQgcHJvamVjdF9oYXNfYmVlbl9tb2RpZmllZCA9IGZhbHNlXG5cdGxldCByZXNpemVfcHJvamVjdDogKHN6OiBudW1iZXJbXSk9PnZvaWRcblx0bGV0IGlzX3NhZmVfdG9fc3dpdGNoX3RvX25ld19wcm9qZWN0XG5cdFxuXHRsZXQgZnVsbF9yZWRyYXdfbmVlZGVkOiBib29sZWFuID0gZmFsc2Vcblx0bGV0IHRyaWdnZXJfY29sb3VyX2Rpc3BsYXlfdXBkYXRlOiAoY29sb3VyX3IsIGNvbG91cl9nLCBjb2xvdXJfYik9PnZvaWRcblxuXHRsZXQgY2FudmFzX2ZiOiBGcmFtZWJ1ZmZlclxuXHRsZXQgY2FudmFzX3JlYWRfdGV4OiBUZXh0dXJlXG5cblx0bGV0IHRlbXBfdW5kb19mYjogRnJhbWVidWZmZXJcblxuXHRsZXQgZHJhd2VyOiBEcmF3ZXJcblx0bGV0IHVibzogVUJPXG5cblx0Y29uc3Qgc2V0X3NoYXJlZF91bmlmb3JtcyA9ICgpID0+IHtcblx0XHR1Ym8uYnVmZi5zeiA9IDBcblx0XHR1Ym8uYnVmZi5jcHVfYnVmZlswXSA9IGNhbnZhc19mYi5fdGV4dHVyZXNbMF0ucmVzWzBdXG5cdFx0dWJvLmJ1ZmYuY3B1X2J1ZmZbMV0gPSBjYW52YXNfZmIuX3RleHR1cmVzWzBdLnJlc1sxXVxuXHRcdHViby5idWZmLmNwdV9idWZmWzJdID0gZGVmYXVsdF9mcmFtZWJ1ZmZlci50ZXh0dXJlc1swXS5yZXNbMF1cblx0XHR1Ym8uYnVmZi5jcHVfYnVmZlszXSA9IGRlZmF1bHRfZnJhbWVidWZmZXIudGV4dHVyZXNbMF0ucmVzWzFdXG5cdFx0dWJvLmJ1ZmYuY3B1X2J1ZmZbNF0gPSBpc09uTW9iaWxlID8gMSA6IDBcblx0XHR1Ym8uYnVmZi51cGxvYWQoKVxuXHR9XG5cblx0Y29uc3QgcGlja19mcm9tX2NhbnZhcyA9ICgpID0+IHtcblx0XHRsZXQgY29vcmQgPSBVdGlscy50ZXh0dXJlX05EQ190b190ZXh0dXJlX3BpeGVsX2Nvb3Jkcyhcblx0XHRcdFV0aWxzLnNjcmVlbl9ORENfdG9fY2FudmFzX05EQyhbLi4uaW8ubW91c2VfcG9zXSwgZGVmYXVsdF9mcmFtZWJ1ZmZlci50ZXh0dXJlc1swXSwgY2FudmFzX3JlYWRfdGV4LCB6b29tWzBdLCBwYW5uaW5nKSxcblx0XHRcdGNhbnZhc19yZWFkX3RleCxcblx0XHQpXG5cdFx0bGV0IGMgPSBjYW52YXNfcmVhZF90ZXgucmVhZF9iYWNrX3BpeGVsKGNvb3JkKVxuXHRcdC8vIGNvbnNvbGUubG9nKGMpXG5cblx0XHRwaWNrZWRfY29sID0gWy4uLmNdXG5cdFx0cGlja2VkX2NvbFswXSA9IGNbMF0gLyAyNTVcblx0XHRwaWNrZWRfY29sWzFdID0gY1sxXSAvIDI1NVxuXHRcdHBpY2tlZF9jb2xbMl0gPSBjWzJdIC8gMjU1XG5cdFx0cGlja2VkX2NvbFswXSA9IHBvdyhwaWNrZWRfY29sWzBdLCAwLjQ1NDU0NTQ1NDU0NTQ1KVxuXHRcdHBpY2tlZF9jb2xbMV0gPSBwb3cocGlja2VkX2NvbFsxXSwgMC40NTQ1NDU0NTQ1NDU0NSlcblx0XHRwaWNrZWRfY29sWzJdID0gcG93KHBpY2tlZF9jb2xbMl0sIDAuNDU0NTQ1NDU0NTQ1NDUpXG5cdFx0cGlja2VkX2NvbC5wb3AoKVxuXHRcdHJldHVybiBjXG5cdH1cblxuXHRjb25zdCBvcGVuTW9kYWwgPSAobW9kYWw6IFNlbWlNb2RhbCkgPT4ge1xuXHRcdGZvciAobGV0IG0gb2YgbW9kYWxzKSB7XG5cdFx0XHRpZiAobSA9PT0gbW9kYWwpIHtcblx0XHRcdFx0aWYgKG0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0bS5oaWRkZW4gPSBmYWxzZVxuXHRcdFx0XHRcdG0ua25vYi5tb2RhbEhpZGRlbiA9IGZhbHNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bS5oaWRkZW4gPSB0cnVlXG5cdFx0XHRcdFx0bS5rbm9iLm1vZGFsSGlkZGVuID0gdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBtLmhpZGUoKVxuXHRcdFx0XHRtLmhpZGRlbiA9IHRydWVcblx0XHRcdFx0bS5rbm9iLm1vZGFsSGlkZGVuID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGNvbnN0IGluaXRfd2ViX2dsID0gKCkgPT4ge1xuXHRcdHdpbmRvdy5pc09uTW9iaWxlID0gVXRpbHMuaXNPbk1vYmlsZSgpXG5cdFx0Ly9AdHMtaWdub3JlXG5cdFx0d2luZG93LmdsID0gZ2wgPSBjYW52YXNFbGVtZW50LmdldENvbnRleHQoJ3dlYmdsMicsIHtcblx0XHRcdHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZSxcblx0XHRcdGFscGhhOiBmYWxzZSxcblx0XHRcdHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG5cdFx0XHRhbnRpYWxpYXM6IHRydWVcblx0XHR9KVxuXHRcdGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcblx0XHRnbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpO1xuXHRcdGdsLmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuXG5cblx0XHRnbC5kZWJ1Z0VuYWJsZWQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50J1xuXHRcdGdsLmRlYnVnRW5hYmxlZCA9IGZhbHNlXG5cdFx0aW5pdF9nbF9lcnJvcl9oYW5kbGluZygpXG5cblx0XHR1c2VyQWdlbnRSZXMgPSBbY2FudmFzRWxlbWVudC5jbGllbnRXaWR0aCwgY2FudmFzRWxlbWVudC5jbGllbnRXaWR0aF1cblxuXHRcdGRlZmF1bHRfZnJhbWVidWZmZXIgPSBPYmplY3QuY3JlYXRlKEZyYW1lYnVmZmVyLnByb3RvdHlwZSlcblx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLmRlZmF1bHQgPSB0cnVlXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci5wb25nYWJsZSA9IGZhbHNlXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci5uZWVkc19wb25nID0gZmFsc2Vcblx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLnBvbmdfaWR4ID0gMFxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLl9mYiA9IG51bGxcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci5fdGV4dHVyZXMgPSBbT2JqZWN0LmNyZWF0ZShUZXh0dXJlLnByb3RvdHlwZSldXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci50ZXh0dXJlc1swXS5yZXMgPSBbLi4udXNlckFnZW50UmVzXVxuXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci5iaW5kKClcblxuXHRcdGNhbnZhc19mYiA9IG5ldyBGcmFtZWJ1ZmZlcihbXG5cdFx0XHRuZXcgVGV4dHVyZShbcHJvamVjdC5jYW52YXNSZXNbMF0sIHByb2plY3QuY2FudmFzUmVzWzFdXSwgZ2wuUkdCQTE2RiwgIWlzT25Nb2JpbGUpIFxuXHRcdF0sIHRydWUpXG5cblx0XHR0ZW1wX3VuZG9fZmIgPSBuZXcgRnJhbWVidWZmZXIoW1xuXHRcdFx0bmV3IFRleHR1cmUoW3Byb2plY3QuY2FudmFzUmVzWzBdLCBwcm9qZWN0LmNhbnZhc1Jlc1sxXV0sIGdsLlJHQkExNkYsIGZhbHNlKSBcblx0XHRdLCBmYWxzZSlcblx0XHRcblxuXHRcdHVibyA9IG5ldyBVQk8oKVxuXHRcdHdpbmRvdy51Ym8gPSB1Ym9cblx0XHRcblxuXHRcdHJlc2l6ZURlZmF1bHRGcmFtZWJ1ZmZlcklmTmVlZGVkKGNhbnZhc0VsZW1lbnQsIGRlZmF1bHRfZnJhbWVidWZmZXIsIHVzZXJBZ2VudFJlcywgKGUpID0+IHt9LCAoKT0+e3NldF9zaGFyZWRfdW5pZm9ybXMoKX0pXG5cdFx0c2V0X3NoYXJlZF91bmlmb3JtcygpXG5cblx0XHRnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSlcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpXG5cdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKVxuXHRcdFxuXHRcdC8vIGdsLmJsZW5kXG5cdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsKTtcblx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREKSBcblx0fVxuXHRjb25zdCBpbml0X290aGVyX3N0dWZmID0gYXN5bmMgKCkgPT4ge1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsKGV2ZW50KT0+e1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9KVxuXHRcdGlmIChcIndha2VMb2NrXCIgaW4gbmF2aWdhdG9yKSB7XG5cdFx0XHQvLyBpc1N1cHBvcnRlZCA9IHRydWU7XG5cdFx0XHRjb25zdCB3YWtlTG9jayA9IGF3YWl0IG5hdmlnYXRvci53YWtlTG9jay5yZXF1ZXN0KFwic2NyZWVuXCIpO1xuXHRcdFx0Ly8gYWxlcnQoXCJ3YWtlIGxvY2tcIilcblx0XHR9IFxuXHRcdGlvID0gbmV3IElPKClcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChldmVudCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSlcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0d2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCAoKT0+IHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBudWxsLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cdFx0fSk7XG5cblx0XHRicnVzaF90ZXh0dXJlcy5wdXNoKFxuXHRcdFx0YXdhaXQgQnJ1c2hUZXh0dXJlLmNyZWF0ZShyZXF1aXJlKFwiLy4uL3B1YmxpYy9pbWFnZXMvYnJvdy53ZWJwXCIpLmRlZmF1bHQsIDApXG5cdFx0KVxuXHRcdGJydXNoX3RleHR1cmVzLnB1c2goXG5cdFx0XHRhd2FpdCBCcnVzaFRleHR1cmUuY3JlYXRlKHJlcXVpcmUoXCIvLi4vcHVibGljL2ltYWdlcy9jaGFyY29hbC53ZWJwXCIpLmRlZmF1bHQsIDEpXG5cdFx0KVxuXHRcdGJydXNoX3RleHR1cmVzLnB1c2goXG5cdFx0XHRhd2FpdCBCcnVzaFRleHR1cmUuY3JlYXRlKHJlcXVpcmUoXCIvLi4vcHVibGljL2ltYWdlcy9jaXJjbGUud2VicFwiKS5kZWZhdWx0LCAyKVxuXHRcdClcblx0XHRicnVzaF90ZXh0dXJlcy5wdXNoKFxuXHRcdFx0YXdhaXQgQnJ1c2hUZXh0dXJlLmNyZWF0ZShyZXF1aXJlKFwiLy4uL3B1YmxpYy9pbWFnZXMvZ3JhZGllbnRfYm90dG9tX3RvX3RvcC53ZWJwXCIpLmRlZmF1bHQsIDMpXG5cdFx0KVxuXHRcdGJydXNoX3RleHR1cmVzLnB1c2goXG5cdFx0XHRhd2FpdCBCcnVzaFRleHR1cmUuY3JlYXRlKHJlcXVpcmUoXCIvLi4vcHVibGljL2ltYWdlcy9vaWxfMDEud2VicFwiKS5kZWZhdWx0LCA0KVxuXHRcdClcblx0XHRicnVzaF90ZXh0dXJlcy5wdXNoKFxuXHRcdFx0YXdhaXQgQnJ1c2hUZXh0dXJlLmNyZWF0ZShyZXF1aXJlKFwiLy4uL3B1YmxpYy9pbWFnZXMvb2lsX3RhcGVyLndlYnBcIikuZGVmYXVsdCwgNSlcblx0XHQpXG5cdFx0YnJ1c2hfdGV4dHVyZXMucHVzaChcblx0XHRcdGF3YWl0IEJydXNoVGV4dHVyZS5jcmVhdGUocmVxdWlyZShcIi8uLi9wdWJsaWMvaW1hZ2VzL3NxdWFyZS53ZWJwXCIpLmRlZmF1bHQsIDYpXG5cdFx0KVxuXHRcdGJydXNoX3RleHR1cmVzID0gWy4uLmJydXNoX3RleHR1cmVzXVxuXG5cdFx0Zm9yKGxldCBicnVzaCBvZiBicnVzaF9wcmVzZXRzKXtcblx0XHRcdGJydXNoLnNlbGVjdGVkX2JydXNoX3RleHR1cmUgPSBicnVzaF90ZXh0dXJlc1swXVxuXHRcdH1cblx0XHRcblx0XHQvLyB3aW5kb3cub25iZWZvcmV1bmxvYWQgPSBhc3luYyAoKT0+IHtcblx0XHQvLyBcdGNvbnN0IGlzX3NhZmUgPSBhd2FpdCBpc19zYWZlX3RvX3N3aXRjaF90b19uZXdfcHJvamVjdCgpXG5cdFx0Ly8gXHRjb25zb2xlLmxvZyhpc19zYWZlKVxuXHRcdC8vIFx0Ly8gaWYoISl7XG5cdFx0Ly8gXHRcdHJldHVybiAnRG8geW91IHdhbnQgdG8gbGVhdmUgdGhpcyBwYWdlPyc7XG5cdFx0Ly8gXHQvLyB9IGVsc2Uge1xuXHRcdC8vIFx0cmV0dXJuIFwiYW1vZ1wiXG5cdFx0Ly8gXHQvLyB9XG5cdFx0Ly8gfVxuXHRcdG1vZGFscyA9IFtjaGFvc1NlbWlNb2RhbCwgZHluYW1pY3NTZW1pTW9kYWwsIHRleER5bmFtaWNzU2VtaU1vZGFsXVxuXHR9XG5cblx0b25Nb3VudChhc3luYyAoKSA9PiB7XG5cdFx0aW5pdF93ZWJfZ2woKVxuXHRcdGF3YWl0IGluaXRfb3RoZXJfc3R1ZmYoKVxuXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci5iaW5kKClcblx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLmNsZWFyKFswLCAwLCAwLCAxXSlcbiBcblx0XHRjYW52YXNfZmIuY2xlYXIoWzAsIDAsIDAsIDBdKVxuXHRcdGNhbnZhc19mYi5wb25nKClcblx0XHRjYW52YXNfZmIuYmFja190ZXh0dXJlc1swXS5iaW5kX3RvX3VuaXQoMSlcblx0XHRjYW52YXNfZmIuY2xlYXIoWzAsIDAsIDAsIDBdKVxuXG5cdFx0Y29uc3QgdGVtcF9zdHJva2VfZmIgPSBuZXcgRnJhbWVidWZmZXIoW1xuXHRcdFx0bmV3IFRleHR1cmUoW3Byb2plY3QuY2FudmFzUmVzWzBdLCBwcm9qZWN0LmNhbnZhc1Jlc1sxXV0sIGdsLlJHQkExNkYsICFpc09uTW9iaWxlKVxuXHRcdF0pXG5cdFx0dGVtcF9zdHJva2VfZmIuY2xlYXIoWzAsIDAsIDAsIDBdKVxuXG5cdFx0Ly8hIC0tLS0tLS0tLS0tLS0tLS0tLS0gU0hBREVSU1xuXHRcdGNvbnN0IGluaXRfdGV4dHVyZV91bmlmb3JtcyA9IChwcm9ncmFtOiBTaGFkZXJQcm9ncmFtKSA9Pntcblx0XHRcdHByb2dyYW0uc2V0VW5pZm9ybVRleHR1cmUoJ3RlbXBfdGV4JywgdGVtcF9zdHJva2VfZmIudGV4dHVyZXNbMF0sIDApXG5cdFx0XHRwcm9ncmFtLnNldFVuaWZvcm1UZXh0dXJlKCdjYW52YXNfYmFjaycsIGNhbnZhc19mYi5iYWNrX3RleHR1cmVzWzBdLCAxKVxuXHRcdFx0cHJvZ3JhbS5zZXRVbmlmb3JtVGV4dHVyZSgnY2FudmFzX2InLCBjYW52YXNfZmIuX3RleHR1cmVzWzBdLCAyKVxuXHRcdFx0cHJvZ3JhbS5zZXRVbmlmb3JtVGV4dHVyZSgnY2FudmFzX2EnLCBjYW52YXNfZmIuX2JhY2tfdGV4dHVyZXNbMF0sIDMpXG5cdFx0XHQvLyBwcm9ncmFtLnNldFVuaWZvcm1UZXh0dXJlKCdjYW52YXNfYScsIGNhbnZhc19mYi5fYmFja190ZXh0dXJlc1swXSwgMylcblx0XHRcdFxuXHRcdFx0Y29uc3QgYnJ1c2hfdGV4X3N0YXJ0X2lkeCA9IDVcblx0XHRcdGJydXNoX3RleHR1cmVzLmZvckVhY2goKGJydXNoX3RleCwgaSApPT57XG5cdFx0XHRcdGNvbnN0IG5hbWUgPSBgYnJ1c2hfdGV4dHVyZVske2l9XWBcblx0XHRcdFx0Y29uc29sZS5sb2cobmFtZSlcblx0XHRcdFx0Y29uc3QgYnJ1c2hfdGV4dHVyZXNfbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0ucHJvZ3JhbSwgbmFtZSlcblx0XHRcdFx0YnJ1c2hfdGV4LmdwdV90ZXguYmluZF90b191bml0KGJydXNoX3RleF9zdGFydF9pZHggKyBpKVx0XHRcdFx0XG5cdFx0XHRcdGdsLnVuaWZvcm0xaShicnVzaF90ZXh0dXJlc19sb2MsIGJydXNoX3RleF9zdGFydF9pZHggKyBpKTtcblx0XHRcdH0pXG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKSAvLyBUT0RFTEVURVxuXHRcdH1cblx0XHRjb25zdCBicnVzaF9wcmV2aWV3X3Byb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShyZXF1aXJlKCdzaGFkZXJzL2JydXNoX3ByZXZpZXcudmVydCcpLCByZXF1aXJlKCdzaGFkZXJzL2JydXNoX3ByZXZpZXcuZnJhZycpKVxuXHRcdGNvbnN0IHBpY2tlcl9wcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0ocmVxdWlyZSgnc2hhZGVycy9waWNrZXIudmVydCcpLCByZXF1aXJlKCdzaGFkZXJzL3BpY2tlci5mcmFnJykpXG5cdFx0Y29uc3QgY29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfcHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKFxuXHRcdFx0cmVxdWlyZSgnc2hhZGVycy9jb21wb3NpdGVfdGVtcF9zdHJva2VfdG9fY2FudmFzLnZlcnQnKSxcblx0XHRcdHJlcXVpcmUoJ3NoYWRlcnMvY29tcG9zaXRlX3RlbXBfc3Ryb2tlX3RvX2NhbnZhcy5mcmFnJyksXG5cdFx0KVxuXHRcdGNvbnN0IGNvbXBvc2l0ZV9zdHJva2VfdG9fY2FudmFzX2JfcHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKFxuXHRcdFx0cmVxdWlyZSgnc2hhZGVycy9jb21wb3NpdGVfdGVtcF9zdHJva2VfdG9fY2FudmFzLnZlcnQnKSxcblx0XHRcdHJlcXVpcmUoJ3NoYWRlcnMvY29tcG9zaXRlX3RlbXBfc3Ryb2tlX3RvX2NhbnZhc19iLmZyYWcnKSxcblx0XHQpXG5cdFx0Y29uc3QgcG9zdF9jYW52YXNfcHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKHJlcXVpcmUoJ3NoYWRlcnMvcG9zdF9jYW52YXMudmVydCcpLCByZXF1aXJlKCdzaGFkZXJzL3Bvc3RfY2FudmFzLmZyYWcnKSlcblx0XHQvL0B0cy1pZ25vcmVcblx0XHRwb3N0X2NhbnZhc19wcm9ncmFtLnpvb21fbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHBvc3RfY2FudmFzX3Byb2dyYW0ucHJvZ3JhbSwgXCJ6b29tXCIpXG5cdFx0Ly9AdHMtaWdub3JlXG5cdFx0cG9zdF9jYW52YXNfcHJvZ3JhbS5wYW5uaW5nX2xvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwb3N0X2NhbnZhc19wcm9ncmFtLnByb2dyYW0sIFwicGFubmluZ1wiKVxuXHRcdC8vQHRzLWlnbm9yZVxuXHRcdHBvc3RfY2FudmFzX3Byb2dyYW0uYmxlbmRpbmdfY29sb3VyX3NwYWNlX2xvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwb3N0X2NhbnZhc19wcm9ncmFtLnByb2dyYW0sIFwiYmxlbmRpbmdfY29sb3VyX3NwYWNlXCIpXG5cdFx0XG5cdFx0Y29uc3QgYnJ1c2hfbG9uZ19wcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0ocmVxdWlyZSgnc2hhZGVycy9icnVzaF9sb25nLnZlcnQnKSwgcmVxdWlyZSgnc2hhZGVycy9icnVzaF9sb25nLmZyYWcnKSlcblxuXHRcdGJydXNoX3ByZXZpZXdfcHJvZ3JhbS51c2UoKVxuXHRcdGluaXRfdGV4dHVyZV91bmlmb3JtcyhicnVzaF9wcmV2aWV3X3Byb2dyYW0pXG5cdFx0cGlja2VyX3Byb2dyYW0udXNlKClcblx0XHRpbml0X3RleHR1cmVfdW5pZm9ybXMocGlja2VyX3Byb2dyYW0pXG5cdFx0Y29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfcHJvZ3JhbS51c2UoKVxuXHRcdGluaXRfdGV4dHVyZV91bmlmb3Jtcyhjb21wb3NpdGVfc3Ryb2tlX3RvX2NhbnZhc19wcm9ncmFtKVxuXHRcdGNvbXBvc2l0ZV9zdHJva2VfdG9fY2FudmFzX2JfcHJvZ3JhbS51c2UoKVxuXHRcdGluaXRfdGV4dHVyZV91bmlmb3Jtcyhjb21wb3NpdGVfc3Ryb2tlX3RvX2NhbnZhc19iX3Byb2dyYW0pXG5cdFx0Ly9AdHMtaWdub3JlXG5cdFx0Y29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfcHJvZ3JhbS5ibGVuZGluZ19jb2xvdXJfc3BhY2VfbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGNvbXBvc2l0ZV9zdHJva2VfdG9fY2FudmFzX3Byb2dyYW0ucHJvZ3JhbSwgXCJibGVuZGluZ19jb2xvdXJfc3BhY2VcIilcblxuXHRcdC8vQHRzLWlnbm9yZVxuXHRcdGNvbXBvc2l0ZV9zdHJva2VfdG9fY2FudmFzX2JfcHJvZ3JhbS5ibGVuZGluZ19jb2xvdXJfc3BhY2VfbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGNvbXBvc2l0ZV9zdHJva2VfdG9fY2FudmFzX2JfcHJvZ3JhbS5wcm9ncmFtLCBcImJsZW5kaW5nX2NvbG91cl9zcGFjZVwiKVxuXG5cdFx0cG9zdF9jYW52YXNfcHJvZ3JhbS51c2UoKVxuXHRcdGluaXRfdGV4dHVyZV91bmlmb3Jtcyhwb3N0X2NhbnZhc19wcm9ncmFtKVxuXG5cdFx0YnJ1c2hfbG9uZ19wcm9ncmFtLnVzZSgpXG5cdFx0aW5pdF90ZXh0dXJlX3VuaWZvcm1zKGJydXNoX2xvbmdfcHJvZ3JhbSlcblx0XHQvL0B0cy1pZ25vcmVcblx0XHRicnVzaF9sb25nX3Byb2dyYW0uYnJ1c2hfdGV4dHVyZV9pZHhfbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGJydXNoX2xvbmdfcHJvZ3JhbS5wcm9ncmFtLCBcImJydXNoX3RleHR1cmVfaWR4XCIpXG5cdFx0Ly9AdHMtaWdub3JlXG5cdFx0YnJ1c2hfbG9uZ19wcm9ncmFtLnRleF9oc3ZfZHluYW1pY3NfbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGJydXNoX2xvbmdfcHJvZ3JhbS5wcm9ncmFtLCBcInRleF9oc3ZfZHluYW1pY3NcIilcblx0XHQvL0B0cy1pZ25vcmVcblx0XHRicnVzaF9sb25nX3Byb2dyYW0udGV4X3N0cmV0Y2hfbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGJydXNoX2xvbmdfcHJvZ3JhbS5wcm9ncmFtLCBcInRleF9zdHJldGNoXCIpXG5cdFx0XG5cblx0XHQvLyEgLS0tLS0tLS0tLS0tLS0tLS0tLSBQT1NUXG5cdFx0bGV0IGZyYW1lID0gMFxuXHRcdGNhbnZhc19yZWFkX3RleCA9IGNhbnZhc19mYi50ZXh0dXJlc1swXVxuXG5cblx0XHRsZXQgYnJ1c2hfYnVmZmVyID0gbmV3IFRoaW5nKFxuXHRcdFx0W25ldyBWZXJ0ZXhCdWZmZXIoNCwgZ2wuRkxPQVQpLCBuZXcgVmVydGV4QnVmZmVyKDQsIGdsLkZMT0FUKV0sXG5cdFx0XHRnbC5UUklBTkdMRVMsXG5cdFx0XHRicnVzaF9sb25nX3Byb2dyYW1cblx0XHQpXG5cdFx0Z2wuYmluZFZlcnRleEFycmF5KGJydXNoX2J1ZmZlci52YW8pXG5cdFx0XG5cblx0XHRsZXQgdDogbnVtYmVyID0gMFxuXHRcdGxldCBkZWx0YV90OiBudW1iZXIgPSAwXG5cdFx0bGV0IHJlZHJhd19uZWVkZWQgPSBmYWxzZVxuXHRcdGxldCByZWRyYXdpbmcgPSBmYWxzZVxuXG5cdFx0bGV0IHJlZG9faGlzdG9yeV9sZW5ndGggPSAwXG5cblx0XHRsZXQgYnJ1c2hfc3Ryb2tlID0gbmV3IEJydXNoU3Ryb2tlKFxuXHRcdFx0Y3Vycl9icnVzaC5zZWxlY3RlZF9icnVzaF90eXBlLCBcblx0XHRcdG5ldyBEcmF3UGFyYW1zKGN1cnJfYnJ1c2gudGV4X2R5bmFtaWNzLCBjdXJyX2JydXNoLnRleF9sY2hfZHluYW1pY3MsIGN1cnJfYnJ1c2gudGV4X3N0cmV0Y2gsIEJsZW5kaW5nQ29sb3VyU3BhY2UuUGlnbWVudHMpLFxuXHRcdFx0XHRjdXJyX2JydXNoLnNlbGVjdGVkX2JydXNoX3RleHR1cmVcblx0XHRcdClcblxuXG5cdFx0ZHJhd2VyID0gbmV3IERyYXdlcihcblx0XHRcdGdsLFxuXHRcdFx0Y2FudmFzX2ZiLnRleHR1cmVzWzBdLFxuXHRcdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlcixcblx0XHQpXG5cdFx0Y29uc3QgY29tcG9zaXRlX3N0cm9rZSA9ICgpID0+IHtcblx0XHRcdC8vIGdsLmRpc2FibGUoZ2wuQkxFTkQpXG5cdFx0XHRjYW52YXNfZmIuYmluZCgpXG5cdFx0XHRjYW52YXNfZmIuY2xlYXIoKVxuXG5cdFx0XHRjb25zdCBjb21wX3Byb2dyYW0gPSBjYW52YXNfZmIucG9uZ19pZHggPT09IDAgPyBjb21wb3NpdGVfc3Ryb2tlX3RvX2NhbnZhc19wcm9ncmFtIDogY29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfYl9wcm9ncmFtXG5cdFx0XHRpZihjYW52YXNfZmIucG9uZ19pZHggPT09IDApe1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdGNvbXBfcHJvZ3JhbS51c2UoKVxuXHRcdFx0Ly8gY29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfcHJvZ3JhbS5zZXRVbmlmb3JtRmxvYXQoXCJwb25nX2lkeFwiLCBjYW52YXNfZmIucG9uZ19pZHgpXG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRnbC51bmlmb3JtMWkoY29tcF9wcm9ncmFtLmJsZW5kaW5nX2NvbG91cl9zcGFjZV9sb2MsIGJsZW5kaW5nX2NvbG91cl9zcGFjZSlcblx0XHRcdGNhbnZhc19mYi5iYWNrX3RleHR1cmVzWzBdLmJpbmRfdG9fdW5pdCgxKVxuXHRcdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNClcblx0XHRcdHRlbXBfc3Ryb2tlX2ZiLmNsZWFyKClcblx0XHR9XG5cdFx0XG5cdFx0Y29uc3QgZHJhd19uX3N0cm9rZXMgPSAoc3RhcnRfaWR4OiBudW1iZXIgfCB1bmRlZmluZWQsIGVuZF9pZHg6IG51bWJlciB8IHVuZGVmaW5lZCwgZnVsbF9yZWRyYXc6IGJvb2xlYW4gPSBmYWxzZSk9Pntcblx0XHRcdGxldCBrID0gMFxuXHRcdFx0XG5cdFx0XHRkcmF3ZXIuYnJ1c2hfYnVmZmVyID0gYnJ1c2hfYnVmZmVyXG5cdFx0XHRkcmF3ZXIucmVzZXQoKVxuXHRcdFx0XG5cdFx0XHRzdGFydF9pZHggPSBzdGFydF9pZHggPz8gMFxuXHRcdFx0ZW5kX2lkeCA9IGVuZF9pZHggPz8gcHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aFxuXHRcdFx0XG5cblx0XHRcdC8vIGNvbnN0IHN0YXJ0X2lkeCA9IHByb2plY3QuYnJ1c2hfc3Ryb2tlcy5sZW5ndGggLSBzdHJva2VfY250XG5cdFx0XHQvLyBjb25zdCBlbmRfaWR4ID0gcHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aCAtIHN0cm9rZV9jbnRcblx0XHRcdGZvcihrID0gc3RhcnRfaWR4OyBrIDwgZW5kX2lkeDsgaysrKXtcblx0XHRcdFx0ZHJhd2VyLnB1c2hfYW55X3N0cm9rZShwcm9qZWN0LmJydXNoX3N0cm9rZXNba10pXG5cdFx0XHR9XG5cblx0XHRcdGRyYXdlci5icnVzaF9idWZmZXIudXBsb2FkX2FsbF9idWZmcygpXG5cdFx0XHRjb25zdCBicnVzaF9zaGFkZXIgPSBkcmF3ZXIuYnJ1c2hfYnVmZmVyLnNoYWRlclxuXHRcdFx0YnJ1c2hfc2hhZGVyLnVzZSgpXG5cblx0XHRcdGxldCBwcmV2X2NvbG91cl9zcGFjZSA9IC0xXG5cdFx0XHRsZXQgcHJldl9jb2xvdXJfc3BhY2VfYiA9IC0xXG5cdFx0XHRsZXQgcHJldl9icnVzaF90ZXhfaWR4ID0gLTFcblx0XHRcdFxuXHRcdFx0bGV0IHByZXZfaHN2X2R5bmFtaWNzID0gWzAsMCwwXVxuXHRcdFx0bGV0IHByZXZfdGV4X3N0cmV0Y2ggPSBbMCwwXVxuXG5cdFx0XHRnbC51c2VQcm9ncmFtKGNvbXBvc2l0ZV9zdHJva2VfdG9fY2FudmFzX3Byb2dyYW0ucHJvZ3JhbSlcblxuXHRcdFx0Y2FudmFzX2ZiLl90ZXh0dXJlc1swXS5iaW5kX3RvX3VuaXQoMilcblx0XHRcdGNhbnZhc19mYi5fYmFja190ZXh0dXJlc1swXS5iaW5kX3RvX3VuaXQoMylcblxuXHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMTUpXG5cdFx0XHRsZXQgY29tcF9wcm9ncmFtID0gY29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfcHJvZ3JhbVxuXHRcdFx0Z2wuY2xlYXJDb2xvcigwLDAsMCwwKVxuXHRcdFx0Z2wudmlld3BvcnQoMCwgMCwgcHJvamVjdC5jYW52YXNSZXNbMF0sIHByb2plY3QuY2FudmFzUmVzWzFdKVxuXG5cdFx0XHRrID0gc3RhcnRfaWR4XG5cdFx0XHRsZXQgaiA9IDBcblx0XHRcdGZvcihsZXQgYW1vZ3VzIG9mIGRyYXdlci5yZWNvcmRlZF9kcmF3Y2FsbHMpe1xuXHRcdFx0XHRjb25zdCBuZXdfdGV4X3N0cmV0Y2ggPSBwcm9qZWN0LmJydXNoX3N0cm9rZXNba10uZHJhd19wYXJhbXMudGV4X3N0cmV0Y2hcblx0XHRcdFx0Y29uc3QgbmV3X2hzdl9keW5hbWljcyA9IHByb2plY3QuYnJ1c2hfc3Ryb2tlc1trXS5kcmF3X3BhcmFtcy50ZXhfbGNoX2R5bmFtaWNzXG5cblx0XHRcdFx0Y29uc3QgbmV3X2JydXNoX3RleF9pZHggPSBwcm9qZWN0LmJydXNoX3N0cm9rZXNba10uYnJ1c2hfdGV4dHVyZS5pZHhcblx0XHRcdFx0Y29uc3QgbmV3X2NvbF9zcGFjZSA9IHByb2plY3QuYnJ1c2hfc3Ryb2tlc1trXS5kcmF3X3BhcmFtcy5ibGVuZGluZ19jb2xvdXJfc3BhY2VcblxuXHRcdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRlbXBfc3Ryb2tlX2ZiLmZiKVxuXHRcdFx0XHRnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKVxuXG5cdFx0XHRcdGJydXNoX3NoYWRlci51c2UoKVxuXG5cdFx0XHRcdGlmKG5ld19icnVzaF90ZXhfaWR4ICE9PSBwcmV2X2JydXNoX3RleF9pZHgpe1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRnbC51bmlmb3JtMWkoYnJ1c2hfc2hhZGVyLmJydXNoX3RleHR1cmVfaWR4X2xvYywgcHJldl9icnVzaF90ZXhfaWR4ID0gbmV3X2JydXNoX3RleF9pZHggKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKFxuXHRcdFx0XHRcdHByZXZfaHN2X2R5bmFtaWNzWzBdICE9PSBuZXdfaHN2X2R5bmFtaWNzWzBdIHx8IFxuXHRcdFx0XHRcdHByZXZfaHN2X2R5bmFtaWNzWzFdICE9PSBuZXdfaHN2X2R5bmFtaWNzWzFdIHx8IFxuXHRcdFx0XHRcdHByZXZfaHN2X2R5bmFtaWNzWzJdICE9PSBuZXdfaHN2X2R5bmFtaWNzWzJdIFxuXHRcdFx0XHQpe1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRnbC51bmlmb3JtM2Z2KGJydXNoX3NoYWRlci50ZXhfaHN2X2R5bmFtaWNzX2xvYywgcHJvamVjdC5icnVzaF9zdHJva2VzW2tdLmRyYXdfcGFyYW1zLnRleF9sY2hfZHluYW1pY3MgKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKFxuXHRcdFx0XHRcdHByZXZfdGV4X3N0cmV0Y2hbMF0gIT09IG5ld190ZXhfc3RyZXRjaFswXSB8fCBcblx0XHRcdFx0XHRwcmV2X3RleF9zdHJldGNoWzFdICE9PSBuZXdfdGV4X3N0cmV0Y2hbMV0gXG5cdFx0XHRcdCl7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdGdsLnVuaWZvcm0yZnYoYnJ1c2hfc2hhZGVyLnRleF9zdHJldGNoX2xvYywgcHJvamVjdC5icnVzaF9zdHJva2VzW2tdLmRyYXdfcGFyYW1zLnRleF9zdHJldGNoIClcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRyYXdlci5kcmF3X3N0cm9rZV9pZHgoailcblxuXHRcdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGNhbnZhc19mYi5mYilcblxuXHRcdFx0XHRjb21wX3Byb2dyYW0gPSBjYW52YXNfZmIucG9uZ19pZHggPT09IDAgPyBjb21wb3NpdGVfc3Ryb2tlX3RvX2NhbnZhc19wcm9ncmFtIDogY29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfYl9wcm9ncmFtXG5cdFx0XHRcdGNvbXBfcHJvZ3JhbS51c2UoKVxuXG5cdFx0XHRcdGlmKGNhbnZhc19mYi5wb25nX2lkeCA9PT0gMCl7XG5cdFx0XHRcdFx0aWYobmV3X2NvbF9zcGFjZSAhPT0gcHJldl9jb2xvdXJfc3BhY2Upe1xuXHRcdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTFpKGNvbXBfcHJvZ3JhbS5ibGVuZGluZ19jb2xvdXJfc3BhY2VfbG9jLCBwcmV2X2NvbG91cl9zcGFjZSA9IG5ld19jb2xfc3BhY2UpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmKG5ld19jb2xfc3BhY2UgIT09IHByZXZfY29sb3VyX3NwYWNlX2Ipe1xuXHRcdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTFpKGNvbXBfcHJvZ3JhbS5ibGVuZGluZ19jb2xvdXJfc3BhY2VfbG9jLCBwcmV2X2NvbG91cl9zcGFjZV9iID0gbmV3X2NvbF9zcGFjZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KVxuXG5cdFx0XHRcdGNhbnZhc19mYi5wb25nKClcblx0XHRcdFx0XG5cdFx0XHRcdGlmKGZ1bGxfcmVkcmF3ICYmIGogPT09IGVuZF9pZHggLSAoZW5kX2lkeCAlIHVuZG9fY2FjaGVfc3RlcHMpIC0gMSl7XG5cdFx0XHRcdFx0Y29weV9mYl90b19mYihjYW52YXNfZmIuZmJfYmFjaywgdGVtcF91bmRvX2ZiLmZiLCBjYW52YXNfZmIuX3RleHR1cmVzWzBdLnJlcylcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cHJldl9oc3ZfZHluYW1pY3NbMF0gPSBuZXdfaHN2X2R5bmFtaWNzWzBdXG5cdFx0XHRcdHByZXZfaHN2X2R5bmFtaWNzWzFdID0gbmV3X2hzdl9keW5hbWljc1sxXVxuXHRcdFx0XHRwcmV2X2hzdl9keW5hbWljc1syXSA9IG5ld19oc3ZfZHluYW1pY3NbMl0gXG5cdFx0XHRcdHByZXZfdGV4X3N0cmV0Y2hbMF0gPSBuZXdfdGV4X3N0cmV0Y2hbMF1cblx0XHRcdFx0cHJldl90ZXhfc3RyZXRjaFsxXSA9IG5ld190ZXhfc3RyZXRjaFsxXVxuXHRcdFx0XHRrKytcblx0XHRcdFx0aisrXG5cdFx0XHR9XG5cdFx0XHRyZWRyYXdfbmVlZGVkID0gdHJ1ZVxuXHRcdFx0dGVtcF9zdHJva2VfZmIuY2xlYXIoKVxuXG5cdFx0fVxuXHRcdFxuXHRcdC8vIGNvbnN0IHJlZHJhd191bmRvX3N0cm9rZXMgPSAoKT0+e1xuXHRcdC8vIFx0Y29weV9mYl90b190ZXh0dXJlKHRlbXBfdW5kb19mYiwgY2FudmFzX2ZiLmJhY2tfdGV4dHVyZXNbMF0pXG5cdFx0Ly8gXHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGNhbnZhc19mYi5mYilcblx0XHQvLyBcdGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXG5cdFx0Ly8gXHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRlbXBfc3Ryb2tlX2ZiLmZiKVxuXHRcdC8vIFx0Z2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVClcblxuXHRcdFx0XG5cdFx0Ly8gfVxuXG5cdFx0Y29uc3QgcmVkcmF3X3dob2xlX3Byb2plY3QgPSAoKSA9PiB7XG5cdFx0XHRjb25zb2xlLmxvZygnUkVEUkFXIEVWRVJZVEhJTkcnKVxuXHRcdFx0Y29uc29sZS50aW1lKFwiUkVEUkFXIEFMTFwiKVxuXHRcdFx0Y2FudmFzX2ZiLmNsZWFyKClcblx0XHRcdGNhbnZhc19mYi5wb25nKClcblx0XHRcdGNhbnZhc19mYi5iYWNrX3RleHR1cmVzWzBdLmJpbmRfdG9fdW5pdCgxKVxuXHRcdFx0Y2FudmFzX2ZiLmNsZWFyKClcblx0XHRcdHRlbXBfc3Ryb2tlX2ZiLmNsZWFyKClcblxuXG5cdFx0XHRkcmF3X25fc3Ryb2tlcygwLCBwcm9qZWN0LmJydXNoX3N0cm9rZXMubGVuZ3RoIC0gcmVkb19oaXN0b3J5X2xlbmd0aCwgdHJ1ZSlcblxuXHRcdFx0Y29uc29sZS50aW1lRW5kKFwiUkVEUkFXIEFMTFwiKVxuXHRcdH1cblx0XHRyZXNpemVfcHJvamVjdCA9IChuZXdfc3o6IG51bWJlcltdKTogdm9pZCA9PiB7XG5cdFx0XHRwcm9qZWN0LmNhbnZhc1JlcyA9IFsuLi5uZXdfc3pdXG5cdFx0XHR0ZW1wX3N0cm9rZV9mYi50ZXh0dXJlc1swXS5yZXNpemUobmV3X3N6KVxuXHRcdFx0Y2FudmFzX2ZiLmJhY2tfdGV4dHVyZXNbMF0ucmVzaXplKG5ld19zeilcblx0XHRcdGNhbnZhc19mYi50ZXh0dXJlc1swXS5yZXNpemUobmV3X3N6KVxuXHRcdFx0Y2FudmFzX2ZiLnJlY3JlYXRlKClcblx0XHRcdGNhbnZhc19mYi5iYWNrX3RleHR1cmVzWzBdLmJpbmRfdG9fdW5pdCgxKVxuXHRcdFx0dGVtcF9zdHJva2VfZmIucmVjcmVhdGUoKVxuXHRcdFx0dGVtcF9zdHJva2VfZmIudGV4dHVyZXNbMF0uYmluZF90b191bml0KDApXG5cdFx0XHR0ZW1wX3VuZG9fZmIudGV4dHVyZXNbMF0ucmVzaXplKG5ld19zeilcblx0XHRcdHRlbXBfdW5kb19mYi5yZWNyZWF0ZSgpXG5cdFx0XHRzZXRfc2hhcmVkX3VuaWZvcm1zKClcblx0XHRcdGZ1bGxfcmVkcmF3X25lZWRlZCA9IHRydWVcblx0XHRcdHByb2plY3RfaGFzX2JlZW5fbW9kaWZpZWQgPSBmYWxzZVxuXHRcdFx0cmVkb19oaXN0b3J5X2xlbmd0aCA9IDBcblx0XHR9XG5cdFx0XG5cdFx0bGV0IGxvYWRfcHJvamVjdCA9IChuZXdfcHJvamVjdDogUHJvamVjdCkgPT57XG5cdFx0XHRwcm9qZWN0ID0gbmV3IFByb2plY3QoKVxuXHRcdFx0cHJvamVjdF9oYXNfYmVlbl9tb2RpZmllZCA9IGZhbHNlXG5cdFx0XHRyZWRvX2hpc3RvcnlfbGVuZ3RoID0gMFxuXHRcdFx0Zm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKG5ld19wcm9qZWN0IGFzIE9iamVjdCkpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRwcm9qZWN0W2tleV0gPSBuZXdfcHJvamVjdFtrZXldXG5cdFx0XHR9XG5cdFx0XHRwcm9qZWN0LmNhbnZhc1JlcyA9IFsuLi5uZXdfcHJvamVjdC5jYW52YXNSZXNdXG5cdFx0XHRyZXNpemVfcHJvamVjdChwcm9qZWN0LmNhbnZhc1Jlcylcblx0XHRcdHJlZHJhd193aG9sZV9wcm9qZWN0KClcblx0XHR9XG5cdFx0bGV0IGxvY2FsX3N0b3JhZ2VfcHJvaiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwcm9qZWN0JylcblxuXHRcdGlmIChsb2NhbF9zdG9yYWdlX3Byb2opIHtcblx0XHRcdGxvY2FsX3N0b3JhZ2VfcHJvaiA9IEpTT04ucGFyc2UobG9jYWxfc3RvcmFnZV9wcm9qKVxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0bG9hZF9wcm9qZWN0KGxvY2FsX3N0b3JhZ2VfcHJvailcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gbG9hZF9wcm9qZWN0KG5ldyBQcm9qZWN0KCkpXG5cdFx0XHRsb2FkX3Byb2plY3QobmV3IFByb2plY3QoKSlcblx0XHR9XG5cdFx0XG5cdFx0Y29uc3QgaGFuZGxlX2lucHV0X2FjdGlvbnMgPSAoKT0+e1xuXHRcdFx0aWYgKGlvLmdldEtleSgnQWx0TGVmdCcpLmRvd24pIHtcblx0XHRcdFx0aWYgKGlvLmdldEtleSgnQWx0TGVmdCcpLmp1c3RfcHJlc3NlZCkge1xuXHRcdFx0XHRcdHBpY2tpbmcgPSB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0cGlja19mcm9tX2NhbnZhcygpXG5cdFx0XHR9IGVsc2UgaWYgKGlvLmdldEtleSgnQWx0TGVmdCcpLmp1c3RfdW5wcmVzc2VkKSB7XG5cdFx0XHRcdGp1c3RfZmluaXNoZWRfcGljayA9IHRydWVcblx0XHRcdFx0cGlja2luZyA9IGZhbHNlXG5cdFx0XHR9XG5cblx0XHRcdHJlZHJhd19uZWVkZWQgPSB0cnVlIC8vIFRPUkVNT1ZFXG5cblx0XHRcdGlmKGlvLmp1c3RfZmluaXNoZWRfcGluY2gpe1xuXHRcdFx0XHR6b29tWzBdID0gZGVzaXJlZF96b29tID0gcG93KDIsIGxvZzIoZGVzaXJlZF96b29tKSArIGlvLnBpbmNoX3pvb20pXG5cdFx0XHR9XG5cdFx0XHRpZihpby50d29fZmluZ2VyX3BpbmNoKXtcblx0XHRcdFx0cmVkcmF3X25lZWRlZCA9IHRydWVcblx0XHRcdFx0em9vbVswXSA9IHBvdygyLGxvZzIoZGVzaXJlZF96b29tKSAgKyBpby5waW5jaF96b29tKVxuXHRcdFx0XHRpZihpby5qdXN0X3N0YXJ0ZWRfcGluY2gpe1xuXHRcdFx0XHRcdHBhbm5pbmdfdGVtcF9waW5jaFswXSA9IHBhbm5pbmdbMF1cblx0XHRcdFx0XHRwYW5uaW5nX3RlbXBfcGluY2hbMV0gPSBwYW5uaW5nWzFdXG5cdFx0XHRcdH1cblx0XHRcdFx0cGFubmluZ1swXSA9IHBhbm5pbmdfdGVtcF9waW5jaFswXSArIGlvLnBpbmNoX3Bvc1swXVxuXHRcdFx0XHRwYW5uaW5nWzFdID0gcGFubmluZ190ZW1wX3BpbmNoWzFdIC0gaW8ucGluY2hfcG9zWzFdXG5cdFx0XHR9IGVsc2UgaWYoYWJzKGRlc2lyZWRfem9vbSAtIHpvb21bMF0pID4gMC4wMDAwMDAwMSApe1xuXHRcdFx0XHRyZWRyYXdfbmVlZGVkID0gdHJ1ZVxuXHRcdFx0XHR6b29tWzBdID0gbWl4KHpvb21bMF0sZGVzaXJlZF96b29tLGRlbHRhX3QqMjApXG5cdFx0XHR9XG5cdFx0XHRpZiAoZnJhbWUgPT09IDAgfHwgcGlja2luZyB8fCBqdXN0X2ZpbmlzaGVkX3BpY2sgfHwgaW8ubW91c2Vfd2hlZWwgfHwgaW8ubW1iX2Rvd24pIHtcblx0XHRcdFx0cmVkcmF3X25lZWRlZCA9IHRydWVcblx0XHRcdFx0aWYgKGp1c3RfZmluaXNoZWRfcGljaykge1xuXHRcdFx0XHRcdGxldCBjb29yZHMgPSBVdGlscy5zY3JlZW5fTkRDX3RvX2NhbnZhc19OREMoXG5cdFx0XHRcdFx0XHRbLi4uaW8ubW91c2VfcG9zXSxcblx0XHRcdFx0XHRcdGRlZmF1bHRfZnJhbWVidWZmZXIudGV4dHVyZXNbMF0sXG5cdFx0XHRcdFx0XHRjYW52YXNfZmIuX3RleHR1cmVzWzBdLFxuXHRcdFx0XHRcdFx0em9vbVswXSxcblx0XHRcdFx0XHRcdHBhbm5pbmcsXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdGlmIChjb29yZHNbMF0gPiAtMSAmJiBjb29yZHNbMF0gPCAxICYmIGNvb3Jkc1sxXSA+IC0xICYmIGNvb3Jkc1sxXSA8IDEpIHtcblx0XHRcdFx0XHRcdC8vIHN0cm9rZV9jb2wgPSBbLi4ucGlja2VkX2NvbF1cblx0XHRcdFx0XHRcdHN0cm9rZV9jb2xbMF0gPSBwaWNrZWRfY29sWzBdXG5cdFx0XHRcdFx0XHRzdHJva2VfY29sWzFdID0gcGlja2VkX2NvbFsxXVxuXHRcdFx0XHRcdFx0c3Ryb2tlX2NvbFsyXSA9IHBpY2tlZF9jb2xbMl1cblx0XHRcdFx0XHRcdFV0aWxzLmdhbW1hX2NvcnJlY3Qoc3Ryb2tlX2NvbCwgdHJ1ZSwgdHJ1ZSlcblx0XHRcdFx0XHRcdHN0cm9rZV9jb2xbM10gPSAxXG5cdFx0XHRcdFx0XHQvLyBzdHJva2VfY29sID0gWy4uLnN0cm9rZV9jb2xdXG5cdFx0XHRcdFx0XHR0cmlnZ2VyX2NvbG91cl9kaXNwbGF5X3VwZGF0ZShzdHJva2VfY29sWzBdLCBzdHJva2VfY29sWzFdLCBzdHJva2VfY29sWzJdKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zb2xlLmxvZyhjb29yZHMpXG5cdFx0XHRcdFx0anVzdF9maW5pc2hlZF9waWNrID0gZmFsc2Vcblx0XHRcdFx0XHRwaWNraW5nID0gZmFsc2Vcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImZpbmlzaGVkIHBpY2tcIilcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW8ubW1iX2Rvd24pIHtcblx0XHRcdFx0XHRwYW5uaW5nWzBdICs9IGlvLmRlbHRhX21vdXNlX3Bvc1swXSAvIHpvb21bMF1cblx0XHRcdFx0XHRwYW5uaW5nWzFdICs9IGlvLmRlbHRhX21vdXNlX3Bvc1sxXSAvIHpvb21bMF1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW8ubW91c2Vfd2hlZWwpIHtcblx0XHRcdFx0XHRpZiAoaW8ubW91c2Vfd2hlZWwgPiAwKSB7XG5cdFx0XHRcdFx0XHRkZXNpcmVkX3pvb20gKj0gMS4yXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRlc2lyZWRfem9vbSAvPSAxLjJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gLS0tLS0gVU5ET19SRURPXG5cdFx0XHRsZXQgbF9jdHJsX2Rvd24gPSBpby5nZXRLZXkoJ0NvbnRyb2xMZWZ0JykuZG93blxuXHRcdFx0bGV0IGxfc2hpZnRfZG93biA9IGlvLmdldEtleSgnU2hpZnRMZWZ0JykuZG93blxuXHRcdFx0bGV0IHpfanVzdF9wcmVzc2VkID0gaW8uZ2V0S2V5KCdLZXlaJykuanVzdF9wcmVzc2VkXG5cdFx0XHRjb25zdCBpZHhfYmVmb3JlID0gcHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aCAtIHJlZG9faGlzdG9yeV9sZW5ndGhcblx0XHRcdGlmIChyZWRvX3BlbmRpbmcgfHwgKGxfc2hpZnRfZG93biAmJiBsX2N0cmxfZG93biAmJiB6X2p1c3RfcHJlc3NlZCkpIHtcblx0XHRcdFx0cmVkb19oaXN0b3J5X2xlbmd0aCAtPSAxXG5cdFx0XHRcdGNvbnN0IGlkeF9ub3cgPSBpZHhfYmVmb3JlICsgMVxuXHRcdFx0XHRpZiAocmVkb19oaXN0b3J5X2xlbmd0aCA+PSAwKSB7IFxuXHRcdFx0XHRcdGlmKGlkeF9ub3cgJSB1bmRvX2NhY2hlX3N0ZXBzID09PSAwKXtcblx0XHRcdFx0XHRcdC8vIHRlbXBfdW5kb19mYi5jbGVhcigpXG5cdFx0XHRcdFx0XHR0ZW1wX3N0cm9rZV9mYi5jbGVhcigpXG5cdFx0XHRcdFx0XHRkcmF3X25fc3Ryb2tlcyhpZHhfYmVmb3JlLCBpZHhfYmVmb3JlICsgMSlcblx0XHRcdFx0XHRcdGNvcHlfZmJfdG9fZmIoY2FudmFzX2ZiLmZiX2JhY2ssdGVtcF91bmRvX2ZiLmZiLCBjYW52YXNfZmIudGV4dHVyZXNbMF0ucmVzKVxuXHRcdFx0XHRcdFx0Ly8gZHJhd19uX3N0cm9rZXMoIGlkeCAtIHVuZG9fY2FjaGVfc3RlcHMgLSAxLCBwcm9qZWN0LmJydXNoX3N0cm9rZXMubGVuZ3RoIC0gcmVkb19oaXN0b3J5X2xlbmd0aClcblx0XHRcdFx0XHRcdC8vIHRlbXBfdW5kb19mYi5iaW5kKClcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGVtcF9zdHJva2VfZmIuY2xlYXIoKVxuXHRcdFx0XHRcdFx0ZHJhd19uX3N0cm9rZXMoaWR4X2JlZm9yZSwgaWR4X2JlZm9yZSArIDEpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgeyBcblx0XHRcdFx0XHQvLyBjbGFtcFxuXHRcdFx0XHRcdHJlZG9faGlzdG9yeV9sZW5ndGggPSAwIFxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHVuZG9fcGVuZGluZyB8fCAobF9jdHJsX2Rvd24gJiYgel9qdXN0X3ByZXNzZWQpKSB7XG5cdFx0XHRcdHJlZG9faGlzdG9yeV9sZW5ndGggKz0gMVxuXHRcdFx0XHRjb25zdCBpZHhfbm93ID0gaWR4X2JlZm9yZSAtIDFcblx0XHRcdFx0aWYgKHJlZG9faGlzdG9yeV9sZW5ndGggPD0gcHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aCkgeyBcblx0XHRcdFx0XHRpZihpZHhfYmVmb3JlICUgdW5kb19jYWNoZV9zdGVwcyA9PT0gMCl7XG5cdFx0XHRcdFx0XHQvLyByZWRyYXcgYWxsXG5cdFx0XHRcdFx0XHRjYW52YXNfZmIuY2xlYXIoKVxuXHRcdFx0XHRcdFx0Y2FudmFzX2ZiLnBvbmcoKVxuXHRcdFx0XHRcdFx0Y2FudmFzX2ZiLmJhY2tfdGV4dHVyZXNbMF0uYmluZF90b191bml0KDEpXG5cdFx0XHRcdFx0XHRjYW52YXNfZmIuY2xlYXIoKVxuXHRcdFx0XHRcdFx0dGVtcF9zdHJva2VfZmIuY2xlYXIoKVxuXHRcdFx0XHRcdFx0ZHJhd19uX3N0cm9rZXMoMCwgaWR4X2JlZm9yZSAtIHVuZG9fY2FjaGVfc3RlcHMpXG5cdFx0XHRcdFx0XHRjb3B5X2ZiX3RvX2ZiKGNhbnZhc19mYi5mYl9iYWNrLHRlbXBfdW5kb19mYi5mYiwgY2FudmFzX2ZiLnRleHR1cmVzWzBdLnJlcylcblx0XHRcdFx0XHRcdHRlbXBfc3Ryb2tlX2ZiLmNsZWFyKClcblx0XHRcdFx0XHRcdGRyYXdfbl9zdHJva2VzKCBpZHhfYmVmb3JlIC0gdW5kb19jYWNoZV9zdGVwcywgcHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aCAtIHJlZG9faGlzdG9yeV9sZW5ndGgpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvcHlfZmJfdG9fZmIodGVtcF91bmRvX2ZiLmZiLGNhbnZhc19mYi5mYl9iYWNrLCBjYW52YXNfZmIudGV4dHVyZXNbMF0ucmVzKVxuXHRcdFx0XHRcdFx0Y2FudmFzX2ZiLmJhY2tfdGV4dHVyZXNbMF0uYmluZF90b191bml0KDEpXG5cdFx0XHRcdFx0XHR0ZW1wX3N0cm9rZV9mYi5jbGVhcigpXG5cdFx0XHRcdFx0XHRjb25zdCB1bmRvX21vZF9vZmZzID0gaWR4X25vdyAlIHVuZG9fY2FjaGVfc3RlcHNcblx0XHRcdFx0XHRcdGRyYXdfbl9zdHJva2VzKCBpZHhfbm93IC0gdW5kb19tb2Rfb2ZmcywgcHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aCAtIHJlZG9faGlzdG9yeV9sZW5ndGgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTE1KVxuXHRcdFx0XHR9IGVsc2UgeyBcblx0XHRcdFx0XHQvLyBjbGFtcFxuXHRcdFx0XHRcdHJlZG9faGlzdG9yeV9sZW5ndGggLT0gMSBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRjb25zdCByZWNvcmRfc3Ryb2tlID0gKCk9Pntcblx0XHRcdFx0aWYgKGlvLm1vdXNlX2p1c3RfcHJlc3NlZCAmJiAhKHJlZG9fcGVuZGluZyB8fCB1bmRvX3BlbmRpbmcpKSB7XG5cdFx0XHRcdFx0YnJ1c2hfc3Ryb2tlID0gbmV3IEJydXNoU3Ryb2tlKGN1cnJfYnJ1c2guc2VsZWN0ZWRfYnJ1c2hfdHlwZSwgbmV3IERyYXdQYXJhbXMoXG5cdFx0XHRcdFx0XHRjdXJyX2JydXNoLnRleF9keW5hbWljcywgY3Vycl9icnVzaC50ZXhfbGNoX2R5bmFtaWNzLCBjdXJyX2JydXNoLnRleF9zdHJldGNoLFxuXHRcdFx0XHRcdFx0YmxlbmRpbmdfY29sb3VyX3NwYWNlXG5cdFx0XHRcdFx0XHQpLCBjdXJyX2JydXNoLnNlbGVjdGVkX2JydXNoX3RleHR1cmUpXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZWRvX2hpc3RvcnlfbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHByb2plY3QuYnJ1c2hfc3Ryb2tlcy5wb3AoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZWRvX2hpc3RvcnlfbGVuZ3RoID0gMFxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGJydXNoX3N0cm9rZSlcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnU0VUIFJFRE8gSElTVE9SWSBUTyAwJylcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJydXNoX3JvdCA9IFsuLi5pby50aWx0XVxuXG5cdFx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBpby5tb3VzZV9wb3NpdGlvbnNfZHVyaW5nX2xhc3RfZnJhbWVfY250OyBpKyspe1xuXHRcdFx0XHRcdC8vIGJydXNoX3Bvc19uZGNfc2NyZWVuID0gWy4uLmlvLm1vdXNlX3Bvc11cblx0XHRcdFx0XHRicnVzaF9wb3NfbmRjX3NjcmVlbiA9IFtcblx0XHRcdFx0XHRcdGlvLm1vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZVtpKjJdLFxuXHRcdFx0XHRcdFx0aW8ubW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lW2kqMiArIDFdXG5cdFx0XHRcdFx0XVxuXHRcdFx0XHRcdGJydXNoX3Bvc19uZGNfY2FudmFzID0gVXRpbHMuc2NyZWVuX05EQ190b19jYW52YXNfTkRDKFxuXHRcdFx0XHRcdFx0YnJ1c2hfcG9zX25kY19zY3JlZW4sXG5cdFx0XHRcdFx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLnRleHR1cmVzWzBdLFxuXHRcdFx0XHRcdFx0Y2FudmFzX3JlYWRfdGV4LFxuXHRcdFx0XHRcdFx0em9vbVswXSxcblx0XHRcdFx0XHRcdHBhbm5pbmcsXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdGJydXNoX3Bvc19uZGNfY2FudmFzWzBdICs9IGN1cnJfYnJ1c2gucG9zX2ppdHRlciAqICgyICogaGFzaC52YWx1ZU5vaXNlU21vb3RoKHQgKiAxMDAgKyAyNTEsIDIpIC0gMSlcblx0XHRcdFx0XHRicnVzaF9wb3NfbmRjX2NhbnZhc1sxXSArPSBjdXJyX2JydXNoLnBvc19qaXR0ZXIgKiAoMiAqIGhhc2gudmFsdWVOb2lzZVNtb290aCh0ICogMTAwICsgMTI1MSwgMikgLSAxKVxuXG5cdFx0XHRcdFx0bGV0IGNvbCA9IFsuLi5zdHJva2VfY29sXVxuXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgY2hyb21hX2dsID0gKGNvbDogbnVtYmVyW10pID0+IHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNocm9tYS5nbChjb2xbMF0sIGNvbFsxXSwgY29sWzJdKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29uc3QgY2hyb21hX29rbGNoID0gKGNvbDogbnVtYmVyW10pID0+IHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNocm9tYS5va2xjaChjb2xbMF0sIGNvbFsxXSwgY29sWzJdKVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbCA9IGNocm9tYV9nbChjb2wpLm9rbGNoKClcblx0XHRcdFx0XHRcdGNvbnN0IGMgPSBjb2xbMV1cblxuXHRcdFx0XHRcdFx0bGV0IGh1ZV9qaXR0X2FtdCA9ICgxLXBvdyhjICwwLjIpKjEuMikqNFxuXHRcdFx0XHRcdFx0aHVlX2ppdHRfYW10ID0gbWF4KGh1ZV9qaXR0X2FtdCwwKVxuXHRcdFx0XHRcdFx0aHVlX2ppdHRfYW10ICs9IHBvdyhzbW9vdGhzdGVwKDAuLDEuLDEtYykgLDU3LikqMi4yXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y29sWzBdICs9ICgtMC41ICsgaGFzaC52YWx1ZU5vaXNlU21vb3RoKHQgKiAxMDAgKiBjdXJyX2JydXNoLmNoYW9zX3NwZWVkLCAyKSkgKiBjdXJyX2JydXNoLmNoYW9zICogY3Vycl9icnVzaC5jaGFvc19sY2hbMF1cblx0XHRcdFx0XHRcdGNvbFsxXSArPSAoLTAuNSArIGhhc2gudmFsdWVOb2lzZVNtb290aCh0ICogMTAwICogY3Vycl9icnVzaC5jaGFvc19zcGVlZCArIDEwMCwgMikpICogY3Vycl9icnVzaC5jaGFvcyAqIGN1cnJfYnJ1c2guY2hhb3NfbGNoWzFdIFxuXHRcdFx0XHRcdFx0Y29sWzJdICs9IGh1ZV9qaXR0X2FtdCooLTAuNSArIGhhc2gudmFsdWVOb2lzZVNtb290aCh0ICogMTAwICogY3Vycl9icnVzaC5jaGFvc19zcGVlZCArIDIwMCwgMikpICogMzAwICogY3Vycl9icnVzaC5jaGFvcyAqIGN1cnJfYnJ1c2guY2hhb3NfbGNoWzJdXG5cdFx0XHRcdFx0XHRjb2xbMF0gPSBjbGFtcChjb2xbMF0sIDAsIDEpXG5cdFx0XHRcdFx0XHRjb2xbMV0gPSBjbGFtcChjb2xbMV0sIDAsIDEpXG5cdFx0XHRcdFx0XHRjb2xbMl0gPSBtb2QoY29sWzJdLCAzNjApXG5cblx0XHRcdFx0XHRcdGNvbCA9IGNocm9tYV9va2xjaChjb2wpLmdsKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0c3Ryb2tlX29wYWNpdHkgPSBsZXJwKGN1cnJfYnJ1c2guc3Ryb2tlX29wYWNpdHlfZHluYW1pY3NbMF0sIGN1cnJfYnJ1c2guc3Ryb2tlX29wYWNpdHlfZHluYW1pY3NbMV0sIGlvLnByZXNzdXJlKVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJydXNoX3JvdFsxXSArPSAxMCpjdXJyX2JydXNoLnJvdF9qaXR0ZXIgKiAoMiAqIGhhc2gudmFsdWVOb2lzZVNtb290aCh0ICogMTAgKyAxMDAsIDIpIC0gMSlcblxuXHRcdFx0XHRcdGxldCBzeiA9IFsuLi5icnVzaF9zel1cblxuXHRcdFx0XHRcdGxldCBzaXplX3ByZXNzdXJlX3dlaWdodCA9IGxlcnAoY3Vycl9icnVzaC5zdHJva2Vfc2l6ZV9keW5hbWljc1swXSxjdXJyX2JydXNoLiBzdHJva2Vfc2l6ZV9keW5hbWljc1sxXSwgaW8ucHJlc3N1cmUpXG5cdFx0XHRcdFx0bGV0IHNpemVfdGlsdF93ZWlnaHQgPSBsZXJwKDAuNCwgMSwgaW8udGlsdFswXSAvIHRhdSlcblx0XHRcdFx0XHQvLyBUT0RPOiBzeiBkeW5hbWljc1xuXHRcdFx0XHRcdHN6WzBdICo9IHNpemVfcHJlc3N1cmVfd2VpZ2h0ICogc2l6ZV90aWx0X3dlaWdodFxuXHRcdFx0XHRcdHN6WzFdICo9IHNpemVfcHJlc3N1cmVfd2VpZ2h0ICogc2l6ZV90aWx0X3dlaWdodFxuXG5cdFx0XHRcdFx0YnJ1c2hfc3Ryb2tlLnB1c2hfc3Ryb2tlKGJydXNoX3Bvc19uZGNfY2FudmFzLCBicnVzaF9yb3QsIHN6LCBzdHJva2Vfb3BhY2l0eSwgY29sKVxuXHRcdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgZHJhdyA9IChfdDogbnVtYmVyKSA9PiB7XG5cdFx0XHRyZWRyYXdfbmVlZGVkID0gZmFsc2Vcblx0XHRcdGNvbnN0IG5ld190ID0gX3QgLyAxMDAwXG5cdFx0XHRkZWx0YV90ID0gbmV3X3QgLSB0XG5cdFx0XHR0ID0gbmV3X3Rcblx0XHRcdHJlc2l6ZURlZmF1bHRGcmFtZWJ1ZmZlcklmTmVlZGVkKGNhbnZhc0VsZW1lbnQsIGRlZmF1bHRfZnJhbWVidWZmZXIsIHVzZXJBZ2VudFJlcywgKHY6IGJvb2xlYW4pID0+IHtcblx0XHRcdFx0cmVkcmF3X25lZWRlZCA9IHZcblx0XHRcdH0sKCk9PntzZXRfc2hhcmVkX3VuaWZvcm1zKCl9KVxuXHRcdFx0aW8udGljaygpXG5cdFx0XHRcblx0XHRcdGlmKG5ld19wcm9qZWN0X3BlbmRpbmcpe1xuXHRcdFx0XHRsb2FkX3Byb2plY3QobmV3IFByb2plY3QoKSlcblx0XHRcdFx0bmV3X3Byb2plY3RfcGVuZGluZyA9IGZhbHNlXG5cdFx0XHR9XG5cdFx0XHRpZihwcm9qZWN0X3BlbmRpbmdfbG9hZCl7XG5cdFx0XHRcdGxvYWRfcHJvamVjdChwcm9qZWN0X3BlbmRpbmdfbG9hZClcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRwcm9qZWN0X3BlbmRpbmdfbG9hZCA9IHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZihmdWxsX3JlZHJhd19uZWVkZWQpe1xuXHRcdFx0XHRyZWRyYXdfd2hvbGVfcHJvamVjdCgpXG5cdFx0XHR9XG5cblx0XHRcdGhhbmRsZV9pbnB1dF9hY3Rpb25zKClcblxuXHRcdFx0Ly8gLS0tLS0gUkVDT1JEIFNUUk9LRSAvIERSQVdcblx0XHRcdGlmICgoaW8ubW91c2VfanVzdF9wcmVzc2VkIHx8IChpby5tb3VzZV9kb3duICYmIGlvLm1vdXNlX2p1c3RfbW92ZWQpKSAmJiBpby5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuXHRcdFx0XHRwcm9qZWN0X2hhc19iZWVuX21vZGlmaWVkID0gdHJ1ZVxuXHRcdFx0XHRyZWRyYXdfbmVlZGVkID0gdHJ1ZVxuXHRcdFx0XHRyZWNvcmRfc3Ryb2tlKClcblx0XHRcdFx0Ly8gZ2wuZW5hYmxlKGdsLkJMRU5EKVxuXHRcdFx0XHR0ZW1wX3N0cm9rZV9mYi5jbGVhcigpXG5cdFx0XHRcdHRlbXBfc3Ryb2tlX2ZiLmJpbmQoKVxuXHRcdFx0XHQvLyBkcmF3ZXIuZHJhd19hbnlfc3Ryb2tlKGJydXNoX3N0cm9rZSwgdCwgYnJ1c2hfYnVmZmVyLCB6b29tLCBwYW5uaW5nKVxuXHRcdFx0XHRkcmF3ZXIuYnJ1c2hfYnVmZmVyID0gYnJ1c2hfYnVmZmVyXG5cdFx0XHRcdGRyYXdlci5yZXNldCgpXG5cdFx0XHRcdGRyYXdlci5wdXNoX2FueV9zdHJva2UoYnJ1c2hfc3Ryb2tlKVxuXHRcdFx0XHRkcmF3ZXIuYnJ1c2hfYnVmZmVyLnVwbG9hZF9hbGxfYnVmZnMoKVxuXHRcdFx0XHRjb25zdCBicnVzaF9zaGFkZXIgPSBkcmF3ZXIuYnJ1c2hfYnVmZmVyLnNoYWRlclxuXHRcdFx0XHRicnVzaF9zaGFkZXIudXNlKClcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRnbC51bmlmb3JtMWkoYnJ1c2hfc2hhZGVyLmJydXNoX3RleHR1cmVfaWR4X2xvYywgY3Vycl9icnVzaC5zZWxlY3RlZF9icnVzaF90ZXh0dXJlLmlkeCApXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0Z2wudW5pZm9ybTNmdihicnVzaF9zaGFkZXIudGV4X2hzdl9keW5hbWljc19sb2MsIGN1cnJfYnJ1c2gudGV4X2xjaF9keW5hbWljcyApXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0Z2wudW5pZm9ybTJmdihicnVzaF9zaGFkZXIudGV4X3N0cmV0Y2hfbG9jLCBjdXJyX2JydXNoLnRleF9zdHJldGNoIClcblx0XHRcdFx0ZHJhd2VyLmRyYXdfc3Ryb2tlX2lkeCgwKVxuXHRcdFx0fVxuXHRcdFx0Ly8gLS0tLS0gQ09NUE9TSVRFIE5FVyBTVFJPS0Vcblx0XHRcdGlmIChpby5tb3VzZV9qdXN0X3VucHJlc3NlZCAmJiBpby5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJyAmJiAhKHVuZG9fcGVuZGluZyB8fCByZWRvX3BlbmRpbmcpKSB7XG5cdFx0XHRcdGlmKGZyYW1lICUgMTUgPT09IDAgfHwgIWlzT25Nb2JpbGUpe1xuXHRcdFx0XHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwcm9qZWN0JywgSlNPTi5zdHJpbmdpZnkocHJvamVjdCkpXG5cdFx0XHRcdFx0Ly8gZmxvYXRpbmdfbW9kYWxfbWVzc2FnZS5zZXQoXCJzYXZlZFwiKVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKGJydXNoX3N0cm9rZSlcblx0XHRcdFx0cHJvamVjdC5wdXNoX3N0cm9rZShicnVzaF9zdHJva2UpXG5cdFx0XHRcdHJlZHJhd19uZWVkZWQgPSB0cnVlXG5cdFx0XHRcdGNvbXBvc2l0ZV9zdHJva2UoKVxuXHRcdFx0XHRjYW52YXNfZmIucG9uZygpXG5cdFx0XHRcdGNhbnZhc19mYi5iYWNrX3RleHR1cmVzWzBdLmJpbmRfdG9fdW5pdCgxKVxuXHRcdFx0XHRpZihwcm9qZWN0LmJydXNoX3N0cm9rZXMubGVuZ3RoICUgdW5kb19jYWNoZV9zdGVwcyA9PT0gMCl7XG5cdFx0XHRcdFx0Y29weV9mYl90b19mYihjYW52YXNfZmIuZmJfYmFjaywgdGVtcF91bmRvX2ZiLmZiLCBjYW52YXNfZmIudGV4dHVyZXNbMF0ucmVzKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChicnVzaFNpemVXaWRnZXREcmFnZ2luZyB8fCBicnVzaFNpemVXaWRnZXRTdG9wcGVkRHJhZ2dpbmcpIHJlZHJhd19uZWVkZWQgPSB0cnVlXG5cblx0XHRcdC8vIC0tLS0tIFJFRFJBV1xuXHRcdFx0aWYgKHJlZHJhd19uZWVkZWQpIHtcblx0XHRcdFx0Ly8gZ2wuZGlzYWJsZShnbC5CTEVORClcblx0XHRcdFx0aWYoY2FudmFzX2ZiLl90ZXh0dXJlc1swXS5taXBtYXBwZWQpe1xuXHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGNhbnZhc19mYi5fdGV4dHVyZXNbMF0udGV4KVxuXHRcdFx0XHRcdGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpXG5cdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgY2FudmFzX2ZiLl9iYWNrX3RleHR1cmVzWzBdLnRleClcblx0XHRcdFx0XHRnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKVxuXHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodGVtcF9zdHJva2VfZmIudGV4dHVyZXNbMF0ubWlwbWFwcGVkKXtcblx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZW1wX3N0cm9rZV9mYi50ZXh0dXJlc1swXS50ZXgpXG5cdFx0XHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRClcblx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci5jbGVhcihbMCwgMCwgMCwgMV0pXG5cdFx0XHRcdGRlZmF1bHRfZnJhbWVidWZmZXIuYmluZCgpXG5cblx0XHRcdFx0cG9zdF9jYW52YXNfcHJvZ3JhbS51c2UoKVxuXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0Z2wudW5pZm9ybTFmKHBvc3RfY2FudmFzX3Byb2dyYW0uem9vbV9sb2MsIHpvb20pXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0Z2wudW5pZm9ybTJmdihwb3N0X2NhbnZhc19wcm9ncmFtLnBhbm5pbmdfbG9jLCBwYW5uaW5nKVxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdGdsLnVuaWZvcm0xaShwb3N0X2NhbnZhc19wcm9ncmFtLmJsZW5kaW5nX2NvbG91cl9zcGFjZV9sb2MsIGJsZW5kaW5nX2NvbG91cl9zcGFjZSlcblx0XHRcdFx0Y2FudmFzX2ZiLmJhY2tfdGV4dHVyZXNbMF0uYmluZF90b191bml0KDEpXG5cdFx0XHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpXG5cblx0XHRcdFx0aWYgKGJydXNoU2l6ZVdpZGdldERyYWdnaW5nKSB7XG5cdFx0XHRcdFx0YnJ1c2hfcHJldmlld19wcm9ncmFtLnVzZSgpXG5cdFx0XHRcdFx0YnJ1c2hfcHJldmlld19wcm9ncmFtLnNldFVuaWZvcm1GbG9hdChcInpvb21cIiwgem9vbVswXSlcblx0XHRcdFx0XHRicnVzaF9wcmV2aWV3X3Byb2dyYW0uc2V0VW5pZm9ybVZlYyhcImJydXNoX3N6XCIsIGJydXNoX3N6KVxuXHRcdFx0XHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocGlja2luZykge1xuXHRcdFx0XHRcdHBpY2tlcl9wcm9ncmFtLnVzZSgpXG5cdFx0XHRcdFx0cGlja2VyX3Byb2dyYW0uc2V0VW5pZm9ybVZlYygncGlja2VkX2NvbCcsIHBpY2tlZF9jb2wpXG5cdFx0XHRcdFx0cGlja2VyX3Byb2dyYW0uc2V0VW5pZm9ybVZlYygncGlja2VyX3BvcycsIFsuLi5pby5tb3VzZV9wb3NdKVxuXHRcdFx0XHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByaW50X29uX2dsX2Vycm9yKClcblx0XHRcdGJydXNoU2l6ZVdpZGdldFN0b3BwZWREcmFnZ2luZyA9IGZhbHNlXG5cdFx0XHRyZWRvX3BlbmRpbmcgPSBmYWxzZVxuXHRcdFx0dW5kb19wZW5kaW5nID0gZmFsc2Vcblx0XHRcdGZ1bGxfcmVkcmF3X25lZWRlZCA9IGZhbHNlXG5cdFx0XHRpby50aWNrX2VuZCgpXG5cdFx0XHRmcmFtZSsrXG5cdFx0XHRmb3IgKGxldCBmcmFtZWJ1ZmZlciBvZiBGcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlcnMpIHtcblx0XHRcdFx0aWYgKGZyYW1lYnVmZmVyLm5lZWRzX3BvbmcpIHtcblx0XHRcdFx0XHRmcmFtZWJ1ZmZlci5wb25nKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpXG5cdFx0fVxuXHRcdDsoKCkgPT4ge1xuXHRcdFx0ZHJhdygwKVxuXHRcdH0pKClcblx0fSlcblxuXHRvbkRlc3Ryb3koKCkgPT4ge30pXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5cdC5rbm9iLWNvbnRhaW5lciB7XG5cdFx0cGFkZGluZzogMXJlbSAwcmVtO1xuXHR9XG5cdCoge1xuXHRcdCoge1xuXHRcdFx0Y29sb3I6IHdoaXRlO1xuXHRcdFx0Zm9udC1mYW1pbHk6ICdKZXRicmFpbnMgTW9ubyc7XG5cdFx0fVxuXHR9XG5cdG1haW4ge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0I2Jhci1jb250YWluZXIge1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdCNiYXIge1xuXHRcdFx0XHQ+Omdsb2JhbChkaXYpIHtcblx0XHRcdFx0XHRtYXgtaGVpZ2h0OiAyLjVyZW07XHRcblx0XHRcdFx0fVxuXHRcdFx0XHRmbGV4LXdyYXA6IHdyYXA7XG5cdFx0XHRcdGJhY2tncm91bmQ6IGJsYWNrO1xuXHRcdFx0XHQvLyBwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0XHRoZWlnaHQ6IDEwMHB4O1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRwYWRkaW5nOiAwcmVtIDFyZW07XG5cdFx0XHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0XHRcdD4gKjpsYXN0LW9mLXR5cGUge1xuXHRcdFx0XHRcdG1hcmdpbi1sZWZ0OiBhdXRvO1xuXHRcdFx0XHRcdG1hcmdpbi1yaWdodDogMHB4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhbnZhcyB7XG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdGhlaWdodDogMTAwJTtcblx0XHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdFx0bWFyZ2luOiBhdXRvO1xuXHRcdFx0cGFkZGluZzogMDtcblx0XHRcdC8vIGJhY2tncm91bmQtY29sb3I6IHJlZDtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgJy4uL3B1YmxpYy9KZXRCcmFpbnNNb25vLVJlZ3VsYXIudHRmJ1xuaW1wb3J0ICcuLi9wdWJsaWMvc3R5bGUuY3NzJ1xuXG5pbXBvcnQgQXBwIGZyb20gJy4vY29tcG9uZW50cy9BcHAuc3ZlbHRlJ1xuXG5jb25zdCBhcHAgPSBuZXcgQXBwKHtcblx0dGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxuXHRwcm9wczoge30sXG59KVxuXG5leHBvcnQgZGVmYXVsdCBhcHBcbiJdLCJuYW1lcyI6WyJzdHJpbmdUb0J5dGVBcnJheSIsImFwcE5hbWUiLCJhcHBDb21wYXROYW1lIiwiYW5hbHl0aWNzTmFtZSIsImFuYWx5dGljc0NvbXBhdE5hbWUiLCJhcHBDaGVja05hbWUiLCJhcHBDaGVja0NvbXBhdE5hbWUiLCJhdXRoTmFtZSIsImF1dGhDb21wYXROYW1lIiwiZGF0YWJhc2VOYW1lIiwiZGF0YWJhc2VDb21wYXROYW1lIiwiZnVuY3Rpb25zTmFtZSIsImZ1bmN0aW9uc0NvbXBhdE5hbWUiLCJpbnN0YWxsYXRpb25zTmFtZSIsImluc3RhbGxhdGlvbnNDb21wYXROYW1lIiwibWVzc2FnaW5nTmFtZSIsIm1lc3NhZ2luZ0NvbXBhdE5hbWUiLCJwZXJmb3JtYW5jZU5hbWUiLCJwZXJmb3JtYW5jZUNvbXBhdE5hbWUiLCJyZW1vdGVDb25maWdOYW1lIiwicmVtb3RlQ29uZmlnQ29tcGF0TmFtZSIsInN0b3JhZ2VOYW1lIiwic3RvcmFnZUNvbXBhdE5hbWUiLCJmaXJlc3RvcmVOYW1lIiwiZmlyZXN0b3JlQ29tcGF0TmFtZSIsInBhY2thZ2VOYW1lIiwic2V0TG9nTGV2ZWxJbXBsIiwibmFtZSIsInZlcnNpb24iLCJqc0hlbHBlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLl9sb2FkSlMiLCJhcHBseUFjdGlvbkNvZGUiLCJzZW5kRW1haWxWZXJpZmljYXRpb24iLCJzZW5kUGFzc3dvcmRSZXNldEVtYWlsIiwic2VuZFNpZ25JbkxpbmtUb0VtYWlsIiwic2lnbkluV2l0aEVtYWlsTGluayIsIklEUF9SRVFVRVNUX1VSSSIsInNpZ25JbldpdGhQaG9uZU51bWJlciIsImxpbmtXaXRoUGhvbmVOdW1iZXIiLCJfbGluayIsInNpZ25JbldpdGhDdXN0b21Ub2tlbiIsImdldElkVG9rZW5SZXNwb25zZSIsImF1dGhlbnRpY2F0aW9uLnNlbmRQYXNzd29yZFJlc2V0RW1haWwiLCJhdXRoZW50aWNhdGlvblxyXG4gICAgICAgICAgICAuc2VuZFBhc3N3b3JkUmVzZXRFbWFpbCIsImFjY291bnQucmVzZXRQYXNzd29yZCIsImFjY291bnQuYXBwbHlBY3Rpb25Db2RlIiwiYXBpLnNlbmRTaWduSW5MaW5rVG9FbWFpbCIsImFwaVxyXG4gICAgICAgICAgICAuc2VuZFNpZ25JbkxpbmtUb0VtYWlsIiwiYXBpLnNlbmRFbWFpbFZlcmlmaWNhdGlvbiIsImFwaS52ZXJpZnlBbmRDaGFuZ2VFbWFpbCIsInVwZGF0ZVByb2ZpbGUiLCJhcGlVcGRhdGVQcm9maWxlIiwiYXBpVXBkYXRlRW1haWxQYXNzd29yZCIsIl9QT0xMSU5HX0lOVEVSVkFMX01TIiwianNIZWxwZXJzLl9nZW5lcmF0ZUNhbGxiYWNrTmFtZSIsImpzSGVscGVycy5fbG9hZEpTIiwiX2xpbmtVc2VyIiwianMuX2dlbmVyYXRlQ2FsbGJhY2tOYW1lIiwianNcclxuICAgICAgICAgICAgICAgIC5fbG9hZEpTIiwiZ2FwaUxvYWRlci5fbG9hZEdhcGkiXSwic291cmNlUm9vdCI6IiJ9