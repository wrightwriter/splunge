/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 8563:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8393);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(2578), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `@font-face {
  font-family: "JetBrains Mono";
  font-style: normal;
  font-weight: 400;
  src: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) format("truetype");
}

* {
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

body {
  margin: 0;
  padding: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  /* background-color: black; */
  touch-action: none;
  margin: 0px;
  width: 100%;
  height: 100%;
}
html {
  touch-action: none;
  width: 100%;
  height: 100%;
}

canvas {
  max-width: 100%;
  max-height: 100%;
  /* width: 100%;
  height: 100%; */
  touch-action: none;
}
`, "",{"version":3,"sources":["webpack://./public/style.css"],"names":[],"mappings":"AAAA;EACE,6BAA6B;EAC7B,kBAAkB;EAClB,gBAAgB;EAChB,+DAA0D;AAC5D;;AAEA;EACE,iBAAiB;EACjB,wCAAwC;AAC1C;;AAEA;EACE,SAAS;EACT,UAAU;EACV,YAAY;EACZ,aAAa;EACb,gBAAgB;EAChB,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,6BAA6B;EAC7B,kBAAkB;EAClB,WAAW;EACX,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;;AAEA;EACE,eAAe;EACf,gBAAgB;EAChB;iBACe;EACf,kBAAkB;AACpB","sourcesContent":["@font-face {\n  font-family: \"JetBrains Mono\";\n  font-style: normal;\n  font-weight: 400;\n  src: url(\"./JetBrainsMono-Regular.ttf\") format(\"truetype\");\n}\n\n* {\n  user-select: none;\n  -webkit-tap-highlight-color: transparent;\n}\n\nbody {\n  margin: 0;\n  padding: 0;\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /* background-color: black; */\n  touch-action: none;\n  margin: 0px;\n  width: 100%;\n  height: 100%;\n}\nhtml {\n  touch-action: none;\n  width: 100%;\n  height: 100%;\n}\n\ncanvas {\n  max-width: 100%;\n  max-height: 100%;\n  /* width: 100%;\n  height: 100%; */\n  touch-action: none;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 1468:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("./images/c9ec27466feec6639c0e7cdd798e5707.webp");

/***/ }),

/***/ 6555:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("./images/11d1819c329097bd42d612af51984ebf.webp");

/***/ }),

/***/ 6258:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("./images/f582214ff3350f1957d2e5f71ac6089c.webp");

/***/ }),

/***/ 5954:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("./images/f06932ac516f7c72ce848dfe5a1557ca.webp");

/***/ }),

/***/ 4493:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("./images/f7442041cb9d6db02b7f80e9a3aa298f.webp");

/***/ }),

/***/ 4830:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("./images/2ee5dd2f76544899d917464f1c7ed687.webp");

/***/ }),

/***/ 5179:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("./images/320fc7b7b1a658588d5b020a90c3ee26.webp");

/***/ }),

/***/ 352:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 8393:
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ 1864:
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ 1956:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

!function(e,t){ true?t(exports):0}(this,(function(e){"use strict";function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){for(var r=0;t.length>r;r++){var i=t[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function i(e,t,i){return t&&r(e.prototype,t),i&&r(e,i),e}function s(e){return(s=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function n(e,t){return(n=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function a(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}function o(e,t,r){return(o=a()?Reflect.construct:function(e,t,r){var i=[null];i.push.apply(i,t);var s=new(Function.bind.apply(e,i));return r&&n(s,r.prototype),s}).apply(null,arguments)}function u(e){var t="function"==typeof Map?new Map:void 0;return(u=function(e){if(null===e||-1===Function.toString.call(e).indexOf("[native code]"))return e;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return o(e,arguments,s(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n(r,e)})(e)}function c(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}var p="app",l="user",f="team",m="dropboxapi.com",h="dropbox.com",d={api:"api",notify:"bolt",content:"api-content"},_={};function g(e){var t="000".concat(e.charCodeAt(0).toString(16)).slice(-4);return"\\u".concat(t)}_.accountSetProfilePhoto=function(e){return this.request("account/set_profile_photo",e,"user","api","rpc","account_info.write")},_.authTokenFromOauth1=function(e){return this.request("auth/token/from_oauth1",e,"app","api","rpc",null)},_.authTokenRevoke=function(){return this.request("auth/token/revoke",null,"user","api","rpc",null)},_.checkApp=function(e){return this.request("check/app",e,"app","api","rpc",null)},_.checkUser=function(e){return this.request("check/user",e,"user","api","rpc","account_info.read")},_.contactsDeleteManualContacts=function(){return this.request("contacts/delete_manual_contacts",null,"user","api","rpc","contacts.write")},_.contactsDeleteManualContactsBatch=function(e){return this.request("contacts/delete_manual_contacts_batch",e,"user","api","rpc","contacts.write")},_.filePropertiesPropertiesAdd=function(e){return this.request("file_properties/properties/add",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesOverwrite=function(e){return this.request("file_properties/properties/overwrite",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesRemove=function(e){return this.request("file_properties/properties/remove",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesSearch=function(e){return this.request("file_properties/properties/search",e,"user","api","rpc","files.metadata.read")},_.filePropertiesPropertiesSearchContinue=function(e){return this.request("file_properties/properties/search/continue",e,"user","api","rpc","files.metadata.read")},_.filePropertiesPropertiesUpdate=function(e){return this.request("file_properties/properties/update",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesAddForTeam=function(e){return this.request("file_properties/templates/add_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesAddForUser=function(e){return this.request("file_properties/templates/add_for_user",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesGetForTeam=function(e){return this.request("file_properties/templates/get_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesGetForUser=function(e){return this.request("file_properties/templates/get_for_user",e,"user","api","rpc","files.metadata.read")},_.filePropertiesTemplatesListForTeam=function(){return this.request("file_properties/templates/list_for_team",null,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesListForUser=function(){return this.request("file_properties/templates/list_for_user",null,"user","api","rpc","files.metadata.read")},_.filePropertiesTemplatesRemoveForTeam=function(e){return this.request("file_properties/templates/remove_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesRemoveForUser=function(e){return this.request("file_properties/templates/remove_for_user",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesUpdateForTeam=function(e){return this.request("file_properties/templates/update_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesUpdateForUser=function(e){return this.request("file_properties/templates/update_for_user",e,"user","api","rpc","files.metadata.write")},_.fileRequestsCount=function(){return this.request("file_requests/count",null,"user","api","rpc","file_requests.read")},_.fileRequestsCreate=function(e){return this.request("file_requests/create",e,"user","api","rpc","file_requests.write")},_.fileRequestsDelete=function(e){return this.request("file_requests/delete",e,"user","api","rpc","file_requests.write")},_.fileRequestsDeleteAllClosed=function(){return this.request("file_requests/delete_all_closed",null,"user","api","rpc","file_requests.write")},_.fileRequestsGet=function(e){return this.request("file_requests/get",e,"user","api","rpc","file_requests.read")},_.fileRequestsListV2=function(e){return this.request("file_requests/list_v2",e,"user","api","rpc","file_requests.read")},_.fileRequestsList=function(){return this.request("file_requests/list",null,"user","api","rpc","file_requests.read")},_.fileRequestsListContinue=function(e){return this.request("file_requests/list/continue",e,"user","api","rpc","file_requests.read")},_.fileRequestsUpdate=function(e){return this.request("file_requests/update",e,"user","api","rpc","file_requests.write")},_.filesAlphaGetMetadata=function(e){return this.request("files/alpha/get_metadata",e,"user","api","rpc","files.metadata.read")},_.filesAlphaUpload=function(e){return this.request("files/alpha/upload",e,"user","content","upload","files.content.write")},_.filesCopyV2=function(e){return this.request("files/copy_v2",e,"user","api","rpc","files.content.write")},_.filesCopy=function(e){return this.request("files/copy",e,"user","api","rpc","files.content.write")},_.filesCopyBatchV2=function(e){return this.request("files/copy_batch_v2",e,"user","api","rpc","files.content.write")},_.filesCopyBatch=function(e){return this.request("files/copy_batch",e,"user","api","rpc","files.content.write")},_.filesCopyBatchCheckV2=function(e){return this.request("files/copy_batch/check_v2",e,"user","api","rpc","files.content.write")},_.filesCopyBatchCheck=function(e){return this.request("files/copy_batch/check",e,"user","api","rpc","files.content.write")},_.filesCopyReferenceGet=function(e){return this.request("files/copy_reference/get",e,"user","api","rpc","files.content.write")},_.filesCopyReferenceSave=function(e){return this.request("files/copy_reference/save",e,"user","api","rpc","files.content.write")},_.filesCreateFolderV2=function(e){return this.request("files/create_folder_v2",e,"user","api","rpc","files.content.write")},_.filesCreateFolder=function(e){return this.request("files/create_folder",e,"user","api","rpc","files.content.write")},_.filesCreateFolderBatch=function(e){return this.request("files/create_folder_batch",e,"user","api","rpc","files.content.write")},_.filesCreateFolderBatchCheck=function(e){return this.request("files/create_folder_batch/check",e,"user","api","rpc","files.content.write")},_.filesDeleteV2=function(e){return this.request("files/delete_v2",e,"user","api","rpc","files.content.write")},_.filesDelete=function(e){return this.request("files/delete",e,"user","api","rpc","files.content.write")},_.filesDeleteBatch=function(e){return this.request("files/delete_batch",e,"user","api","rpc","files.content.write")},_.filesDeleteBatchCheck=function(e){return this.request("files/delete_batch/check",e,"user","api","rpc","files.content.write")},_.filesDownload=function(e){return this.request("files/download",e,"user","content","download","files.content.read")},_.filesDownloadZip=function(e){return this.request("files/download_zip",e,"user","content","download","files.content.read")},_.filesExport=function(e){return this.request("files/export",e,"user","content","download","files.content.read")},_.filesGetFileLockBatch=function(e){return this.request("files/get_file_lock_batch",e,"user","api","rpc","files.content.read")},_.filesGetMetadata=function(e){return this.request("files/get_metadata",e,"user","api","rpc","files.metadata.read")},_.filesGetPreview=function(e){return this.request("files/get_preview",e,"user","content","download","files.content.read")},_.filesGetTemporaryLink=function(e){return this.request("files/get_temporary_link",e,"user","api","rpc","files.content.read")},_.filesGetTemporaryUploadLink=function(e){return this.request("files/get_temporary_upload_link",e,"user","api","rpc","files.content.write")},_.filesGetThumbnail=function(e){return this.request("files/get_thumbnail",e,"user","content","download","files.content.read")},_.filesGetThumbnailV2=function(e){return this.request("files/get_thumbnail_v2",e,"app, user","content","download","files.content.read")},_.filesGetThumbnailBatch=function(e){return this.request("files/get_thumbnail_batch",e,"user","content","rpc","files.content.read")},_.filesListFolder=function(e){return this.request("files/list_folder",e,"app, user","api","rpc","files.metadata.read")},_.filesListFolderContinue=function(e){return this.request("files/list_folder/continue",e,"app, user","api","rpc","files.metadata.read")},_.filesListFolderGetLatestCursor=function(e){return this.request("files/list_folder/get_latest_cursor",e,"user","api","rpc","files.metadata.read")},_.filesListFolderLongpoll=function(e){return this.request("files/list_folder/longpoll",e,"noauth","notify","rpc","files.metadata.read")},_.filesListRevisions=function(e){return this.request("files/list_revisions",e,"user","api","rpc","files.metadata.read")},_.filesLockFileBatch=function(e){return this.request("files/lock_file_batch",e,"user","api","rpc","files.content.write")},_.filesMoveV2=function(e){return this.request("files/move_v2",e,"user","api","rpc","files.content.write")},_.filesMove=function(e){return this.request("files/move",e,"user","api","rpc","files.content.write")},_.filesMoveBatchV2=function(e){return this.request("files/move_batch_v2",e,"user","api","rpc","files.content.write")},_.filesMoveBatch=function(e){return this.request("files/move_batch",e,"user","api","rpc","files.content.write")},_.filesMoveBatchCheckV2=function(e){return this.request("files/move_batch/check_v2",e,"user","api","rpc","files.content.write")},_.filesMoveBatchCheck=function(e){return this.request("files/move_batch/check",e,"user","api","rpc","files.content.write")},_.filesPaperCreate=function(e){return this.request("files/paper/create",e,"user","api","upload","files.content.write")},_.filesPaperUpdate=function(e){return this.request("files/paper/update",e,"user","api","upload","files.content.write")},_.filesPermanentlyDelete=function(e){return this.request("files/permanently_delete",e,"user","api","rpc","files.permanent_delete")},_.filesPropertiesAdd=function(e){return this.request("files/properties/add",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesOverwrite=function(e){return this.request("files/properties/overwrite",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesRemove=function(e){return this.request("files/properties/remove",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesTemplateGet=function(e){return this.request("files/properties/template/get",e,"user","api","rpc","files.metadata.read")},_.filesPropertiesTemplateList=function(){return this.request("files/properties/template/list",null,"user","api","rpc","files.metadata.read")},_.filesPropertiesUpdate=function(e){return this.request("files/properties/update",e,"user","api","rpc","files.metadata.write")},_.filesRestore=function(e){return this.request("files/restore",e,"user","api","rpc","files.content.write")},_.filesSaveUrl=function(e){return this.request("files/save_url",e,"user","api","rpc","files.content.write")},_.filesSaveUrlCheckJobStatus=function(e){return this.request("files/save_url/check_job_status",e,"user","api","rpc","files.content.write")},_.filesSearch=function(e){return this.request("files/search",e,"user","api","rpc","files.metadata.read")},_.filesSearchV2=function(e){return this.request("files/search_v2",e,"user","api","rpc","files.metadata.read")},_.filesSearchContinueV2=function(e){return this.request("files/search/continue_v2",e,"user","api","rpc","files.metadata.read")},_.filesTagsAdd=function(e){return this.request("files/tags/add",e,"user","api","rpc","files.metadata.write")},_.filesTagsGet=function(e){return this.request("files/tags/get",e,"user","api","rpc","files.metadata.read")},_.filesTagsRemove=function(e){return this.request("files/tags/remove",e,"user","api","rpc","files.metadata.write")},_.filesUnlockFileBatch=function(e){return this.request("files/unlock_file_batch",e,"user","api","rpc","files.content.write")},_.filesUpload=function(e){return this.request("files/upload",e,"user","content","upload","files.content.write")},_.filesUploadSessionAppendV2=function(e){return this.request("files/upload_session/append_v2",e,"user","content","upload","files.content.write")},_.filesUploadSessionAppend=function(e){return this.request("files/upload_session/append",e,"user","content","upload","files.content.write")},_.filesUploadSessionFinish=function(e){return this.request("files/upload_session/finish",e,"user","content","upload","files.content.write")},_.filesUploadSessionFinishBatch=function(e){return this.request("files/upload_session/finish_batch",e,"user","api","rpc","files.content.write")},_.filesUploadSessionFinishBatchV2=function(e){return this.request("files/upload_session/finish_batch_v2",e,"user","api","rpc","files.content.write")},_.filesUploadSessionFinishBatchCheck=function(e){return this.request("files/upload_session/finish_batch/check",e,"user","api","rpc","files.content.write")},_.filesUploadSessionStart=function(e){return this.request("files/upload_session/start",e,"user","content","upload","files.content.write")},_.filesUploadSessionStartBatch=function(e){return this.request("files/upload_session/start_batch",e,"user","api","rpc","files.content.write")},_.openidUserinfo=function(e){return this.request("openid/userinfo",e,"user","api","rpc","openid")},_.paperDocsArchive=function(e){return this.request("paper/docs/archive",e,"user","api","rpc","files.content.write")},_.paperDocsCreate=function(e){return this.request("paper/docs/create",e,"user","api","upload","files.content.write")},_.paperDocsDownload=function(e){return this.request("paper/docs/download",e,"user","api","download","files.content.read")},_.paperDocsFolderUsersList=function(e){return this.request("paper/docs/folder_users/list",e,"user","api","rpc","sharing.read")},_.paperDocsFolderUsersListContinue=function(e){return this.request("paper/docs/folder_users/list/continue",e,"user","api","rpc","sharing.read")},_.paperDocsGetFolderInfo=function(e){return this.request("paper/docs/get_folder_info",e,"user","api","rpc","sharing.read")},_.paperDocsList=function(e){return this.request("paper/docs/list",e,"user","api","rpc","files.metadata.read")},_.paperDocsListContinue=function(e){return this.request("paper/docs/list/continue",e,"user","api","rpc","files.metadata.read")},_.paperDocsPermanentlyDelete=function(e){return this.request("paper/docs/permanently_delete",e,"user","api","rpc","files.permanent_delete")},_.paperDocsSharingPolicyGet=function(e){return this.request("paper/docs/sharing_policy/get",e,"user","api","rpc","sharing.read")},_.paperDocsSharingPolicySet=function(e){return this.request("paper/docs/sharing_policy/set",e,"user","api","rpc","sharing.write")},_.paperDocsUpdate=function(e){return this.request("paper/docs/update",e,"user","api","upload","files.content.write")},_.paperDocsUsersAdd=function(e){return this.request("paper/docs/users/add",e,"user","api","rpc","sharing.write")},_.paperDocsUsersList=function(e){return this.request("paper/docs/users/list",e,"user","api","rpc","sharing.read")},_.paperDocsUsersListContinue=function(e){return this.request("paper/docs/users/list/continue",e,"user","api","rpc","sharing.read")},_.paperDocsUsersRemove=function(e){return this.request("paper/docs/users/remove",e,"user","api","rpc","sharing.write")},_.paperFoldersCreate=function(e){return this.request("paper/folders/create",e,"user","api","rpc","files.content.write")},_.sharingAddFileMember=function(e){return this.request("sharing/add_file_member",e,"user","api","rpc","sharing.write")},_.sharingAddFolderMember=function(e){return this.request("sharing/add_folder_member",e,"user","api","rpc","sharing.write")},_.sharingCheckJobStatus=function(e){return this.request("sharing/check_job_status",e,"user","api","rpc","sharing.write")},_.sharingCheckRemoveMemberJobStatus=function(e){return this.request("sharing/check_remove_member_job_status",e,"user","api","rpc","sharing.write")},_.sharingCheckShareJobStatus=function(e){return this.request("sharing/check_share_job_status",e,"user","api","rpc","sharing.write")},_.sharingCreateSharedLink=function(e){return this.request("sharing/create_shared_link",e,"user","api","rpc","sharing.write")},_.sharingCreateSharedLinkWithSettings=function(e){return this.request("sharing/create_shared_link_with_settings",e,"user","api","rpc","sharing.write")},_.sharingGetFileMetadata=function(e){return this.request("sharing/get_file_metadata",e,"user","api","rpc","sharing.read")},_.sharingGetFileMetadataBatch=function(e){return this.request("sharing/get_file_metadata/batch",e,"user","api","rpc","sharing.read")},_.sharingGetFolderMetadata=function(e){return this.request("sharing/get_folder_metadata",e,"user","api","rpc","sharing.read")},_.sharingGetSharedLinkFile=function(e){return this.request("sharing/get_shared_link_file",e,"user","content","download","sharing.read")},_.sharingGetSharedLinkMetadata=function(e){return this.request("sharing/get_shared_link_metadata",e,"app, user","api","rpc","sharing.read")},_.sharingGetSharedLinks=function(e){return this.request("sharing/get_shared_links",e,"user","api","rpc","sharing.read")},_.sharingListFileMembers=function(e){return this.request("sharing/list_file_members",e,"user","api","rpc","sharing.read")},_.sharingListFileMembersBatch=function(e){return this.request("sharing/list_file_members/batch",e,"user","api","rpc","sharing.read")},_.sharingListFileMembersContinue=function(e){return this.request("sharing/list_file_members/continue",e,"user","api","rpc","sharing.read")},_.sharingListFolderMembers=function(e){return this.request("sharing/list_folder_members",e,"user","api","rpc","sharing.read")},_.sharingListFolderMembersContinue=function(e){return this.request("sharing/list_folder_members/continue",e,"user","api","rpc","sharing.read")},_.sharingListFolders=function(e){return this.request("sharing/list_folders",e,"user","api","rpc","sharing.read")},_.sharingListFoldersContinue=function(e){return this.request("sharing/list_folders/continue",e,"user","api","rpc","sharing.read")},_.sharingListMountableFolders=function(e){return this.request("sharing/list_mountable_folders",e,"user","api","rpc","sharing.read")},_.sharingListMountableFoldersContinue=function(e){return this.request("sharing/list_mountable_folders/continue",e,"user","api","rpc","sharing.read")},_.sharingListReceivedFiles=function(e){return this.request("sharing/list_received_files",e,"user","api","rpc","sharing.read")},_.sharingListReceivedFilesContinue=function(e){return this.request("sharing/list_received_files/continue",e,"user","api","rpc","sharing.read")},_.sharingListSharedLinks=function(e){return this.request("sharing/list_shared_links",e,"user","api","rpc","sharing.read")},_.sharingModifySharedLinkSettings=function(e){return this.request("sharing/modify_shared_link_settings",e,"user","api","rpc","sharing.write")},_.sharingMountFolder=function(e){return this.request("sharing/mount_folder",e,"user","api","rpc","sharing.write")},_.sharingRelinquishFileMembership=function(e){return this.request("sharing/relinquish_file_membership",e,"user","api","rpc","sharing.write")},_.sharingRelinquishFolderMembership=function(e){return this.request("sharing/relinquish_folder_membership",e,"user","api","rpc","sharing.write")},_.sharingRemoveFileMember=function(e){return this.request("sharing/remove_file_member",e,"user","api","rpc","sharing.write")},_.sharingRemoveFileMember2=function(e){return this.request("sharing/remove_file_member_2",e,"user","api","rpc","sharing.write")},_.sharingRemoveFolderMember=function(e){return this.request("sharing/remove_folder_member",e,"user","api","rpc","sharing.write")},_.sharingRevokeSharedLink=function(e){return this.request("sharing/revoke_shared_link",e,"user","api","rpc","sharing.write")},_.sharingSetAccessInheritance=function(e){return this.request("sharing/set_access_inheritance",e,"user","api","rpc","sharing.write")},_.sharingShareFolder=function(e){return this.request("sharing/share_folder",e,"user","api","rpc","sharing.write")},_.sharingTransferFolder=function(e){return this.request("sharing/transfer_folder",e,"user","api","rpc","sharing.write")},_.sharingUnmountFolder=function(e){return this.request("sharing/unmount_folder",e,"user","api","rpc","sharing.write")},_.sharingUnshareFile=function(e){return this.request("sharing/unshare_file",e,"user","api","rpc","sharing.write")},_.sharingUnshareFolder=function(e){return this.request("sharing/unshare_folder",e,"user","api","rpc","sharing.write")},_.sharingUpdateFileMember=function(e){return this.request("sharing/update_file_member",e,"user","api","rpc","sharing.write")},_.sharingUpdateFolderMember=function(e){return this.request("sharing/update_folder_member",e,"user","api","rpc","sharing.write")},_.sharingUpdateFolderPolicy=function(e){return this.request("sharing/update_folder_policy",e,"user","api","rpc","sharing.write")},_.teamDevicesListMemberDevices=function(e){return this.request("team/devices/list_member_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesListMembersDevices=function(e){return this.request("team/devices/list_members_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesListTeamDevices=function(e){return this.request("team/devices/list_team_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesRevokeDeviceSession=function(e){return this.request("team/devices/revoke_device_session",e,"team","api","rpc","sessions.modify")},_.teamDevicesRevokeDeviceSessionBatch=function(e){return this.request("team/devices/revoke_device_session_batch",e,"team","api","rpc","sessions.modify")},_.teamFeaturesGetValues=function(e){return this.request("team/features/get_values",e,"team","api","rpc","team_info.read")},_.teamGetInfo=function(){return this.request("team/get_info",null,"team","api","rpc","team_info.read")},_.teamGroupsCreate=function(e){return this.request("team/groups/create",e,"team","api","rpc","groups.write")},_.teamGroupsDelete=function(e){return this.request("team/groups/delete",e,"team","api","rpc","groups.write")},_.teamGroupsGetInfo=function(e){return this.request("team/groups/get_info",e,"team","api","rpc","groups.read")},_.teamGroupsJobStatusGet=function(e){return this.request("team/groups/job_status/get",e,"team","api","rpc","groups.write")},_.teamGroupsList=function(e){return this.request("team/groups/list",e,"team","api","rpc","groups.read")},_.teamGroupsListContinue=function(e){return this.request("team/groups/list/continue",e,"team","api","rpc","groups.read")},_.teamGroupsMembersAdd=function(e){return this.request("team/groups/members/add",e,"team","api","rpc","groups.write")},_.teamGroupsMembersList=function(e){return this.request("team/groups/members/list",e,"team","api","rpc","groups.read")},_.teamGroupsMembersListContinue=function(e){return this.request("team/groups/members/list/continue",e,"team","api","rpc","groups.read")},_.teamGroupsMembersRemove=function(e){return this.request("team/groups/members/remove",e,"team","api","rpc","groups.write")},_.teamGroupsMembersSetAccessType=function(e){return this.request("team/groups/members/set_access_type",e,"team","api","rpc","groups.write")},_.teamGroupsUpdate=function(e){return this.request("team/groups/update",e,"team","api","rpc","groups.write")},_.teamLegalHoldsCreatePolicy=function(e){return this.request("team/legal_holds/create_policy",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsGetPolicy=function(e){return this.request("team/legal_holds/get_policy",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsListHeldRevisions=function(e){return this.request("team/legal_holds/list_held_revisions",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsListHeldRevisionsContinue=function(e){return this.request("team/legal_holds/list_held_revisions_continue",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsListPolicies=function(e){return this.request("team/legal_holds/list_policies",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsReleasePolicy=function(e){return this.request("team/legal_holds/release_policy",e,"team","api","rpc","team_data.governance.write")},_.teamLegalHoldsUpdatePolicy=function(e){return this.request("team/legal_holds/update_policy",e,"team","api","rpc","team_data.governance.write")},_.teamLinkedAppsListMemberLinkedApps=function(e){return this.request("team/linked_apps/list_member_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsListMembersLinkedApps=function(e){return this.request("team/linked_apps/list_members_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsListTeamLinkedApps=function(e){return this.request("team/linked_apps/list_team_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsRevokeLinkedApp=function(e){return this.request("team/linked_apps/revoke_linked_app",e,"team","api","rpc","sessions.modify")},_.teamLinkedAppsRevokeLinkedAppBatch=function(e){return this.request("team/linked_apps/revoke_linked_app_batch",e,"team","api","rpc","sessions.modify")},_.teamMemberSpaceLimitsExcludedUsersAdd=function(e){return this.request("team/member_space_limits/excluded_users/add",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsExcludedUsersList=function(e){return this.request("team/member_space_limits/excluded_users/list",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsExcludedUsersListContinue=function(e){return this.request("team/member_space_limits/excluded_users/list/continue",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsExcludedUsersRemove=function(e){return this.request("team/member_space_limits/excluded_users/remove",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsGetCustomQuota=function(e){return this.request("team/member_space_limits/get_custom_quota",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsRemoveCustomQuota=function(e){return this.request("team/member_space_limits/remove_custom_quota",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsSetCustomQuota=function(e){return this.request("team/member_space_limits/set_custom_quota",e,"team","api","rpc","members.read")},_.teamMembersAddV2=function(e){return this.request("team/members/add_v2",e,"team","api","rpc","members.write")},_.teamMembersAdd=function(e){return this.request("team/members/add",e,"team","api","rpc","members.write")},_.teamMembersAddJobStatusGetV2=function(e){return this.request("team/members/add/job_status/get_v2",e,"team","api","rpc","members.write")},_.teamMembersAddJobStatusGet=function(e){return this.request("team/members/add/job_status/get",e,"team","api","rpc","members.write")},_.teamMembersDeleteProfilePhotoV2=function(e){return this.request("team/members/delete_profile_photo_v2",e,"team","api","rpc","members.write")},_.teamMembersDeleteProfilePhoto=function(e){return this.request("team/members/delete_profile_photo",e,"team","api","rpc","members.write")},_.teamMembersGetAvailableTeamMemberRoles=function(){return this.request("team/members/get_available_team_member_roles",null,"team","api","rpc","members.read")},_.teamMembersGetInfoV2=function(e){return this.request("team/members/get_info_v2",e,"team","api","rpc","members.read")},_.teamMembersGetInfo=function(e){return this.request("team/members/get_info",e,"team","api","rpc","members.read")},_.teamMembersListV2=function(e){return this.request("team/members/list_v2",e,"team","api","rpc","members.read")},_.teamMembersList=function(e){return this.request("team/members/list",e,"team","api","rpc","members.read")},_.teamMembersListContinueV2=function(e){return this.request("team/members/list/continue_v2",e,"team","api","rpc","members.read")},_.teamMembersListContinue=function(e){return this.request("team/members/list/continue",e,"team","api","rpc","members.read")},_.teamMembersMoveFormerMemberFiles=function(e){return this.request("team/members/move_former_member_files",e,"team","api","rpc","members.write")},_.teamMembersMoveFormerMemberFilesJobStatusCheck=function(e){return this.request("team/members/move_former_member_files/job_status/check",e,"team","api","rpc","members.write")},_.teamMembersRecover=function(e){return this.request("team/members/recover",e,"team","api","rpc","members.delete")},_.teamMembersRemove=function(e){return this.request("team/members/remove",e,"team","api","rpc","members.delete")},_.teamMembersRemoveJobStatusGet=function(e){return this.request("team/members/remove/job_status/get",e,"team","api","rpc","members.delete")},_.teamMembersSecondaryEmailsAdd=function(e){return this.request("team/members/secondary_emails/add",e,"team","api","rpc","members.write")},_.teamMembersSecondaryEmailsDelete=function(e){return this.request("team/members/secondary_emails/delete",e,"team","api","rpc","members.write")},_.teamMembersSecondaryEmailsResendVerificationEmails=function(e){return this.request("team/members/secondary_emails/resend_verification_emails",e,"team","api","rpc","members.write")},_.teamMembersSendWelcomeEmail=function(e){return this.request("team/members/send_welcome_email",e,"team","api","rpc","members.write")},_.teamMembersSetAdminPermissionsV2=function(e){return this.request("team/members/set_admin_permissions_v2",e,"team","api","rpc","members.write")},_.teamMembersSetAdminPermissions=function(e){return this.request("team/members/set_admin_permissions",e,"team","api","rpc","members.write")},_.teamMembersSetProfileV2=function(e){return this.request("team/members/set_profile_v2",e,"team","api","rpc","members.write")},_.teamMembersSetProfile=function(e){return this.request("team/members/set_profile",e,"team","api","rpc","members.write")},_.teamMembersSetProfilePhotoV2=function(e){return this.request("team/members/set_profile_photo_v2",e,"team","api","rpc","members.write")},_.teamMembersSetProfilePhoto=function(e){return this.request("team/members/set_profile_photo",e,"team","api","rpc","members.write")},_.teamMembersSuspend=function(e){return this.request("team/members/suspend",e,"team","api","rpc","members.write")},_.teamMembersUnsuspend=function(e){return this.request("team/members/unsuspend",e,"team","api","rpc","members.write")},_.teamNamespacesList=function(e){return this.request("team/namespaces/list",e,"team","api","rpc","team_data.member")},_.teamNamespacesListContinue=function(e){return this.request("team/namespaces/list/continue",e,"team","api","rpc","team_data.member")},_.teamPropertiesTemplateAdd=function(e){return this.request("team/properties/template/add",e,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateGet=function(e){return this.request("team/properties/template/get",e,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateList=function(){return this.request("team/properties/template/list",null,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateUpdate=function(e){return this.request("team/properties/template/update",e,"team","api","rpc","files.team_metadata.write")},_.teamReportsGetActivity=function(e){return this.request("team/reports/get_activity",e,"team","api","rpc","team_info.read")},_.teamReportsGetDevices=function(e){return this.request("team/reports/get_devices",e,"team","api","rpc","team_info.read")},_.teamReportsGetMembership=function(e){return this.request("team/reports/get_membership",e,"team","api","rpc","team_info.read")},_.teamReportsGetStorage=function(e){return this.request("team/reports/get_storage",e,"team","api","rpc","team_info.read")},_.teamSharingAllowlistAdd=function(e){return this.request("team/sharing_allowlist/add",e,"team","api","rpc","team_info.write")},_.teamSharingAllowlistList=function(e){return this.request("team/sharing_allowlist/list",e,"team","api","rpc","team_info.read")},_.teamSharingAllowlistListContinue=function(e){return this.request("team/sharing_allowlist/list/continue",e,"team","api","rpc","team_info.read")},_.teamSharingAllowlistRemove=function(e){return this.request("team/sharing_allowlist/remove",e,"team","api","rpc","team_info.write")},_.teamTeamFolderActivate=function(e){return this.request("team/team_folder/activate",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderArchive=function(e){return this.request("team/team_folder/archive",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderArchiveCheck=function(e){return this.request("team/team_folder/archive/check",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderCreate=function(e){return this.request("team/team_folder/create",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderGetInfo=function(e){return this.request("team/team_folder/get_info",e,"team","api","rpc","team_data.content.read")},_.teamTeamFolderList=function(e){return this.request("team/team_folder/list",e,"team","api","rpc","team_data.content.read")},_.teamTeamFolderListContinue=function(e){return this.request("team/team_folder/list/continue",e,"team","api","rpc","team_data.content.read")},_.teamTeamFolderPermanentlyDelete=function(e){return this.request("team/team_folder/permanently_delete",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderRename=function(e){return this.request("team/team_folder/rename",e,"team","api","rpc","team_data.content.write")},_.teamTeamFolderUpdateSyncSettings=function(e){return this.request("team/team_folder/update_sync_settings",e,"team","api","rpc","team_data.content.write")},_.teamTokenGetAuthenticatedAdmin=function(){return this.request("team/token/get_authenticated_admin",null,"team","api","rpc","team_info.read")},_.teamLogGetEvents=function(e){return this.request("team_log/get_events",e,"team","api","rpc","events.read")},_.teamLogGetEventsContinue=function(e){return this.request("team_log/get_events/continue",e,"team","api","rpc","events.read")},_.usersFeaturesGetValues=function(e){return this.request("users/features/get_values",e,"user","api","rpc","account_info.read")},_.usersGetAccount=function(e){return this.request("users/get_account",e,"user","api","rpc","sharing.read")},_.usersGetAccountBatch=function(e){return this.request("users/get_account_batch",e,"user","api","rpc","sharing.read")},_.usersGetCurrentAccount=function(){return this.request("users/get_current_account",null,"user","api","rpc","account_info.read")},_.usersGetSpaceUsage=function(){return this.request("users/get_space_usage",null,"user","api","rpc","account_info.read")};var q=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:".";return r?(t!==m&&void 0!==d[e]&&(e=d[e],r="-"),"https://".concat(e).concat(r).concat(t,"/2/")):"https://".concat(t,"/2/")},b=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:h;return e!==h&&(e="meta-".concat(e)),"https://".concat(e,"/oauth2/authorize")},v=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:".",r="api";return e!==m&&(r=d[r],t="-"),"https://".concat(r).concat(t).concat(e,"/oauth2/token")};function w(e){return JSON.stringify(e).replace(/[\u007f-\uffff]/g,g)}function k(e){return new Date(Date.now()+1e3*e)}function y(){return"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope||"undefined"=="object"||"undefined"!=typeof window}function A(){return"undefined"!=typeof window}function S(){return"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope}function C(e){return e.toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}var T,L,M,P=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&n(e,t)}(u,e);var r,i,o=(r=u,i=a(),function(){var e,t=s(r);if(i){var n=s(this).constructor;e=Reflect.construct(t,arguments,n)}else e=t.apply(this,arguments);return c(this,e)});function u(e,r,i){var s;return t(this,u),(s=o.call(this,"Response failed with a ".concat(e," code"))).name="DropboxResponseError",s.status=e,s.headers=r,s.error=i,s}return u}(u(Error)),R=function e(r,i,s){t(this,e),this.status=r,this.headers=i,this.result=s};function F(e){return e.text().then((function(t){var r;try{r=JSON.parse(t)}catch(e){r=t}throw new P(e.status,e.headers,r)}))}function D(e){return e.ok?e.text().then((function(t){var r;try{r=JSON.parse(t)}catch(e){r=t}return new R(e.status,e.headers,r)})):F(e)}var G=["legacy","offline","online"],U=["code","token"],x=["none","user","team"],E=function(){function e(r){t(this,e),r=r||{},A()?(T=window.fetch.bind(window),L=window.crypto||window.msCrypto):S()?(T=self.fetch.bind(self),L=self.crypto):(T=__webpack_require__(1898),L=__webpack_require__(8090)),M="undefined"==typeof TextEncoder?(__webpack_require__(2974).TextEncoder):TextEncoder,this.fetch=r.fetch||T,this.accessToken=r.accessToken,this.accessTokenExpiresAt=r.accessTokenExpiresAt,this.refreshToken=r.refreshToken,this.clientId=r.clientId,this.clientSecret=r.clientSecret,this.domain=r.domain,this.domainDelimiter=r.domainDelimiter,this.customHeaders=r.customHeaders,this.dataOnBody=r.dataOnBody}return i(e,[{key:"setAccessToken",value:function(e){this.accessToken=e}},{key:"getAccessToken",value:function(){return this.accessToken}},{key:"setClientId",value:function(e){this.clientId=e}},{key:"getClientId",value:function(){return this.clientId}},{key:"setClientSecret",value:function(e){this.clientSecret=e}},{key:"getClientSecret",value:function(){return this.clientSecret}},{key:"getRefreshToken",value:function(){return this.refreshToken}},{key:"setRefreshToken",value:function(e){this.refreshToken=e}},{key:"getAccessTokenExpiresAt",value:function(){return this.accessTokenExpiresAt}},{key:"setAccessTokenExpiresAt",value:function(e){this.accessTokenExpiresAt=e}},{key:"setCodeVerifier",value:function(e){this.codeVerifier=e}},{key:"getCodeVerifier",value:function(){return this.codeVerifier}},{key:"generateCodeChallenge",value:function(){var e,t=this,r=(new M).encode(this.codeVerifier);if(A()||S())return L.subtle.digest("SHA-256",r).then((function(r){var i=btoa(String.fromCharCode.apply(null,new Uint8Array(r)));e=C(i).substr(0,128),t.codeChallenge=e}));var i=L.createHash("sha256").update(r).digest();return e=C(i),this.codeChallenge=e,Promise.resolve()}},{key:"generatePKCECodes",value:function(){var e;if(A()||S()){var t=new Uint8Array(128),r=L.getRandomValues(t);e=C(btoa(r)).substr(0,128)}else{e=C(L.randomBytes(128)).substr(0,128)}return this.codeVerifier=e,this.generateCodeChallenge()}},{key:"getAuthenticationUrl",value:function(e,t){var r,i=this,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"token",n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"none",u=arguments.length>6&&void 0!==arguments[6]&&arguments[6],c=this.getClientId(),p=b(this.domain);if(!c)throw Error("A client id is required. You can set the client id using .setClientId().");if("code"!==s&&!e)throw Error("A redirect uri is required.");if(!U.includes(s))throw Error("Authorization type must be code or token");if(n&&!G.includes(n))throw Error("Token Access Type must be legacy, offline, or online");if(a&&!(a instanceof Array))throw Error("Scope must be an array of strings");if(!x.includes(o))throw Error("includeGrantedScopes must be none, user, or team");return r="code"===s?"".concat(p,"?response_type=code&client_id=").concat(c):"".concat(p,"?response_type=token&client_id=").concat(c),e&&(r+="&redirect_uri=".concat(e)),t&&(r+="&state=".concat(t)),n&&(r+="&token_access_type=".concat(n)),a&&(r+="&scope=".concat(a.join(" "))),"none"!==o&&(r+="&include_granted_scopes=".concat(o)),u?this.generatePKCECodes().then((function(){return r+="&code_challenge_method=S256",r+="&code_challenge=".concat(i.codeChallenge)})):Promise.resolve(r)}},{key:"getAccessTokenFromCode",value:function(e,t){var r=this.getClientId(),i=this.getClientSecret();if(!r)throw Error("A client id is required. You can set the client id using .setClientId().");var s=v(this.domain,this.domainDelimiter);if(s+="?grant_type=authorization_code",s+="&code=".concat(t),s+="&client_id=".concat(r),i)s+="&client_secret=".concat(i);else{if(!this.codeVerifier)throw Error("You must use PKCE when generating the authorization URL to not include a client secret");s+="&code_verifier=".concat(this.codeVerifier)}e&&(s+="&redirect_uri=".concat(e));return this.fetch(s,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"}}).then((function(e){return D(e)}))}},{key:"checkAndRefreshAccessToken",value:function(){var e=this.getRefreshToken()&&this.getClientId(),t=!this.getAccessTokenExpiresAt()||new Date(Date.now()+3e5)>=this.getAccessTokenExpiresAt(),r=!this.getAccessToken();return(t||r)&&e?this.refreshAccessToken():Promise.resolve()}},{key:"refreshAccessToken",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=this.getClientId(),i=this.getClientSecret();if(!r)throw Error("A client id is required. You can set the client id using .setClientId().");if(t&&!(t instanceof Array))throw Error("Scope must be an array of strings");var s=v(this.domain,this.domainDelimiter),n={headers:{"Content-Type":"application/json"},method:"POST"};if(this.dataOnBody){var a={grant_type:"refresh_token",client_id:r,refresh_token:this.getRefreshToken()};i&&(a.client_secret=i),t&&(a.scope=t.join(" ")),n.body=a}else s+="?grant_type=refresh_token&refresh_token=".concat(this.getRefreshToken()),s+="&client_id=".concat(r),i&&(s+="&client_secret=".concat(i)),t&&(s+="&scope=".concat(t.join(" ")));return this.fetch(s,n).then((function(e){return D(e)})).then((function(t){e.setAccessToken(t.result.access_token),e.setAccessTokenExpiresAt(k(t.result.expires_in))}))}}]),e}(),B="undefined"==typeof btoa?function(e){return Buffer.from(e).toString("base64")}:btoa;e.Dropbox=function(){function e(r){t(this,e),this.auth=(r=r||{}).auth?r.auth:new E(r),this.fetch=r.fetch||this.auth.fetch,this.selectUser=r.selectUser,this.selectAdmin=r.selectAdmin,this.pathRoot=r.pathRoot,this.domain=r.domain||this.auth.domain,this.domainDelimiter=r.domainDelimiter||this.auth.domainDelimiter,this.customHeaders=r.customHeaders||this.auth.customHeaders,Object.assign(this,_)}return i(e,[{key:"request",value:function(e,t,r,i,s){switch(s){case"rpc":return this.rpcRequest(e,t,r,i);case"download":return this.downloadRequest(e,t,r,i);case"upload":return this.uploadRequest(e,t,r,i);default:throw Error("Invalid request style: ".concat(s))}}},{key:"rpcRequest",value:function(e,t,r,i){var s=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e={method:"POST",body:t?JSON.stringify(t):null,headers:{}};return t&&(e.headers["Content-Type"]="application/json"),s.setAuthHeaders(r,e),s.setCommonHeaders(e),e})).then((function(t){return s.fetch(q(i,s.domain,s.domainDelimiter)+e,t)})).then((function(e){return D(e)}))}},{key:"downloadRequest",value:function(e,t,r,i){var s=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e={method:"POST",headers:{"Dropbox-API-Arg":w(t)}};return s.setAuthHeaders(r,e),s.setCommonHeaders(e),e})).then((function(t){return s.fetch(q(i,s.domain,s.domainDelimiter)+e,t)})).then((function(e){return function(e){return e.ok?new Promise((function(t){y()?e.blob().then((function(e){return t(e)})):e.buffer().then((function(e){return t(e)}))})).then((function(t){var r=JSON.parse(e.headers.get("dropbox-api-result"));return y()?r.fileBlob=t:r.fileBinary=t,new R(e.status,e.headers,r)})):F(e)}(e)}))}},{key:"uploadRequest",value:function(e,t,r,i){var s=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e=t.contents;delete t.contents;var i={body:e,method:"POST",headers:{"Content-Type":"application/octet-stream","Dropbox-API-Arg":w(t)}};return s.setAuthHeaders(r,i),s.setCommonHeaders(i),i})).then((function(t){return s.fetch(q(i,s.domain,s.domainDelimiter)+e,t)})).then((function(e){return D(e)}))}},{key:"setAuthHeaders",value:function(e,t){if(e.split(",").length>1){var r=e.replace(" ","").split(",");r.includes(l)&&this.auth.getAccessToken()?e=l:r.includes(f)&&this.auth.getAccessToken()?e=f:r.includes(p)&&(e=p)}switch(e){case p:if(this.auth.clientId&&this.auth.clientSecret){var i=B("".concat(this.auth.clientId,":").concat(this.auth.clientSecret));t.headers.Authorization="Basic ".concat(i)}break;case f:case l:this.auth.getAccessToken()&&(t.headers.Authorization="Bearer ".concat(this.auth.getAccessToken()));break;case"noauth":case"cookie":break;default:throw Error("Unhandled auth type: ".concat(e))}}},{key:"setCommonHeaders",value:function(e){var t=this;(this.selectUser&&(e.headers["Dropbox-API-Select-User"]=this.selectUser),this.selectAdmin&&(e.headers["Dropbox-API-Select-Admin"]=this.selectAdmin),this.pathRoot&&(e.headers["Dropbox-API-Path-Root"]=this.pathRoot),this.customHeaders)&&Object.keys(this.customHeaders).forEach((function(r){e.headers[r]=t.customHeaders[r]}))}}]),e}(),e.DropboxAuth=E,e.DropboxResponse=R,e.DropboxResponseError=P,Object.defineProperty(e,"__esModule",{value:!0})}));


/***/ }),

/***/ 720:
/***/ ((module) => {

"use strict";


module.exports = earcut;
module.exports["default"] = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ 2587:
/***/ (function(module) {

"use strict";
/*

 Copyright 2000, Silicon Graphics, Inc. All Rights Reserved.
 Copyright 2015, Google Inc. All Rights Reserved.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to
 deal in the Software without restriction, including without limitation the
 rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice including the dates of first publication and
 either this permission notice or a reference to http://oss.sgi.com/projects/FreeB/
 shall be included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 Original Code. The Original Code is: OpenGL Sample Implementation,
 Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
 Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
 Copyright in any portions created by third parties is as indicated
 elsewhere herein. All Rights Reserved.
*/
var n;function t(a,b){return a.b===b.b&&a.a===b.a}function u(a,b){return a.b<b.b||a.b===b.b&&a.a<=b.a}function v(a,b,c){var d=b.b-a.b,e=c.b-b.b;return 0<d+e?d<e?b.a-a.a+d/(d+e)*(a.a-c.a):b.a-c.a+e/(d+e)*(c.a-a.a):0}function x(a,b,c){var d=b.b-a.b,e=c.b-b.b;return 0<d+e?(b.a-c.a)*d+(b.a-a.a)*e:0}function z(a,b){return a.a<b.a||a.a===b.a&&a.b<=b.b}function aa(a,b,c){var d=b.a-a.a,e=c.a-b.a;return 0<d+e?d<e?b.b-a.b+d/(d+e)*(a.b-c.b):b.b-c.b+e/(d+e)*(c.b-a.b):0}
function ba(a,b,c){var d=b.a-a.a,e=c.a-b.a;return 0<d+e?(b.b-c.b)*d+(b.b-a.b)*e:0}function ca(a){return u(a.b.a,a.a)}function da(a){return u(a.a,a.b.a)}function A(a,b,c,d){a=0>a?0:a;c=0>c?0:c;return a<=c?0===c?(b+d)/2:b+a/(a+c)*(d-b):d+c/(a+c)*(b-d)};function ea(a){var b=B(a.b);C(b,a.c);C(b.b,a.c);D(b,a.a);return b}function E(a,b){var c=!1,d=!1;a!==b&&(b.a!==a.a&&(d=!0,F(b.a,a.a)),b.d!==a.d&&(c=!0,G(b.d,a.d)),H(b,a),d||(C(b,a.a),a.a.c=a),c||(D(b,a.d),a.d.a=a))}function I(a){var b=a.b,c=!1;a.d!==a.b.d&&(c=!0,G(a.d,a.b.d));a.c===a?F(a.a,null):(a.b.d.a=J(a),a.a.c=a.c,H(a,J(a)),c||D(a,a.d));b.c===b?(F(b.a,null),G(b.d,null)):(a.d.a=J(b),b.a.c=b.c,H(b,J(b)));fa(a)}
function K(a){var b=B(a),c=b.b;H(b,a.e);b.a=a.b.a;C(c,b.a);b.d=c.d=a.d;b=b.b;H(a.b,J(a.b));H(a.b,b);a.b.a=b.a;b.b.a.c=b.b;b.b.d=a.b.d;b.f=a.f;b.b.f=a.b.f;return b}function L(a,b){var c=!1,d=B(a),e=d.b;b.d!==a.d&&(c=!0,G(b.d,a.d));H(d,a.e);H(e,b);d.a=a.b.a;e.a=b.a;d.d=e.d=a.d;a.d.a=e;c||D(d,a.d);return d}function B(a){var b=new M,c=new M,d=a.b.h;c.h=d;d.b.h=b;b.h=a;a.b.h=c;b.b=c;b.c=b;b.e=c;c.b=b;c.c=c;return c.e=b}function H(a,b){var c=a.c,d=b.c;c.b.e=b;d.b.e=a;a.c=d;b.c=c}
function C(a,b){var c=b.f,d=new N(b,c);c.e=d;b.f=d;c=d.c=a;do c.a=d,c=c.c;while(c!==a)}function D(a,b){var c=b.d,d=new ga(b,c);c.b=d;b.d=d;d.a=a;d.c=b.c;c=a;do c.d=d,c=c.e;while(c!==a)}function fa(a){var b=a.h;a=a.b.h;b.b.h=a;a.b.h=b}function F(a,b){var c=a.c,d=c;do d.a=b,d=d.c;while(d!==c);c=a.f;d=a.e;d.f=c;c.e=d}function G(a,b){var c=a.a,d=c;do d.d=b,d=d.e;while(d!==c);c=a.d;d=a.b;d.d=c;c.b=d};function ha(a){var b=0;Math.abs(a[1])>Math.abs(a[0])&&(b=1);Math.abs(a[2])>Math.abs(a[b])&&(b=2);return b};var O=4*1E150;function P(a,b){a.f+=b.f;a.b.f+=b.b.f}function ia(a,b,c){a=a.a;b=b.a;c=c.a;if(b.b.a===a)return c.b.a===a?u(b.a,c.a)?0>=x(c.b.a,b.a,c.a):0<=x(b.b.a,c.a,b.a):0>=x(c.b.a,a,c.a);if(c.b.a===a)return 0<=x(b.b.a,a,b.a);b=v(b.b.a,a,b.a);a=v(c.b.a,a,c.a);return b>=a}function Q(a){a.a.i=null;var b=a.e;b.a.c=b.c;b.c.a=b.a;a.e=null}function ja(a,b){I(a.a);a.c=!1;a.a=b;b.i=a}function ka(a){var b=a.a.a;do a=R(a);while(a.a.a===b);a.c&&(b=L(S(a).a.b,a.a.e),ja(a,b),a=R(a));return a}
function la(a,b,c){var d=new ma;d.a=c;d.e=na(a.f,b.e,d);return c.i=d}function oa(a,b){switch(a.s){case 100130:return 0!==(b&1);case 100131:return 0!==b;case 100132:return 0<b;case 100133:return 0>b;case 100134:return 2<=b||-2>=b}return!1}function pa(a){var b=a.a,c=b.d;c.c=a.d;c.a=b;Q(a)}function T(a,b,c){a=b;for(b=b.a;a!==c;){a.c=!1;var d=S(a),e=d.a;if(e.a!==b.a){if(!d.c){pa(a);break}e=L(b.c.b,e.b);ja(d,e)}b.c!==e&&(E(J(e),e),E(b,e));pa(a);b=d.a;a=d}return b}
function U(a,b,c,d,e,f){var g=!0;do la(a,b,c.b),c=c.c;while(c!==d);for(null===e&&(e=S(b).a.b.c);;){d=S(b);c=d.a.b;if(c.a!==e.a)break;c.c!==e&&(E(J(c),c),E(J(e),c));d.f=b.f-c.f;d.d=oa(a,d.f);b.b=!0;!g&&qa(a,b)&&(P(c,e),Q(b),I(e));g=!1;b=d;e=c}b.b=!0;f&&ra(a,b)}function sa(a,b,c,d,e){var f=[b.g[0],b.g[1],b.g[2]];b.d=null;b.d=a.o?a.o(f,c,d,a.c)||null:null;null===b.d&&(e?a.n||(V(a,100156),a.n=!0):b.d=c[0])}
function ta(a,b,c){var d=[null,null,null,null];d[0]=b.a.d;d[1]=c.a.d;sa(a,b.a,d,[.5,.5,0,0],!1);E(b,c)}function ua(a,b,c,d,e){var f=Math.abs(b.b-a.b)+Math.abs(b.a-a.a),g=Math.abs(c.b-a.b)+Math.abs(c.a-a.a),h=e+1;d[e]=.5*g/(f+g);d[h]=.5*f/(f+g);a.g[0]+=d[e]*b.g[0]+d[h]*c.g[0];a.g[1]+=d[e]*b.g[1]+d[h]*c.g[1];a.g[2]+=d[e]*b.g[2]+d[h]*c.g[2]}
function qa(a,b){var c=S(b),d=b.a,e=c.a;if(u(d.a,e.a)){if(0<x(e.b.a,d.a,e.a))return!1;if(!t(d.a,e.a))K(e.b),E(d,J(e)),b.b=c.b=!0;else if(d.a!==e.a){var c=a.e,f=d.a.h;if(0<=f){var c=c.b,g=c.d,h=c.e,k=c.c,l=k[f];g[l]=g[c.a];k[g[l]]=l;l<=--c.a&&(1>=l?W(c,l):u(h[g[l>>1]],h[g[l]])?W(c,l):va(c,l));h[f]=null;k[f]=c.b;c.b=f}else for(c.c[-(f+1)]=null;0<c.a&&null===c.c[c.d[c.a-1]];)--c.a;ta(a,J(e),d)}}else{if(0>x(d.b.a,e.a,d.a))return!1;R(b).b=b.b=!0;K(d.b);E(J(e),d)}return!0}
function wa(a,b){var c=S(b),d=b.a,e=c.a,f=d.a,g=e.a,h=d.b.a,k=e.b.a,l=new N;x(h,a.a,f);x(k,a.a,g);if(f===g||Math.min(f.a,h.a)>Math.max(g.a,k.a))return!1;if(u(f,g)){if(0<x(k,f,g))return!1}else if(0>x(h,g,f))return!1;var r=h,p=f,q=k,y=g,m,w;u(r,p)||(m=r,r=p,p=m);u(q,y)||(m=q,q=y,y=m);u(r,q)||(m=r,r=q,q=m,m=p,p=y,y=m);u(q,p)?u(p,y)?(m=v(r,q,p),w=v(q,p,y),0>m+w&&(m=-m,w=-w),l.b=A(m,q.b,w,p.b)):(m=x(r,q,p),w=-x(r,y,p),0>m+w&&(m=-m,w=-w),l.b=A(m,q.b,w,y.b)):l.b=(q.b+p.b)/2;z(r,p)||(m=r,r=p,p=m);z(q,y)||
(m=q,q=y,y=m);z(r,q)||(m=r,r=q,q=m,m=p,p=y,y=m);z(q,p)?z(p,y)?(m=aa(r,q,p),w=aa(q,p,y),0>m+w&&(m=-m,w=-w),l.a=A(m,q.a,w,p.a)):(m=ba(r,q,p),w=-ba(r,y,p),0>m+w&&(m=-m,w=-w),l.a=A(m,q.a,w,y.a)):l.a=(q.a+p.a)/2;u(l,a.a)&&(l.b=a.a.b,l.a=a.a.a);r=u(f,g)?f:g;u(r,l)&&(l.b=r.b,l.a=r.a);if(t(l,f)||t(l,g))return qa(a,b),!1;if(!t(h,a.a)&&0<=x(h,a.a,l)||!t(k,a.a)&&0>=x(k,a.a,l)){if(k===a.a)return K(d.b),E(e.b,d),b=ka(b),d=S(b).a,T(a,S(b),c),U(a,b,J(d),d,d,!0),!0;if(h===a.a){K(e.b);E(d.e,J(e));f=c=b;g=f.a.b.a;
do f=R(f);while(f.a.b.a===g);b=f;f=S(b).a.b.c;c.a=J(e);e=T(a,c,null);U(a,b,e.c,d.b.c,f,!0);return!0}0<=x(h,a.a,l)&&(R(b).b=b.b=!0,K(d.b),d.a.b=a.a.b,d.a.a=a.a.a);0>=x(k,a.a,l)&&(b.b=c.b=!0,K(e.b),e.a.b=a.a.b,e.a.a=a.a.a);return!1}K(d.b);K(e.b);E(J(e),d);d.a.b=l.b;d.a.a=l.a;d.a.h=xa(a.e,d.a);d=d.a;e=[0,0,0,0];l=[f.d,h.d,g.d,k.d];d.g[0]=d.g[1]=d.g[2]=0;ua(d,f,h,e,0);ua(d,g,k,e,2);sa(a,d,l,e,!0);R(b).b=b.b=c.b=!0;return!1}
function ra(a,b){for(var c=S(b);;){for(;c.b;)b=c,c=S(c);if(!b.b&&(c=b,b=R(b),null===b||!b.b))break;b.b=!1;var d=b.a,e=c.a,f;if(f=d.b.a!==e.b.a)a:{f=b;var g=S(f),h=f.a,k=g.a,l=void 0;if(u(h.b.a,k.b.a)){if(0>x(h.b.a,k.b.a,h.a)){f=!1;break a}R(f).b=f.b=!0;l=K(h);E(k.b,l);l.d.c=f.d}else{if(0<x(k.b.a,h.b.a,k.a)){f=!1;break a}f.b=g.b=!0;l=K(k);E(h.e,k.b);l.b.d.c=f.d}f=!0}f&&(c.c?(Q(c),I(e),c=S(b),e=c.a):b.c&&(Q(b),I(d),b=R(c),d=b.a));if(d.a!==e.a)if(d.b.a===e.b.a||b.c||c.c||d.b.a!==a.a&&e.b.a!==a.a)qa(a,
b);else if(wa(a,b))break;d.a===e.a&&d.b.a===e.b.a&&(P(e,d),Q(b),I(d),b=R(c))}}
function ya(a,b){a.a=b;for(var c=b.c;null===c.i;)if(c=c.c,c===b.c){var c=a,d=b,e=new ma;e.a=d.c.b;var f=c.f,g=f.a;do g=g.a;while(null!==g.b&&!f.c(f.b,e,g.b));var f=g.b,h=S(f),e=f.a,g=h.a;if(0===x(e.b.a,d,e.a))e=f.a,t(e.a,d)||t(e.b.a,d)||(K(e.b),f.c&&(I(e.c),f.c=!1),E(d.c,e),ya(c,d));else{var k=u(g.b.a,e.b.a)?f:h,h=void 0;f.d||k.c?(k===f?h=L(d.c.b,e.e):h=L(g.b.c.b,d.c).b,k.c?ja(k,h):(e=c,f=la(c,f,h),f.f=R(f).f+f.a.f,f.d=oa(e,f.f)),ya(c,d)):U(c,f,d.c,d.c,null,!0)}return}c=ka(c.i);e=S(c);f=e.a;e=T(a,
e,null);if(e.c===f){var f=e,e=f.c,g=S(c),h=c.a,k=g.a,l=!1;h.b.a!==k.b.a&&wa(a,c);t(h.a,a.a)&&(E(J(e),h),c=ka(c),e=S(c).a,T(a,S(c),g),l=!0);t(k.a,a.a)&&(E(f,J(k)),f=T(a,g,null),l=!0);l?U(a,c,f.c,e,e,!0):(u(k.a,h.a)?d=J(k):d=h,d=L(f.c.b,d),U(a,c,d,d.c,d.c,!1),d.b.i.c=!0,ra(a,c))}else U(a,c,e.c,f,f,!0)}function za(a,b){var c=new ma,d=ea(a.b);d.a.b=O;d.a.a=b;d.b.a.b=-O;d.b.a.a=b;a.a=d.b.a;c.a=d;c.f=0;c.d=!1;c.c=!1;c.h=!0;c.b=!1;d=a.f;d=na(d,d.a,c);c.e=d};function Aa(a){this.a=new Ba;this.b=a;this.c=ia}function na(a,b,c){do b=b.c;while(null!==b.b&&!a.c(a.b,b.b,c));a=new Ba(c,b.a,b);b.a.c=a;return b.a=a};function Ba(a,b,c){this.b=a||null;this.a=b||this;this.c=c||this};function X(){this.d=Y;this.p=this.b=this.q=null;this.j=[0,0,0];this.s=100130;this.n=!1;this.o=this.a=this.e=this.f=null;this.m=!1;this.c=this.r=this.i=this.k=this.l=this.h=null}var Y=0;n=X.prototype;n.x=function(){Z(this,Y)};n.B=function(a,b){switch(a){case 100142:return;case 100140:switch(b){case 100130:case 100131:case 100132:case 100133:case 100134:this.s=b;return}break;case 100141:this.m=!!b;return;default:V(this,100900);return}V(this,100901)};
n.y=function(a){switch(a){case 100142:return 0;case 100140:return this.s;case 100141:return this.m;default:V(this,100900)}return!1};n.A=function(a,b,c){this.j[0]=a;this.j[1]=b;this.j[2]=c};
n.z=function(a,b){var c=b?b:null;switch(a){case 100100:case 100106:this.h=c;break;case 100104:case 100110:this.l=c;break;case 100101:case 100107:this.k=c;break;case 100102:case 100108:this.i=c;break;case 100103:case 100109:this.p=c;break;case 100105:case 100111:this.o=c;break;case 100112:this.r=c;break;default:V(this,100900)}};
n.C=function(a,b){var c=!1,d=[0,0,0];Z(this,2);for(var e=0;3>e;++e){var f=a[e];-1E150>f&&(f=-1E150,c=!0);1E150<f&&(f=1E150,c=!0);d[e]=f}c&&V(this,100155);c=this.q;null===c?(c=ea(this.b),E(c,c.b)):(K(c),c=c.e);c.a.d=b;c.a.g[0]=d[0];c.a.g[1]=d[1];c.a.g[2]=d[2];c.f=1;c.b.f=-1;this.q=c};n.u=function(a){Z(this,Y);this.d=1;this.b=new Ca;this.c=a};n.t=function(){Z(this,1);this.d=2;this.q=null};n.v=function(){Z(this,2);this.d=1};
n.w=function(){Z(this,1);this.d=Y;var a=this.j[0],b=this.j[1],c=this.j[2],d=!1,e=[a,b,c];if(0===a&&0===b&&0===c){for(var b=[-2*1E150,-2*1E150,-2*1E150],f=[2*1E150,2*1E150,2*1E150],c=[],g=[],d=this.b.c,a=d.e;a!==d;a=a.e)for(var h=0;3>h;++h){var k=a.g[h];k<f[h]&&(f[h]=k,g[h]=a);k>b[h]&&(b[h]=k,c[h]=a)}a=0;b[1]-f[1]>b[0]-f[0]&&(a=1);b[2]-f[2]>b[a]-f[a]&&(a=2);if(f[a]>=b[a])e[0]=0,e[1]=0,e[2]=1;else{b=0;f=g[a];c=c[a];g=[0,0,0];f=[f.g[0]-c.g[0],f.g[1]-c.g[1],f.g[2]-c.g[2]];h=[0,0,0];for(a=d.e;a!==d;a=
a.e)h[0]=a.g[0]-c.g[0],h[1]=a.g[1]-c.g[1],h[2]=a.g[2]-c.g[2],g[0]=f[1]*h[2]-f[2]*h[1],g[1]=f[2]*h[0]-f[0]*h[2],g[2]=f[0]*h[1]-f[1]*h[0],k=g[0]*g[0]+g[1]*g[1]+g[2]*g[2],k>b&&(b=k,e[0]=g[0],e[1]=g[1],e[2]=g[2]);0>=b&&(e[0]=e[1]=e[2]=0,e[ha(f)]=1)}d=!0}g=ha(e);a=this.b.c;b=(g+1)%3;c=(g+2)%3;g=0<e[g]?1:-1;for(e=a.e;e!==a;e=e.e)e.b=e.g[b],e.a=g*e.g[c];if(d){e=0;d=this.b.a;for(a=d.b;a!==d;a=a.b)if(b=a.a,!(0>=b.f)){do e+=(b.a.b-b.b.a.b)*(b.a.a+b.b.a.a),b=b.e;while(b!==a.a)}if(0>e)for(e=this.b.c,d=e.e;d!==
e;d=d.e)d.a=-d.a}this.n=!1;e=this.b.b;for(a=e.h;a!==e;a=d)if(d=a.h,b=a.e,t(a.a,a.b.a)&&a.e.e!==a&&(ta(this,b,a),I(a),a=b,b=a.e),b.e===a){if(b!==a){if(b===d||b===d.b)d=d.h;I(b)}if(a===d||a===d.b)d=d.h;I(a)}this.e=e=new Da;d=this.b.c;for(a=d.e;a!==d;a=a.e)a.h=xa(e,a);Ea(e);this.f=new Aa(this);za(this,-O);for(za(this,O);null!==(e=Fa(this.e));){for(;;){a:if(a=this.e,0===a.a)d=Ga(a.b);else if(d=a.c[a.d[a.a-1]],0!==a.b.a&&(a=Ga(a.b),u(a,d))){d=a;break a}if(null===d||!t(d,e))break;d=Fa(this.e);ta(this,e.c,
d.c)}ya(this,e)}this.a=this.f.a.a.b.a.a;for(e=0;null!==(d=this.f.a.a.b);)d.h||++e,Q(d);this.f=null;e=this.e;e.b=null;e.d=null;this.e=e.c=null;e=this.b;for(a=e.a.b;a!==e.a;a=d)d=a.b,a=a.a,a.e.e===a&&(P(a.c,a),I(a));if(!this.n){e=this.b;if(this.m)for(a=e.b.h;a!==e.b;a=d)d=a.h,a.b.d.c!==a.d.c?a.f=a.d.c?1:-1:I(a);else for(a=e.a.b;a!==e.a;a=d)if(d=a.b,a.c){for(a=a.a;u(a.b.a,a.a);a=a.c.b);for(;u(a.a,a.b.a);a=a.e);b=a.c.b;for(c=void 0;a.e!==b;)if(u(a.b.a,b.a)){for(;b.e!==a&&(ca(b.e)||0>=x(b.a,b.b.a,b.e.b.a));)c=
L(b.e,b),b=c.b;b=b.c.b}else{for(;b.e!==a&&(da(a.c.b)||0<=x(a.b.a,a.a,a.c.b.a));)c=L(a,a.c.b),a=c.b;a=a.e}for(;b.e.e!==a;)c=L(b.e,b),b=c.b}if(this.h||this.i||this.k||this.l)if(this.m)for(e=this.b,d=e.a.b;d!==e.a;d=d.b){if(d.c){this.h&&this.h(2,this.c);a=d.a;do this.k&&this.k(a.a.d,this.c),a=a.e;while(a!==d.a);this.i&&this.i(this.c)}}else{e=this.b;d=!!this.l;a=!1;b=-1;for(c=e.a.d;c!==e.a;c=c.d)if(c.c){a||(this.h&&this.h(4,this.c),a=!0);g=c.a;do d&&(f=g.b.d.c?0:1,b!==f&&(b=f,this.l&&this.l(!!b,this.c))),
this.k&&this.k(g.a.d,this.c),g=g.e;while(g!==c.a)}a&&this.i&&this.i(this.c)}if(this.r){e=this.b;for(a=e.a.b;a!==e.a;a=d)if(d=a.b,!a.c){b=a.a;c=b.e;g=void 0;do g=c,c=g.e,g.d=null,null===g.b.d&&(g.c===g?F(g.a,null):(g.a.c=g.c,H(g,J(g))),f=g.b,f.c===f?F(f.a,null):(f.a.c=f.c,H(f,J(f))),fa(g));while(g!==b);b=a.d;a=a.b;a.d=b;b.b=a}this.r(this.b);this.c=this.b=null;return}}this.b=this.c=null};
function Z(a,b){if(a.d!==b)for(;a.d!==b;)if(a.d<b)switch(a.d){case Y:V(a,100151);a.u(null);break;case 1:V(a,100152),a.t()}else switch(a.d){case 2:V(a,100154);a.v();break;case 1:V(a,100153),a.w()}}function V(a,b){a.p&&a.p(b,a.c)};function ga(a,b){this.b=a||this;this.d=b||this;this.a=null;this.c=!1};function M(){this.h=this;this.i=this.d=this.a=this.e=this.c=this.b=null;this.f=0}function J(a){return a.b.e};function Ca(){this.c=new N;this.a=new ga;this.b=new M;this.d=new M;this.b.b=this.d;this.d.b=this.b};function N(a,b){this.e=a||this;this.f=b||this;this.d=this.c=null;this.g=[0,0,0];this.h=this.a=this.b=0};function Da(){this.c=[];this.d=null;this.a=0;this.e=!1;this.b=new Ha}function Ea(a){a.d=[];for(var b=0;b<a.a;b++)a.d[b]=b;a.d.sort(function(a){return function(b,e){return u(a[b],a[e])?1:-1}}(a.c));a.e=!0;Ia(a.b)}function xa(a,b){if(a.e){var c=a.b,d=++c.a;2*d>c.f&&(c.f*=2,c.c=Ja(c.c,c.f+1));var e;0===c.b?e=d:(e=c.b,c.b=c.c[c.b]);c.e[e]=b;c.c[e]=d;c.d[d]=e;c.h&&va(c,d);return e}c=a.a++;a.c[c]=b;return-(c+1)}
function Fa(a){if(0===a.a)return Ka(a.b);var b=a.c[a.d[a.a-1]];if(0!==a.b.a&&u(Ga(a.b),b))return Ka(a.b);do--a.a;while(0<a.a&&null===a.c[a.d[a.a-1]]);return b};function Ha(){this.d=Ja([0],33);this.e=[null,null];this.c=[0,0];this.a=0;this.f=32;this.b=0;this.h=!1;this.d[1]=1}function Ja(a,b){for(var c=Array(b),d=0;d<a.length;d++)c[d]=a[d];for(;d<b;d++)c[d]=0;return c}function Ia(a){for(var b=a.a;1<=b;--b)W(a,b);a.h=!0}function Ga(a){return a.e[a.d[1]]}function Ka(a){var b=a.d,c=a.e,d=a.c,e=b[1],f=c[e];0<a.a&&(b[1]=b[a.a],d[b[1]]=1,c[e]=null,d[e]=a.b,a.b=e,0<--a.a&&W(a,1));return f}
function W(a,b){for(var c=a.d,d=a.e,e=a.c,f=b,g=c[f];;){var h=f<<1;h<a.a&&u(d[c[h+1]],d[c[h]])&&(h+=1);var k=c[h];if(h>a.a||u(d[g],d[k])){c[f]=g;e[g]=f;break}c[f]=k;e[k]=f;f=h}}function va(a,b){for(var c=a.d,d=a.e,e=a.c,f=b,g=c[f];;){var h=f>>1,k=c[h];if(0===h||u(d[k],d[g])){c[f]=g;e[g]=f;break}c[f]=k;e[k]=f;f=h}};function ma(){this.e=this.a=null;this.f=0;this.c=this.b=this.h=this.d=!1}function S(a){return a.e.c.b}function R(a){return a.e.a.b};this.libtess={GluTesselator:X,windingRule:{GLU_TESS_WINDING_ODD:100130,GLU_TESS_WINDING_NONZERO:100131,GLU_TESS_WINDING_POSITIVE:100132,GLU_TESS_WINDING_NEGATIVE:100133,GLU_TESS_WINDING_ABS_GEQ_TWO:100134},primitiveType:{GL_LINE_LOOP:2,GL_TRIANGLES:4,GL_TRIANGLE_STRIP:5,GL_TRIANGLE_FAN:6},errorType:{GLU_TESS_MISSING_BEGIN_POLYGON:100151,GLU_TESS_MISSING_END_POLYGON:100153,GLU_TESS_MISSING_BEGIN_CONTOUR:100152,GLU_TESS_MISSING_END_CONTOUR:100154,GLU_TESS_COORD_TOO_LARGE:100155,GLU_TESS_NEED_COMBINE_CALLBACK:100156},
gluEnum:{GLU_TESS_MESH:100112,GLU_TESS_TOLERANCE:100142,GLU_TESS_WINDING_RULE:100140,GLU_TESS_BOUNDARY_ONLY:100141,GLU_INVALID_ENUM:100900,GLU_INVALID_VALUE:100901,GLU_TESS_BEGIN:100100,GLU_TESS_VERTEX:100101,GLU_TESS_END:100102,GLU_TESS_ERROR:100103,GLU_TESS_EDGE_FLAG:100104,GLU_TESS_COMBINE:100105,GLU_TESS_BEGIN_DATA:100106,GLU_TESS_VERTEX_DATA:100107,GLU_TESS_END_DATA:100108,GLU_TESS_ERROR_DATA:100109,GLU_TESS_EDGE_FLAG_DATA:100110,GLU_TESS_COMBINE_DATA:100111}};X.prototype.gluDeleteTess=X.prototype.x;
X.prototype.gluTessProperty=X.prototype.B;X.prototype.gluGetTessProperty=X.prototype.y;X.prototype.gluTessNormal=X.prototype.A;X.prototype.gluTessCallback=X.prototype.z;X.prototype.gluTessVertex=X.prototype.C;X.prototype.gluTessBeginPolygon=X.prototype.u;X.prototype.gluTessBeginContour=X.prototype.t;X.prototype.gluTessEndContour=X.prototype.v;X.prototype.gluTessEndPolygon=X.prototype.w; if (true) { module.exports = this.libtess; }


/***/ }),

/***/ 1898:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof __webpack_require__.g !== 'undefined') { return __webpack_require__.g; }
	throw new Error('unable to locate global object');
}

var globalObject = getGlobal();

module.exports = exports = globalObject.fetch;

// Needed for TypeScript and Webpack.
if (globalObject.fetch) {
	exports["default"] = globalObject.fetch.bind(globalObject);
}

exports.Headers = globalObject.Headers;
exports.Request = globalObject.Request;
exports.Response = globalObject.Response;


/***/ }),

/***/ 3379:
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 569:
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ 9216:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ 3565:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 7795:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ 4589:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ 1036:
/***/ ((module) => {

module.exports = "<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 689 456.3\"><circle cx=\"78.99\" cy=\"226.63\" r=\"78.99\"></circle><circle cx=\"296.5\" cy=\"344.5\" r=\"111.8\"></circle><circle cx=\"541.36\" cy=\"147.64\" r=\"147.64\"></circle></svg>"

/***/ }),

/***/ 6212:
/***/ ((module) => {

module.exports = "<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 623.98 532.11\"><path d=\"M591.31,495.25c57.9-140.61-220.75-311-366.91-77.42L64,228.89C409,44.34,605.42,160.72,668.16,308c70.35,165.11-61.18,345-163,356.88-94.7,11.09-214.8-58.09-245.56-84.45l81.29-156S533.4,635.86,591.31,495.25Z\" transform=\"translate(-64.02 -133.94)\"></path><path d=\"M598,428\" transform=\"translate(-64.02 -133.94)\"></path></svg>"

/***/ }),

/***/ 6504:
/***/ ((module) => {

module.exports = "<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 596 610\"><path d=\"M634,572,216,732,92,474,328,174l360-52\" transform=\"translate(-92 -122)\"></path><path d=\"M598,428\" transform=\"translate(-92 -122)\"></path></svg>"

/***/ }),

/***/ 6445:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>capture</title><path d=\"M4 2v28h24v-28h-24zM24 22h-16v-16h16v16z\"></path></svg>"

/***/ }),

/***/ 5399:
/***/ ((module) => {

module.exports = "<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 600 600\"><path d=\"M300,100V200H600V500H700V100Z\" transform=\"translate(-100 -100)\"></path><path d=\"M328,700V600H200V472H100V700Z\" transform=\"translate(-100 -100)\"></path></svg>"

/***/ }),

/***/ 8028:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>download</title><path d=\"M16.001 19.314l-8.485-8.485 2.828-2.829 5.657 5.657 5.657-5.657 2.828 2.828-8.485 8.486zM8 28h16v-4h-16v4z\"></path></svg>"

/***/ }),

/***/ 4461:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>forbid</title><path d=\"M18.828 16l4.243 4.243-2.828 2.828-4.243-4.243-4.243 4.243-2.828-2.828 4.243-4.243-4.243-4.243 2.828-2.828 4.243 4.243 4.243-4.243 2.828 2.828-4.243 4.243z\"></path></svg>"

/***/ }),

/***/ 2485:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>launch</title><path d=\"M24 24h-6v4h-4v-4h-6l4-4v-13l4-4 4 4v13l4 4z\"></path></svg>"

/***/ }),

/***/ 5713:
/***/ ((module) => {

module.exports = "<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 525.86 431.95\"><path d=\"M385,607.38,148.64,422.62l61.57-78.8L367.78,467l228-291.57L674.5,237Z\" transform=\"translate(-148.64 -175.43)\"></path></svg>"

/***/ }),

/***/ 6801:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>plug</title><path d=\"M22 11v-8h-12v8h-2v14h6v4h4v-4h6v-14h-2zM18 11h-4v-4h4v4z\"></path></svg>"

/***/ }),

/***/ 6056:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>redo</title><path d=\"M28 24v4h-24v-20h10.071l-3.657-3.654 2.828-2.826 8.485 8.485-8.485 8.484-2.828-2.83 3.657-3.659h-6.071v12h20z\"></path></svg>"

/***/ }),

/***/ 1878:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>resize</title><path d=\"M28 12v-8h-8v2h-8v-2h-8v8h2v8h-2v8h8v-2h8v2h8v-8h-2v-8h2zM22 20h-2v2h-8v-2h-2v-8h2v-2h8v2h2v8z\"></path></svg>"

/***/ }),

/***/ 4878:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>solve</title><path d=\"M28 12v4h-4v6h-6v4h-4v-4h-6v-6h-4v-4h4v-6h6v4h4v-4h6v6h4z\"></path></svg>"

/***/ }),

/***/ 8179:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>time</title><path d=\"M22 18h-8v-8h4v4h4v4zM30 2v28h-28v-28h28zM26 6h-20v20h20v-20z\"></path></svg>"

/***/ }),

/***/ 4897:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>undo</title><path d=\"M28 8v20h-24v-4h20v-12h-6.071l3.657 3.66-2.828 2.83-8.485-8.484 8.485-8.485 2.828 2.826-3.657 3.653h10.071z\"></path></svg>"

/***/ }),

/***/ 2578:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "73fb7b7f0e68b372adfe.ttf";

/***/ }),

/***/ 5200:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nuint seed = 11425u;\\n\\nuint hash_u(uint _a) {\\n   uint a = _a;\\n   a ^= a >> 16;\\n   a *= 0x7feb352du;\\n   a ^= a >> 15;\\n   a *= 0x846ca68bu;\\n   a ^= a >> 16;\\n   return a; \\n }\\nfloat hash_f(){ uint s = hash_u(seed); seed = s;return ( float( s ) / float( 0xffffffffu ) ); }\\nvec2 hash_v2(){ return vec2(hash_f(), hash_f()); }\\nvec3 hash_v3(){ return vec3(hash_f(), hash_f(), hash_f()); }\\nvec4 hash_v4(){ return vec4(hash_f(), hash_f(), hash_f(), hash_f()); }\\n\\nfloat hash_f_s(uint s){ s = hash_u(s); return ( float( s ) / float( 0xffffffffu ) ); }\\n// vec2 hash_22_s(uvec2 s){ uint _s = hash_u(s.x) + hash_u(s.y); return vec2(hash_f_s(_s.x), hash_f_s(_s.y)); }\\nfloat hash_21_s(ivec2 _s_){ \\n  uvec2 s = uvec2(_s_);\\n  uint _s = hash_u(s.x + hash_u(s.y)) + hash_u(s.y + hash_u(s.x)); \\n  return hash_f_s(_s); \\n}\\n// vec3 hash_23_s(){ return vec3(hash_f_s(), hash_f_s(), hash_f_s()); }\\n// vec4 hash_24_s(){ return vec4(hash_f_s(), hash_f_s(), hash_f_s(), hash_f_s()); }\\n\\nfloat valueNoise( in vec2 p ){\\n    p += 100.;\\n    ivec2 i = ivec2(floor( p ));\\n    vec2 f = fract( p );\\n\\n    // cubic interpolant\\n    vec2 u = f*f*(3.0-2.0*f);\\n\\n    return mix( mix( hash_21_s( i + ivec2(0,0) ), \\n                     hash_21_s( i + ivec2(1,0) ), u.x),\\n                mix( hash_21_s( i + ivec2(0,1) ), \\n                     hash_21_s( i + ivec2(1,1) ), u.x), u.y);\\n}\\n\\nuniform mat4 brush_params;\\n// uniform int brush_texture_idx;\\n// uniform vec3 tex_hsv_dynamics;\\n// uniform vec2 noise_stretch;\\n// uniform vec2 tex_stretch;\\n\\nin vec2 uv;\\nin vec4 vCol;\\nout vec4 col;\\n\\nvec4 sample_brush_tex(int idx, vec2 uv){\\n  if(idx == 0){\\n    return texture(brush_texture[0],uv,-1.);\\n  }\\n  if(idx == 1){\\n    return texture(brush_texture[1],uv,-1.);\\n  }\\n  if(idx == 2){\\n    return texture(brush_texture[2],uv,-1.);\\n  }\\n  if(idx == 3){\\n    return texture(brush_texture[3],uv,-1.);\\n  }\\n  if(idx == 4){\\n    return texture(brush_texture[4],uv,-1.);\\n  }\\n  if(idx == 5){\\n    return texture(brush_texture[5],uv,-1.);\\n  }\\n  if(idx == 6){\\n    return texture(brush_texture[6],uv,-1.);\\n  } \\n  // if(idx == 7){\\n  //   return texture(brush_texture[7],uv);\\n  // }\\n  // if(idx == 8){\\n  //   return texture(brush_texture_8,uv);\\n  // }\\n  // if(idx == 9){\\n  //   return texture(brush_texture_9,uv);\\n  // }\\n  // if(idx == 10){\\n  //   return texture(brush_texture_10,uv);\\n  // }\\n  // if(idx == 11){\\n  //   return texture(brush_texture_11,uv);\\n  // }\\n  // if(idx == 12){\\n  //   return texture(brush_texture_12,uv);\\n  // }\\n}\\n\\nfloat sdBox(vec2 p, vec2 sz){\\n    p = abs(p) - sz;\\n    return max(p.x,p.y);\\n}\\nvoid main() {\\n\\n  int brush_texture_idx = int(brush_params[0][0]+0.5);\\n  vec3 tex_hsv_dynamics = vec3(brush_params[0][1], brush_params[0][2], brush_params[0][3]);\\n  vec2 noise_stretch = vec2(brush_params[1][0], brush_params[1][1]);\\n  vec2 tex_stretch = vec2(brush_params[1][2], brush_params[0][3]);\\n  col = vec4(1);\\n  // col.xyz = stroke_col.xyz;\\n  \\n  vec2 u = uv - 0.5;\\n  \\n  vec2 boxSz = vec2(0.49);\\n  \\n  float pi = 3.14159265359;\\n  float tau = 2.*pi;\\n\\n  col = vCol;\\n  {\\n    col.xyz = srgb_to_oklch(col.xyz);\\n\\n    vec2 nuv = uv*2120.;\\n    nuv *= noise_stretch;\\n    float n = (valueNoise(nuv)*2. - 1.);\\n\\n    col.z += 5.5* n * tex_hsv_dynamics.z;\\n    col.x += n * tex_hsv_dynamics.x;\\n    col.y += n * tex_hsv_dynamics.y;\\n\\n    col.x = clamp(col.x, 0., 1.);\\n    col.y = clamp(col.y, 0., 1.);\\n    col.z = mod(col.z, tau);\\n    col.xyz = oklch_to_srgb(col.xyz);\\n  }\\n  \\n  {\\n    vec2 dx = dFdx(uv.xy);\\n    vec2 dy = dFdy(uv.xy);\\n    \\n    float sd = sdBox(u,boxSz);\\n    // sd = sdBox(u,boxSz - fwidth(sd)); // ?\\n\\n    float fw = fwidth((sd));\\n    \\n    #define render(pos)  (1.-step(0.,sdBox(pos,boxSz)))\\n        \\n    \\n    float brush_alpha = sample_brush_tex(\\n      brush_texture_idx, \\n      fract(((uv - 0.5) * tex_stretch) + 0.5)\\n      // fract(uv*4.)\\n    ).w;\\n\\n    if(brush_alpha > 0.001){\\n      if(fw < 0.004){\\n        col.w *= smoothstep(1.,0.,(sd)/fw);\\n      } else{\\n        // col.w *= smoothstep(1.,0.,(sd)/fw);\\n\\n          float w = 0.;\\n          float _Bias = 1.;\\n          vec2 uvOffsets = vec2(0.125, 0.375);\\n          vec2 offsetUV = vec2(0.0, 0.0);\\n\\n          offsetUV.xy = u.xy + uvOffsets.x * dx + uvOffsets.y * dy;\\n          w += render(offsetUV.xy);\\n          offsetUV.xy = u.xy - uvOffsets.x * dx - uvOffsets.y * dy;\\n          w += render(offsetUV.xy);\\n          offsetUV.xy = u.xy + uvOffsets.y * dx - uvOffsets.x * dy;\\n          w += render(offsetUV.xy);\\n          offsetUV.xy = u.xy - uvOffsets.y * dx + uvOffsets.x * dy;\\n          w += render(offsetUV.xy);\\n          w *= 1./4.;\\n          col.w *= w;\\n          \\n          // uvOffsets = uvOffsets * rot(0.25*acos(-1.));\\n          // offsetUV.xy = u.xy + uvOffsets.x * dx + uvOffsets.y * dy;\\n          // w += render(offsetUV.xy);\\n          // offsetUV.xy = u.xy - uvOffsets.x * dx - uvOffsets.y * dy;\\n          // w += render(offsetUV.xy);\\n          // offsetUV.xy = u.xy + uvOffsets.y * dx - uvOffsets.x * dy;\\n          // w += render(offsetUV.xy);\\n          // offsetUV.xy = u.xy - uvOffsets.y * dx + uvOffsets.x * dy;\\n          // w += render(offsetUV.xy);\\n\\n          // w /= 8.;\\n          // col.w *= w;\\n          //col.x = 1.;\\n      }\\n      col.w *= brush_alpha;\\n    } else {\\n      col = vec4(0);\\n    }\\n  }\\n}\";";

/***/ }),

/***/ 5522:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\nout vec2 uv;\\n\\nlayout(location = 0) in vec4 pos;\\nlayout(location = 1) in vec4 col;\\nout vec4 vCol;\\nvoid main(){\\n  // gl_Position.xy *= brush_sz;\\n  gl_Position = vec4(pos.xy,0,1);\\n  \\n  vCol = col;\\n\\n  uv = pos.zw;\\n}  \";";

/***/ }),

/***/ 8180:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nin vec2 uv;\\nout vec4 col;\\nvoid main() {\\n  col = vec4(1);\\n  \\n  vec2 u = uv;\\n  u = abs(u) \\n    - 0.5/css_contain(vec2(1), canvasR,R);\\n  ;\\n  float rect_sdf = max(u.x,u.y);\\n  rect_sdf = -1.;\\n  if(rect_sdf >0.)\\n    col.xyz = vec3(0);\\n\\n  col.w = 1.;\\n}\";";

/***/ }),

/***/ 9083:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nuniform float zoom;\\nuniform vec2 brush_sz;\\nout vec2 uv;\\nvoid main(){\\n  gl_Position = vec4(positions[gl_VertexID],0,1);\\n  uv = gl_Position.xy;\\n  gl_Position.xy *= brush_sz*0.2125*zoom;\\n\\n  vec2 aspect_correction;\\n  if (canvasR.x > canvasR.y) {\\n    aspect_correction.x = canvasR.y / canvasR.x;\\n    aspect_correction.y = 1.;\\n  } else {\\n    aspect_correction.x = 1.;\\n    aspect_correction.y = canvasR.x / canvasR.y;\\n  }\\n  gl_Position.xy *= aspect_correction;\\n  gl_Position.xy = css_contain(gl_Position.xy,canvasR,R);\\n}  \";";

/***/ }),

/***/ 2527:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nuniform vec4 colour;\\nin vec2 uv;\\nout vec4 col;\\nvoid main() {\\n  col = vec4(1);\\n  col.xyz = pow(colour.xyz,vec3(0.454545454545));\\n\\n  vec2 u = uv;\\n  u = abs(u) - 0.8;\\n  float rect_sdf = max(u.x,u.y);\\n  if(rect_sdf >0.)\\n    col.xyz = vec3(0.5);\\n  \\n}\\n\";";

/***/ }),

/***/ 9346:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nout vec2 uv;\\nvoid main(){\\n  gl_Position = vec4(positions[gl_VertexID],0,1);\\n  uv = gl_Position.xy;\\n\\n  gl_Position.xy *= vec2(0.1);\\n\\n  vec2 aspect_correction;\\n  if (canvasR.x > canvasR.y) {\\n    aspect_correction.x = canvasR.y / canvasR.x;\\n    aspect_correction.y = 1.;\\n  } else {\\n    aspect_correction.x = 1.;\\n    aspect_correction.y = canvasR.x / canvasR.y;\\n  }\\n  gl_Position.xy *= aspect_correction;\\n  \\n  gl_Position.xy = css_contain(gl_Position.xy,canvasR,R);\\n}  \";";

/***/ }),

/***/ 2082:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\n#ifndef SPECTRAL\\n#define SPECTRAL\\n\\nconst int SPECTRAL_SIZE = 38;\\nconst float SPECTRAL_GAMMA = 2.4;\\nconst float SPECTRAL_EPSILON = 0.0001;\\n\\nfloat spectral_uncompand(float x) {\\n  return (x < 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, SPECTRAL_GAMMA);\\n}\\n\\nfloat spectral_compand(float x) {\\n  return (x < 0.0031308) ? x * 12.92 : 1.055 * pow(x, 1.0 / SPECTRAL_GAMMA) - 0.055;\\n}\\n\\nvec3 spectral_srgb_to_linear(vec3 srgb) {\\n    return vec3(spectral_uncompand(srgb[0]), spectral_uncompand(srgb[1]), spectral_uncompand(srgb[2]));\\n}\\n\\nvec3 spectral_linear_to_srgb(vec3 lrgb) {\\n    return clamp(vec3(spectral_compand(lrgb[0]), spectral_compand(lrgb[1]), spectral_compand(lrgb[2])), 0.0, 1.0);\\n}\\n\\nvoid spectral_upsampling(vec3 lrgb, out float w, out float c, out float m, out float y, out float r, out float g, out float b) {\\n    w = min(lrgb.r, min(lrgb.g, lrgb.b));\\n\\n    lrgb -= w;\\n\\n    c = min(lrgb.g, lrgb.b);\\n    m = min(lrgb.r, lrgb.b);\\n    y = min(lrgb.r, lrgb.g);\\n    r = min(max(0., lrgb.r - lrgb.b), max(0., lrgb.r - lrgb.g));\\n    g = min(max(0., lrgb.g - lrgb.b), max(0., lrgb.g - lrgb.r));\\n    b = min(max(0., lrgb.b - lrgb.g), max(0., lrgb.b - lrgb.r));\\n}\\n\\nvoid spectral_linear_to_reflectance(vec3 lrgb, inout float R[SPECTRAL_SIZE]) {\\n    float w, c, m, y, r, g, b;\\n    \\n    spectral_upsampling(lrgb, w, c, m, y, r, g, b);\\n    \\n     R[0] = max(SPECTRAL_EPSILON, w + c * 0.96853629 + m * 0.51567122 + y * 0.02055257 + r * 0.03147571 + g * 0.49108579 + b * 0.97901834);\\n     R[1] = max(SPECTRAL_EPSILON, w + c * 0.96855103 + m * 0.54015520 + y * 0.02059936 + r * 0.03146636 + g * 0.46944057 + b * 0.97901649);\\n     R[2] = max(SPECTRAL_EPSILON, w + c * 0.96859338 + m * 0.62645502 + y * 0.02062723 + r * 0.03140624 + g * 0.40165780 + b * 0.97901118);\\n     R[3] = max(SPECTRAL_EPSILON, w + c * 0.96877345 + m * 0.75595012 + y * 0.02073387 + r * 0.03119611 + g * 0.24490420 + b * 0.97892146);\\n     R[4] = max(SPECTRAL_EPSILON, w + c * 0.96942204 + m * 0.92826996 + y * 0.02114202 + r * 0.03053888 + g * 0.06826880 + b * 0.97858555);\\n     R[5] = max(SPECTRAL_EPSILON, w + c * 0.97143709 + m * 0.97223624 + y * 0.02233154 + r * 0.02856855 + g * 0.02732883 + b * 0.97743705);\\n     R[6] = max(SPECTRAL_EPSILON, w + c * 0.97541862 + m * 0.98616174 + y * 0.02556857 + r * 0.02459485 + g * 0.01360600 + b * 0.97428075);\\n     R[7] = max(SPECTRAL_EPSILON, w + c * 0.98074186 + m * 0.98955255 + y * 0.03330189 + r * 0.01929520 + g * 0.01000187 + b * 0.96663223);\\n     R[8] = max(SPECTRAL_EPSILON, w + c * 0.98580992 + m * 0.98676237 + y * 0.05185294 + r * 0.01423112 + g * 0.01284127 + b * 0.94822893);\\n     R[9] = max(SPECTRAL_EPSILON, w + c * 0.98971194 + m * 0.97312575 + y * 0.10087639 + r * 0.01033111 + g * 0.02636635 + b * 0.89937713);\\n    R[10] = max(SPECTRAL_EPSILON, w + c * 0.99238027 + m * 0.91944277 + y * 0.24000413 + r * 0.00765876 + g * 0.07058713 + b * 0.76070164);\\n    R[11] = max(SPECTRAL_EPSILON, w + c * 0.99409844 + m * 0.32564851 + y * 0.53589066 + r * 0.00593693 + g * 0.70421692 + b * 0.46420440);\\n    R[12] = max(SPECTRAL_EPSILON, w + c * 0.99517200 + m * 0.13820628 + y * 0.79874659 + r * 0.00485616 + g * 0.85473994 + b * 0.20123039);\\n    R[13] = max(SPECTRAL_EPSILON, w + c * 0.99576545 + m * 0.05015143 + y * 0.91186529 + r * 0.00426186 + g * 0.95081565 + b * 0.08808402);\\n    R[14] = max(SPECTRAL_EPSILON, w + c * 0.99593552 + m * 0.02912336 + y * 0.95399623 + r * 0.00409039 + g * 0.97170370 + b * 0.04592894);\\n    R[15] = max(SPECTRAL_EPSILON, w + c * 0.99564041 + m * 0.02421691 + y * 0.97137099 + r * 0.00438375 + g * 0.97651888 + b * 0.02860373);\\n    R[16] = max(SPECTRAL_EPSILON, w + c * 0.99464769 + m * 0.02660696 + y * 0.97939505 + r * 0.00537525 + g * 0.97429245 + b * 0.02060067);\\n    R[17] = max(SPECTRAL_EPSILON, w + c * 0.99229579 + m * 0.03407586 + y * 0.98345207 + r * 0.00772962 + g * 0.97012917 + b * 0.01656701);\\n    R[18] = max(SPECTRAL_EPSILON, w + c * 0.98638762 + m * 0.04835936 + y * 0.98553736 + r * 0.01366120 + g * 0.94258630 + b * 0.01451549);\\n    R[19] = max(SPECTRAL_EPSILON, w + c * 0.96829712 + m * 0.00011720 + y * 0.98648905 + r * 0.03181352 + g * 0.99989207 + b * 0.01357964);\\n    R[20] = max(SPECTRAL_EPSILON, w + c * 0.89228016 + m * 0.00008554 + y * 0.98674535 + r * 0.10791525 + g * 0.99989891 + b * 0.01331243);\\n    R[21] = max(SPECTRAL_EPSILON, w + c * 0.53740239 + m * 0.85267882 + y * 0.98657555 + r * 0.46249516 + g * 0.13823139 + b * 0.01347661);\\n    R[22] = max(SPECTRAL_EPSILON, w + c * 0.15360445 + m * 0.93188793 + y * 0.98611877 + r * 0.84604333 + g * 0.06968113 + b * 0.01387181);\\n    R[23] = max(SPECTRAL_EPSILON, w + c * 0.05705719 + m * 0.94810268 + y * 0.98559942 + r * 0.94275572 + g * 0.05628787 + b * 0.01435472);\\n    R[24] = max(SPECTRAL_EPSILON, w + c * 0.03126539 + m * 0.94200977 + y * 0.98507063 + r * 0.96860996 + g * 0.06111561 + b * 0.01479836);\\n    R[25] = max(SPECTRAL_EPSILON, w + c * 0.02205445 + m * 0.91478045 + y * 0.98460039 + r * 0.97783966 + g * 0.08987709 + b * 0.01515250);\\n    R[26] = max(SPECTRAL_EPSILON, w + c * 0.01802271 + m * 0.87065445 + y * 0.98425301 + r * 0.98187757 + g * 0.13656016 + b * 0.01540513);\\n    R[27] = max(SPECTRAL_EPSILON, w + c * 0.01613460 + m * 0.78827548 + y * 0.98403909 + r * 0.98377315 + g * 0.22169624 + b * 0.01557233);\\n    R[28] = max(SPECTRAL_EPSILON, w + c * 0.01520947 + m * 0.65738359 + y * 0.98388535 + r * 0.98470202 + g * 0.32176956 + b * 0.01565710);\\n    R[29] = max(SPECTRAL_EPSILON, w + c * 0.01475977 + m * 0.59909403 + y * 0.98376116 + r * 0.98515481 + g * 0.36157329 + b * 0.01571025);\\n    R[30] = max(SPECTRAL_EPSILON, w + c * 0.01454263 + m * 0.56817268 + y * 0.98368246 + r * 0.98537114 + g * 0.48361920 + b * 0.01571916);\\n    R[31] = max(SPECTRAL_EPSILON, w + c * 0.01444459 + m * 0.54031997 + y * 0.98365023 + r * 0.98546685 + g * 0.46488579 + b * 0.01572133);\\n    R[32] = max(SPECTRAL_EPSILON, w + c * 0.01439897 + m * 0.52110241 + y * 0.98361309 + r * 0.98550011 + g * 0.47440306 + b * 0.01572502);\\n    R[33] = max(SPECTRAL_EPSILON, w + c * 0.01437620 + m * 0.51041094 + y * 0.98357259 + r * 0.98551031 + g * 0.48576990 + b * 0.01571717);\\n    R[34] = max(SPECTRAL_EPSILON, w + c * 0.01436343 + m * 0.50526577 + y * 0.98353856 + r * 0.98550741 + g * 0.49267971 + b * 0.01571905);\\n    R[35] = max(SPECTRAL_EPSILON, w + c * 0.01435687 + m * 0.50255080 + y * 0.98351247 + r * 0.98551323 + g * 0.49625685 + b * 0.01571059);\\n    R[36] = max(SPECTRAL_EPSILON, w + c * 0.01435370 + m * 0.50126452 + y * 0.98350101 + r * 0.98551563 + g * 0.49807754 + b * 0.01569728);\\n    R[37] = max(SPECTRAL_EPSILON, w + c * 0.01435408 + m * 0.50083021 + y * 0.98350852 + r * 0.98551547 + g * 0.49889859 + b * 0.01570020);\\n}\\n\\nvec3 spectral_xyz_to_srgb(vec3 xyz) {\\n    mat3 XYZ_RGB;\\n\\n    XYZ_RGB[0] = vec3( 3.24306333, -1.53837619, -0.49893282);\\n    XYZ_RGB[1] = vec3(-0.96896309,  1.87542451,  0.04154303);\\n    XYZ_RGB[2] = vec3( 0.05568392, -0.20417438,  1.05799454);\\n    \\n    float r = dot(XYZ_RGB[0], xyz);\\n    float g = dot(XYZ_RGB[1], xyz);\\n    float b = dot(XYZ_RGB[2], xyz);\\n\\n    return spectral_linear_to_srgb(vec3(r, g, b));\\n}\\n\\nvec3 spectral_reflectance_to_xyz(float R[SPECTRAL_SIZE]) {\\n    vec3 xyz = vec3(0.0);\\n    \\n    xyz +=  R[0] * vec3(0.00006469, 0.00000184, 0.00030502);\\n    xyz +=  R[1] * vec3(0.00021941, 0.00000621, 0.00103681);\\n    xyz +=  R[2] * vec3(0.00112057, 0.00003101, 0.00531314);\\n    xyz +=  R[3] * vec3(0.00376661, 0.00010475, 0.01795439);\\n    xyz +=  R[4] * vec3(0.01188055, 0.00035364, 0.05707758);\\n    xyz +=  R[5] * vec3(0.02328644, 0.00095147, 0.11365162);\\n    xyz +=  R[6] * vec3(0.03455942, 0.00228226, 0.17335873);\\n    xyz +=  R[7] * vec3(0.03722379, 0.00420733, 0.19620658);\\n    xyz +=  R[8] * vec3(0.03241838, 0.00668880, 0.18608237);\\n    xyz +=  R[9] * vec3(0.02123321, 0.00988840, 0.13995048);\\n    xyz += R[10] * vec3(0.01049099, 0.01524945, 0.08917453);\\n    xyz += R[11] * vec3(0.00329584, 0.02141831, 0.04789621);\\n    xyz += R[12] * vec3(0.00050704, 0.03342293, 0.02814563);\\n    xyz += R[13] * vec3(0.00094867, 0.05131001, 0.01613766);\\n    xyz += R[14] * vec3(0.00627372, 0.07040208, 0.00775910);\\n    xyz += R[15] * vec3(0.01686462, 0.08783871, 0.00429615);\\n    xyz += R[16] * vec3(0.02868965, 0.09424905, 0.00200551);\\n    xyz += R[17] * vec3(0.04267481, 0.09795667, 0.00086147);\\n    xyz += R[18] * vec3(0.05625475, 0.09415219, 0.00036904);\\n    xyz += R[19] * vec3(0.06947040, 0.08678102, 0.00019143);\\n    xyz += R[20] * vec3(0.08305315, 0.07885653, 0.00014956);\\n    xyz += R[21] * vec3(0.08612610, 0.06352670, 0.00009231);\\n    xyz += R[22] * vec3(0.09046614, 0.05374142, 0.00006813);\\n    xyz += R[23] * vec3(0.08500387, 0.04264606, 0.00002883);\\n    xyz += R[24] * vec3(0.07090667, 0.03161735, 0.00001577);\\n    xyz += R[25] * vec3(0.05062889, 0.02088521, 0.00000394);\\n    xyz += R[26] * vec3(0.03547396, 0.01386011, 0.00000158);\\n    xyz += R[27] * vec3(0.02146821, 0.00810264, 0.00000000);\\n    xyz += R[28] * vec3(0.01251646, 0.00463010, 0.00000000);\\n    xyz += R[29] * vec3(0.00680458, 0.00249138, 0.00000000);\\n    xyz += R[30] * vec3(0.00346457, 0.00125930, 0.00000000);\\n    xyz += R[31] * vec3(0.00149761, 0.00054165, 0.00000000);\\n    xyz += R[32] * vec3(0.00076970, 0.00027795, 0.00000000);\\n    xyz += R[33] * vec3(0.00040737, 0.00014711, 0.00000000);\\n    xyz += R[34] * vec3(0.00016901, 0.00006103, 0.00000000);\\n    xyz += R[35] * vec3(0.00009522, 0.00003439, 0.00000000);\\n    xyz += R[36] * vec3(0.00004903, 0.00001771, 0.00000000);\\n    xyz += R[37] * vec3(0.00002000, 0.00000722, 0.00000000);\\n\\n    return xyz;\\n}\\n\\nfloat spectral_linear_to_concentration(float l1, float l2, float t) {\\n    float t1 = l1 * pow(1.0 - t, 2.0);\\n    float t2 = l2 * pow(t, 2.0);\\n\\n    return t2 / (t1 + t2);\\n}\\n\\nvec3 spectral_mix(vec3 color1, vec3 color2, float t) {\\n    vec3 lrgb1 = spectral_srgb_to_linear(color1);\\n    vec3 lrgb2 = spectral_srgb_to_linear(color2);\\n\\n    float R1[SPECTRAL_SIZE];\\n    float R2[SPECTRAL_SIZE];\\n\\n    spectral_linear_to_reflectance(lrgb1, R1);\\n    spectral_linear_to_reflectance(lrgb2, R2);\\n\\n    float l1 = spectral_reflectance_to_xyz(R1)[1];\\n    float l2 = spectral_reflectance_to_xyz(R2)[1];\\n\\n    t = spectral_linear_to_concentration(l1, l2, t);\\n\\n    float R[SPECTRAL_SIZE];\\n\\n    for (int i = 0; i < SPECTRAL_SIZE; i++) {\\n      float KS = (1.0 - t) * (pow(1.0 - R1[i], 2.0) / (2.0 * R1[i])) + t * (pow(1.0 - R2[i], 2.0) / (2.0 * R2[i]));\\n      float KM = 1.0 + KS - sqrt(pow(KS, 2.0) + 2.0 * KS);\\n\\n      //Saunderson correction\\n      // let S = ((1.0 - K1) * (1.0 - K2) * KM) / (1.0 - K2 * KM);\\n\\n      R[i] = KM;\\n    }\\n\\n    return spectral_xyz_to_srgb(spectral_reflectance_to_xyz(R));\\n}\\n\\nvec4 spectral_mix(vec4 color1, vec4 color2, float t) {\\n    return vec4(spectral_mix(color1.rgb, color2.rgb, t), mix(color1.a, color2.a, t));\\n}\\n\\n#endif\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nvec4 blend_brushstroke(vec4 col, vec4 stroke, int blending_colour_space){\\n  // col.xyz = mix(col.xyz, stroke.xyz, stroke.w); \\n  \\n  int mode = blending_colour_space;\\n  \\n  if(stroke.w > 0.00000001){\\n    // float interpolant = stroke.w;\\n    stroke.xyz = stroke.xyz/max(stroke.w,0.001);\\n    \\n    if(mode == 0){\\n      col.xyz = spectral_mix(col.xyz, clamp(stroke.xyz,0.00001,0.99999), stroke.w);\\n      if(stroke.w > 0.99999)\\n        col.xyz = stroke.xyz;\\n    } else if(mode == 1){\\n      col.xyz = srgb_to_oklch( col.xyz );\\n      stroke.xyz = srgb_to_oklch( stroke.xyz );\\n      col.xy = mix(col.xy, stroke.xy,stroke.w);\\n      float tau = acos(-1.) * 2.;\\n      float h_a = stroke.z;\\n      float h_b = stroke.z + tau;\\n      float dist_a = abs(col.z - h_a);\\n      float dist_b = abs(col.z - h_b);\\n      if(dist_a < dist_b){\\n        col.z = mix(col.z, h_a, stroke.w);\\n      } else {\\n        col.z = mix(col.z, h_b, stroke.w);\\n      }\\n      col.z = mod(col.z, tau);\\n      // col.z = max(col.z)\\n      // if(isnan(col.z)){\\n      //   col.z = 1.;\\n      // }\\n\\n      col.xyz = oklch_to_srgb( col.xyz );\\n      col.xyz = clamp(col.xyz,0.,1.);\\n    \\n    } else {\\n      col.xyz = mix(col.xyz, stroke.xyz, stroke.w);\\n    }\\n    col.w = max(col.w, stroke.w);\\n  }\\n\\n  return col; \\n}\\n\\n// uniform float pong_idx;\\nuniform int amogus;\\nuniform int blending_colour_space;\\nin vec2 uv;\\nout vec4 col;\\nvoid main() {\\n  col = texture(canvas_a,uv);\\n  col.w = 1.;\\n\\n  vec4 temp_tex = texture(temp_tex,uv);\\n \\n  if(temp_tex.w > 0.000001)\\n    col = blend_brushstroke(col,temp_tex,blending_colour_space); \\n}      \";";

/***/ }),

/***/ 7529:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\nout vec2 uv;\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nvoid main(){\\n  uv = positions[gl_VertexID];\\n  uv = uv*0.5 + 0.5;\\n  gl_Position = vec4(positions[gl_VertexID],0,1);\\n}  \";";

/***/ }),

/***/ 6727:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\n#ifndef SPECTRAL\\n#define SPECTRAL\\n\\nconst int SPECTRAL_SIZE = 38;\\nconst float SPECTRAL_GAMMA = 2.4;\\nconst float SPECTRAL_EPSILON = 0.0001;\\n\\nfloat spectral_uncompand(float x) {\\n  return (x < 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, SPECTRAL_GAMMA);\\n}\\n\\nfloat spectral_compand(float x) {\\n  return (x < 0.0031308) ? x * 12.92 : 1.055 * pow(x, 1.0 / SPECTRAL_GAMMA) - 0.055;\\n}\\n\\nvec3 spectral_srgb_to_linear(vec3 srgb) {\\n    return vec3(spectral_uncompand(srgb[0]), spectral_uncompand(srgb[1]), spectral_uncompand(srgb[2]));\\n}\\n\\nvec3 spectral_linear_to_srgb(vec3 lrgb) {\\n    return clamp(vec3(spectral_compand(lrgb[0]), spectral_compand(lrgb[1]), spectral_compand(lrgb[2])), 0.0, 1.0);\\n}\\n\\nvoid spectral_upsampling(vec3 lrgb, out float w, out float c, out float m, out float y, out float r, out float g, out float b) {\\n    w = min(lrgb.r, min(lrgb.g, lrgb.b));\\n\\n    lrgb -= w;\\n\\n    c = min(lrgb.g, lrgb.b);\\n    m = min(lrgb.r, lrgb.b);\\n    y = min(lrgb.r, lrgb.g);\\n    r = min(max(0., lrgb.r - lrgb.b), max(0., lrgb.r - lrgb.g));\\n    g = min(max(0., lrgb.g - lrgb.b), max(0., lrgb.g - lrgb.r));\\n    b = min(max(0., lrgb.b - lrgb.g), max(0., lrgb.b - lrgb.r));\\n}\\n\\nvoid spectral_linear_to_reflectance(vec3 lrgb, inout float R[SPECTRAL_SIZE]) {\\n    float w, c, m, y, r, g, b;\\n    \\n    spectral_upsampling(lrgb, w, c, m, y, r, g, b);\\n    \\n     R[0] = max(SPECTRAL_EPSILON, w + c * 0.96853629 + m * 0.51567122 + y * 0.02055257 + r * 0.03147571 + g * 0.49108579 + b * 0.97901834);\\n     R[1] = max(SPECTRAL_EPSILON, w + c * 0.96855103 + m * 0.54015520 + y * 0.02059936 + r * 0.03146636 + g * 0.46944057 + b * 0.97901649);\\n     R[2] = max(SPECTRAL_EPSILON, w + c * 0.96859338 + m * 0.62645502 + y * 0.02062723 + r * 0.03140624 + g * 0.40165780 + b * 0.97901118);\\n     R[3] = max(SPECTRAL_EPSILON, w + c * 0.96877345 + m * 0.75595012 + y * 0.02073387 + r * 0.03119611 + g * 0.24490420 + b * 0.97892146);\\n     R[4] = max(SPECTRAL_EPSILON, w + c * 0.96942204 + m * 0.92826996 + y * 0.02114202 + r * 0.03053888 + g * 0.06826880 + b * 0.97858555);\\n     R[5] = max(SPECTRAL_EPSILON, w + c * 0.97143709 + m * 0.97223624 + y * 0.02233154 + r * 0.02856855 + g * 0.02732883 + b * 0.97743705);\\n     R[6] = max(SPECTRAL_EPSILON, w + c * 0.97541862 + m * 0.98616174 + y * 0.02556857 + r * 0.02459485 + g * 0.01360600 + b * 0.97428075);\\n     R[7] = max(SPECTRAL_EPSILON, w + c * 0.98074186 + m * 0.98955255 + y * 0.03330189 + r * 0.01929520 + g * 0.01000187 + b * 0.96663223);\\n     R[8] = max(SPECTRAL_EPSILON, w + c * 0.98580992 + m * 0.98676237 + y * 0.05185294 + r * 0.01423112 + g * 0.01284127 + b * 0.94822893);\\n     R[9] = max(SPECTRAL_EPSILON, w + c * 0.98971194 + m * 0.97312575 + y * 0.10087639 + r * 0.01033111 + g * 0.02636635 + b * 0.89937713);\\n    R[10] = max(SPECTRAL_EPSILON, w + c * 0.99238027 + m * 0.91944277 + y * 0.24000413 + r * 0.00765876 + g * 0.07058713 + b * 0.76070164);\\n    R[11] = max(SPECTRAL_EPSILON, w + c * 0.99409844 + m * 0.32564851 + y * 0.53589066 + r * 0.00593693 + g * 0.70421692 + b * 0.46420440);\\n    R[12] = max(SPECTRAL_EPSILON, w + c * 0.99517200 + m * 0.13820628 + y * 0.79874659 + r * 0.00485616 + g * 0.85473994 + b * 0.20123039);\\n    R[13] = max(SPECTRAL_EPSILON, w + c * 0.99576545 + m * 0.05015143 + y * 0.91186529 + r * 0.00426186 + g * 0.95081565 + b * 0.08808402);\\n    R[14] = max(SPECTRAL_EPSILON, w + c * 0.99593552 + m * 0.02912336 + y * 0.95399623 + r * 0.00409039 + g * 0.97170370 + b * 0.04592894);\\n    R[15] = max(SPECTRAL_EPSILON, w + c * 0.99564041 + m * 0.02421691 + y * 0.97137099 + r * 0.00438375 + g * 0.97651888 + b * 0.02860373);\\n    R[16] = max(SPECTRAL_EPSILON, w + c * 0.99464769 + m * 0.02660696 + y * 0.97939505 + r * 0.00537525 + g * 0.97429245 + b * 0.02060067);\\n    R[17] = max(SPECTRAL_EPSILON, w + c * 0.99229579 + m * 0.03407586 + y * 0.98345207 + r * 0.00772962 + g * 0.97012917 + b * 0.01656701);\\n    R[18] = max(SPECTRAL_EPSILON, w + c * 0.98638762 + m * 0.04835936 + y * 0.98553736 + r * 0.01366120 + g * 0.94258630 + b * 0.01451549);\\n    R[19] = max(SPECTRAL_EPSILON, w + c * 0.96829712 + m * 0.00011720 + y * 0.98648905 + r * 0.03181352 + g * 0.99989207 + b * 0.01357964);\\n    R[20] = max(SPECTRAL_EPSILON, w + c * 0.89228016 + m * 0.00008554 + y * 0.98674535 + r * 0.10791525 + g * 0.99989891 + b * 0.01331243);\\n    R[21] = max(SPECTRAL_EPSILON, w + c * 0.53740239 + m * 0.85267882 + y * 0.98657555 + r * 0.46249516 + g * 0.13823139 + b * 0.01347661);\\n    R[22] = max(SPECTRAL_EPSILON, w + c * 0.15360445 + m * 0.93188793 + y * 0.98611877 + r * 0.84604333 + g * 0.06968113 + b * 0.01387181);\\n    R[23] = max(SPECTRAL_EPSILON, w + c * 0.05705719 + m * 0.94810268 + y * 0.98559942 + r * 0.94275572 + g * 0.05628787 + b * 0.01435472);\\n    R[24] = max(SPECTRAL_EPSILON, w + c * 0.03126539 + m * 0.94200977 + y * 0.98507063 + r * 0.96860996 + g * 0.06111561 + b * 0.01479836);\\n    R[25] = max(SPECTRAL_EPSILON, w + c * 0.02205445 + m * 0.91478045 + y * 0.98460039 + r * 0.97783966 + g * 0.08987709 + b * 0.01515250);\\n    R[26] = max(SPECTRAL_EPSILON, w + c * 0.01802271 + m * 0.87065445 + y * 0.98425301 + r * 0.98187757 + g * 0.13656016 + b * 0.01540513);\\n    R[27] = max(SPECTRAL_EPSILON, w + c * 0.01613460 + m * 0.78827548 + y * 0.98403909 + r * 0.98377315 + g * 0.22169624 + b * 0.01557233);\\n    R[28] = max(SPECTRAL_EPSILON, w + c * 0.01520947 + m * 0.65738359 + y * 0.98388535 + r * 0.98470202 + g * 0.32176956 + b * 0.01565710);\\n    R[29] = max(SPECTRAL_EPSILON, w + c * 0.01475977 + m * 0.59909403 + y * 0.98376116 + r * 0.98515481 + g * 0.36157329 + b * 0.01571025);\\n    R[30] = max(SPECTRAL_EPSILON, w + c * 0.01454263 + m * 0.56817268 + y * 0.98368246 + r * 0.98537114 + g * 0.48361920 + b * 0.01571916);\\n    R[31] = max(SPECTRAL_EPSILON, w + c * 0.01444459 + m * 0.54031997 + y * 0.98365023 + r * 0.98546685 + g * 0.46488579 + b * 0.01572133);\\n    R[32] = max(SPECTRAL_EPSILON, w + c * 0.01439897 + m * 0.52110241 + y * 0.98361309 + r * 0.98550011 + g * 0.47440306 + b * 0.01572502);\\n    R[33] = max(SPECTRAL_EPSILON, w + c * 0.01437620 + m * 0.51041094 + y * 0.98357259 + r * 0.98551031 + g * 0.48576990 + b * 0.01571717);\\n    R[34] = max(SPECTRAL_EPSILON, w + c * 0.01436343 + m * 0.50526577 + y * 0.98353856 + r * 0.98550741 + g * 0.49267971 + b * 0.01571905);\\n    R[35] = max(SPECTRAL_EPSILON, w + c * 0.01435687 + m * 0.50255080 + y * 0.98351247 + r * 0.98551323 + g * 0.49625685 + b * 0.01571059);\\n    R[36] = max(SPECTRAL_EPSILON, w + c * 0.01435370 + m * 0.50126452 + y * 0.98350101 + r * 0.98551563 + g * 0.49807754 + b * 0.01569728);\\n    R[37] = max(SPECTRAL_EPSILON, w + c * 0.01435408 + m * 0.50083021 + y * 0.98350852 + r * 0.98551547 + g * 0.49889859 + b * 0.01570020);\\n}\\n\\nvec3 spectral_xyz_to_srgb(vec3 xyz) {\\n    mat3 XYZ_RGB;\\n\\n    XYZ_RGB[0] = vec3( 3.24306333, -1.53837619, -0.49893282);\\n    XYZ_RGB[1] = vec3(-0.96896309,  1.87542451,  0.04154303);\\n    XYZ_RGB[2] = vec3( 0.05568392, -0.20417438,  1.05799454);\\n    \\n    float r = dot(XYZ_RGB[0], xyz);\\n    float g = dot(XYZ_RGB[1], xyz);\\n    float b = dot(XYZ_RGB[2], xyz);\\n\\n    return spectral_linear_to_srgb(vec3(r, g, b));\\n}\\n\\nvec3 spectral_reflectance_to_xyz(float R[SPECTRAL_SIZE]) {\\n    vec3 xyz = vec3(0.0);\\n    \\n    xyz +=  R[0] * vec3(0.00006469, 0.00000184, 0.00030502);\\n    xyz +=  R[1] * vec3(0.00021941, 0.00000621, 0.00103681);\\n    xyz +=  R[2] * vec3(0.00112057, 0.00003101, 0.00531314);\\n    xyz +=  R[3] * vec3(0.00376661, 0.00010475, 0.01795439);\\n    xyz +=  R[4] * vec3(0.01188055, 0.00035364, 0.05707758);\\n    xyz +=  R[5] * vec3(0.02328644, 0.00095147, 0.11365162);\\n    xyz +=  R[6] * vec3(0.03455942, 0.00228226, 0.17335873);\\n    xyz +=  R[7] * vec3(0.03722379, 0.00420733, 0.19620658);\\n    xyz +=  R[8] * vec3(0.03241838, 0.00668880, 0.18608237);\\n    xyz +=  R[9] * vec3(0.02123321, 0.00988840, 0.13995048);\\n    xyz += R[10] * vec3(0.01049099, 0.01524945, 0.08917453);\\n    xyz += R[11] * vec3(0.00329584, 0.02141831, 0.04789621);\\n    xyz += R[12] * vec3(0.00050704, 0.03342293, 0.02814563);\\n    xyz += R[13] * vec3(0.00094867, 0.05131001, 0.01613766);\\n    xyz += R[14] * vec3(0.00627372, 0.07040208, 0.00775910);\\n    xyz += R[15] * vec3(0.01686462, 0.08783871, 0.00429615);\\n    xyz += R[16] * vec3(0.02868965, 0.09424905, 0.00200551);\\n    xyz += R[17] * vec3(0.04267481, 0.09795667, 0.00086147);\\n    xyz += R[18] * vec3(0.05625475, 0.09415219, 0.00036904);\\n    xyz += R[19] * vec3(0.06947040, 0.08678102, 0.00019143);\\n    xyz += R[20] * vec3(0.08305315, 0.07885653, 0.00014956);\\n    xyz += R[21] * vec3(0.08612610, 0.06352670, 0.00009231);\\n    xyz += R[22] * vec3(0.09046614, 0.05374142, 0.00006813);\\n    xyz += R[23] * vec3(0.08500387, 0.04264606, 0.00002883);\\n    xyz += R[24] * vec3(0.07090667, 0.03161735, 0.00001577);\\n    xyz += R[25] * vec3(0.05062889, 0.02088521, 0.00000394);\\n    xyz += R[26] * vec3(0.03547396, 0.01386011, 0.00000158);\\n    xyz += R[27] * vec3(0.02146821, 0.00810264, 0.00000000);\\n    xyz += R[28] * vec3(0.01251646, 0.00463010, 0.00000000);\\n    xyz += R[29] * vec3(0.00680458, 0.00249138, 0.00000000);\\n    xyz += R[30] * vec3(0.00346457, 0.00125930, 0.00000000);\\n    xyz += R[31] * vec3(0.00149761, 0.00054165, 0.00000000);\\n    xyz += R[32] * vec3(0.00076970, 0.00027795, 0.00000000);\\n    xyz += R[33] * vec3(0.00040737, 0.00014711, 0.00000000);\\n    xyz += R[34] * vec3(0.00016901, 0.00006103, 0.00000000);\\n    xyz += R[35] * vec3(0.00009522, 0.00003439, 0.00000000);\\n    xyz += R[36] * vec3(0.00004903, 0.00001771, 0.00000000);\\n    xyz += R[37] * vec3(0.00002000, 0.00000722, 0.00000000);\\n\\n    return xyz;\\n}\\n\\nfloat spectral_linear_to_concentration(float l1, float l2, float t) {\\n    float t1 = l1 * pow(1.0 - t, 2.0);\\n    float t2 = l2 * pow(t, 2.0);\\n\\n    return t2 / (t1 + t2);\\n}\\n\\nvec3 spectral_mix(vec3 color1, vec3 color2, float t) {\\n    vec3 lrgb1 = spectral_srgb_to_linear(color1);\\n    vec3 lrgb2 = spectral_srgb_to_linear(color2);\\n\\n    float R1[SPECTRAL_SIZE];\\n    float R2[SPECTRAL_SIZE];\\n\\n    spectral_linear_to_reflectance(lrgb1, R1);\\n    spectral_linear_to_reflectance(lrgb2, R2);\\n\\n    float l1 = spectral_reflectance_to_xyz(R1)[1];\\n    float l2 = spectral_reflectance_to_xyz(R2)[1];\\n\\n    t = spectral_linear_to_concentration(l1, l2, t);\\n\\n    float R[SPECTRAL_SIZE];\\n\\n    for (int i = 0; i < SPECTRAL_SIZE; i++) {\\n      float KS = (1.0 - t) * (pow(1.0 - R1[i], 2.0) / (2.0 * R1[i])) + t * (pow(1.0 - R2[i], 2.0) / (2.0 * R2[i]));\\n      float KM = 1.0 + KS - sqrt(pow(KS, 2.0) + 2.0 * KS);\\n\\n      //Saunderson correction\\n      // let S = ((1.0 - K1) * (1.0 - K2) * KM) / (1.0 - K2 * KM);\\n\\n      R[i] = KM;\\n    }\\n\\n    return spectral_xyz_to_srgb(spectral_reflectance_to_xyz(R));\\n}\\n\\nvec4 spectral_mix(vec4 color1, vec4 color2, float t) {\\n    return vec4(spectral_mix(color1.rgb, color2.rgb, t), mix(color1.a, color2.a, t));\\n}\\n\\n#endif\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nvec4 blend_brushstroke(vec4 col, vec4 stroke, int blending_colour_space){\\n  // col.xyz = mix(col.xyz, stroke.xyz, stroke.w); \\n  \\n  int mode = blending_colour_space;\\n  \\n  if(stroke.w > 0.00000001){\\n    // float interpolant = stroke.w;\\n    stroke.xyz = stroke.xyz/max(stroke.w,0.001);\\n    \\n    if(mode == 0){\\n      col.xyz = spectral_mix(col.xyz, clamp(stroke.xyz,0.00001,0.99999), stroke.w);\\n      if(stroke.w > 0.99999)\\n        col.xyz = stroke.xyz;\\n    } else if(mode == 1){\\n      col.xyz = srgb_to_oklch( col.xyz );\\n      stroke.xyz = srgb_to_oklch( stroke.xyz );\\n      col.xy = mix(col.xy, stroke.xy,stroke.w);\\n      float tau = acos(-1.) * 2.;\\n      float h_a = stroke.z;\\n      float h_b = stroke.z + tau;\\n      float dist_a = abs(col.z - h_a);\\n      float dist_b = abs(col.z - h_b);\\n      if(dist_a < dist_b){\\n        col.z = mix(col.z, h_a, stroke.w);\\n      } else {\\n        col.z = mix(col.z, h_b, stroke.w);\\n      }\\n      col.z = mod(col.z, tau);\\n      // col.z = max(col.z)\\n      // if(isnan(col.z)){\\n      //   col.z = 1.;\\n      // }\\n\\n      col.xyz = oklch_to_srgb( col.xyz );\\n      col.xyz = clamp(col.xyz,0.,1.);\\n    \\n    } else {\\n      col.xyz = mix(col.xyz, stroke.xyz, stroke.w);\\n    }\\n    col.w = max(col.w, stroke.w);\\n  }\\n\\n  return col; \\n}\\n\\n// uniform float pong_idx;\\nuniform int amogus;\\nuniform int blending_colour_space;\\nin vec2 uv;\\nout vec4 col;\\nvoid main() {\\n  col = texture(canvas_b,uv);\\n  col.w = 1.;\\n\\n  vec4 temp_tex = texture(temp_tex,uv);\\n \\n  if(temp_tex.w > 0.000001)\\n    col = blend_brushstroke(col,temp_tex,blending_colour_space); \\n}      \";";

/***/ }),

/***/ 3045:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nuint seed = 11425u;\\n\\nuint hash_u(uint _a) {\\n   uint a = _a;\\n   a ^= a >> 16;\\n   a *= 0x7feb352du;\\n   a ^= a >> 15;\\n   a *= 0x846ca68bu;\\n   a ^= a >> 16;\\n   return a; \\n }\\nfloat hash_f(){ uint s = hash_u(seed); seed = s;return ( float( s ) / float( 0xffffffffu ) ); }\\nvec2 hash_v2(){ return vec2(hash_f(), hash_f()); }\\nvec3 hash_v3(){ return vec3(hash_f(), hash_f(), hash_f()); }\\nvec4 hash_v4(){ return vec4(hash_f(), hash_f(), hash_f(), hash_f()); }\\n\\nfloat hash_f_s(uint s){ s = hash_u(s); return ( float( s ) / float( 0xffffffffu ) ); }\\n// vec2 hash_22_s(uvec2 s){ uint _s = hash_u(s.x) + hash_u(s.y); return vec2(hash_f_s(_s.x), hash_f_s(_s.y)); }\\nfloat hash_21_s(ivec2 _s_){ \\n  uvec2 s = uvec2(_s_);\\n  uint _s = hash_u(s.x + hash_u(s.y)) + hash_u(s.y + hash_u(s.x)); \\n  return hash_f_s(_s); \\n}\\n// vec3 hash_23_s(){ return vec3(hash_f_s(), hash_f_s(), hash_f_s()); }\\n// vec4 hash_24_s(){ return vec4(hash_f_s(), hash_f_s(), hash_f_s(), hash_f_s()); }\\n\\nfloat valueNoise( in vec2 p ){\\n    p += 100.;\\n    ivec2 i = ivec2(floor( p ));\\n    vec2 f = fract( p );\\n\\n    // cubic interpolant\\n    vec2 u = f*f*(3.0-2.0*f);\\n\\n    return mix( mix( hash_21_s( i + ivec2(0,0) ), \\n                     hash_21_s( i + ivec2(1,0) ), u.x),\\n                mix( hash_21_s( i + ivec2(0,1) ), \\n                     hash_21_s( i + ivec2(1,1) ), u.x), u.y);\\n}\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nuniform vec3 picked_col;\\n\\nin vec2 uv;\\nout vec4 col;\\nvoid main() {\\n  col.xyz = picked_col;\\n  \\n  vec2 u = uv;\\n  u = abs(u) - 0.8;\\n  float rect_sdf = max(u.x,u.y);\\n  if(rect_sdf >0.)\\n    col.xyz = vec3(1);\\n\\n  col.w = 1.;\\n}\";";

/***/ }),

/***/ 4950:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nuniform vec2 picker_pos;\\nout vec2 uv;\\nvoid main(){\\n  gl_Position = vec4(positions[gl_VertexID],0,1);\\n  uv = gl_Position.xy;\\n  gl_Position.xy *= ndc_aspect_correct(vec2(0.05), R);\\n  gl_Position.xy += picker_pos;\\n}\";";

/***/ }),

/***/ 2975:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\n#ifndef SPECTRAL\\n#define SPECTRAL\\n\\nconst int SPECTRAL_SIZE = 38;\\nconst float SPECTRAL_GAMMA = 2.4;\\nconst float SPECTRAL_EPSILON = 0.0001;\\n\\nfloat spectral_uncompand(float x) {\\n  return (x < 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, SPECTRAL_GAMMA);\\n}\\n\\nfloat spectral_compand(float x) {\\n  return (x < 0.0031308) ? x * 12.92 : 1.055 * pow(x, 1.0 / SPECTRAL_GAMMA) - 0.055;\\n}\\n\\nvec3 spectral_srgb_to_linear(vec3 srgb) {\\n    return vec3(spectral_uncompand(srgb[0]), spectral_uncompand(srgb[1]), spectral_uncompand(srgb[2]));\\n}\\n\\nvec3 spectral_linear_to_srgb(vec3 lrgb) {\\n    return clamp(vec3(spectral_compand(lrgb[0]), spectral_compand(lrgb[1]), spectral_compand(lrgb[2])), 0.0, 1.0);\\n}\\n\\nvoid spectral_upsampling(vec3 lrgb, out float w, out float c, out float m, out float y, out float r, out float g, out float b) {\\n    w = min(lrgb.r, min(lrgb.g, lrgb.b));\\n\\n    lrgb -= w;\\n\\n    c = min(lrgb.g, lrgb.b);\\n    m = min(lrgb.r, lrgb.b);\\n    y = min(lrgb.r, lrgb.g);\\n    r = min(max(0., lrgb.r - lrgb.b), max(0., lrgb.r - lrgb.g));\\n    g = min(max(0., lrgb.g - lrgb.b), max(0., lrgb.g - lrgb.r));\\n    b = min(max(0., lrgb.b - lrgb.g), max(0., lrgb.b - lrgb.r));\\n}\\n\\nvoid spectral_linear_to_reflectance(vec3 lrgb, inout float R[SPECTRAL_SIZE]) {\\n    float w, c, m, y, r, g, b;\\n    \\n    spectral_upsampling(lrgb, w, c, m, y, r, g, b);\\n    \\n     R[0] = max(SPECTRAL_EPSILON, w + c * 0.96853629 + m * 0.51567122 + y * 0.02055257 + r * 0.03147571 + g * 0.49108579 + b * 0.97901834);\\n     R[1] = max(SPECTRAL_EPSILON, w + c * 0.96855103 + m * 0.54015520 + y * 0.02059936 + r * 0.03146636 + g * 0.46944057 + b * 0.97901649);\\n     R[2] = max(SPECTRAL_EPSILON, w + c * 0.96859338 + m * 0.62645502 + y * 0.02062723 + r * 0.03140624 + g * 0.40165780 + b * 0.97901118);\\n     R[3] = max(SPECTRAL_EPSILON, w + c * 0.96877345 + m * 0.75595012 + y * 0.02073387 + r * 0.03119611 + g * 0.24490420 + b * 0.97892146);\\n     R[4] = max(SPECTRAL_EPSILON, w + c * 0.96942204 + m * 0.92826996 + y * 0.02114202 + r * 0.03053888 + g * 0.06826880 + b * 0.97858555);\\n     R[5] = max(SPECTRAL_EPSILON, w + c * 0.97143709 + m * 0.97223624 + y * 0.02233154 + r * 0.02856855 + g * 0.02732883 + b * 0.97743705);\\n     R[6] = max(SPECTRAL_EPSILON, w + c * 0.97541862 + m * 0.98616174 + y * 0.02556857 + r * 0.02459485 + g * 0.01360600 + b * 0.97428075);\\n     R[7] = max(SPECTRAL_EPSILON, w + c * 0.98074186 + m * 0.98955255 + y * 0.03330189 + r * 0.01929520 + g * 0.01000187 + b * 0.96663223);\\n     R[8] = max(SPECTRAL_EPSILON, w + c * 0.98580992 + m * 0.98676237 + y * 0.05185294 + r * 0.01423112 + g * 0.01284127 + b * 0.94822893);\\n     R[9] = max(SPECTRAL_EPSILON, w + c * 0.98971194 + m * 0.97312575 + y * 0.10087639 + r * 0.01033111 + g * 0.02636635 + b * 0.89937713);\\n    R[10] = max(SPECTRAL_EPSILON, w + c * 0.99238027 + m * 0.91944277 + y * 0.24000413 + r * 0.00765876 + g * 0.07058713 + b * 0.76070164);\\n    R[11] = max(SPECTRAL_EPSILON, w + c * 0.99409844 + m * 0.32564851 + y * 0.53589066 + r * 0.00593693 + g * 0.70421692 + b * 0.46420440);\\n    R[12] = max(SPECTRAL_EPSILON, w + c * 0.99517200 + m * 0.13820628 + y * 0.79874659 + r * 0.00485616 + g * 0.85473994 + b * 0.20123039);\\n    R[13] = max(SPECTRAL_EPSILON, w + c * 0.99576545 + m * 0.05015143 + y * 0.91186529 + r * 0.00426186 + g * 0.95081565 + b * 0.08808402);\\n    R[14] = max(SPECTRAL_EPSILON, w + c * 0.99593552 + m * 0.02912336 + y * 0.95399623 + r * 0.00409039 + g * 0.97170370 + b * 0.04592894);\\n    R[15] = max(SPECTRAL_EPSILON, w + c * 0.99564041 + m * 0.02421691 + y * 0.97137099 + r * 0.00438375 + g * 0.97651888 + b * 0.02860373);\\n    R[16] = max(SPECTRAL_EPSILON, w + c * 0.99464769 + m * 0.02660696 + y * 0.97939505 + r * 0.00537525 + g * 0.97429245 + b * 0.02060067);\\n    R[17] = max(SPECTRAL_EPSILON, w + c * 0.99229579 + m * 0.03407586 + y * 0.98345207 + r * 0.00772962 + g * 0.97012917 + b * 0.01656701);\\n    R[18] = max(SPECTRAL_EPSILON, w + c * 0.98638762 + m * 0.04835936 + y * 0.98553736 + r * 0.01366120 + g * 0.94258630 + b * 0.01451549);\\n    R[19] = max(SPECTRAL_EPSILON, w + c * 0.96829712 + m * 0.00011720 + y * 0.98648905 + r * 0.03181352 + g * 0.99989207 + b * 0.01357964);\\n    R[20] = max(SPECTRAL_EPSILON, w + c * 0.89228016 + m * 0.00008554 + y * 0.98674535 + r * 0.10791525 + g * 0.99989891 + b * 0.01331243);\\n    R[21] = max(SPECTRAL_EPSILON, w + c * 0.53740239 + m * 0.85267882 + y * 0.98657555 + r * 0.46249516 + g * 0.13823139 + b * 0.01347661);\\n    R[22] = max(SPECTRAL_EPSILON, w + c * 0.15360445 + m * 0.93188793 + y * 0.98611877 + r * 0.84604333 + g * 0.06968113 + b * 0.01387181);\\n    R[23] = max(SPECTRAL_EPSILON, w + c * 0.05705719 + m * 0.94810268 + y * 0.98559942 + r * 0.94275572 + g * 0.05628787 + b * 0.01435472);\\n    R[24] = max(SPECTRAL_EPSILON, w + c * 0.03126539 + m * 0.94200977 + y * 0.98507063 + r * 0.96860996 + g * 0.06111561 + b * 0.01479836);\\n    R[25] = max(SPECTRAL_EPSILON, w + c * 0.02205445 + m * 0.91478045 + y * 0.98460039 + r * 0.97783966 + g * 0.08987709 + b * 0.01515250);\\n    R[26] = max(SPECTRAL_EPSILON, w + c * 0.01802271 + m * 0.87065445 + y * 0.98425301 + r * 0.98187757 + g * 0.13656016 + b * 0.01540513);\\n    R[27] = max(SPECTRAL_EPSILON, w + c * 0.01613460 + m * 0.78827548 + y * 0.98403909 + r * 0.98377315 + g * 0.22169624 + b * 0.01557233);\\n    R[28] = max(SPECTRAL_EPSILON, w + c * 0.01520947 + m * 0.65738359 + y * 0.98388535 + r * 0.98470202 + g * 0.32176956 + b * 0.01565710);\\n    R[29] = max(SPECTRAL_EPSILON, w + c * 0.01475977 + m * 0.59909403 + y * 0.98376116 + r * 0.98515481 + g * 0.36157329 + b * 0.01571025);\\n    R[30] = max(SPECTRAL_EPSILON, w + c * 0.01454263 + m * 0.56817268 + y * 0.98368246 + r * 0.98537114 + g * 0.48361920 + b * 0.01571916);\\n    R[31] = max(SPECTRAL_EPSILON, w + c * 0.01444459 + m * 0.54031997 + y * 0.98365023 + r * 0.98546685 + g * 0.46488579 + b * 0.01572133);\\n    R[32] = max(SPECTRAL_EPSILON, w + c * 0.01439897 + m * 0.52110241 + y * 0.98361309 + r * 0.98550011 + g * 0.47440306 + b * 0.01572502);\\n    R[33] = max(SPECTRAL_EPSILON, w + c * 0.01437620 + m * 0.51041094 + y * 0.98357259 + r * 0.98551031 + g * 0.48576990 + b * 0.01571717);\\n    R[34] = max(SPECTRAL_EPSILON, w + c * 0.01436343 + m * 0.50526577 + y * 0.98353856 + r * 0.98550741 + g * 0.49267971 + b * 0.01571905);\\n    R[35] = max(SPECTRAL_EPSILON, w + c * 0.01435687 + m * 0.50255080 + y * 0.98351247 + r * 0.98551323 + g * 0.49625685 + b * 0.01571059);\\n    R[36] = max(SPECTRAL_EPSILON, w + c * 0.01435370 + m * 0.50126452 + y * 0.98350101 + r * 0.98551563 + g * 0.49807754 + b * 0.01569728);\\n    R[37] = max(SPECTRAL_EPSILON, w + c * 0.01435408 + m * 0.50083021 + y * 0.98350852 + r * 0.98551547 + g * 0.49889859 + b * 0.01570020);\\n}\\n\\nvec3 spectral_xyz_to_srgb(vec3 xyz) {\\n    mat3 XYZ_RGB;\\n\\n    XYZ_RGB[0] = vec3( 3.24306333, -1.53837619, -0.49893282);\\n    XYZ_RGB[1] = vec3(-0.96896309,  1.87542451,  0.04154303);\\n    XYZ_RGB[2] = vec3( 0.05568392, -0.20417438,  1.05799454);\\n    \\n    float r = dot(XYZ_RGB[0], xyz);\\n    float g = dot(XYZ_RGB[1], xyz);\\n    float b = dot(XYZ_RGB[2], xyz);\\n\\n    return spectral_linear_to_srgb(vec3(r, g, b));\\n}\\n\\nvec3 spectral_reflectance_to_xyz(float R[SPECTRAL_SIZE]) {\\n    vec3 xyz = vec3(0.0);\\n    \\n    xyz +=  R[0] * vec3(0.00006469, 0.00000184, 0.00030502);\\n    xyz +=  R[1] * vec3(0.00021941, 0.00000621, 0.00103681);\\n    xyz +=  R[2] * vec3(0.00112057, 0.00003101, 0.00531314);\\n    xyz +=  R[3] * vec3(0.00376661, 0.00010475, 0.01795439);\\n    xyz +=  R[4] * vec3(0.01188055, 0.00035364, 0.05707758);\\n    xyz +=  R[5] * vec3(0.02328644, 0.00095147, 0.11365162);\\n    xyz +=  R[6] * vec3(0.03455942, 0.00228226, 0.17335873);\\n    xyz +=  R[7] * vec3(0.03722379, 0.00420733, 0.19620658);\\n    xyz +=  R[8] * vec3(0.03241838, 0.00668880, 0.18608237);\\n    xyz +=  R[9] * vec3(0.02123321, 0.00988840, 0.13995048);\\n    xyz += R[10] * vec3(0.01049099, 0.01524945, 0.08917453);\\n    xyz += R[11] * vec3(0.00329584, 0.02141831, 0.04789621);\\n    xyz += R[12] * vec3(0.00050704, 0.03342293, 0.02814563);\\n    xyz += R[13] * vec3(0.00094867, 0.05131001, 0.01613766);\\n    xyz += R[14] * vec3(0.00627372, 0.07040208, 0.00775910);\\n    xyz += R[15] * vec3(0.01686462, 0.08783871, 0.00429615);\\n    xyz += R[16] * vec3(0.02868965, 0.09424905, 0.00200551);\\n    xyz += R[17] * vec3(0.04267481, 0.09795667, 0.00086147);\\n    xyz += R[18] * vec3(0.05625475, 0.09415219, 0.00036904);\\n    xyz += R[19] * vec3(0.06947040, 0.08678102, 0.00019143);\\n    xyz += R[20] * vec3(0.08305315, 0.07885653, 0.00014956);\\n    xyz += R[21] * vec3(0.08612610, 0.06352670, 0.00009231);\\n    xyz += R[22] * vec3(0.09046614, 0.05374142, 0.00006813);\\n    xyz += R[23] * vec3(0.08500387, 0.04264606, 0.00002883);\\n    xyz += R[24] * vec3(0.07090667, 0.03161735, 0.00001577);\\n    xyz += R[25] * vec3(0.05062889, 0.02088521, 0.00000394);\\n    xyz += R[26] * vec3(0.03547396, 0.01386011, 0.00000158);\\n    xyz += R[27] * vec3(0.02146821, 0.00810264, 0.00000000);\\n    xyz += R[28] * vec3(0.01251646, 0.00463010, 0.00000000);\\n    xyz += R[29] * vec3(0.00680458, 0.00249138, 0.00000000);\\n    xyz += R[30] * vec3(0.00346457, 0.00125930, 0.00000000);\\n    xyz += R[31] * vec3(0.00149761, 0.00054165, 0.00000000);\\n    xyz += R[32] * vec3(0.00076970, 0.00027795, 0.00000000);\\n    xyz += R[33] * vec3(0.00040737, 0.00014711, 0.00000000);\\n    xyz += R[34] * vec3(0.00016901, 0.00006103, 0.00000000);\\n    xyz += R[35] * vec3(0.00009522, 0.00003439, 0.00000000);\\n    xyz += R[36] * vec3(0.00004903, 0.00001771, 0.00000000);\\n    xyz += R[37] * vec3(0.00002000, 0.00000722, 0.00000000);\\n\\n    return xyz;\\n}\\n\\nfloat spectral_linear_to_concentration(float l1, float l2, float t) {\\n    float t1 = l1 * pow(1.0 - t, 2.0);\\n    float t2 = l2 * pow(t, 2.0);\\n\\n    return t2 / (t1 + t2);\\n}\\n\\nvec3 spectral_mix(vec3 color1, vec3 color2, float t) {\\n    vec3 lrgb1 = spectral_srgb_to_linear(color1);\\n    vec3 lrgb2 = spectral_srgb_to_linear(color2);\\n\\n    float R1[SPECTRAL_SIZE];\\n    float R2[SPECTRAL_SIZE];\\n\\n    spectral_linear_to_reflectance(lrgb1, R1);\\n    spectral_linear_to_reflectance(lrgb2, R2);\\n\\n    float l1 = spectral_reflectance_to_xyz(R1)[1];\\n    float l2 = spectral_reflectance_to_xyz(R2)[1];\\n\\n    t = spectral_linear_to_concentration(l1, l2, t);\\n\\n    float R[SPECTRAL_SIZE];\\n\\n    for (int i = 0; i < SPECTRAL_SIZE; i++) {\\n      float KS = (1.0 - t) * (pow(1.0 - R1[i], 2.0) / (2.0 * R1[i])) + t * (pow(1.0 - R2[i], 2.0) / (2.0 * R2[i]));\\n      float KM = 1.0 + KS - sqrt(pow(KS, 2.0) + 2.0 * KS);\\n\\n      //Saunderson correction\\n      // let S = ((1.0 - K1) * (1.0 - K2) * KM) / (1.0 - K2 * KM);\\n\\n      R[i] = KM;\\n    }\\n\\n    return spectral_xyz_to_srgb(spectral_reflectance_to_xyz(R));\\n}\\n\\nvec4 spectral_mix(vec4 color1, vec4 color2, float t) {\\n    return vec4(spectral_mix(color1.rgb, color2.rgb, t), mix(color1.a, color2.a, t));\\n}\\n\\n#endif\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nvec4 blend_brushstroke(vec4 col, vec4 stroke, int blending_colour_space){\\n  // col.xyz = mix(col.xyz, stroke.xyz, stroke.w); \\n  \\n  int mode = blending_colour_space;\\n  \\n  if(stroke.w > 0.00000001){\\n    // float interpolant = stroke.w;\\n    stroke.xyz = stroke.xyz/max(stroke.w,0.001);\\n    \\n    if(mode == 0){\\n      col.xyz = spectral_mix(col.xyz, clamp(stroke.xyz,0.00001,0.99999), stroke.w);\\n      if(stroke.w > 0.99999)\\n        col.xyz = stroke.xyz;\\n    } else if(mode == 1){\\n      col.xyz = srgb_to_oklch( col.xyz );\\n      stroke.xyz = srgb_to_oklch( stroke.xyz );\\n      col.xy = mix(col.xy, stroke.xy,stroke.w);\\n      float tau = acos(-1.) * 2.;\\n      float h_a = stroke.z;\\n      float h_b = stroke.z + tau;\\n      float dist_a = abs(col.z - h_a);\\n      float dist_b = abs(col.z - h_b);\\n      if(dist_a < dist_b){\\n        col.z = mix(col.z, h_a, stroke.w);\\n      } else {\\n        col.z = mix(col.z, h_b, stroke.w);\\n      }\\n      col.z = mod(col.z, tau);\\n      // col.z = max(col.z)\\n      // if(isnan(col.z)){\\n      //   col.z = 1.;\\n      // }\\n\\n      col.xyz = oklch_to_srgb( col.xyz );\\n      col.xyz = clamp(col.xyz,0.,1.);\\n    \\n    } else {\\n      col.xyz = mix(col.xyz, stroke.xyz, stroke.w);\\n    }\\n    col.w = max(col.w, stroke.w);\\n  }\\n\\n  return col; \\n}\\n\\nuniform int blending_colour_space;\\nin vec2 uv;\\nout vec4 col;\\n\\nvec4 sample_tex_mobile(sampler2D tex, vec2 fruv, ivec2 ifuv){\\n  ivec3 st = ivec3(1,1,0);\\n  return mix(\\n    mix(\\n      texelFetch(tex,ifuv,0),\\n      texelFetch(tex,ifuv + st.xz,0),\\n      // smoothstep(0.,1.,fruv.x)\\n      fruv.x\\n    ),\\n    mix(\\n      texelFetch(tex,ifuv + st.zy,0),\\n      texelFetch(tex,ifuv + st.xy,0),\\n      // smoothstep(0.,1.,fruv.x)\\n      fruv.x\\n    ),\\n    // smoothstep(0.,1.,fruv.y)\\n    fruv.y\\n  );\\n}\\nvec4 sample_tex_desktop(sampler2D tex, vec2 uv){\\n\\n    vec2 dx = dFdx(uv.xy);\\n    vec2 dy = dFdy(uv.xy);\\n\\n    vec2 textureRes = vec2(textureSize(tex,0));\\n\\n    dx *= clamp( 0.5 * log2(dot(dx * textureRes, dx * textureRes)), 0., 1.);\\n    dy *= clamp( 0.5 * log2(dot(dy * textureRes, dy * textureRes)), 0., 1.);\\n\\n    float _Bias = -1.;\\n    vec2 uvOffsets = vec2(0.125, 0.375);\\n    vec2 offsetUV = vec2(0.0, 0.0);\\n    \\n    vec4 col = vec4(0);\\n    // supersampled using 2x2 rotated grid\\n    // half4 col = 0;\\n    offsetUV.xy = uv.xy + uvOffsets.x * dx + uvOffsets.y * dy;\\n    col += texture(tex, offsetUV, _Bias);\\n    offsetUV.xy = uv.xy - uvOffsets.x * dx - uvOffsets.y * dy;\\n    col += texture(tex, offsetUV, _Bias);\\n    offsetUV.xy = uv.xy + uvOffsets.y * dx - uvOffsets.x * dy;\\n    col += texture(tex, offsetUV, _Bias);\\n    offsetUV.xy = uv.xy - uvOffsets.y * dx + uvOffsets.x * dy;\\n    col += texture(tex, offsetUV, _Bias);\\n    col *= 0.25;\\n    return col;\\n}\\nvoid main() {\\n  col = vec4(1);\\n  \\n  vec4 _temp_tex;\\n  \\n  if(is_on_mobile > 0.5){\\n    ivec2 ifuv = ivec2(uv*canvasR);\\n    vec2 fruv = fract(uv*canvasR);\\n\\n    col.xyz = sample_tex_mobile(canvas_back, fruv, ifuv).xyz;\\n    _temp_tex = sample_tex_mobile(temp_tex, fruv, ifuv);\\n  } else {\\n    col.xyz = sample_tex_desktop(canvas_back,uv).xyz;\\n    // col.xyz = texture(canvas_back, uv).xyz;\\n    // _temp_tex = texture(temp_tex, uv);    \\n\\n    ivec2 ifuv = ivec2(uv*canvasR);\\n    vec2 fruv = fract(uv*canvasR);\\n\\n    // _temp_tex = sample_tex_desktop(temp_tex,uv);\\n    // _temp_tex = texelFetch(temp_tex,ivec2(uv*canvasR),0);\\n    _temp_tex = texture(temp_tex,uv);\\n\\n    // _temp_tex = sample_tex_mobile(temp_tex, fruv, ifuv);    \\n  }\\n\\n  // // if(temp_tex.w > 0.)\\n  if(_temp_tex.w > 0.0)\\n    col = blend_brushstroke(\\n      col,\\n      _temp_tex,\\n      blending_colour_space\\n    );\\n \\n    \\n  col = pow(col,vec4(0.454545454545)); \\n  col.w = 1.;\\n}    \\n\\n  \\n  \\n\\t\\t \";";

/***/ }),

/***/ 2199:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 canvasR;\\n  vec2 R;\\n  float time;\\n  float canvas_idx;\\n  float is_on_mobile;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\nout vec2 uv;\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nuniform float zoom;\\nuniform vec2 panning;\\nvoid main(){\\n  uv = positions[gl_VertexID];\\n  uv = uv*0.5 + 0.5;\\n\\n  gl_Position = vec4(positions[gl_VertexID],0,1);\\n  gl_Position.xy += panning/css_contain(vec2(1), canvasR, R);\\n  gl_Position.xy = css_contain(gl_Position.xy, canvasR, R);\\n  gl_Position.xy *= zoom;\\n}  \\n\\t\\t\\t\\n\";";

/***/ }),

/***/ 8090:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 2974:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 6302:
/***/ (function(module) {

/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */

(function (global, factory) {
     true ? module.exports = factory() :
    0;
})(this, (function () { 'use strict';

    var limit$2 = function (x, min, max) {
        if ( min === void 0 ) min=0;
        if ( max === void 0 ) max=1;

        return x < min ? min : x > max ? max : x;
    };

    var limit$1 = limit$2;

    var clip_rgb$3 = function (rgb) {
        rgb._clipped = false;
        rgb._unclipped = rgb.slice(0);
        for (var i=0; i<=3; i++) {
            if (i < 3) {
                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }
                rgb[i] = limit$1(rgb[i], 0, 255);
            } else if (i === 3) {
                rgb[i] = limit$1(rgb[i], 0, 1);
            }
        }
        return rgb;
    };

    // ported from jQuery's $.type
    var classToType = {};
    for (var i$1 = 0, list$1 = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i$1 < list$1.length; i$1 += 1) {
        var name = list$1[i$1];

        classToType[("[object " + name + "]")] = name.toLowerCase();
    }
    var type$p = function(obj) {
        return classToType[Object.prototype.toString.call(obj)] || "object";
    };

    var type$o = type$p;

    var unpack$B = function (args, keyOrder) {
        if ( keyOrder === void 0 ) keyOrder=null;

    	// if called with more than 3 arguments, we return the arguments
        if (args.length >= 3) { return Array.prototype.slice.call(args); }
        // with less than 3 args we check if first arg is object
        // and use the keyOrder string to extract and sort properties
    	if (type$o(args[0]) == 'object' && keyOrder) {
    		return keyOrder.split('')
    			.filter(function (k) { return args[0][k] !== undefined; })
    			.map(function (k) { return args[0][k]; });
    	}
    	// otherwise we just return the first argument
    	// (which we suppose is an array of args)
        return args[0];
    };

    var type$n = type$p;

    var last$4 = function (args) {
        if (args.length < 2) { return null; }
        var l = args.length-1;
        if (type$n(args[l]) == 'string') { return args[l].toLowerCase(); }
        return null;
    };

    var PI$2 = Math.PI;

    var utils = {
    	clip_rgb: clip_rgb$3,
    	limit: limit$2,
    	type: type$p,
    	unpack: unpack$B,
    	last: last$4,
    	PI: PI$2,
    	TWOPI: PI$2*2,
    	PITHIRD: PI$2/3,
    	DEG2RAD: PI$2 / 180,
    	RAD2DEG: 180 / PI$2
    };

    var input$h = {
    	format: {},
    	autodetect: []
    };

    var last$3 = utils.last;
    var clip_rgb$2 = utils.clip_rgb;
    var type$m = utils.type;
    var _input = input$h;

    var Color$D = function Color() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var me = this;
        if (type$m(args[0]) === 'object' &&
            args[0].constructor &&
            args[0].constructor === this.constructor) {
            // the argument is already a Color instance
            return args[0];
        }

        // last argument could be the mode
        var mode = last$3(args);
        var autodetect = false;

        if (!mode) {
            autodetect = true;
            if (!_input.sorted) {
                _input.autodetect = _input.autodetect.sort(function (a,b) { return b.p - a.p; });
                _input.sorted = true;
            }
            // auto-detect format
            for (var i = 0, list = _input.autodetect; i < list.length; i += 1) {
                var chk = list[i];

                mode = chk.test.apply(chk, args);
                if (mode) { break; }
            }
        }

        if (_input.format[mode]) {
            var rgb = _input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));
            me._rgb = clip_rgb$2(rgb);
        } else {
            throw new Error('unknown format: '+args);
        }

        // add alpha channel
        if (me._rgb.length === 3) { me._rgb.push(1); }
    };

    Color$D.prototype.toString = function toString () {
        if (type$m(this.hex) == 'function') { return this.hex(); }
        return ("[" + (this._rgb.join(',')) + "]");
    };

    var Color_1 = Color$D;

    var chroma$k = function () {
    	var args = [], len = arguments.length;
    	while ( len-- ) args[ len ] = arguments[ len ];

    	return new (Function.prototype.bind.apply( chroma$k.Color, [ null ].concat( args) ));
    };

    chroma$k.Color = Color_1;
    chroma$k.version = '2.4.2';

    var chroma_1 = chroma$k;

    var unpack$A = utils.unpack;
    var max$2 = Math.max;

    var rgb2cmyk$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$A(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r = r / 255;
        g = g / 255;
        b = b / 255;
        var k = 1 - max$2(r,max$2(g,b));
        var f = k < 1 ? 1 / (1-k) : 0;
        var c = (1-r-k) * f;
        var m = (1-g-k) * f;
        var y = (1-b-k) * f;
        return [c,m,y,k];
    };

    var rgb2cmyk_1 = rgb2cmyk$1;

    var unpack$z = utils.unpack;

    var cmyk2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$z(args, 'cmyk');
        var c = args[0];
        var m = args[1];
        var y = args[2];
        var k = args[3];
        var alpha = args.length > 4 ? args[4] : 1;
        if (k === 1) { return [0,0,0,alpha]; }
        return [
            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r
            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g
            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b
            alpha
        ];
    };

    var cmyk2rgb_1 = cmyk2rgb;

    var chroma$j = chroma_1;
    var Color$C = Color_1;
    var input$g = input$h;
    var unpack$y = utils.unpack;
    var type$l = utils.type;

    var rgb2cmyk = rgb2cmyk_1;

    Color$C.prototype.cmyk = function() {
        return rgb2cmyk(this._rgb);
    };

    chroma$j.cmyk = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$C, [ null ].concat( args, ['cmyk']) ));
    };

    input$g.format.cmyk = cmyk2rgb_1;

    input$g.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$y(args, 'cmyk');
            if (type$l(args) === 'array' && args.length === 4) {
                return 'cmyk';
            }
        }
    });

    var unpack$x = utils.unpack;
    var last$2 = utils.last;
    var rnd = function (a) { return Math.round(a*100)/100; };

    /*
     * supported arguments:
     * - hsl2css(h,s,l)
     * - hsl2css(h,s,l,a)
     * - hsl2css([h,s,l], mode)
     * - hsl2css([h,s,l,a], mode)
     * - hsl2css({h,s,l,a}, mode)
     */
    var hsl2css$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hsla = unpack$x(args, 'hsla');
        var mode = last$2(args) || 'lsa';
        hsla[0] = rnd(hsla[0] || 0);
        hsla[1] = rnd(hsla[1]*100) + '%';
        hsla[2] = rnd(hsla[2]*100) + '%';
        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {
            hsla[3] = hsla.length > 3 ? hsla[3] : 1;
            mode = 'hsla';
        } else {
            hsla.length = 3;
        }
        return (mode + "(" + (hsla.join(',')) + ")");
    };

    var hsl2css_1 = hsl2css$1;

    var unpack$w = utils.unpack;

    /*
     * supported arguments:
     * - rgb2hsl(r,g,b)
     * - rgb2hsl(r,g,b,a)
     * - rgb2hsl([r,g,b])
     * - rgb2hsl([r,g,b,a])
     * - rgb2hsl({r,g,b,a})
     */
    var rgb2hsl$3 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$w(args, 'rgba');
        var r = args[0];
        var g = args[1];
        var b = args[2];

        r /= 255;
        g /= 255;
        b /= 255;

        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);

        var l = (max + min) / 2;
        var s, h;

        if (max === min){
            s = 0;
            h = Number.NaN;
        } else {
            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
        }

        if (r == max) { h = (g - b) / (max - min); }
        else if (g == max) { h = 2 + (b - r) / (max - min); }
        else if (b == max) { h = 4 + (r - g) / (max - min); }

        h *= 60;
        if (h < 0) { h += 360; }
        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }
        return [h,s,l];
    };

    var rgb2hsl_1 = rgb2hsl$3;

    var unpack$v = utils.unpack;
    var last$1 = utils.last;
    var hsl2css = hsl2css_1;
    var rgb2hsl$2 = rgb2hsl_1;
    var round$6 = Math.round;

    /*
     * supported arguments:
     * - rgb2css(r,g,b)
     * - rgb2css(r,g,b,a)
     * - rgb2css([r,g,b], mode)
     * - rgb2css([r,g,b,a], mode)
     * - rgb2css({r,g,b,a}, mode)
     */
    var rgb2css$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$v(args, 'rgba');
        var mode = last$1(args) || 'rgb';
        if (mode.substr(0,3) == 'hsl') {
            return hsl2css(rgb2hsl$2(rgba), mode);
        }
        rgba[0] = round$6(rgba[0]);
        rgba[1] = round$6(rgba[1]);
        rgba[2] = round$6(rgba[2]);
        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {
            rgba[3] = rgba.length > 3 ? rgba[3] : 1;
            mode = 'rgba';
        }
        return (mode + "(" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + ")");
    };

    var rgb2css_1 = rgb2css$1;

    var unpack$u = utils.unpack;
    var round$5 = Math.round;

    var hsl2rgb$1 = function () {
        var assign;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$u(args, 'hsl');
        var h = args[0];
        var s = args[1];
        var l = args[2];
        var r,g,b;
        if (s === 0) {
            r = g = b = l*255;
        } else {
            var t3 = [0,0,0];
            var c = [0,0,0];
            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;
            var t1 = 2 * l - t2;
            var h_ = h / 360;
            t3[0] = h_ + 1/3;
            t3[1] = h_;
            t3[2] = h_ - 1/3;
            for (var i=0; i<3; i++) {
                if (t3[i] < 0) { t3[i] += 1; }
                if (t3[i] > 1) { t3[i] -= 1; }
                if (6 * t3[i] < 1)
                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }
                else if (2 * t3[i] < 1)
                    { c[i] = t2; }
                else if (3 * t3[i] < 2)
                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }
                else
                    { c[i] = t1; }
            }
            (assign = [round$5(c[0]*255),round$5(c[1]*255),round$5(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);
        }
        if (args.length > 3) {
            // keep alpha channel
            return [r,g,b,args[3]];
        }
        return [r,g,b,1];
    };

    var hsl2rgb_1 = hsl2rgb$1;

    var hsl2rgb = hsl2rgb_1;
    var input$f = input$h;

    var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
    var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;

    var round$4 = Math.round;

    var css2rgb$1 = function (css) {
        css = css.toLowerCase().trim();
        var m;

        if (input$f.format.named) {
            try {
                return input$f.format.named(css);
            } catch (e) {
                // eslint-disable-next-line
            }
        }

        // rgb(250,20,0)
        if ((m = css.match(RE_RGB))) {
            var rgb = m.slice(1,4);
            for (var i=0; i<3; i++) {
                rgb[i] = +rgb[i];
            }
            rgb[3] = 1;  // default alpha
            return rgb;
        }

        // rgba(250,20,0,0.4)
        if ((m = css.match(RE_RGBA))) {
            var rgb$1 = m.slice(1,5);
            for (var i$1=0; i$1<4; i$1++) {
                rgb$1[i$1] = +rgb$1[i$1];
            }
            return rgb$1;
        }

        // rgb(100%,0%,0%)
        if ((m = css.match(RE_RGB_PCT))) {
            var rgb$2 = m.slice(1,4);
            for (var i$2=0; i$2<3; i$2++) {
                rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
            }
            rgb$2[3] = 1;  // default alpha
            return rgb$2;
        }

        // rgba(100%,0%,0%,0.4)
        if ((m = css.match(RE_RGBA_PCT))) {
            var rgb$3 = m.slice(1,5);
            for (var i$3=0; i$3<3; i$3++) {
                rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
            }
            rgb$3[3] = +rgb$3[3];
            return rgb$3;
        }

        // hsl(0,100%,50%)
        if ((m = css.match(RE_HSL))) {
            var hsl = m.slice(1,4);
            hsl[1] *= 0.01;
            hsl[2] *= 0.01;
            var rgb$4 = hsl2rgb(hsl);
            rgb$4[3] = 1;
            return rgb$4;
        }

        // hsla(0,100%,50%,0.5)
        if ((m = css.match(RE_HSLA))) {
            var hsl$1 = m.slice(1,4);
            hsl$1[1] *= 0.01;
            hsl$1[2] *= 0.01;
            var rgb$5 = hsl2rgb(hsl$1);
            rgb$5[3] = +m[4];  // default alpha = 1
            return rgb$5;
        }
    };

    css2rgb$1.test = function (s) {
        return RE_RGB.test(s) ||
            RE_RGBA.test(s) ||
            RE_RGB_PCT.test(s) ||
            RE_RGBA_PCT.test(s) ||
            RE_HSL.test(s) ||
            RE_HSLA.test(s);
    };

    var css2rgb_1 = css2rgb$1;

    var chroma$i = chroma_1;
    var Color$B = Color_1;
    var input$e = input$h;
    var type$k = utils.type;

    var rgb2css = rgb2css_1;
    var css2rgb = css2rgb_1;

    Color$B.prototype.css = function(mode) {
        return rgb2css(this._rgb, mode);
    };

    chroma$i.css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$B, [ null ].concat( args, ['css']) ));
    };

    input$e.format.css = css2rgb;

    input$e.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$k(h) === 'string' && css2rgb.test(h)) {
                return 'css';
            }
        }
    });

    var Color$A = Color_1;
    var chroma$h = chroma_1;
    var input$d = input$h;
    var unpack$t = utils.unpack;

    input$d.format.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$t(args, 'rgba');
        rgb[0] *= 255;
        rgb[1] *= 255;
        rgb[2] *= 255;
        return rgb;
    };

    chroma$h.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$A, [ null ].concat( args, ['gl']) ));
    };

    Color$A.prototype.gl = function() {
        var rgb = this._rgb;
        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];
    };

    var unpack$s = utils.unpack;

    var rgb2hcg$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$s(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var c = delta * 100 / 255;
        var _g = min / (255 - delta) * 100;
        var h;
        if (delta === 0) {
            h = Number.NaN;
        } else {
            if (r === max) { h = (g - b) / delta; }
            if (g === max) { h = 2+(b - r) / delta; }
            if (b === max) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, c, _g];
    };

    var rgb2hcg_1 = rgb2hcg$1;

    var unpack$r = utils.unpack;
    var floor$3 = Math.floor;

    /*
     * this is basically just HSV with some minor tweaks
     *
     * hue.. [0..360]
     * chroma .. [0..1]
     * grayness .. [0..1]
     */

    var hcg2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$r(args, 'hcg');
        var h = args[0];
        var c = args[1];
        var _g = args[2];
        var r,g,b;
        _g = _g * 255;
        var _c = c * 255;
        if (c === 0) {
            r = g = b = _g;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;
            var i = floor$3(h);
            var f = h - i;
            var p = _g * (1 - c);
            var q = p + _c * (1 - f);
            var t = p + _c * f;
            var v = p + _c;
            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var hcg2rgb_1 = hcg2rgb;

    var unpack$q = utils.unpack;
    var type$j = utils.type;
    var chroma$g = chroma_1;
    var Color$z = Color_1;
    var input$c = input$h;

    var rgb2hcg = rgb2hcg_1;

    Color$z.prototype.hcg = function() {
        return rgb2hcg(this._rgb);
    };

    chroma$g.hcg = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$z, [ null ].concat( args, ['hcg']) ));
    };

    input$c.format.hcg = hcg2rgb_1;

    input$c.autodetect.push({
        p: 1,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$q(args, 'hcg');
            if (type$j(args) === 'array' && args.length === 3) {
                return 'hcg';
            }
        }
    });

    var unpack$p = utils.unpack;
    var last = utils.last;
    var round$3 = Math.round;

    var rgb2hex$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$p(args, 'rgba');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var a = ref[3];
        var mode = last(args) || 'auto';
        if (a === undefined) { a = 1; }
        if (mode === 'auto') {
            mode = a < 1 ? 'rgba' : 'rgb';
        }
        r = round$3(r);
        g = round$3(g);
        b = round$3(b);
        var u = r << 16 | g << 8 | b;
        var str = "000000" + u.toString(16); //#.toUpperCase();
        str = str.substr(str.length - 6);
        var hxa = '0' + round$3(a * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        switch (mode.toLowerCase()) {
            case 'rgba': return ("#" + str + hxa);
            case 'argb': return ("#" + hxa + str);
            default: return ("#" + str);
        }
    };

    var rgb2hex_1 = rgb2hex$2;

    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;

    var hex2rgb$1 = function (hex) {
        if (hex.match(RE_HEX)) {
            // remove optional leading #
            if (hex.length === 4 || hex.length === 7) {
                hex = hex.substr(1);
            }
            // expand short-notation to full six-digit
            if (hex.length === 3) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            }
            var u = parseInt(hex, 16);
            var r = u >> 16;
            var g = u >> 8 & 0xFF;
            var b = u & 0xFF;
            return [r,g,b,1];
        }

        // match rgba hex format, eg #FF000077
        if (hex.match(RE_HEXA)) {
            if (hex.length === 5 || hex.length === 9) {
                // remove optional leading #
                hex = hex.substr(1);
            }
            // expand short-notation to full eight-digit
            if (hex.length === 4) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];
            }
            var u$1 = parseInt(hex, 16);
            var r$1 = u$1 >> 24 & 0xFF;
            var g$1 = u$1 >> 16 & 0xFF;
            var b$1 = u$1 >> 8 & 0xFF;
            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;
            return [r$1,g$1,b$1,a];
        }

        // we used to check for css colors here
        // if _input.css? and rgb = _input.css hex
        //     return rgb

        throw new Error(("unknown hex color: " + hex));
    };

    var hex2rgb_1 = hex2rgb$1;

    var chroma$f = chroma_1;
    var Color$y = Color_1;
    var type$i = utils.type;
    var input$b = input$h;

    var rgb2hex$1 = rgb2hex_1;

    Color$y.prototype.hex = function(mode) {
        return rgb2hex$1(this._rgb, mode);
    };

    chroma$f.hex = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$y, [ null ].concat( args, ['hex']) ));
    };

    input$b.format.hex = hex2rgb_1;
    input$b.autodetect.push({
        p: 4,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$i(h) === 'string' && [3,4,5,6,7,8,9].indexOf(h.length) >= 0) {
                return 'hex';
            }
        }
    });

    var unpack$o = utils.unpack;
    var TWOPI$2 = utils.TWOPI;
    var min$2 = Math.min;
    var sqrt$4 = Math.sqrt;
    var acos = Math.acos;

    var rgb2hsi$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
        */
        var ref = unpack$o(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r /= 255;
        g /= 255;
        b /= 255;
        var h;
        var min_ = min$2(r,g,b);
        var i = (r+g+b) / 3;
        var s = i > 0 ? 1 - min_/i : 0;
        if (s === 0) {
            h = NaN;
        } else {
            h = ((r-g)+(r-b)) / 2;
            h /= sqrt$4((r-g)*(r-g) + (r-b)*(g-b));
            h = acos(h);
            if (b > g) {
                h = TWOPI$2 - h;
            }
            h /= TWOPI$2;
        }
        return [h*360,s,i];
    };

    var rgb2hsi_1 = rgb2hsi$1;

    var unpack$n = utils.unpack;
    var limit = utils.limit;
    var TWOPI$1 = utils.TWOPI;
    var PITHIRD = utils.PITHIRD;
    var cos$4 = Math.cos;

    /*
     * hue [0..360]
     * saturation [0..1]
     * intensity [0..1]
     */
    var hsi2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
        */
        args = unpack$n(args, 'hsi');
        var h = args[0];
        var s = args[1];
        var i = args[2];
        var r,g,b;

        if (isNaN(h)) { h = 0; }
        if (isNaN(s)) { s = 0; }
        // normalize hue
        if (h > 360) { h -= 360; }
        if (h < 0) { h += 360; }
        h /= 360;
        if (h < 1/3) {
            b = (1-s)/3;
            r = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            g = 1 - (b+r);
        } else if (h < 2/3) {
            h -= 1/3;
            r = (1-s)/3;
            g = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            b = 1 - (r+g);
        } else {
            h -= 2/3;
            g = (1-s)/3;
            b = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            r = 1 - (g+b);
        }
        r = limit(i*r*3);
        g = limit(i*g*3);
        b = limit(i*b*3);
        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];
    };

    var hsi2rgb_1 = hsi2rgb;

    var unpack$m = utils.unpack;
    var type$h = utils.type;
    var chroma$e = chroma_1;
    var Color$x = Color_1;
    var input$a = input$h;

    var rgb2hsi = rgb2hsi_1;

    Color$x.prototype.hsi = function() {
        return rgb2hsi(this._rgb);
    };

    chroma$e.hsi = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$x, [ null ].concat( args, ['hsi']) ));
    };

    input$a.format.hsi = hsi2rgb_1;

    input$a.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$m(args, 'hsi');
            if (type$h(args) === 'array' && args.length === 3) {
                return 'hsi';
            }
        }
    });

    var unpack$l = utils.unpack;
    var type$g = utils.type;
    var chroma$d = chroma_1;
    var Color$w = Color_1;
    var input$9 = input$h;

    var rgb2hsl$1 = rgb2hsl_1;

    Color$w.prototype.hsl = function() {
        return rgb2hsl$1(this._rgb);
    };

    chroma$d.hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$w, [ null ].concat( args, ['hsl']) ));
    };

    input$9.format.hsl = hsl2rgb_1;

    input$9.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$l(args, 'hsl');
            if (type$g(args) === 'array' && args.length === 3) {
                return 'hsl';
            }
        }
    });

    var unpack$k = utils.unpack;
    var min$1 = Math.min;
    var max$1 = Math.max;

    /*
     * supported arguments:
     * - rgb2hsv(r,g,b)
     * - rgb2hsv([r,g,b])
     * - rgb2hsv({r,g,b})
     */
    var rgb2hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$k(args, 'rgb');
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var min_ = min$1(r, g, b);
        var max_ = max$1(r, g, b);
        var delta = max_ - min_;
        var h,s,v;
        v = max_ / 255.0;
        if (max_ === 0) {
            h = Number.NaN;
            s = 0;
        } else {
            s = delta / max_;
            if (r === max_) { h = (g - b) / delta; }
            if (g === max_) { h = 2+(b - r) / delta; }
            if (b === max_) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, s, v]
    };

    var rgb2hsv$1 = rgb2hsl;

    var unpack$j = utils.unpack;
    var floor$2 = Math.floor;

    var hsv2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$j(args, 'hsv');
        var h = args[0];
        var s = args[1];
        var v = args[2];
        var r,g,b;
        v *= 255;
        if (s === 0) {
            r = g = b = v;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;

            var i = floor$2(h);
            var f = h - i;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));

            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r,g,b,args.length > 3?args[3]:1];
    };

    var hsv2rgb_1 = hsv2rgb;

    var unpack$i = utils.unpack;
    var type$f = utils.type;
    var chroma$c = chroma_1;
    var Color$v = Color_1;
    var input$8 = input$h;

    var rgb2hsv = rgb2hsv$1;

    Color$v.prototype.hsv = function() {
        return rgb2hsv(this._rgb);
    };

    chroma$c.hsv = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$v, [ null ].concat( args, ['hsv']) ));
    };

    input$8.format.hsv = hsv2rgb_1;

    input$8.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$i(args, 'hsv');
            if (type$f(args) === 'array' && args.length === 3) {
                return 'hsv';
            }
        }
    });

    var labConstants = {
        // Corresponds roughly to RGB brighter/darker
        Kn: 18,

        // D65 standard referent
        Xn: 0.950470,
        Yn: 1,
        Zn: 1.088830,

        t0: 0.137931034,  // 4 / 29
        t1: 0.206896552,  // 6 / 29
        t2: 0.12841855,   // 3 * t1 * t1
        t3: 0.008856452,  // t1 * t1 * t1
    };

    var LAB_CONSTANTS$3 = labConstants;
    var unpack$h = utils.unpack;
    var pow$a = Math.pow;

    var rgb2lab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$h(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2xyz(r,g,b);
        var x = ref$1[0];
        var y = ref$1[1];
        var z = ref$1[2];
        var l = 116 * y - 16;
        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
    };

    var rgb_xyz = function (r) {
        if ((r /= 255) <= 0.04045) { return r / 12.92; }
        return pow$a((r + 0.055) / 1.055, 2.4);
    };

    var xyz_lab = function (t) {
        if (t > LAB_CONSTANTS$3.t3) { return pow$a(t, 1 / 3); }
        return t / LAB_CONSTANTS$3.t2 + LAB_CONSTANTS$3.t0;
    };

    var rgb2xyz = function (r,g,b) {
        r = rgb_xyz(r);
        g = rgb_xyz(g);
        b = rgb_xyz(b);
        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS$3.Xn);
        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / LAB_CONSTANTS$3.Yn);
        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / LAB_CONSTANTS$3.Zn);
        return [x,y,z];
    };

    var rgb2lab_1 = rgb2lab$2;

    var LAB_CONSTANTS$2 = labConstants;
    var unpack$g = utils.unpack;
    var pow$9 = Math.pow;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var lab2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$g(args, 'lab');
        var l = args[0];
        var a = args[1];
        var b = args[2];
        var x,y,z, r,g,b_;

        y = (l + 16) / 116;
        x = isNaN(a) ? y : y + a / 500;
        z = isNaN(b) ? y : y - b / 200;

        y = LAB_CONSTANTS$2.Yn * lab_xyz(y);
        x = LAB_CONSTANTS$2.Xn * lab_xyz(x);
        z = LAB_CONSTANTS$2.Zn * lab_xyz(z);

        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB
        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);

        return [r,g,b_,args.length > 3 ? args[3] : 1];
    };

    var xyz_rgb = function (r) {
        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$9(r, 1 / 2.4) - 0.055)
    };

    var lab_xyz = function (t) {
        return t > LAB_CONSTANTS$2.t1 ? t * t * t : LAB_CONSTANTS$2.t2 * (t - LAB_CONSTANTS$2.t0)
    };

    var lab2rgb_1 = lab2rgb$1;

    var unpack$f = utils.unpack;
    var type$e = utils.type;
    var chroma$b = chroma_1;
    var Color$u = Color_1;
    var input$7 = input$h;

    var rgb2lab$1 = rgb2lab_1;

    Color$u.prototype.lab = function() {
        return rgb2lab$1(this._rgb);
    };

    chroma$b.lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$u, [ null ].concat( args, ['lab']) ));
    };

    input$7.format.lab = lab2rgb_1;

    input$7.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$f(args, 'lab');
            if (type$e(args) === 'array' && args.length === 3) {
                return 'lab';
            }
        }
    });

    var unpack$e = utils.unpack;
    var RAD2DEG = utils.RAD2DEG;
    var sqrt$3 = Math.sqrt;
    var atan2$2 = Math.atan2;
    var round$2 = Math.round;

    var lab2lch$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$e(args, 'lab');
        var l = ref[0];
        var a = ref[1];
        var b = ref[2];
        var c = sqrt$3(a * a + b * b);
        var h = (atan2$2(b, a) * RAD2DEG + 360) % 360;
        if (round$2(c*10000) === 0) { h = Number.NaN; }
        return [l, c, h];
    };

    var lab2lch_1 = lab2lch$2;

    var unpack$d = utils.unpack;
    var rgb2lab = rgb2lab_1;
    var lab2lch$1 = lab2lch_1;

    var rgb2lch$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$d(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2lab(r,g,b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch$1(l,a,b_);
    };

    var rgb2lch_1 = rgb2lch$1;

    var unpack$c = utils.unpack;
    var DEG2RAD = utils.DEG2RAD;
    var sin$3 = Math.sin;
    var cos$3 = Math.cos;

    var lch2lab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.
        These formulas were invented by David Dalrymple to obtain maximum contrast without going
        out of gamut if the parameters are in the range 0-1.

        A saturation multiplier was added by Gregor Aisch
        */
        var ref = unpack$c(args, 'lch');
        var l = ref[0];
        var c = ref[1];
        var h = ref[2];
        if (isNaN(h)) { h = 0; }
        h = h * DEG2RAD;
        return [l, cos$3(h) * c, sin$3(h) * c]
    };

    var lch2lab_1 = lch2lab$2;

    var unpack$b = utils.unpack;
    var lch2lab$1 = lch2lab_1;
    var lab2rgb = lab2rgb_1;

    var lch2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$b(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab$1 (l,c,h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = lab2rgb (L,a,b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var lch2rgb_1 = lch2rgb$1;

    var unpack$a = utils.unpack;
    var lch2rgb = lch2rgb_1;

    var hcl2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hcl = unpack$a(args, 'hcl').reverse();
        return lch2rgb.apply(void 0, hcl);
    };

    var hcl2rgb_1 = hcl2rgb;

    var unpack$9 = utils.unpack;
    var type$d = utils.type;
    var chroma$a = chroma_1;
    var Color$t = Color_1;
    var input$6 = input$h;

    var rgb2lch = rgb2lch_1;

    Color$t.prototype.lch = function() { return rgb2lch(this._rgb); };
    Color$t.prototype.hcl = function() { return rgb2lch(this._rgb).reverse(); };

    chroma$a.lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['lch']) ));
    };
    chroma$a.hcl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['hcl']) ));
    };

    input$6.format.lch = lch2rgb_1;
    input$6.format.hcl = hcl2rgb_1;

    ['lch','hcl'].forEach(function (m) { return input$6.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$9(args, m);
            if (type$d(args) === 'array' && args.length === 3) {
                return m;
            }
        }
    }); });

    /**
    	X11 color names

    	http://www.w3.org/TR/css3-color/#svg-color
    */

    var w3cx11$1 = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflower: '#6495ed',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        laserlemon: '#ffff54',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrod: '#fafad2',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        maroon2: '#7f0000',
        maroon3: '#b03060',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        purple2: '#7f007f',
        purple3: '#a020f0',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32'
    };

    var w3cx11_1 = w3cx11$1;

    var Color$s = Color_1;
    var input$5 = input$h;
    var type$c = utils.type;

    var w3cx11 = w3cx11_1;
    var hex2rgb = hex2rgb_1;
    var rgb2hex = rgb2hex_1;

    Color$s.prototype.name = function() {
        var hex = rgb2hex(this._rgb, 'rgb');
        for (var i = 0, list = Object.keys(w3cx11); i < list.length; i += 1) {
            var n = list[i];

            if (w3cx11[n] === hex) { return n.toLowerCase(); }
        }
        return hex;
    };

    input$5.format.named = function (name) {
        name = name.toLowerCase();
        if (w3cx11[name]) { return hex2rgb(w3cx11[name]); }
        throw new Error('unknown color name: '+name);
    };

    input$5.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$c(h) === 'string' && w3cx11[h.toLowerCase()]) {
                return 'named';
            }
        }
    });

    var unpack$8 = utils.unpack;

    var rgb2num$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$8(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        return (r << 16) + (g << 8) + b;
    };

    var rgb2num_1 = rgb2num$1;

    var type$b = utils.type;

    var num2rgb = function (num) {
        if (type$b(num) == "number" && num >= 0 && num <= 0xFFFFFF) {
            var r = num >> 16;
            var g = (num >> 8) & 0xFF;
            var b = num & 0xFF;
            return [r,g,b,1];
        }
        throw new Error("unknown num color: "+num);
    };

    var num2rgb_1 = num2rgb;

    var chroma$9 = chroma_1;
    var Color$r = Color_1;
    var input$4 = input$h;
    var type$a = utils.type;

    var rgb2num = rgb2num_1;

    Color$r.prototype.num = function() {
        return rgb2num(this._rgb);
    };

    chroma$9.num = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$r, [ null ].concat( args, ['num']) ));
    };

    input$4.format.num = num2rgb_1;

    input$4.autodetect.push({
        p: 5,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            if (args.length === 1 && type$a(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {
                return 'num';
            }
        }
    });

    var chroma$8 = chroma_1;
    var Color$q = Color_1;
    var input$3 = input$h;
    var unpack$7 = utils.unpack;
    var type$9 = utils.type;
    var round$1 = Math.round;

    Color$q.prototype.rgb = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        if (rnd === false) { return this._rgb.slice(0,3); }
        return this._rgb.slice(0,3).map(round$1);
    };

    Color$q.prototype.rgba = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        return this._rgb.slice(0,4).map(function (v,i) {
            return i<3 ? (rnd === false ? v : round$1(v)) : v;
        });
    };

    chroma$8.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$q, [ null ].concat( args, ['rgb']) ));
    };

    input$3.format.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$7(args, 'rgba');
        if (rgba[3] === undefined) { rgba[3] = 1; }
        return rgba;
    };

    input$3.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$7(args, 'rgba');
            if (type$9(args) === 'array' && (args.length === 3 ||
                args.length === 4 && type$9(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {
                return 'rgb';
            }
        }
    });

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     */

    var log$1 = Math.log;

    var temperature2rgb$1 = function (kelvin) {
        var temp = kelvin / 100;
        var r,g,b;
        if (temp < 66) {
            r = 255;
            g = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log$1(g);
            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log$1(b);
        } else {
            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log$1(r);
            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log$1(g);
            b = 255;
        }
        return [r,g,b,1];
    };

    var temperature2rgb_1 = temperature2rgb$1;

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     **/

    var temperature2rgb = temperature2rgb_1;
    var unpack$6 = utils.unpack;
    var round = Math.round;

    var rgb2temperature$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$6(args, 'rgb');
        var r = rgb[0], b = rgb[2];
        var minTemp = 1000;
        var maxTemp = 40000;
        var eps = 0.4;
        var temp;
        while (maxTemp - minTemp > eps) {
            temp = (maxTemp + minTemp) * 0.5;
            var rgb$1 = temperature2rgb(temp);
            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {
                maxTemp = temp;
            } else {
                minTemp = temp;
            }
        }
        return round(temp);
    };

    var rgb2temperature_1 = rgb2temperature$1;

    var chroma$7 = chroma_1;
    var Color$p = Color_1;
    var input$2 = input$h;

    var rgb2temperature = rgb2temperature_1;

    Color$p.prototype.temp =
    Color$p.prototype.kelvin =
    Color$p.prototype.temperature = function() {
        return rgb2temperature(this._rgb);
    };

    chroma$7.temp =
    chroma$7.kelvin =
    chroma$7.temperature = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$p, [ null ].concat( args, ['temp']) ));
    };

    input$2.format.temp =
    input$2.format.kelvin =
    input$2.format.temperature = temperature2rgb_1;

    var unpack$5 = utils.unpack;
    var cbrt = Math.cbrt;
    var pow$8 = Math.pow;
    var sign$1 = Math.sign;

    var rgb2oklab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        // OKLab color space implementation taken from
        // https://bottosson.github.io/posts/oklab/
        var ref = unpack$5(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = [rgb2lrgb(r / 255), rgb2lrgb(g / 255), rgb2lrgb(b / 255)];
        var lr = ref$1[0];
        var lg = ref$1[1];
        var lb = ref$1[2];
        var l = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
        var m = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
        var s = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);

        return [
            0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
            1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
            0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s
        ];
    };

    var rgb2oklab_1 = rgb2oklab$2;

    function rgb2lrgb(c) {
        var abs = Math.abs(c);
        if (abs < 0.04045) {
            return c / 12.92;
        }
        return (sign$1(c) || 1) * pow$8((abs + 0.055) / 1.055, 2.4);
    }

    var unpack$4 = utils.unpack;
    var pow$7 = Math.pow;
    var sign = Math.sign;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var oklab2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$4(args, 'lab');
        var L = args[0];
        var a = args[1];
        var b = args[2];

        var l = pow$7(L + 0.3963377774 * a + 0.2158037573 * b, 3);
        var m = pow$7(L - 0.1055613458 * a - 0.0638541728 * b, 3);
        var s = pow$7(L - 0.0894841775 * a - 1.291485548 * b, 3);

        return [
            255 * lrgb2rgb(+4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s),
            255 * lrgb2rgb(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s),
            255 * lrgb2rgb(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s),
            args.length > 3 ? args[3] : 1
        ];
    };

    var oklab2rgb_1 = oklab2rgb$1;

    function lrgb2rgb(c) {
        var abs = Math.abs(c);
        if (abs > 0.0031308) {
            return (sign(c) || 1) * (1.055 * pow$7(abs, 1 / 2.4) - 0.055);
        }
        return c * 12.92;
    }

    var unpack$3 = utils.unpack;
    var type$8 = utils.type;
    var chroma$6 = chroma_1;
    var Color$o = Color_1;
    var input$1 = input$h;

    var rgb2oklab$1 = rgb2oklab_1;

    Color$o.prototype.oklab = function () {
        return rgb2oklab$1(this._rgb);
    };

    chroma$6.oklab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$o, [ null ].concat( args, ['oklab']) ));
    };

    input$1.format.oklab = oklab2rgb_1;

    input$1.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$3(args, 'oklab');
            if (type$8(args) === 'array' && args.length === 3) {
                return 'oklab';
            }
        }
    });

    var unpack$2 = utils.unpack;
    var rgb2oklab = rgb2oklab_1;
    var lab2lch = lab2lch_1;

    var rgb2oklch$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$2(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2oklab(r, g, b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch(l, a, b_);
    };

    var rgb2oklch_1 = rgb2oklch$1;

    var unpack$1 = utils.unpack;
    var lch2lab = lch2lab_1;
    var oklab2rgb = oklab2rgb_1;

    var oklch2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$1(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab(l, c, h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = oklab2rgb(L, a, b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var oklch2rgb_1 = oklch2rgb;

    var unpack = utils.unpack;
    var type$7 = utils.type;
    var chroma$5 = chroma_1;
    var Color$n = Color_1;
    var input = input$h;

    var rgb2oklch = rgb2oklch_1;

    Color$n.prototype.oklch = function () {
        return rgb2oklch(this._rgb);
    };

    chroma$5.oklch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$n, [ null ].concat( args, ['oklch']) ));
    };

    input.format.oklch = oklch2rgb_1;

    input.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'oklch');
            if (type$7(args) === 'array' && args.length === 3) {
                return 'oklch';
            }
        }
    });

    var Color$m = Color_1;
    var type$6 = utils.type;

    Color$m.prototype.alpha = function(a, mutate) {
        if ( mutate === void 0 ) mutate=false;

        if (a !== undefined && type$6(a) === 'number') {
            if (mutate) {
                this._rgb[3] = a;
                return this;
            }
            return new Color$m([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');
        }
        return this._rgb[3];
    };

    var Color$l = Color_1;

    Color$l.prototype.clipped = function() {
        return this._rgb._clipped || false;
    };

    var Color$k = Color_1;
    var LAB_CONSTANTS$1 = labConstants;

    Color$k.prototype.darken = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lab = me.lab();
    	lab[0] -= LAB_CONSTANTS$1.Kn * amount;
    	return new Color$k(lab, 'lab').alpha(me.alpha(), true);
    };

    Color$k.prototype.brighten = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.darken(-amount);
    };

    Color$k.prototype.darker = Color$k.prototype.darken;
    Color$k.prototype.brighter = Color$k.prototype.brighten;

    var Color$j = Color_1;

    Color$j.prototype.get = function (mc) {
        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) { return src[i]; }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var Color$i = Color_1;
    var type$5 = utils.type;
    var pow$6 = Math.pow;

    var EPS = 1e-7;
    var MAX_ITER = 20;

    Color$i.prototype.luminance = function(lum) {
        if (lum !== undefined && type$5(lum) === 'number') {
            if (lum === 0) {
                // return pure black
                return new Color$i([0,0,0,this._rgb[3]], 'rgb');
            }
            if (lum === 1) {
                // return pure white
                return new Color$i([255,255,255,this._rgb[3]], 'rgb');
            }
            // compute new color using...
            var cur_lum = this.luminance();
            var mode = 'rgb';
            var max_iter = MAX_ITER;

            var test = function (low, high) {
                var mid = low.interpolate(high, 0.5, mode);
                var lm = mid.luminance();
                if (Math.abs(lum - lm) < EPS || !max_iter--) {
                    // close enough
                    return mid;
                }
                return lm > lum ? test(low, mid) : test(mid, high);
            };

            var rgb = (cur_lum > lum ? test(new Color$i([0,0,0]), this) : test(this, new Color$i([255,255,255]))).rgb();
            return new Color$i(rgb.concat( [this._rgb[3]]));
        }
        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));
    };


    var rgb2luminance = function (r,g,b) {
        // relative luminance
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        r = luminance_x(r);
        g = luminance_x(g);
        b = luminance_x(b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };

    var luminance_x = function (x) {
        x /= 255;
        return x <= 0.03928 ? x/12.92 : pow$6((x+0.055)/1.055, 2.4);
    };

    var interpolator$1 = {};

    var Color$h = Color_1;
    var type$4 = utils.type;
    var interpolator = interpolator$1;

    var mix$1 = function (col1, col2, f) {
        if ( f === void 0 ) f=0.5;
        var rest = [], len = arguments.length - 3;
        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];

        var mode = rest[0] || 'lrgb';
        if (!interpolator[mode] && !rest.length) {
            // fall back to the first supported mode
            mode = Object.keys(interpolator)[0];
        }
        if (!interpolator[mode]) {
            throw new Error(("interpolation mode " + mode + " is not defined"));
        }
        if (type$4(col1) !== 'object') { col1 = new Color$h(col1); }
        if (type$4(col2) !== 'object') { col2 = new Color$h(col2); }
        return interpolator[mode](col1, col2, f)
            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
    };

    var Color$g = Color_1;
    var mix = mix$1;

    Color$g.prototype.mix =
    Color$g.prototype.interpolate = function(col2, f) {
    	if ( f === void 0 ) f=0.5;
    	var rest = [], len = arguments.length - 2;
    	while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];

    	return mix.apply(void 0, [ this, col2, f ].concat( rest ));
    };

    var Color$f = Color_1;

    Color$f.prototype.premultiply = function(mutate) {
    	if ( mutate === void 0 ) mutate=false;

    	var rgb = this._rgb;
    	var a = rgb[3];
    	if (mutate) {
    		this._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];
    		return this;
    	} else {
    		return new Color$f([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');
    	}
    };

    var Color$e = Color_1;
    var LAB_CONSTANTS = labConstants;

    Color$e.prototype.saturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lch = me.lch();
    	lch[1] += LAB_CONSTANTS.Kn * amount;
    	if (lch[1] < 0) { lch[1] = 0; }
    	return new Color$e(lch, 'lch').alpha(me.alpha(), true);
    };

    Color$e.prototype.desaturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.saturate(-amount);
    };

    var Color$d = Color_1;
    var type$3 = utils.type;

    Color$d.prototype.set = function (mc, value, mutate) {
        if ( mutate === void 0 ) mutate = false;

        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) {
                if (type$3(value) == 'string') {
                    switch (value.charAt(0)) {
                        case '+':
                            src[i] += +value;
                            break;
                        case '-':
                            src[i] += +value;
                            break;
                        case '*':
                            src[i] *= +value.substr(1);
                            break;
                        case '/':
                            src[i] /= +value.substr(1);
                            break;
                        default:
                            src[i] = +value;
                    }
                } else if (type$3(value) === 'number') {
                    src[i] = value;
                } else {
                    throw new Error("unsupported value for Color.set");
                }
                var out = new Color$d(src, mode);
                if (mutate) {
                    this._rgb = out._rgb;
                    return this;
                }
                return out;
            }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var Color$c = Color_1;

    var rgb = function (col1, col2, f) {
        var xyz0 = col1._rgb;
        var xyz1 = col2._rgb;
        return new Color$c(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'rgb'
        )
    };

    // register interpolator
    interpolator$1.rgb = rgb;

    var Color$b = Color_1;
    var sqrt$2 = Math.sqrt;
    var pow$5 = Math.pow;

    var lrgb = function (col1, col2, f) {
        var ref = col1._rgb;
        var x1 = ref[0];
        var y1 = ref[1];
        var z1 = ref[2];
        var ref$1 = col2._rgb;
        var x2 = ref$1[0];
        var y2 = ref$1[1];
        var z2 = ref$1[2];
        return new Color$b(
            sqrt$2(pow$5(x1,2) * (1-f) + pow$5(x2,2) * f),
            sqrt$2(pow$5(y1,2) * (1-f) + pow$5(y2,2) * f),
            sqrt$2(pow$5(z1,2) * (1-f) + pow$5(z2,2) * f),
            'rgb'
        )
    };

    // register interpolator
    interpolator$1.lrgb = lrgb;

    var Color$a = Color_1;

    var lab = function (col1, col2, f) {
        var xyz0 = col1.lab();
        var xyz1 = col2.lab();
        return new Color$a(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'lab'
        )
    };

    // register interpolator
    interpolator$1.lab = lab;

    var Color$9 = Color_1;

    var _hsx = function (col1, col2, f, m) {
        var assign, assign$1;

        var xyz0, xyz1;
        if (m === 'hsl') {
            xyz0 = col1.hsl();
            xyz1 = col2.hsl();
        } else if (m === 'hsv') {
            xyz0 = col1.hsv();
            xyz1 = col2.hsv();
        } else if (m === 'hcg') {
            xyz0 = col1.hcg();
            xyz1 = col2.hcg();
        } else if (m === 'hsi') {
            xyz0 = col1.hsi();
            xyz1 = col2.hsi();
        } else if (m === 'lch' || m === 'hcl') {
            m = 'hcl';
            xyz0 = col1.hcl();
            xyz1 = col2.hcl();
        } else if (m === 'oklch') {
            xyz0 = col1.oklch().reverse();
            xyz1 = col2.oklch().reverse();
        }

        var hue0, hue1, sat0, sat1, lbv0, lbv1;
        if (m.substr(0, 1) === 'h' || m === 'oklch') {
            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);
            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);
        }

        var sat, hue, lbv, dh;

        if (!isNaN(hue0) && !isNaN(hue1)) {
            // both colors have hue
            if (hue1 > hue0 && hue1 - hue0 > 180) {
                dh = hue1 - (hue0 + 360);
            } else if (hue1 < hue0 && hue0 - hue1 > 180) {
                dh = hue1 + 360 - hue0;
            } else {
                dh = hue1 - hue0;
            }
            hue = hue0 + f * dh;
        } else if (!isNaN(hue0)) {
            hue = hue0;
            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }
        } else if (!isNaN(hue1)) {
            hue = hue1;
            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }
        } else {
            hue = Number.NaN;
        }

        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }
        lbv = lbv0 + f * (lbv1 - lbv0);
        return m === 'oklch' ? new Color$9([lbv, sat, hue], m) : new Color$9([hue, sat, lbv], m);
    };

    var interpolate_hsx$5 = _hsx;

    var lch = function (col1, col2, f) {
    	return interpolate_hsx$5(col1, col2, f, 'lch');
    };

    // register interpolator
    interpolator$1.lch = lch;
    interpolator$1.hcl = lch;

    var Color$8 = Color_1;

    var num = function (col1, col2, f) {
        var c1 = col1.num();
        var c2 = col2.num();
        return new Color$8(c1 + f * (c2-c1), 'num')
    };

    // register interpolator
    interpolator$1.num = num;

    var interpolate_hsx$4 = _hsx;

    var hcg = function (col1, col2, f) {
    	return interpolate_hsx$4(col1, col2, f, 'hcg');
    };

    // register interpolator
    interpolator$1.hcg = hcg;

    var interpolate_hsx$3 = _hsx;

    var hsi = function (col1, col2, f) {
    	return interpolate_hsx$3(col1, col2, f, 'hsi');
    };

    // register interpolator
    interpolator$1.hsi = hsi;

    var interpolate_hsx$2 = _hsx;

    var hsl = function (col1, col2, f) {
    	return interpolate_hsx$2(col1, col2, f, 'hsl');
    };

    // register interpolator
    interpolator$1.hsl = hsl;

    var interpolate_hsx$1 = _hsx;

    var hsv = function (col1, col2, f) {
    	return interpolate_hsx$1(col1, col2, f, 'hsv');
    };

    // register interpolator
    interpolator$1.hsv = hsv;

    var Color$7 = Color_1;

    var oklab = function (col1, col2, f) {
        var xyz0 = col1.oklab();
        var xyz1 = col2.oklab();
        return new Color$7(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            'oklab'
        );
    };

    // register interpolator
    interpolator$1.oklab = oklab;

    var interpolate_hsx = _hsx;

    var oklch = function (col1, col2, f) {
        return interpolate_hsx(col1, col2, f, 'oklch');
    };

    // register interpolator
    interpolator$1.oklch = oklch;

    var Color$6 = Color_1;
    var clip_rgb$1 = utils.clip_rgb;
    var pow$4 = Math.pow;
    var sqrt$1 = Math.sqrt;
    var PI$1 = Math.PI;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var atan2$1 = Math.atan2;

    var average = function (colors, mode, weights) {
        if ( mode === void 0 ) mode='lrgb';
        if ( weights === void 0 ) weights=null;

        var l = colors.length;
        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }
        // normalize weights
        var k = l / weights.reduce(function(a, b) { return a + b; });
        weights.forEach(function (w,i) { weights[i] *= k; });
        // convert colors to Color objects
        colors = colors.map(function (c) { return new Color$6(c); });
        if (mode === 'lrgb') {
            return _average_lrgb(colors, weights)
        }
        var first = colors.shift();
        var xyz = first.get(mode);
        var cnt = [];
        var dx = 0;
        var dy = 0;
        // initial color
        for (var i=0; i<xyz.length; i++) {
            xyz[i] = (xyz[i] || 0) * weights[0];
            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);
            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {
                var A = xyz[i] / 180 * PI$1;
                dx += cos$2(A) * weights[0];
                dy += sin$2(A) * weights[0];
            }
        }

        var alpha = first.alpha() * weights[0];
        colors.forEach(function (c,ci) {
            var xyz2 = c.get(mode);
            alpha += c.alpha() * weights[ci+1];
            for (var i=0; i<xyz.length; i++) {
                if (!isNaN(xyz2[i])) {
                    cnt[i] += weights[ci+1];
                    if (mode.charAt(i) === 'h') {
                        var A = xyz2[i] / 180 * PI$1;
                        dx += cos$2(A) * weights[ci+1];
                        dy += sin$2(A) * weights[ci+1];
                    } else {
                        xyz[i] += xyz2[i] * weights[ci+1];
                    }
                }
            }
        });

        for (var i$1=0; i$1<xyz.length; i$1++) {
            if (mode.charAt(i$1) === 'h') {
                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;
                while (A$1 < 0) { A$1 += 360; }
                while (A$1 >= 360) { A$1 -= 360; }
                xyz[i$1] = A$1;
            } else {
                xyz[i$1] = xyz[i$1]/cnt[i$1];
            }
        }
        alpha /= l;
        return (new Color$6(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);
    };


    var _average_lrgb = function (colors, weights) {
        var l = colors.length;
        var xyz = [0,0,0,0];
        for (var i=0; i < colors.length; i++) {
            var col = colors[i];
            var f = weights[i] / l;
            var rgb = col._rgb;
            xyz[0] += pow$4(rgb[0],2) * f;
            xyz[1] += pow$4(rgb[1],2) * f;
            xyz[2] += pow$4(rgb[2],2) * f;
            xyz[3] += rgb[3] * f;
        }
        xyz[0] = sqrt$1(xyz[0]);
        xyz[1] = sqrt$1(xyz[1]);
        xyz[2] = sqrt$1(xyz[2]);
        if (xyz[3] > 0.9999999) { xyz[3] = 1; }
        return new Color$6(clip_rgb$1(xyz));
    };

    // minimal multi-purpose interface

    // @requires utils color analyze

    var chroma$4 = chroma_1;
    var type$2 = utils.type;

    var pow$3 = Math.pow;

    var scale$2 = function(colors) {

        // constructor
        var _mode = 'rgb';
        var _nacol = chroma$4('#ccc');
        var _spread = 0;
        // const _fixed = false;
        var _domain = [0, 1];
        var _pos = [];
        var _padding = [0,0];
        var _classes = false;
        var _colors = [];
        var _out = false;
        var _min = 0;
        var _max = 1;
        var _correctLightness = false;
        var _colorCache = {};
        var _useCache = true;
        var _gamma = 1;

        // private methods

        var setColors = function(colors) {
            colors = colors || ['#fff', '#000'];
            if (colors && type$2(colors) === 'string' && chroma$4.brewer &&
                chroma$4.brewer[colors.toLowerCase()]) {
                colors = chroma$4.brewer[colors.toLowerCase()];
            }
            if (type$2(colors) === 'array') {
                // handle single color
                if (colors.length === 1) {
                    colors = [colors[0], colors[0]];
                }
                // make a copy of the colors
                colors = colors.slice(0);
                // convert to chroma classes
                for (var c=0; c<colors.length; c++) {
                    colors[c] = chroma$4(colors[c]);
                }
                // auto-fill color position
                _pos.length = 0;
                for (var c$1=0; c$1<colors.length; c$1++) {
                    _pos.push(c$1/(colors.length-1));
                }
            }
            resetCache();
            return _colors = colors;
        };

        var getClass = function(value) {
            if (_classes != null) {
                var n = _classes.length-1;
                var i = 0;
                while (i < n && value >= _classes[i]) {
                    i++;
                }
                return i-1;
            }
            return 0;
        };

        var tMapLightness = function (t) { return t; };
        var tMapDomain = function (t) { return t; };

        // const classifyValue = function(value) {
        //     let val = value;
        //     if (_classes.length > 2) {
        //         const n = _classes.length-1;
        //         const i = getClass(value);
        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class
        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class
        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));
        //     }
        //     return val;
        // };

        var getColor = function(val, bypassMap) {
            var col, t;
            if (bypassMap == null) { bypassMap = false; }
            if (isNaN(val) || (val === null)) { return _nacol; }
            if (!bypassMap) {
                if (_classes && (_classes.length > 2)) {
                    // find the class
                    var c = getClass(val);
                    t = c / (_classes.length-2);
                } else if (_max !== _min) {
                    // just interpolate between min/max
                    t = (val - _min) / (_max - _min);
                } else {
                    t = 1;
                }
            } else {
                t = val;
            }

            // domain map
            t = tMapDomain(t);

            if (!bypassMap) {
                t = tMapLightness(t);  // lightness correction
            }

            if (_gamma !== 1) { t = pow$3(t, _gamma); }

            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));

            t = Math.min(1, Math.max(0, t));

            var k = Math.floor(t * 10000);

            if (_useCache && _colorCache[k]) {
                col = _colorCache[k];
            } else {
                if (type$2(_colors) === 'array') {
                    //for i in [0.._pos.length-1]
                    for (var i=0; i<_pos.length; i++) {
                        var p = _pos[i];
                        if (t <= p) {
                            col = _colors[i];
                            break;
                        }
                        if ((t >= p) && (i === (_pos.length-1))) {
                            col = _colors[i];
                            break;
                        }
                        if (t > p && t < _pos[i+1]) {
                            t = (t-p)/(_pos[i+1]-p);
                            col = chroma$4.interpolate(_colors[i], _colors[i+1], t, _mode);
                            break;
                        }
                    }
                } else if (type$2(_colors) === 'function') {
                    col = _colors(t);
                }
                if (_useCache) { _colorCache[k] = col; }
            }
            return col;
        };

        var resetCache = function () { return _colorCache = {}; };

        setColors(colors);

        // public interface

        var f = function(v) {
            var c = chroma$4(getColor(v));
            if (_out && c[_out]) { return c[_out](); } else { return c; }
        };

        f.classes = function(classes) {
            if (classes != null) {
                if (type$2(classes) === 'array') {
                    _classes = classes;
                    _domain = [classes[0], classes[classes.length-1]];
                } else {
                    var d = chroma$4.analyze(_domain);
                    if (classes === 0) {
                        _classes = [d.min, d.max];
                    } else {
                        _classes = chroma$4.limits(d, 'e', classes);
                    }
                }
                return f;
            }
            return _classes;
        };


        f.domain = function(domain) {
            if (!arguments.length) {
                return _domain;
            }
            _min = domain[0];
            _max = domain[domain.length-1];
            _pos = [];
            var k = _colors.length;
            if ((domain.length === k) && (_min !== _max)) {
                // update positions
                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {
                    var d = list[i];

                  _pos.push((d-_min) / (_max-_min));
                }
            } else {
                for (var c=0; c<k; c++) {
                    _pos.push(c/(k-1));
                }
                if (domain.length > 2) {
                    // set domain map
                    var tOut = domain.map(function (d,i) { return i/(domain.length-1); });
                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });
                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {
                        tMapDomain = function (t) {
                            if (t <= 0 || t >= 1) { return t; }
                            var i = 0;
                            while (t >= tBreaks[i+1]) { i++; }
                            var f = (t - tBreaks[i]) / (tBreaks[i+1] - tBreaks[i]);
                            var out = tOut[i] + f * (tOut[i+1] - tOut[i]);
                            return out;
                        };
                    }

                }
            }
            _domain = [_min, _max];
            return f;
        };

        f.mode = function(_m) {
            if (!arguments.length) {
                return _mode;
            }
            _mode = _m;
            resetCache();
            return f;
        };

        f.range = function(colors, _pos) {
            setColors(colors);
            return f;
        };

        f.out = function(_o) {
            _out = _o;
            return f;
        };

        f.spread = function(val) {
            if (!arguments.length) {
                return _spread;
            }
            _spread = val;
            return f;
        };

        f.correctLightness = function(v) {
            if (v == null) { v = true; }
            _correctLightness = v;
            resetCache();
            if (_correctLightness) {
                tMapLightness = function(t) {
                    var L0 = getColor(0, true).lab()[0];
                    var L1 = getColor(1, true).lab()[0];
                    var pol = L0 > L1;
                    var L_actual = getColor(t, true).lab()[0];
                    var L_ideal = L0 + ((L1 - L0) * t);
                    var L_diff = L_actual - L_ideal;
                    var t0 = 0;
                    var t1 = 1;
                    var max_iter = 20;
                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {
                        (function() {
                            if (pol) { L_diff *= -1; }
                            if (L_diff < 0) {
                                t0 = t;
                                t += (t1 - t) * 0.5;
                            } else {
                                t1 = t;
                                t += (t0 - t) * 0.5;
                            }
                            L_actual = getColor(t, true).lab()[0];
                            return L_diff = L_actual - L_ideal;
                        })();
                    }
                    return t;
                };
            } else {
                tMapLightness = function (t) { return t; };
            }
            return f;
        };

        f.padding = function(p) {
            if (p != null) {
                if (type$2(p) === 'number') {
                    p = [p,p];
                }
                _padding = p;
                return f;
            } else {
                return _padding;
            }
        };

        f.colors = function(numColors, out) {
            // If no arguments are given, return the original colors that were provided
            if (arguments.length < 2) { out = 'hex'; }
            var result = [];

            if (arguments.length === 0) {
                result = _colors.slice(0);

            } else if (numColors === 1) {
                result = [f(0.5)];

            } else if (numColors > 1) {
                var dm = _domain[0];
                var dd = _domain[1] - dm;
                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });

            } else { // returns all colors based on the defined classes
                colors = [];
                var samples = [];
                if (_classes && (_classes.length > 2)) {
                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
                        samples.push((_classes[i-1]+_classes[i])*0.5);
                    }
                } else {
                    samples = _domain;
                }
                result = samples.map(function (v) { return f(v); });
            }

            if (chroma$4[out]) {
                result = result.map(function (c) { return c[out](); });
            }
            return result;
        };

        f.cache = function(c) {
            if (c != null) {
                _useCache = c;
                return f;
            } else {
                return _useCache;
            }
        };

        f.gamma = function(g) {
            if (g != null) {
                _gamma = g;
                return f;
            } else {
                return _gamma;
            }
        };

        f.nodata = function(d) {
            if (d != null) {
                _nacol = chroma$4(d);
                return f;
            } else {
                return _nacol;
            }
        };

        return f;
    };

    function __range__(left, right, inclusive) {
      var range = [];
      var ascending = left < right;
      var end = !inclusive ? right : ascending ? right + 1 : right - 1;
      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
        range.push(i);
      }
      return range;
    }

    //
    // interpolates between a set of colors uzing a bezier spline
    //

    // @requires utils lab
    var Color$5 = Color_1;

    var scale$1 = scale$2;

    // nth row of the pascal triangle
    var binom_row = function(n) {
        var row = [1, 1];
        for (var i = 1; i < n; i++) {
            var newrow = [1];
            for (var j = 1; j <= row.length; j++) {
                newrow[j] = (row[j] || 0) + row[j - 1];
            }
            row = newrow;
        }
        return row;
    };

    var bezier = function(colors) {
        var assign, assign$1, assign$2;

        var I, lab0, lab1, lab2;
        colors = colors.map(function (c) { return new Color$5(c); });
        if (colors.length === 2) {
            // linear interpolation
            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length === 3) {
            // quadratic bezier interpolation
            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length === 4) {
            // cubic bezier interpolation
            var lab3;
            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length >= 5) {
            // general case (degree n bezier)
            var labs, row, n;
            labs = colors.map(function (c) { return c.lab(); });
            n = colors.length - 1;
            row = binom_row(n);
            I = function (t) {
                var u = 1 - t;
                var lab = ([0, 1, 2].map(function (i) { return labs.reduce(function (sum, el, j) { return (sum + row[j] * Math.pow( u, (n - j) ) * Math.pow( t, j ) * el[i]); }, 0); }));
                return new Color$5(lab, 'lab');
            };
        } else {
            throw new RangeError("No point in running bezier with only one color.")
        }
        return I;
    };

    var bezier_1 = function (colors) {
        var f = bezier(colors);
        f.scale = function () { return scale$1(f); };
        return f;
    };

    /*
     * interpolates between a set of colors uzing a bezier spline
     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/
     */

    var chroma$3 = chroma_1;

    var blend = function (bottom, top, mode) {
        if (!blend[mode]) {
            throw new Error('unknown blend mode ' + mode);
        }
        return blend[mode](bottom, top);
    };

    var blend_f = function (f) { return function (bottom,top) {
            var c0 = chroma$3(top).rgb();
            var c1 = chroma$3(bottom).rgb();
            return chroma$3.rgb(f(c0, c1));
        }; };

    var each = function (f) { return function (c0, c1) {
            var out = [];
            out[0] = f(c0[0], c1[0]);
            out[1] = f(c0[1], c1[1]);
            out[2] = f(c0[2], c1[2]);
            return out;
        }; };

    var normal = function (a) { return a; };
    var multiply = function (a,b) { return a * b / 255; };
    var darken = function (a,b) { return a > b ? b : a; };
    var lighten = function (a,b) { return a > b ? a : b; };
    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };
    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };
    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };
    var dodge = function (a,b) {
        if (a === 255) { return 255; }
        a = 255 * (b / 255) / (1 - a / 255);
        return a > 255 ? 255 : a
    };

    // # add = (a,b) ->
    // #     if (a + b > 255) then 255 else a + b

    blend.normal = blend_f(each(normal));
    blend.multiply = blend_f(each(multiply));
    blend.screen = blend_f(each(screen));
    blend.overlay = blend_f(each(overlay));
    blend.darken = blend_f(each(darken));
    blend.lighten = blend_f(each(lighten));
    blend.dodge = blend_f(each(dodge));
    blend.burn = blend_f(each(burn));
    // blend.add = blend_f(each(add));

    var blend_1 = blend;

    // cubehelix interpolation
    // based on D.A. Green "A colour scheme for the display of astronomical intensity images"
    // http://astron-soc.in/bulletin/11June/289392011.pdf

    var type$1 = utils.type;
    var clip_rgb = utils.clip_rgb;
    var TWOPI = utils.TWOPI;
    var pow$2 = Math.pow;
    var sin$1 = Math.sin;
    var cos$1 = Math.cos;
    var chroma$2 = chroma_1;

    var cubehelix = function(start, rotations, hue, gamma, lightness) {
        if ( start === void 0 ) start=300;
        if ( rotations === void 0 ) rotations=-1.5;
        if ( hue === void 0 ) hue=1;
        if ( gamma === void 0 ) gamma=1;
        if ( lightness === void 0 ) lightness=[0,1];

        var dh = 0, dl;
        if (type$1(lightness) === 'array') {
            dl = lightness[1] - lightness[0];
        } else {
            dl = 0;
            lightness = [lightness, lightness];
        }

        var f = function(fract) {
            var a = TWOPI * (((start+120)/360) + (rotations * fract));
            var l = pow$2(lightness[0] + (dl * fract), gamma);
            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;
            var amp = (h * l * (1-l)) / 2;
            var cos_a = cos$1(a);
            var sin_a = sin$1(a);
            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));
            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));
            var b = l + (amp * (+1.97294 * cos_a));
            return chroma$2(clip_rgb([r*255,g*255,b*255,1]));
        };

        f.start = function(s) {
            if ((s == null)) { return start; }
            start = s;
            return f;
        };

        f.rotations = function(r) {
            if ((r == null)) { return rotations; }
            rotations = r;
            return f;
        };

        f.gamma = function(g) {
            if ((g == null)) { return gamma; }
            gamma = g;
            return f;
        };

        f.hue = function(h) {
            if ((h == null)) { return hue; }
            hue = h;
            if (type$1(hue) === 'array') {
                dh = hue[1] - hue[0];
                if (dh === 0) { hue = hue[1]; }
            } else {
                dh = 0;
            }
            return f;
        };

        f.lightness = function(h) {
            if ((h == null)) { return lightness; }
            if (type$1(h) === 'array') {
                lightness = h;
                dl = h[1] - h[0];
            } else {
                lightness = [h,h];
                dl = 0;
            }
            return f;
        };

        f.scale = function () { return chroma$2.scale(f); };

        f.hue(hue);

        return f;
    };

    var Color$4 = Color_1;
    var digits = '0123456789abcdef';

    var floor$1 = Math.floor;
    var random = Math.random;

    var random_1 = function () {
        var code = '#';
        for (var i=0; i<6; i++) {
            code += digits.charAt(floor$1(random() * 16));
        }
        return new Color$4(code, 'hex');
    };

    var type = type$p;
    var log = Math.log;
    var pow$1 = Math.pow;
    var floor = Math.floor;
    var abs$1 = Math.abs;


    var analyze = function (data, key) {
        if ( key === void 0 ) key=null;

        var r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE*-1,
            sum: 0,
            values: [],
            count: 0
        };
        if (type(data) === 'object') {
            data = Object.values(data);
        }
        data.forEach(function (val) {
            if (key && type(val) === 'object') { val = val[key]; }
            if (val !== undefined && val !== null && !isNaN(val)) {
                r.values.push(val);
                r.sum += val;
                if (val < r.min) { r.min = val; }
                if (val > r.max) { r.max = val; }
                r.count += 1;
            }
        });

        r.domain = [r.min, r.max];

        r.limits = function (mode, num) { return limits(r, mode, num); };

        return r;
    };


    var limits = function (data, mode, num) {
        if ( mode === void 0 ) mode='equal';
        if ( num === void 0 ) num=7;

        if (type(data) == 'array') {
            data = analyze(data);
        }
        var min = data.min;
        var max = data.max;
        var values = data.values.sort(function (a,b) { return a-b; });

        if (num === 1) { return [min,max]; }

        var limits = [];

        if (mode.substr(0,1) === 'c') { // continuous
            limits.push(min);
            limits.push(max);
        }

        if (mode.substr(0,1) === 'e') { // equal interval
            limits.push(min);
            for (var i=1; i<num; i++) {
                limits.push(min+((i/num)*(max-min)));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'l') { // log scale
            if (min <= 0) {
                throw new Error('Logarithmic scales are only possible for values > 0');
            }
            var min_log = Math.LOG10E * log(min);
            var max_log = Math.LOG10E * log(max);
            limits.push(min);
            for (var i$1=1; i$1<num; i$1++) {
                limits.push(pow$1(10, min_log + ((i$1/num) * (max_log - min_log))));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'q') { // quantile scale
            limits.push(min);
            for (var i$2=1; i$2<num; i$2++) {
                var p = ((values.length-1) * i$2)/num;
                var pb = floor(p);
                if (pb === p) {
                    limits.push(values[pb]);
                } else { // p > pb
                    var pr = p - pb;
                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));
                }
            }
            limits.push(max);

        }

        else if (mode.substr(0,1) === 'k') { // k-means clustering
            /*
            implementation based on
            http://code.google.com/p/figue/source/browse/trunk/figue.js#336
            simplified for 1-d input values
            */
            var cluster;
            var n = values.length;
            var assignments = new Array(n);
            var clusterSizes = new Array(num);
            var repeat = true;
            var nb_iters = 0;
            var centroids = null;

            // get seed values
            centroids = [];
            centroids.push(min);
            for (var i$3=1; i$3<num; i$3++) {
                centroids.push(min + ((i$3/num) * (max-min)));
            }
            centroids.push(max);

            while (repeat) {
                // assignment step
                for (var j=0; j<num; j++) {
                    clusterSizes[j] = 0;
                }
                for (var i$4=0; i$4<n; i$4++) {
                    var value = values[i$4];
                    var mindist = Number.MAX_VALUE;
                    var best = (void 0);
                    for (var j$1=0; j$1<num; j$1++) {
                        var dist = abs$1(centroids[j$1]-value);
                        if (dist < mindist) {
                            mindist = dist;
                            best = j$1;
                        }
                        clusterSizes[best]++;
                        assignments[i$4] = best;
                    }
                }

                // update centroids step
                var newCentroids = new Array(num);
                for (var j$2=0; j$2<num; j$2++) {
                    newCentroids[j$2] = null;
                }
                for (var i$5=0; i$5<n; i$5++) {
                    cluster = assignments[i$5];
                    if (newCentroids[cluster] === null) {
                        newCentroids[cluster] = values[i$5];
                    } else {
                        newCentroids[cluster] += values[i$5];
                    }
                }
                for (var j$3=0; j$3<num; j$3++) {
                    newCentroids[j$3] *= 1/clusterSizes[j$3];
                }

                // check convergence
                repeat = false;
                for (var j$4=0; j$4<num; j$4++) {
                    if (newCentroids[j$4] !== centroids[j$4]) {
                        repeat = true;
                        break;
                    }
                }

                centroids = newCentroids;
                nb_iters++;

                if (nb_iters > 200) {
                    repeat = false;
                }
            }

            // finished k-means clustering
            // the next part is borrowed from gabrielflor.it
            var kClusters = {};
            for (var j$5=0; j$5<num; j$5++) {
                kClusters[j$5] = [];
            }
            for (var i$6=0; i$6<n; i$6++) {
                cluster = assignments[i$6];
                kClusters[cluster].push(values[i$6]);
            }
            var tmpKMeansBreaks = [];
            for (var j$6=0; j$6<num; j$6++) {
                tmpKMeansBreaks.push(kClusters[j$6][0]);
                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);
            }
            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });
            limits.push(tmpKMeansBreaks[0]);
            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {
                var v = tmpKMeansBreaks[i$7];
                if (!isNaN(v) && (limits.indexOf(v) === -1)) {
                    limits.push(v);
                }
            }
        }
        return limits;
    };

    var analyze_1 = {analyze: analyze, limits: limits};

    var Color$3 = Color_1;


    var contrast = function (a, b) {
        // WCAG contrast ratio
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
        a = new Color$3(a);
        b = new Color$3(b);
        var l1 = a.luminance();
        var l2 = b.luminance();
        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
    };

    var Color$2 = Color_1;
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var min = Math.min;
    var max = Math.max;
    var atan2 = Math.atan2;
    var abs = Math.abs;
    var cos = Math.cos;
    var sin = Math.sin;
    var exp = Math.exp;
    var PI = Math.PI;

    var deltaE = function(a, b, Kl, Kc, Kh) {
        if ( Kl === void 0 ) Kl=1;
        if ( Kc === void 0 ) Kc=1;
        if ( Kh === void 0 ) Kh=1;

        // Delta E (CIE 2000)
        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html
        var rad2deg = function(rad) {
            return 360 * rad / (2 * PI);
        };
        var deg2rad = function(deg) {
            return (2 * PI * deg) / 360;
        };
        a = new Color$2(a);
        b = new Color$2(b);
        var ref = Array.from(a.lab());
        var L1 = ref[0];
        var a1 = ref[1];
        var b1 = ref[2];
        var ref$1 = Array.from(b.lab());
        var L2 = ref$1[0];
        var a2 = ref$1[1];
        var b2 = ref$1[2];
        var avgL = (L1 + L2)/2;
        var C1 = sqrt(pow(a1, 2) + pow(b1, 2));
        var C2 = sqrt(pow(a2, 2) + pow(b2, 2));
        var avgC = (C1 + C2)/2;
        var G = 0.5*(1-sqrt(pow(avgC, 7)/(pow(avgC, 7) + pow(25, 7))));
        var a1p = a1*(1+G);
        var a2p = a2*(1+G);
        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));
        var C2p = sqrt(pow(a2p, 2) + pow(b2, 2));
        var avgCp = (C1p + C2p)/2;
        var arctan1 = rad2deg(atan2(b1, a1p));
        var arctan2 = rad2deg(atan2(b2, a2p));
        var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
        var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
        var avgHp = abs(h1p - h2p) > 180 ? (h1p + h2p + 360)/2 : (h1p + h2p)/2;
        var T = 1 - 0.17*cos(deg2rad(avgHp - 30)) + 0.24*cos(deg2rad(2*avgHp)) + 0.32*cos(deg2rad(3*avgHp + 6)) - 0.2*cos(deg2rad(4*avgHp - 63));
        var deltaHp = h2p - h1p;
        deltaHp = abs(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
        deltaHp = 2*sqrt(C1p*C2p)*sin(deg2rad(deltaHp)/2);
        var deltaL = L2 - L1;
        var deltaCp = C2p - C1p;    
        var sl = 1 + (0.015*pow(avgL - 50, 2))/sqrt(20 + pow(avgL - 50, 2));
        var sc = 1 + 0.045*avgCp;
        var sh = 1 + 0.015*avgCp*T;
        var deltaTheta = 30*exp(-pow((avgHp - 275)/25, 2));
        var Rc = 2*sqrt(pow(avgCp, 7)/(pow(avgCp, 7) + pow(25, 7)));
        var Rt = -Rc*sin(2*deg2rad(deltaTheta));
        var result = sqrt(pow(deltaL/(Kl*sl), 2) + pow(deltaCp/(Kc*sc), 2) + pow(deltaHp/(Kh*sh), 2) + Rt*(deltaCp/(Kc*sc))*(deltaHp/(Kh*sh)));
        return max(0, min(100, result));
    };

    var Color$1 = Color_1;

    // simple Euclidean distance
    var distance = function(a, b, mode) {
        if ( mode === void 0 ) mode='lab';

        // Delta E (CIE 1976)
        // see http://www.brucelindbloom.com/index.html?Equations.html
        a = new Color$1(a);
        b = new Color$1(b);
        var l1 = a.get(mode);
        var l2 = b.get(mode);
        var sum_sq = 0;
        for (var i in l1) {
            var d = (l1[i] || 0) - (l2[i] || 0);
            sum_sq += d*d;
        }
        return Math.sqrt(sum_sq);
    };

    var Color = Color_1;

    var valid = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        try {
            new (Function.prototype.bind.apply( Color, [ null ].concat( args) ));
            return true;
        } catch (e) {
            return false;
        }
    };

    // some pre-defined color scales:
    var chroma$1 = chroma_1;

    var scale = scale$2;

    var scales = {
    	cool: function cool() { return scale([chroma$1.hsl(180,1,.9), chroma$1.hsl(250,.7,.4)]) },
    	hot: function hot() { return scale(['#000','#f00','#ff0','#fff']).mode('rgb') }
    };

    /**
        ColorBrewer colors for chroma.js

        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
        Pennsylvania State University.

        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing, software distributed
        under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
        CONDITIONS OF ANY KIND, either express or implied. See the License for the
        specific language governing permissions and limitations under the License.
    */

    var colorbrewer = {
        // sequential
        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],

        // diverging

        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],

        // qualitative

        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
    };

    // add lowercase aliases for case-insensitive matches
    for (var i = 0, list = Object.keys(colorbrewer); i < list.length; i += 1) {
        var key = list[i];

        colorbrewer[key.toLowerCase()] = colorbrewer[key];
    }

    var colorbrewer_1 = colorbrewer;

    var chroma = chroma_1;

    // feel free to comment out anything to rollup
    // a smaller chroma.js built

    // io --> convert colors

















    // operators --> modify existing Colors










    // interpolators












    // generators -- > create new colors
    chroma.average = average;
    chroma.bezier = bezier_1;
    chroma.blend = blend_1;
    chroma.cubehelix = cubehelix;
    chroma.mix = chroma.interpolate = mix$1;
    chroma.random = random_1;
    chroma.scale = scale$2;

    // other utility methods
    chroma.analyze = analyze_1.analyze;
    chroma.contrast = contrast;
    chroma.deltaE = deltaE;
    chroma.distance = distance;
    chroma.limits = analyze_1.limits;
    chroma.valid = valid;

    // scale
    chroma.scales = scales;

    // colors
    chroma.colors = w3cx11_1;
    chroma.brewer = colorbrewer_1;

    var chroma_js = chroma;

    return chroma_js;

}));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			179: 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// UNUSED EXPORTS: default

// EXTERNAL MODULE: ./public/JetBrainsMono-Regular.ttf
var JetBrainsMono_Regular = __webpack_require__(2578);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(3379);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(7795);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(569);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(3565);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(9216);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(4589);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./public/style.css
var style = __webpack_require__(8563);
;// CONCATENATED MODULE: ./public/style.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(style/* default */.Z, options);




       /* harmony default export */ const public_style = (style/* default */.Z && style/* default */.Z.locals ? style/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/utils.js
/** @returns {void} */
function utils_noop() {}

const identity = (x) => x;

/**
 * @template T
 * @template S
 * @param {T} tar
 * @param {S} src
 * @returns {T & S}
 */
function utils_assign(tar, src) {
	// @ts-ignore
	for (const k in src) tar[k] = src[k];
	return /** @type {T & S} */ (tar);
}

// Adapted from https://github.com/then/is-promise/blob/master/index.js
// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE
/**
 * @param {any} value
 * @returns {value is PromiseLike<any>}
 */
function utils_is_promise(value) {
	return (
		!!value &&
		(typeof value === 'object' || typeof value === 'function') &&
		typeof (/** @type {any} */ (value).then) === 'function'
	);
}

/** @returns {void} */
function add_location(element, file, line, column, char) {
	element.__svelte_meta = {
		loc: { file, line, column, char }
	};
}

function run(fn) {
	return fn();
}

function utils_blank_object() {
	return Object.create(null);
}

/**
 * @param {Function[]} fns
 * @returns {void}
 */
function utils_run_all(fns) {
	fns.forEach(run);
}

/**
 * @param {any} thing
 * @returns {thing is Function}
 */
function utils_is_function(thing) {
	return typeof thing === 'function';
}

/** @returns {boolean} */
function safe_not_equal(a, b) {
	return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';
}

let src_url_equal_anchor;

/** @returns {boolean} */
function src_url_equal(element_src, url) {
	if (!src_url_equal_anchor) {
		src_url_equal_anchor = document.createElement('a');
	}
	src_url_equal_anchor.href = url;
	return element_src === src_url_equal_anchor.href;
}

/** @returns {boolean} */
function not_equal(a, b) {
	return a != a ? b == b : a !== b;
}

/** @returns {boolean} */
function is_empty(obj) {
	return Object.keys(obj).length === 0;
}

/** @returns {void} */
function validate_store(store, name) {
	if (store != null && typeof store.subscribe !== 'function') {
		throw new Error(`'${name}' is not a store with a 'subscribe' method`);
	}
}

function utils_subscribe(store, ...callbacks) {
	if (store == null) {
		for (const callback of callbacks) {
			callback(undefined);
		}
		return utils_noop;
	}
	const unsub = store.subscribe(...callbacks);
	return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}

/**
 * Get the current value from a store by subscribing and immediately unsubscribing.
 *
 * https://svelte.dev/docs/svelte-store#get
 * @template T
 * @param {import('../store/public.js').Readable<T>} store
 * @returns {T}
 */
function get_store_value(store) {
	let value;
	utils_subscribe(store, (_) => (value = _))();
	return value;
}

/** @returns {void} */
function component_subscribe(component, store, callback) {
	component.$$.on_destroy.push(utils_subscribe(store, callback));
}

function create_slot(definition, ctx, $$scope, fn) {
	if (definition) {
		const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
		return definition[0](slot_ctx);
	}
}

function get_slot_context(definition, ctx, $$scope, fn) {
	return definition[1] && fn ? utils_assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}

function get_slot_changes(definition, $$scope, dirty, fn) {
	if (definition[2] && fn) {
		const lets = definition[2](fn(dirty));
		if ($$scope.dirty === undefined) {
			return lets;
		}
		if (typeof lets === 'object') {
			const merged = [];
			const len = Math.max($$scope.dirty.length, lets.length);
			for (let i = 0; i < len; i += 1) {
				merged[i] = $$scope.dirty[i] | lets[i];
			}
			return merged;
		}
		return $$scope.dirty | lets;
	}
	return $$scope.dirty;
}

/** @returns {void} */
function update_slot_base(
	slot,
	slot_definition,
	ctx,
	$$scope,
	slot_changes,
	get_slot_context_fn
) {
	if (slot_changes) {
		const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
		slot.p(slot_context, slot_changes);
	}
}

/** @returns {void} */
function update_slot(
	slot,
	slot_definition,
	ctx,
	$$scope,
	dirty,
	get_slot_changes_fn,
	get_slot_context_fn
) {
	const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
	update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
}

/** @returns {any[] | -1} */
function get_all_dirty_from_scope($$scope) {
	if ($$scope.ctx.length > 32) {
		const dirty = [];
		const length = $$scope.ctx.length / 32;
		for (let i = 0; i < length; i++) {
			dirty[i] = -1;
		}
		return dirty;
	}
	return -1;
}

/** @returns {{}} */
function exclude_internal_props(props) {
	const result = {};
	for (const k in props) if (k[0] !== '$') result[k] = props[k];
	return result;
}

/** @returns {{}} */
function compute_rest_props(props, keys) {
	const rest = {};
	keys = new Set(keys);
	for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];
	return rest;
}

/** @returns {{}} */
function compute_slots(slots) {
	const result = {};
	for (const key in slots) {
		result[key] = true;
	}
	return result;
}

/** @returns {(this: any, ...args: any[]) => void} */
function once(fn) {
	let ran = false;
	return function (...args) {
		if (ran) return;
		ran = true;
		fn.call(this, ...args);
	};
}

function null_to_empty(value) {
	return value == null ? '' : value;
}

function set_store_value(store, ret, value) {
	store.set(value);
	return ret;
}

const utils_has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

function action_destroyer(action_result) {
	return action_result && utils_is_function(action_result.destroy) ? action_result.destroy : utils_noop;
}

/** @param {number | string} value
 * @returns {[number, string]}
 */
function utils_split_css_unit(value) {
	const split = typeof value === 'string' && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
	return split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];
}

const utils_contenteditable_truthy_values = (/* unused pure expression or super */ null && (['', true, 1, 'true', 'contenteditable']));

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/environment.js


const is_client = typeof window !== 'undefined';

/** @type {() => number} */
let environment_now = is_client ? () => window.performance.now() : () => Date.now();

let raf = is_client ? (cb) => requestAnimationFrame(cb) : utils_noop;

// used internally for testing
/** @returns {void} */
function set_now(fn) {
	environment_now = fn;
}

/** @returns {void} */
function set_raf(fn) {
	raf = fn;
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/loop.js


const tasks = new Set();

/**
 * @param {number} now
 * @returns {void}
 */
function run_tasks(now) {
	tasks.forEach((task) => {
		if (!task.c(now)) {
			tasks.delete(task);
			task.f();
		}
	});
	if (tasks.size !== 0) raf(run_tasks);
}

/**
 * For testing purposes only!
 * @returns {void}
 */
function clear_loops() {
	tasks.clear();
}

/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 * @param {import('./private.js').TaskCallback} callback
 * @returns {import('./private.js').Task}
 */
function loop_loop(callback) {
	/** @type {import('./private.js').TaskEntry} */
	let task;
	if (tasks.size === 0) raf(run_tasks);
	return {
		promise: new Promise((fulfill) => {
			tasks.add((task = { c: callback, f: fulfill }));
		}),
		abort() {
			tasks.delete(task);
		}
	};
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/globals.js
/** @type {typeof globalThis} */
const globals =
	typeof window !== 'undefined'
		? window
		: typeof globalThis !== 'undefined'
		? globalThis
		: // @ts-ignore Node typings have this
		  global;

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js


/**
 * Resize observer singleton.
 * One listener per element only!
 * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ
 */
class ResizeObserverSingleton {
	/**
	 * @private
	 * @readonly
	 * @type {WeakMap<Element, import('./private.js').Listener>}
	 */
	_listeners = "WeakMap" in globals ? new WeakMap() : undefined;

	/**
	 * @private
	 * @type {ResizeObserver}
	 */
	_observer = undefined;

	/** @type {ResizeObserverOptions} */
	options;

	/** @param {ResizeObserverOptions} options */
	constructor(options) {
		this.options = options;
	}

	/**
	 * @param {Element} element
	 * @param {import('./private.js').Listener} listener
	 * @returns {() => void}
	 */
	observe(element, listener) {
		this._listeners.set(element, listener);
		this._getObserver().observe(element, this.options);
		return () => {
			this._listeners.delete(element);
			this._observer.unobserve(element); // this line can probably be removed
		};
	}

	/**
	 * @private
	 */
	_getObserver() {
		return (
			this._observer ??
			(this._observer = new ResizeObserver((entries) => {
				for (const entry of entries) {
					ResizeObserverSingleton.entries.set(entry.target, entry);
					this._listeners.get(entry.target)?.(entry);
				}
			}))
		);
	}
}

// Needs to be written like this to pass the tree-shake-test
ResizeObserverSingleton.entries = "WeakMap" in globals ? new WeakMap() : undefined;

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/dom.js


// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
// at the end of hydration without touching the remaining nodes.
let is_hydrating = false;

/**
 * @returns {void}
 */
function start_hydrating() {
	is_hydrating = true;
}

/**
 * @returns {void}
 */
function end_hydrating() {
	is_hydrating = false;
}

/**
 * @param {number} low
 * @param {number} high
 * @param {(index: number) => number} key
 * @param {number} value
 * @returns {number}
 */
function upper_bound(low, high, key, value) {
	// Return first index of value larger than input value in the range [low, high)
	while (low < high) {
		const mid = low + ((high - low) >> 1);
		if (key(mid) <= value) {
			low = mid + 1;
		} else {
			high = mid;
		}
	}
	return low;
}

/**
 * @param {NodeEx} target
 * @returns {void}
 */
function init_hydrate(target) {
	if (target.hydrate_init) return;
	target.hydrate_init = true;
	// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>

	let children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);
	// If target is <head>, there may be children without claim_order
	if (target.nodeName === 'HEAD') {
		const myChildren = [];
		for (let i = 0; i < children.length; i++) {
			const node = children[i];
			if (node.claim_order !== undefined) {
				myChildren.push(node);
			}
		}
		children = myChildren;
	}
	/*
	 * Reorder claimed children optimally.
	 * We can reorder claimed children optimally by finding the longest subsequence of
	 * nodes that are already claimed in order and only moving the rest. The longest
	 * subsequence of nodes that are claimed in order can be found by
	 * computing the longest increasing subsequence of .claim_order values.
	 *
	 * This algorithm is optimal in generating the least amount of reorder operations
	 * possible.
	 *
	 * Proof:
	 * We know that, given a set of reordering operations, the nodes that do not move
	 * always form an increasing subsequence, since they do not move among each other
	 * meaning that they must be already ordered among each other. Thus, the maximal
	 * set of nodes that do not move form a longest increasing subsequence.
	 */
	// Compute longest increasing subsequence
	// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
	const m = new Int32Array(children.length + 1);
	// Predecessor indices + 1
	const p = new Int32Array(children.length);
	m[0] = -1;
	let longest = 0;
	for (let i = 0; i < children.length; i++) {
		const current = children[i].claim_order;
		// Find the largest subsequence length such that it ends in a value less than our current value
		// upper_bound returns first greater value, so we subtract one
		// with fast path for when we are on the current longest subsequence
		const seqLen =
			(longest > 0 && children[m[longest]].claim_order <= current
				? longest + 1
				: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;
		p[i] = m[seqLen] + 1;
		const newLen = seqLen + 1;
		// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
		m[newLen] = i;
		longest = Math.max(newLen, longest);
	}
	// The longest increasing subsequence of nodes (initially reversed)

	/**
	 * @type {NodeEx2[]}
	 */
	const lis = [];
	// The rest of the nodes, nodes that will be moved

	/**
	 * @type {NodeEx2[]}
	 */
	const toMove = [];
	let last = children.length - 1;
	for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
		lis.push(children[cur - 1]);
		for (; last >= cur; last--) {
			toMove.push(children[last]);
		}
		last--;
	}
	for (; last >= 0; last--) {
		toMove.push(children[last]);
	}
	lis.reverse();
	// We sort the nodes being moved to guarantee that their insertion order matches the claim order
	toMove.sort((a, b) => a.claim_order - b.claim_order);
	// Finally, we move the nodes
	for (let i = 0, j = 0; i < toMove.length; i++) {
		while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
			j++;
		}
		const anchor = j < lis.length ? lis[j] : null;
		target.insertBefore(toMove[i], anchor);
	}
}

/**
 * @param {Node} target
 * @param {Node} node
 * @returns {void}
 */
function append(target, node) {
	target.appendChild(node);
}

/**
 * @param {Node} target
 * @param {string} style_sheet_id
 * @param {string} styles
 * @returns {void}
 */
function append_styles(target, style_sheet_id, styles) {
	const append_styles_to = get_root_for_style(target);
	if (!append_styles_to.getElementById(style_sheet_id)) {
		const style = dom_element('style');
		style.id = style_sheet_id;
		style.textContent = styles;
		append_stylesheet(append_styles_to, style);
	}
}

/**
 * @param {Node} node
 * @returns {ShadowRoot | Document}
 */
function get_root_for_style(node) {
	if (!node) return document;
	const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
	if (root && /** @type {ShadowRoot} */ (root).host) {
		return /** @type {ShadowRoot} */ (root);
	}
	return node.ownerDocument;
}

/**
 * @param {Node} node
 * @returns {CSSStyleSheet}
 */
function append_empty_stylesheet(node) {
	const style_element = dom_element('style');
	// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,
	// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.
	// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.
	// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.
	// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.
	style_element.textContent = '/* empty */';
	append_stylesheet(get_root_for_style(node), style_element);
	return style_element.sheet;
}

/**
 * @param {ShadowRoot | Document} node
 * @param {HTMLStyleElement} style
 * @returns {CSSStyleSheet}
 */
function append_stylesheet(node, style) {
	append(/** @type {Document} */ (node).head || node, style);
	return style.sheet;
}

/**
 * @param {NodeEx} target
 * @param {NodeEx} node
 * @returns {void}
 */
function dom_append_hydration(target, node) {
	if (is_hydrating) {
		init_hydrate(target);
		if (
			target.actual_end_child === undefined ||
			(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)
		) {
			target.actual_end_child = target.firstChild;
		}
		// Skip nodes of undefined ordering
		while (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {
			target.actual_end_child = target.actual_end_child.nextSibling;
		}
		if (node !== target.actual_end_child) {
			// We only insert if the ordering of this node should be modified or the parent node is not target
			if (node.claim_order !== undefined || node.parentNode !== target) {
				target.insertBefore(node, target.actual_end_child);
			}
		} else {
			target.actual_end_child = node.nextSibling;
		}
	} else if (node.parentNode !== target || node.nextSibling !== null) {
		target.appendChild(node);
	}
}

/**
 * @param {Node} target
 * @param {Node} node
 * @param {Node} [anchor]
 * @returns {void}
 */
function insert(target, node, anchor) {
	target.insertBefore(node, anchor || null);
}

/**
 * @param {NodeEx} target
 * @param {NodeEx} node
 * @param {NodeEx} [anchor]
 * @returns {void}
 */
function dom_insert_hydration(target, node, anchor) {
	if (is_hydrating && !anchor) {
		dom_append_hydration(target, node);
	} else if (node.parentNode !== target || node.nextSibling != anchor) {
		target.insertBefore(node, anchor || null);
	}
}

/**
 * @param {Node} node
 * @returns {void}
 */
function detach(node) {
	if (node.parentNode) {
		node.parentNode.removeChild(node);
	}
}

/**
 * @returns {void} */
function destroy_each(iterations, detaching) {
	for (let i = 0; i < iterations.length; i += 1) {
		if (iterations[i]) iterations[i].d(detaching);
	}
}

/**
 * @template {keyof HTMLElementTagNameMap} K
 * @param {K} name
 * @returns {HTMLElementTagNameMap[K]}
 */
function dom_element(name) {
	return document.createElement(name);
}

/**
 * @template {keyof HTMLElementTagNameMap} K
 * @param {K} name
 * @param {string} is
 * @returns {HTMLElementTagNameMap[K]}
 */
function element_is(name, is) {
	return document.createElement(name, { is });
}

/**
 * @template T
 * @template {keyof T} K
 * @param {T} obj
 * @param {K[]} exclude
 * @returns {Pick<T, Exclude<keyof T, K>>}
 */
function object_without_properties(obj, exclude) {
	const target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});
	for (const k in obj) {
		if (
			has_prop(obj, k) &&
			// @ts-ignore
			exclude.indexOf(k) === -1
		) {
			// @ts-ignore
			target[k] = obj[k];
		}
	}
	return target;
}

/**
 * @template {keyof SVGElementTagNameMap} K
 * @param {K} name
 * @returns {SVGElement}
 */
function svg_element(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

/**
 * @param {string} data
 * @returns {Text}
 */
function dom_text(data) {
	return document.createTextNode(data);
}

/**
 * @returns {Text} */
function space() {
	return dom_text(' ');
}

/**
 * @returns {Text} */
function empty() {
	return dom_text('');
}

/**
 * @param {string} content
 * @returns {Comment}
 */
function comment(content) {
	return document.createComment(content);
}

/**
 * @param {EventTarget} node
 * @param {string} event
 * @param {EventListenerOrEventListenerObject} handler
 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
 * @returns {() => void}
 */
function listen(node, event, handler, options) {
	node.addEventListener(event, handler, options);
	return () => node.removeEventListener(event, handler, options);
}

/**
 * @returns {(event: any) => any} */
function prevent_default(fn) {
	return function (event) {
		event.preventDefault();
		// @ts-ignore
		return fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => any} */
function stop_propagation(fn) {
	return function (event) {
		event.stopPropagation();
		// @ts-ignore
		return fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => any} */
function stop_immediate_propagation(fn) {
	return function (event) {
		event.stopImmediatePropagation();
		// @ts-ignore
		return fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => void} */
function dom_self(fn) {
	return function (event) {
		// @ts-ignore
		if (event.target === this) fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => void} */
function trusted(fn) {
	return function (event) {
		// @ts-ignore
		if (event.isTrusted) fn.call(this, event);
	};
}

/**
 * @param {Element} node
 * @param {string} attribute
 * @param {string} [value]
 * @returns {void}
 */
function attr(node, attribute, value) {
	if (value == null) node.removeAttribute(attribute);
	else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
/**
 * List of attributes that should always be set through the attr method,
 * because updating them through the property setter doesn't work reliably.
 * In the example of `width`/`height`, the problem is that the setter only
 * accepts numeric values, but the attribute can also be set to a string like `50%`.
 * If this list becomes too big, rethink this approach.
 */
const always_set_through_set_attribute = (/* unused pure expression or super */ null && (['width', 'height']));

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {{ [x: string]: string }} attributes
 * @returns {void}
 */
function set_attributes(node, attributes) {
	// @ts-ignore
	const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
	for (const key in attributes) {
		if (attributes[key] == null) {
			node.removeAttribute(key);
		} else if (key === 'style') {
			node.style.cssText = attributes[key];
		} else if (key === '__value') {
			/** @type {any} */ (node).value = node[key] = attributes[key];
		} else if (
			descriptors[key] &&
			descriptors[key].set &&
			always_set_through_set_attribute.indexOf(key) === -1
		) {
			node[key] = attributes[key];
		} else {
			attr(node, key, attributes[key]);
		}
	}
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {{ [x: string]: string }} attributes
 * @returns {void}
 */
function set_svg_attributes(node, attributes) {
	for (const key in attributes) {
		attr(node, key, attributes[key]);
	}
}

/**
 * @param {Record<string, unknown>} data_map
 * @returns {void}
 */
function set_custom_element_data_map(node, data_map) {
	Object.keys(data_map).forEach((key) => {
		set_custom_element_data(node, key, data_map[key]);
	});
}

/**
 * @returns {void} */
function set_custom_element_data(node, prop, value) {
	if (prop in node) {
		node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
	} else {
		attr(node, prop, value);
	}
}

/**
 * @param {string} tag
 */
function set_dynamic_element_data(tag) {
	return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
}

/**
 * @returns {void}
 */
function xlink_attr(node, attribute, value) {
	node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}

/**
 * @param {HTMLElement} node
 * @returns {string}
 */
function get_svelte_dataset(node) {
	return node.dataset.svelteH;
}

/**
 * @returns {unknown[]} */
function get_binding_group_value(group, __value, checked) {
	const value = new Set();
	for (let i = 0; i < group.length; i += 1) {
		if (group[i].checked) value.add(group[i].__value);
	}
	if (!checked) {
		value.delete(__value);
	}
	return Array.from(value);
}

/**
 * @param {HTMLInputElement[]} group
 * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}
 */
function init_binding_group(group) {
	/**
	 * @type {HTMLInputElement[]} */
	let _inputs;
	return {
		/* push */ p(...inputs) {
			_inputs = inputs;
			_inputs.forEach((input) => group.push(input));
		},
		/* remove */ r() {
			_inputs.forEach((input) => group.splice(group.indexOf(input), 1));
		}
	};
}

/**
 * @param {number[]} indexes
 * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}
 */
function init_binding_group_dynamic(group, indexes) {
	/**
	 * @type {HTMLInputElement[]} */
	let _group = get_binding_group(group);

	/**
	 * @type {HTMLInputElement[]} */
	let _inputs;

	function get_binding_group(group) {
		for (let i = 0; i < indexes.length; i++) {
			group = group[indexes[i]] = group[indexes[i]] || [];
		}
		return group;
	}

	/**
	 * @returns {void} */
	function push() {
		_inputs.forEach((input) => _group.push(input));
	}

	/**
	 * @returns {void} */
	function remove() {
		_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));
	}
	return {
		/* update */ u(new_indexes) {
			indexes = new_indexes;
			const new_group = get_binding_group(group);
			if (new_group !== _group) {
				remove();
				_group = new_group;
				push();
			}
		},
		/* push */ p(...inputs) {
			_inputs = inputs;
			push();
		},
		/* remove */ r: remove
	};
}

/**
 * @returns {number} */
function to_number(value) {
	return value === '' ? null : +value;
}

/**
 * @returns {any[]} */
function time_ranges_to_array(ranges) {
	const array = [];
	for (let i = 0; i < ranges.length; i += 1) {
		array.push({ start: ranges.start(i), end: ranges.end(i) });
	}
	return array;
}

/**
 * @param {Element} element
 * @returns {ChildNode[]}
 */
function children(element) {
	return Array.from(element.childNodes);
}

/**
 * @param {ChildNodeArray} nodes
 * @returns {void}
 */
function init_claim_info(nodes) {
	if (nodes.claim_info === undefined) {
		nodes.claim_info = { last_index: 0, total_claimed: 0 };
	}
}

/**
 * @template {ChildNodeEx} R
 * @param {ChildNodeArray} nodes
 * @param {(node: ChildNodeEx) => node is R} predicate
 * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} processNode
 * @param {() => R} createNode
 * @param {boolean} dontUpdateLastIndex
 * @returns {R}
 */
function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
	// Try to find nodes in an order such that we lengthen the longest increasing subsequence
	init_claim_info(nodes);
	const resultNode = (() => {
		// We first try to find an element after the previous one
		for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {
			const node = nodes[i];
			if (predicate(node)) {
				const replacement = processNode(node);
				if (replacement === undefined) {
					nodes.splice(i, 1);
				} else {
					nodes[i] = replacement;
				}
				if (!dontUpdateLastIndex) {
					nodes.claim_info.last_index = i;
				}
				return node;
			}
		}
		// Otherwise, we try to find one before
		// We iterate in reverse so that we don't go too far back
		for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {
			const node = nodes[i];
			if (predicate(node)) {
				const replacement = processNode(node);
				if (replacement === undefined) {
					nodes.splice(i, 1);
				} else {
					nodes[i] = replacement;
				}
				if (!dontUpdateLastIndex) {
					nodes.claim_info.last_index = i;
				} else if (replacement === undefined) {
					// Since we spliced before the last_index, we decrease it
					nodes.claim_info.last_index--;
				}
				return node;
			}
		}
		// If we can't find any matching node, we create a new one
		return createNode();
	})();
	resultNode.claim_order = nodes.claim_info.total_claimed;
	nodes.claim_info.total_claimed += 1;
	return resultNode;
}

/**
 * @param {ChildNodeArray} nodes
 * @param {string} name
 * @param {{ [key: string]: boolean }} attributes
 * @param {(name: string) => Element | SVGElement} create_element
 * @returns {Element | SVGElement}
 */
function claim_element_base(nodes, name, attributes, create_element) {
	return claim_node(
		nodes,
		/** @returns {node is Element | SVGElement} */
		(node) => node.nodeName === name,
		/** @param {Element} node */
		(node) => {
			const remove = [];
			for (let j = 0; j < node.attributes.length; j++) {
				const attribute = node.attributes[j];
				if (!attributes[attribute.name]) {
					remove.push(attribute.name);
				}
			}
			remove.forEach((v) => node.removeAttribute(v));
			return undefined;
		},
		() => create_element(name)
	);
}

/**
 * @param {ChildNodeArray} nodes
 * @param {string} name
 * @param {{ [key: string]: boolean }} attributes
 * @returns {Element | SVGElement}
 */
function claim_element(nodes, name, attributes) {
	return claim_element_base(nodes, name, attributes, dom_element);
}

/**
 * @param {ChildNodeArray} nodes
 * @param {string} name
 * @param {{ [key: string]: boolean }} attributes
 * @returns {Element | SVGElement}
 */
function claim_svg_element(nodes, name, attributes) {
	return claim_element_base(nodes, name, attributes, svg_element);
}

/**
 * @param {ChildNodeArray} nodes
 * @returns {Text}
 */
function claim_text(nodes, data) {
	return claim_node(
		nodes,
		/** @returns {node is Text} */
		(node) => node.nodeType === 3,
		/** @param {Text} node */
		(node) => {
			const dataStr = '' + data;
			if (node.data.startsWith(dataStr)) {
				if (node.data.length !== dataStr.length) {
					return node.splitText(dataStr.length);
				}
			} else {
				node.data = dataStr;
			}
		},
		() => dom_text(data),
		true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements
	);
}

/**
 * @returns {Text} */
function claim_space(nodes) {
	return claim_text(nodes, ' ');
}

/**
 * @param {ChildNodeArray} nodes
 * @returns {Comment}
 */
function claim_comment(nodes, data) {
	return claim_node(
		nodes,
		/** @returns {node is Comment} */
		(node) => node.nodeType === 8,
		/** @param {Comment} node */
		(node) => {
			node.data = '' + data;
			return undefined;
		},
		() => comment(data),
		true
	);
}

function find_comment(nodes, text, start) {
	for (let i = start; i < nodes.length; i += 1) {
		const node = nodes[i];
		if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {
			return i;
		}
	}
	return nodes.length;
}

/**
 * @param {boolean} is_svg
 * @returns {HtmlTagHydration}
 */
function claim_html_tag(nodes, is_svg) {
	// find html opening tag
	const start_index = find_comment(nodes, 'HTML_TAG_START', 0);
	const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);
	if (start_index === end_index) {
		return new HtmlTagHydration(undefined, is_svg);
	}
	init_claim_info(nodes);
	const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);
	detach(html_tag_nodes[0]);
	detach(html_tag_nodes[html_tag_nodes.length - 1]);
	const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
	for (const n of claimed_nodes) {
		n.claim_order = nodes.claim_info.total_claimed;
		nodes.claim_info.total_claimed += 1;
	}
	return new HtmlTagHydration(claimed_nodes, is_svg);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data(text, data) {
	data = '' + data;
	if (text.data === data) return;
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data_contenteditable(text, data) {
	data = '' + data;
	if (text.wholeText === data) return;
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @param {string} attr_value
 * @returns {void}
 */
function set_data_maybe_contenteditable(text, data, attr_value) {
	if (~contenteditable_truthy_values.indexOf(attr_value)) {
		set_data_contenteditable(text, data);
	} else {
		set_data(text, data);
	}
}

/**
 * @returns {void} */
function set_input_value(input, value) {
	input.value = value == null ? '' : value;
}

/**
 * @returns {void} */
function set_input_type(input, type) {
	try {
		input.type = type;
	} catch (e) {
		// do nothing
	}
}

/**
 * @returns {void} */
function set_style(node, key, value, important) {
	if (value == null) {
		node.style.removeProperty(key);
	} else {
		node.style.setProperty(key, value, important ? 'important' : '');
	}
}

/**
 * @returns {void} */
function select_option(select, value, mounting) {
	for (let i = 0; i < select.options.length; i += 1) {
		const option = select.options[i];
		if (option.__value === value) {
			option.selected = true;
			return;
		}
	}
	if (!mounting || value !== undefined) {
		select.selectedIndex = -1; // no option should be selected
	}
}

/**
 * @returns {void} */
function select_options(select, value) {
	for (let i = 0; i < select.options.length; i += 1) {
		const option = select.options[i];
		option.selected = ~value.indexOf(option.__value);
	}
}

function select_value(select) {
	const selected_option = select.querySelector(':checked');
	return selected_option && selected_option.__value;
}

function select_multiple_value(select) {
	return [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead

/**
 * @type {boolean} */
let crossorigin;

/**
 * @returns {boolean} */
function is_crossorigin() {
	if (crossorigin === undefined) {
		crossorigin = false;
		try {
			if (typeof window !== 'undefined' && window.parent) {
				void window.parent.document;
			}
		} catch (error) {
			crossorigin = true;
		}
	}
	return crossorigin;
}

/**
 * @param {HTMLElement} node
 * @param {() => void} fn
 * @returns {() => void}
 */
function add_iframe_resize_listener(node, fn) {
	const computed_style = getComputedStyle(node);
	if (computed_style.position === 'static') {
		node.style.position = 'relative';
	}
	const iframe = dom_element('iframe');
	iframe.setAttribute(
		'style',
		'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
			'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'
	);
	iframe.setAttribute('aria-hidden', 'true');
	iframe.tabIndex = -1;
	const crossorigin = is_crossorigin();

	/**
	 * @type {() => void}
	 */
	let unsubscribe;
	if (crossorigin) {
		iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
		unsubscribe = listen(
			window,
			'message',
			/** @param {MessageEvent} event */ (event) => {
				if (event.source === iframe.contentWindow) fn();
			}
		);
	} else {
		iframe.src = 'about:blank';
		iframe.onload = () => {
			unsubscribe = listen(iframe.contentWindow, 'resize', fn);
			// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)
			// see https://github.com/sveltejs/svelte/issues/4233
			fn();
		};
	}
	append(node, iframe);
	return () => {
		if (crossorigin) {
			unsubscribe();
		} else if (unsubscribe && iframe.contentWindow) {
			unsubscribe();
		}
		detach(iframe);
	};
}
const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
	box: 'content-box'
});
const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({
	box: 'border-box'
});
const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(
	{ box: 'device-pixel-content-box' }
);


/**
 * @returns {void} */
function toggle_class(element, name, toggle) {
	// The `!!` is required because an `undefined` flag means flipping the current state.
	element.classList.toggle(name, !!toggle);
}

/**
 * @template T
 * @param {string} type
 * @param {T} [detail]
 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
 * @returns {CustomEvent<T>}
 */
function dom_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
	return new CustomEvent(type, { detail, bubbles, cancelable });
}

/**
 * @param {string} selector
 * @param {HTMLElement} parent
 * @returns {ChildNodeArray}
 */
function query_selector_all(selector, parent = document.body) {
	return Array.from(parent.querySelectorAll(selector));
}

/**
 * @param {string} nodeId
 * @param {HTMLElement} head
 * @returns {any[]}
 */
function head_selector(nodeId, head) {
	const result = [];
	let started = 0;
	for (const node of head.childNodes) {
		if (node.nodeType === 8 /* comment node */) {
			const comment = node.textContent.trim();
			if (comment === `HEAD_${nodeId}_END`) {
				started -= 1;
				result.push(node);
			} else if (comment === `HEAD_${nodeId}_START`) {
				started += 1;
				result.push(node);
			}
		} else if (started > 0) {
			result.push(node);
		}
	}
	return result;
}
/** */
class HtmlTag {
	/**
	 * @private
	 * @default false
	 */
	is_svg = false;
	// parent for creating node
	/** */
	e = undefined;
	// html tag nodes
	/** */
	n = undefined;
	// target
	/** */
	t = undefined;
	// anchor
	/** */
	a = undefined;
	constructor(is_svg = false) {
		this.is_svg = is_svg;
		this.e = this.n = null;
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	c(html) {
		this.h(html);
	}

	/**
	 * @param {string} html
	 * @param {HTMLElement | SVGElement} target
	 * @param {HTMLElement | SVGElement} anchor
	 * @returns {void}
	 */
	m(html, target, anchor = null) {
		if (!this.e) {
			if (this.is_svg)
				this.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));
			/** #7364  target for <template> may be provided as #document-fragment(11) */ else
				this.e = dom_element(
					/** @type {keyof HTMLElementTagNameMap} */ (
						target.nodeType === 11 ? 'TEMPLATE' : target.nodeName
					)
				);
			this.t =
				target.tagName !== 'TEMPLATE'
					? target
					: /** @type {HTMLTemplateElement} */ (target).content;
			this.c(html);
		}
		this.i(anchor);
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	h(html) {
		this.e.innerHTML = html;
		this.n = Array.from(
			this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes
		);
	}

	/**
	 * @returns {void} */
	i(anchor) {
		for (let i = 0; i < this.n.length; i += 1) {
			insert(this.t, this.n[i], anchor);
		}
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	p(html) {
		this.d();
		this.h(html);
		this.i(this.a);
	}

	/**
	 * @returns {void} */
	d() {
		this.n.forEach(detach);
	}
}

/**
 * @extends HtmlTag */
class HtmlTagHydration extends (/* unused pure expression or super */ null && (HtmlTag)) {
	// hydration claimed nodes
	/** */
	l = undefined;
	constructor(claimed_nodes, is_svg = false) {
		super(is_svg);
		this.e = this.n = null;
		this.l = claimed_nodes;
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	c(html) {
		if (this.l) {
			this.n = this.l;
		} else {
			super.c(html);
		}
	}

	/**
	 * @returns {void} */
	i(anchor) {
		for (let i = 0; i < this.n.length; i += 1) {
			dom_insert_hydration(this.t, this.n[i], anchor);
		}
	}
}

/**
 * @param {NamedNodeMap} attributes
 * @returns {{}}
 */
function attribute_to_object(attributes) {
	const result = {};
	for (const attribute of attributes) {
		result[attribute.name] = attribute.value;
	}
	return result;
}

/**
 * @param {HTMLElement} element
 * @returns {{}}
 */
function get_custom_elements_slots(element) {
	const result = {};
	element.childNodes.forEach(
		/** @param {Element} node */ (node) => {
			result[node.slot || 'default'] = true;
		}
	);
	return result;
}

function construct_svelte_component(component, props) {
	return new component(props);
}

/**
 * @typedef {Node & {
 * 	claim_order?: number;
 * 	hydrate_init?: true;
 * 	actual_end_child?: NodeEx;
 * 	childNodes: NodeListOf<NodeEx>;
 * }} NodeEx
 */

/** @typedef {ChildNode & NodeEx} ChildNodeEx */

/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

/**
 * @typedef {ChildNodeEx[] & {
 * 	claim_info?: {
 * 		last_index: number;
 * 		total_claimed: number;
 * 	};
 * }} ChildNodeArray
 */

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/style_manager.js



// we need to store the information for multiple documents because a Svelte application could also contain iframes
// https://github.com/sveltejs/svelte/issues/3624
/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */
const managed_styles = new Map();

let active = 0;

// https://github.com/darkskyapp/string-hash/blob/master/index.js
/**
 * @param {string} str
 * @returns {number}
 */
function hash(str) {
	let hash = 5381;
	let i = str.length;
	while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
	return hash >>> 0;
}

/**
 * @param {Document | ShadowRoot} doc
 * @param {Element & ElementCSSInlineStyle} node
 * @returns {{ stylesheet: any; rules: {}; }}
 */
function create_style_information(doc, node) {
	const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
	managed_styles.set(doc, info);
	return info;
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {number} a
 * @param {number} b
 * @param {number} duration
 * @param {number} delay
 * @param {(t: number) => number} ease
 * @param {(t: number, u: number) => string} fn
 * @param {number} uid
 * @returns {string}
 */
function style_manager_create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
	const step = 16.666 / duration;
	let keyframes = '{\n';
	for (let p = 0; p <= 1; p += step) {
		const t = a + (b - a) * ease(p);
		keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
	}
	const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
	const name = `__svelte_${hash(rule)}_${uid}`;
	const doc = get_root_for_style(node);
	const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
	if (!rules[name]) {
		rules[name] = true;
		stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
	}
	const animation = node.style.animation || '';
	node.style.animation = `${
		animation ? `${animation}, ` : ''
	}${name} ${duration}ms linear ${delay}ms 1 both`;
	active += 1;
	return name;
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {string} [name]
 * @returns {void}
 */
function style_manager_delete_rule(node, name) {
	const previous = (node.style.animation || '').split(', ');
	const next = previous.filter(
		name
			? (anim) => anim.indexOf(name) < 0 // remove specific animation
			: (anim) => anim.indexOf('__svelte') === -1 // remove all Svelte animations
	);
	const deleted = previous.length - next.length;
	if (deleted) {
		node.style.animation = next.join(', ');
		active -= deleted;
		if (!active) clear_rules();
	}
}

/** @returns {void} */
function clear_rules() {
	raf(() => {
		if (active) return;
		managed_styles.forEach((info) => {
			const { ownerNode } = info.stylesheet;
			// there is no ownerNode if it runs on jsdom.
			if (ownerNode) detach(ownerNode);
		});
		managed_styles.clear();
	});
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/animations.js





/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {import('./private.js').PositionRect} from
 * @param {import('./private.js').AnimationFn} fn
 */
function create_animation(node, from, fn, params) {
	if (!from) return noop;
	const to = node.getBoundingClientRect();
	if (
		from.left === to.left &&
		from.right === to.right &&
		from.top === to.top &&
		from.bottom === to.bottom
	)
		return noop;
	const {
		delay = 0,
		duration = 300,
		easing = linear,
		// @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
		start: start_time = now() + delay,
		// @ts-ignore todo:
		end = start_time + duration,
		tick = noop,
		css
	} = fn(node, { from, to }, params);
	let running = true;
	let started = false;
	let name;
	/** @returns {void} */
	function start() {
		if (css) {
			name = create_rule(node, 0, 1, duration, delay, easing, css);
		}
		if (!delay) {
			started = true;
		}
	}
	/** @returns {void} */
	function stop() {
		if (css) delete_rule(node, name);
		running = false;
	}
	loop((now) => {
		if (!started && now >= start_time) {
			started = true;
		}
		if (started && now >= end) {
			tick(1, 0);
			stop();
		}
		if (!running) {
			return false;
		}
		if (started) {
			const p = now - start_time;
			const t = 0 + 1 * easing(p / duration);
			tick(t, 1 - t);
		}
		return true;
	});
	start();
	tick(0, 1);
	return stop;
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @returns {void}
 */
function fix_position(node) {
	const style = getComputedStyle(node);
	if (style.position !== 'absolute' && style.position !== 'fixed') {
		const { width, height } = style;
		const a = node.getBoundingClientRect();
		node.style.position = 'absolute';
		node.style.width = width;
		node.style.height = height;
		add_transform(node, a);
	}
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {import('./private.js').PositionRect} a
 * @returns {void}
 */
function add_transform(node, a) {
	const b = node.getBoundingClientRect();
	if (a.left !== b.left || a.top !== b.top) {
		const style = getComputedStyle(node);
		const transform = style.transform === 'none' ? '' : style.transform;
		node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
	}
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/lifecycle.js


let lifecycle_current_component;

/** @returns {void} */
function lifecycle_set_current_component(component) {
	lifecycle_current_component = component;
}

function lifecycle_get_current_component() {
	if (!lifecycle_current_component) throw new Error('Function called outside component initialization');
	return lifecycle_current_component;
}

/**
 * Schedules a callback to run immediately before the component is updated after any state change.
 *
 * The first time the callback runs will be before the initial `onMount`
 *
 * https://svelte.dev/docs/svelte#beforeupdate
 * @param {() => any} fn
 * @returns {void}
 */
function beforeUpdate(fn) {
	lifecycle_get_current_component().$$.before_update.push(fn);
}

/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
 *
 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs/svelte#onmount
 * @template T
 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
 * @returns {void}
 */
function onMount(fn) {
	lifecycle_get_current_component().$$.on_mount.push(fn);
}

/**
 * Schedules a callback to run immediately after the component has been updated.
 *
 * The first time the callback runs will be after the initial `onMount`
 *
 * https://svelte.dev/docs/svelte#afterupdate
 * @param {() => any} fn
 * @returns {void}
 */
function afterUpdate(fn) {
	lifecycle_get_current_component().$$.after_update.push(fn);
}

/**
 * Schedules a callback to run immediately before the component is unmounted.
 *
 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
 * only one that runs inside a server-side component.
 *
 * https://svelte.dev/docs/svelte#ondestroy
 * @param {() => any} fn
 * @returns {void}
 */
function onDestroy(fn) {
	lifecycle_get_current_component().$$.on_destroy.push(fn);
}

/**
 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
 *
 * Component events created with `createEventDispatcher` create a
 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
 * property and can contain any type of data.
 *
 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
 * ```ts
 * const dispatch = createEventDispatcher<{
 *  loaded: never; // does not take a detail argument
 *  change: string; // takes a detail argument of type string, which is required
 *  optional: number | null; // takes an optional detail argument of type number
 * }>();
 * ```
 *
 * https://svelte.dev/docs/svelte#createeventdispatcher
 * @template {Record<string, any>} [EventMap=any]
 * @returns {import('./public.js').EventDispatcher<EventMap>}
 */
function createEventDispatcher() {
	const component = lifecycle_get_current_component();
	return (type, detail, { cancelable = false } = {}) => {
		const callbacks = component.$$.callbacks[type];
		if (callbacks) {
			// TODO are there situations where events could be dispatched
			// in a server (non-DOM) environment?
			const event = custom_event(/** @type {string} */ (type), detail, { cancelable });
			callbacks.slice().forEach((fn) => {
				fn.call(component, event);
			});
			return !event.defaultPrevented;
		}
		return true;
	};
}

/**
 * Associates an arbitrary `context` object with the current component and the specified `key`
 * and returns that object. The context is then available to children of the component
 * (including slotted content) with `getContext`.
 *
 * Like lifecycle functions, this must be called during component initialisation.
 *
 * https://svelte.dev/docs/svelte#setcontext
 * @template T
 * @param {any} key
 * @param {T} context
 * @returns {T}
 */
function setContext(key, context) {
	lifecycle_get_current_component().$$.context.set(key, context);
	return context;
}

/**
 * Retrieves the context that belongs to the closest parent component with the specified `key`.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs/svelte#getcontext
 * @template T
 * @param {any} key
 * @returns {T}
 */
function getContext(key) {
	return lifecycle_get_current_component().$$.context.get(key);
}

/**
 * Retrieves the whole context map that belongs to the closest parent component.
 * Must be called during component initialisation. Useful, for example, if you
 * programmatically create a component and want to pass the existing context to it.
 *
 * https://svelte.dev/docs/svelte#getallcontexts
 * @template {Map<any, any>} [T=Map<any, any>]
 * @returns {T}
 */
function getAllContexts() {
	return lifecycle_get_current_component().$$.context;
}

/**
 * Checks whether a given `key` has been set in the context of a parent component.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs/svelte#hascontext
 * @param {any} key
 * @returns {boolean}
 */
function hasContext(key) {
	return lifecycle_get_current_component().$$.context.has(key);
}

// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
/**
 * @param component
 * @param event
 * @returns {void}
 */
function bubble(component, event) {
	const callbacks = component.$$.callbacks[event.type];
	if (callbacks) {
		// @ts-ignore
		callbacks.slice().forEach((fn) => fn.call(this, event));
	}
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/scheduler.js



const dirty_components = [];
const intros = { enabled: false };
const binding_callbacks = [];

let render_callbacks = [];

const flush_callbacks = [];

const resolved_promise = /* @__PURE__ */ Promise.resolve();

let update_scheduled = false;

/** @returns {void} */
function schedule_update() {
	if (!update_scheduled) {
		update_scheduled = true;
		resolved_promise.then(scheduler_flush);
	}
}

/** @returns {Promise<void>} */
function tick() {
	schedule_update();
	return resolved_promise;
}

/** @returns {void} */
function scheduler_add_render_callback(fn) {
	render_callbacks.push(fn);
}

/** @returns {void} */
function add_flush_callback(fn) {
	flush_callbacks.push(fn);
}

// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();

let flushidx = 0; // Do *not* move this inside the flush() function

/** @returns {void} */
function scheduler_flush() {
	// Do not reenter flush while dirty components are updated, as this can
	// result in an infinite loop. Instead, let the inner flush handle it.
	// Reentrancy is ok afterwards for bindings etc.
	if (flushidx !== 0) {
		return;
	}
	const saved_component = lifecycle_current_component;
	do {
		// first, call beforeUpdate functions
		// and update components
		try {
			while (flushidx < dirty_components.length) {
				const component = dirty_components[flushidx];
				flushidx++;
				lifecycle_set_current_component(component);
				scheduler_update(component.$$);
			}
		} catch (e) {
			// reset dirty state to not end up in a deadlocked state and then rethrow
			dirty_components.length = 0;
			flushidx = 0;
			throw e;
		}
		lifecycle_set_current_component(null);
		dirty_components.length = 0;
		flushidx = 0;
		while (binding_callbacks.length) binding_callbacks.pop()();
		// then, once components are updated, call
		// afterUpdate functions. This may cause
		// subsequent updates...
		for (let i = 0; i < render_callbacks.length; i += 1) {
			const callback = render_callbacks[i];
			if (!seen_callbacks.has(callback)) {
				// ...so guard against infinite loops
				seen_callbacks.add(callback);
				callback();
			}
		}
		render_callbacks.length = 0;
	} while (dirty_components.length);
	while (flush_callbacks.length) {
		flush_callbacks.pop()();
	}
	update_scheduled = false;
	seen_callbacks.clear();
	lifecycle_set_current_component(saved_component);
}

/** @returns {void} */
function scheduler_update($$) {
	if ($$.fragment !== null) {
		$$.update();
		utils_run_all($$.before_update);
		const dirty = $$.dirty;
		$$.dirty = [-1];
		$$.fragment && $$.fragment.p($$.ctx, dirty);
		$$.after_update.forEach(scheduler_add_render_callback);
	}
}

/**
 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
 * @param {Function[]} fns
 * @returns {void}
 */
function flush_render_callbacks(fns) {
	const filtered = [];
	const targets = [];
	render_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));
	targets.forEach((c) => c());
	render_callbacks = filtered;
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/transitions.js







/**
 * @type {Promise<void> | null}
 */
let promise;

/**
 * @returns {Promise<void>}
 */
function wait() {
	if (!promise) {
		promise = Promise.resolve();
		promise.then(() => {
			promise = null;
		});
	}
	return promise;
}

/**
 * @param {Element} node
 * @param {INTRO | OUTRO | boolean} direction
 * @param {'start' | 'end'} kind
 * @returns {void}
 */
function dispatch(node, direction, kind) {
	node.dispatchEvent(dom_custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}

const outroing = new Set();

/**
 * @type {Outro}
 */
let outros;

/**
 * @returns {void} */
function transitions_group_outros() {
	outros = {
		r: 0,
		c: [],
		p: outros // parent group
	};
}

/**
 * @returns {void} */
function transitions_check_outros() {
	if (!outros.r) {
		utils_run_all(outros.c);
	}
	outros = outros.p;
}

/**
 * @param {import('./private.js').Fragment} block
 * @param {0 | 1} [local]
 * @returns {void}
 */
function transitions_transition_in(block, local) {
	if (block && block.i) {
		outroing.delete(block);
		block.i(local);
	}
}

/**
 * @param {import('./private.js').Fragment} block
 * @param {0 | 1} local
 * @param {0 | 1} [detach]
 * @param {() => void} [callback]
 * @returns {void}
 */
function transitions_transition_out(block, local, detach, callback) {
	if (block && block.o) {
		if (outroing.has(block)) return;
		outroing.add(block);
		outros.c.push(() => {
			outroing.delete(block);
			if (callback) {
				if (detach) block.d(1);
				callback();
			}
		});
		block.o(local);
	} else if (callback) {
		callback();
	}
}

/**
 * @type {import('../transition/public.js').TransitionConfig}
 */
const null_transition = { duration: 0 };

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {TransitionFn} fn
 * @param {any} params
 * @returns {{ start(): void; invalidate(): void; end(): void; }}
 */
function create_in_transition(node, fn, params) {
	/**
	 * @type {TransitionOptions} */
	const options = { direction: 'in' };
	let config = fn(node, params, options);
	let running = false;
	let animation_name;
	let task;
	let uid = 0;

	/**
	 * @returns {void} */
	function cleanup() {
		if (animation_name) style_manager_delete_rule(node, animation_name);
	}

	/**
	 * @returns {void} */
	function go() {
		const {
			delay = 0,
			duration = 300,
			easing = identity,
			tick = utils_noop,
			css
		} = config || null_transition;
		if (css) animation_name = style_manager_create_rule(node, 0, 1, duration, delay, easing, css, uid++);
		tick(0, 1);
		const start_time = environment_now() + delay;
		const end_time = start_time + duration;
		if (task) task.abort();
		running = true;
		scheduler_add_render_callback(() => dispatch(node, true, 'start'));
		task = loop_loop((now) => {
			if (running) {
				if (now >= end_time) {
					tick(1, 0);
					dispatch(node, true, 'end');
					cleanup();
					return (running = false);
				}
				if (now >= start_time) {
					const t = easing((now - start_time) / duration);
					tick(t, 1 - t);
				}
			}
			return running;
		});
	}
	let started = false;
	return {
		start() {
			if (started) return;
			started = true;
			style_manager_delete_rule(node);
			if (utils_is_function(config)) {
				config = config(options);
				wait().then(go);
			} else {
				go();
			}
		},
		invalidate() {
			started = false;
		},
		end() {
			if (running) {
				cleanup();
				running = false;
			}
		}
	};
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {TransitionFn} fn
 * @param {any} params
 * @returns {{ end(reset: any): void; }}
 */
function create_out_transition(node, fn, params) {
	/** @type {TransitionOptions} */
	const options = { direction: 'out' };
	let config = fn(node, params, options);
	let running = true;
	let animation_name;
	const group = outros;
	group.r += 1;
	/** @type {boolean} */
	let original_inert_value;

	/**
	 * @returns {void} */
	function go() {
		const {
			delay = 0,
			duration = 300,
			easing = linear,
			tick = noop,
			css
		} = config || null_transition;

		if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);

		const start_time = now() + delay;
		const end_time = start_time + duration;
		add_render_callback(() => dispatch(node, false, 'start'));

		if ('inert' in node) {
			original_inert_value = /** @type {HTMLElement} */ (node).inert;
			node.inert = true;
		}

		loop((now) => {
			if (running) {
				if (now >= end_time) {
					tick(0, 1);
					dispatch(node, false, 'end');
					if (!--group.r) {
						// this will result in `end()` being called,
						// so we don't need to clean up here
						run_all(group.c);
					}
					return false;
				}
				if (now >= start_time) {
					const t = easing((now - start_time) / duration);
					tick(1 - t, t);
				}
			}
			return running;
		});
	}

	if (is_function(config)) {
		wait().then(() => {
			// @ts-ignore
			config = config(options);
			go();
		});
	} else {
		go();
	}

	return {
		end(reset) {
			if (reset && 'inert' in node) {
				node.inert = original_inert_value;
			}
			if (reset && config.tick) {
				config.tick(1, 0);
			}
			if (running) {
				if (animation_name) delete_rule(node, animation_name);
				running = false;
			}
		}
	};
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {TransitionFn} fn
 * @param {any} params
 * @param {boolean} intro
 * @returns {{ run(b: 0 | 1): void; end(): void; }}
 */
function create_bidirectional_transition(node, fn, params, intro) {
	/**
	 * @type {TransitionOptions} */
	const options = { direction: 'both' };
	let config = fn(node, params, options);
	let t = intro ? 0 : 1;

	/**
	 * @type {Program | null} */
	let running_program = null;

	/**
	 * @type {PendingProgram | null} */
	let pending_program = null;
	let animation_name = null;

	/** @type {boolean} */
	let original_inert_value;

	/**
	 * @returns {void} */
	function clear_animation() {
		if (animation_name) style_manager_delete_rule(node, animation_name);
	}

	/**
	 * @param {PendingProgram} program
	 * @param {number} duration
	 * @returns {Program}
	 */
	function init(program, duration) {
		const d = /** @type {Program['d']} */ (program.b - t);
		duration *= Math.abs(d);
		return {
			a: t,
			b: program.b,
			d,
			duration,
			start: program.start,
			end: program.start + duration,
			group: program.group
		};
	}

	/**
	 * @param {INTRO | OUTRO} b
	 * @returns {void}
	 */
	function go(b) {
		const {
			delay = 0,
			duration = 300,
			easing = identity,
			tick = utils_noop,
			css
		} = config || null_transition;

		/**
		 * @type {PendingProgram} */
		const program = {
			start: environment_now() + delay,
			b
		};

		if (!b) {
			// @ts-ignore todo: improve typings
			program.group = outros;
			outros.r += 1;
		}

		if ('inert' in node) {
			if (b) {
				if (original_inert_value !== undefined) {
					// aborted/reversed outro — restore previous inert value
					node.inert = original_inert_value;
				}
			} else {
				original_inert_value = /** @type {HTMLElement} */ (node).inert;
				node.inert = true;
			}
		}

		if (running_program || pending_program) {
			pending_program = program;
		} else {
			// if this is an intro, and there's a delay, we need to do
			// an initial tick and/or apply CSS animation immediately
			if (css) {
				clear_animation();
				animation_name = style_manager_create_rule(node, t, b, duration, delay, easing, css);
			}
			if (b) tick(0, 1);
			running_program = init(program, duration);
			scheduler_add_render_callback(() => dispatch(node, b, 'start'));
			loop_loop((now) => {
				if (pending_program && now > pending_program.start) {
					running_program = init(pending_program, duration);
					pending_program = null;
					dispatch(node, running_program.b, 'start');
					if (css) {
						clear_animation();
						animation_name = style_manager_create_rule(
							node,
							t,
							running_program.b,
							running_program.duration,
							0,
							easing,
							config.css
						);
					}
				}
				if (running_program) {
					if (now >= running_program.end) {
						tick((t = running_program.b), 1 - t);
						dispatch(node, running_program.b, 'end');
						if (!pending_program) {
							// we're done
							if (running_program.b) {
								// intro — we can tidy up immediately
								clear_animation();
							} else {
								// outro — needs to be coordinated
								if (!--running_program.group.r) utils_run_all(running_program.group.c);
							}
						}
						running_program = null;
					} else if (now >= running_program.start) {
						const p = now - running_program.start;
						t = running_program.a + running_program.d * easing(p / running_program.duration);
						tick(t, 1 - t);
					}
				}
				return !!(running_program || pending_program);
			});
		}
	}
	return {
		run(b) {
			if (utils_is_function(config)) {
				wait().then(() => {
					const opts = { direction: b ? 'in' : 'out' };
					// @ts-ignore
					config = config(opts);
					go(b);
				});
			} else {
				go(b);
			}
		},
		end() {
			clear_animation();
			running_program = pending_program = null;
		}
	};
}

/** @typedef {1} INTRO */
/** @typedef {0} OUTRO */
/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

/**
 * @typedef {Object} Outro
 * @property {number} r
 * @property {Function[]} c
 * @property {Object} p
 */

/**
 * @typedef {Object} PendingProgram
 * @property {number} start
 * @property {INTRO|OUTRO} b
 * @property {Outro} [group]
 */

/**
 * @typedef {Object} Program
 * @property {number} a
 * @property {INTRO|OUTRO} b
 * @property {1|-1} d
 * @property {number} duration
 * @property {number} start
 * @property {number} end
 * @property {Outro} [group]
 */

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/await_block.js





/**
 * @template T
 * @param {Promise<T>} promise
 * @param {import('./private.js').PromiseInfo<T>} info
 * @returns {boolean}
 */
function handle_promise(promise, info) {
	const token = (info.token = {});
	/**
	 * @param {import('./private.js').FragmentFactory} type
	 * @param {0 | 1 | 2} index
	 * @param {number} [key]
	 * @param {any} [value]
	 * @returns {void}
	 */
	function update(type, index, key, value) {
		if (info.token !== token) return;
		info.resolved = value;
		let child_ctx = info.ctx;
		if (key !== undefined) {
			child_ctx = child_ctx.slice();
			child_ctx[key] = value;
		}
		const block = type && (info.current = type)(child_ctx);
		let needs_flush = false;
		if (info.block) {
			if (info.blocks) {
				info.blocks.forEach((block, i) => {
					if (i !== index && block) {
						group_outros();
						transition_out(block, 1, 1, () => {
							if (info.blocks[i] === block) {
								info.blocks[i] = null;
							}
						});
						check_outros();
					}
				});
			} else {
				info.block.d(1);
			}
			block.c();
			transition_in(block, 1);
			block.m(info.mount(), info.anchor);
			needs_flush = true;
		}
		info.block = block;
		if (info.blocks) info.blocks[index] = block;
		if (needs_flush) {
			flush();
		}
	}
	if (is_promise(promise)) {
		const current_component = get_current_component();
		promise.then(
			(value) => {
				set_current_component(current_component);
				update(info.then, 1, info.value, value);
				set_current_component(null);
			},
			(error) => {
				set_current_component(current_component);
				update(info.catch, 2, info.error, error);
				set_current_component(null);
				if (!info.hasCatch) {
					throw error;
				}
			}
		);
		// if we previously had a then/catch block, destroy it
		if (info.current !== info.pending) {
			update(info.pending, 0);
			return true;
		}
	} else {
		if (info.current !== info.then) {
			update(info.then, 1, info.value, promise);
			return true;
		}
		info.resolved = /** @type {T} */ (promise);
	}
}

/** @returns {void} */
function update_await_block_branch(info, ctx, dirty) {
	const child_ctx = ctx.slice();
	const { resolved } = info;
	if (info.current === info.then) {
		child_ctx[info.value] = resolved;
	}
	if (info.current === info.catch) {
		child_ctx[info.error] = resolved;
	}
	info.block.p(child_ctx, dirty);
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/each.js



// general each functions:

function each_ensure_array_like(array_like_or_iterator) {
	return array_like_or_iterator?.length !== undefined
		? array_like_or_iterator
		: Array.from(array_like_or_iterator);
}

// keyed each functions:

/** @returns {void} */
function destroy_block(block, lookup) {
	block.d(1);
	lookup.delete(block.key);
}

/** @returns {void} */
function outro_and_destroy_block(block, lookup) {
	transition_out(block, 1, 1, () => {
		lookup.delete(block.key);
	});
}

/** @returns {void} */
function fix_and_destroy_block(block, lookup) {
	block.f();
	destroy_block(block, lookup);
}

/** @returns {void} */
function fix_and_outro_and_destroy_block(block, lookup) {
	block.f();
	outro_and_destroy_block(block, lookup);
}

/** @returns {any[]} */
function update_keyed_each(
	old_blocks,
	dirty,
	get_key,
	dynamic,
	ctx,
	list,
	lookup,
	node,
	destroy,
	create_each_block,
	next,
	get_context
) {
	let o = old_blocks.length;
	let n = list.length;
	let i = o;
	const old_indexes = {};
	while (i--) old_indexes[old_blocks[i].key] = i;
	const new_blocks = [];
	const new_lookup = new Map();
	const deltas = new Map();
	const updates = [];
	i = n;
	while (i--) {
		const child_ctx = get_context(ctx, list, i);
		const key = get_key(child_ctx);
		let block = lookup.get(key);
		if (!block) {
			block = create_each_block(key, child_ctx);
			block.c();
		} else if (dynamic) {
			// defer updates until all the DOM shuffling is done
			updates.push(() => block.p(child_ctx, dirty));
		}
		new_lookup.set(key, (new_blocks[i] = block));
		if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
	}
	const will_move = new Set();
	const did_move = new Set();
	/** @returns {void} */
	function insert(block) {
		transition_in(block, 1);
		block.m(node, next);
		lookup.set(block.key, block);
		next = block.first;
		n--;
	}
	while (o && n) {
		const new_block = new_blocks[n - 1];
		const old_block = old_blocks[o - 1];
		const new_key = new_block.key;
		const old_key = old_block.key;
		if (new_block === old_block) {
			// do nothing
			next = new_block.first;
			o--;
			n--;
		} else if (!new_lookup.has(old_key)) {
			// remove old block
			destroy(old_block, lookup);
			o--;
		} else if (!lookup.has(new_key) || will_move.has(new_key)) {
			insert(new_block);
		} else if (did_move.has(old_key)) {
			o--;
		} else if (deltas.get(new_key) > deltas.get(old_key)) {
			did_move.add(new_key);
			insert(new_block);
		} else {
			will_move.add(old_key);
			o--;
		}
	}
	while (o--) {
		const old_block = old_blocks[o];
		if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
	}
	while (n) insert(new_blocks[n - 1]);
	run_all(updates);
	return new_blocks;
}

/** @returns {void} */
function validate_each_keys(ctx, list, get_context, get_key) {
	const keys = new Map();
	for (let i = 0; i < list.length; i++) {
		const key = get_key(get_context(ctx, list, i));
		if (keys.has(key)) {
			let value = '';
			try {
				value = `with value '${String(key)}' `;
			} catch (e) {
				// can't stringify
			}
			throw new Error(
				`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(
					key
				)} and ${i} ${value}are duplicates`
			);
		}
		keys.set(key, i);
	}
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/shared/boolean_attributes.js
const _boolean_attributes = /** @type {const} */ ([
	'allowfullscreen',
	'allowpaymentrequest',
	'async',
	'autofocus',
	'autoplay',
	'checked',
	'controls',
	'default',
	'defer',
	'disabled',
	'formnovalidate',
	'hidden',
	'inert',
	'ismap',
	'loop',
	'multiple',
	'muted',
	'nomodule',
	'novalidate',
	'open',
	'playsinline',
	'readonly',
	'required',
	'reversed',
	'selected'
]);

/**
 * List of HTML boolean attributes (e.g. `<input disabled>`).
 * Source: https://html.spec.whatwg.org/multipage/indices.html
 *
 * @type {Set<string>}
 */
const boolean_attributes_boolean_attributes = new Set([..._boolean_attributes]);

/** @typedef {typeof _boolean_attributes[number]} BooleanAttributes */

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/ssr.js






const invalid_attribute_name_character =
	/[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter

/** @returns {string} */
function spread(args, attrs_to_add) {
	const attributes = Object.assign({}, ...args);
	if (attrs_to_add) {
		const classes_to_add = attrs_to_add.classes;
		const styles_to_add = attrs_to_add.styles;
		if (classes_to_add) {
			if (attributes.class == null) {
				attributes.class = classes_to_add;
			} else {
				attributes.class += ' ' + classes_to_add;
			}
		}
		if (styles_to_add) {
			if (attributes.style == null) {
				attributes.style = style_object_to_string(styles_to_add);
			} else {
				attributes.style = style_object_to_string(
					merge_ssr_styles(attributes.style, styles_to_add)
				);
			}
		}
	}
	let str = '';
	Object.keys(attributes).forEach((name) => {
		if (invalid_attribute_name_character.test(name)) return;
		const value = attributes[name];
		if (value === true) str += ' ' + name;
		else if (boolean_attributes.has(name.toLowerCase())) {
			if (value) str += ' ' + name;
		} else if (value != null) {
			str += ` ${name}="${value}"`;
		}
	});
	return str;
}

/** @returns {{}} */
function merge_ssr_styles(style_attribute, style_directive) {
	const style_object = {};
	for (const individual_style of style_attribute.split(';')) {
		const colon_index = individual_style.indexOf(':');
		const name = individual_style.slice(0, colon_index).trim();
		const value = individual_style.slice(colon_index + 1).trim();
		if (!name) continue;
		style_object[name] = value;
	}
	for (const name in style_directive) {
		const value = style_directive[name];
		if (value) {
			style_object[name] = value;
		} else {
			delete style_object[name];
		}
	}
	return style_object;
}

const ATTR_REGEX = /[&"]/g;
const CONTENT_REGEX = /[&<]/g;

/**
 * Note: this method is performance sensitive and has been optimized
 * https://github.com/sveltejs/svelte/pull/5701
 * @param {unknown} value
 * @returns {string}
 */
function ssr_escape(value, is_attr = false) {
	const str = String(value);
	const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
	pattern.lastIndex = 0;
	let escaped = '';
	let last = 0;
	while (pattern.test(str)) {
		const i = pattern.lastIndex - 1;
		const ch = str[i];
		escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : ch === '"' ? '&quot;' : '&lt;');
		last = i + 1;
	}
	return escaped + str.substring(last);
}

function escape_attribute_value(value) {
	// keep booleans, null, and undefined for the sake of `spread`
	const should_escape = typeof value === 'string' || (value && typeof value === 'object');
	return should_escape ? ssr_escape(value, true) : value;
}

/** @returns {{}} */
function escape_object(obj) {
	const result = {};
	for (const key in obj) {
		result[key] = escape_attribute_value(obj[key]);
	}
	return result;
}

/** @returns {string} */
function each(items, fn) {
	items = ensure_array_like(items);
	let str = '';
	for (let i = 0; i < items.length; i += 1) {
		str += fn(items[i], i);
	}
	return str;
}

const missing_component = {
	$$render: () => ''
};

function validate_component(component, name) {
	if (!component || !component.$$render) {
		if (name === 'svelte:component') name += ' this={...}';
		throw new Error(
			`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`
		);
	}
	return component;
}

/** @returns {string} */
function debug(file, line, column, values) {
	console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
	console.log(values); // eslint-disable-line no-console
	return '';
}

let on_destroy;

/** @returns {{ render: (props?: {}, { $$slots, context }?: { $$slots?: {}; context?: Map<any, any>; }) => { html: any; css: { code: string; map: any; }; head: string; }; $$render: (result: any, props: any, bindings: any, slots: any, context: any) => any; }} */
function create_ssr_component(fn) {
	function $$render(result, props, bindings, slots, context) {
		const parent_component = current_component;
		const $$ = {
			on_destroy,
			context: new Map(context || (parent_component ? parent_component.$$.context : [])),
			// these will be immediately discarded
			on_mount: [],
			before_update: [],
			after_update: [],
			callbacks: blank_object()
		};
		set_current_component({ $$ });
		const html = fn(result, props, bindings, slots);
		set_current_component(parent_component);
		return html;
	}
	return {
		render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
			on_destroy = [];
			const result = { title: '', head: '', css: new Set() };
			const html = $$render(result, props, {}, $$slots, context);
			run_all(on_destroy);
			return {
				html,
				css: {
					code: Array.from(result.css)
						.map((css) => css.code)
						.join('\n'),
					map: null // TODO
				},
				head: result.title + result.head
			};
		},
		$$render
	};
}

/** @returns {string} */
function add_attribute(name, value, boolean) {
	if (value == null || (boolean && !value)) return '';
	const assignment = boolean && value === true ? '' : `="${ssr_escape(value, true)}"`;
	return ` ${name}${assignment}`;
}

/** @returns {string} */
function add_classes(classes) {
	return classes ? ` class="${classes}"` : '';
}

/** @returns {string} */
function style_object_to_string(style_object) {
	return Object.keys(style_object)
		.filter((key) => style_object[key])
		.map((key) => `${key}: ${escape_attribute_value(style_object[key])};`)
		.join(' ');
}

/** @returns {string} */
function add_styles(style_object) {
	const styles = style_object_to_string(style_object);
	return styles ? ` style="${styles}"` : '';
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/Component.js






/** @returns {void} */
function bind(component, name, callback) {
	const index = component.$$.props[name];
	if (index !== undefined) {
		component.$$.bound[index] = callback;
		callback(component.$$.ctx[index]);
	}
}

/** @returns {void} */
function create_component(block) {
	block && block.c();
}

/** @returns {void} */
function claim_component(block, parent_nodes) {
	block && block.l(parent_nodes);
}

/** @returns {void} */
function mount_component(component, target, anchor) {
	const { fragment, after_update } = component.$$;
	fragment && fragment.m(target, anchor);
	// onMount happens before the initial afterUpdate
	scheduler_add_render_callback(() => {
		const new_on_destroy = component.$$.on_mount.map(run).filter(utils_is_function);
		// if the component was destroyed immediately
		// it will update the `$$.on_destroy` reference to `null`.
		// the destructured on_destroy may still reference to the old array
		if (component.$$.on_destroy) {
			component.$$.on_destroy.push(...new_on_destroy);
		} else {
			// Edge case - component was destroyed immediately,
			// most likely as a result of a binding initialising
			utils_run_all(new_on_destroy);
		}
		component.$$.on_mount = [];
	});
	after_update.forEach(scheduler_add_render_callback);
}

/** @returns {void} */
function destroy_component(component, detaching) {
	const $$ = component.$$;
	if ($$.fragment !== null) {
		flush_render_callbacks($$.after_update);
		utils_run_all($$.on_destroy);
		$$.fragment && $$.fragment.d(detaching);
		// TODO null out other refs, including component.$$ (but need to
		// preserve final state?)
		$$.on_destroy = $$.fragment = null;
		$$.ctx = [];
	}
}

/** @returns {void} */
function make_dirty(component, i) {
	if (component.$$.dirty[0] === -1) {
		dirty_components.push(component);
		schedule_update();
		component.$$.dirty.fill(0);
	}
	component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
}

/** @returns {void} */
function init(
	component,
	options,
	instance,
	create_fragment,
	not_equal,
	props,
	append_styles,
	dirty = [-1]
) {
	const parent_component = lifecycle_current_component;
	lifecycle_set_current_component(component);
	/** @type {import('./private.js').T$$} */
	const $$ = (component.$$ = {
		fragment: null,
		ctx: [],
		// state
		props,
		update: utils_noop,
		not_equal,
		bound: utils_blank_object(),
		// lifecycle
		on_mount: [],
		on_destroy: [],
		on_disconnect: [],
		before_update: [],
		after_update: [],
		context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
		// everything else
		callbacks: utils_blank_object(),
		dirty,
		skip_bound: false,
		root: options.target || parent_component.$$.root
	});
	append_styles && append_styles($$.root);
	let ready = false;
	$$.ctx = instance
		? instance(component, options.props || {}, (i, ret, ...rest) => {
				const value = rest.length ? rest[0] : ret;
				if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
					if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
					if (ready) make_dirty(component, i);
				}
				return ret;
		  })
		: [];
	$$.update();
	ready = true;
	utils_run_all($$.before_update);
	// `false` as a special case of no DOM component
	$$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	if (options.target) {
		if (options.hydrate) {
			start_hydrating();
			const nodes = children(options.target);
			// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
			$$.fragment && $$.fragment.l(nodes);
			nodes.forEach(detach);
		} else {
			// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
			$$.fragment && $$.fragment.c();
		}
		if (options.intro) transitions_transition_in(component.$$.fragment);
		mount_component(component, options.target, options.anchor);
		end_hydrating();
		scheduler_flush();
	}
	lifecycle_set_current_component(parent_component);
}

let SvelteElement;

if (typeof HTMLElement === 'function') {
	SvelteElement = class extends HTMLElement {
		$$componentCtor;
		$$slots;
		$$component;
		$$connected = false;
		$$data = {};
		$$reflecting = false;
		/** @type {Record<string, CustomElementPropDefinition>} */
		$$props_definition = {};
		/** @type {Record<string, Function[]>} */
		$$listeners = {};
		/** @type {Map<Function, Function>} */
		$$listener_unsubscribe_fns = new Map();

		constructor($$componentCtor, $$slots, use_shadow_dom) {
			super();
			this.$$componentCtor = $$componentCtor;
			this.$$slots = $$slots;
			if (use_shadow_dom) {
				this.attachShadow({ mode: 'open' });
			}
		}

		addEventListener(type, listener, options) {
			// We can't determine upfront if the event is a custom event or not, so we have to
			// listen to both. If someone uses a custom event with the same name as a regular
			// browser event, this fires twice - we can't avoid that.
			this.$$listeners[type] = this.$$listeners[type] || [];
			this.$$listeners[type].push(listener);
			if (this.$$component) {
				const unsub = this.$$component.$on(type, listener);
				this.$$listener_unsubscribe_fns.set(listener, unsub);
			}
			super.addEventListener(type, listener, options);
		}

		removeEventListener(type, listener, options) {
			super.removeEventListener(type, listener, options);
			if (this.$$component) {
				const unsub = this.$$listener_unsubscribe_fns.get(listener);
				if (unsub) {
					unsub();
					this.$$listener_unsubscribe_fns.delete(listener);
				}
			}
		}

		async connectedCallback() {
			this.$$connected = true;
			if (!this.$$component) {
				// We wait one tick to let possible child slot elements be created/mounted
				await Promise.resolve();
				if (!this.$$connected) {
					return;
				}
				function create_slot(name) {
					return () => {
						let node;
						const obj = {
							c: function create() {
								node = document.createElement('slot');
								if (name !== 'default') {
									node.setAttribute('name', name);
								}
							},
							/**
							 * @param {HTMLElement} target
							 * @param {HTMLElement} [anchor]
							 */
							m: function mount(target, anchor) {
								insert(target, node, anchor);
							},
							d: function destroy(detaching) {
								if (detaching) {
									detach(node);
								}
							}
						};
						return obj;
					};
				}
				const $$slots = {};
				const existing_slots = get_custom_elements_slots(this);
				for (const name of this.$$slots) {
					if (name in existing_slots) {
						$$slots[name] = [create_slot(name)];
					}
				}
				for (const attribute of this.attributes) {
					// this.$$data takes precedence over this.attributes
					const name = this.$$get_prop_name(attribute.name);
					if (!(name in this.$$data)) {
						this.$$data[name] = get_custom_element_value(
							name,
							attribute.value,
							this.$$props_definition,
							'toProp'
						);
					}
				}
				this.$$component = new this.$$componentCtor({
					target: this.shadowRoot || this,
					props: {
						...this.$$data,
						$$slots,
						$$scope: {
							ctx: []
						}
					}
				});
				for (const type in this.$$listeners) {
					for (const listener of this.$$listeners[type]) {
						const unsub = this.$$component.$on(type, listener);
						this.$$listener_unsubscribe_fns.set(listener, unsub);
					}
				}
				this.$$listeners = {};
			}
		}

		// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
		// and setting attributes through setAttribute etc, this is helpful
		attributeChangedCallback(attr, _oldValue, newValue) {
			if (this.$$reflecting) return;
			attr = this.$$get_prop_name(attr);
			this.$$data[attr] = get_custom_element_value(
				attr,
				newValue,
				this.$$props_definition,
				'toProp'
			);
			this.$$component?.$set({ [attr]: this.$$data[attr] });
		}

		disconnectedCallback() {
			this.$$connected = false;
			// In a microtask, because this could be a move within the DOM
			Promise.resolve().then(() => {
				if (!this.$$connected) {
					this.$$component.$destroy();
					this.$$component = undefined;
				}
			});
		}

		$$get_prop_name(attribute_name) {
			return (
				Object.keys(this.$$props_definition).find(
					(key) =>
						this.$$props_definition[key].attribute === attribute_name ||
						(!this.$$props_definition[key].attribute && key.toLowerCase() === attribute_name)
				) || attribute_name
			);
		}
	};
}

/**
 * @param {string} prop
 * @param {any} value
 * @param {Record<string, CustomElementPropDefinition>} props_definition
 * @param {'toAttribute' | 'toProp'} [transform]
 */
function get_custom_element_value(prop, value, props_definition, transform) {
	const type = props_definition[prop]?.type;
	value = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;
	if (!transform || !props_definition[prop]) {
		return value;
	} else if (transform === 'toAttribute') {
		switch (type) {
			case 'Object':
			case 'Array':
				return value == null ? null : JSON.stringify(value);
			case 'Boolean':
				return value ? '' : null;
			case 'Number':
				return value == null ? null : value;
			default:
				return value;
		}
	} else {
		switch (type) {
			case 'Object':
			case 'Array':
				return value && JSON.parse(value);
			case 'Boolean':
				return value; // conversion already handled above
			case 'Number':
				return value != null ? +value : value;
			default:
				return value;
		}
	}
}

/**
 * @internal
 *
 * Turn a Svelte component into a custom element.
 * @param {import('./public.js').ComponentType} Component  A Svelte component constructor
 * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe
 * @param {string[]} slots  The slots to create
 * @param {string[]} accessors  Other accessors besides the ones for props the component has
 * @param {boolean} use_shadow_dom  Whether to use shadow DOM
 */
function create_custom_element(
	Component,
	props_definition,
	slots,
	accessors,
	use_shadow_dom
) {
	const Class = class extends SvelteElement {
		constructor() {
			super(Component, slots, use_shadow_dom);
			this.$$props_definition = props_definition;
		}
		static get observedAttributes() {
			return Object.keys(props_definition).map((key) =>
				(props_definition[key].attribute || key).toLowerCase()
			);
		}
	};
	Object.keys(props_definition).forEach((prop) => {
		Object.defineProperty(Class.prototype, prop, {
			get() {
				return this.$$component && prop in this.$$component
					? this.$$component[prop]
					: this.$$data[prop];
			},
			set(value) {
				value = get_custom_element_value(prop, value, props_definition);
				this.$$data[prop] = value;
				this.$$component?.$set({ [prop]: value });
				if (props_definition[prop].reflect) {
					this.$$reflecting = true;
					const attribute_value = get_custom_element_value(
						prop,
						value,
						props_definition,
						'toAttribute'
					);
					if (attribute_value == null) {
						this.removeAttribute(prop);
					} else {
						this.setAttribute(props_definition[prop].attribute || prop, attribute_value);
					}
					this.$$reflecting = false;
				}
			}
		});
	});
	accessors.forEach((accessor) => {
		Object.defineProperty(Class.prototype, accessor, {
			get() {
				return this.$$component?.[accessor];
			}
		});
	});
	Component.element = /** @type {any} */ (Class);
	return Class;
}

/**
 * Base class for Svelte components. Used when dev=false.
 *
 * @template {Record<string, any>} [Props=any]
 * @template {Record<string, any>} [Events=any]
 */
class SvelteComponent {
	/**
	 * ### PRIVATE API
	 *
	 * Do not use, may change at any time
	 *
	 * @type {any}
	 */
	$$ = undefined;
	/**
	 * ### PRIVATE API
	 *
	 * Do not use, may change at any time
	 *
	 * @type {any}
	 */
	$$set = undefined;

	/** @returns {void} */
	$destroy() {
		destroy_component(this, 1);
		this.$destroy = utils_noop;
	}

	/**
	 * @template {Extract<keyof Events, string>} K
	 * @param {K} type
	 * @param {((e: Events[K]) => void) | null | undefined} callback
	 * @returns {() => void}
	 */
	$on(type, callback) {
		if (!utils_is_function(callback)) {
			return utils_noop;
		}
		const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
		callbacks.push(callback);
		return () => {
			const index = callbacks.indexOf(callback);
			if (index !== -1) callbacks.splice(index, 1);
		};
	}

	/**
	 * @param {Partial<Props>} props
	 * @returns {void}
	 */
	$set(props) {
		if (this.$$set && !is_empty(props)) {
			this.$$.skip_bound = true;
			this.$$set(props);
			this.$$.skip_bound = false;
		}
	}
}

/**
 * @typedef {Object} CustomElementPropDefinition
 * @property {string} [attribute]
 * @property {boolean} [reflect]
 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
 */

;// CONCATENATED MODULE: ./node_modules/svelte/src/shared/version.js
// generated during release, do not modify

/**
 * The current version, as set in package.json.
 *
 * https://svelte.dev/docs/svelte-compiler#svelte-version
 * @type {string}
 */
const VERSION = '4.0.1';
const PUBLIC_VERSION = '4';

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/dev.js







/**
 * @template T
 * @param {string} type
 * @param {T} [detail]
 * @returns {void}
 */
function dispatch_dev(type, detail) {
	document.dispatchEvent(dom_custom_event(type, { version: VERSION, ...detail }, { bubbles: true }));
}

/**
 * @param {Node} target
 * @param {Node} node
 * @returns {void}
 */
function append_dev(target, node) {
	dispatch_dev('SvelteDOMInsert', { target, node });
	append(target, node);
}

/**
 * @param {Node} target
 * @param {Node} node
 * @returns {void}
 */
function append_hydration_dev(target, node) {
	dispatch_dev('SvelteDOMInsert', { target, node });
	append_hydration(target, node);
}

/**
 * @param {Node} target
 * @param {Node} node
 * @param {Node} [anchor]
 * @returns {void}
 */
function insert_dev(target, node, anchor) {
	dispatch_dev('SvelteDOMInsert', { target, node, anchor });
	insert(target, node, anchor);
}

/** @param {Node} target
 * @param {Node} node
 * @param {Node} [anchor]
 * @returns {void}
 */
function insert_hydration_dev(target, node, anchor) {
	dispatch_dev('SvelteDOMInsert', { target, node, anchor });
	insert_hydration(target, node, anchor);
}

/**
 * @param {Node} node
 * @returns {void}
 */
function detach_dev(node) {
	dispatch_dev('SvelteDOMRemove', { node });
	detach(node);
}

/**
 * @param {Node} before
 * @param {Node} after
 * @returns {void}
 */
function detach_between_dev(before, after) {
	while (before.nextSibling && before.nextSibling !== after) {
		detach_dev(before.nextSibling);
	}
}

/**
 * @param {Node} after
 * @returns {void}
 */
function detach_before_dev(after) {
	while (after.previousSibling) {
		detach_dev(after.previousSibling);
	}
}

/**
 * @param {Node} before
 * @returns {void}
 */
function detach_after_dev(before) {
	while (before.nextSibling) {
		detach_dev(before.nextSibling);
	}
}

/**
 * @param {Node} node
 * @param {string} event
 * @param {EventListenerOrEventListenerObject} handler
 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
 * @param {boolean} [has_prevent_default]
 * @param {boolean} [has_stop_propagation]
 * @param {boolean} [has_stop_immediate_propagation]
 * @returns {() => void}
 */
function listen_dev(
	node,
	event,
	handler,
	options,
	has_prevent_default,
	has_stop_propagation,
	has_stop_immediate_propagation
) {
	const modifiers =
		options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
	if (has_prevent_default) modifiers.push('preventDefault');
	if (has_stop_propagation) modifiers.push('stopPropagation');
	if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');
	dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
	const dispose = listen(node, event, handler, options);
	return () => {
		dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
		dispose();
	};
}

/**
 * @param {Element} node
 * @param {string} attribute
 * @param {string} [value]
 * @returns {void}
 */
function attr_dev(node, attribute, value) {
	attr(node, attribute, value);
	if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
	else dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
}

/**
 * @param {Element} node
 * @param {string} property
 * @param {any} [value]
 * @returns {void}
 */
function prop_dev(node, property, value) {
	node[property] = value;
	dispatch_dev('SvelteDOMSetProperty', { node, property, value });
}

/**
 * @param {HTMLElement} node
 * @param {string} property
 * @param {any} [value]
 * @returns {void}
 */
function dataset_dev(node, property, value) {
	node.dataset[property] = value;
	dispatch_dev('SvelteDOMSetDataset', { node, property, value });
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data_dev(text, data) {
	data = '' + data;
	if (text.data === data) return;
	dispatch_dev('SvelteDOMSetData', { node: text, data });
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data_contenteditable_dev(text, data) {
	data = '' + data;
	if (text.wholeText === data) return;
	dispatch_dev('SvelteDOMSetData', { node: text, data });
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @param {string} attr_value
 * @returns {void}
 */
function set_data_maybe_contenteditable_dev(text, data, attr_value) {
	if (~contenteditable_truthy_values.indexOf(attr_value)) {
		set_data_contenteditable_dev(text, data);
	} else {
		set_data_dev(text, data);
	}
}

function ensure_array_like_dev(arg) {
	if (
		typeof arg !== 'string' &&
		!(arg && typeof arg === 'object' && 'length' in arg) &&
		!(typeof Symbol === 'function' && arg && Symbol.iterator in arg)
	) {
		throw new Error('{#each} only works with iterable values.');
	}
	return each_ensure_array_like(arg);
}

/**
 * @returns {void} */
function validate_slots(name, slot, keys) {
	for (const slot_key of Object.keys(slot)) {
		if (!~keys.indexOf(slot_key)) {
			console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
		}
	}
}

/**
 * @param {unknown} tag
 * @returns {void}
 */
function validate_dynamic_element(tag) {
	const is_string = typeof tag === 'string';
	if (tag && !is_string) {
		throw new Error('<svelte:element> expects "this" attribute to be a string.');
	}
}

/**
 * @param {undefined | string} tag
 * @returns {void}
 */
function validate_void_dynamic_element(tag) {
	if (tag && is_void(tag)) {
		console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
	}
}

function construct_svelte_component_dev(component, props) {
	const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
	try {
		const instance = new component(props);
		if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
			throw new Error(error_message);
		}
		return instance;
	} catch (err) {
		const { message } = err;
		if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
			throw new Error(error_message);
		} else {
			throw err;
		}
	}
}

/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 *
 * Can be used to create strongly typed Svelte components.
 *
 * #### Example:
 *
 * You have component library on npm called `component-library`, from which
 * you export a component called `MyComponent`. For Svelte+TypeScript users,
 * you want to provide typings. Therefore you create a `index.d.ts`:
 * ```ts
 * import { SvelteComponent } from "svelte";
 * export class MyComponent extends SvelteComponent<{foo: string}> {}
 * ```
 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
 * to provide intellisense and to use the component like this in a Svelte file
 * with TypeScript:
 * ```svelte
 * <script lang="ts">
 * 	import { MyComponent } from "component-library";
 * </script>
 * <MyComponent foo={'bar'} />
 * ```
 * @template {Record<string, any>} [Props=any]
 * @template {Record<string, any>} [Events=any]
 * @template {Record<string, any>} [Slots=any]
 * @extends {SvelteComponent<Props, Events>}
 */
class SvelteComponentDev extends SvelteComponent {
	/**
	 * For type checking capabilities only.
	 * Does not exist at runtime.
	 * ### DO NOT USE!
	 *
	 * @type {Props}
	 */
	$$prop_def;
	/**
	 * For type checking capabilities only.
	 * Does not exist at runtime.
	 * ### DO NOT USE!
	 *
	 * @type {Events}
	 */
	$$events_def;
	/**
	 * For type checking capabilities only.
	 * Does not exist at runtime.
	 * ### DO NOT USE!
	 *
	 * @type {Slots}
	 */
	$$slot_def;

	/** @param {import('./public.js').ComponentConstructorOptions<Props>} options */
	constructor(options) {
		if (!options || (!options.target && !options.$$inline)) {
			throw new Error("'target' is a required option");
		}
		super();
	}

	/** @returns {void} */
	$destroy() {
		super.$destroy();
		this.$destroy = () => {
			console.warn('Component was already destroyed'); // eslint-disable-line no-console
		};
	}

	/** @returns {void} */
	$capture_state() {}

	/** @returns {void} */
	$inject_state() {}
}
/**
 * @template {Record<string, any>} [Props=any]
 * @template {Record<string, any>} [Events=any]
 * @template {Record<string, any>} [Slots=any]
 * @deprecated Use `SvelteComponent` instead. See PR for more information: https://github.com/sveltejs/svelte/pull/8512
 * @extends {SvelteComponentDev<Props, Events, Slots>}
 */
class SvelteComponentTyped extends (/* unused pure expression or super */ null && (SvelteComponentDev)) {}

/** @returns {() => void} */
function loop_guard(timeout) {
	const start = Date.now();
	return () => {
		if (Date.now() - start > timeout) {
			throw new Error('Infinite loop detected');
		}
	};
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/index.js
















;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/disclose-version/index.js


if (typeof window !== 'undefined')
	// @ts-ignore
	(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/index.js


;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/store/index.js


const subscriber_queue = [];

/**
 * Creates a `Readable` store that allows reading by subscription.
 *
 * https://svelte.dev/docs/svelte-store#readable
 * @template T
 * @param {T} [value] initial value
 * @param {import('./public.js').StartStopNotifier<T>} [start]
 * @returns {import('./public.js').Readable<T>}
 */
function readable(value, start) {
	return {
		subscribe: writable(value, start).subscribe
	};
}

/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 *
 * https://svelte.dev/docs/svelte-store#writable
 * @template T
 * @param {T} [value] initial value
 * @param {import('./public.js').StartStopNotifier<T>} [start]
 * @returns {import('./public.js').Writable<T>}
 */
function writable(value, start = utils_noop) {
	/** @type {import('./public.js').Unsubscriber} */
	let stop;
	/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
	const subscribers = new Set();
	/** @param {T} new_value
	 * @returns {void}
	 */
	function set(new_value) {
		if (safe_not_equal(value, new_value)) {
			value = new_value;
			if (stop) {
				// store is ready
				const run_queue = !subscriber_queue.length;
				for (const subscriber of subscribers) {
					subscriber[1]();
					subscriber_queue.push(subscriber, value);
				}
				if (run_queue) {
					for (let i = 0; i < subscriber_queue.length; i += 2) {
						subscriber_queue[i][0](subscriber_queue[i + 1]);
					}
					subscriber_queue.length = 0;
				}
			}
		}
	}

	/**
	 * @param {import('./public.js').Updater<T>} fn
	 * @returns {void}
	 */
	function update(fn) {
		set(fn(value));
	}

	/**
	 * @param {import('./public.js').Subscriber<T>} run
	 * @param {import('./private.js').Invalidator<T>} [invalidate]
	 * @returns {import('./public.js').Unsubscriber}
	 */
	function subscribe(run, invalidate = utils_noop) {
		/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
		const subscriber = [run, invalidate];
		subscribers.add(subscriber);
		if (subscribers.size === 1) {
			stop = start(set, update) || utils_noop;
		}
		run(value);
		return () => {
			subscribers.delete(subscriber);
			if (subscribers.size === 0 && stop) {
				stop();
				stop = null;
			}
		};
	}
	return { set, update, subscribe };
}

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 *
 * https://svelte.dev/docs/svelte-store#derived
 * @template {import('./private.js').Stores} S
 * @template T
 * @overload
 * @param {S} stores - input stores
 * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values
 * @param {T} [initial_value] - initial value
 * @returns {import('./public.js').Readable<T>}
 */

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 *
 * https://svelte.dev/docs/svelte-store#derived
 * @template {import('./private.js').Stores} S
 * @template T
 * @overload
 * @param {S} stores - input stores
 * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values
 * @param {T} [initial_value] - initial value
 * @returns {import('./public.js').Readable<T>}
 */

/**
 * @template {import('./private.js').Stores} S
 * @template T
 * @param {S} stores
 * @param {Function} fn
 * @param {T} [initial_value]
 * @returns {import('./public.js').Readable<T>}
 */
function derived(stores, fn, initial_value) {
	const single = !Array.isArray(stores);
	/** @type {Array<import('./public.js').Readable<any>>} */
	const stores_array = single ? [stores] : stores;
	if (!stores_array.every(Boolean)) {
		throw new Error('derived() expects stores as input, got a falsy value');
	}
	const auto = fn.length < 2;
	return readable(initial_value, (set, update) => {
		let started = false;
		const values = [];
		let pending = 0;
		let cleanup = noop;
		const sync = () => {
			if (pending) {
				return;
			}
			cleanup();
			const result = fn(single ? values[0] : values, set, update);
			if (auto) {
				set(result);
			} else {
				cleanup = is_function(result) ? result : noop;
			}
		};
		const unsubscribers = stores_array.map((store, i) =>
			subscribe(
				store,
				(value) => {
					values[i] = value;
					pending &= ~(1 << i);
					if (started) {
						sync();
					}
				},
				() => {
					pending |= 1 << i;
				}
			)
		);
		started = true;
		sync();
		return function stop() {
			run_all(unsubscribers);
			cleanup();
			// We need to set this to false because callbacks can still happen despite having unsubscribed:
			// Callbacks might already be placed in the queue which doesn't know it should no longer
			// invoke this derived store.
			started = false;
		};
	});
}

/**
 * Takes a store and returns a new one derived from the old one that is readable.
 *
 * https://svelte.dev/docs/svelte-store#readonly
 * @template T
 * @param {import('./public.js').Readable<T>} store  - store to make readonly
 * @returns {import('./public.js').Readable<T>}
 */
function readonly(store) {
	return {
		subscribe: store.subscribe.bind(store)
	};
}



;// CONCATENATED MODULE: ./src/store.ts

let gallery_open = writable(false);
let floating_modal_message = writable(undefined);

;// CONCATENATED MODULE: ./node_modules/@0b5vr/experimental/dist/0b5vr-experimental.esm.js
/*!
* @0b5vr/experimental v0.9.5
* Experimental edition of 0b5vr
*
* Copyright (c) 2019-2023 0b5vr
* @0b5vr/experimental is distributed under MIT License
* https://github.com/0b5vr/experimental-npm/blob/release/LICENSE
*/
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/algorithm/binarySearch.ts
function binarySearch(array, elementOrCompare) {
  if (typeof elementOrCompare !== "function") {
    return binarySearch(array, (element) => element < elementOrCompare);
  }
  const compare = elementOrCompare;
  let start = 0;
  let end = array.length;
  while (start < end) {
    const center = start + end >> 1;
    const centerElement = array[center];
    const compareResult = compare(centerElement);
    if (compareResult) {
      start = center + 1;
    } else {
      end = center;
    }
  }
  return start;
}

// src/algorithm/traverse.ts
function traverse(root, traverser) {
  const nodesNeedProcess = [root];
  const nodesSeen = new Set(nodesNeedProcess);
  while (nodesNeedProcess.length > 0) {
    const currentNode = nodesNeedProcess.shift();
    const children = traverser(currentNode);
    if (!children) {
      break;
    }
    const nodesFound = children.filter((node) => !nodesSeen.has(node));
    nodesNeedProcess.unshift(...nodesFound);
    nodesFound.map((node) => nodesSeen.add(node));
  }
}

// src/array/arrayRange.ts
function arrayRange(start, end, step) {
  let current = start;
  const ret = [];
  if (start < end) {
    step = step != null ? step : 1;
    while (current < end) {
      ret.push(current);
      current += step;
    }
  } else {
    step = step != null ? step : -1;
    while (current > end) {
      ret.push(current);
      current += step;
    }
  }
  return ret;
}

// src/array/arraySerial.ts
var arraySerial = (count) => [...Array(count)].map((_, i) => i);

// src/array/arraySet.ts
function arraySetDelete(array, value) {
  const index = array.indexOf(value);
  if (index === -1) {
    return false;
  }
  array.splice(index, 1);
  return true;
}
function arraySetHas(array, value) {
  return array.indexOf(value) !== -1;
}
function arraySetAdd(array, value) {
  const index = array.indexOf(value);
  if (index !== -1) {
    return false;
  }
  array.push(value);
  return true;
}
function arraySetUnion(a, b) {
  const out = [...a];
  b.forEach((v) => {
    if (!arraySetHas(out, v)) {
      out.push(v);
    }
  });
  return out;
}
function arraySetDiff(from, diff) {
  const out = [...from];
  diff.forEach((v) => {
    arraySetDelete(out, v);
  });
  return out;
}

// src/array/constants.ts
var TRIANGLE_STRIP_QUAD = (/* unused pure expression or super */ null && ([-1, -1, 1, -1, -1, 1, 1, 1]));
var TRIANGLE_STRIP_QUAD_3D = (/* unused pure expression or super */ null && ([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]));
var TRIANGLE_STRIP_QUAD_NORMAL = (/* unused pure expression or super */ null && ([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]));
var TRIANGLE_STRIP_QUAD_UV = (/* unused pure expression or super */ null && ([0, 0, 1, 0, 0, 1, 1, 1]));

// src/array/utils.ts
function shuffleArray(array, dice) {
  const f = dice ? dice : () => Math.random();
  for (let i = 0; i < array.length - 1; i++) {
    const ir = i + Math.floor(f() * (array.length - i));
    const temp = array[ir];
    array[ir] = array[i];
    array[i] = temp;
  }
  return array;
}
function triIndexToLineIndex(array) {
  const ret = [];
  for (let i = 0; i < array.length / 3; i++) {
    const head = i * 3;
    ret.push(array[head], array[head + 1], array[head + 1], array[head + 2], array[head + 2], array[head]);
  }
  return ret;
}
function matrix2d(w, h) {
  const arr = [];
  for (let iy = 0; iy < h; iy++) {
    for (let ix = 0; ix < w; ix++) {
      arr.push(ix, iy);
    }
  }
  return arr;
}
function matrix3d(w, h, d) {
  const arr = [];
  for (let iz = 0; iz < d; iz++) {
    for (let iy = 0; iy < h; iy++) {
      for (let ix = 0; ix < w; ix++) {
        arr.push(ix, iy, iz);
      }
    }
  }
  return arr;
}

// src/CDS/CDS.ts
var CDS = class {
  constructor() {
    this.factor = 100;
    this.ratio = 1;
    this.velocity = 0;
    this.value = 0;
    this.target = 0;
  }
  update(deltaTime) {
    this.velocity += (-this.factor * (this.value - this.target) - 2 * this.velocity * Math.sqrt(this.factor) * this.ratio) * deltaTime;
    this.value += this.velocity * deltaTime;
    return this.value;
  }
};

// src/Clock/Clock.ts
var Clock = class {
  constructor() {
    this.__time = 0;
    this.__deltaTime = 0;
    this.__isPlaying = false;
  }
  get time() {
    return this.__time;
  }
  get deltaTime() {
    return this.__deltaTime;
  }
  get isPlaying() {
    return this.__isPlaying;
  }
  update(time) {
    const prevTime = this.__time;
    this.__time = time || 0;
    this.__deltaTime = this.__time - prevTime;
  }
  play() {
    this.__isPlaying = true;
  }
  pause() {
    this.__isPlaying = false;
  }
  setTime(time) {
    this.__time = time;
  }
};

// src/Clock/ClockFrame.ts
var ClockFrame = class extends (/* unused pure expression or super */ null && (Clock)) {
  constructor(fps = 60) {
    super();
    this.__frame = 0;
    this.__fps = fps;
  }
  get frame() {
    return this.__frame;
  }
  get fps() {
    return this.__fps;
  }
  update() {
    if (this.__isPlaying) {
      this.__time = this.__frame / this.__fps;
      this.__deltaTime = 1 / this.__fps;
      this.__frame++;
    } else {
      this.__deltaTime = 0;
    }
  }
  setTime(time) {
    this.__frame = Math.floor(this.__fps * time);
    this.__time = this.__frame / this.__fps;
  }
};

// src/Clock/ClockRealtime.ts
var ClockRealtime = class extends (/* unused pure expression or super */ null && (Clock)) {
  constructor() {
    super(...arguments);
    this.__rtTime = 0;
    this.__rtDate = performance.now();
  }
  get isRealtime() {
    return true;
  }
  update() {
    const now = performance.now();
    if (this.__isPlaying) {
      const prevTime = this.__time;
      const deltaDate = now - this.__rtDate;
      this.__time = this.__rtTime + deltaDate / 1e3;
      this.__deltaTime = this.time - prevTime;
    } else {
      this.__rtTime = this.time;
      this.__rtDate = now;
      this.__deltaTime = 0;
    }
  }
  setTime(time) {
    this.__time = time;
    this.__rtTime = this.time;
    this.__rtDate = performance.now();
  }
};

// src/color/colorFromAtariST.ts
function colorFromAtariST(stColor) {
  return [
    (stColor >> 8 & 7) / 7,
    (stColor >> 4 & 7) / 7,
    (stColor & 7) / 7
  ];
}

// src/math/utils.ts
function lerp(a, b, x) {
  return a + (b - a) * x;
}
function clamp(x, l, h) {
  return Math.min(Math.max(x, l), h);
}
function saturate(x) {
  return clamp(x, 0, 1);
}
function range(x, x0, x1, y0, y1) {
  return (x - x0) * (y1 - y0) / (x1 - x0) + y0;
}
function linearstep(a, b, x) {
  return saturate((x - a) / (b - a));
}
function smoothstep(a, b, x) {
  const t = linearstep(a, b, x);
  return t * t * (3 - 2 * t);
}
function smootherstep(a, b, x) {
  const t = linearstep(a, b, x);
  return t * t * t * (t * (t * 6 - 15) + 10);
}
function smootheststep(a, b, x) {
  const t = linearstep(a, b, x);
  return t * t * t * t * (t * (t * (-20 * t + 70) - 84) + 35);
}

// src/color/colorHSV2RGB.ts
function colorHSV2RGB([h, s, v]) {
  const ht = h % 1 * 6;
  return [0, 4, 2].map((p) => {
    const colH = Math.min(Math.max(Math.abs((ht + p) % 6 - 3) - 1, 0), 1);
    const colS = lerp(1, colH, s);
    return v * colS;
  });
}

// src/color/colorToHex.ts
function colorToHex(color) {
  return "#" + color.map((v) => ("0" + Math.round(saturate(v) * 255).toString(16)).slice(-2)).join("");
}

// src/math/vec/vecDot.ts
function vecDot(vecA, vecB) {
  return vecA.reduce((sum, v, i) => sum + v * vecB[i], 0);
}

// src/color/colorTurbo.ts
function colorTurbo(x) {
  const kr = [
    0.13572138,
    4.6153926,
    -42.66032258,
    132.13108234,
    -152.94239396,
    59.28637943
  ];
  const kg = [
    0.09140261,
    2.19418839,
    4.84296658,
    -14.18503333,
    4.27729857,
    2.82956604
  ];
  const kb = [
    0.1066733,
    12.64194608,
    -60.58204836,
    110.36276771,
    -89.90310912,
    27.34824973
  ];
  const xt = saturate(x);
  const xv = [
    1,
    xt,
    xt * xt,
    xt * xt * xt,
    xt * xt * xt * xt,
    xt * xt * xt * xt * xt
  ];
  const col = [
    saturate(vecDot(kr, xv)),
    saturate(vecDot(kg, xv)),
    saturate(vecDot(kb, xv))
  ];
  return col;
}

// src/color/eotfRec709.ts
function eotfRec709(value) {
  return value.map((v) => v < 0.081 ? v / 4.5 : Math.pow((v + 0.099) / 1.099, 1 / 0.45));
}

// src/color/oetfRec709.ts
function oetfRec709(luminance) {
  return luminance.map((l) => l < 0.018 ? 4.5 * l : 1.099 * Math.pow(l, 0.45) - 0.099);
}

// src/dag/dagEdgesParents.ts
function dagEdgesParents(edges, destination) {
  return edges.filter((edge) => edge[1] === destination).map((edge) => edge[0]);
}

// src/dag/dagEdgesAncestors.ts
function dagEdgesAncestors(edges, destination) {
  const ancestors = /* @__PURE__ */ new Set();
  traverse(destination, (node) => {
    const parents = dagEdgesParents(edges, node);
    parents.map((parent) => ancestors.add(parent));
    return parents;
  });
  return Array.from(ancestors);
}

// src/dag/dagEdgesChildren.ts
function dagEdgesChildren(edges, source) {
  return edges.filter((edge) => edge[0] === source).map((edge) => edge[1]);
}

// src/dag/dagEdgesDescendants.ts
function dagEdgesDescendants(edges, source) {
  const descendants = /* @__PURE__ */ new Set();
  traverse(source, (node) => {
    const children = dagEdgesChildren(edges, node);
    children.map((child) => descendants.add(child));
    return children;
  });
  return Array.from(descendants);
}

// src/dag/dagEdgesParent.ts
function dagEdgesParent(edges, destination) {
  var _a, _b;
  return (_b = (_a = edges.find((edge) => edge[1] === destination)) == null ? void 0 : _a[0]) != null ? _b : null;
}

// src/dag/dagEdgesResolve.ts
function dagEdgesResolve(edges, nodes) {
  const order = [];
  const nodeSet = new Set(nodes);
  let tempEdges = edges.concat();
  while (tempEdges.length > 0) {
    nodeSet.forEach((node) => {
      const hasParents = dagEdgesParent(tempEdges, node) != null;
      if (!hasParents) {
        nodeSet.delete(node);
        order.push(node);
        tempEdges = tempEdges.filter(([src]) => src !== node);
      }
    });
  }
  return order.concat(Array.from(nodeSet));
}

// src/edt/edt.ts
function edt1d(data, offset, stride, length) {
  let k = 0;
  const v = new Float32Array(length);
  v[0] = 0;
  const z = new Float32Array(length + 1);
  z[0] = -Infinity;
  z[1] = Infinity;
  const f = new Float32Array(length);
  for (let q = 0; q < length; q++) {
    f[q] = data[offset + q * stride];
  }
  for (let q = 1; q < length; q++) {
    let s = 0;
    while (0 <= k) {
      s = (f[q] + q * q - f[v[k]] - v[k] * v[k]) / (2 * q - 2 * v[k]);
      if (s <= z[k]) {
        k--;
      } else {
        break;
      }
    }
    k++;
    v[k] = q;
    z[k] = s;
    z[k + 1] = Infinity;
  }
  k = 0;
  for (let q = 0; q < length; q++) {
    while (z[k + 1] < q) {
      k++;
    }
    const qSubVK = q - v[k];
    data[offset + q * stride] = f[v[k]] + qSubVK * qSubVK;
  }
}
function edt2d(data, width, height) {
  for (let x = 0; x < width; x++) {
    edt1d(data, x, width, height);
  }
  for (let y = 0; y < height; y++) {
    edt1d(data, y * width, 1, width);
  }
}

// src/ExpSmooth/ExpSmooth.ts
var ExpSmooth = class {
  constructor() {
    this.factor = 10;
    this.target = 0;
    this.value = 0;
  }
  update(deltaTime) {
    this.value = lerp(this.target, this.value, Math.exp(-this.factor * deltaTime));
    return this.value;
  }
};

// src/Pool/Pool.ts
var Pool = class {
  constructor(array) {
    this.index = 0;
    this.array = array;
  }
  get current() {
    return this.array[this.index];
  }
  next() {
    this.index = (this.index + 1) % this.array.length;
    return this.current;
  }
};

// src/GPUTimer/GPUTimer.ts
var GPUTimer = class {
  static isSupported(gl) {
    return new Set(gl.getSupportedExtensions()).has("EXT_disjoint_timer_query_webgl2");
  }
  constructor(gl) {
    this.gl = gl;
    const queries = new Array(1024).fill(1).map(() => gl.createQuery());
    this.queries = new Pool(queries);
    this.stack = [];
    this.ext = gl.getExtension("EXT_disjoint_timer_query_webgl2");
    this.__loopTasks = /* @__PURE__ */ new Set();
    const update = () => {
      this.update();
      requestAnimationFrame(update);
    };
    update();
  }
  update() {
    Array.from(this.__loopTasks).forEach((task) => task());
  }
  measure(func) {
    return __async(this, null, function* () {
      const { gl } = this;
      if (this.stack.length !== 0) {
        gl.endQuery(this.ext.TIME_ELAPSED_EXT);
        const promiseFinishingPrev = this.check(this.queries.current);
        this.stack = this.stack.map((promiseAccum2) => __async(this, null, function* () {
          return (yield promiseAccum2) + (yield promiseFinishingPrev);
        }));
      }
      this.stack.push(Promise.resolve(0));
      gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.queries.next());
      func();
      gl.endQuery(this.ext.TIME_ELAPSED_EXT);
      const promiseAccum = this.stack.pop();
      const promiseThis = this.check(this.queries.current);
      if (this.stack.length !== 0) {
        this.stack = this.stack.map((promiseAccum2) => __async(this, null, function* () {
          return (yield promiseAccum2) + (yield promiseThis);
        }));
        gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.queries.next());
      }
      return (yield promiseAccum) + (yield promiseThis);
    });
  }
  check(query) {
    const { gl } = this;
    return new Promise((resolve) => {
      const task = () => {
        const isAvailable = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);
        if (isAvailable) {
          this.__loopTasks.delete(task);
          resolve(gl.getQueryParameter(query, gl.QUERY_RESULT) * 1e-3 * 1e-3);
        }
      };
      this.__loopTasks.add(task);
    });
  }
};

// src/HistoryMeanCalculator/HistoryMeanCalculator.ts
var HistoryMeanCalculator = class {
  constructor(length) {
    this.__recalcForEach = 0;
    this.__countUntilRecalc = 0;
    this.__history = [];
    this.__index = 0;
    this.__count = 0;
    this.__cache = 0;
    this.__length = length;
    this.__recalcForEach = length;
    for (let i = 0; i < length; i++) {
      this.__history[i] = 0;
    }
  }
  get mean() {
    const count = Math.min(this.__count, this.__length);
    return count === 0 ? 0 : this.__cache / count;
  }
  get recalcForEach() {
    return this.__recalcForEach;
  }
  set recalcForEach(value) {
    const delta = value - this.__recalcForEach;
    this.__recalcForEach = value;
    this.__countUntilRecalc = Math.max(0, this.__countUntilRecalc + delta);
  }
  reset() {
    this.__index = 0;
    this.__count = 0;
    this.__cache = 0;
    this.__countUntilRecalc = 0;
    for (let i = 0; i < this.__length; i++) {
      this.__history[i] = 0;
    }
  }
  push(value) {
    const prev = this.__history[this.__index];
    this.__history[this.__index] = value;
    this.__count++;
    this.__index = (this.__index + 1) % this.__length;
    if (this.__countUntilRecalc === 0) {
      this.recalc();
    } else {
      this.__countUntilRecalc--;
      this.__cache -= prev;
      this.__cache += value;
    }
  }
  recalc() {
    this.__countUntilRecalc = this.__recalcForEach;
    const sum = this.__history.slice(0, Math.min(this.__count, this.__length)).reduce((sum2, v) => sum2 + v, 0);
    this.__cache = sum;
  }
};

// src/HistoryMeanCalculator/HistoryPercentileCalculator.ts
var HistoryPercentileCalculator = class {
  constructor(length) {
    this.__history = [];
    this.__sorted = [];
    this.__index = 0;
    this.__length = length;
  }
  get median() {
    return this.percentile(50);
  }
  percentile(percentile) {
    if (this.__history.length === 0) {
      return 0;
    }
    return this.__sorted[Math.round(percentile * 0.01 * (this.__history.length - 1))];
  }
  reset() {
    this.__index = 0;
    this.__history = [];
    this.__sorted = [];
  }
  push(value) {
    const prev = this.__history[this.__index];
    this.__history[this.__index] = value;
    this.__index = (this.__index + 1) % this.__length;
    if (this.__sorted.length === this.__length) {
      const prevIndex = binarySearch(this.__sorted, prev);
      this.__sorted.splice(prevIndex, 1);
    }
    const index = binarySearch(this.__sorted, value);
    this.__sorted.splice(index, 0, value);
  }
};

// src/HistoryMeanCalculator/HistoryMedianCalculator.ts
var HistoryMedianCalculator = class extends (/* unused pure expression or super */ null && (HistoryPercentileCalculator)) {
  constructor(length) {
    super(length);
    console.warn("HistoryMedianCalculator: Deprecated. Use HistoryPercentileCalculator instead");
  }
};

// src/MapOfSet/MapOfSet.ts
var MapOfSet = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    var _a;
    return (_a = this.map.get(key)) != null ? _a : /* @__PURE__ */ new Set();
  }
  add(key, value) {
    let set = this.map.get(key);
    if (set == null) {
      set = /* @__PURE__ */ new Set();
      this.map.set(key, set);
    }
    set.add(value);
  }
};

// src/math/vec/vecAbs.ts
function vecAbs(vec) {
  return vec.map((v) => Math.abs(v));
}

// src/math/vec/vecAdd.ts
function vecAdd(...vecs) {
  if (vecs.length < 2) {
    return vecs[0];
  }
  const a = vecs.shift();
  const b = vecAdd(...vecs);
  return a.map((v, i) => v + b[i]);
}

// src/math/vec/vecDivide.ts
function vecDivide(vecA, vecB) {
  return vecA.map((v, i) => v / vecB[i]);
}

// src/math/vec/vecLength.ts
function vecLength(vec) {
  return Math.sqrt(vec.reduce((sum, v) => sum + v * v, 0));
}

// src/math/vec/vecLengthSq.ts
function vecLengthSq(vec) {
  return vec.reduce((sum, v) => sum + v * v, 0);
}

// src/math/vec/vecManhattanLength.ts
function vecManhattanLength(vec) {
  return vec.reduce((sum, v) => sum + Math.abs(v), 0);
}

// src/math/vec/vecMultiply.ts
function vecMultiply(...vecs) {
  if (vecs.length < 2) {
    return vecs[0];
  }
  const a = vecs.shift();
  const b = vecMultiply(...vecs);
  return a.map((v, i) => v * b[i]);
}

// src/math/vec/vecNeg.ts
function vecNeg(vec) {
  return vec.map((v) => -v);
}

// src/math/vec/vecScale.ts
function vecScale(vec, scalar) {
  return vec.map((v) => v * scalar);
}

// src/math/vec/vecNormalize.ts
function vecNormalize(vec) {
  const len = vecLength(vec);
  const invLen = len === 0 ? 0 : 1 / len;
  return vecScale(vec, invLen);
}

// src/math/vec/vecSub.ts
function vecSub(vecA, vecB) {
  return vecA.map((v, i) => v - vecB[i]);
}

// src/math/vec/Vector.ts
var Vector = class {
  get length() {
    return vecLength(this.elements);
  }
  get lengthSq() {
    return vecLengthSq(this.elements);
  }
  get manhattanLength() {
    return vecManhattanLength(this.elements);
  }
  get normalized() {
    return this.__new(vecNormalize(this.elements));
  }
  get negated() {
    return this.__new(vecNeg(this.elements));
  }
  get abs() {
    return this.__new(vecAbs(this.elements));
  }
  clone() {
    return this.__new(this.elements.concat());
  }
  add(...vectors) {
    return this.__new(vecAdd(this.elements, ...vectors.map((v) => v.elements)));
  }
  sub(vector) {
    return this.__new(vecSub(this.elements, vector.elements));
  }
  multiply(...vectors) {
    return this.__new(vecMultiply(this.elements, ...vectors.map((v) => v.elements)));
  }
  divide(vector) {
    return this.__new(vecDivide(this.elements, vector.elements));
  }
  scale(scalar) {
    return this.__new(vecScale(this.elements, scalar));
  }
  dot(vector) {
    return vecDot(this.elements, vector.elements);
  }
};

// src/math/vec4/vec4ApplyMatrix4.ts
function vec4ApplyMatrix4(v, m) {
  return [
    m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3],
    m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3],
    m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3],
    m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3]
  ];
}

// src/math/vec3/vec3ApplyMatrix4.ts
function vec3ApplyMatrix4(v, m) {
  const vec4 = vec4ApplyMatrix4([...v, 1], m);
  const xyz = [vec4[0], vec4[1], vec4[2]];
  const w = vec4[3];
  return vecScale(xyz, 1 / w);
}

// src/math/quat/quatInverse.ts
function quatInverse(quat) {
  return [-quat[0], -quat[1], -quat[2], quat[3]];
}

// src/math/quat/quatMultiply.ts
function quatMultiply(...quats) {
  if (quats.length < 2) {
    return quats[0];
  }
  const a = quats.shift();
  const b = quatMultiply(...quats);
  return [
    a[3] * b[0] + a[0] * b[3] + a[1] * b[2] - a[2] * b[1],
    a[3] * b[1] - a[0] * b[2] + a[1] * b[3] + a[2] * b[0],
    a[3] * b[2] + a[0] * b[1] - a[1] * b[0] + a[2] * b[3],
    a[3] * b[3] - a[0] * b[0] - a[1] * b[1] - a[2] * b[2]
  ];
}

// src/math/vec3/vec3ApplyQuaternion.ts
function vec3ApplyQuaternion(vec, quat) {
  const p = [...vec, 0];
  const r = quatInverse(quat);
  const res = quatMultiply(quat, p, r);
  res.pop();
  return res;
}

// src/math/vec3/vec3Cross.ts
function vec3Cross(vecA, vecB) {
  return [
    vecA[1] * vecB[2] - vecA[2] * vecB[1],
    vecA[2] * vecB[0] - vecA[0] * vecB[2],
    vecA[0] * vecB[1] - vecA[1] * vecB[0]
  ];
}

// src/math/vec3/vec3OrthoNormalize.ts
function vec3OrthoNormalize(normal, tangent = [0, 1, 0], binormal) {
  const n = vecNormalize(normal);
  let t = vecNormalize(tangent);
  let dotNT = vecDot(n, t);
  if (dotNT === 1) {
    if (Math.abs(n[1]) > Math.abs(n[2])) {
      t = [0, 0, 1];
    } else {
      t = [0, 1, 0];
    }
    dotNT = vecDot(n, t);
  }
  t = vecNormalize(vecSub(t, vecScale(n, dotNT)));
  let b = vec3Cross(t, n);
  if (binormal && vecDot(b, binormal) < 0) {
    b = vecNeg(b);
  }
  return {
    normal: n,
    tangent: t,
    binormal: b
  };
}

// src/math/vec3/Vector3.ts
var Vector3 = class extends (/* unused pure expression or super */ null && (Vector)) {
  constructor(v = [0, 0, 0]) {
    super();
    this.elements = v;
  }
  get x() {
    return this.elements[0];
  }
  set x(x) {
    this.elements[0] = x;
  }
  get y() {
    return this.elements[1];
  }
  set y(y) {
    this.elements[1] = y;
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
  }
  toString() {
    return `Vector3( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)} )`;
  }
  cross(vector) {
    return new Vector3(vec3Cross(this.elements, vector.elements));
  }
  applyQuaternion(quaternion) {
    return new Vector3(vec3ApplyQuaternion(this.elements, quaternion.elements));
  }
  applyMatrix4(matrix) {
    return new Vector3(vec3ApplyMatrix4(this.elements, matrix.elements));
  }
  __new(v) {
    return new Vector3(v);
  }
  static get zero() {
    return new Vector3([0, 0, 0]);
  }
  static get px() {
    return new Vector3([1, 0, 0]);
  }
  static get nx() {
    return new Vector3([-1, 0, 0]);
  }
  static get py() {
    return new Vector3([0, 1, 0]);
  }
  static get ny() {
    return new Vector3([0, -1, 0]);
  }
  static get pz() {
    return new Vector3([0, 0, 1]);
  }
  static get nz() {
    return new Vector3([0, 0, -1]);
  }
  static get one() {
    return new Vector3([1, 1, 1]);
  }
  static orthoNormalize(normal, tangent, binormal) {
    const result = vec3OrthoNormalize(normal.elements, tangent.elements, binormal.elements);
    return {
      normal: new Vector3(result.normal),
      tangent: new Vector3(result.tangent),
      binormal: new Vector3(result.binormal)
    };
  }
};

// src/math/box3/box3ContainsPoint.ts
function box3ContainsPoint(box, point) {
  return box[0][0] <= point[0] && box[1][0] >= point[0] && box[0][1] <= point[1] && box[1][1] >= point[1] && box[0][2] <= point[2] && box[1][2] >= point[2];
}

// src/math/box3/Box3.ts
var Box3 = class {
  constructor(min = Vector3.zero, max = Vector3.zero) {
    this.min = min;
    this.max = max;
  }
  get raw() {
    return [this.min.elements, this.max.elements];
  }
  containsPoint(point) {
    return box3ContainsPoint(this.raw, point.elements);
  }
  static fromRaw(box) {
    return new Box3(new Vector3(box[0]), new Vector3(box[1]));
  }
};

// src/math/mat3/mat3FromMat4Transpose.ts
function mat3FromMat4Transpose(source) {
  return [
    source[0],
    source[4],
    source[8],
    source[1],
    source[5],
    source[9],
    source[2],
    source[6],
    source[10]
  ];
}

// src/math/mat3/mat3Inverse.ts
function mat3Inverse(m) {
  const n11 = m[0], n21 = m[1], n31 = m[2], n12 = m[3], n22 = m[4], n32 = m[5], n13 = m[6], n23 = m[7], n33 = m[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
  if (det === 0) {
    return vecScale(m, 0);
  }
  return vecScale([
    t11,
    n31 * n23 - n33 * n21,
    n32 * n21 - n31 * n22,
    t12,
    n33 * n11 - n31 * n13,
    n31 * n12 - n32 * n11,
    t13,
    n21 * n13 - n23 * n11,
    n22 * n11 - n21 * n12
  ], 1 / det);
}

// src/math/mat3/mat3CreateNormalMatrix.ts
function mat3CreateNormalMatrix(m) {
  return mat3Inverse(mat3FromMat4Transpose(m));
}

// src/math/mat3/mat3Determinant.ts
function mat3Determinant(m) {
  const n11 = m[0], n21 = m[1], n31 = m[2], n12 = m[3], n22 = m[4], n32 = m[5], n13 = m[6], n23 = m[7], n33 = m[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13;
  return n11 * t11 + n21 * t12 + n31 * t13;
}

// src/math/mat3/mat3FromMat4.ts
function mat3FromMat4(source) {
  return [
    source[0],
    source[1],
    source[2],
    source[4],
    source[5],
    source[6],
    source[8],
    source[9],
    source[10]
  ];
}

// src/math/mat3/mat3FromQuaternion.ts
function mat3FromQuaternion(quat) {
  const x = quat[0];
  const y = quat[1];
  const z = quat[2];
  const w = quat[3];
  return [
    1 - 2 * y * y - 2 * z * z,
    2 * x * y + 2 * z * w,
    2 * x * z - 2 * y * w,
    2 * x * y - 2 * z * w,
    1 - 2 * x * x - 2 * z * z,
    2 * y * z + 2 * x * w,
    2 * x * z + 2 * y * w,
    2 * y * z - 2 * x * w,
    1 - 2 * x * x - 2 * y * y
  ];
}

// src/math/mat3/mat3Multiply.ts
function mat3Multiply(...mats) {
  if (mats.length < 2) {
    return mats[0];
  }
  const a = mats.shift();
  const b = mat3Multiply(...mats);
  const a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];
  return [
    a00 * b00 + a10 * b01 + a20 * b02,
    a01 * b00 + a11 * b01 + a21 * b02,
    a02 * b00 + a12 * b01 + a22 * b02,
    a00 * b10 + a10 * b11 + a20 * b12,
    a01 * b10 + a11 * b11 + a21 * b12,
    a02 * b10 + a12 * b11 + a22 * b12,
    a00 * b20 + a10 * b21 + a20 * b22,
    a01 * b20 + a11 * b21 + a21 * b22,
    a02 * b20 + a12 * b21 + a22 * b22
  ];
}

// src/math/mat3/mat3Transpose.ts
function mat3Transpose(source) {
  return [
    source[0],
    source[3],
    source[6],
    source[1],
    source[4],
    source[7],
    source[2],
    source[5],
    source[8]
  ];
}

// src/math/mat3/Matrix3.ts
var rawIdentityMatrix3 = (/* unused pure expression or super */ null && ([
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1
]));
var Matrix3 = class {
  constructor(v = rawIdentityMatrix3) {
    this.elements = v;
  }
  get transpose() {
    return new Matrix3(mat3Transpose(this.elements));
  }
  get determinant() {
    return mat3Determinant(this.elements);
  }
  get inverse() {
    return new Matrix3(mat3Inverse(this.elements));
  }
  get matrix4() {
    return Matrix4.fromMatrix3(this);
  }
  toString() {
    const m = this.elements.map((v) => v.toFixed(3));
    return `Matrix3( ${m[0]}, ${m[3]}, ${m[6]}; ${m[1]}, ${m[4]}, ${m[7]}; ${m[2]}, ${m[5]}, ${m[8]} )`;
  }
  clone() {
    return new Matrix3(this.elements.concat());
  }
  multiply(...matrices) {
    return Matrix3.multiply(this, ...matrices);
  }
  scaleScalar(scalar) {
    return new Matrix3(vecScale(this.elements, scalar));
  }
  static get identity() {
    return new Matrix3(rawIdentityMatrix3);
  }
  static multiply(...matrices) {
    if (matrices.length === 0) {
      return Matrix3.identity;
    } else {
      return new Matrix3(mat3Multiply(...matrices.map((m) => m.elements)));
    }
  }
  static createNormalMatrix(matrix4) {
    return new Matrix3(mat3CreateNormalMatrix(matrix4.elements));
  }
  static fromMatrix4(matrix4) {
    return new Matrix3(mat3FromMat4(matrix4.elements));
  }
  static fromQuaternion(quaternion) {
    return new Matrix3(mat3FromQuaternion(quaternion.elements));
  }
};

// src/math/mat4/mat4FromQuaternion.ts
function mat4FromQuaternion(quat) {
  const x = quat[0];
  const y = quat[1];
  const z = quat[2];
  const w = quat[3];
  return [
    1 - 2 * y * y - 2 * z * z,
    2 * x * y + 2 * z * w,
    2 * x * z - 2 * y * w,
    0,
    2 * x * y - 2 * z * w,
    1 - 2 * x * x - 2 * z * z,
    2 * y * z + 2 * x * w,
    0,
    2 * x * z + 2 * y * w,
    2 * y * z - 2 * x * w,
    1 - 2 * x * x - 2 * y * y,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Compose.ts
function mat4Compose(position, rotation, scale) {
  const matRot = mat4FromQuaternion(rotation);
  const sx = scale[0], sy = scale[1], sz = scale[2];
  return [
    matRot[0] * sx,
    matRot[1] * sx,
    matRot[2] * sx,
    0,
    matRot[4] * sy,
    matRot[5] * sy,
    matRot[6] * sy,
    0,
    matRot[8] * sz,
    matRot[9] * sz,
    matRot[10] * sz,
    0,
    position[0],
    position[1],
    position[2],
    1
  ];
}

// src/math/mat4/mat4Determinant.ts
function mat4Determinant(m) {
  const a00 = m[0], a01 = m[1], a02 = m[2], a03 = m[3], a10 = m[4], a11 = m[5], a12 = m[6], a13 = m[7], a20 = m[8], a21 = m[9], a22 = m[10], a23 = m[11], a30 = m[12], a31 = m[13], a32 = m[14], a33 = m[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

// src/math/quat/quatFromMatrix3.ts
function quatFromMatrix3(m) {
  const m11 = m[0], m12 = m[3], m13 = m[6], m21 = m[1], m22 = m[4], m23 = m[7], m31 = m[2], m32 = m[5], m33 = m[8], trace = m11 + m22 + m33;
  if (trace > 0) {
    const s = 0.5 / Math.sqrt(trace + 1);
    return [
      (m32 - m23) * s,
      (m13 - m31) * s,
      (m21 - m12) * s,
      0.25 / s
    ];
  } else if (m11 > m22 && m11 > m33) {
    const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
    return [
      0.25 * s,
      (m12 + m21) / s,
      (m13 + m31) / s,
      (m32 - m23) / s
    ];
  } else if (m22 > m33) {
    const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
    return [
      (m12 + m21) / s,
      0.25 * s,
      (m23 + m32) / s,
      (m13 - m31) / s
    ];
  } else {
    const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
    return [
      (m13 + m31) / s,
      (m23 + m32) / s,
      0.25 * s,
      (m21 - m12) / s
    ];
  }
}

// src/math/quat/quatFromMatrix4.ts
function quatFromMatrix4(m) {
  return quatFromMatrix3(mat3FromMat4(m));
}

// src/math/mat4/mat4Decompose.ts
function mat4Decompose(m) {
  let sx = vecLength([m[0], m[1], m[2]]);
  const sy = vecLength([m[4], m[5], m[6]]);
  const sz = vecLength([m[8], m[9], m[10]]);
  const det = mat4Determinant(m);
  if (det < 0) {
    sx = -sx;
  }
  const invSx = 1 / sx;
  const invSy = 1 / sy;
  const invSz = 1 / sz;
  const rotationMatrix = m.concat();
  rotationMatrix[0] *= invSx;
  rotationMatrix[1] *= invSx;
  rotationMatrix[2] *= invSx;
  rotationMatrix[4] *= invSy;
  rotationMatrix[5] *= invSy;
  rotationMatrix[6] *= invSy;
  rotationMatrix[8] *= invSz;
  rotationMatrix[9] *= invSz;
  rotationMatrix[10] *= invSz;
  return {
    position: [m[12], m[13], m[14]],
    scale: [sx, sy, sz],
    rotation: quatFromMatrix4(rotationMatrix)
  };
}

// src/math/mat4/mat4FromMat3.ts
function mat4FromMat3(source) {
  return [
    source[0],
    source[1],
    source[2],
    0,
    source[3],
    source[4],
    source[5],
    0,
    source[6],
    source[7],
    source[8],
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Inverse.ts
function mat4Inverse(m) {
  const a00 = m[0], a01 = m[1], a02 = m[2], a03 = m[3], a10 = m[4], a11 = m[5], a12 = m[6], a13 = m[7], a20 = m[8], a21 = m[9], a22 = m[10], a23 = m[11], a30 = m[12], a31 = m[13], a32 = m[14], a33 = m[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
  const det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (det === 0) {
    return vecScale(m, 0);
  }
  return vecScale([
    a11 * b11 - a12 * b10 + a13 * b09,
    a02 * b10 - a01 * b11 - a03 * b09,
    a31 * b05 - a32 * b04 + a33 * b03,
    a22 * b04 - a21 * b05 - a23 * b03,
    a12 * b08 - a10 * b11 - a13 * b07,
    a00 * b11 - a02 * b08 + a03 * b07,
    a32 * b02 - a30 * b05 - a33 * b01,
    a20 * b05 - a22 * b02 + a23 * b01,
    a10 * b10 - a11 * b08 + a13 * b06,
    a01 * b08 - a00 * b10 - a03 * b06,
    a30 * b04 - a31 * b02 + a33 * b00,
    a21 * b02 - a20 * b04 - a23 * b00,
    a11 * b07 - a10 * b09 - a12 * b06,
    a00 * b09 - a01 * b07 + a02 * b06,
    a31 * b01 - a30 * b03 - a32 * b00,
    a20 * b03 - a21 * b01 + a22 * b00
  ], 1 / det);
}

// src/math/mat4/mat4LookAt.ts
function mat4LookAt(position, target = [0, 0, 0], up = [0, 1, 0], roll = 0) {
  const dir = vecNormalize(vecSub(position, target));
  let sid = vecNormalize(vec3Cross(up, dir));
  if (roll !== 0) {
    sid = vecAdd(vecScale(sid, Math.cos(roll)), vecScale(vec3Cross(dir, sid), Math.sin(roll)));
  }
  const top = vec3Cross(dir, sid);
  return [
    sid[0],
    sid[1],
    sid[2],
    0,
    top[0],
    top[1],
    top[2],
    0,
    dir[0],
    dir[1],
    dir[2],
    0,
    position[0],
    position[1],
    position[2],
    1
  ];
}

// src/math/mat4/mat4LookAtInverse.ts
function mat4LookAtInverse(position, target = [0, 0, 0], up = [0, 1, 0], roll = 0) {
  const dir = vecNormalize(vecSub(position, target));
  let sid = vecNormalize(vec3Cross(up, dir));
  if (roll !== 0) {
    sid = vecAdd(vecScale(sid, Math.cos(roll)), vecScale(vec3Cross(dir, sid), Math.sin(roll)));
  }
  const top = vec3Cross(dir, sid);
  return [
    sid[0],
    top[0],
    dir[0],
    0,
    sid[1],
    top[1],
    dir[1],
    0,
    sid[2],
    top[2],
    dir[2],
    0,
    -vecDot(sid, position),
    -vecDot(top, position),
    -vecDot(dir, position),
    1
  ];
}

// src/math/mat4/mat4Multiply.ts
function mat4Multiply(...mats) {
  if (mats.length < 2) {
    return mats[0];
  }
  const a = mats.shift();
  const b = mat4Multiply(...mats);
  const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3], b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7], b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11], b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];
  return [
    a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03,
    a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03,
    a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03,
    a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03,
    a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13,
    a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13,
    a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13,
    a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13,
    a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23,
    a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23,
    a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23,
    a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23,
    a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33,
    a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33,
    a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33,
    a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33
  ];
}

// src/math/mat4/mat4Perspective.ts
function mat4Perspective(fov = 45, near = 0.01, far = 100, aspect = 1) {
  const p = 1 / Math.tan(fov * Math.PI / 360);
  const d = far - near;
  return [
    p / aspect,
    0,
    0,
    0,
    0,
    p,
    0,
    0,
    0,
    0,
    -(far + near) / d,
    -1,
    0,
    0,
    -2 * far * near / d,
    0
  ];
}

// src/math/mat4/mat4RotationX.ts
function mat4RotationX(theta) {
  const c = Math.cos(theta);
  const s = Math.sin(theta);
  return [
    1,
    0,
    0,
    0,
    0,
    c,
    -s,
    0,
    0,
    s,
    c,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4RotationY.ts
function mat4RotationY(theta) {
  const c = Math.cos(theta);
  const s = Math.sin(theta);
  return [
    c,
    0,
    s,
    0,
    0,
    1,
    0,
    0,
    -s,
    0,
    c,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4RotationZ.ts
function mat4RotationZ(theta) {
  const c = Math.cos(theta);
  const s = Math.sin(theta);
  return [
    c,
    -s,
    0,
    0,
    s,
    c,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Scale.ts
function mat4Scale(vec) {
  return [
    vec[0],
    0,
    0,
    0,
    0,
    vec[1],
    0,
    0,
    0,
    0,
    vec[2],
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4ScaleScalar.ts
function mat4ScaleScalar(scalar) {
  return [
    scalar,
    0,
    0,
    0,
    0,
    scalar,
    0,
    0,
    0,
    0,
    scalar,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Translate.ts
function mat4Translate(vec) {
  return [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    vec[0],
    vec[1],
    vec[2],
    1
  ];
}

// src/math/mat4/mat4Transpose.ts
function mat4Transpose(m) {
  return [
    m[0],
    m[4],
    m[8],
    m[12],
    m[1],
    m[5],
    m[9],
    m[13],
    m[2],
    m[6],
    m[10],
    m[14],
    m[3],
    m[7],
    m[11],
    m[15]
  ];
}

// src/math/mat4/Matrix4.ts
var rawIdentityMatrix4 = (/* unused pure expression or super */ null && ([
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
]));
var Matrix4 = class {
  constructor(v = rawIdentityMatrix4) {
    this.elements = v;
  }
  get transpose() {
    return new Matrix4(mat4Transpose(this.elements));
  }
  get determinant() {
    return mat4Determinant(this.elements);
  }
  get inverse() {
    return new Matrix4(mat4Inverse(this.elements));
  }
  get matrix3() {
    return Matrix3.fromMatrix4(this);
  }
  get normalMatrix() {
    return Matrix3.createNormalMatrix(this);
  }
  toString() {
    const m = this.elements.map((v) => v.toFixed(3));
    return `Matrix4( ${m[0]}, ${m[4]}, ${m[8]}, ${m[12]}; ${m[1]}, ${m[5]}, ${m[9]}, ${m[13]}; ${m[2]}, ${m[6]}, ${m[10]}, ${m[14]}; ${m[3]}, ${m[7]}, ${m[11]}, ${m[15]} )`;
  }
  clone() {
    return new Matrix4(this.elements.concat());
  }
  multiply(...matrices) {
    return Matrix4.multiply(this, ...matrices);
  }
  scaleScalar(scalar) {
    return new Matrix4(vecScale(this.elements, scalar));
  }
  decompose() {
    const { position, scale, rotation } = mat4Decompose(this.elements);
    return {
      position: new Vector3(position),
      scale: new Vector3(scale),
      rotation: new Quaternion(rotation)
    };
  }
  static get identity() {
    return new Matrix4(rawIdentityMatrix4);
  }
  static multiply(...matrices) {
    if (matrices.length === 0) {
      return Matrix4.identity;
    } else {
      return new Matrix4(mat4Multiply(...matrices.map((m) => m.elements)));
    }
  }
  static fromQuaternion(quaternion) {
    return new Matrix4(mat4FromQuaternion(quaternion.elements));
  }
  static fromMatrix3(matrix3) {
    return new Matrix4(mat4FromMat3(matrix3.elements));
  }
  static translate(vector) {
    return new Matrix4(mat4Translate(vector.elements));
  }
  static scale(vector) {
    return new Matrix4(mat4Scale(vector.elements));
  }
  static scaleScalar(scalar) {
    return new Matrix4(mat4ScaleScalar(scalar));
  }
  static rotationX(theta) {
    return new Matrix4(mat4RotationX(theta));
  }
  static rotationY(theta) {
    return new Matrix4(mat4RotationY(theta));
  }
  static rotationZ(theta) {
    return new Matrix4(mat4RotationZ(theta));
  }
  static lookAt(position, target = new Vector3([0, 0, 0]), up = new Vector3([0, 1, 0]), roll = 0) {
    return new Matrix4(mat4LookAt(position.elements, target.elements, up.elements, roll));
  }
  static lookAtInverse(position, target = new Vector3([0, 0, 0]), up = new Vector3([0, 1, 0]), roll = 0) {
    return new Matrix4(mat4LookAtInverse(position.elements, target.elements, up.elements, roll));
  }
  static perspective(fov = 45, near = 0.01, far = 100) {
    return new Matrix4(mat4Perspective(fov, near, far));
  }
  static compose(position, rotation, scale) {
    return new Matrix4(mat4Compose(position.elements, rotation.elements, scale.elements));
  }
};

// src/math/quat/quatFromAxisAngle.ts
function quatFromAxisAngle(axis, angle) {
  const halfAngle = angle / 2;
  const sinHalfAngle = Math.sin(halfAngle);
  return [
    axis[0] * sinHalfAngle,
    axis[1] * sinHalfAngle,
    axis[2] * sinHalfAngle,
    Math.cos(halfAngle)
  ];
}

// src/math/quat/quatLookRotation.ts
function quatLookRotation(look, up) {
  const { normal, tangent, binormal } = vec3OrthoNormalize(look, up != null ? up : [0, 1, 0]);
  const w = Math.sqrt(1 + binormal[0] + tangent[1] + normal[2]) * 0.5;
  const invW4 = 0.25 / w;
  return [
    (tangent[2] - normal[1]) * invW4,
    (normal[0] - binormal[2]) * invW4,
    (binormal[1] - tangent[0]) * invW4,
    w
  ];
}

// src/math/quat/quatNormalize.ts
function quatNormalize(vec) {
  const len = vecLength(vec);
  if (len === 0) {
    return [0, 0, 0, 1];
  }
  return vecScale(vec, 1 / len);
}

// src/math/quat/quatRotationX.ts
function quatRotationX(theta) {
  return [Math.sin(theta / 2), 0, 0, Math.cos(theta / 2)];
}

// src/math/quat/quatRotationY.ts
function quatRotationY(theta) {
  return [0, Math.sin(theta / 2), 0, Math.cos(theta / 2)];
}

// src/math/quat/quatRotationZ.ts
function quatRotationZ(theta) {
  return [0, 0, Math.sin(theta / 2), Math.cos(theta / 2)];
}

// src/math/quat/quatSlerp.ts
function quatSlerp(a, b, t) {
  if (t === 0) {
    return a.concat();
  }
  if (t === 1) {
    return b.concat();
  }
  let cosHalfTheta = vecDot(a, b);
  if (cosHalfTheta < 0) {
    b = vecNeg(b);
    cosHalfTheta = -cosHalfTheta;
  }
  if (cosHalfTheta >= 1) {
    return a.concat();
  }
  const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
  if (sqrSinHalfTheta <= Number.EPSILON) {
    const s = 1 - t;
    return vecNormalize([
      s * a[0] + t * b[0],
      s * a[1] + t * b[1],
      s * a[2] + t * b[2],
      s * a[3] + t * b[3]
    ]);
  }
  const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
  const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
  const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
  const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
  return [
    a[0] * ratioA + b[0] * ratioB,
    a[1] * ratioA + b[1] * ratioB,
    a[2] * ratioA + b[2] * ratioB,
    a[3] * ratioA + b[3] * ratioB
  ];
}

// src/math/quat/Quaternion.ts
var rawIdentityQuaternion = (/* unused pure expression or super */ null && ([0, 0, 0, 1]));
var Quaternion = class {
  constructor(elements = rawIdentityQuaternion) {
    this.elements = elements;
  }
  get x() {
    return this.elements[0];
  }
  get y() {
    return this.elements[1];
  }
  get z() {
    return this.elements[2];
  }
  get w() {
    return this.elements[3];
  }
  toString() {
    return `Quaternion( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)}, ${this.w.toFixed(3)} )`;
  }
  clone() {
    return new Quaternion(this.elements.concat());
  }
  get matrix4() {
    return new Matrix4(mat4FromQuaternion(this.elements));
  }
  get inversed() {
    return new Quaternion(quatInverse(this.elements));
  }
  get length() {
    return vecLength(this.elements);
  }
  get lengthSq() {
    return vecLengthSq(this.elements);
  }
  get normalized() {
    return new Quaternion(quatNormalize(this.elements));
  }
  multiply(...quaternions) {
    return Quaternion.multiply(this, ...quaternions);
  }
  slerp(b, t) {
    return Quaternion.slerp(this, b, t);
  }
  static get identity() {
    return new Quaternion(rawIdentityQuaternion);
  }
  static multiply(...quaternions) {
    if (quaternions.length === 0) {
      return Quaternion.identity;
    } else {
      return new Quaternion(quatMultiply(...quaternions.map((q) => q.elements)));
    }
  }
  static slerp(a, b, t) {
    return new Quaternion(quatSlerp(a.elements, b.elements, t));
  }
  static rotationX(theta) {
    return new Quaternion(quatRotationX(theta));
  }
  static rotationY(theta) {
    return new Quaternion(quatRotationY(theta));
  }
  static rotationZ(theta) {
    return new Quaternion(quatRotationZ(theta));
  }
  static lookRotation(look, up) {
    return new Quaternion(quatLookRotation(look.elements, up.elements));
  }
  static fromAxisAngle(axis, angle) {
    return new Quaternion(quatFromAxisAngle(axis.elements, angle));
  }
  static fromMatrix4(matrix) {
    return new Quaternion(quatFromMatrix4(matrix.elements));
  }
};

// src/math/mod.ts
function _0b5vr_experimental_esm_mod(value, divisor) {
  return value - Math.floor(value / divisor) * divisor;
}

// src/math/sanitizeAngle.ts
function sanitizeAngle(angle) {
  return _0b5vr_experimental_esm_mod(angle + Math.PI, 2 * Math.PI) - Math.PI;
}

// src/math/euler/eulerFromMat3.ts
function eulerFromMat3(m, order) {
  const [i, j, k, sign] = !order || order === "XYZ" ? [0, 1, 2, 1] : order === "XZY" ? [0, 2, 1, -1] : order === "YXZ" ? [1, 0, 2, -1] : order === "YZX" ? [1, 2, 0, 1] : order === "ZXY" ? [2, 0, 1, 1] : [2, 1, 0, -1];
  const result = [0, 0, 0];
  const c = m[k + i * 3];
  result[j] = -sign * Math.asin(clamp(c, -1, 1));
  if (Math.abs(c) < 0.999999) {
    result[i] = sign * Math.atan2(m[k + j * 3], m[k * 4]);
    result[k] = sign * Math.atan2(m[j + i * 3], m[i * 4]);
  } else {
    result[i] = sign * Math.atan2(-m[j + k * 3], m[j * 4]);
  }
  if (vecManhattanLength(result) > 1.5 * Math.PI) {
    result[i] = sanitizeAngle(result[i] + Math.PI);
    result[j] = sanitizeAngle(Math.PI - result[j]);
    result[k] = sanitizeAngle(result[k] + Math.PI);
  }
  return result;
}

// src/math/euler/eulerFromMat4.ts
function eulerFromMat4(m, order) {
  return eulerFromMat3(mat3FromMat4(m), order);
}

// src/math/euler/eulerFromQuaternion.ts
function eulerFromQuaternion(m, order) {
  return eulerFromMat3(mat3FromQuaternion(m), order);
}

// src/math/quat/quatFromEuler.ts
function quatFromEuler(euler, order) {
  const [i, j, k, sign] = !order || order === "XYZ" ? [0, 1, 2, 1] : order === "XZY" ? [0, 2, 1, -1] : order === "YXZ" ? [1, 0, 2, -1] : order === "YZX" ? [1, 2, 0, 1] : order === "ZXY" ? [2, 0, 1, 1] : [2, 1, 0, -1];
  const ti = 0.5 * euler[i];
  const tj = 0.5 * sign * euler[j];
  const tk = 0.5 * euler[k];
  const ci = Math.cos(ti);
  const cj = Math.cos(tj);
  const ck = Math.cos(tk);
  const si = Math.sin(ti);
  const sj = Math.sin(tj);
  const sk = Math.sin(tk);
  const result = [
    0,
    0,
    0,
    ck * cj * ci + sk * sj * si
  ];
  result[i] = ck * cj * si - sk * sj * ci;
  result[j] = sign * (ck * sj * ci + sk * cj * si);
  result[k] = sk * cj * ci - ck * sj * si;
  return result;
}

// src/math/euler/Euler.ts
var Euler = class {
  constructor(elements = [0, 0, 0], order = "XYZ") {
    this.elements = elements;
    this.order = order;
  }
  get x() {
    return this.elements[0];
  }
  get y() {
    return this.elements[1];
  }
  get z() {
    return this.elements[2];
  }
  toString() {
    return `Euler( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)} (${this.order}) )`;
  }
  clone() {
    return new Euler(this.elements.concat(), this.order);
  }
  get quaternion() {
    return new Quaternion(quatFromEuler(this.elements, this.order));
  }
  get matrix4() {
    return this.quaternion.matrix4;
  }
  static fromMatrix3(matrix, order) {
    return new Euler(eulerFromMat3(matrix.elements, order), order);
  }
  static fromMatrix4(matrix, order) {
    return new Euler(eulerFromMat4(matrix.elements, order), order);
  }
  static fromQuaternion(quaternion, order) {
    return new Euler(eulerFromQuaternion(quaternion.elements, order), order);
  }
};

// src/math/ray3/ray3DistanceToSphere.ts
function ray3DistanceToSphere([ro, rd], sphere) {
  const v = vecSub(ro, sphere[0]);
  const b = vecDot(v, rd);
  const c = vecDot(v, v) - sphere[1];
  const d = b * b - c;
  if (d < 0) {
    return null;
  }
  const sqrtD = Math.sqrt(d);
  return [-b - sqrtD, -b + sqrtD];
}

// src/math/line3/line3Delta.ts
function line3Delta(line) {
  return vecSub(line[1], line[0]);
}

// src/math/ray3/ray3FromLine3.ts
function ray3FromLine3(line) {
  return [
    line[0],
    vecNormalize(line3Delta(line))
  ];
}

// src/math/ray3/Ray3.ts
var Ray3 = class {
  constructor(start = Vector3.zero, end = Vector3.pz) {
    this.origin = start;
    this.direction = end;
  }
  get raw() {
    return [this.origin.elements, this.direction.elements];
  }
  distanceToSphere(sphere) {
    return ray3DistanceToSphere(this.raw, sphere.raw);
  }
  static fromRaw(ray) {
    return new Ray3(new Vector3(ray[0]), new Vector3(ray[1]));
  }
  static fromLine3(line) {
    return Ray3.fromRaw(ray3FromLine3(line.raw));
  }
};

// src/math/line3/line3ApplyMatrix4.ts
function line3ApplyMatrix4([start, end], matrix) {
  return [
    vec3ApplyMatrix4(start, matrix),
    vec3ApplyMatrix4(end, matrix)
  ];
}

// src/math/line3/line3At.ts
function line3At(line, t) {
  return vecAdd(vecScale(line[0], 1 - t), vecScale(line[1], t));
}

// src/math/line3/line3ClosestPointToPoint.ts
function line3ClosestPointToPoint(line, point, segment) {
  const ap = vecSub(point, line[0]);
  const ab = vecSub(line[1], line[0]);
  let t = vecDot(ap, ab) / vecDot(ab, ab);
  segment && (t = saturate(t));
  return line3At(line, t);
}

// src/math/line3/line3DistanceToPoint.ts
function line3DistanceToPoint(line, point, segment) {
  return vecLength(vecSub(line3ClosestPointToPoint(line, point, segment), point));
}

// src/math/line3/Line3.ts
var Line3 = class {
  constructor(start = Vector3.zero, end = Vector3.zero) {
    this.start = start;
    this.end = end;
  }
  get raw() {
    return [this.start.elements, this.end.elements];
  }
  get ray() {
    return Ray3.fromLine3(this);
  }
  delta() {
    return new Vector3(line3Delta(this.raw));
  }
  length() {
    return this.delta.length;
  }
  at(t) {
    return new Vector3(line3At(this.raw, t));
  }
  applyMatrix4(matrix) {
    return Line3.fromRaw(line3ApplyMatrix4(this.raw, matrix.elements));
  }
  closestPointToPoint(point, segment) {
    return new Vector3(line3ClosestPointToPoint(this.raw, point.elements, segment));
  }
  distanceToPoint(point, segment) {
    return line3DistanceToPoint(this.raw, point.elements, segment);
  }
  static fromRaw(line) {
    return new Line3(new Vector3(line[0]), new Vector3(line[1]));
  }
};

// src/math/mat2/mat2Determinant.ts
function mat2Determinant(m) {
  return m[0] * m[3] - m[2] * m[1];
}

// src/math/mat2/mat2Inverse.ts
function mat2Inverse(m) {
  const n11 = m[0], n21 = m[1], n12 = m[2], n22 = m[3], det = n11 * n22 - n12 * n21;
  if (det === 0) {
    return vecScale(m, 0);
  }
  return vecScale([
    n22,
    -n21,
    -n12,
    n11
  ], 1 / det);
}

// src/math/mat2/mat2Multiply.ts
function mat2Multiply(...mats) {
  if (mats.length < 2) {
    return mats[0];
  }
  const a = mats.shift();
  const b = mat2Multiply(...mats);
  const a00 = a[0], a01 = a[1], a10 = a[2], a11 = a[3], b00 = b[0], b01 = b[1], b10 = b[2], b11 = b[3];
  return [
    a00 * b00 + a10 * b01,
    a01 * b00 + a11 * b01,
    a00 * b10 + a10 * b11,
    a01 * b10 + a11 * b11
  ];
}

// src/math/mat2/mat2Transpose.ts
function mat2Transpose(source) {
  return [
    source[0],
    source[2],
    source[1],
    source[3]
  ];
}

// src/math/mat2/Matrix2.ts
var rawIdentityMatrix2 = (/* unused pure expression or super */ null && ([
  1,
  0,
  0,
  1
]));
var Matrix2 = class {
  constructor(v = rawIdentityMatrix2) {
    this.elements = v;
  }
  get transpose() {
    return new Matrix2(mat2Transpose(this.elements));
  }
  get determinant() {
    return mat2Determinant(this.elements);
  }
  get inverse() {
    return new Matrix2(mat2Inverse(this.elements));
  }
  toString() {
    const m = this.elements.map((v) => v.toFixed(3));
    return `Matrix2( ${m[0]}, ${m[2]}; ${m[1]}, ${m[3]} )`;
  }
  clone() {
    return new Matrix2(this.elements.concat());
  }
  multiply(...matrices) {
    return Matrix2.multiply(this, ...matrices);
  }
  scaleScalar(scalar) {
    return new Matrix2(vecScale(this.elements, scalar));
  }
  static get identity() {
    return new Matrix2(rawIdentityMatrix2);
  }
  static multiply(...matrices) {
    if (matrices.length === 0) {
      return Matrix2.identity;
    } else {
      return new Matrix2(mat2Multiply(...matrices.map((m) => m.elements)));
    }
  }
};

// src/math/vec3/vec3ApplyMatrix3.ts
function vec3ApplyMatrix3(v, m) {
  return [
    m[0] * v[0] + m[3] * v[1] + m[6] * v[2],
    m[1] * v[0] + m[4] * v[1] + m[7] * v[2],
    m[2] * v[0] + m[5] * v[1] + m[8] * v[2]
  ];
}

// src/math/plane3/plane3ApplyMatrix4.ts
function plane3ApplyMatrix4([normal, distance], matrix, normalMatrix) {
  const newNormal = vecNormalize(vec3ApplyMatrix3(normal, normalMatrix));
  const coplanar = vecScale(normal, -distance);
  const refPoint = vec3ApplyMatrix4(coplanar, matrix);
  const newDistance = -vecDot(refPoint, normal);
  return [newNormal, newDistance];
}

// src/math/plane3/plane3DistanceToPoint.ts
function plane3DistanceToPoint([normal, distance], point) {
  return vecDot(normal, point) + distance;
}

// src/math/plane3/plane3Normalize.ts
function plane3Normalize([normal, distance]) {
  const invL = 1 / vecLength(normal);
  return [vecScale(normal, invL), distance * invL];
}

// src/math/plane3/Plane3.ts
var Plane3 = class {
  get raw() {
    return [this.normal.elements, this.distance];
  }
  get normalized() {
    return Plane3.fromRaw(plane3Normalize(this.raw));
  }
  constructor(normal = Vector3.pz, distance = 0) {
    this.normal = normal;
    this.distance = distance;
  }
  applyMatrix4(matrix, normalMatrix) {
    var _a;
    return Plane3.fromRaw(plane3ApplyMatrix4(this.raw, matrix.elements, (_a = normalMatrix == null ? void 0 : normalMatrix.elements) != null ? _a : matrix.normalMatrix.elements));
  }
  distanceToPoint(point) {
    return plane3DistanceToPoint(this.raw, point.elements);
  }
  static fromRaw(plane) {
    return new Plane3(new Vector3(plane[0]), plane[1]);
  }
};

// src/math/plane3/planes3ContainPoint.ts
function planes3ContainPoint(planes, point) {
  return planes.every((plane) => plane3DistanceToPoint(plane, point) >= 0);
}

// src/math/plane3/planes3FromBox3.ts
function planes3FromBox3(box) {
  return [
    [[1, 0, 0], -box[0][0]],
    [[-1, 0, 0], box[1][0]],
    [[0, 1, 0], -box[0][1]],
    [[0, -1, 0], box[1][1]],
    [[0, 0, 1], -box[0][2]],
    [[0, 0, -1], box[1][2]]
  ];
}

// src/math/plane3/planes3FromProjectionMatrix.ts
function planes3FromProjectionMatrix(m) {
  const m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
  return [
    plane3Normalize([[m41 - m11, m42 - m12, m43 - m13], m44 - m14]),
    plane3Normalize([[m41 + m11, m42 + m12, m43 + m13], m44 + m14]),
    plane3Normalize([[m41 - m21, m42 - m22, m43 - m23], m44 - m24]),
    plane3Normalize([[m41 + m21, m42 + m22, m43 + m23], m44 + m24]),
    plane3Normalize([[m41 - m31, m42 - m32, m43 - m33], m44 - m34]),
    plane3Normalize([[m41 + m31, m42 + m32, m43 + m33], m44 + m34])
  ];
}

// src/math/plane3/planes3IntersectBox3.ts
function planes3IntersectBox3(planes, box) {
  return planes.every((plane) => {
    const v = plane[0].map((nc, i) => box[nc > 0 ? 1 : 0][i]);
    return plane3DistanceToPoint(plane, v) >= 0;
  });
}

// src/math/plane3/planes3IntersectSphere3.ts
function planes3IntersectSphere3(planes, sphere) {
  return planes.every((plane) => plane3DistanceToPoint(plane, sphere[0]) >= -sphere[1]);
}

// src/math/plane3/Planes3.ts
var Planes3 = class {
  get raw() {
    return this.planes.map((plane) => plane.raw);
  }
  constructor(planes) {
    this.planes = planes;
  }
  containPoint(point) {
    return planes3ContainPoint(this.raw, point.elements);
  }
  intersectBox3(box) {
    return planes3IntersectBox3(this.raw, box.raw);
  }
  intersectSphere3(sphere) {
    return planes3IntersectSphere3(this.raw, sphere.raw);
  }
  static fromRaw(planes) {
    return new Planes3(planes.map((plane) => Plane3.fromRaw(plane)));
  }
  static fromBox3(box) {
    return Planes3.fromRaw(planes3FromBox3(box.raw));
  }
  static fromProjectionMatrix(matrix) {
    return Planes3.fromRaw(planes3FromProjectionMatrix(matrix.elements));
  }
};

// src/math/sphere3/sphere3ContainsPoint.ts
function sphere3ContainsPoint(sphere, point) {
  return vecLengthSq(vecSub(sphere[0], point)) <= sphere[1] * sphere[1];
}

// src/math/sphere3/Sphere3.ts
var Sphere3 = class {
  constructor(origin = Vector3.zero, radius = 0) {
    this.origin = origin;
    this.radius = radius;
  }
  get raw() {
    return [this.origin.elements, this.radius];
  }
  containsPoint(point) {
    return sphere3ContainsPoint(this.raw, point.elements);
  }
  static fromRaw(sphere) {
    return new Sphere3(new Vector3(sphere[0]), sphere[1]);
  }
};

// src/math/vec4/vec4ApplyMatrix3.ts
function vec4ApplyMatrix3(v, m) {
  const v3 = [v[0], v[1], v[2]];
  const xyz = vec3ApplyMatrix3(v3, m);
  const w = v[3];
  return [xyz[0], xyz[1], xyz[2], w];
}

// src/math/vec4/Vector4.ts
var Vector4 = class extends (/* unused pure expression or super */ null && (Vector)) {
  constructor(v = [0, 0, 0, 0]) {
    super();
    this.elements = v;
  }
  get x() {
    return this.elements[0];
  }
  set x(x) {
    this.elements[0] = x;
  }
  get y() {
    return this.elements[1];
  }
  set y(y) {
    this.elements[1] = y;
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
  }
  get w() {
    return this.elements[3];
  }
  set w(z) {
    this.elements[3] = z;
  }
  toString() {
    return `Vector4( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)}, ${this.w.toFixed(3)} )`;
  }
  applyMatrix3(matrix) {
    return new Vector4(vec4ApplyMatrix3(this.elements, matrix.elements));
  }
  applyMatrix4(matrix) {
    return new Vector4(vec4ApplyMatrix4(this.elements, matrix.elements));
  }
  __new(v) {
    return new Vector4(v);
  }
  static get zero() {
    return new Vector4([0, 0, 0, 0]);
  }
  static get one() {
    return new Vector4([1, 1, 1, 1]);
  }
};

// src/midi/midiParse.ts
function readU8(array, headBox) {
  return array[headBox[0]++];
}
function readU16(array, headBox) {
  return readU8(array, headBox) * 256 + readU8(array, headBox);
}
function readU32(array, headBox) {
  return readU16(array, headBox) * 65536 + readU16(array, headBox);
}
function readUVar(array, headBox) {
  let v = 0;
  for (; ; ) {
    const vv = readU8(array, headBox);
    v = v * 128 + (vv & 127);
    if (vv < 128) {
      return v;
    }
  }
}
function parseHeader(array, headBox) {
  headBox[0] += 8;
  return [
    readU16(array, headBox),
    readU16(array, headBox),
    readU16(array, headBox)
  ];
}
function parseTrack(array, headBox) {
  headBox[0] += 4;
  const endOfTrack = headBox[0] + readU32(array, headBox) + 4;
  const track = [];
  let type = 0;
  while (headBox[0] < endOfTrack) {
    const delta = readUVar(array, headBox);
    const status = readU8(array, headBox);
    type = status < 128 ? type : status;
    const data0 = status < 128 ? status : readU8(array, headBox);
    if (type < 192) {
      track.push([
        delta,
        type,
        data0,
        readU8(array, headBox)
      ]);
    } else if (type === 255) {
      const eventLength = readU8(array, headBox);
      track.push([
        delta,
        type,
        data0,
        arraySerial(eventLength).map(() => readU8(array, headBox))
      ]);
      if (data0 === 47) {
        break;
      }
    } else {
      throw new Error(`${type}`);
    }
  }
  return track;
}
function midiParse(buffer) {
  const array = new Uint8Array(buffer);
  const headBox = [0];
  const header = parseHeader(array, headBox);
  const tracks = [];
  while (headBox[0] < array.length) {
    tracks.push(parseTrack(array, headBox));
  }
  return [header, tracks];
}

// src/poker/pokerRanksByStrength.ts
var pokerRanksByStrength = (/* unused pure expression or super */ null && ([
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "T",
  "J",
  "Q",
  "K",
  "A"
]));

// src/poker/pokerSuitsByIndex.ts
var pokerSuitsByIndex = (/* unused pure expression or super */ null && ([
  "c",
  "d",
  "h",
  "s"
]));

// src/poker/createPokerDeck.ts
function createPokerDeck() {
  const array = [];
  pokerSuitsByIndex.map((suit) => pokerRanksByStrength.map((rank) => array.push(rank + suit)));
  return array;
}

// src/poker/pokerHandStrengthMap.ts
var pokerHandStrengthMap = {
  "HighCard": 0,
  "OnePair": 1,
  "TwoPair": 2,
  "ThreeOfAKind": 3,
  "Straight": 4,
  "Flush": 5,
  "FullHouse": 6,
  "FourOfAKind": 7,
  "StraightFlush": 8
};

// src/poker/pokerRankStrengthMap.ts
var pokerRankStrengthMap = {
  "2": 0,
  "3": 1,
  "4": 2,
  "5": 3,
  "6": 4,
  "7": 5,
  "8": 6,
  "9": 7,
  "T": 8,
  "J": 9,
  "Q": 10,
  "K": 11,
  "A": 12
};

// src/poker/pokerSuitIndexMap.ts
var pokerSuitIndexMap = {
  "c": 0,
  "d": 1,
  "h": 2,
  "s": 3
};

// src/poker/sortPokerCardsByRank.ts
function sortPokerCardsByRank(cards) {
  return cards.sort((a, b) => pokerSuitIndexMap[a[1]] - pokerSuitIndexMap[b[1]]).sort((a, b) => pokerRankStrengthMap[a[0]] - pokerRankStrengthMap[b[0]]);
}

// src/poker/evaluatePokerHand.ts
function evaluatePokerHand(cards) {
  const cards_ = cards.concat();
  const cardsByRank = new MapOfSet();
  const cardsBySuit = new MapOfSet();
  cards_.map((card) => {
    const rank = card[0];
    const suit = card[1];
    cardsByRank.add(rank, card);
    cardsBySuit.add(suit, card);
  });
  const fours = [];
  const threes = [];
  const twos = [];
  pokerRanksByStrength.map((rank) => {
    const cards2 = cardsByRank.get(rank);
    if (cards2.size > 3) {
      fours.push(rank);
    } else if (cards2.size > 2) {
      threes.push(rank);
    } else if (cards2.size > 1) {
      twos.push(rank);
    }
  });
  let straightCards;
  {
    let current = [];
    const a = Array.from(cardsByRank.get("A"))[0];
    if (a) {
      current.push(a);
    }
    pokerRanksByStrength.map((rank) => {
      const card = Array.from(cardsByRank.get(rank))[0];
      if (card) {
        current.push(card);
        if (current.length > 4) {
          straightCards = current;
        }
      } else {
        current = [];
      }
    });
  }
  if (straightCards) {
    for (const [suit, cardsSet] of cardsBySuit.map) {
      if (cardsSet.size > 0) {
        let straightFlushCards;
        let current = [];
        const target = "A" + suit;
        const a = cardsSet.has(target);
        if (a) {
          current.push(target);
        }
        pokerRanksByStrength.map((rank) => {
          const target2 = rank + suit;
          if (cardsSet.has(target2)) {
            current.push(target2);
            if (current.length > 4) {
              straightFlushCards = current;
            }
          } else {
            current = [];
          }
        });
        if (straightFlushCards) {
          straightFlushCards.splice(0, straightFlushCards.length - 5);
          const hand = "StraightFlush";
          const strength = [
            pokerHandStrengthMap[hand],
            pokerRankStrengthMap[straightFlushCards[4][0]]
          ];
          return {
            hand,
            cards: straightFlushCards,
            strength
          };
        }
      }
    }
  }
  if (fours.length > 0) {
    fours.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    fours.splice(0, fours.length - 1);
    const sameCards = Array.from(cardsByRank.get(fours[0]));
    sameCards.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 1);
    const hand = "FourOfAKind";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[fours[0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...sameCards);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  if (threes.length > 0 && threes.length + twos.length > 1) {
    threes.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    twos.push(...threes.splice(0, threes.length - 1));
    twos.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    twos.splice(0, twos.length - 1);
    const sameCards = Array.from(cardsByRank.get(threes[0]));
    sameCards.push(...Array.from(cardsByRank.get(twos[0])));
    sortPokerCardsByRank(sameCards).splice(0, sameCards.length - 5);
    const hand = "FullHouse";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[threes[0]],
      pokerRankStrengthMap[twos[0]]
    ];
    return {
      hand,
      cards: sameCards,
      strength
    };
  }
  for (const [_suit, cardsSet] of cardsBySuit.map) {
    if (cardsSet.size > 4) {
      const cards2 = sortPokerCardsByRank(Array.from(cardsSet));
      cards2.splice(0, cards2.length - 5);
      const hand = "Flush";
      const strength = [
        pokerHandStrengthMap[hand],
        ...cards2.concat().reverse().map((card) => pokerRankStrengthMap[card[0]])
      ];
      return {
        hand,
        cards: cards2,
        strength
      };
    }
  }
  if (straightCards) {
    straightCards.splice(0, straightCards.length - 5);
    const hand = "Straight";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[straightCards[4][0]]
    ];
    return {
      hand,
      cards: straightCards,
      strength
    };
  }
  if (threes.length > 0) {
    threes.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    threes.splice(0, threes.length - 1);
    const sameCards = Array.from(cardsByRank.get(threes[0]));
    sameCards.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 2);
    const hand = "ThreeOfAKind";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[threes[0]],
      pokerRankStrengthMap[cards_[1][0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...sameCards);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  if (twos.length > 1) {
    twos.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    twos.splice(0, twos.length - 2);
    const pairs = Array.from(cardsByRank.get(twos[0]));
    pairs.push(...Array.from(cardsByRank.get(twos[1])));
    pairs.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 1);
    const hand = "TwoPair";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[twos[1]],
      pokerRankStrengthMap[twos[0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...pairs);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  if (twos.length > 0) {
    const pair = Array.from(cardsByRank.get(twos[0]));
    pair.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 3);
    const hand = "OnePair";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[twos[0]],
      pokerRankStrengthMap[cards_[2][0]],
      pokerRankStrengthMap[cards_[1][0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...pair);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  {
    const hand = "HighCard";
    sortPokerCardsByRank(cards_);
    cards_.splice(0, cards_.length - 5);
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[cards_[4][0]],
      pokerRankStrengthMap[cards_[3][0]],
      pokerRankStrengthMap[cards_[2][0]],
      pokerRankStrengthMap[cards_[1][0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    return {
      hand,
      cards: cards_,
      strength
    };
  }
}

// src/poker/pokerHandsByStrength.ts
var pokerHandsByStrength = (/* unused pure expression or super */ null && ([
  "HighCard",
  "OnePair",
  "TwoPair",
  "ThreeOfAKind",
  "Straight",
  "Flush",
  "FullHouse",
  "FourOfAKind",
  "StraightFlush"
]));

// src/retry/asyncRetry.ts
function asyncRetry(func, n) {
  return __async(this, null, function* () {
    return yield func().catch((error) => {
      if (n <= 1) {
        throw error;
      }
      return asyncRetry(func, n - 1);
    });
  });
}

// src/retry/retry.ts
function retry(func, n) {
  try {
    return func();
  } catch (error) {
    if (n <= 1) {
      throw error;
    }
    return retry(func, n - 1);
  }
}

// src/stniccc/parseSTNICCC.ts
function parseSTNICCC(buffer) {
  const frames = [];
  const array = new Uint8Array(buffer);
  const palette = new Uint16Array(16);
  let head = 0;
  let shouldSkip = false;
  let shouldEnd = false;
  for (; ; ) {
    const flags = array[head++];
    const needsClear = (flags & 1) === 1;
    const hasPalette = (flags >> 1 & 1) === 1;
    const indexedMode = (flags >> 2 & 1) === 1;
    if (hasPalette) {
      const bitmask = array[head++] << 8 | array[head++];
      for (let i = 0; i < 16; i++) {
        if (bitmask >> 15 - i & 1) {
          palette[i] = array[head++] << 8 | array[head++];
        }
      }
    }
    if (indexedMode) {
      const nVertices = array[head++];
      const vertices = array.subarray(head, head + 2 * nVertices);
      head += 2 * nVertices;
      const polygons = [];
      for (; ; ) {
        const descriptor = array[head++];
        if (descriptor === 255) {
          break;
        } else if (descriptor === 254) {
          shouldSkip = true;
          break;
        } else if (descriptor === 253) {
          shouldEnd = true;
          break;
        }
        const colorIndex = descriptor >> 4 & 15;
        const nIndices = descriptor & 15;
        const indices = array.subarray(head, head + nIndices);
        head += nIndices;
        polygons.push({
          colorIndex,
          indices: Array.from(indices)
        });
      }
      frames.push({
        needsClear,
        indexedMode,
        palette: Array.from(palette),
        vertices: Array.from(vertices),
        polygons
      });
    } else {
      const polygons = [];
      for (; ; ) {
        const descriptor = array[head++];
        if (descriptor === 255) {
          break;
        } else if (descriptor === 254) {
          shouldSkip = true;
          break;
        } else if (descriptor === 253) {
          shouldEnd = true;
          break;
        }
        const colorIndex = descriptor >> 4 & 15;
        const nVertices = descriptor & 15;
        const vertices = array.subarray(head, head + 2 * nVertices);
        head += 2 * nVertices;
        polygons.push({
          colorIndex,
          vertices: Array.from(vertices)
        });
      }
      frames.push({
        needsClear,
        indexedMode,
        palette: Array.from(palette),
        polygons
      });
    }
    if (shouldSkip) {
      head = (Math.floor(head / 65536) + 1) * 65536;
      shouldSkip = false;
    }
    if (shouldEnd) {
      break;
    }
  }
  return frames;
}

// src/stniccc/stnicccToSVG.ts
function stnicccToSVG(frames, options = {}) {
  var _a;
  const delta = 1 / ((_a = options == null ? void 0 : options.fps) != null ? _a : 30);
  let svg = '<svg width="256" height="200" viewBox="0 0 256 200" xmlns="http://www.w3.org/2000/svg">';
  let style = `g{visibility:hidden;animation-duration:${(delta * frames.length).toFixed(3)}s;animation-iteration-count:infinite;animation-name:frame}@keyframes frame{0%{visibility:visible}${200 / frames.length}%{visibility:hidden}}`;
  frames.map((frame, iFrame) => {
    const { indexedMode, palette, polygons } = frame;
    style += `#f${iFrame}{animation-delay:${(delta * iFrame).toFixed(3)}s}`;
    const paletteInHex = palette.map((stColor) => {
      const color = colorFromAtariST(stColor);
      return colorToHex(color);
    });
    let childrenStr = '<rect width="256" height="200" fill="#000" />';
    let currentColorIndex = -1;
    let d = "";
    if (indexedMode) {
      const { vertices } = frame;
      polygons.map(({ colorIndex, indices }) => {
        if (currentColorIndex !== colorIndex) {
          if (currentColorIndex !== -1) {
            const colorHex2 = paletteInHex[currentColorIndex];
            childrenStr += `<path d="${d}" fill="${colorHex2}" />`;
          }
          currentColorIndex = colorIndex;
          d = "";
        }
        for (let i = 0; i < indices.length; i++) {
          const index = indices[i];
          const x = vertices[2 * index];
          const y = vertices[2 * index + 1];
          d += i === 0 ? `M${x},${y}` : `L${x},${y}`;
        }
      });
    } else {
      polygons.map(({ colorIndex, vertices }) => {
        if (currentColorIndex !== colorIndex) {
          if (currentColorIndex !== -1) {
            const colorHex2 = paletteInHex[currentColorIndex];
            childrenStr += `<path d="${d}" fill="${colorHex2}" />`;
          }
          currentColorIndex = colorIndex;
          d = "";
        }
        for (let i = 0; i < vertices.length; i += 2) {
          const x = vertices[i];
          const y = vertices[i + 1];
          d += i === 0 ? `M${x},${y}` : `L${x},${y}`;
        }
      });
    }
    const colorHex = paletteInHex[currentColorIndex];
    childrenStr += `<path d="${d}" fill="${colorHex}" />`;
    svg += `<g id="f${iFrame}">${childrenStr}</g>`;
  });
  svg += `<style>${style}</style></svg>`;
  return svg;
}

// src/SmoothDamp/SmoothDamp.ts
var SmoothDamp = class {
  constructor() {
    this.smoothTime = 1;
    this.velocity = 0;
    this.value = 0;
    this.target = 0;
  }
  update(deltaTime) {
    const omega = 2 / this.smoothTime;
    const x = omega * deltaTime;
    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
    const delta = this.value - this.target;
    const temp = (this.velocity + omega * delta) * deltaTime;
    this.velocity = (this.velocity - omega * temp) * exp;
    this.value = this.target + (delta + temp) * exp;
    return this.value;
  }
};

// src/Swap/Swap.ts
var Swap = class {
  constructor(a, b) {
    this.i = a;
    this.o = b;
  }
  swap() {
    const i = this.i;
    this.i = this.o;
    this.o = i;
  }
};

// src/TapTempo/TapTempo.ts
var TapTempo = class {
  constructor() {
    this.__bpm = 0;
    this.__lastTap = 0;
    this.__lastBeat = 0;
    this.__lastTime = 0;
    this.__calc = new HistoryMeanCalculator(16);
  }
  get beatDuration() {
    return 60 / this.__bpm;
  }
  get bpm() {
    return this.__bpm;
  }
  set bpm(bpm) {
    this.__lastBeat = this.beat;
    this.__lastTime = performance.now();
    this.__bpm = bpm;
  }
  get beat() {
    return this.__lastBeat + (performance.now() - this.__lastTime) * 1e-3 / this.beatDuration;
  }
  reset() {
    this.__calc.reset();
  }
  nudge(amount) {
    this.__lastBeat = this.beat + amount;
    this.__lastTime = performance.now();
  }
  tap() {
    const now = performance.now();
    const delta = (now - this.__lastTap) * 1e-3;
    if (2 < delta) {
      this.reset();
    } else {
      this.__calc.push(delta);
      this.__bpm = 60 / this.__calc.mean;
    }
    this.__lastTap = now;
    this.__lastTime = now;
    this.__lastBeat = 0;
  }
};

// src/tinyseq/createTinyseqPolyReader.ts
function createTinyseqPolyReader(buffer, options = {}) {
  var _a, _b, _c, _d;
  const poly = (_a = options.poly) != null ? _a : 8;
  const blockSize = (_b = options.blockSize) != null ? _b : 128;
  const sampleRate = (_c = options.sampleRate) != null ? _c : 48e3;
  const stepsPerSecond = (_d = options.stepsPerSecond) != null ? _d : 1;
  let samples = 0;
  let pos = 0;
  let note;
  const notes = arraySerial(poly).fill(-1);
  const notesTime = arraySerial(poly).fill(-Infinity);
  const notesOffTime = arraySerial(poly).fill(-Infinity);
  let nextStep = 0;
  return () => {
    const ret = arraySerial(poly).map(() => new Float32Array(4 * blockSize));
    arraySerial(blockSize).map((iSample) => {
      const t = samples / sampleRate;
      const s = t * stepsPerSecond;
      if (s >= nextStep) {
        const eventNote = buffer[pos];
        const eventDeltaStep = buffer[pos + 1];
        note = (pos === 0 ? 60 : note) + eventNote & 127;
        let iPoly = notes.indexOf(note);
        let tEarliest = Infinity;
        if (iPoly === -1) {
          notesTime.map((tOn, jPoly) => {
            const tOff = notesOffTime[jPoly];
            if (tOn <= tOff) {
              if (tOff < tEarliest) {
                iPoly = jPoly;
                tEarliest = tOff;
              }
            }
          });
        }
        if (iPoly === -1) {
          notesTime.map((tOn, jPoly) => {
            if (tOn < tEarliest) {
              iPoly = jPoly;
              tEarliest = tOn;
            }
          });
        }
        notes[iPoly] = note;
        if (eventNote & 128) {
          if (notesOffTime[iPoly] < notesTime[iPoly]) {
            notesOffTime[iPoly] = t;
          }
        } else {
          if (notesOffTime[iPoly] >= notesTime[iPoly]) {
            notesTime[iPoly] = t;
          }
        }
        nextStep += eventDeltaStep;
        pos = (pos + 2) % buffer.length;
      }
      samples++;
      arraySerial(poly).map((iPoly) => {
        const noteTime = notesTime[iPoly];
        const noteOffTime = notesOffTime[iPoly];
        ret[iPoly][4 * iSample + 0] = t - noteTime;
        ret[iPoly][4 * iSample + 1] = noteOffTime < noteTime ? 0 : t - noteOffTime;
        ret[iPoly][4 * iSample + 2] = notes[iPoly];
        ret[iPoly][4 * iSample + 3] = 0;
      });
    });
    return ret;
  };
}

// src/tinyseq/createTinyseqReader.ts
function createTinyseqReader(buffer, options = {}) {
  var _a, _b, _c;
  const blockSize = (_a = options.blockSize) != null ? _a : 128;
  const sampleRate = (_b = options.sampleRate) != null ? _b : 48e3;
  const stepsPerSecond = (_c = options.stepsPerSecond) != null ? _c : 960;
  let samples = 0;
  let pos = 0;
  let note;
  let noteTime = -Infinity;
  let noteOffTime = -Infinity;
  let nextStep = 0;
  return () => {
    return new Float32Array(arraySerial(blockSize).map(() => {
      const t = samples / sampleRate;
      const s = t * stepsPerSecond;
      if (s >= nextStep) {
        const eventNote = buffer[pos];
        const eventDeltaStep = buffer[pos + 1];
        note = (pos === 0 ? 60 : note) + eventNote & 127;
        if (eventNote & 128) {
          if (noteOffTime < noteTime) {
            noteOffTime = t;
          }
        } else {
          if (noteOffTime >= noteTime) {
            noteTime = t;
          }
        }
        nextStep += eventDeltaStep;
        pos = (pos + 2) % buffer.length;
      }
      samples++;
      return [
        t - noteTime,
        noteOffTime < noteTime ? 0 : t - noteOffTime,
        note,
        0
      ];
    }).flat());
  };
}

// src/tinyseq/tinyseqFromMidiParseResult.ts
function tinyseqFromMidiParseResult(midi, { track, tickMultiplier } = {}) {
  const data = [];
  let lastNote = 60;
  let delta = 0;
  const trackEvents = midi[1][track != null ? track : 0];
  arraySerial(trackEvents.length + 1).map((i) => {
    var _a, _b, _c, _d, _e, _f;
    delta += ((_b = (_a = trackEvents[i]) == null ? void 0 : _a[0]) != null ? _b : 0) * (tickMultiplier != null ? tickMultiplier : 1);
    if (delta === 0 && i === 0) {
      return;
    }
    const evMsg = (_d = (_c = trackEvents[i - 1]) == null ? void 0 : _c[1]) != null ? _d : 128;
    const evNote = (_f = (_e = trackEvents[i - 1]) == null ? void 0 : _e[2]) != null ? _f : 60;
    if (evMsg >= 160) {
      return;
    }
    const noteDelta = evNote - lastNote + 128 & 127;
    lastNote = evNote;
    const onoff = evMsg < 144 ? 128 : 0;
    let deltaConsume = Math.floor(Math.min(delta, 240));
    data.push(noteDelta + onoff, deltaConsume);
    delta -= deltaConsume;
    while (delta >= 1) {
      deltaConsume = Math.floor(Math.min(delta, 240));
      data.push(onoff, deltaConsume);
      delta -= deltaConsume;
    }
  });
  return new Uint8Array(data);
}

// src/Xorshift/Xorshift.ts
var Xorshift = class {
  constructor(seed) {
    this.seed = seed || 1;
  }
  gen(seed) {
    if (seed) {
      this.seed = seed;
    }
    this.seed = this.seed ^ this.seed << 13;
    this.seed = this.seed ^ this.seed >>> 17;
    this.seed = this.seed ^ this.seed << 5;
    return this.seed / Math.pow(2, 32) + 0.5;
  }
  set(seed) {
    this.seed = seed || this.seed || 1;
  }
};

// src/yugop/getYugopText.ts
function getYugopText(text, phase, randomRatio = 0.5) {
  if (phase >= 1) {
    return text;
  }
  if (phase < 0) {
    return "";
  }
  const displayTween = linearstep(0, 1 - randomRatio, phase);
  const fixTween = linearstep(randomRatio, 1, phase);
  const displayLength = 1 + Math.floor(displayTween * (text.length - 1));
  const fixLength = phase < randomRatio ? 0 : 1 + Math.floor(fixTween * (text.length - 1));
  const randomLength = displayLength - fixLength;
  const randomStr = [...Array(randomLength)].map(() => String.fromCharCode(33 + Math.floor(93 * Math.random()))).join("");
  return text.substring(0, fixLength) + randomStr;
}

// src/BinaryHeap.ts
var BinaryHeap = class {
  static defaultComparator(a, b) {
    const aStr = `${a}`;
    const bStr = `${b}`;
    if (aStr > bStr) {
      return 1;
    } else if (aStr < bStr) {
      return -1;
    } else {
      return 0;
    }
  }
  get length() {
    return this.array.length;
  }
  get isEmpty() {
    return this.array.length === 0;
  }
  get root() {
    return this.array[0];
  }
  constructor(init, comparator) {
    this.array = [];
    this.elementIndexMap = /* @__PURE__ */ new Map();
    this.comparator = comparator != null ? comparator : BinaryHeap.defaultComparator;
    if (init != null) {
      for (const el of init) {
        this.push(el);
      }
    }
  }
  push(...elements) {
    elements.map((el) => {
      const i = this.length;
      this.array.push(el);
      this.elementIndexMap.set(el, i);
      this.__up(i, el);
    });
  }
  pop() {
    if (this.isEmpty) {
      return null;
    }
    const el = this.array[0];
    this.elementIndexMap.delete(el);
    if (this.length === 1) {
      this.array.splice(0);
    } else {
      const rep = this.array.pop();
      this.__down(0, rep);
    }
    return el;
  }
  delete(i) {
    this.elementIndexMap.delete(this.array[i]);
    const rep = this.array.pop();
    if (rep != null) {
      i = this.__up(i, rep);
      i = this.__down(i, rep);
    }
    return true;
  }
  replace(i, rep) {
    if (i != null) {
      this.elementIndexMap.delete(this.array[i]);
      i = this.__up(i, rep);
      i = this.__down(i, rep);
    }
    return i != null ? i : null;
  }
  __up(i, el) {
    let ic = i;
    while (ic !== 0) {
      const ip = ic - 1 >> 1;
      const p = this.array[ip];
      if (this.comparator(el, p) < 0) {
        this.array[ic] = p;
        this.elementIndexMap.set(p, ic);
        ic = ip;
      } else {
        break;
      }
    }
    this.array[ic] = el;
    this.elementIndexMap.set(el, ic);
    return ic;
  }
  __down(i, el) {
    let ip = i;
    while ((ip << 1) + 1 < this.length) {
      const ic1 = (ip << 1) + 1;
      const ic2 = (ip << 1) + 2;
      if (ic2 < this.length) {
        const c1 = this.array[ic1];
        const c2 = this.array[ic2];
        const pickLeft = this.comparator(c1, c2) < 0;
        const c = pickLeft ? c1 : c2;
        const ic = pickLeft ? ic1 : ic2;
        if (this.comparator(c, el) < 0) {
          this.array[ip] = c;
          this.elementIndexMap.set(c, ip);
          ip = ic;
        } else {
          break;
        }
      } else if (this.comparator(this.array[ic1], el) < 0) {
        this.array[ip] = this.array[ic1];
        this.elementIndexMap.set(this.array[ip], ip);
        ip = ic1;
      } else {
        break;
      }
    }
    this.array[ip] = el;
    this.elementIndexMap.set(el, ip);
    return ip;
  }
};

// src/notifyObservers.ts
function notifyObservers(observers, param) {
  for (const observer of observers) {
    observer(param);
  }
}

/*!
 * Turbo colormap
 *
 * Copyright 2019 Google LLC. (Apache-2.0)
 *
 * https://gist.github.com/mikhailov-work/0d177465a8151eb6ede1768d51d476c7
 */

;// CONCATENATED MODULE: ./src/wmath.ts

function fract(a) {
    return _0b5vr_experimental_esm_mod(a, 1);
}
const tau = Math.PI * 2.0;
const pi = Math.PI;
const halfPi = Math.PI / 2;
function max(a, b) {
    return Math.max(a, b);
}
function min(a, b) {
    return Math.min(a, b);
}
function mix(a, b, f) {
    return a * (1.0 - f) + b * f;
}
function log(a) {
    return Math.log(a);
}
function log2(a) {
    return Math.log2(a);
}
class Hash {
    seed = 0;
    constructor(seed = 1251254) {
        Hash.seed = seed;
    }
    static h11(p) {
        p = fract(p * 0.1031);
        p *= p + 33.33;
        p *= p + p;
        return fract(p);
    }
    h11(p) {
        return this.seeded(125124 + p * 1250);
    }
    seeded(a) {
        var t = (a += 0x6d2b79f5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
    valueNoise(a) {
        const fla = floor(a);
        const ceila = fla + 1;
        const rcurr = Hash.h11(fla);
        const rnext = Hash.h11(ceila);
        let fr = fract(a);
        fr = wmath_smoothstep(0, 1, fr);
        return wmath_lerp(rcurr, rnext, fr);
    }
    valueNoiseSmooth(a, smoothness) {
        const fla = floor(a);
        const ceila = fla + 1;
        const rcurr = this.h11(fla);
        const rnext = this.h11(ceila);
        let fr = fract(a);
        for (let i = 0; i < smoothness; i++) {
            if (floor(i) === floor(smoothness)) {
                fr = wmath_lerp(fr, wmath_smoothstep(0, 1, fr), smoothness - i);
                break;
            }
            else {
                fr = wmath_smoothstep(0, 1, fr);
            }
        }
        return wmath_lerp(rcurr, rnext, fr);
    }
}
const r2pi = 0.63661977236;
const nkingSin = (x) => {
    const xtau = x * tau;
    if (xtau - Math.floor(xtau) > pi) {
        const mod = (x - pi) * r2pi - 1;
        return mod * mod - 1;
    }
    else {
        const mod = x * r2pi - 1;
        return 1 - mod * mod;
    }
};
const smoothsin = (x) => {
    const b = x * x * (3.0 - 2.0 * x);
    const a = x * (3 - 1.0 * x);
    return a + (b - a) * b;
};
const oneOverHalfPi = 1 / (pi / 2);
const fastSin = (x) => {
    x *= oneOverHalfPi;
    const id = Math.floor(x);
    x = x % 1;
    let side = 1;
    if ((id - 2) % 4 < 2) {
        side = -1;
    }
    if (id % 2 === 1) {
        x = 1 - x;
    }
    let approx = smoothsin(x);
    approx *= side;
    return approx;
};
function quantize(a, b) {
    return Math.floor(a / b) * b;
}
function dmod(a, b, c = 2) {
    return max(mod(a, b) - b + 2, 0);
}
function abs(a) {
    return Math.abs(a);
}
function sign(a) {
    return a < 0 ? -1 : 1;
}
function tri(a) {
    const fr = a - Math.floor(a);
    return abs(fr - 0.5) * 2 - 1;
}
function sin(a) {
    return Math.sin(a);
}
function cos(a) {
    return Math.cos(a);
}
function floor(a) {
    return Math.floor(a);
}
function pow(a, b) {
    return Math.pow(a, b);
}
function sqrt(a) {
    return Math.sqrt(a);
}
function wmath_wrap(a, from, to) {
    const range = to - from;
    a -= from;
    a = mod(a, range);
    return from + a;
}
const wmath_lerp = (a, b, x) => a + (b - a) * x;
const wmath_clamp = (x, l, h) => Math.min(Math.max(x, l), h);
const wmath_saturate = (x) => Math.min(Math.max(x, 0.0), 1.0);
const wmath_linearstep = (a, b, x) => wmath_saturate((x - a) / (b - a));
const wmath_smoothstep = (a, b, x) => {
    const t = wmath_linearstep(a, b, x);
    return t * t * (3.0 - 2.0 * t);
};
function rand() {
    return Math.random();
}
class Ease {
    static linear(t) {
        ;
        (t) => t;
    }
    static easeInQuad(t) {
        return t * t;
    }
    static easeOutQuad(t) {
        return t * (2 - t);
    }
    static easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    static easeInCubic(t) {
        return t * t * t;
    }
    static easeOutCubic(t) {
        return --t * t * t + 1;
    }
    static easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    }
    static easeInQuart(t) {
        return t * t * t * t;
    }
    static easeOutQuart(t) {
        return 1 - --t * t * t * t;
    }
    static easeInOutQuart(t) {
        return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    }
    static easeInQuint(t) {
        return t * t * t * t * t;
    }
    static easeOutQuint(t) {
        return 1 + --t * t * t * t * t;
    }
    static easeInOutQuint(t) {
        return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    }
    static easeInElastic(t) {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
    }
    static easeOutElastic(t) {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }
}
class WMath {
    static macos(x) {
        return Math.acos(x);
    }
    static masin(x) {
        return Math.asin(x);
    }
    static matan(y, x) {
        return Math.atan2(y, x);
    }
    static mcos(x) {
        return Math.cos(x);
    }
    static msin(x) {
        return Math.sin(x);
    }
    static cos2(x) {
        return [Math.cos(x[0]), Math.cos(x[1])];
    }
    static cos3(x) {
        return [Math.cos(x[0]), Math.cos(x[1]), Math.cos(x[2])];
    }
    static sin2(x) {
        return [Math.sin(x[0]), Math.sin(x[1])];
    }
    static sin3(x) {
        return [Math.sin(x[0]), Math.sin(x[1]), Math.sin(x[2])];
    }
    static sin4(x) {
        return [Math.sin(x[0]), Math.sin(x[1]), Math.sin(x[2]), Math.sin(x[3])];
    }
    static SC(x) {
        return [Math.sin(x), Math.cos(x)];
    }
    static add2(a, b) {
        return [a[0] + b[0], a[1] + b[1]];
    }
    static add3(a, b) {
        return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
    }
    static add31(a, b) {
        return [a[0] + b, a[1] + b, a[2] + b];
    }
    static add4(a, b) {
        return [a[0] + b[0], a[1] + b[1], a[2] + b[2], a[3] + b[3]];
    }
    static sub3(a, b) {
        return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
    }
    static sub2(a, b) {
        return [a[0] - b[0], a[1] - b[1]];
    }
    static dot3(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    static abs3(a) {
        return [a[0] > 0 ? a[0] : -a[0], a[1] > 0 ? a[1] : -a[1], a[2] > 0 ? a[2] : -a[2]];
    }
    static scale2(a, b) {
        return [a[0] * b, a[1] * b];
    }
    static scale3(a, b) {
        return [a[0] * b, a[1] * b, a[2] * b];
    }
    static scale4(a, b) {
        return [a[0] * b, a[1] * b, a[2] * b, a[3] * b];
    }
    static mul3(a, b) {
        return [a[0] * b[0], a[1] * b[1], a[2] * b[2]];
    }
    static mul4(a, b) {
        return [a[0] * b[0], a[1] * b[1], a[2] * b[2], a[3] * b[3]];
    }
    static mymix(a, b, f) {
        return a * (1.0 - f) + b * f;
    }
    static mymix22(a, b, f) {
        return [a[0] * (1.0 - f[0]) + b[0] * f[0], a[1] * (1.0 - f[1]) + b[1] * f[1]];
    }
    static mix1(a, b, f) {
        return a * (1.0 - f) + b * f;
    }
    static mix3(a, b, f) {
        return add3(scale3(a, 1.0 - f), scale3(b, f));
    }
    static length2(a) {
        return Math.sqrt(a[0] * a[0] + a[1] * a[1]);
    }
    static length3(a) {
        return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
    }
    static length4(a) {
        return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3]);
    }
    static normalize3(a) {
        return scale3(a, 1.0 / length3(a));
    }
    static normalize4(a) {
        return scale4(a, 1.0 / length4(a));
    }
    static cross(a, b) {
        return [a[1] * b[2] - b[1] * a[2], a[2] * b[0] - b[2] * a[0], a[0] * b[1] - b[0] * a[1]];
    }
    G = 0.5 + Math.sqrt(5 / 4);
    static fract1(a) {
        return a - Math.floor(a);
    }
    static floor2(a) {
        return [Math.floor(a[0]), Math.floor(a[1])];
    }
    static fract2(a) {
        return [fract1(a[0]), fract1(a[1])];
    }
    static fract3(a) {
        return [fract1(a[0]), fract1(a[1]), fract1(a[2])];
    }
    static fract4(a) {
        return [fract1(a[0]), fract1(a[1]), fract1(a[2]), fract1(a[3])];
    }
    static clamp1(a, a1, a2) {
        return a < a1 ? a1 : a > a2 ? a2 : a;
    }
    static clamp31(a, a1, a2) {
        return [clamp1(a[0], a1, a2), clamp1(a[1], a1, a2), clamp1(a[2], a1, a2)];
    }
    static rotX(ph, v) {
        return [v[0], v[1] * mcos(ph) + v[2] * msin(ph), v[2] * mcos(ph) - v[1] * msin(ph)];
    }
    static rotY(ph, v) {
        return [v[0] * mcos(ph) + v[2] * msin(ph), v[1], v[2] * mcos(ph) - v[0] * msin(ph)];
    }
    static rotZ(ph, v) {
        return [v[0] * mcos(ph) + v[1] * msin(ph), v[1] * mcos(ph) - v[0] * msin(ph), v[2]];
    }
    static hsv2rgb(c) {
        var K = [1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0];
        var p = abs3(sub3(scale3(fract3(add3([c[0], c[0], c[0]], K)), 6.0), [3, 3, 3]));
        return scale3(mix3([1, 1, 1], clamp31(sub3(p, [1, 1, 1]), 0.0, 1.0), c[1]), c[2]);
    }
}

;// CONCATENATED MODULE: ./src/gl/Texture.ts



class Texture {
    tex;
    internal_format;
    format;
    type;
    res;
    is_float;
    mipmapped;
    mip_levels;
    constructor(res, internal_format = gl.RGBA, mipmapped = false, mip_levels = 0) {
        const eq_any = (a, b) => {
            let eq = false;
            b.forEach((b) => {
                if (b === a) {
                    eq = true;
                }
            });
            return eq;
        };
        this.res = [...res];
        this.internal_format = internal_format;
        this.mipmapped = mipmapped;
        this.mip_levels = mip_levels;
        this.is_float = eq_any(internal_format, [gl.RGBA32F, gl.RGBA16F, gl.RGB16F, gl.RGB32F]);
        let comp_cnt = 4;
        if (eq_any(internal_format, [gl.RGBA32F, gl.RGBA16F, gl.RGBA, gl.RGBA16I, gl.RGBA16UI, gl.RGBA32I, gl.RGBA8I, gl.RGBA8UI])) {
            comp_cnt = 4;
        }
        if (eq_any(internal_format, [gl.RGB32F, gl.RGB16F, gl.RGB, gl.RGB16I, gl.RGB16UI, gl.RGB32I, gl.RGB8I, gl.RGB8UI])) {
            comp_cnt = 3;
        }
        this.format = comp_cnt === 4 ? gl.RGBA : gl.RGB;
        this.type = this.is_float ? gl.FLOAT : gl.UNSIGNED_BYTE;
        if (eq_any(internal_format, [gl.RGBA8UI, gl.RGBA16UI, gl.RGBA32UI, gl.RGB8UI, gl.RGB16UI, gl.RGB32UI])) {
            this.type = gl.UNSIGNED_INT;
        }
        if (eq_any(internal_format, [gl.RGBA8I, gl.RGBA16I, gl.RGBA32I, gl.RGB8I, gl.RGB16I, gl.RGB32I])) {
            this.type = gl.INT;
        }
        this.recreate();
    }
    recreate() {
        this.tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.tex);
        if (this.is_float) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        }
        else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (this.mipmapped) {
            if (this.mip_levels === 0) {
                if (this.res[0] > 4 && this.res[1] > 4) {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texStorage2D(gl.TEXTURE_2D, log2(min(this.res[0], this.res[1])), this.internal_format, this.res[0], this.res[1]);
                }
                else {
                    gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, null);
                }
            }
            pause_on_gl_error();
        }
        else {
            gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, null);
        }
        if (!gl.isTexture(this.tex)) {
            console.error('TEXTURE INCOMPLETE');
        }
    }
    resize(new_res) {
        this.res = [...new_res];
        if (this.mipmapped) {
            gl.deleteTexture(this.tex);
            this.recreate();
        }
        else {
            gl.activeTexture(gl.TEXTURE15);
            gl.bindTexture(gl.TEXTURE_2D, this.tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, null);
        }
    }
    static async from_image_path(img_path) {
        function loadImage(url) {
            return new Promise((resolve) => {
                const image = new Image();
                image.addEventListener('load', () => {
                    resolve(image);
                });
                image.src = url;
            });
        }
        const img = await loadImage(img_path);
        const tex = new Texture([img.naturalWidth, img.naturalHeight], gl.RGBA8, true, 0);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, tex.res[0], tex.res[1], tex.format, tex.type, img);
        gl.generateMipmap(gl.TEXTURE_2D);
        pause_on_gl_error();
        gl.finish();
        img.remove();
        return tex;
    }
    upload_from_cpu(image) {
        if (image instanceof HTMLImageElement) {
            gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, image);
        }
        else {
            debugger;
        }
    }
    clone() {
        return new Texture(this.res, this.internal_format, this.mipmapped, this.mip_levels);
    }
    bind_to_unit(unit) {
        gl.activeTexture(gl.TEXTURE0 + unit);
        gl.bindTexture(gl.TEXTURE_2D, this.tex);
    }
    read_back_array(offs = [0, 0], read_back_res = [...this.res]) {
        let temp_fb = gl.createFramebuffer();
        let prev_bound_fb = Framebuffer.currently_bound;
        gl.bindFramebuffer(gl.FRAMEBUFFER, temp_fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.tex, 0);
        const data = this.is_float
            ? new Float32Array(read_back_res[0] * read_back_res[1] * 4)
            : new Uint8Array(read_back_res[0] * read_back_res[1] * 4);
        gl.readPixels(offs[0], offs[1], read_back_res[0], read_back_res[1], this.format, this.type, data);
        gl.deleteFramebuffer(temp_fb);
        gl.bindFramebuffer(gl.FRAMEBUFFER, prev_bound_fb.fb);
        return data;
    }
    read_back_pixel(offs) {
        let data = this.read_back_array(offs, [1, 1]);
        if (this.is_float) {
            data.forEach((e, i, a) => {
                a[i] *= 255;
            });
        }
        data[3] = 255;
        return Array.from(data);
    }
    async read_back_image(gamma_correct = false, offs = [0, 0], read_back_res = [...this.res]) {
        let data = this.read_back_array(offs, read_back_res);
        let i = 0;
        let idx = 0;
        for (let pixel of data) {
            if (i === 3) {
                if (this.is_float) {
                    data[idx] = 255;
                }
                else {
                    data[idx] = 255;
                }
                i = -1;
            }
            else {
                if (gamma_correct) {
                    if (this.is_float) {
                        data[idx] = 255 * pow(data[idx], 0.4545454545);
                    }
                    else {
                        data[idx] = 255 * pow(data[idx] / 255, 0.4545454545);
                    }
                }
            }
            idx++;
            i++;
        }
        const canvas = document.createElement('canvas');
        canvas.width = this.res[0];
        canvas.height = this.res[1];
        const context = canvas.getContext('2d');
        let blob;
        const getCanvasBlob = (canvas) => {
            return new Promise(function (resolve, reject) {
                canvas.toBlob(function (blob) {
                    resolve(blob);
                }, 'image/png');
            });
        };
        blob = await getCanvasBlob(canvas);
        console.log('BLORGUBS');
        console.log(blob);
        const imageData = context.createImageData(canvas.width, canvas.height);
        imageData.data.set(data);
        context.putImageData(imageData, 0, 0);
        const img = new Image();
        img.src = canvas.toDataURL();
        canvas.remove();
        return [img, blob];
    }
}

;// CONCATENATED MODULE: ./src/gl/Framebuffer.ts

class Framebuffer {
    static currently_bound;
    static framebuffers = [];
    _textures;
    _back_textures;
    _fb;
    _fb_back = undefined;
    default = false;
    pongable = false;
    needs_pong = false;
    pong_idx = 0;
    get textures() {
        if (this.pong_idx === 0)
            return this._textures;
        else
            return this._back_textures;
    }
    get back_textures() {
        if (this.pong_idx === 0)
            return this._back_textures;
        else
            return this._textures;
    }
    get fb() {
        if (this.pong_idx === 0)
            return this._fb;
        else
            return this._fb_back;
    }
    get fb_back() {
        if (this.pong_idx === 0)
            return this._fb_back;
        else
            return this._fb;
    }
    pong() {
        this.pong_idx = 1 - this.pong_idx;
        this.needs_pong = false;
    }
    recreate() {
        if (this.pongable) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fb_back);
            let i = 0;
            for (let tex of this._back_textures) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, tex.tex, 0);
            }
            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                console.error('FRAMEBUFFER INCOMPLETE');
            }
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fb);
        let i = 0;
        for (let tex of this._textures) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, tex.tex, 0);
            i++;
        }
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
            console.error('FRAMEBUFFER INCOMPLETE');
        }
    }
    constructor(textures, pongable = false) {
        this._fb = gl.createFramebuffer();
        this._textures = [...textures];
        this.pongable = pongable;
        this._back_textures = [];
        if (this.pongable) {
            this._fb_back = gl.createFramebuffer();
            for (let tex of this.textures) {
                this._back_textures.push(tex.clone());
            }
        }
        this.recreate();
        gl.bindFramebuffer(gl.FRAMEBUFFER, Framebuffer.currently_bound._fb);
        Framebuffer.framebuffers.push(this);
    }
    bind() {
        if (this.pongable)
            this.needs_pong = true;
        let draw_buffs = [];
        if (this.default) {
            draw_buffs = [gl.BACK];
        }
        else {
            let i = 0;
            for (let tex of this.textures) {
                draw_buffs.push(gl.COLOR_ATTACHMENT0 + i);
                i++;
            }
        }
        gl.viewport(0, 0, this.textures[0].res[0], this.textures[0].res[1]);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);
        Framebuffer.currently_bound = this;
    }
    clear(colour = [0, 0, 0, 0]) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);
        gl.clearColor(colour[0], colour[1], colour[2], colour[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, Framebuffer.currently_bound.fb);
    }
}

;// CONCATENATED MODULE: ./src/gl_utils.ts


function init_gl_error_handling() {
    if (!gl.debugEnabled)
        return;
    gl.glEnums = {};
    gl.enumStringToValue = {};
    for (let propertyName in gl) {
        if (typeof gl[propertyName] === 'number') {
            gl.glEnums[gl[propertyName]] = propertyName;
            gl.enumStringToValue[propertyName] = gl[propertyName];
        }
    }
}
function gl_enum_to_string(value) {
    const name = window.gl.glEnums[value];
    return name !== undefined ? 'gl.' + name : '/*UNKNOWN WebGL ENUM*/ 0x' + value.toString(16) + '';
}
function print_on_gl_error() {
    if (!gl.debugEnabled)
        return;
    let err = window.gl.getError();
    if (err !== 0) {
        console.error(err);
        console.error(gl_enum_to_string(err));
    }
}
function pause_on_gl_error() {
    if (!gl.debugEnabled)
        return;
    let err = window.gl.getError();
    if (err !== 0) {
        console.error(err);
        console.error(gl_enum_to_string(err));
        debugger;
    }
}
function copy_fb_to_texture(in_framebuffer, out_texture) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, in_framebuffer);
    gl.bindTexture(gl.TEXTURE_2D, out_texture.tex);
    gl.copyTexImage2D(gl.TEXTURE_2D, 0, out_texture.internal_format, 0, 0, out_texture.res[0], out_texture.res[1], 0);
}
function copy_fb_to_fb(in_framebuffer, out_framebuffer, res) {
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, in_framebuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, out_framebuffer);
    gl.blitFramebuffer(0, 0, res[0], res[1], 0, 0, res[0], res[1], gl.COLOR_BUFFER_BIT, gl.NEAREST);
}
function resizeIfNeeded(canvas, default_framebuffer, client_res, set_redraw_needed, set_shared_uniforms) {
    const displayWidth = canvas.clientWidth;
    const displayHeight = canvas.clientHeight;
    const needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;
    if (needResize) {
        client_res[0] = canvas.width = displayWidth;
        client_res[1] = canvas.height = displayHeight;
        set_redraw_needed(true);
        default_framebuffer._textures[0].res = [...client_res];
        set_shared_uniforms();
    }
    return needResize;
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/easing/index.js
/*
Adapted from https://github.com/mattdesl
Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
*/


/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function backInOut(t) {
	const s = 1.70158 * 1.525;
	if ((t *= 2) < 1) return 0.5 * (t * t * ((s + 1) * t - s));
	return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function backIn(t) {
	const s = 1.70158;
	return t * t * ((s + 1) * t - s);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function backOut(t) {
	const s = 1.70158;
	return --t * t * ((s + 1) * t + s) + 1;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function bounceOut(t) {
	const a = 4.0 / 11.0;
	const b = 8.0 / 11.0;
	const c = 9.0 / 10.0;
	const ca = 4356.0 / 361.0;
	const cb = 35442.0 / 1805.0;
	const cc = 16061.0 / 1805.0;
	const t2 = t * t;
	return t < a
		? 7.5625 * t2
		: t < b
		? 9.075 * t2 - 9.9 * t + 3.4
		: t < c
		? ca * t2 - cb * t + cc
		: 10.8 * t * t - 20.52 * t + 10.72;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function bounceInOut(t) {
	return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function bounceIn(t) {
	return 1.0 - bounceOut(1.0 - t);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function circInOut(t) {
	if ((t *= 2) < 1) return -0.5 * (Math.sqrt(1 - t * t) - 1);
	return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function circIn(t) {
	return 1.0 - Math.sqrt(1.0 - t * t);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function circOut(t) {
	return Math.sqrt(1 - --t * t);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function easing_cubicInOut(t) {
	return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function cubicIn(t) {
	return t * t * t;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function easing_cubicOut(t) {
	const f = t - 1.0;
	return f * f * f + 1.0;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function elasticInOut(t) {
	return t < 0.5
		? 0.5 * Math.sin(((+13.0 * Math.PI) / 2) * 2.0 * t) * Math.pow(2.0, 10.0 * (2.0 * t - 1.0))
		: 0.5 *
				Math.sin(((-13.0 * Math.PI) / 2) * (2.0 * t - 1.0 + 1.0)) *
				Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) +
				1.0;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function elasticIn(t) {
	return Math.sin((13.0 * t * Math.PI) / 2) * Math.pow(2.0, 10.0 * (t - 1.0));
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function elasticOut(t) {
	return Math.sin((-13.0 * (t + 1.0) * Math.PI) / 2) * Math.pow(2.0, -10.0 * t) + 1.0;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function expoInOut(t) {
	return t === 0.0 || t === 1.0
		? t
		: t < 0.5
		? +0.5 * Math.pow(2.0, 20.0 * t - 10.0)
		: -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function expoIn(t) {
	return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function expoOut(t) {
	return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function quadInOut(t) {
	t /= 0.5;
	if (t < 1) return 0.5 * t * t;
	t--;
	return -0.5 * (t * (t - 2) - 1);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function quadIn(t) {
	return t * t;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function quadOut(t) {
	return -t * (t - 2.0);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function quartInOut(t) {
	return t < 0.5 ? +8.0 * Math.pow(t, 4.0) : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function quartIn(t) {
	return Math.pow(t, 4.0);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function quartOut(t) {
	return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function quintInOut(t) {
	if ((t *= 2) < 1) return 0.5 * t * t * t * t * t;
	return 0.5 * ((t -= 2) * t * t * t * t + 2);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function quintIn(t) {
	return t * t * t * t * t;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function quintOut(t) {
	return --t * t * t * t * t + 1;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function sineInOut(t) {
	return -0.5 * (Math.cos(Math.PI * t) - 1);
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function sineIn(t) {
	const v = Math.cos(t * Math.PI * 0.5);
	if (Math.abs(v) < 1e-14) return 1;
	else return 1 - v;
}

/**
 * https://svelte.dev/docs/svelte-easing
 * @param {number} t
 * @returns {number}
 */
function sineOut(t) {
	return Math.sin((t * Math.PI) / 2);
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/transition/index.js



/**
 * Animates a `blur` filter alongside an element's opacity.
 *
 * https://svelte.dev/docs/svelte-transition#blur
 * @param {Element} node
 * @param {import('./public').BlurParams} [params]
 * @returns {import('./public').TransitionConfig}
 */
function transition_blur(
	node,
	{ delay = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0 } = {}
) {
	const style = getComputedStyle(node);
	const target_opacity = +style.opacity;
	const f = style.filter === 'none' ? '' : style.filter;
	const od = target_opacity * (1 - opacity);
	const [value, unit] = split_css_unit(amount);
	return {
		delay,
		duration,
		easing,
		css: (_t, u) => `opacity: ${target_opacity - od * u}; filter: ${f} blur(${u * value}${unit});`
	};
}

/**
 * Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.
 *
 * https://svelte.dev/docs/svelte-transition#fade
 * @param {Element} node
 * @param {import('./public').FadeParams} [params]
 * @returns {import('./public').TransitionConfig}
 */
function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
	const o = +getComputedStyle(node).opacity;
	return {
		delay,
		duration,
		easing,
		css: (t) => `opacity: ${t * o}`
	};
}

/**
 * Animates the x and y positions and the opacity of an element. `in` transitions animate from the provided values, passed as parameters to the element's default values. `out` transitions animate from the element's default values to the provided values.
 *
 * https://svelte.dev/docs/svelte-transition#fly
 * @param {Element} node
 * @param {import('./public').FlyParams} [params]
 * @returns {import('./public').TransitionConfig}
 */
function fly(
	node,
	{ delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}
) {
	const style = getComputedStyle(node);
	const target_opacity = +style.opacity;
	const transform = style.transform === 'none' ? '' : style.transform;
	const od = target_opacity * (1 - opacity);
	const [xValue, xUnit] = split_css_unit(x);
	const [yValue, yUnit] = split_css_unit(y);
	return {
		delay,
		duration,
		easing,
		css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});
			opacity: ${target_opacity - od * u}`
	};
}

/**
 * Slides an element in and out.
 *
 * https://svelte.dev/docs/svelte-transition#slide
 * @param {Element} node
 * @param {import('./public').SlideParams} [params]
 * @returns {import('./public').TransitionConfig}
 */
function slide(node, { delay = 0, duration = 400, easing = easing_cubicOut, axis = 'y' } = {}) {
	const style = getComputedStyle(node);
	const opacity = +style.opacity;
	const primary_property = axis === 'y' ? 'height' : 'width';
	const primary_property_value = parseFloat(style[primary_property]);
	const secondary_properties = axis === 'y' ? ['top', 'bottom'] : ['left', 'right'];
	const capitalized_secondary_properties = secondary_properties.map(
		(e) => `${e[0].toUpperCase()}${e.slice(1)}`
	);
	const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
	const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
	const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
	const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
	const border_width_start_value = parseFloat(
		style[`border${capitalized_secondary_properties[0]}Width`]
	);
	const border_width_end_value = parseFloat(
		style[`border${capitalized_secondary_properties[1]}Width`]
	);
	return {
		delay,
		duration,
		easing,
		css: (t) =>
			'overflow: hidden;' +
			`opacity: ${Math.min(t * 20, 1) * opacity};` +
			`${primary_property}: ${t * primary_property_value}px;` +
			`padding-${secondary_properties[0]}: ${t * padding_start_value}px;` +
			`padding-${secondary_properties[1]}: ${t * padding_end_value}px;` +
			`margin-${secondary_properties[0]}: ${t * margin_start_value}px;` +
			`margin-${secondary_properties[1]}: ${t * margin_end_value}px;` +
			`border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;` +
			`border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
	};
}

/**
 * Animates the opacity and scale of an element. `in` transitions animate from an element's current (default) values to the provided values, passed as parameters. `out` transitions animate from the provided values to an element's default values.
 *
 * https://svelte.dev/docs/svelte-transition#scale
 * @param {Element} node
 * @param {import('./public').ScaleParams} [params]
 * @returns {import('./public').TransitionConfig}
 */
function scale(
	node,
	{ delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}
) {
	const style = getComputedStyle(node);
	const target_opacity = +style.opacity;
	const transform = style.transform === 'none' ? '' : style.transform;
	const sd = 1 - start;
	const od = target_opacity * (1 - opacity);
	return {
		delay,
		duration,
		easing,
		css: (_t, u) => `
			transform: ${transform} scale(${1 - sd * u});
			opacity: ${target_opacity - od * u}
		`
	};
}

/**
 * Animates the stroke of an SVG element, like a snake in a tube. `in` transitions begin with the path invisible and draw the path to the screen over time. `out` transitions start in a visible state and gradually erase the path. `draw` only works with elements that have a `getTotalLength` method, like `<path>` and `<polyline>`.
 *
 * https://svelte.dev/docs/svelte-transition#draw
 * @param {SVGElement & { getTotalLength(): number }} node
 * @param {import('./public').DrawParams} [params]
 * @returns {import('./public').TransitionConfig}
 */
function draw(node, { delay = 0, speed, duration, easing = cubicInOut } = {}) {
	let len = node.getTotalLength();
	const style = getComputedStyle(node);
	if (style.strokeLinecap !== 'butt') {
		len += parseInt(style.strokeWidth);
	}
	if (duration === undefined) {
		if (speed === undefined) {
			duration = 800;
		} else {
			duration = len / speed;
		}
	} else if (typeof duration === 'function') {
		duration = duration(len);
	}
	return {
		delay,
		duration,
		easing,
		css: (_, u) => `
			stroke-dasharray: ${len};
			stroke-dashoffset: ${u * len};
		`
	};
}

/**
 * The `crossfade` function creates a pair of [transitions](/docs#template-syntax-element-directives-transition-fn) called `send` and `receive`. When an element is 'sent', it looks for a corresponding element being 'received', and generates a transition that transforms the element to its counterpart's position and fades it out. When an element is 'received', the reverse happens. If there is no counterpart, the `fallback` transition is used.
 *
 * https://svelte.dev/docs/svelte-transition#crossfade
 * @param {import('./public').CrossfadeParams & {
 * 	fallback?: (node: Element, params: import('./public').CrossfadeParams, intro: boolean) => import('./public').TransitionConfig;
 * }} params
 * @returns {[(node: any, params: import('./public').CrossfadeParams & { key: any; }) => () => import('./public').TransitionConfig, (node: any, params: import('./public').CrossfadeParams & { key: any; }) => () => import('./public').TransitionConfig]}
 */
function crossfade({ fallback, ...defaults }) {
	/** @type {Map<any, Element>} */
	const to_receive = new Map();
	/** @type {Map<any, Element>} */
	const to_send = new Map();
	/**
	 * @param {Element} from_node
	 * @param {Element} node
	 * @param {import('./public').CrossfadeParams} params
	 * @returns {import('./public').TransitionConfig}
	 */
	function crossfade(from_node, node, params) {
		const {
			delay = 0,
			duration = (d) => Math.sqrt(d) * 30,
			easing = cubicOut
		} = assign(assign({}, defaults), params);
		const from = from_node.getBoundingClientRect();
		const to = node.getBoundingClientRect();
		const dx = from.left - to.left;
		const dy = from.top - to.top;
		const dw = from.width / to.width;
		const dh = from.height / to.height;
		const d = Math.sqrt(dx * dx + dy * dy);
		const style = getComputedStyle(node);
		const transform = style.transform === 'none' ? '' : style.transform;
		const opacity = +style.opacity;
		return {
			delay,
			duration: is_function(duration) ? duration(d) : duration,
			easing,
			css: (t, u) => `
				opacity: ${t * opacity};
				transform-origin: top left;
				transform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${
				t + (1 - t) * dh
			});
			`
		};
	}

	/**
	 * @param {Map<any, Element>} items
	 * @param {Map<any, Element>} counterparts
	 * @param {boolean} intro
	 * @returns {(node: any, params: import('./public').CrossfadeParams & { key: any; }) => () => import('./public').TransitionConfig}
	 */
	function transition(items, counterparts, intro) {
		return (node, params) => {
			items.set(params.key, node);
			return () => {
				if (counterparts.has(params.key)) {
					const other_node = counterparts.get(params.key);
					counterparts.delete(params.key);
					return crossfade(other_node, node, params);
				}
				// if the node is disappearing altogether
				// (i.e. wasn't claimed by the other list)
				// then we need to supply an outro
				items.delete(params.key);
				return fallback && fallback(node, params, intro);
			};
		};
	}
	return [transition(to_send, to_receive, false), transition(to_receive, to_send, true)];
}

;// CONCATENATED MODULE: ./src/components/SemiModal.svelte
/* src/components/SemiModal.svelte generated by Svelte v4.0.1 */






const file = "src/components/SemiModal.svelte";

function add_css(target) {
	append_styles(target, "svelte-1pb3dee", "#bar.svelte-1pb3dee{z-index:0 !important;background:black;width:100%;height:6rem;display:flex;padding:0rem 1rem;align-items:center;justify-content:flex-end;flex-wrap:wrap;background:black;width:100%;display:flex;align-items:center}#bar.svelte-1pb3dee>div{max-height:4rem;height:100%;margin-right:0.25rem;z-index:1}#bar.svelte-1pb3dee>div:not(:first-of-type){margin-left:0.25rem}#bar.svelte-1pb3dee>div:last-of-type{margin-right:4rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VtaU1vZGFsLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtQmtCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlNlbWlNb2RhbC5zdmVsdGUiXX0= */");
}

// (11:0) {#if !hidden}
function create_if_block(ctx) {
	let div;
	let div_style_value;
	let div_transition;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	const block = {
		c: function create() {
			div = dom_element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "id", "bar");
			attr_dev(div, "style", div_style_value = /*$gallery_open*/ ctx[1] ? "display: none;" : "");
			attr_dev(div, "class", "svelte-1pb3dee");
			add_location(div, file, 14, 0, 238);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*$gallery_open*/ 2 && div_style_value !== (div_style_value = /*$gallery_open*/ ctx[1] ? "display: none;" : "")) {
				attr_dev(div, "style", div_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(default_slot, local);

			if (local) {
				scheduler_add_render_callback(() => {
					if (!current) return;
					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 200 }, true);
					div_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(default_slot, local);

			if (local) {
				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 200 }, false);
				div_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (default_slot) default_slot.d(detaching);
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(11:0) {#if !hidden}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = !/*hidden*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!/*hidden*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*hidden*/ 1) {
						transitions_transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transitions_transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				transitions_group_outros();

				transitions_transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				transitions_check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $gallery_open;
	validate_store(gallery_open, 'gallery_open');
	component_subscribe($$self, gallery_open, $$value => $$invalidate(1, $gallery_open = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('SemiModal', slots, ['default']);
	let { hidden = true } = $$props;
	let { knob } = $$props;

	$$self.$$.on_mount.push(function () {
		if (knob === undefined && !('knob' in $$props || $$self.$$.bound[$$self.$$.props['knob']])) {
			console.warn("<SemiModal> was created without expected prop 'knob'");
		}
	});

	const writable_props = ['hidden', 'knob'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SemiModal> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('hidden' in $$props) $$invalidate(0, hidden = $$props.hidden);
		if ('knob' in $$props) $$invalidate(2, knob = $$props.knob);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		Knob: Knob_svelte,
		fade: fade,
		slide: slide,
		gallery_open: gallery_open,
		hidden,
		knob,
		$gallery_open
	});

	$$self.$inject_state = $$props => {
		if ('hidden' in $$props) $$invalidate(0, hidden = $$props.hidden);
		if ('knob' in $$props) $$invalidate(2, knob = $$props.knob);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [hidden, $gallery_open, knob, $$scope, slots];
}

class SemiModal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { hidden: 0, knob: 2 }, add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SemiModal",
			options,
			id: create_fragment.name
		});
	}

	get hidden() {
		return this.$$.ctx[0];
	}

	set hidden(hidden) {
		this.$$set({ hidden });
		scheduler_flush();
	}

	get knob() {
		return this.$$.ctx[2];
	}

	set knob(knob) {
		this.$$set({ knob });
		scheduler_flush();
	}
}

/* harmony default export */ const SemiModal_svelte = (SemiModal);
;// CONCATENATED MODULE: ./src/components/Knob.svelte
/* src/components/Knob.svelte generated by Svelte v4.0.1 */







const Knob_svelte_file = "src/components/Knob.svelte";

function Knob_svelte_add_css(target) {
	append_styles(target, "svelte-1god0ab", ".knob-container-container.svelte-1god0ab.svelte-1god0ab{aspect-ratio:1/1;margin-top:0.5rem;margin-right:0.5rem;display:flex;flex-direction:column;justify-content:center;align-items:center;pointer-events:all;user-select:none}.knob-container-container.svelte-1god0ab>.title.menu-toggle.svelte-1god0ab{background:white;color:black}.knob-container-container.svelte-1god0ab>.title.svelte-1god0ab{cursor:pointer;font-size:0.8rem !important;margin-top:0.5rem;color:white;width:100%;text-align:center;font-weight:bolder;top:5.5rem;user-select:none}.knob-container-container.svelte-1god0ab>.knob-container.svelte-1god0ab{box-sizing:border-box;-webkit-box-sizing:border-box;aspect-ratio:1/1;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;background-image:conic-gradient(from 45deg, var(--secondary-color) 0deg 15deg, var(--tertiary-color) 60deg 60deg, var(--darken-color) 120deg 240deg, var(--tertiary-color) 300deg 300deg, var(--secondary-color) 345deg 360deg);border-radius:50%;border:0.2rem solid white}.knob-container-container.svelte-1god0ab>.knob-container.svelte-1god0ab:hover{cursor:pointer}.knob-container-container.svelte-1god0ab>.knob svg.svelte-1god0ab{width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiS25vYi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBc0ZrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJLbm9iLnN2ZWx0ZSJdfQ== */");
}

function Knob_svelte_create_fragment(ctx) {
	let div3;
	let div1;
	let div0;
	let svg;
	let g;
	let path;
	let t0;
	let div2;
	let t1;
	let div2_class_value;
	let div2_style_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div3 = dom_element("div");
			div1 = dom_element("div");
			div0 = dom_element("div");
			svg = svg_element("svg");
			g = svg_element("g");
			path = svg_element("path");
			t0 = space();
			div2 = dom_element("div");
			t1 = dom_text(/*title*/ ctx[3]);
			attr_dev(path, "stroke-width", "10");
			attr_dev(path, "d", "M50 40 l0 -50");
			add_location(path, Knob_svelte_file, 74, 10, 2001);
			attr_dev(g, "fill", "none");
			attr_dev(g, "stroke", "currentColor");
			add_location(g, Knob_svelte_file, 73, 8, 1953);
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "0 0 100 100");
			attr_dev(svg, "class", "svelte-1god0ab");
			add_location(svg, Knob_svelte_file, 72, 6, 1890);
			attr_dev(div0, "class", "knob");
			set_style(div0, "transform", "rotate(calc(" + /*rotation*/ ctx[5] + " * 1rad))");
			add_location(div0, Knob_svelte_file, 71, 4, 1785);
			attr_dev(div1, "class", "knob-container svelte-1god0ab");
			add_location(div1, Knob_svelte_file, 70, 2, 1752);
			attr_dev(div2, "class", div2_class_value = "title " + (/*triggerModal*/ ctx[1] ? "menu-toggle" : "") + " svelte-1god0ab");
			attr_dev(div2, "style", div2_style_value = "" + ((!/*modalHidden*/ ctx[0] && "outline: 1px solid white; outline-offset: 0.1rem;") + " " + (/*modal*/ ctx[2] && "cursor: pointer;")));
			add_location(div2, Knob_svelte_file, 79, 2, 2094);
			attr_dev(div3, "draggable", "false");
			attr_dev(div3, "class", "knob-container-container svelte-1god0ab");
			add_location(div3, Knob_svelte_file, 69, 0, 1693);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div1);
			append_dev(div1, div0);
			append_dev(div0, svg);
			append_dev(svg, g);
			append_dev(g, path);
			append_dev(div3, t0);
			append_dev(div3, div2);
			append_dev(div2, t1);
			/*div2_binding*/ ctx[8](div2);

			if (!mounted) {
				dispose = listen_dev(div0, "pointerdown", /*pointerDown*/ ctx[6], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*rotation*/ 32) {
				set_style(div0, "transform", "rotate(calc(" + /*rotation*/ ctx[5] + " * 1rad))");
			}

			if (dirty & /*title*/ 8) set_data_dev(t1, /*title*/ ctx[3]);

			if (dirty & /*triggerModal*/ 2 && div2_class_value !== (div2_class_value = "title " + (/*triggerModal*/ ctx[1] ? "menu-toggle" : "") + " svelte-1god0ab")) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (dirty & /*modalHidden, modal*/ 5 && div2_style_value !== (div2_style_value = "" + ((!/*modalHidden*/ ctx[0] && "outline: 1px solid white; outline-offset: 0.1rem;") + " " + (/*modal*/ ctx[2] && "cursor: pointer;")))) {
				attr_dev(div2, "style", div2_style_value);
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div3);
			}

			/*div2_binding*/ ctx[8](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Knob_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function Knob_svelte_instance($$self, $$props, $$invalidate) {
	let rotation;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Knob', slots, []);
	let { value } = $$props;
	let { triggerModal = undefined } = $$props;
	let { modal = undefined } = $$props;
	let { modalHidden = true } = $$props;
	let { title = "" } = $$props;
	let titleElement;
	const rotRange = 2 * Math.PI * 0.83;
	let startY = 0;
	let startX = 0;
	let startValue = 0;

	const pointerMove = ({ clientX, clientY }) => {
		let scale = 3. / min(document.documentElement.clientWidth, document.documentElement.clientHeight);
		let valueDiff = (startY - clientY) * scale;
		valueDiff -= (startX - clientX) * scale;
		$$invalidate(7, value = saturate(startValue + valueDiff));
	};

	const pointerDown = e => {
		let { clientX, clientY } = e;
		startY = clientY;
		startX = clientX;
		startValue = value;
		window.addEventListener('pointermove', pointerMove);
		window.addEventListener('pointerup', pointerUp);
		e.stopPropagation();
	};

	function pointerUp() {
		window.removeEventListener('pointermove', pointerMove);
		window.removeEventListener('pointerup', pointerUp);
	}

	onMount(() => {
		let pointerDown;

		let pointerUp = () => {
			if (modal) {
				triggerModal?.(modal);
				$$invalidate(0, modalHidden = modal.hidden);
			}

			titleElement.removeEventListener("pointerdown", pointerDown);
		};

		pointerDown = () => {
			titleElement.removeEventListener("pointerup", pointerUp);
			titleElement.addEventListener("pointerup", pointerUp);
		};

		titleElement.addEventListener("pointerdown", pointerDown);
	});

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<Knob> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value', 'triggerModal', 'modal', 'modalHidden', 'title'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Knob> was created with unknown prop '${key}'`);
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			titleElement = $$value;
			$$invalidate(4, titleElement);
		});
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(7, value = $$props.value);
		if ('triggerModal' in $$props) $$invalidate(1, triggerModal = $$props.triggerModal);
		if ('modal' in $$props) $$invalidate(2, modal = $$props.modal);
		if ('modalHidden' in $$props) $$invalidate(0, modalHidden = $$props.modalHidden);
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
	};

	$$self.$capture_state = () => ({
		min: min,
		SemiModal: SemiModal_svelte,
		onMount: onMount,
		saturate: saturate,
		value,
		triggerModal,
		modal,
		modalHidden,
		title,
		titleElement,
		rotRange,
		startY,
		startX,
		startValue,
		pointerMove,
		pointerDown,
		pointerUp,
		rotation
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(7, value = $$props.value);
		if ('triggerModal' in $$props) $$invalidate(1, triggerModal = $$props.triggerModal);
		if ('modal' in $$props) $$invalidate(2, modal = $$props.modal);
		if ('modalHidden' in $$props) $$invalidate(0, modalHidden = $$props.modalHidden);
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
		if ('titleElement' in $$props) $$invalidate(4, titleElement = $$props.titleElement);
		if ('startY' in $$props) startY = $$props.startY;
		if ('startX' in $$props) startX = $$props.startX;
		if ('startValue' in $$props) startValue = $$props.startValue;
		if ('rotation' in $$props) $$invalidate(5, rotation = $$props.rotation);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 128) {
			$: $$invalidate(5, rotation = -Math.PI * 0.83 + value * rotRange);
		}
	};

	return [
		modalHidden,
		triggerModal,
		modal,
		title,
		titleElement,
		rotation,
		pointerDown,
		value,
		div2_binding
	];
}

class Knob extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			Knob_svelte_instance,
			Knob_svelte_create_fragment,
			safe_not_equal,
			{
				value: 7,
				triggerModal: 1,
				modal: 2,
				modalHidden: 0,
				title: 3
			},
			Knob_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Knob",
			options,
			id: Knob_svelte_create_fragment.name
		});
	}

	get value() {
		return this.$$.ctx[7];
	}

	set value(value) {
		this.$$set({ value });
		scheduler_flush();
	}

	get triggerModal() {
		return this.$$.ctx[1];
	}

	set triggerModal(triggerModal) {
		this.$$set({ triggerModal });
		scheduler_flush();
	}

	get modal() {
		return this.$$.ctx[2];
	}

	set modal(modal) {
		this.$$set({ modal });
		scheduler_flush();
	}

	get modalHidden() {
		return this.$$.ctx[0];
	}

	set modalHidden(modalHidden) {
		this.$$set({ modalHidden });
		scheduler_flush();
	}

	get title() {
		return this.$$.ctx[3];
	}

	set title(title) {
		this.$$set({ title });
		scheduler_flush();
	}
}

/* harmony default export */ const Knob_svelte = (Knob);
// EXTERNAL MODULE: ./public/copy.svg
var copy = __webpack_require__(5399);
var copy_default = /*#__PURE__*/__webpack_require__.n(copy);
;// CONCATENATED MODULE: ./src/components/BrushSizeWidget.svelte
/* src/components/BrushSizeWidget.svelte generated by Svelte v4.0.1 */





const BrushSizeWidget_svelte_file = "src/components/BrushSizeWidget.svelte";

function BrushSizeWidget_svelte_add_css(target) {
	append_styles(target, "svelte-1fnn83o", ".knob-container.svelte-1fnn83o.svelte-1fnn83o{cursor:pointer;aspect-ratio:1/1;height:100%;margin-left:0.5rem;margin-right:0.5rem;margin-bottom:auto;margin-top:auto;pointer-events:all;user-select:none;width:unset}.knob-container.svelte-1fnn83o.svelte-1fnn83o:hover{cursor:pointer}.knob.svelte-1fnn83o.svelte-1fnn83o{display:block;aspect-ratio:1/1;height:100%;padding:0;color:var(--text-color);fill:white;width:unset;max-width:unset;transform-origin:50% 50%}.knob.svelte-1fnn83o.svelte-1fnn83o:active{filter:invert(1);background:black}.knob.svelte-1fnn83o svg{fill:white;width:100%;height:100%}.knob-container-container.svelte-1fnn83o.svelte-1fnn83o{aspect-ratio:1/1}.knob-container-container.svelte-1fnn83o.svelte-1fnn83o:active{filter:invert(1)}.knob-container-container.svelte-1fnn83o .knob.svelte-1fnn83o:active{filter:invert(0);background:black}.knob-container-container.svelte-1fnn83o.svelte-1fnn83o:hover{cursor:pointer}.knob-container-container.svelte-1fnn83o .knob-container.svelte-1fnn83o{margin-left:0;margin-right:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnJ1c2hTaXplV2lkZ2V0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFzRGtCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJydXNoU2l6ZVdpZGdldC5zdmVsdGUiXX0= */");
}

function BrushSizeWidget_svelte_create_fragment(ctx) {
	let div2;
	let div1;
	let div0;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div2 = dom_element("div");
			div1 = dom_element("div");
			div0 = dom_element("div");
			attr_dev(div0, "class", "knob svelte-1fnn83o");
			add_location(div0, BrushSizeWidget_svelte_file, 4, 2, 161);
			attr_dev(div1, "class", "knob-container svelte-1fnn83o");
			add_location(div1, BrushSizeWidget_svelte_file, 3, 1, 130);
			attr_dev(div2, "class", "knob-container-container svelte-1fnn83o");
			toggle_class(div2, "knob-selected", /*dragging*/ ctx[0]);
			add_location(div2, BrushSizeWidget_svelte_file, 2, 0, 30);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, div0);
			div0.innerHTML = (copy_default());

			if (!mounted) {
				dispose = listen_dev(div2, "pointerdown", /*pointerDown*/ ctx[1], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*dragging*/ 1) {
				toggle_class(div2, "knob-selected", /*dragging*/ ctx[0]);
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div2);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BrushSizeWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function BrushSizeWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BrushSizeWidget', slots, []);
	let { brush_sz = [0.2, 0.2] } = $$props;
	let { dragging = false } = $$props;
	let { stopped_dragging = false } = $$props;
	let startY = 0;
	let startValue = [0, 0];
	let startX = 0;

	const pointerMove = ({ clientX, clientY }) => {
		const scale = 10. / min(document.documentElement.clientWidth, document.documentElement.clientHeight);
		const valueDiffY = (startY - clientY) * scale;
		const valueDiffX = (startX - clientX) * scale;
		$$invalidate(2, brush_sz[0] = wmath_clamp(startValue[0] - valueDiffX, 0, 5), brush_sz);
		$$invalidate(2, brush_sz[1] = wmath_clamp(startValue[1] + valueDiffY, 0, 5), brush_sz);
	};

	const pointerDown = e => {
		$$invalidate(0, dragging = true);
		const { clientX, clientY } = e;
		startY = clientY;
		startX = clientX;
		startValue = [...brush_sz];
		window.addEventListener('pointermove', pointerMove);
		window.addEventListener('pointerup', pointerUp);
		e.stopPropagation();
	};

	function pointerUp() {
		$$invalidate(0, dragging = false);
		$$invalidate(3, stopped_dragging = true);
		window.removeEventListener('pointermove', pointerMove);
		window.removeEventListener('pointerup', pointerUp);
	}

	const writable_props = ['brush_sz', 'dragging', 'stopped_dragging'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BrushSizeWidget> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('brush_sz' in $$props) $$invalidate(2, brush_sz = $$props.brush_sz);
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
		if ('stopped_dragging' in $$props) $$invalidate(3, stopped_dragging = $$props.stopped_dragging);
	};

	$$self.$capture_state = () => ({
		clamp: wmath_clamp,
		min: min,
		brushSizeIcon: (copy_default()),
		brush_sz,
		dragging,
		stopped_dragging,
		startY,
		startValue,
		startX,
		pointerMove,
		pointerDown,
		pointerUp
	});

	$$self.$inject_state = $$props => {
		if ('brush_sz' in $$props) $$invalidate(2, brush_sz = $$props.brush_sz);
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
		if ('stopped_dragging' in $$props) $$invalidate(3, stopped_dragging = $$props.stopped_dragging);
		if ('startY' in $$props) startY = $$props.startY;
		if ('startValue' in $$props) startValue = $$props.startValue;
		if ('startX' in $$props) startX = $$props.startX;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [dragging, pointerDown, brush_sz, stopped_dragging];
}

class BrushSizeWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			BrushSizeWidget_svelte_instance,
			BrushSizeWidget_svelte_create_fragment,
			safe_not_equal,
			{
				brush_sz: 2,
				dragging: 0,
				stopped_dragging: 3
			},
			BrushSizeWidget_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BrushSizeWidget",
			options,
			id: BrushSizeWidget_svelte_create_fragment.name
		});
	}

	get brush_sz() {
		return this.$$.ctx[2];
	}

	set brush_sz(brush_sz) {
		this.$$set({ brush_sz });
		scheduler_flush();
	}

	get dragging() {
		return this.$$.ctx[0];
	}

	set dragging(dragging) {
		this.$$set({ dragging });
		scheduler_flush();
	}

	get stopped_dragging() {
		return this.$$.ctx[3];
	}

	set stopped_dragging(stopped_dragging) {
		this.$$set({ stopped_dragging });
		scheduler_flush();
	}
}

/* harmony default export */ const BrushSizeWidget_svelte = (BrushSizeWidget);
;// CONCATENATED MODULE: ./src/stuff.ts



function assert(v) {
    if (!v)
        debugger;
}
class BrushTexture {
    gpu_tex = undefined;
    path = undefined;
    idx;
    static async create(path, idx) {
        const gpu_tex = await Texture.from_image_path(path);
        return {
            gpu_tex,
            path,
            idx,
        };
    }
}
class Project {
    id = Date.now();
    saved = false;
    brush_strokes = [];
    canvasRes = [1024, 2048];
    constructor() { }
    push_stroke(stroke) {
        this.brush_strokes.push(stroke);
    }
}
class Utils {
    static isOnMobile = () => {
        let check = false;
        (function (a) {
            if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) ||
                /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
                check = true;
        })(navigator.userAgent || navigator.vendor || window.opera);
        return check;
    };
    static gamma_correct(u, inverse = false, modify = false) {
        const exponent = inverse ? 1 / 0.45454545454545 : 0.45454545454545;
        if (!modify)
            u = [...u];
        u.forEach((v, i, a) => {
            a[i] = pow(v, exponent);
        });
        return u;
    }
    static css_contain(u, input_res, tex_res) {
        const user_res = input_res;
        const canvas_res = tex_res;
        const input_ratio = user_res[0] / user_res[1];
        const tex_ratio = canvas_res[0] / canvas_res[1];
        const ratio = input_ratio / tex_ratio;
        if (ratio > 1) {
            return [u[0] * ratio, u[1]];
        }
        else {
            return [u[0], u[1] / ratio];
        }
    }
    static screen_NDC_to_canvas_NDC(u, user_tex, canvas_tex, zoom, pan) {
        const user_res = user_tex.res;
        const canvas_res = canvas_tex.res;
        u = [...u];
        const input_ratio = user_res[0] / user_res[1];
        const tex_ratio = canvas_res[0] / canvas_res[1];
        const ratio = input_ratio / tex_ratio;
        if (ratio > 1) {
            u[0] *= ratio / zoom;
            u[1] /= zoom;
            const cont = Utils.css_contain([1, 1], user_res, canvas_res);
            u[0] -= pan[0] * cont[0];
            u[1] -= pan[1] * cont[1];
        }
        else {
            u[0] /= zoom;
            u[1] /= ratio * zoom;
            const cont = Utils.css_contain([1, 1], user_res, canvas_res);
            u[0] -= pan[0] * cont[0];
            u[1] -= pan[1] * cont[1];
        }
        return u;
    }
    static texture_NDC_to_texture_pixel_coords(u, tex) {
        return [(u[0] * 0.5 + 0.5) * tex.res[0], (u[1] * 0.5 + 0.5) * tex.res[1]];
    }
}

;// CONCATENATED MODULE: ./src/brush_stroke.ts

var BlendingColourSpace;
(function (BlendingColourSpace) {
    BlendingColourSpace[BlendingColourSpace["RGB"] = 0] = "RGB";
    BlendingColourSpace[BlendingColourSpace["OkLCH"] = 1] = "OkLCH";
    BlendingColourSpace[BlendingColourSpace["Pigments"] = 2] = "Pigments";
})(BlendingColourSpace || (BlendingColourSpace = {}));
class DrawParams {
    tex_dynamics = 0.3;
    tex_lch_dynamics = [0, 0, 0.2];
    noise_stretch = [1, 0.2];
    tex_stretch = [1, 0.2];
    blending_colour_space = BlendingColourSpace.Pigments;
    constructor(tex_dynamics, tex_lch_dynamics, noise_stretch, tex_stretch, blending_colour_space) {
        this.tex_dynamics = tex_dynamics;
        this.tex_lch_dynamics = [...tex_lch_dynamics];
        this.noise_stretch = [...noise_stretch];
        this.tex_stretch = [...tex_stretch];
        this.blending_colour_space = blending_colour_space;
    }
}
class BrushPreset {
    selected_brush_type = BrushType.Blobs;
    chaos_lch = [0, 0, 1];
    chaos_speed = 0.3;
    chaos = 0.7;
    dynamics = 0.3;
    stroke_opacity_dynamics = [0, 1];
    stroke_size_dynamics = [0.7, 1];
    rot_jitter = 0;
    pos_jitter = 0;
    selected_brush_texture = undefined;
    tex_dynamics = 0.3;
    tex_lch_dynamics = [0, 0, 0.02];
    noise_stretch = [1, 0.2];
    tex_stretch = [1, 0.2];
    constructor() { }
}
var BrushType;
(function (BrushType) {
    BrushType[BrushType["Blobs"] = 0] = "Blobs";
    BrushType[BrushType["Long"] = 1] = "Long";
    BrushType[BrushType["Tri"] = 2] = "Tri";
})(BrushType || (BrushType = {}));
class BrushStroke {
    brush_type;
    brush_texture;
    draw_params;
    positions = [];
    rotations = [];
    sizes = [];
    opacities = [];
    colours = [];
    idx = 0;
    constructor(brush_type, draw_params, brush_texture) {
        this.draw_params = draw_params;
        this.brush_type = brush_type;
        this.brush_texture = brush_texture;
    }
    push_stroke(position, rotation, size, opacity, colour) {
        const curr_idx = this.idx;
        this.positions.length += 2;
        this.rotations.length += 2;
        this.sizes.length += 2;
        this.opacities.length += 1;
        this.colours.length += 3;
        this.positions[curr_idx * 2] = position[0];
        this.positions[curr_idx * 2 + 1] = position[1];
        this.sizes[curr_idx * 2] = size[0];
        this.sizes[curr_idx * 2 + 1] = size[1];
        this.rotations[curr_idx * 2] = rotation[0];
        this.rotations[curr_idx * 2 + 1] = rotation[1];
        this.opacities[curr_idx] = opacity;
        this.colours[curr_idx * 3] = colour[0];
        this.colours[curr_idx * 3 + 1] = colour[1];
        this.colours[curr_idx * 3 + 2] = colour[2];
        this.idx++;
    }
}

// EXTERNAL MODULE: ./public/brush-blobs.svg
var brush_blobs = __webpack_require__(1036);
var brush_blobs_default = /*#__PURE__*/__webpack_require__.n(brush_blobs);
// EXTERNAL MODULE: ./public/brush-long.svg
var brush_long = __webpack_require__(6212);
var brush_long_default = /*#__PURE__*/__webpack_require__.n(brush_long);
// EXTERNAL MODULE: ./public/brush-triangles.svg
var brush_triangles = __webpack_require__(6504);
var brush_triangles_default = /*#__PURE__*/__webpack_require__.n(brush_triangles);
;// CONCATENATED MODULE: ./src/components/BrushTypeWidget.svelte
/* src/components/BrushTypeWidget.svelte generated by Svelte v4.0.1 */


const { Object: Object_1 } = globals;






const BrushTypeWidget_svelte_file = "src/components/BrushTypeWidget.svelte";

function BrushTypeWidget_svelte_add_css(target) {
	append_styles(target, "svelte-4hqcru", ".knob-container-container.svelte-4hqcru.svelte-4hqcru{aspect-ratio:unset;display:grid;grid-template-columns:1fr 1fr;grid-column-gap:0.4rem;grid-row-gap:0.4rem;pointer-events:all;user-select:none;cursor:pointer;overflow:visible;height:100%;width:4rem;max-width:unset;padding:0.2rem}.knob-container-container.svelte-4hqcru>.title.menu-toggle.svelte-4hqcru{user-select:none;width:100%;height:100%}.knob-container-container.svelte-4hqcru>.title.menu-toggle.svelte-4hqcru svg{fill:white;height:100%;width:100%}.knob-container-container.svelte-4hqcru>.title.menu-toggle.svelte-4hqcru svg:active{filter:invert(1);background:black}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnJ1c2hUeXBlV2lkZ2V0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEyRWtCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJydXNoVHlwZVdpZGdldC5zdmVsdGUiXX0= */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	child_ctx[8] = list;
	child_ctx[9] = i;
	return child_ctx;
}

// (4:1) {#each brush_types as brush_type, i}
function create_each_block(ctx) {
	let div;
	let html_tag;

	let raw_value = (/*i*/ ctx[9] === 0
	? (brush_blobs_default())
	: /*i*/ ctx[9] === 1
		? (brush_long_default())
		: (brush_triangles_default())) + "";

	let t;
	let i = /*i*/ ctx[9];
	let mounted;
	let dispose;
	const assign_div = () => /*div_binding*/ ctx[3](div, i);
	const unassign_div = () => /*div_binding*/ ctx[3](null, i);

	function click_handler() {
		return /*click_handler*/ ctx[4](/*brush_type*/ ctx[7], /*i*/ ctx[9]);
	}

	const block = {
		c: function create() {
			div = dom_element("div");
			html_tag = new HtmlTag(false);
			t = space();
			html_tag.a = t;
			attr_dev(div, "class", "title menu-toggle svelte-4hqcru");
			attr_dev(div, "role", "button");
			attr_dev(div, "tabindex", "0");
			set_style(div, "cursor", "pointer");
			add_location(div, BrushTypeWidget_svelte_file, 4, 2, 109);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			html_tag.m(raw_value, div);
			append_dev(div, t);
			assign_div();

			if (!mounted) {
				dispose = listen_dev(div, "click", click_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (i !== /*i*/ ctx[9]) {
				unassign_div();
				i = /*i*/ ctx[9];
				assign_div();
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			unassign_div();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(4:1) {#each brush_types as brush_type, i}",
		ctx
	});

	return block;
}

function BrushTypeWidget_svelte_create_fragment(ctx) {
	let div;
	let each_value = ensure_array_like_dev(/*brush_types*/ ctx[2]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "knob-container-container svelte-4hqcru");
			add_location(div, BrushTypeWidget_svelte_file, 2, 0, 30);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*elements, curr_brush, BrushType, brush_types, brush_blobs_icon, brush_long_icon, brush_triangles_icon*/ 7) {
				each_value = ensure_array_like_dev(/*brush_types*/ ctx[2]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BrushTypeWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function BrushTypeWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BrushTypeWidget', slots, []);
	let { curr_brush } = $$props;
	let selected_brush_type;
	let elements = [];
	let brush_types = [];

	for (let type of Object.keys(BrushType).filter(v => isNaN(Number(v)))) {
		brush_types.push(type);
		elements.length++;
	}

	const update_styles = () => {
		let k = 0;

		try {
			for (let element of elements) {
				let brush_type_int = BrushType[brush_types[k]];

				if (brush_type_int === selected_brush_type) {
					element.style.outline = '1px solid white';
					element.style.outlineOffset = '0.1rem';
				} else {
					element.style.outline = '0px solid white';
				}

				k++;
			}
		} catch(_) {
			
		}
	};

	onMount(() => {
		update_styles();
	});

	$$self.$$.on_mount.push(function () {
		if (curr_brush === undefined && !('curr_brush' in $$props || $$self.$$.bound[$$self.$$.props['curr_brush']])) {
			console.warn("<BrushTypeWidget> was created without expected prop 'curr_brush'");
		}
	});

	const writable_props = ['curr_brush'];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BrushTypeWidget> was created with unknown prop '${key}'`);
	});

	function div_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elements[i] = $$value;
			$$invalidate(1, elements);
		});
	}

	const click_handler = (brush_type, i) => {
		$$invalidate(0, curr_brush.selected_brush_type = BrushType[brush_type], curr_brush);
		let k = 0;

		for (let element of elements) {
			if (k === i) {
				element.style.outline = '1px solid white';
				element.style.outlineOffset = '0rem';
			} else {
				element.style.outline = '0px solid white';
			}

			k++;
		}
	};

	$$self.$$set = $$props => {
		if ('curr_brush' in $$props) $$invalidate(0, curr_brush = $$props.curr_brush);
	};

	$$self.$capture_state = () => ({
		BrushPreset: BrushPreset,
		BrushType: BrushType,
		onMount: onMount,
		brush_blobs_icon: (brush_blobs_default()),
		brush_long_icon: (brush_long_default()),
		brush_triangles_icon: (brush_triangles_default()),
		curr_brush,
		selected_brush_type,
		elements,
		brush_types,
		update_styles
	});

	$$self.$inject_state = $$props => {
		if ('curr_brush' in $$props) $$invalidate(0, curr_brush = $$props.curr_brush);
		if ('selected_brush_type' in $$props) selected_brush_type = $$props.selected_brush_type;
		if ('elements' in $$props) $$invalidate(1, elements = $$props.elements);
		if ('brush_types' in $$props) $$invalidate(2, brush_types = $$props.brush_types);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*curr_brush*/ 1) {
			$: {
				selected_brush_type = curr_brush.selected_brush_type;
				update_styles();
			}
		}
	};

	return [curr_brush, elements, brush_types, div_binding, click_handler];
}

class BrushTypeWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, BrushTypeWidget_svelte_instance, BrushTypeWidget_svelte_create_fragment, safe_not_equal, { curr_brush: 0 }, BrushTypeWidget_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BrushTypeWidget",
			options,
			id: BrushTypeWidget_svelte_create_fragment.name
		});
	}

	get curr_brush() {
		return this.$$.ctx[0];
	}

	set curr_brush(curr_brush) {
		this.$$set({ curr_brush });
		scheduler_flush();
	}
}

/* harmony default export */ const BrushTypeWidget_svelte = (BrushTypeWidget);
;// CONCATENATED MODULE: ./src/components/BrushPresetWidget.svelte
/* src/components/BrushPresetWidget.svelte generated by Svelte v4.0.1 */





const BrushPresetWidget_svelte_file = "src/components/BrushPresetWidget.svelte";

function BrushPresetWidget_svelte_add_css(target) {
	append_styles(target, "svelte-1v2tr2u", ".knob-container-container.svelte-1v2tr2u.svelte-1v2tr2u{aspect-ratio:unset;display:grid;pointer-events:all;user-select:none;cursor:pointer;grid-template-columns:1fr 1fr 1fr;overflow:hidden;height:100%;width:4rem;margin:0;margin-top:auto;margin-bottom:auto;max-width:unset;margin-right:1rem}.knob-container-container.svelte-1v2tr2u>.title.menu-toggle.svelte-1v2tr2u{background:white;color:black;width:100%;height:100%}.knob-container-container.svelte-1v2tr2u>.title.svelte-1v2tr2u{padding:0rem;font-size:0.8rem !important;margin:0rem;color:white;text-align:center;font-weight:bolder;user-select:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnJ1c2hQcmVzZXRXaWRnZXQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXFEa0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQnJ1c2hQcmVzZXRXaWRnZXQuc3ZlbHRlIl19 */");
}

function BrushPresetWidget_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[6] = list;
	child_ctx[7] = i;
	return child_ctx;
}

// (28:2) {#each brush_presets as preset, i}
function BrushPresetWidget_svelte_create_each_block(ctx) {
	let div;
	let i = /*i*/ ctx[7];
	let mounted;
	let dispose;
	const assign_div = () => /*div_binding*/ ctx[3](div, i);
	const unassign_div = () => /*div_binding*/ ctx[3](null, i);

	function click_handler() {
		return /*click_handler*/ ctx[4](/*preset*/ ctx[5], /*i*/ ctx[7]);
	}

	const block = {
		c: function create() {
			div = dom_element("div");
			div.textContent = `${/*i*/ ctx[7].toString()}`;
			attr_dev(div, "class", "title menu-toggle svelte-1v2tr2u");
			attr_dev(div, "role", "button");
			attr_dev(div, "tabindex", "0");
			set_style(div, "cursor", "pointer");
			add_location(div, BrushPresetWidget_svelte_file, 31, 4, 703);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			assign_div();

			if (!mounted) {
				dispose = listen_dev(div, "click", click_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (i !== /*i*/ ctx[7]) {
				unassign_div();
				i = /*i*/ ctx[7];
				assign_div();
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			unassign_div();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BrushPresetWidget_svelte_create_each_block.name,
		type: "each",
		source: "(28:2) {#each brush_presets as preset, i}",
		ctx
	});

	return block;
}

function BrushPresetWidget_svelte_create_fragment(ctx) {
	let div;
	let each_value = ensure_array_like_dev(/*brush_presets*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = BrushPresetWidget_svelte_create_each_block(BrushPresetWidget_svelte_get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "knob-container-container svelte-1v2tr2u");
			add_location(div, BrushPresetWidget_svelte_file, 29, 0, 623);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*elements, selected_brush_preset, brush_presets*/ 7) {
				each_value = ensure_array_like_dev(/*brush_presets*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = BrushPresetWidget_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = BrushPresetWidget_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BrushPresetWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function BrushPresetWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BrushPresetWidget', slots, []);
	let { brush_presets } = $$props;
	let { selected_brush_preset } = $$props;
	let elements = [];

	for (let preset of brush_presets) {
		elements.length++;
	}

	onMount(() => {
		let k = 0;

		for (let element of elements) {
			if (selected_brush_preset === brush_presets[k]) {
				element.style.outline = '1px solid white';
				element.style.outlineOffset = '0.1rem';
			} else {
				element.style.outline = '0px solid white';
			}

			k++;
		}
	});

	$$self.$$.on_mount.push(function () {
		if (brush_presets === undefined && !('brush_presets' in $$props || $$self.$$.bound[$$self.$$.props['brush_presets']])) {
			console.warn("<BrushPresetWidget> was created without expected prop 'brush_presets'");
		}

		if (selected_brush_preset === undefined && !('selected_brush_preset' in $$props || $$self.$$.bound[$$self.$$.props['selected_brush_preset']])) {
			console.warn("<BrushPresetWidget> was created without expected prop 'selected_brush_preset'");
		}
	});

	const writable_props = ['brush_presets', 'selected_brush_preset'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BrushPresetWidget> was created with unknown prop '${key}'`);
	});

	function div_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elements[i] = $$value;
			$$invalidate(2, elements);
		});
	}

	const click_handler = (preset, i) => {
		$$invalidate(0, selected_brush_preset = preset);
		let k = 0;

		for (let element of elements) {
			if (k === i) {
				element.style.outline = '1px solid white';
				element.style.outlineOffset = '0.1rem';
			} else {
				element.style.outline = '0px solid white';
			}

			k++;
		}
	};

	$$self.$$set = $$props => {
		if ('brush_presets' in $$props) $$invalidate(1, brush_presets = $$props.brush_presets);
		if ('selected_brush_preset' in $$props) $$invalidate(0, selected_brush_preset = $$props.selected_brush_preset);
	};

	$$self.$capture_state = () => ({
		BrushPreset: BrushPreset,
		onMount: onMount,
		brush_presets,
		selected_brush_preset,
		elements
	});

	$$self.$inject_state = $$props => {
		if ('brush_presets' in $$props) $$invalidate(1, brush_presets = $$props.brush_presets);
		if ('selected_brush_preset' in $$props) $$invalidate(0, selected_brush_preset = $$props.selected_brush_preset);
		if ('elements' in $$props) $$invalidate(2, elements = $$props.elements);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [selected_brush_preset, brush_presets, elements, div_binding, click_handler];
}

class BrushPresetWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			BrushPresetWidget_svelte_instance,
			BrushPresetWidget_svelte_create_fragment,
			safe_not_equal,
			{
				brush_presets: 1,
				selected_brush_preset: 0
			},
			BrushPresetWidget_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BrushPresetWidget",
			options,
			id: BrushPresetWidget_svelte_create_fragment.name
		});
	}

	get brush_presets() {
		return this.$$.ctx[1];
	}

	set brush_presets(brush_presets) {
		this.$$set({ brush_presets });
		scheduler_flush();
	}

	get selected_brush_preset() {
		return this.$$.ctx[0];
	}

	set selected_brush_preset(selected_brush_preset) {
		this.$$set({ selected_brush_preset });
		scheduler_flush();
	}
}

/* harmony default export */ const BrushPresetWidget_svelte = (BrushPresetWidget);
// EXTERNAL MODULE: ./public/undo.svg
var public_undo = __webpack_require__(4897);
var undo_default = /*#__PURE__*/__webpack_require__.n(public_undo);
// EXTERNAL MODULE: ./public/redo.svg
var public_redo = __webpack_require__(6056);
var redo_default = /*#__PURE__*/__webpack_require__.n(public_redo);
;// CONCATENATED MODULE: ./src/components/UndoRedoWidget.svelte
/* src/components/UndoRedoWidget.svelte generated by Svelte v4.0.1 */





const UndoRedoWidget_svelte_file = "src/components/UndoRedoWidget.svelte";

function UndoRedoWidget_svelte_add_css(target) {
	append_styles(target, "svelte-14y6avi", ".knob-container.svelte-14y6avi{cursor:pointer;aspect-ratio:1/1;height:100%;margin-left:0.5rem;margin-right:0.5rem;margin-bottom:auto;margin-top:auto;pointer-events:all;user-select:none;width:unset}.knob-container.svelte-14y6avi:hover{cursor:pointer}.knob.svelte-14y6avi{display:block;aspect-ratio:1/1;height:100%;padding:0;color:var(--text-color);fill:white;width:unset;max-width:unset;transform-origin:50% 50%}.knob.svelte-14y6avi:active{filter:invert(1);background:black}.knob.svelte-14y6avi svg{fill:white;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVW5kb1JlZG9XaWRnZXQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTZCa0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVW5kb1JlZG9XaWRnZXQuc3ZlbHRlIl19 */");
}

function UndoRedoWidget_svelte_create_fragment(ctx) {
	let div1;
	let div0;
	let t;
	let div3;
	let div2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			t = space();
			div3 = dom_element("div");
			div2 = dom_element("div");
			attr_dev(div0, "class", "knob svelte-14y6avi");
			add_location(div0, UndoRedoWidget_svelte_file, 16, 4, 243);
			attr_dev(div1, "class", "knob-container svelte-14y6avi");
			add_location(div1, UndoRedoWidget_svelte_file, 15, 2, 210);
			attr_dev(div2, "class", "knob svelte-14y6avi");
			add_location(div2, UndoRedoWidget_svelte_file, 21, 4, 362);
			attr_dev(div3, "class", "knob-container svelte-14y6avi");
			add_location(div3, UndoRedoWidget_svelte_file, 20, 2, 329);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			div0.innerHTML = (undo_default());
			insert_dev(target, t, anchor);
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			div2.innerHTML = (redo_default());

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*click_handler*/ ctx[2], false, false, false, false),
					listen_dev(div2, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: utils_noop,
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
				detach_dev(t);
				detach_dev(div3);
			}

			mounted = false;
			utils_run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: UndoRedoWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function UndoRedoWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('UndoRedoWidget', slots, []);
	let { redo } = $$props;
	let { undo } = $$props;

	$$self.$$.on_mount.push(function () {
		if (redo === undefined && !('redo' in $$props || $$self.$$.bound[$$self.$$.props['redo']])) {
			console.warn("<UndoRedoWidget> was created without expected prop 'redo'");
		}

		if (undo === undefined && !('undo' in $$props || $$self.$$.bound[$$self.$$.props['undo']])) {
			console.warn("<UndoRedoWidget> was created without expected prop 'undo'");
		}
	});

	const writable_props = ['redo', 'undo'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UndoRedoWidget> was created with unknown prop '${key}'`);
	});

	const click_handler = () => undo();
	const click_handler_1 = () => redo();

	$$self.$$set = $$props => {
		if ('redo' in $$props) $$invalidate(0, redo = $$props.redo);
		if ('undo' in $$props) $$invalidate(1, undo = $$props.undo);
	};

	$$self.$capture_state = () => ({ undoIcon: (undo_default()), redoIcon: (redo_default()), redo, undo });

	$$self.$inject_state = $$props => {
		if ('redo' in $$props) $$invalidate(0, redo = $$props.redo);
		if ('undo' in $$props) $$invalidate(1, undo = $$props.undo);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [redo, undo, click_handler, click_handler_1];
}

class UndoRedoWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, UndoRedoWidget_svelte_instance, UndoRedoWidget_svelte_create_fragment, safe_not_equal, { redo: 0, undo: 1 }, UndoRedoWidget_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UndoRedoWidget",
			options,
			id: UndoRedoWidget_svelte_create_fragment.name
		});
	}

	get redo() {
		return this.$$.ctx[0];
	}

	set redo(redo) {
		this.$$set({ redo });
		scheduler_flush();
	}

	get undo() {
		return this.$$.ctx[1];
	}

	set undo(undo) {
		this.$$set({ undo });
		scheduler_flush();
	}
}

/* harmony default export */ const UndoRedoWidget_svelte = (UndoRedoWidget);
// EXTERNAL MODULE: ./public/solve.svg
var solve = __webpack_require__(4878);
var solve_default = /*#__PURE__*/__webpack_require__.n(solve);
// EXTERNAL MODULE: ./public/launch.svg
var launch = __webpack_require__(2485);
var launch_default = /*#__PURE__*/__webpack_require__.n(launch);
// EXTERNAL MODULE: ./public/resize.svg
var resize = __webpack_require__(1878);
var resize_default = /*#__PURE__*/__webpack_require__.n(resize);
// EXTERNAL MODULE: ./public/forbid.svg
var forbid = __webpack_require__(4461);
var forbid_default = /*#__PURE__*/__webpack_require__.n(forbid);
// EXTERNAL MODULE: ./public/ok.svg
var ok = __webpack_require__(5713);
var ok_default = /*#__PURE__*/__webpack_require__.n(ok);
// EXTERNAL MODULE: ./public/capture.svg
var capture = __webpack_require__(6445);
var capture_default = /*#__PURE__*/__webpack_require__.n(capture);
// EXTERNAL MODULE: ./public/download.svg
var download = __webpack_require__(8028);
var download_default = /*#__PURE__*/__webpack_require__.n(download);
// EXTERNAL MODULE: ./public/time.svg
var time = __webpack_require__(8179);
var time_default = /*#__PURE__*/__webpack_require__.n(time);
// EXTERNAL MODULE: ./node_modules/dropbox/dist/Dropbox-sdk.min.js
var Dropbox_sdk_min = __webpack_require__(1956);
;// CONCATENATED MODULE: ./node_modules/@firebase/util/dist/index.esm2017.js
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.
 */
const CONSTANTS = {
    /**
     * @define {boolean} Whether this is the client Node.js SDK.
     */
    NODE_CLIENT: false,
    /**
     * @define {boolean} Whether this is the Admin Node.js SDK.
     */
    NODE_ADMIN: false,
    /**
     * Firebase SDK Version
     */
    SDK_VERSION: '${JSCORE_VERSION}'
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Throws an error if the provided assertion is falsy
 */
const index_esm2017_assert = function (assertion, message) {
    if (!assertion) {
        throw assertionError(message);
    }
};
/**
 * Returns an Error object suitable for throwing.
 */
const assertionError = function (message) {
    return new Error('Firebase Database (' +
        CONSTANTS.SDK_VERSION +
        ') INTERNAL ASSERT FAILED: ' +
        message);
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const stringToByteArray$1 = function (str) {
    // TODO(user): Use native implementations if/when available
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if ((c & 0xfc00) === 0xd800 &&
            i + 1 < str.length &&
            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
            // Surrogate Pair
            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return out;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param bytes Array of numbers representing characters.
 * @return Stringification of the array.
 */
const byteArrayToString = function (bytes) {
    // TODO(user): Use native implementations if/when available
    const out = [];
    let pos = 0, c = 0;
    while (pos < bytes.length) {
        const c1 = bytes[pos++];
        if (c1 < 128) {
            out[c++] = String.fromCharCode(c1);
        }
        else if (c1 > 191 && c1 < 224) {
            const c2 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
        }
        else if (c1 > 239 && c1 < 365) {
            // Surrogate Pair
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            const c4 = bytes[pos++];
            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -
                0x10000;
            out[c++] = String.fromCharCode(0xd800 + (u >> 10));
            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));
        }
        else {
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
        }
    }
    return out.join('');
};
// We define it as an object literal instead of a class because a class compiled down to es5 can't
// be treeshaked. https://github.com/rollup/rollup/issues/1691
// Static lookup maps, lazily populated by init_()
const base64 = {
    /**
     * Maps bytes to characters.
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     */
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + '+/=';
    },
    /**
     * Our websafe alphabet.
     */
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + '-_.';
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     */
    HAS_NATIVE_SUPPORT: typeof atob === 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeByteArray(input, webSafe) {
        if (!Array.isArray(input)) {
            throw Error('encodeByteArray takes an array as a parameter');
        }
        this.init_();
        const byteToCharMap = webSafe
            ? this.byteToCharMapWebSafe_
            : this.byteToCharMap_;
        const output = [];
        for (let i = 0; i < input.length; i += 3) {
            const byte1 = input[i];
            const haveByte2 = i + 1 < input.length;
            const byte2 = haveByte2 ? input[i + 1] : 0;
            const haveByte3 = i + 2 < input.length;
            const byte3 = haveByte3 ? input[i + 2] : 0;
            const outByte1 = byte1 >> 2;
            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);
            let outByte4 = byte3 & 0x3f;
            if (!haveByte3) {
                outByte4 = 64;
                if (!haveByte2) {
                    outByte3 = 64;
                }
            }
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join('');
    },
    /**
     * Base64-encode a string.
     *
     * @param input A string to encode.
     * @param webSafe If true, we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeString(input, webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
            return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray$1(input), webSafe);
    },
    /**
     * Base64-decode a string.
     *
     * @param input to decode.
     * @param webSafe True if we should use the
     *     alternative alphabet.
     * @return string representing the decoded value.
     */
    decodeString(input, webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
            return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param input Input to decode.
     * @param webSafe True if we should use the web-safe alphabet.
     * @return bytes representing the decoded value.
     */
    decodeStringToByteArray(input, webSafe) {
        this.init_();
        const charToByteMap = webSafe
            ? this.charToByteMapWebSafe_
            : this.charToByteMap_;
        const output = [];
        for (let i = 0; i < input.length;) {
            const byte1 = charToByteMap[input.charAt(i++)];
            const haveByte2 = i < input.length;
            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            const haveByte3 = i < input.length;
            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            const haveByte4 = i < input.length;
            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
                throw new DecodeBase64StringError();
            }
            const outByte1 = (byte1 << 2) | (byte2 >> 4);
            output.push(outByte1);
            if (byte3 !== 64) {
                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);
                output.push(outByte2);
                if (byte4 !== 64) {
                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;
                    output.push(outByte3);
                }
            }
        }
        return output;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_() {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {};
            this.charToByteMap_ = {};
            this.byteToCharMapWebSafe_ = {};
            this.charToByteMapWebSafe_ = {};
            // We want quick mappings back and forth, so we precompute two maps.
            for (let i = 0; i < this.ENCODED_VALS.length; i++) {
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) {
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
                }
            }
        }
    }
};
/**
 * An error encountered while decoding base64 string.
 */
class DecodeBase64StringError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'DecodeBase64StringError';
    }
}
/**
 * URL-safe base64 encoding
 */
const base64Encode = function (str) {
    const utf8Bytes = stringToByteArray$1(str);
    return base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 encoding (without "." padding in the end).
 * e.g. Used in JSON Web Token (JWT) parts.
 */
const base64urlEncodeWithoutPadding = function (str) {
    // Use base64url encoding and remove padding in the end (dot characters).
    return base64Encode(str).replace(/\./g, '');
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param str To be decoded
 * @return Decoded result, if possible
 */
const base64Decode = function (str) {
    try {
        return base64.decodeString(str, true);
    }
    catch (e) {
        console.error('base64Decode failed: ', e);
    }
    return null;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Do a deep-copy of basic JavaScript Objects or Arrays.
 */
function deepCopy(value) {
    return deepExtend(undefined, value);
}
/**
 * Copy properties from source to target (recursively allows extension
 * of Objects and Arrays).  Scalar values in the target are over-written.
 * If target is undefined, an object of the appropriate type will be created
 * (and returned).
 *
 * We recursively copy all child properties of plain Objects in the source- so
 * that namespace- like dictionaries are merged.
 *
 * Note that the target can be a function, in which case the properties in
 * the source Object are copied onto it as static properties of the Function.
 *
 * Note: we don't merge __proto__ to prevent prototype pollution
 */
function deepExtend(target, source) {
    if (!(source instanceof Object)) {
        return source;
    }
    switch (source.constructor) {
        case Date:
            // Treat Dates like scalars; if the target date object had any child
            // properties - they will be lost!
            const dateValue = source;
            return new Date(dateValue.getTime());
        case Object:
            if (target === undefined) {
                target = {};
            }
            break;
        case Array:
            // Always copy the array source and overwrite the target.
            target = [];
            break;
        default:
            // Not a plain Object - treat it as a scalar.
            return source;
    }
    for (const prop in source) {
        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202
        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
            continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
    }
    return target;
}
function isValidKey(key) {
    return key !== '__proto__';
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Polyfill for `globalThis` object.
 * @returns the `globalThis` object for the given environment.
 * @public
 */
function getGlobal() {
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof __webpack_require__.g !== 'undefined') {
        return __webpack_require__.g;
    }
    throw new Error('Unable to locate global object.');
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;
/**
 * Attempt to read defaults from a JSON string provided to
 * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in
 * process(.)env(.)__FIREBASE_DEFAULTS_PATH__
 * The dots are in parens because certain compilers (Vite?) cannot
 * handle seeing that variable in comments.
 * See https://github.com/firebase/firebase-js-sdk/issues/6838
 */
const getDefaultsFromEnvVariable = () => {
    if (typeof process === 'undefined' || typeof process.env === 'undefined') {
        return;
    }
    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;
    if (defaultsJsonString) {
        return JSON.parse(defaultsJsonString);
    }
};
const getDefaultsFromCookie = () => {
    if (typeof document === 'undefined') {
        return;
    }
    let match;
    try {
        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
    }
    catch (e) {
        // Some environments such as Angular Universal SSR have a
        // `document` object but error on accessing `document.cookie`.
        return;
    }
    const decoded = match && base64Decode(match[1]);
    return decoded && JSON.parse(decoded);
};
/**
 * Get the __FIREBASE_DEFAULTS__ object. It checks in order:
 * (1) if such an object exists as a property of `globalThis`
 * (2) if such an object was provided on a shell environment variable
 * (3) if such an object exists in a cookie
 * @public
 */
const getDefaults = () => {
    try {
        return (getDefaultsFromGlobal() ||
            getDefaultsFromEnvVariable() ||
            getDefaultsFromCookie());
    }
    catch (e) {
        /**
         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due
         * to any environment case we have not accounted for. Log to
         * info instead of swallowing so we can find these unknown cases
         * and add paths for them if needed.
         */
        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
        return;
    }
};
/**
 * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object
 * for the given product.
 * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available
 * @public
 */
const getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };
/**
 * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object
 * for the given product.
 * @returns a pair of hostname and port like `["::1", 4000]` if available
 * @public
 */
const getDefaultEmulatorHostnameAndPort = (productName) => {
    const host = getDefaultEmulatorHost(productName);
    if (!host) {
        return undefined;
    }
    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.
    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {
        throw new Error(`Invalid host ${host} with no separate hostname and port!`);
    }
    // eslint-disable-next-line no-restricted-globals
    const port = parseInt(host.substring(separatorIndex + 1), 10);
    if (host[0] === '[') {
        // Bracket-quoted `[ipv6addr]:port` => return "ipv6addr" (without brackets).
        return [host.substring(1, separatorIndex - 1), port];
    }
    else {
        return [host.substring(0, separatorIndex), port];
    }
};
/**
 * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.
 * @public
 */
const getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };
/**
 * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties
 * prefixed by "_")
 * @public
 */
const getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Deferred {
    constructor() {
        this.reject = () => { };
        this.resolve = () => { };
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    /**
     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
     * and returns a node-style callback which will resolve or reject the Deferred's promise.
     */
    wrapCallback(callback) {
        return (error, value) => {
            if (error) {
                this.reject(error);
            }
            else {
                this.resolve(value);
            }
            if (typeof callback === 'function') {
                // Attaching noop handler just in case developer wasn't expecting
                // promises
                this.promise.catch(() => { });
                // Some of our callbacks don't expect a value and our own tests
                // assert that the parameter length is 1
                if (callback.length === 1) {
                    callback(error);
                }
                else {
                    callback(error, value);
                }
            }
        };
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createMockUserToken(token, projectId) {
    if (token.uid) {
        throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
    }
    // Unsecured JWTs use "none" as the algorithm.
    const header = {
        alg: 'none',
        type: 'JWT'
    };
    const project = projectId || 'demo-project';
    const iat = token.iat || 0;
    const sub = token.sub || token.user_id;
    if (!sub) {
        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
    }
    const payload = Object.assign({ 
        // Set all required fields to decent defaults
        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {
            sign_in_provider: 'custom',
            identities: {}
        } }, token);
    // Unsecured JWTs use the empty string as a signature.
    const signature = '';
    return [
        base64urlEncodeWithoutPadding(JSON.stringify(header)),
        base64urlEncodeWithoutPadding(JSON.stringify(payload)),
        signature
    ].join('.');
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns navigator.userAgent string or '' if it's not defined.
 * @return user agent string
 */
function index_esm2017_getUA() {
    if (typeof navigator !== 'undefined' &&
        typeof navigator['userAgent'] === 'string') {
        return navigator['userAgent'];
    }
    else {
        return '';
    }
}
/**
 * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
 *
 * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap
 * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally
 * wait for a callback.
 */
function isMobileCordova() {
    return (typeof window !== 'undefined' &&
        // @ts-ignore Setting up an broadly applicable index signature for Window
        // just to deal with this case would probably be a bad idea.
        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&
        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(index_esm2017_getUA()));
}
/**
 * Detect Node.js.
 *
 * @return true if Node.js environment is detected or specified.
 */
// Node detection logic from: https://github.com/iliakan/detect-node/
function isNode() {
    var _a;
    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;
    if (forceEnvironment === 'node') {
        return true;
    }
    else if (forceEnvironment === 'browser') {
        return false;
    }
    try {
        return (Object.prototype.toString.call(__webpack_require__.g.process) === '[object process]');
    }
    catch (e) {
        return false;
    }
}
/**
 * Detect Browser Environment
 */
function isBrowser() {
    return typeof self === 'object' && self.self === self;
}
function isBrowserExtension() {
    const runtime = typeof chrome === 'object'
        ? chrome.runtime
        : typeof browser === 'object'
            ? browser.runtime
            : undefined;
    return typeof runtime === 'object' && runtime.id !== undefined;
}
/**
 * Detect React Native.
 *
 * @return true if ReactNative environment is detected.
 */
function isReactNative() {
    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');
}
/** Detects Electron apps. */
function isElectron() {
    return index_esm2017_getUA().indexOf('Electron/') >= 0;
}
/** Detects Internet Explorer. */
function isIE() {
    const ua = index_esm2017_getUA();
    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
}
/** Detects Universal Windows Platform apps. */
function isUWP() {
    return index_esm2017_getUA().indexOf('MSAppHost/') >= 0;
}
/**
 * Detect whether the current SDK build is the Node version.
 *
 * @return true if it's the Node SDK build.
 */
function isNodeSdk() {
    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
}
/** Returns true if we are running in Safari. */
function isSafari() {
    return (!isNode() &&
        navigator.userAgent.includes('Safari') &&
        !navigator.userAgent.includes('Chrome'));
}
/**
 * This method checks if indexedDB is supported by current browser/service worker context
 * @return true if indexedDB is supported by current browser/service worker context
 */
function isIndexedDBAvailable() {
    try {
        return typeof indexedDB === 'object';
    }
    catch (e) {
        return false;
    }
}
/**
 * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject
 * if errors occur during the database open operation.
 *
 * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox
 * private browsing)
 */
function validateIndexedDBOpenable() {
    return new Promise((resolve, reject) => {
        try {
            let preExist = true;
            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';
            const request = self.indexedDB.open(DB_CHECK_NAME);
            request.onsuccess = () => {
                request.result.close();
                // delete database only when it doesn't pre-exist
                if (!preExist) {
                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);
                }
                resolve(true);
            };
            request.onupgradeneeded = () => {
                preExist = false;
            };
            request.onerror = () => {
                var _a;
                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');
            };
        }
        catch (error) {
            reject(error);
        }
    });
}
/**
 *
 * This method checks whether cookie is enabled within current browser
 * @return true if cookie is enabled within current browser
 */
function areCookiesEnabled() {
    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {
        return false;
    }
    return true;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Standardized Firebase Error.
 *
 * Usage:
 *
 *   // Typescript string literals for type-safe codes
 *   type Err =
 *     'unknown' |
 *     'object-not-found'
 *     ;
 *
 *   // Closure enum for type-safe error codes
 *   // at-enum {string}
 *   var Err = {
 *     UNKNOWN: 'unknown',
 *     OBJECT_NOT_FOUND: 'object-not-found',
 *   }
 *
 *   let errors: Map<Err, string> = {
 *     'generic-error': "Unknown error",
 *     'file-not-found': "Could not find file: {$file}",
 *   };
 *
 *   // Type-safe function - must pass a valid error code as param.
 *   let error = new ErrorFactory<Err>('service', 'Service', errors);
 *
 *   ...
 *   throw error.create(Err.GENERIC);
 *   ...
 *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});
 *   ...
 *   // Service: Could not file file: foo.txt (service/file-not-found).
 *
 *   catch (e) {
 *     assert(e.message === "Could not find file: foo.txt.");
 *     if ((e as FirebaseError)?.code === 'service/file-not-found') {
 *       console.log("Could not read file: " + e['file']);
 *     }
 *   }
 */
const ERROR_NAME = 'FirebaseError';
// Based on code from:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
class FirebaseError extends Error {
    constructor(
    /** The error code for this error. */
    code, message, 
    /** Custom data for this error. */
    customData) {
        super(message);
        this.code = code;
        this.customData = customData;
        /** The custom name for all FirebaseErrors. */
        this.name = ERROR_NAME;
        // Fix For ES5
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, FirebaseError.prototype);
        // Maintains proper stack trace for where our error was thrown.
        // Only available on V8.
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ErrorFactory.prototype.create);
        }
    }
}
class ErrorFactory {
    constructor(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
    }
    create(code, ...data) {
        const customData = data[0] || {};
        const fullCode = `${this.service}/${code}`;
        const template = this.errors[code];
        const message = template ? replaceTemplate(template, customData) : 'Error';
        // Service Name: Error message (service/code).
        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
        const error = new FirebaseError(fullCode, fullMessage, customData);
        return error;
    }
}
function replaceTemplate(template, data) {
    return template.replace(PATTERN, (_, key) => {
        const value = data[key];
        return value != null ? String(value) : `<${key}?>`;
    });
}
const PATTERN = /\{\$([^}]+)}/g;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Evaluates a JSON string into a javascript object.
 *
 * @param {string} str A string containing JSON.
 * @return {*} The javascript object representing the specified JSON.
 */
function jsonEval(str) {
    return JSON.parse(str);
}
/**
 * Returns JSON representing a javascript object.
 * @param {*} data Javascript object to be stringified.
 * @return {string} The JSON contents of the object.
 */
function stringify(data) {
    return JSON.stringify(data);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Decodes a Firebase auth. token into constituent parts.
 *
 * Notes:
 * - May return with invalid / incomplete claims if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const decode = function (token) {
    let header = {}, claims = {}, data = {}, signature = '';
    try {
        const parts = token.split('.');
        header = jsonEval(base64Decode(parts[0]) || '');
        claims = jsonEval(base64Decode(parts[1]) || '');
        signature = parts[2];
        data = claims['d'] || {};
        delete claims['d'];
    }
    catch (e) { }
    return {
        header,
        claims,
        data,
        signature
    };
};
/**
 * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the
 * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const isValidTimestamp = function (token) {
    const claims = decode(token).claims;
    const now = Math.floor(new Date().getTime() / 1000);
    let validSince = 0, validUntil = 0;
    if (typeof claims === 'object') {
        if (claims.hasOwnProperty('nbf')) {
            validSince = claims['nbf'];
        }
        else if (claims.hasOwnProperty('iat')) {
            validSince = claims['iat'];
        }
        if (claims.hasOwnProperty('exp')) {
            validUntil = claims['exp'];
        }
        else {
            // token will expire after 24h by default
            validUntil = validSince + 86400;
        }
    }
    return (!!now &&
        !!validSince &&
        !!validUntil &&
        now >= validSince &&
        now <= validUntil);
};
/**
 * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.
 *
 * Notes:
 * - May return null if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const issuedAtTime = function (token) {
    const claims = decode(token).claims;
    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {
        return claims['iat'];
    }
    return null;
};
/**
 * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const isValidFormat = function (token) {
    const decoded = decode(token), claims = decoded.claims;
    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');
};
/**
 * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const isAdmin = function (token) {
    const claims = decode(token).claims;
    return typeof claims === 'object' && claims['admin'] === true;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function contains(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
function safeGet(obj, key) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return obj[key];
    }
    else {
        return undefined;
    }
}
function isEmpty(obj) {
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            return false;
        }
    }
    return true;
}
function map(obj, fn, contextObj) {
    const res = {};
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            res[key] = fn.call(contextObj, obj[key], key, obj);
        }
    }
    return res;
}
/**
 * Deep equal two objects. Support Arrays and Objects.
 */
function deepEqual(a, b) {
    if (a === b) {
        return true;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    for (const k of aKeys) {
        if (!bKeys.includes(k)) {
            return false;
        }
        const aProp = a[k];
        const bProp = b[k];
        if (isObject(aProp) && isObject(bProp)) {
            if (!deepEqual(aProp, bProp)) {
                return false;
            }
        }
        else if (aProp !== bProp) {
            return false;
        }
    }
    for (const k of bKeys) {
        if (!aKeys.includes(k)) {
            return false;
        }
    }
    return true;
}
function isObject(thing) {
    return thing !== null && typeof thing === 'object';
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Rejects if the given promise doesn't resolve in timeInMS milliseconds.
 * @internal
 */
function promiseWithTimeout(promise, timeInMS = 2000) {
    const deferredPromise = new Deferred();
    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);
    promise.then(deferredPromise.resolve, deferredPromise.reject);
    return deferredPromise.promise;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a
 * params object (e.g. {arg: 'val', arg2: 'val2'})
 * Note: You must prepend it with ? when adding it to a URL.
 */
function index_esm2017_querystring(querystringParams) {
    const params = [];
    for (const [key, value] of Object.entries(querystringParams)) {
        if (Array.isArray(value)) {
            value.forEach(arrayVal => {
                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));
            });
        }
        else {
            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        }
    }
    return params.length ? '&' + params.join('&') : '';
}
/**
 * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object
 * (e.g. {arg: 'val', arg2: 'val2'})
 */
function querystringDecode(querystring) {
    const obj = {};
    const tokens = querystring.replace(/^\?/, '').split('&');
    tokens.forEach(token => {
        if (token) {
            const [key, value] = token.split('=');
            obj[decodeURIComponent(key)] = decodeURIComponent(value);
        }
    });
    return obj;
}
/**
 * Extract the query string part of a URL, including the leading question mark (if present).
 */
function extractQuerystring(url) {
    const queryStart = url.indexOf('?');
    if (!queryStart) {
        return '';
    }
    const fragmentStart = url.indexOf('#', queryStart);
    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */
/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @final
 * @struct
 */
class Sha1 {
    constructor() {
        /**
         * Holds the previous values of accumulated variables a-e in the compress_
         * function.
         * @private
         */
        this.chain_ = [];
        /**
         * A buffer holding the partially computed hash result.
         * @private
         */
        this.buf_ = [];
        /**
         * An array of 80 bytes, each a part of the message to be hashed.  Referred to
         * as the message schedule in the docs.
         * @private
         */
        this.W_ = [];
        /**
         * Contains data needed to pad messages less than 64 bytes.
         * @private
         */
        this.pad_ = [];
        /**
         * @private {number}
         */
        this.inbuf_ = 0;
        /**
         * @private {number}
         */
        this.total_ = 0;
        this.blockSize = 512 / 8;
        this.pad_[0] = 128;
        for (let i = 1; i < this.blockSize; ++i) {
            this.pad_[i] = 0;
        }
        this.reset();
    }
    reset() {
        this.chain_[0] = 0x67452301;
        this.chain_[1] = 0xefcdab89;
        this.chain_[2] = 0x98badcfe;
        this.chain_[3] = 0x10325476;
        this.chain_[4] = 0xc3d2e1f0;
        this.inbuf_ = 0;
        this.total_ = 0;
    }
    /**
     * Internal compress helper function.
     * @param buf Block to compress.
     * @param offset Offset of the block in the buffer.
     * @private
     */
    compress_(buf, offset) {
        if (!offset) {
            offset = 0;
        }
        const W = this.W_;
        // get 16 big endian words
        if (typeof buf === 'string') {
            for (let i = 0; i < 16; i++) {
                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS
                // have a bug that turns the post-increment ++ operator into pre-increment
                // during JIT compilation.  We have code that depends heavily on SHA-1 for
                // correctness and which is affected by this bug, so I've removed all uses
                // of post-increment ++ in which the result value is used.  We can revert
                // this change once the Safari bug
                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
                // most clients have been updated.
                W[i] =
                    (buf.charCodeAt(offset) << 24) |
                        (buf.charCodeAt(offset + 1) << 16) |
                        (buf.charCodeAt(offset + 2) << 8) |
                        buf.charCodeAt(offset + 3);
                offset += 4;
            }
        }
        else {
            for (let i = 0; i < 16; i++) {
                W[i] =
                    (buf[offset] << 24) |
                        (buf[offset + 1] << 16) |
                        (buf[offset + 2] << 8) |
                        buf[offset + 3];
                offset += 4;
            }
        }
        // expand to 80 words
        for (let i = 16; i < 80; i++) {
            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;
        }
        let a = this.chain_[0];
        let b = this.chain_[1];
        let c = this.chain_[2];
        let d = this.chain_[3];
        let e = this.chain_[4];
        let f, k;
        // TODO(user): Try to unroll this loop to speed up the computation.
        for (let i = 0; i < 80; i++) {
            if (i < 40) {
                if (i < 20) {
                    f = d ^ (b & (c ^ d));
                    k = 0x5a827999;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0x6ed9eba1;
                }
            }
            else {
                if (i < 60) {
                    f = (b & c) | (d & (b | c));
                    k = 0x8f1bbcdc;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0xca62c1d6;
                }
            }
            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;
            e = d;
            d = c;
            c = ((b << 30) | (b >>> 2)) & 0xffffffff;
            b = a;
            a = t;
        }
        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;
        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;
        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;
        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;
        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;
    }
    update(bytes, length) {
        // TODO(johnlenz): tighten the function signature and remove this check
        if (bytes == null) {
            return;
        }
        if (length === undefined) {
            length = bytes.length;
        }
        const lengthMinusBlock = length - this.blockSize;
        let n = 0;
        // Using local instead of member variables gives ~5% speedup on Firefox 16.
        const buf = this.buf_;
        let inbuf = this.inbuf_;
        // The outer while loop should execute at most twice.
        while (n < length) {
            // When we have no data in the block to top up, we can directly process the
            // input buffer (assuming it contains sufficient data). This gives ~25%
            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
            // the data is provided in large chunks (or in multiples of 64 bytes).
            if (inbuf === 0) {
                while (n <= lengthMinusBlock) {
                    this.compress_(bytes, n);
                    n += this.blockSize;
                }
            }
            if (typeof bytes === 'string') {
                while (n < length) {
                    buf[inbuf] = bytes.charCodeAt(n);
                    ++inbuf;
                    ++n;
                    if (inbuf === this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
            else {
                while (n < length) {
                    buf[inbuf] = bytes[n];
                    ++inbuf;
                    ++n;
                    if (inbuf === this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
        }
        this.inbuf_ = inbuf;
        this.total_ += length;
    }
    /** @override */
    digest() {
        const digest = [];
        let totalBits = this.total_ * 8;
        // Add pad 0x80 0x00*.
        if (this.inbuf_ < 56) {
            this.update(this.pad_, 56 - this.inbuf_);
        }
        else {
            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        // Add # bits.
        for (let i = this.blockSize - 1; i >= 56; i--) {
            this.buf_[i] = totalBits & 255;
            totalBits /= 256; // Don't use bit-shifting here!
        }
        this.compress_(this.buf_);
        let n = 0;
        for (let i = 0; i < 5; i++) {
            for (let j = 24; j >= 0; j -= 8) {
                digest[n] = (this.chain_[i] >> j) & 255;
                ++n;
            }
        }
        return digest;
    }
}

/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */
function createSubscribe(executor, onNoObservers) {
    const proxy = new ObserverProxy(executor, onNoObservers);
    return proxy.subscribe.bind(proxy);
}
/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */
class ObserverProxy {
    /**
     * @param executor Function which can make calls to a single Observer
     *     as a proxy.
     * @param onNoObservers Callback when count of Observers goes to zero.
     */
    constructor(executor, onNoObservers) {
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        // Micro-task scheduling by calling task.then().
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        // Call the executor asynchronously so subscribers that are called
        // synchronously after the creation of the subscribe function
        // can still receive the very first value generated in the executor.
        this.task
            .then(() => {
            executor(this);
        })
            .catch(e => {
            this.error(e);
        });
    }
    next(value) {
        this.forEachObserver((observer) => {
            observer.next(value);
        });
    }
    error(error) {
        this.forEachObserver((observer) => {
            observer.error(error);
        });
        this.close(error);
    }
    complete() {
        this.forEachObserver((observer) => {
            observer.complete();
        });
        this.close();
    }
    /**
     * Subscribe function that can be used to add an Observer to the fan-out list.
     *
     * - We require that no event is sent to a subscriber sychronously to their
     *   call to subscribe().
     */
    subscribe(nextOrObserver, error, complete) {
        let observer;
        if (nextOrObserver === undefined &&
            error === undefined &&
            complete === undefined) {
            throw new Error('Missing Observer.');
        }
        // Assemble an Observer object when passed as callback functions.
        if (implementsAnyMethods(nextOrObserver, [
            'next',
            'error',
            'complete'
        ])) {
            observer = nextOrObserver;
        }
        else {
            observer = {
                next: nextOrObserver,
                error,
                complete
            };
        }
        if (observer.next === undefined) {
            observer.next = index_esm2017_noop;
        }
        if (observer.error === undefined) {
            observer.error = index_esm2017_noop;
        }
        if (observer.complete === undefined) {
            observer.complete = index_esm2017_noop;
        }
        const unsub = this.unsubscribeOne.bind(this, this.observers.length);
        // Attempt to subscribe to a terminated Observable - we
        // just respond to the Observer with the final error or complete
        // event.
        if (this.finalized) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.task.then(() => {
                try {
                    if (this.finalError) {
                        observer.error(this.finalError);
                    }
                    else {
                        observer.complete();
                    }
                }
                catch (e) {
                    // nothing
                }
                return;
            });
        }
        this.observers.push(observer);
        return unsub;
    }
    // Unsubscribe is synchronous - we guarantee that no events are sent to
    // any unsubscribed Observer.
    unsubscribeOne(i) {
        if (this.observers === undefined || this.observers[i] === undefined) {
            return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== undefined) {
            this.onNoObservers(this);
        }
    }
    forEachObserver(fn) {
        if (this.finalized) {
            // Already closed by previous event....just eat the additional values.
            return;
        }
        // Since sendOne calls asynchronously - there is no chance that
        // this.observers will become undefined.
        for (let i = 0; i < this.observers.length; i++) {
            this.sendOne(i, fn);
        }
    }
    // Call the Observer via one of it's callback function. We are careful to
    // confirm that the observe has not been unsubscribed since this asynchronous
    // function had been queued.
    sendOne(i, fn) {
        // Execute the callback asynchronously
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.task.then(() => {
            if (this.observers !== undefined && this.observers[i] !== undefined) {
                try {
                    fn(this.observers[i]);
                }
                catch (e) {
                    // Ignore exceptions raised in Observers or missing methods of an
                    // Observer.
                    // Log error to console. b/31404806
                    if (typeof console !== 'undefined' && console.error) {
                        console.error(e);
                    }
                }
            }
        });
    }
    close(err) {
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        if (err !== undefined) {
            this.finalError = err;
        }
        // Proxy is no longer needed - garbage collect references
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.task.then(() => {
            this.observers = undefined;
            this.onNoObservers = undefined;
        });
    }
}
/** Turn synchronous function into one called asynchronously. */
// eslint-disable-next-line @typescript-eslint/ban-types
function index_esm2017_async(fn, onError) {
    return (...args) => {
        Promise.resolve(true)
            .then(() => {
            fn(...args);
        })
            .catch((error) => {
            if (onError) {
                onError(error);
            }
        });
    };
}
/**
 * Return true if the object passed in implements any of the named methods.
 */
function implementsAnyMethods(obj, methods) {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    for (const method of methods) {
        if (method in obj && typeof obj[method] === 'function') {
            return true;
        }
    }
    return false;
}
function index_esm2017_noop() {
    // do nothing
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Check to make sure the appropriate number of arguments are provided for a public function.
 * Throws an error if it fails.
 *
 * @param fnName The function name
 * @param minCount The minimum number of arguments to allow for the function call
 * @param maxCount The maximum number of argument to allow for the function call
 * @param argCount The actual number of arguments provided.
 */
const validateArgCount = function (fnName, minCount, maxCount, argCount) {
    let argError;
    if (argCount < minCount) {
        argError = 'at least ' + minCount;
    }
    else if (argCount > maxCount) {
        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;
    }
    if (argError) {
        const error = fnName +
            ' failed: Was called with ' +
            argCount +
            (argCount === 1 ? ' argument.' : ' arguments.') +
            ' Expects ' +
            argError +
            '.';
        throw new Error(error);
    }
};
/**
 * Generates a string to prefix an error message about failed argument validation
 *
 * @param fnName The function name
 * @param argName The name of the argument
 * @return The prefix to add to the error thrown for validation.
 */
function errorPrefix(fnName, argName) {
    return `${fnName} failed: ${argName} argument `;
}
/**
 * @param fnName
 * @param argumentNumber
 * @param namespace
 * @param optional
 */
function validateNamespace(fnName, namespace, optional) {
    if (optional && !namespace) {
        return;
    }
    if (typeof namespace !== 'string') {
        //TODO: I should do more validation here. We only allow certain chars in namespaces.
        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');
    }
}
function validateCallback(fnName, argumentName, 
// eslint-disable-next-line @typescript-eslint/ban-types
callback, optional) {
    if (optional && !callback) {
        return;
    }
    if (typeof callback !== 'function') {
        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');
    }
}
function validateContextObject(fnName, argumentName, context, optional) {
    if (optional && !context) {
        return;
    }
    if (typeof context !== 'object' || context === null) {
        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they
// automatically replaced '\r\n' with '\n', and they didn't handle surrogate pairs,
// so it's been modified.
// Note that not all Unicode characters appear as single characters in JavaScript strings.
// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters
// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first
// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate
// pair).
// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3
/**
 * @param {string} str
 * @return {Array}
 */
const stringToByteArray = function (str) {
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        // Is this the lead surrogate in a surrogate pair?
        if (c >= 0xd800 && c <= 0xdbff) {
            const high = c - 0xd800; // the high 10 bits.
            i++;
            index_esm2017_assert(i < str.length, 'Surrogate pair missing trail surrogate.');
            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.
            c = 0x10000 + (high << 10) + low;
        }
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if (c < 65536) {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return out;
};
/**
 * Calculate length without actually converting; useful for doing cheaper validation.
 * @param {string} str
 * @return {number}
 */
const stringLength = function (str) {
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 128) {
            p++;
        }
        else if (c < 2048) {
            p += 2;
        }
        else if (c >= 0xd800 && c <= 0xdbff) {
            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.
            p += 4;
            i++; // skip trail surrogate.
        }
        else {
            p += 3;
        }
    }
    return p;
};

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Copied from https://stackoverflow.com/a/2117523
 * Generates a new uuid.
 * @public
 */
const uuidv4 = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
};

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The amount of milliseconds to exponentially increase.
 */
const DEFAULT_INTERVAL_MILLIS = 1000;
/**
 * The factor to backoff by.
 * Should be a number greater than 1.
 */
const DEFAULT_BACKOFF_FACTOR = 2;
/**
 * The maximum milliseconds to increase to.
 *
 * <p>Visible for testing
 */
const MAX_VALUE_MILLIS = (/* unused pure expression or super */ null && (4 * 60 * 60 * 1000)); // Four hours, like iOS and Android.
/**
 * The percentage of backoff time to randomize by.
 * See
 * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic
 * for context.
 *
 * <p>Visible for testing
 */
const RANDOM_FACTOR = 0.5;
/**
 * Based on the backoff method from
 * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.
 * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.
 */
function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {
    // Calculates an exponentially increasing value.
    // Deviation: calculates value from count and a constant interval, so we only need to save value
    // and count to restore state.
    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
    // A random "fuzz" to avoid waves of retries.
    // Deviation: randomFactor is required.
    const randomWait = Math.round(
    // A fraction of the backoff value to add/subtract.
    // Deviation: changes multiplication order to improve readability.
    RANDOM_FACTOR *
        currBaseValue *
        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines
        // if we add or subtract.
        (Math.random() - 0.5) *
        2);
    // Limits backoff to max to avoid effectively permanent backoff.
    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provide English ordinal letters after a number
 */
function ordinal(i) {
    if (!Number.isFinite(i)) {
        return `${i}`;
    }
    return i + indicator(i);
}
function indicator(i) {
    i = Math.abs(i);
    const cent = i % 100;
    if (cent >= 10 && cent <= 20) {
        return 'th';
    }
    const dec = i % 10;
    if (dec === 1) {
        return 'st';
    }
    if (dec === 2) {
        return 'nd';
    }
    if (dec === 3) {
        return 'rd';
    }
    return 'th';
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function index_esm2017_getModularInstance(service) {
    if (service && service._delegate) {
        return service._delegate;
    }
    else {
        return service;
    }
}



;// CONCATENATED MODULE: ./node_modules/@firebase/component/dist/esm/index.esm2017.js


/**
 * Component for service name T, e.g. `auth`, `auth-internal`
 */
class Component {
    /**
     *
     * @param name The public service name, e.g. app, auth, firestore, database
     * @param instanceFactory Service factory responsible for creating the public interface
     * @param type whether the service provided by the component is public or private
     */
    constructor(name, instanceFactory, type) {
        this.name = name;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        /**
         * Properties to be added to the service namespace
         */
        this.serviceProps = {};
        this.instantiationMode = "LAZY" /* InstantiationMode.LAZY */;
        this.onInstanceCreated = null;
    }
    setInstantiationMode(mode) {
        this.instantiationMode = mode;
        return this;
    }
    setMultipleInstances(multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
    }
    setServiceProps(props) {
        this.serviceProps = props;
        return this;
    }
    setInstanceCreatedCallback(callback) {
        this.onInstanceCreated = callback;
        return this;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME = '[DEFAULT]';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for instance for service name T, e.g. 'auth', 'auth-internal'
 * NameServiceMapping[T] is an alias for the type of the instance
 */
class Provider {
    constructor(name, container) {
        this.name = name;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.instancesOptions = new Map();
        this.onInitCallbacks = new Map();
    }
    /**
     * @param identifier A provider can provide mulitple instances of a service
     * if this.component.multipleInstances is true.
     */
    get(identifier) {
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) {
            const deferred = new Deferred();
            this.instancesDeferred.set(normalizedIdentifier, deferred);
            if (this.isInitialized(normalizedIdentifier) ||
                this.shouldAutoInitialize()) {
                // initialize the service if it can be auto-initialized
                try {
                    const instance = this.getOrInitializeService({
                        instanceIdentifier: normalizedIdentifier
                    });
                    if (instance) {
                        deferred.resolve(instance);
                    }
                }
                catch (e) {
                    // when the instance factory throws an exception during get(), it should not cause
                    // a fatal error. We just return the unresolved promise in this case.
                }
            }
        }
        return this.instancesDeferred.get(normalizedIdentifier).promise;
    }
    getImmediate(options) {
        var _a;
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) ||
            this.shouldAutoInitialize()) {
            try {
                return this.getOrInitializeService({
                    instanceIdentifier: normalizedIdentifier
                });
            }
            catch (e) {
                if (optional) {
                    return null;
                }
                else {
                    throw e;
                }
            }
        }
        else {
            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw
            if (optional) {
                return null;
            }
            else {
                throw Error(`Service ${this.name} is not available`);
            }
        }
    }
    getComponent() {
        return this.component;
    }
    setComponent(component) {
        if (component.name !== this.name) {
            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
        }
        if (this.component) {
            throw Error(`Component for ${this.name} has already been provided`);
        }
        this.component = component;
        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)
        if (!this.shouldAutoInitialize()) {
            return;
        }
        // if the service is eager, initialize the default instance
        if (isComponentEager(component)) {
            try {
                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });
            }
            catch (e) {
                // when the instance factory for an eager Component throws an exception during the eager
                // initialization, it should not cause a fatal error.
                // TODO: Investigate if we need to make it configurable, because some component may want to cause
                // a fatal error in this case?
            }
        }
        // Create service instances for the pending promises and resolve them
        // NOTE: if this.multipleInstances is false, only the default instance will be created
        // and all promises with resolve with it regardless of the identifier.
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            try {
                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.
                const instance = this.getOrInitializeService({
                    instanceIdentifier: normalizedIdentifier
                });
                instanceDeferred.resolve(instance);
            }
            catch (e) {
                // when the instance factory throws an exception, it should not cause
                // a fatal error. We just leave the promise unresolved.
            }
        }
    }
    clearInstance(identifier = DEFAULT_ENTRY_NAME) {
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
    }
    // app.delete() will call this method on every provider to delete the services
    // TODO: should we mark the provider as deleted?
    async delete() {
        const services = Array.from(this.instances.values());
        await Promise.all([
            ...services
                .filter(service => 'INTERNAL' in service) // legacy services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service.INTERNAL.delete()),
            ...services
                .filter(service => '_delete' in service) // modularized services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service._delete())
        ]);
    }
    isComponentSet() {
        return this.component != null;
    }
    isInitialized(identifier = DEFAULT_ENTRY_NAME) {
        return this.instances.has(identifier);
    }
    getOptions(identifier = DEFAULT_ENTRY_NAME) {
        return this.instancesOptions.get(identifier) || {};
    }
    initialize(opts = {}) {
        const { options = {} } = opts;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) {
            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
        }
        if (!this.isComponentSet()) {
            throw Error(`Component ${this.name} has not been registered yet`);
        }
        const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier,
            options
        });
        // resolve any pending promise waiting for the service instance
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            if (normalizedIdentifier === normalizedDeferredIdentifier) {
                instanceDeferred.resolve(instance);
            }
        }
        return instance;
    }
    /**
     *
     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
     *
     * @param identifier An optional instance identifier
     * @returns a function to unregister the callback
     */
    onInit(callback, identifier) {
        var _a;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        const existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) {
            callback(existingInstance, normalizedIdentifier);
        }
        return () => {
            existingCallbacks.delete(callback);
        };
    }
    /**
     * Invoke onInit callbacks synchronously
     * @param instance the service instance`
     */
    invokeOnInitCallbacks(instance, identifier) {
        const callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) {
            return;
        }
        for (const callback of callbacks) {
            try {
                callback(instance, identifier);
            }
            catch (_a) {
                // ignore errors in the onInit callback
            }
        }
    }
    getOrInitializeService({ instanceIdentifier, options = {} }) {
        let instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) {
            instance = this.component.instanceFactory(this.container, {
                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
                options
            });
            this.instances.set(instanceIdentifier, instance);
            this.instancesOptions.set(instanceIdentifier, options);
            /**
             * Invoke onInit listeners.
             * Note this.component.onInstanceCreated is different, which is used by the component creator,
             * while onInit listeners are registered by consumers of the provider.
             */
            this.invokeOnInitCallbacks(instance, instanceIdentifier);
            /**
             * Order is important
             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which
             * makes `isInitialized()` return true.
             */
            if (this.component.onInstanceCreated) {
                try {
                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
                }
                catch (_a) {
                    // ignore errors in the onInstanceCreatedCallback
                }
            }
        }
        return instance || null;
    }
    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {
        if (this.component) {
            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
        }
        else {
            return identifier; // assume multiple instances are supported before the component is provided.
        }
    }
    shouldAutoInitialize() {
        return (!!this.component &&
            this.component.instantiationMode !== "EXPLICIT" /* InstantiationMode.EXPLICIT */);
    }
}
// undefined should be passed to the service factory for the default instance
function normalizeIdentifierForFactory(identifier) {
    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;
}
function isComponentEager(component) {
    return component.instantiationMode === "EAGER" /* InstantiationMode.EAGER */;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`
 */
class ComponentContainer {
    constructor(name) {
        this.name = name;
        this.providers = new Map();
    }
    /**
     *
     * @param component Component being added
     * @param overwrite When a component with the same name has already been registered,
     * if overwrite is true: overwrite the existing component with the new component and create a new
     * provider with the new component. It can be useful in tests where you want to use different mocks
     * for different tests.
     * if overwrite is false: throw an exception
     */
    addComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
        }
        provider.setComponent(component);
    }
    addOrOverwriteComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
            // delete the existing provider from the container, so we can register the new component
            this.providers.delete(component.name);
        }
        this.addComponent(component);
    }
    /**
     * getProvider provides a type safe interface where it can only be called with a field name
     * present in NameServiceMapping interface.
     *
     * Firebase SDKs providing services should extend NameServiceMapping interface to register
     * themselves.
     */
    getProvider(name) {
        if (this.providers.has(name)) {
            return this.providers.get(name);
        }
        // create a Provider for a service that hasn't registered with Firebase
        const provider = new Provider(name, this);
        this.providers.set(name, provider);
        return provider;
    }
    getProviders() {
        return Array.from(this.providers.values());
    }
}



;// CONCATENATED MODULE: ./node_modules/@firebase/logger/dist/esm/index.esm2017.js
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A container for all of the Logger instances
 */
const instances = [];
/**
 * The JS SDK supports 5 log levels and also allows a user the ability to
 * silence the logs altogether.
 *
 * The order is a follows:
 * DEBUG < VERBOSE < INFO < WARN < ERROR
 *
 * All of the log types above the current log level will be captured (i.e. if
 * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and
 * `VERBOSE` logs will not)
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
const levelStringToEnum = {
    'debug': LogLevel.DEBUG,
    'verbose': LogLevel.VERBOSE,
    'info': LogLevel.INFO,
    'warn': LogLevel.WARN,
    'error': LogLevel.ERROR,
    'silent': LogLevel.SILENT
};
/**
 * The default log level
 */
const defaultLogLevel = LogLevel.INFO;
/**
 * By default, `console.debug` is not displayed in the developer console (in
 * chrome). To avoid forcing users to have to opt-in to these logs twice
 * (i.e. once for firebase, and once in the console), we are sending `DEBUG`
 * logs to the `console.log` function.
 */
const ConsoleMethod = {
    [LogLevel.DEBUG]: 'log',
    [LogLevel.VERBOSE]: 'log',
    [LogLevel.INFO]: 'info',
    [LogLevel.WARN]: 'warn',
    [LogLevel.ERROR]: 'error'
};
/**
 * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR
 * messages on to their corresponding console counterparts (if the log method
 * is supported by the current log level)
 */
const defaultLogHandler = (instance, logType, ...args) => {
    if (logType < instance.logLevel) {
        return;
    }
    const now = new Date().toISOString();
    const method = ConsoleMethod[logType];
    if (method) {
        console[method](`[${now}]  ${instance.name}:`, ...args);
    }
    else {
        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
    }
};
class Logger {
    /**
     * Gives you an instance of a Logger to capture messages according to
     * Firebase's logging scheme.
     *
     * @param name The name that the logs will be associated with
     */
    constructor(name) {
        this.name = name;
        /**
         * The log level of the given Logger instance.
         */
        this._logLevel = defaultLogLevel;
        /**
         * The main (internal) log handler for the Logger instance.
         * Can be set to a new function in internal package code but not by user.
         */
        this._logHandler = defaultLogHandler;
        /**
         * The optional, additional, user-defined log handler for the Logger instance.
         */
        this._userLogHandler = null;
        /**
         * Capture the current instance for later use
         */
        instances.push(this);
    }
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(val) {
        if (!(val in LogLevel)) {
            throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
        }
        this._logLevel = val;
    }
    // Workaround for setter/getter having to be the same type.
    setLogLevel(val) {
        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;
    }
    get logHandler() {
        return this._logHandler;
    }
    set logHandler(val) {
        if (typeof val !== 'function') {
            throw new TypeError('Value assigned to `logHandler` must be a function');
        }
        this._logHandler = val;
    }
    get userLogHandler() {
        return this._userLogHandler;
    }
    set userLogHandler(val) {
        this._userLogHandler = val;
    }
    /**
     * The functions below are all based on the `console` interface
     */
    debug(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
        this._logHandler(this, LogLevel.DEBUG, ...args);
    }
    log(...args) {
        this._userLogHandler &&
            this._userLogHandler(this, LogLevel.VERBOSE, ...args);
        this._logHandler(this, LogLevel.VERBOSE, ...args);
    }
    info(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
        this._logHandler(this, LogLevel.INFO, ...args);
    }
    warn(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
        this._logHandler(this, LogLevel.WARN, ...args);
    }
    error(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
        this._logHandler(this, LogLevel.ERROR, ...args);
    }
}
function setLogLevel(level) {
    instances.forEach(inst => {
        inst.setLogLevel(level);
    });
}
function index_esm2017_setUserLogHandler(logCallback, options) {
    for (const instance of instances) {
        let customLogLevel = null;
        if (options && options.level) {
            customLogLevel = levelStringToEnum[options.level];
        }
        if (logCallback === null) {
            instance.userLogHandler = null;
        }
        else {
            instance.userLogHandler = (instance, level, ...args) => {
                const message = args
                    .map(arg => {
                    if (arg == null) {
                        return null;
                    }
                    else if (typeof arg === 'string') {
                        return arg;
                    }
                    else if (typeof arg === 'number' || typeof arg === 'boolean') {
                        return arg.toString();
                    }
                    else if (arg instanceof Error) {
                        return arg.message;
                    }
                    else {
                        try {
                            return JSON.stringify(arg);
                        }
                        catch (ignored) {
                            return null;
                        }
                    }
                })
                    .filter(arg => arg)
                    .join(' ');
                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {
                    logCallback({
                        level: LogLevel[level].toLowerCase(),
                        message,
                        args,
                        type: instance.name
                    });
                }
            };
        }
    }
}



;// CONCATENATED MODULE: ./node_modules/idb/build/wrap-idb-value.js
const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);

let idbProxyableTypes;
let cursorAdvanceMethods;
// This is a function to prevent it throwing up in node environments.
function getIdbProxyableTypes() {
    return (idbProxyableTypes ||
        (idbProxyableTypes = [
            IDBDatabase,
            IDBObjectStore,
            IDBIndex,
            IDBCursor,
            IDBTransaction,
        ]));
}
// This is a function to prevent it throwing up in node environments.
function getCursorAdvanceMethods() {
    return (cursorAdvanceMethods ||
        (cursorAdvanceMethods = [
            IDBCursor.prototype.advance,
            IDBCursor.prototype.continue,
            IDBCursor.prototype.continuePrimaryKey,
        ]));
}
const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
        const unlisten = () => {
            request.removeEventListener('success', success);
            request.removeEventListener('error', error);
        };
        const success = () => {
            resolve(wrap_idb_value_wrap(request.result));
            unlisten();
        };
        const error = () => {
            reject(request.error);
            unlisten();
        };
        request.addEventListener('success', success);
        request.addEventListener('error', error);
    });
    promise
        .then((value) => {
        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
        // (see wrapFunction).
        if (value instanceof IDBCursor) {
            cursorRequestMap.set(value, request);
        }
        // Catching to avoid "Uncaught Promise exceptions"
    })
        .catch(() => { });
    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
    // is because we create many promises from a single IDBRequest.
    reverseTransformCache.set(promise, request);
    return promise;
}
function cacheDonePromiseForTransaction(tx) {
    // Early bail if we've already created a done promise for this transaction.
    if (transactionDoneMap.has(tx))
        return;
    const done = new Promise((resolve, reject) => {
        const unlisten = () => {
            tx.removeEventListener('complete', complete);
            tx.removeEventListener('error', error);
            tx.removeEventListener('abort', error);
        };
        const complete = () => {
            resolve();
            unlisten();
        };
        const error = () => {
            reject(tx.error || new DOMException('AbortError', 'AbortError'));
            unlisten();
        };
        tx.addEventListener('complete', complete);
        tx.addEventListener('error', error);
        tx.addEventListener('abort', error);
    });
    // Cache it for later retrieval.
    transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
    get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
            // Special handling for transaction.done.
            if (prop === 'done')
                return transactionDoneMap.get(target);
            // Polyfill for objectStoreNames because of Edge.
            if (prop === 'objectStoreNames') {
                return target.objectStoreNames || transactionStoreNamesMap.get(target);
            }
            // Make tx.store return the only store in the transaction, or undefined if there are many.
            if (prop === 'store') {
                return receiver.objectStoreNames[1]
                    ? undefined
                    : receiver.objectStore(receiver.objectStoreNames[0]);
            }
        }
        // Else transform whatever we get back.
        return wrap_idb_value_wrap(target[prop]);
    },
    set(target, prop, value) {
        target[prop] = value;
        return true;
    },
    has(target, prop) {
        if (target instanceof IDBTransaction &&
            (prop === 'done' || prop === 'store')) {
            return true;
        }
        return prop in target;
    },
};
function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
    // Due to expected object equality (which is enforced by the caching in `wrap`), we
    // only create one new func per func.
    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
    if (func === IDBDatabase.prototype.transaction &&
        !('objectStoreNames' in IDBTransaction.prototype)) {
        return function (storeNames, ...args) {
            const tx = func.call(unwrap(this), storeNames, ...args);
            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
            return wrap_idb_value_wrap(tx);
        };
    }
    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
    // with real promises, so each advance methods returns a new promise for the cursor object, or
    // undefined if the end of the cursor has been reached.
    if (getCursorAdvanceMethods().includes(func)) {
        return function (...args) {
            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
            // the original object.
            func.apply(unwrap(this), args);
            return wrap_idb_value_wrap(cursorRequestMap.get(this));
        };
    }
    return function (...args) {
        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
        // the original object.
        return wrap_idb_value_wrap(func.apply(unwrap(this), args));
    };
}
function transformCachableValue(value) {
    if (typeof value === 'function')
        return wrapFunction(value);
    // This doesn't return, it just creates a 'done' promise for the transaction,
    // which is later returned for transaction.done (see idbObjectHandler).
    if (value instanceof IDBTransaction)
        cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
        return new Proxy(value, idbProxyTraps);
    // Return the same value back if we're not going to transform it.
    return value;
}
function wrap_idb_value_wrap(value) {
    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
    if (value instanceof IDBRequest)
        return promisifyRequest(value);
    // If we've already transformed this value before, reuse the transformed value.
    // This is faster, but it also provides object equality.
    if (transformCache.has(value))
        return transformCache.get(value);
    const newValue = transformCachableValue(value);
    // Not all types are transformed.
    // These may be primitive types, so they can't be WeakMap keys.
    if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
    }
    return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);



;// CONCATENATED MODULE: ./node_modules/idb/build/index.js



/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap_idb_value_wrap(request);
    if (upgrade) {
        request.addEventListener('upgradeneeded', (event) => {
            upgrade(wrap_idb_value_wrap(request.result), event.oldVersion, event.newVersion, wrap_idb_value_wrap(request.transaction), event);
        });
    }
    if (blocked) {
        request.addEventListener('blocked', (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion, event.newVersion, event));
    }
    openPromise
        .then((db) => {
        if (terminated)
            db.addEventListener('close', () => terminated());
        if (blocking) {
            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));
        }
    })
        .catch(() => { });
    return openPromise;
}
/**
 * Delete a database.
 *
 * @param name Name of the database.
 */
function deleteDB(name, { blocked } = {}) {
    const request = indexedDB.deleteDatabase(name);
    if (blocked) {
        request.addEventListener('blocked', (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion, event));
    }
    return wrap(request).then(() => undefined);
}

const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
const writeMethods = ['put', 'add', 'delete', 'clear'];
const cachedMethods = new Map();
function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase &&
        !(prop in target) &&
        typeof prop === 'string')) {
        return;
    }
    if (cachedMethods.get(prop))
        return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, '');
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
        !(isWrite || readMethods.includes(targetFuncName))) {
        return;
    }
    const method = async function (storeName, ...args) {
        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
        let target = tx.store;
        if (useIndex)
            target = target.index(args.shift());
        // Must reject if op rejects.
        // If it's a write operation, must reject if tx.done rejects.
        // Must reject with op rejection first.
        // Must resolve with op value.
        // Must handle both promises (no unhandled rejections)
        return (await Promise.all([
            target[targetFuncName](...args),
            isWrite && tx.done,
        ]))[0];
    };
    cachedMethods.set(prop, method);
    return method;
}
replaceTraps((oldTraps) => ({
    ...oldTraps,
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
}));



;// CONCATENATED MODULE: ./node_modules/@firebase/app/dist/esm/index.esm2017.js






/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlatformLoggerServiceImpl {
    constructor(container) {
        this.container = container;
    }
    // In initial implementation, this will be called by installations on
    // auth token refresh, and installations will send this string.
    getPlatformInfoString() {
        const providers = this.container.getProviders();
        // Loop through providers and get library/version pairs from any that are
        // version components.
        return providers
            .map(provider => {
            if (isVersionServiceProvider(provider)) {
                const service = provider.getImmediate();
                return `${service.library}/${service.version}`;
            }
            else {
                return null;
            }
        })
            .filter(logString => logString)
            .join(' ');
    }
}
/**
 *
 * @param provider check if this provider provides a VersionService
 *
 * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider
 * provides VersionService. The provider is not necessarily a 'app-version'
 * provider.
 */
function isVersionServiceProvider(provider) {
    const component = provider.getComponent();
    return (component === null || component === void 0 ? void 0 : component.type) === "VERSION" /* ComponentType.VERSION */;
}

const name$o = "@firebase/app";
const version$1 = "0.9.13";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger = new Logger('@firebase/app');

const name$n = "@firebase/app-compat";

const name$m = "@firebase/analytics-compat";

const name$l = "@firebase/analytics";

const name$k = "@firebase/app-check-compat";

const name$j = "@firebase/app-check";

const name$i = "@firebase/auth";

const name$h = "@firebase/auth-compat";

const name$g = "@firebase/database";

const name$f = "@firebase/database-compat";

const name$e = "@firebase/functions";

const name$d = "@firebase/functions-compat";

const name$c = "@firebase/installations";

const name$b = "@firebase/installations-compat";

const name$a = "@firebase/messaging";

const name$9 = "@firebase/messaging-compat";

const name$8 = "@firebase/performance";

const name$7 = "@firebase/performance-compat";

const name$6 = "@firebase/remote-config";

const name$5 = "@firebase/remote-config-compat";

const name$4 = "@firebase/storage";

const name$3 = "@firebase/storage-compat";

const name$2 = "@firebase/firestore";

const name$1 = "@firebase/firestore-compat";

const index_esm2017_name = "firebase";
const version = "9.23.0";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The default app name
 *
 * @internal
 */
const index_esm2017_DEFAULT_ENTRY_NAME = '[DEFAULT]';
const PLATFORM_LOG_STRING = {
    [name$o]: 'fire-core',
    [name$n]: 'fire-core-compat',
    [name$l]: 'fire-analytics',
    [name$m]: 'fire-analytics-compat',
    [name$j]: 'fire-app-check',
    [name$k]: 'fire-app-check-compat',
    [name$i]: 'fire-auth',
    [name$h]: 'fire-auth-compat',
    [name$g]: 'fire-rtdb',
    [name$f]: 'fire-rtdb-compat',
    [name$e]: 'fire-fn',
    [name$d]: 'fire-fn-compat',
    [name$c]: 'fire-iid',
    [name$b]: 'fire-iid-compat',
    [name$a]: 'fire-fcm',
    [name$9]: 'fire-fcm-compat',
    [name$8]: 'fire-perf',
    [name$7]: 'fire-perf-compat',
    [name$6]: 'fire-rc',
    [name$5]: 'fire-rc-compat',
    [name$4]: 'fire-gcs',
    [name$3]: 'fire-gcs-compat',
    [name$2]: 'fire-fst',
    [name$1]: 'fire-fst-compat',
    'fire-js': 'fire-js',
    [index_esm2017_name]: 'fire-js-all'
};

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
const _apps = new Map();
/**
 * Registered components.
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const _components = new Map();
/**
 * @param component - the component being added to this app's container
 *
 * @internal
 */
function _addComponent(app, component) {
    try {
        app.container.addComponent(component);
    }
    catch (e) {
        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);
    }
}
/**
 *
 * @internal
 */
function _addOrOverwriteComponent(app, component) {
    app.container.addOrOverwriteComponent(component);
}
/**
 *
 * @param component - the component to register
 * @returns whether or not the component is registered successfully
 *
 * @internal
 */
function _registerComponent(component) {
    const componentName = component.name;
    if (_components.has(componentName)) {
        logger.debug(`There were multiple attempts to register component ${componentName}.`);
        return false;
    }
    _components.set(componentName, component);
    // add the component to existing app instances
    for (const app of _apps.values()) {
        _addComponent(app, component);
    }
    return true;
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 *
 * @returns the provider for the service with the matching name
 *
 * @internal
 */
function _getProvider(app, name) {
    const heartbeatController = app.container
        .getProvider('heartbeat')
        .getImmediate({ optional: true });
    if (heartbeatController) {
        void heartbeatController.triggerHeartbeat();
    }
    return app.container.getProvider(name);
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 * @param instanceIdentifier - service instance identifier in case the service supports multiple instances
 *
 * @internal
 */
function _removeServiceInstance(app, name, instanceIdentifier = index_esm2017_DEFAULT_ENTRY_NAME) {
    _getProvider(app, name).clearInstance(instanceIdentifier);
}
/**
 * Test only
 *
 * @internal
 */
function _clearComponents() {
    _components.clear();
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = {
    ["no-app" /* AppError.NO_APP */]: "No Firebase App '{$appName}' has been created - " +
        'call initializeApp() first',
    ["bad-app-name" /* AppError.BAD_APP_NAME */]: "Illegal App name: '{$appName}",
    ["duplicate-app" /* AppError.DUPLICATE_APP */]: "Firebase App named '{$appName}' already exists with different options or config",
    ["app-deleted" /* AppError.APP_DELETED */]: "Firebase App named '{$appName}' already deleted",
    ["no-options" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',
    ["invalid-app-argument" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +
        'Firebase App instance.',
    ["invalid-log-argument" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',
    ["idb-open" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',
    ["idb-get" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',
    ["idb-set" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',
    ["idb-delete" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.'
};
const ERROR_FACTORY = new ErrorFactory('app', 'Firebase', ERRORS);

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl {
    constructor(options, config, container) {
        this._isDeleted = false;
        this._options = Object.assign({}, options);
        this._config = Object.assign({}, config);
        this._name = config.name;
        this._automaticDataCollectionEnabled =
            config.automaticDataCollectionEnabled;
        this._container = container;
        this.container.addComponent(new Component('app', () => this, "PUBLIC" /* ComponentType.PUBLIC */));
    }
    get automaticDataCollectionEnabled() {
        this.checkDestroyed();
        return this._automaticDataCollectionEnabled;
    }
    set automaticDataCollectionEnabled(val) {
        this.checkDestroyed();
        this._automaticDataCollectionEnabled = val;
    }
    get name() {
        this.checkDestroyed();
        return this._name;
    }
    get options() {
        this.checkDestroyed();
        return this._options;
    }
    get config() {
        this.checkDestroyed();
        return this._config;
    }
    get container() {
        return this._container;
    }
    get isDeleted() {
        return this._isDeleted;
    }
    set isDeleted(val) {
        this._isDeleted = val;
    }
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    checkDestroyed() {
        if (this.isDeleted) {
            throw ERROR_FACTORY.create("app-deleted" /* AppError.APP_DELETED */, { appName: this._name });
        }
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The current SDK version.
 *
 * @public
 */
const SDK_VERSION = version;
function initializeApp(_options, rawConfig = {}) {
    let options = _options;
    if (typeof rawConfig !== 'object') {
        const name = rawConfig;
        rawConfig = { name };
    }
    const config = Object.assign({ name: index_esm2017_DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);
    const name = config.name;
    if (typeof name !== 'string' || !name) {
        throw ERROR_FACTORY.create("bad-app-name" /* AppError.BAD_APP_NAME */, {
            appName: String(name)
        });
    }
    options || (options = getDefaultAppConfig());
    if (!options) {
        throw ERROR_FACTORY.create("no-options" /* AppError.NO_OPTIONS */);
    }
    const existingApp = _apps.get(name);
    if (existingApp) {
        // return the existing app if options and config deep equal the ones in the existing app.
        if (deepEqual(options, existingApp.options) &&
            deepEqual(config, existingApp.config)) {
            return existingApp;
        }
        else {
            throw ERROR_FACTORY.create("duplicate-app" /* AppError.DUPLICATE_APP */, { appName: name });
        }
    }
    const container = new ComponentContainer(name);
    for (const component of _components.values()) {
        container.addComponent(component);
    }
    const newApp = new FirebaseAppImpl(options, config, container);
    _apps.set(name, newApp);
    return newApp;
}
/**
 * Retrieves a {@link @firebase/app#FirebaseApp} instance.
 *
 * When called with no arguments, the default app is returned. When an app name
 * is provided, the app corresponding to that name is returned.
 *
 * An exception is thrown if the app being retrieved has not yet been
 * initialized.
 *
 * @example
 * ```javascript
 * // Return the default app
 * const app = getApp();
 * ```
 *
 * @example
 * ```javascript
 * // Return a named app
 * const otherApp = getApp("otherApp");
 * ```
 *
 * @param name - Optional name of the app to return. If no name is
 *   provided, the default is `"[DEFAULT]"`.
 *
 * @returns The app corresponding to the provided app name.
 *   If no app name is provided, the default app is returned.
 *
 * @public
 */
function getApp(name = index_esm2017_DEFAULT_ENTRY_NAME) {
    const app = _apps.get(name);
    if (!app && name === index_esm2017_DEFAULT_ENTRY_NAME && getDefaultAppConfig()) {
        return initializeApp();
    }
    if (!app) {
        throw ERROR_FACTORY.create("no-app" /* AppError.NO_APP */, { appName: name });
    }
    return app;
}
/**
 * A (read-only) array of all initialized apps.
 * @public
 */
function getApps() {
    return Array.from(_apps.values());
}
/**
 * Renders this app unusable and frees the resources of all associated
 * services.
 *
 * @example
 * ```javascript
 * deleteApp(app)
 *   .then(function() {
 *     console.log("App deleted successfully");
 *   })
 *   .catch(function(error) {
 *     console.log("Error deleting app:", error);
 *   });
 * ```
 *
 * @public
 */
async function deleteApp(app) {
    const name = app.name;
    if (_apps.has(name)) {
        _apps.delete(name);
        await Promise.all(app.container
            .getProviders()
            .map(provider => provider.delete()));
        app.isDeleted = true;
    }
}
/**
 * Registers a library's name and version for platform logging purposes.
 * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)
 * @param version - Current version of that library.
 * @param variant - Bundle variant, e.g., node, rn, etc.
 *
 * @public
 */
function registerVersion(libraryKeyOrName, version, variant) {
    var _a;
    // TODO: We can use this check to whitelist strings when/if we set up
    // a good whitelist system.
    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
    if (variant) {
        library += `-${variant}`;
    }
    const libraryMismatch = library.match(/\s|\//);
    const versionMismatch = version.match(/\s|\//);
    if (libraryMismatch || versionMismatch) {
        const warning = [
            `Unable to register library "${library}" with version "${version}":`
        ];
        if (libraryMismatch) {
            warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
        }
        if (libraryMismatch && versionMismatch) {
            warning.push('and');
        }
        if (versionMismatch) {
            warning.push(`version name "${version}" contains illegal characters (whitespace or "/")`);
        }
        logger.warn(warning.join(' '));
        return;
    }
    _registerComponent(new Component(`${library}-version`, () => ({ library, version }), "VERSION" /* ComponentType.VERSION */));
}
/**
 * Sets log handler for all Firebase SDKs.
 * @param logCallback - An optional custom log handler that executes user code whenever
 * the Firebase SDK makes a logging call.
 *
 * @public
 */
function onLog(logCallback, options) {
    if (logCallback !== null && typeof logCallback !== 'function') {
        throw ERROR_FACTORY.create("invalid-log-argument" /* AppError.INVALID_LOG_ARGUMENT */);
    }
    setUserLogHandler(logCallback, options);
}
/**
 * Sets log level for all Firebase SDKs.
 *
 * All of the log types above the current log level are captured (i.e. if
 * you set the log level to `info`, errors are logged, but `debug` and
 * `verbose` logs are not).
 *
 * @public
 */
function index_esm2017_setLogLevel(logLevel) {
    setLogLevel$1(logLevel);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME = 'firebase-heartbeat-database';
const DB_VERSION = 1;
const STORE_NAME = 'firebase-heartbeat-store';
let dbPromise = null;
function getDbPromise() {
    if (!dbPromise) {
        dbPromise = openDB(DB_NAME, DB_VERSION, {
            upgrade: (db, oldVersion) => {
                // We don't use 'break' in this switch statement, the fall-through
                // behavior is what we want, because if there are multiple versions between
                // the old version and the current version, we want ALL the migrations
                // that correspond to those versions to run, not only the last one.
                // eslint-disable-next-line default-case
                switch (oldVersion) {
                    case 0:
                        db.createObjectStore(STORE_NAME);
                }
            }
        }).catch(e => {
            throw ERROR_FACTORY.create("idb-open" /* AppError.IDB_OPEN */, {
                originalErrorMessage: e.message
            });
        });
    }
    return dbPromise;
}
async function readHeartbeatsFromIndexedDB(app) {
    try {
        const db = await getDbPromise();
        const result = await db
            .transaction(STORE_NAME)
            .objectStore(STORE_NAME)
            .get(computeKey(app));
        return result;
    }
    catch (e) {
        if (e instanceof FirebaseError) {
            logger.warn(e.message);
        }
        else {
            const idbGetError = ERROR_FACTORY.create("idb-get" /* AppError.IDB_GET */, {
                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
            });
            logger.warn(idbGetError.message);
        }
    }
}
async function writeHeartbeatsToIndexedDB(app, heartbeatObject) {
    try {
        const db = await getDbPromise();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const objectStore = tx.objectStore(STORE_NAME);
        await objectStore.put(heartbeatObject, computeKey(app));
        await tx.done;
    }
    catch (e) {
        if (e instanceof FirebaseError) {
            logger.warn(e.message);
        }
        else {
            const idbGetError = ERROR_FACTORY.create("idb-set" /* AppError.IDB_WRITE */, {
                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
            });
            logger.warn(idbGetError.message);
        }
    }
}
function computeKey(app) {
    return `${app.name}!${app.options.appId}`;
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_HEADER_BYTES = 1024;
// 30 days
const STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;
class HeartbeatServiceImpl {
    constructor(container) {
        this.container = container;
        /**
         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate
         * the header string.
         * Stores one record per date. This will be consolidated into the standard
         * format of one record per user agent string before being sent as a header.
         * Populated from indexedDB when the controller is instantiated and should
         * be kept in sync with indexedDB.
         * Leave public for easier testing.
         */
        this._heartbeatsCache = null;
        const app = this.container.getProvider('app').getImmediate();
        this._storage = new HeartbeatStorageImpl(app);
        this._heartbeatsCachePromise = this._storage.read().then(result => {
            this._heartbeatsCache = result;
            return result;
        });
    }
    /**
     * Called to report a heartbeat. The function will generate
     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
     * to IndexedDB.
     * Note that we only store one heartbeat per day. So if a heartbeat for today is
     * already logged, subsequent calls to this function in the same day will be ignored.
     */
    async triggerHeartbeat() {
        const platformLogger = this.container
            .getProvider('platform-logger')
            .getImmediate();
        // This is the "Firebase user agent" string from the platform logger
        // service, not the browser user agent.
        const agent = platformLogger.getPlatformInfoString();
        const date = getUTCDateString();
        if (this._heartbeatsCache === null) {
            this._heartbeatsCache = await this._heartbeatsCachePromise;
        }
        // Do not store a heartbeat if one is already stored for this day
        // or if a header has already been sent today.
        if (this._heartbeatsCache.lastSentHeartbeatDate === date ||
            this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {
            return;
        }
        else {
            // There is no entry for this date. Create one.
            this._heartbeatsCache.heartbeats.push({ date, agent });
        }
        // Remove entries older than 30 days.
        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {
            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
            const now = Date.now();
            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
        });
        return this._storage.overwrite(this._heartbeatsCache);
    }
    /**
     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
     * It also clears all heartbeats from memory as well as in IndexedDB.
     *
     * NOTE: Consuming product SDKs should not send the header if this method
     * returns an empty string.
     */
    async getHeartbeatsHeader() {
        if (this._heartbeatsCache === null) {
            await this._heartbeatsCachePromise;
        }
        // If it's still null or the array is empty, there is no data to send.
        if (this._heartbeatsCache === null ||
            this._heartbeatsCache.heartbeats.length === 0) {
            return '';
        }
        const date = getUTCDateString();
        // Extract as many heartbeats from the cache as will fit under the size limit.
        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
        const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
        // Store last sent date to prevent another being logged/sent for the same day.
        this._heartbeatsCache.lastSentHeartbeatDate = date;
        if (unsentEntries.length > 0) {
            // Store any unsent entries if they exist.
            this._heartbeatsCache.heartbeats = unsentEntries;
            // This seems more likely than emptying the array (below) to lead to some odd state
            // since the cache isn't empty and this will be called again on the next request,
            // and is probably safest if we await it.
            await this._storage.overwrite(this._heartbeatsCache);
        }
        else {
            this._heartbeatsCache.heartbeats = [];
            // Do not wait for this, to reduce latency.
            void this._storage.overwrite(this._heartbeatsCache);
        }
        return headerString;
    }
}
function getUTCDateString() {
    const today = new Date();
    // Returns date format 'YYYY-MM-DD'
    return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
    // Heartbeats grouped by user agent in the standard format to be sent in
    // the header.
    const heartbeatsToSend = [];
    // Single date format heartbeats that are not sent.
    let unsentEntries = heartbeatsCache.slice();
    for (const singleDateHeartbeat of heartbeatsCache) {
        // Look for an existing entry with the same user agent.
        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);
        if (!heartbeatEntry) {
            // If no entry for this user agent exists, create one.
            heartbeatsToSend.push({
                agent: singleDateHeartbeat.agent,
                dates: [singleDateHeartbeat.date]
            });
            if (countBytes(heartbeatsToSend) > maxSize) {
                // If the header would exceed max size, remove the added heartbeat
                // entry and stop adding to the header.
                heartbeatsToSend.pop();
                break;
            }
        }
        else {
            heartbeatEntry.dates.push(singleDateHeartbeat.date);
            // If the header would exceed max size, remove the added date
            // and stop adding to the header.
            if (countBytes(heartbeatsToSend) > maxSize) {
                heartbeatEntry.dates.pop();
                break;
            }
        }
        // Pop unsent entry from queue. (Skipped if adding the entry exceeded
        // quota and the loop breaks early.)
        unsentEntries = unsentEntries.slice(1);
    }
    return {
        heartbeatsToSend,
        unsentEntries
    };
}
class HeartbeatStorageImpl {
    constructor(app) {
        this.app = app;
        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
    }
    async runIndexedDBEnvironmentCheck() {
        if (!isIndexedDBAvailable()) {
            return false;
        }
        else {
            return validateIndexedDBOpenable()
                .then(() => true)
                .catch(() => false);
        }
    }
    /**
     * Read all heartbeats.
     */
    async read() {
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return { heartbeats: [] };
        }
        else {
            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
            return idbHeartbeatObject || { heartbeats: [] };
        }
    }
    // overwrite the storage with the provided heartbeats
    async overwrite(heartbeatsObject) {
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return;
        }
        else {
            const existingHeartbeatsObject = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
                heartbeats: heartbeatsObject.heartbeats
            });
        }
    }
    // add heartbeats
    async add(heartbeatsObject) {
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return;
        }
        else {
            const existingHeartbeatsObject = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
                heartbeats: [
                    ...existingHeartbeatsObject.heartbeats,
                    ...heartbeatsObject.heartbeats
                ]
            });
        }
    }
}
/**
 * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped
 * in a platform logging header JSON object, stringified, and converted
 * to base 64.
 */
function countBytes(heartbeatsCache) {
    // base64 has a restricted set of characters, all of which should be 1 byte.
    return base64urlEncodeWithoutPadding(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents(variant) {
    _registerComponent(new Component('platform-logger', container => new PlatformLoggerServiceImpl(container), "PRIVATE" /* ComponentType.PRIVATE */));
    _registerComponent(new Component('heartbeat', container => new HeartbeatServiceImpl(container), "PRIVATE" /* ComponentType.PRIVATE */));
    // Register `app` package.
    registerVersion(name$o, version$1, variant);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(name$o, version$1, 'esm2017');
    // Register platform SDK identifier (no version).
    registerVersion('fire-js', '');
}

/**
 * Firebase App
 *
 * @remarks This package coordinates the communication between the different Firebase components
 * @packageDocumentation
 */
registerCoreComponents('');



;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.mjs
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

/* harmony default export */ const tslib_es6 = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
});

;// CONCATENATED MODULE: ./node_modules/@firebase/auth/dist/esm2017/index-e3d5d3f4.js






/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An enum of factors that may be used for multifactor authentication.
 *
 * @public
 */
const FactorId = {
    /** Phone as second factor */
    PHONE: 'phone',
    TOTP: 'totp'
};
/**
 * Enumeration of supported providers.
 *
 * @public
 */
const ProviderId = {
    /** Facebook provider ID */
    FACEBOOK: 'facebook.com',
    /** GitHub provider ID */
    GITHUB: 'github.com',
    /** Google provider ID */
    GOOGLE: 'google.com',
    /** Password provider */
    PASSWORD: 'password',
    /** Phone provider */
    PHONE: 'phone',
    /** Twitter provider ID */
    TWITTER: 'twitter.com'
};
/**
 * Enumeration of supported sign-in methods.
 *
 * @public
 */
const SignInMethod = {
    /** Email link sign in method */
    EMAIL_LINK: 'emailLink',
    /** Email/password sign in method */
    EMAIL_PASSWORD: 'password',
    /** Facebook sign in method */
    FACEBOOK: 'facebook.com',
    /** GitHub sign in method */
    GITHUB: 'github.com',
    /** Google sign in method */
    GOOGLE: 'google.com',
    /** Phone sign in method */
    PHONE: 'phone',
    /** Twitter sign in method */
    TWITTER: 'twitter.com'
};
/**
 * Enumeration of supported operation types.
 *
 * @public
 */
const OperationType = {
    /** Operation involving linking an additional provider to an already signed-in user. */
    LINK: 'link',
    /** Operation involving using a provider to reauthenticate an already signed-in user. */
    REAUTHENTICATE: 'reauthenticate',
    /** Operation involving signing in a user. */
    SIGN_IN: 'signIn'
};
/**
 * An enumeration of the possible email action types.
 *
 * @public
 */
const ActionCodeOperation = {
    /** The email link sign-in action. */
    EMAIL_SIGNIN: 'EMAIL_SIGNIN',
    /** The password reset action. */
    PASSWORD_RESET: 'PASSWORD_RESET',
    /** The email revocation action. */
    RECOVER_EMAIL: 'RECOVER_EMAIL',
    /** The revert second factor addition email action. */
    REVERT_SECOND_FACTOR_ADDITION: 'REVERT_SECOND_FACTOR_ADDITION',
    /** The revert second factor addition email action. */
    VERIFY_AND_CHANGE_EMAIL: 'VERIFY_AND_CHANGE_EMAIL',
    /** The email verification action. */
    VERIFY_EMAIL: 'VERIFY_EMAIL'
};

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _debugErrorMap() {
    return {
        ["admin-restricted-operation" /* AuthErrorCode.ADMIN_ONLY_OPERATION */]: 'This operation is restricted to administrators only.',
        ["argument-error" /* AuthErrorCode.ARGUMENT_ERROR */]: '',
        ["app-not-authorized" /* AuthErrorCode.APP_NOT_AUTHORIZED */]: "This app, identified by the domain where it's hosted, is not " +
            'authorized to use Firebase Authentication with the provided API key. ' +
            'Review your key configuration in the Google API console.',
        ["app-not-installed" /* AuthErrorCode.APP_NOT_INSTALLED */]: 'The requested mobile application corresponding to the identifier (' +
            'Android package name or iOS bundle ID) provided is not installed on ' +
            'this device.',
        ["captcha-check-failed" /* AuthErrorCode.CAPTCHA_CHECK_FAILED */]: 'The reCAPTCHA response token provided is either invalid, expired, ' +
            'already used or the domain associated with it does not match the list ' +
            'of whitelisted domains.',
        ["code-expired" /* AuthErrorCode.CODE_EXPIRED */]: 'The SMS code has expired. Please re-send the verification code to try ' +
            'again.',
        ["cordova-not-ready" /* AuthErrorCode.CORDOVA_NOT_READY */]: 'Cordova framework is not ready.',
        ["cors-unsupported" /* AuthErrorCode.CORS_UNSUPPORTED */]: 'This browser is not supported.',
        ["credential-already-in-use" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */]: 'This credential is already associated with a different user account.',
        ["custom-token-mismatch" /* AuthErrorCode.CREDENTIAL_MISMATCH */]: 'The custom token corresponds to a different audience.',
        ["requires-recent-login" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: 'This operation is sensitive and requires recent authentication. Log in ' +
            'again before retrying this request.',
        ["dependent-sdk-initialized-before-auth" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +
            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +
            'starting any other Firebase SDK.',
        ["dynamic-link-not-activated" /* AuthErrorCode.DYNAMIC_LINK_NOT_ACTIVATED */]: 'Please activate Dynamic Links in the Firebase Console and agree to the terms and ' +
            'conditions.',
        ["email-change-needs-verification" /* AuthErrorCode.EMAIL_CHANGE_NEEDS_VERIFICATION */]: 'Multi-factor users must always have a verified email.',
        ["email-already-in-use" /* AuthErrorCode.EMAIL_EXISTS */]: 'The email address is already in use by another account.',
        ["emulator-config-failed" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */]: 'Auth instance has already been used to make a network call. Auth can ' +
            'no longer be configured to use the emulator. Try calling ' +
            '"connectAuthEmulator()" sooner.',
        ["expired-action-code" /* AuthErrorCode.EXPIRED_OOB_CODE */]: 'The action code has expired.',
        ["cancelled-popup-request" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */]: 'This operation has been cancelled due to another conflicting popup being opened.',
        ["internal-error" /* AuthErrorCode.INTERNAL_ERROR */]: 'An internal AuthError has occurred.',
        ["invalid-app-credential" /* AuthErrorCode.INVALID_APP_CREDENTIAL */]: 'The phone verification request contains an invalid application verifier.' +
            ' The reCAPTCHA token response is either invalid or expired.',
        ["invalid-app-id" /* AuthErrorCode.INVALID_APP_ID */]: 'The mobile app identifier is not registed for the current project.',
        ["invalid-user-token" /* AuthErrorCode.INVALID_AUTH */]: "This user's credential isn't valid for this project. This can happen " +
            "if the user's token has been tampered with, or if the user isn't for " +
            'the project associated with this API key.',
        ["invalid-auth-event" /* AuthErrorCode.INVALID_AUTH_EVENT */]: 'An internal AuthError has occurred.',
        ["invalid-verification-code" /* AuthErrorCode.INVALID_CODE */]: 'The SMS verification code used to create the phone auth credential is ' +
            'invalid. Please resend the verification code sms and be sure to use the ' +
            'verification code provided by the user.',
        ["invalid-continue-uri" /* AuthErrorCode.INVALID_CONTINUE_URI */]: 'The continue URL provided in the request is invalid.',
        ["invalid-cordova-configuration" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */]: 'The following Cordova plugins must be installed to enable OAuth sign-in: ' +
            'cordova-plugin-buildinfo, cordova-universal-links-plugin, ' +
            'cordova-plugin-browsertab, cordova-plugin-inappbrowser and ' +
            'cordova-plugin-customurlscheme.',
        ["invalid-custom-token" /* AuthErrorCode.INVALID_CUSTOM_TOKEN */]: 'The custom token format is incorrect. Please check the documentation.',
        ["invalid-dynamic-link-domain" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */]: 'The provided dynamic link domain is not configured or authorized for the current project.',
        ["invalid-email" /* AuthErrorCode.INVALID_EMAIL */]: 'The email address is badly formatted.',
        ["invalid-emulator-scheme" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */]: 'Emulator URL must start with a valid scheme (http:// or https://).',
        ["invalid-api-key" /* AuthErrorCode.INVALID_API_KEY */]: 'Your API key is invalid, please check you have copied it correctly.',
        ["invalid-cert-hash" /* AuthErrorCode.INVALID_CERT_HASH */]: 'The SHA-1 certificate hash provided is invalid.',
        ["invalid-credential" /* AuthErrorCode.INVALID_IDP_RESPONSE */]: 'The supplied auth credential is malformed or has expired.',
        ["invalid-message-payload" /* AuthErrorCode.INVALID_MESSAGE_PAYLOAD */]: 'The email template corresponding to this action contains invalid characters in its message. ' +
            'Please fix by going to the Auth email templates section in the Firebase Console.',
        ["invalid-multi-factor-session" /* AuthErrorCode.INVALID_MFA_SESSION */]: 'The request does not contain a valid proof of first factor successful sign-in.',
        ["invalid-oauth-provider" /* AuthErrorCode.INVALID_OAUTH_PROVIDER */]: 'EmailAuthProvider is not supported for this operation. This operation ' +
            'only supports OAuth providers.',
        ["invalid-oauth-client-id" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */]: 'The OAuth client ID provided is either invalid or does not match the ' +
            'specified API key.',
        ["unauthorized-domain" /* AuthErrorCode.INVALID_ORIGIN */]: 'This domain is not authorized for OAuth operations for your Firebase ' +
            'project. Edit the list of authorized domains from the Firebase console.',
        ["invalid-action-code" /* AuthErrorCode.INVALID_OOB_CODE */]: 'The action code is invalid. This can happen if the code is malformed, ' +
            'expired, or has already been used.',
        ["wrong-password" /* AuthErrorCode.INVALID_PASSWORD */]: 'The password is invalid or the user does not have a password.',
        ["invalid-persistence-type" /* AuthErrorCode.INVALID_PERSISTENCE */]: 'The specified persistence type is invalid. It can only be local, session or none.',
        ["invalid-phone-number" /* AuthErrorCode.INVALID_PHONE_NUMBER */]: 'The format of the phone number provided is incorrect. Please enter the ' +
            'phone number in a format that can be parsed into E.164 format. E.164 ' +
            'phone numbers are written in the format [+][country code][subscriber ' +
            'number including area code].',
        ["invalid-provider-id" /* AuthErrorCode.INVALID_PROVIDER_ID */]: 'The specified provider ID is invalid.',
        ["invalid-recipient-email" /* AuthErrorCode.INVALID_RECIPIENT_EMAIL */]: 'The email corresponding to this action failed to send as the provided ' +
            'recipient email address is invalid.',
        ["invalid-sender" /* AuthErrorCode.INVALID_SENDER */]: 'The email template corresponding to this action contains an invalid sender email or name. ' +
            'Please fix by going to the Auth email templates section in the Firebase Console.',
        ["invalid-verification-id" /* AuthErrorCode.INVALID_SESSION_INFO */]: 'The verification ID used to create the phone auth credential is invalid.',
        ["invalid-tenant-id" /* AuthErrorCode.INVALID_TENANT_ID */]: "The Auth instance's tenant ID is invalid.",
        ["login-blocked" /* AuthErrorCode.LOGIN_BLOCKED */]: 'Login blocked by user-provided method: {$originalMessage}',
        ["missing-android-pkg-name" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */]: 'An Android Package Name must be provided if the Android App is required to be installed.',
        ["auth-domain-config-required" /* AuthErrorCode.MISSING_AUTH_DOMAIN */]: 'Be sure to include authDomain when calling firebase.initializeApp(), ' +
            'by following the instructions in the Firebase console.',
        ["missing-app-credential" /* AuthErrorCode.MISSING_APP_CREDENTIAL */]: 'The phone verification request is missing an application verifier ' +
            'assertion. A reCAPTCHA response token needs to be provided.',
        ["missing-verification-code" /* AuthErrorCode.MISSING_CODE */]: 'The phone auth credential was created with an empty SMS verification code.',
        ["missing-continue-uri" /* AuthErrorCode.MISSING_CONTINUE_URI */]: 'A continue URL must be provided in the request.',
        ["missing-iframe-start" /* AuthErrorCode.MISSING_IFRAME_START */]: 'An internal AuthError has occurred.',
        ["missing-ios-bundle-id" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */]: 'An iOS Bundle ID must be provided if an App Store ID is provided.',
        ["missing-or-invalid-nonce" /* AuthErrorCode.MISSING_OR_INVALID_NONCE */]: 'The request does not contain a valid nonce. This can occur if the ' +
            'SHA-256 hash of the provided raw nonce does not match the hashed nonce ' +
            'in the ID token payload.',
        ["missing-password" /* AuthErrorCode.MISSING_PASSWORD */]: 'A non-empty password must be provided',
        ["missing-multi-factor-info" /* AuthErrorCode.MISSING_MFA_INFO */]: 'No second factor identifier is provided.',
        ["missing-multi-factor-session" /* AuthErrorCode.MISSING_MFA_SESSION */]: 'The request is missing proof of first factor successful sign-in.',
        ["missing-phone-number" /* AuthErrorCode.MISSING_PHONE_NUMBER */]: 'To send verification codes, provide a phone number for the recipient.',
        ["missing-verification-id" /* AuthErrorCode.MISSING_SESSION_INFO */]: 'The phone auth credential was created with an empty verification ID.',
        ["app-deleted" /* AuthErrorCode.MODULE_DESTROYED */]: 'This instance of FirebaseApp has been deleted.',
        ["multi-factor-info-not-found" /* AuthErrorCode.MFA_INFO_NOT_FOUND */]: 'The user does not have a second factor matching the identifier provided.',
        ["multi-factor-auth-required" /* AuthErrorCode.MFA_REQUIRED */]: 'Proof of ownership of a second factor is required to complete sign-in.',
        ["account-exists-with-different-credential" /* AuthErrorCode.NEED_CONFIRMATION */]: 'An account already exists with the same email address but different ' +
            'sign-in credentials. Sign in using a provider associated with this ' +
            'email address.',
        ["network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */]: 'A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.',
        ["no-auth-event" /* AuthErrorCode.NO_AUTH_EVENT */]: 'An internal AuthError has occurred.',
        ["no-such-provider" /* AuthErrorCode.NO_SUCH_PROVIDER */]: 'User was not linked to an account with the given provider.',
        ["null-user" /* AuthErrorCode.NULL_USER */]: 'A null user object was provided as the argument for an operation which ' +
            'requires a non-null user object.',
        ["operation-not-allowed" /* AuthErrorCode.OPERATION_NOT_ALLOWED */]: 'The given sign-in provider is disabled for this Firebase project. ' +
            'Enable it in the Firebase console, under the sign-in method tab of the ' +
            'Auth section.',
        ["operation-not-supported-in-this-environment" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */]: 'This operation is not supported in the environment this application is ' +
            'running on. "location.protocol" must be http, https or chrome-extension' +
            ' and web storage must be enabled.',
        ["popup-blocked" /* AuthErrorCode.POPUP_BLOCKED */]: 'Unable to establish a connection with the popup. It may have been blocked by the browser.',
        ["popup-closed-by-user" /* AuthErrorCode.POPUP_CLOSED_BY_USER */]: 'The popup has been closed by the user before finalizing the operation.',
        ["provider-already-linked" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */]: 'User can only be linked to one identity for the given provider.',
        ["quota-exceeded" /* AuthErrorCode.QUOTA_EXCEEDED */]: "The project's quota for this operation has been exceeded.",
        ["redirect-cancelled-by-user" /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */]: 'The redirect operation has been cancelled by the user before finalizing.',
        ["redirect-operation-pending" /* AuthErrorCode.REDIRECT_OPERATION_PENDING */]: 'A redirect sign-in operation is already pending.',
        ["rejected-credential" /* AuthErrorCode.REJECTED_CREDENTIAL */]: 'The request contains malformed or mismatching credentials.',
        ["second-factor-already-in-use" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */]: 'The second factor is already enrolled on this account.',
        ["maximum-second-factor-count-exceeded" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */]: 'The maximum allowed number of second factors on a user has been exceeded.',
        ["tenant-id-mismatch" /* AuthErrorCode.TENANT_ID_MISMATCH */]: "The provided tenant ID does not match the Auth instance's tenant ID",
        ["timeout" /* AuthErrorCode.TIMEOUT */]: 'The operation has timed out.',
        ["user-token-expired" /* AuthErrorCode.TOKEN_EXPIRED */]: "The user's credential is no longer valid. The user must sign in again.",
        ["too-many-requests" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */]: 'We have blocked all requests from this device due to unusual activity. ' +
            'Try again later.',
        ["unauthorized-continue-uri" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */]: 'The domain of the continue URL is not whitelisted.  Please whitelist ' +
            'the domain in the Firebase console.',
        ["unsupported-first-factor" /* AuthErrorCode.UNSUPPORTED_FIRST_FACTOR */]: 'Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.',
        ["unsupported-persistence-type" /* AuthErrorCode.UNSUPPORTED_PERSISTENCE */]: 'The current environment does not support the specified persistence type.',
        ["unsupported-tenant-operation" /* AuthErrorCode.UNSUPPORTED_TENANT_OPERATION */]: 'This operation is not supported in a multi-tenant context.',
        ["unverified-email" /* AuthErrorCode.UNVERIFIED_EMAIL */]: 'The operation requires a verified email.',
        ["user-cancelled" /* AuthErrorCode.USER_CANCELLED */]: 'The user did not grant your application the permissions it requested.',
        ["user-not-found" /* AuthErrorCode.USER_DELETED */]: 'There is no user record corresponding to this identifier. The user may ' +
            'have been deleted.',
        ["user-disabled" /* AuthErrorCode.USER_DISABLED */]: 'The user account has been disabled by an administrator.',
        ["user-mismatch" /* AuthErrorCode.USER_MISMATCH */]: 'The supplied credentials do not correspond to the previously signed in user.',
        ["user-signed-out" /* AuthErrorCode.USER_SIGNED_OUT */]: '',
        ["weak-password" /* AuthErrorCode.WEAK_PASSWORD */]: 'The password must be 6 characters long or more.',
        ["web-storage-unsupported" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */]: 'This browser is not supported or 3rd party cookies and data may be disabled.',
        ["already-initialized" /* AuthErrorCode.ALREADY_INITIALIZED */]: 'initializeAuth() has already been called with ' +
            'different options. To avoid this error, call initializeAuth() with the ' +
            'same options as when it was originally called, or call getAuth() to return the' +
            ' already initialized instance.',
        ["missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is missing when sending request to the backend.',
        ["invalid-recaptcha-token" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is invalid when sending request to the backend.',
        ["invalid-recaptcha-action" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */]: 'The reCAPTCHA action is invalid when sending request to the backend.',
        ["recaptcha-not-enabled" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */]: 'reCAPTCHA Enterprise integration is not enabled for this project.',
        ["missing-client-type" /* AuthErrorCode.MISSING_CLIENT_TYPE */]: 'The reCAPTCHA client type is missing when sending request to the backend.',
        ["missing-recaptcha-version" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is missing when sending request to the backend.',
        ["invalid-req-type" /* AuthErrorCode.INVALID_REQ_TYPE */]: 'Invalid request parameters.',
        ["invalid-recaptcha-version" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is invalid when sending request to the backend.'
    };
}
function _prodErrorMap() {
    // We will include this one message in the prod error map since by the very
    // nature of this error, developers will never be able to see the message
    // using the debugErrorMap (which is installed during auth initialization).
    return {
        ["dependent-sdk-initialized-before-auth" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +
            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +
            'starting any other Firebase SDK.'
    };
}
/**
 * A verbose error map with detailed descriptions for most error codes.
 *
 * See discussion at {@link AuthErrorMap}
 *
 * @public
 */
const debugErrorMap = (/* unused pure expression or super */ null && (_debugErrorMap));
/**
 * A minimal error map with all verbose error messages stripped.
 *
 * See discussion at {@link AuthErrorMap}
 *
 * @public
 */
const prodErrorMap = _prodErrorMap;
const _DEFAULT_AUTH_ERROR_FACTORY = new ErrorFactory('auth', 'Firebase', _prodErrorMap());
/**
 * A map of potential `Auth` error codes, for easier comparison with errors
 * thrown by the SDK.
 *
 * @remarks
 * Note that you can't tree-shake individual keys
 * in the map, so by using the map you might substantially increase your
 * bundle size.
 *
 * @public
 */
const AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {
    ADMIN_ONLY_OPERATION: 'auth/admin-restricted-operation',
    ARGUMENT_ERROR: 'auth/argument-error',
    APP_NOT_AUTHORIZED: 'auth/app-not-authorized',
    APP_NOT_INSTALLED: 'auth/app-not-installed',
    CAPTCHA_CHECK_FAILED: 'auth/captcha-check-failed',
    CODE_EXPIRED: 'auth/code-expired',
    CORDOVA_NOT_READY: 'auth/cordova-not-ready',
    CORS_UNSUPPORTED: 'auth/cors-unsupported',
    CREDENTIAL_ALREADY_IN_USE: 'auth/credential-already-in-use',
    CREDENTIAL_MISMATCH: 'auth/custom-token-mismatch',
    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'auth/requires-recent-login',
    DEPENDENT_SDK_INIT_BEFORE_AUTH: 'auth/dependent-sdk-initialized-before-auth',
    DYNAMIC_LINK_NOT_ACTIVATED: 'auth/dynamic-link-not-activated',
    EMAIL_CHANGE_NEEDS_VERIFICATION: 'auth/email-change-needs-verification',
    EMAIL_EXISTS: 'auth/email-already-in-use',
    EMULATOR_CONFIG_FAILED: 'auth/emulator-config-failed',
    EXPIRED_OOB_CODE: 'auth/expired-action-code',
    EXPIRED_POPUP_REQUEST: 'auth/cancelled-popup-request',
    INTERNAL_ERROR: 'auth/internal-error',
    INVALID_API_KEY: 'auth/invalid-api-key',
    INVALID_APP_CREDENTIAL: 'auth/invalid-app-credential',
    INVALID_APP_ID: 'auth/invalid-app-id',
    INVALID_AUTH: 'auth/invalid-user-token',
    INVALID_AUTH_EVENT: 'auth/invalid-auth-event',
    INVALID_CERT_HASH: 'auth/invalid-cert-hash',
    INVALID_CODE: 'auth/invalid-verification-code',
    INVALID_CONTINUE_URI: 'auth/invalid-continue-uri',
    INVALID_CORDOVA_CONFIGURATION: 'auth/invalid-cordova-configuration',
    INVALID_CUSTOM_TOKEN: 'auth/invalid-custom-token',
    INVALID_DYNAMIC_LINK_DOMAIN: 'auth/invalid-dynamic-link-domain',
    INVALID_EMAIL: 'auth/invalid-email',
    INVALID_EMULATOR_SCHEME: 'auth/invalid-emulator-scheme',
    INVALID_IDP_RESPONSE: 'auth/invalid-credential',
    INVALID_MESSAGE_PAYLOAD: 'auth/invalid-message-payload',
    INVALID_MFA_SESSION: 'auth/invalid-multi-factor-session',
    INVALID_OAUTH_CLIENT_ID: 'auth/invalid-oauth-client-id',
    INVALID_OAUTH_PROVIDER: 'auth/invalid-oauth-provider',
    INVALID_OOB_CODE: 'auth/invalid-action-code',
    INVALID_ORIGIN: 'auth/unauthorized-domain',
    INVALID_PASSWORD: 'auth/wrong-password',
    INVALID_PERSISTENCE: 'auth/invalid-persistence-type',
    INVALID_PHONE_NUMBER: 'auth/invalid-phone-number',
    INVALID_PROVIDER_ID: 'auth/invalid-provider-id',
    INVALID_RECIPIENT_EMAIL: 'auth/invalid-recipient-email',
    INVALID_SENDER: 'auth/invalid-sender',
    INVALID_SESSION_INFO: 'auth/invalid-verification-id',
    INVALID_TENANT_ID: 'auth/invalid-tenant-id',
    MFA_INFO_NOT_FOUND: 'auth/multi-factor-info-not-found',
    MFA_REQUIRED: 'auth/multi-factor-auth-required',
    MISSING_ANDROID_PACKAGE_NAME: 'auth/missing-android-pkg-name',
    MISSING_APP_CREDENTIAL: 'auth/missing-app-credential',
    MISSING_AUTH_DOMAIN: 'auth/auth-domain-config-required',
    MISSING_CODE: 'auth/missing-verification-code',
    MISSING_CONTINUE_URI: 'auth/missing-continue-uri',
    MISSING_IFRAME_START: 'auth/missing-iframe-start',
    MISSING_IOS_BUNDLE_ID: 'auth/missing-ios-bundle-id',
    MISSING_OR_INVALID_NONCE: 'auth/missing-or-invalid-nonce',
    MISSING_MFA_INFO: 'auth/missing-multi-factor-info',
    MISSING_MFA_SESSION: 'auth/missing-multi-factor-session',
    MISSING_PHONE_NUMBER: 'auth/missing-phone-number',
    MISSING_SESSION_INFO: 'auth/missing-verification-id',
    MODULE_DESTROYED: 'auth/app-deleted',
    NEED_CONFIRMATION: 'auth/account-exists-with-different-credential',
    NETWORK_REQUEST_FAILED: 'auth/network-request-failed',
    NULL_USER: 'auth/null-user',
    NO_AUTH_EVENT: 'auth/no-auth-event',
    NO_SUCH_PROVIDER: 'auth/no-such-provider',
    OPERATION_NOT_ALLOWED: 'auth/operation-not-allowed',
    OPERATION_NOT_SUPPORTED: 'auth/operation-not-supported-in-this-environment',
    POPUP_BLOCKED: 'auth/popup-blocked',
    POPUP_CLOSED_BY_USER: 'auth/popup-closed-by-user',
    PROVIDER_ALREADY_LINKED: 'auth/provider-already-linked',
    QUOTA_EXCEEDED: 'auth/quota-exceeded',
    REDIRECT_CANCELLED_BY_USER: 'auth/redirect-cancelled-by-user',
    REDIRECT_OPERATION_PENDING: 'auth/redirect-operation-pending',
    REJECTED_CREDENTIAL: 'auth/rejected-credential',
    SECOND_FACTOR_ALREADY_ENROLLED: 'auth/second-factor-already-in-use',
    SECOND_FACTOR_LIMIT_EXCEEDED: 'auth/maximum-second-factor-count-exceeded',
    TENANT_ID_MISMATCH: 'auth/tenant-id-mismatch',
    TIMEOUT: 'auth/timeout',
    TOKEN_EXPIRED: 'auth/user-token-expired',
    TOO_MANY_ATTEMPTS_TRY_LATER: 'auth/too-many-requests',
    UNAUTHORIZED_DOMAIN: 'auth/unauthorized-continue-uri',
    UNSUPPORTED_FIRST_FACTOR: 'auth/unsupported-first-factor',
    UNSUPPORTED_PERSISTENCE: 'auth/unsupported-persistence-type',
    UNSUPPORTED_TENANT_OPERATION: 'auth/unsupported-tenant-operation',
    UNVERIFIED_EMAIL: 'auth/unverified-email',
    USER_CANCELLED: 'auth/user-cancelled',
    USER_DELETED: 'auth/user-not-found',
    USER_DISABLED: 'auth/user-disabled',
    USER_MISMATCH: 'auth/user-mismatch',
    USER_SIGNED_OUT: 'auth/user-signed-out',
    WEAK_PASSWORD: 'auth/weak-password',
    WEB_STORAGE_UNSUPPORTED: 'auth/web-storage-unsupported',
    ALREADY_INITIALIZED: 'auth/already-initialized',
    RECAPTCHA_NOT_ENABLED: 'auth/recaptcha-not-enabled',
    MISSING_RECAPTCHA_TOKEN: 'auth/missing-recaptcha-token',
    INVALID_RECAPTCHA_TOKEN: 'auth/invalid-recaptcha-token',
    INVALID_RECAPTCHA_ACTION: 'auth/invalid-recaptcha-action',
    MISSING_CLIENT_TYPE: 'auth/missing-client-type',
    MISSING_RECAPTCHA_VERSION: 'auth/missing-recaptcha-version',
    INVALID_RECAPTCHA_VERSION: 'auth/invalid-recaptcha-version',
    INVALID_REQ_TYPE: 'auth/invalid-req-type'
};

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logClient = new Logger('@firebase/auth');
function _logWarn(msg, ...args) {
    if (logClient.logLevel <= LogLevel.WARN) {
        logClient.warn(`Auth (${SDK_VERSION}): ${msg}`, ...args);
    }
}
function _logError(msg, ...args) {
    if (logClient.logLevel <= LogLevel.ERROR) {
        logClient.error(`Auth (${SDK_VERSION}): ${msg}`, ...args);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _fail(authOrCode, ...rest) {
    throw createErrorInternal(authOrCode, ...rest);
}
function _createError(authOrCode, ...rest) {
    return createErrorInternal(authOrCode, ...rest);
}
function _errorWithCustomMessage(auth, code, message) {
    const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message });
    const factory = new ErrorFactory('auth', 'Firebase', errorMap);
    return factory.create(code, {
        appName: auth.name
    });
}
function _assertInstanceOf(auth, object, instance) {
    const constructorInstance = instance;
    if (!(object instanceof constructorInstance)) {
        if (constructorInstance.name !== object.constructor.name) {
            _fail(auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        }
        throw _errorWithCustomMessage(auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */, `Type of ${object.constructor.name} does not match expected instance.` +
            `Did you pass a reference from a different Auth SDK?`);
    }
}
function createErrorInternal(authOrCode, ...rest) {
    if (typeof authOrCode !== 'string') {
        const code = rest[0];
        const fullParams = [...rest.slice(1)];
        if (fullParams[0]) {
            fullParams[0].appName = authOrCode.name;
        }
        return authOrCode._errorFactory.create(code, ...fullParams);
    }
    return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);
}
function _assert(assertion, authOrCode, ...rest) {
    if (!assertion) {
        throw createErrorInternal(authOrCode, ...rest);
    }
}
/**
 * Unconditionally fails, throwing an internal error with the given message.
 *
 * @param failure type of failure encountered
 * @throws Error
 */
function debugFail(failure) {
    // Log the failure in addition to throw an exception, just in case the
    // exception is swallowed.
    const message = `INTERNAL ASSERTION FAILED: ` + failure;
    _logError(message);
    // NOTE: We don't use FirebaseError here because these are internal failures
    // that cannot be handled by the user. (Also it would create a circular
    // dependency between the error and assert modules which doesn't work.)
    throw new Error(message);
}
/**
 * Fails if the given assertion condition is false, throwing an Error with the
 * given message if it did.
 *
 * @param assertion
 * @param message
 */
function debugAssert(assertion, message) {
    if (!assertion) {
        debugFail(message);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getCurrentUrl() {
    var _a;
    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href)) || '';
}
function _isHttpOrHttps() {
    return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';
}
function _getCurrentScheme() {
    var _a;
    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol)) || null;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Determine whether the browser is working online
 */
function _isOnline() {
    if (typeof navigator !== 'undefined' &&
        navigator &&
        'onLine' in navigator &&
        typeof navigator.onLine === 'boolean' &&
        // Apply only for traditional web apps and Chrome extensions.
        // This is especially true for Cordova apps which have unreliable
        // navigator.onLine behavior unless cordova-plugin-network-information is
        // installed which overwrites the native navigator.onLine value and
        // defines navigator.connection.
        (_isHttpOrHttps() || isBrowserExtension() || 'connection' in navigator)) {
        return navigator.onLine;
    }
    // If we can't determine the state, assume it is online.
    return true;
}
function _getUserLanguage() {
    if (typeof navigator === 'undefined') {
        return null;
    }
    const navigatorLanguage = navigator;
    return (
    // Most reliable, but only supported in Chrome/Firefox.
    (navigatorLanguage.languages && navigatorLanguage.languages[0]) ||
        // Supported in most browsers, but returns the language of the browser
        // UI, not the language set in browser settings.
        navigatorLanguage.language ||
        // Couldn't determine language.
        null);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A structure to help pick between a range of long and short delay durations
 * depending on the current environment. In general, the long delay is used for
 * mobile environments whereas short delays are used for desktop environments.
 */
class Delay {
    constructor(shortDelay, longDelay) {
        this.shortDelay = shortDelay;
        this.longDelay = longDelay;
        // Internal error when improperly initialized.
        debugAssert(longDelay > shortDelay, 'Short delay should be less than long delay!');
        this.isMobile = isMobileCordova() || isReactNative();
    }
    get() {
        if (!_isOnline()) {
            // Pick the shorter timeout.
            return Math.min(5000 /* DelayMin.OFFLINE */, this.shortDelay);
        }
        // If running in a mobile environment, return the long delay, otherwise
        // return the short delay.
        // This could be improved in the future to dynamically change based on other
        // variables instead of just reading the current environment.
        return this.isMobile ? this.longDelay : this.shortDelay;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _emulatorUrl(config, path) {
    debugAssert(config.emulator, 'Emulator should always be set here');
    const { url } = config.emulator;
    if (!path) {
        return url;
    }
    return `${url}${path.startsWith('/') ? path.slice(1) : path}`;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FetchProvider {
    static initialize(fetchImpl, headersImpl, responseImpl) {
        this.fetchImpl = fetchImpl;
        if (headersImpl) {
            this.headersImpl = headersImpl;
        }
        if (responseImpl) {
            this.responseImpl = responseImpl;
        }
    }
    static fetch() {
        if (this.fetchImpl) {
            return this.fetchImpl;
        }
        if (typeof self !== 'undefined' && 'fetch' in self) {
            return self.fetch;
        }
        debugFail('Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');
    }
    static headers() {
        if (this.headersImpl) {
            return this.headersImpl;
        }
        if (typeof self !== 'undefined' && 'Headers' in self) {
            return self.Headers;
        }
        debugFail('Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');
    }
    static response() {
        if (this.responseImpl) {
            return this.responseImpl;
        }
        if (typeof self !== 'undefined' && 'Response' in self) {
            return self.Response;
        }
        debugFail('Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Map from errors returned by the server to errors to developer visible errors
 */
const SERVER_ERROR_MAP = {
    // Custom token errors.
    ["CREDENTIAL_MISMATCH" /* ServerError.CREDENTIAL_MISMATCH */]: "custom-token-mismatch" /* AuthErrorCode.CREDENTIAL_MISMATCH */,
    // This can only happen if the SDK sends a bad request.
    ["MISSING_CUSTOM_TOKEN" /* ServerError.MISSING_CUSTOM_TOKEN */]: "internal-error" /* AuthErrorCode.INTERNAL_ERROR */,
    // Create Auth URI errors.
    ["INVALID_IDENTIFIER" /* ServerError.INVALID_IDENTIFIER */]: "invalid-email" /* AuthErrorCode.INVALID_EMAIL */,
    // This can only happen if the SDK sends a bad request.
    ["MISSING_CONTINUE_URI" /* ServerError.MISSING_CONTINUE_URI */]: "internal-error" /* AuthErrorCode.INTERNAL_ERROR */,
    // Sign in with email and password errors (some apply to sign up too).
    ["INVALID_PASSWORD" /* ServerError.INVALID_PASSWORD */]: "wrong-password" /* AuthErrorCode.INVALID_PASSWORD */,
    // This can only happen if the SDK sends a bad request.
    ["MISSING_PASSWORD" /* ServerError.MISSING_PASSWORD */]: "missing-password" /* AuthErrorCode.MISSING_PASSWORD */,
    // Sign up with email and password errors.
    ["EMAIL_EXISTS" /* ServerError.EMAIL_EXISTS */]: "email-already-in-use" /* AuthErrorCode.EMAIL_EXISTS */,
    ["PASSWORD_LOGIN_DISABLED" /* ServerError.PASSWORD_LOGIN_DISABLED */]: "operation-not-allowed" /* AuthErrorCode.OPERATION_NOT_ALLOWED */,
    // Verify assertion for sign in with credential errors:
    ["INVALID_IDP_RESPONSE" /* ServerError.INVALID_IDP_RESPONSE */]: "invalid-credential" /* AuthErrorCode.INVALID_IDP_RESPONSE */,
    ["INVALID_PENDING_TOKEN" /* ServerError.INVALID_PENDING_TOKEN */]: "invalid-credential" /* AuthErrorCode.INVALID_IDP_RESPONSE */,
    ["FEDERATED_USER_ID_ALREADY_LINKED" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */]: "credential-already-in-use" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */,
    // This can only happen if the SDK sends a bad request.
    ["MISSING_REQ_TYPE" /* ServerError.MISSING_REQ_TYPE */]: "internal-error" /* AuthErrorCode.INTERNAL_ERROR */,
    // Send Password reset email errors:
    ["EMAIL_NOT_FOUND" /* ServerError.EMAIL_NOT_FOUND */]: "user-not-found" /* AuthErrorCode.USER_DELETED */,
    ["RESET_PASSWORD_EXCEED_LIMIT" /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */]: "too-many-requests" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,
    ["EXPIRED_OOB_CODE" /* ServerError.EXPIRED_OOB_CODE */]: "expired-action-code" /* AuthErrorCode.EXPIRED_OOB_CODE */,
    ["INVALID_OOB_CODE" /* ServerError.INVALID_OOB_CODE */]: "invalid-action-code" /* AuthErrorCode.INVALID_OOB_CODE */,
    // This can only happen if the SDK sends a bad request.
    ["MISSING_OOB_CODE" /* ServerError.MISSING_OOB_CODE */]: "internal-error" /* AuthErrorCode.INTERNAL_ERROR */,
    // Operations that require ID token in request:
    ["CREDENTIAL_TOO_OLD_LOGIN_AGAIN" /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: "requires-recent-login" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */,
    ["INVALID_ID_TOKEN" /* ServerError.INVALID_ID_TOKEN */]: "invalid-user-token" /* AuthErrorCode.INVALID_AUTH */,
    ["TOKEN_EXPIRED" /* ServerError.TOKEN_EXPIRED */]: "user-token-expired" /* AuthErrorCode.TOKEN_EXPIRED */,
    ["USER_NOT_FOUND" /* ServerError.USER_NOT_FOUND */]: "user-token-expired" /* AuthErrorCode.TOKEN_EXPIRED */,
    // Other errors.
    ["TOO_MANY_ATTEMPTS_TRY_LATER" /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */]: "too-many-requests" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,
    // Phone Auth related errors.
    ["INVALID_CODE" /* ServerError.INVALID_CODE */]: "invalid-verification-code" /* AuthErrorCode.INVALID_CODE */,
    ["INVALID_SESSION_INFO" /* ServerError.INVALID_SESSION_INFO */]: "invalid-verification-id" /* AuthErrorCode.INVALID_SESSION_INFO */,
    ["INVALID_TEMPORARY_PROOF" /* ServerError.INVALID_TEMPORARY_PROOF */]: "invalid-credential" /* AuthErrorCode.INVALID_IDP_RESPONSE */,
    ["MISSING_SESSION_INFO" /* ServerError.MISSING_SESSION_INFO */]: "missing-verification-id" /* AuthErrorCode.MISSING_SESSION_INFO */,
    ["SESSION_EXPIRED" /* ServerError.SESSION_EXPIRED */]: "code-expired" /* AuthErrorCode.CODE_EXPIRED */,
    // Other action code errors when additional settings passed.
    // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.
    // This is OK as this error will be caught by client side validation.
    ["MISSING_ANDROID_PACKAGE_NAME" /* ServerError.MISSING_ANDROID_PACKAGE_NAME */]: "missing-android-pkg-name" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */,
    ["UNAUTHORIZED_DOMAIN" /* ServerError.UNAUTHORIZED_DOMAIN */]: "unauthorized-continue-uri" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */,
    // getProjectConfig errors when clientId is passed.
    ["INVALID_OAUTH_CLIENT_ID" /* ServerError.INVALID_OAUTH_CLIENT_ID */]: "invalid-oauth-client-id" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */,
    // User actions (sign-up or deletion) disabled errors.
    ["ADMIN_ONLY_OPERATION" /* ServerError.ADMIN_ONLY_OPERATION */]: "admin-restricted-operation" /* AuthErrorCode.ADMIN_ONLY_OPERATION */,
    // Multi factor related errors.
    ["INVALID_MFA_PENDING_CREDENTIAL" /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */]: "invalid-multi-factor-session" /* AuthErrorCode.INVALID_MFA_SESSION */,
    ["MFA_ENROLLMENT_NOT_FOUND" /* ServerError.MFA_ENROLLMENT_NOT_FOUND */]: "multi-factor-info-not-found" /* AuthErrorCode.MFA_INFO_NOT_FOUND */,
    ["MISSING_MFA_ENROLLMENT_ID" /* ServerError.MISSING_MFA_ENROLLMENT_ID */]: "missing-multi-factor-info" /* AuthErrorCode.MISSING_MFA_INFO */,
    ["MISSING_MFA_PENDING_CREDENTIAL" /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */]: "missing-multi-factor-session" /* AuthErrorCode.MISSING_MFA_SESSION */,
    ["SECOND_FACTOR_EXISTS" /* ServerError.SECOND_FACTOR_EXISTS */]: "second-factor-already-in-use" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */,
    ["SECOND_FACTOR_LIMIT_EXCEEDED" /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */]: "maximum-second-factor-count-exceeded" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */,
    // Blocking functions related errors.
    ["BLOCKING_FUNCTION_ERROR_RESPONSE" /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */]: "internal-error" /* AuthErrorCode.INTERNAL_ERROR */,
    // Recaptcha related errors.
    ["RECAPTCHA_NOT_ENABLED" /* ServerError.RECAPTCHA_NOT_ENABLED */]: "recaptcha-not-enabled" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */,
    ["MISSING_RECAPTCHA_TOKEN" /* ServerError.MISSING_RECAPTCHA_TOKEN */]: "missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */,
    ["INVALID_RECAPTCHA_TOKEN" /* ServerError.INVALID_RECAPTCHA_TOKEN */]: "invalid-recaptcha-token" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */,
    ["INVALID_RECAPTCHA_ACTION" /* ServerError.INVALID_RECAPTCHA_ACTION */]: "invalid-recaptcha-action" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */,
    ["MISSING_CLIENT_TYPE" /* ServerError.MISSING_CLIENT_TYPE */]: "missing-client-type" /* AuthErrorCode.MISSING_CLIENT_TYPE */,
    ["MISSING_RECAPTCHA_VERSION" /* ServerError.MISSING_RECAPTCHA_VERSION */]: "missing-recaptcha-version" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */,
    ["INVALID_RECAPTCHA_VERSION" /* ServerError.INVALID_RECAPTCHA_VERSION */]: "invalid-recaptcha-version" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */,
    ["INVALID_REQ_TYPE" /* ServerError.INVALID_REQ_TYPE */]: "invalid-req-type" /* AuthErrorCode.INVALID_REQ_TYPE */
};

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_API_TIMEOUT_MS = new Delay(30000, 60000);
function _addTidIfNecessary(auth, request) {
    if (auth.tenantId && !request.tenantId) {
        return Object.assign(Object.assign({}, request), { tenantId: auth.tenantId });
    }
    return request;
}
async function _performApiRequest(auth, method, path, request, customErrorMap = {}) {
    return _performFetchWithErrorHandling(auth, customErrorMap, async () => {
        let body = {};
        let params = {};
        if (request) {
            if (method === "GET" /* HttpMethod.GET */) {
                params = request;
            }
            else {
                body = {
                    body: JSON.stringify(request)
                };
            }
        }
        const query = index_esm2017_querystring(Object.assign({ key: auth.config.apiKey }, params)).slice(1);
        const headers = await auth._getAdditionalHeaders();
        headers["Content-Type" /* HttpHeader.CONTENT_TYPE */] = 'application/json';
        if (auth.languageCode) {
            headers["X-Firebase-Locale" /* HttpHeader.X_FIREBASE_LOCALE */] = auth.languageCode;
        }
        return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), Object.assign({ method,
            headers, referrerPolicy: 'no-referrer' }, body));
    });
}
async function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {
    auth._canInitEmulator = false;
    const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);
    try {
        const networkTimeout = new NetworkTimeout(auth);
        const response = await Promise.race([
            fetchFn(),
            networkTimeout.promise
        ]);
        // If we've reached this point, the fetch succeeded and the networkTimeout
        // didn't throw; clear the network timeout delay so that Node won't hang
        networkTimeout.clearNetworkTimeout();
        const json = await response.json();
        if ('needConfirmation' in json) {
            throw _makeTaggedError(auth, "account-exists-with-different-credential" /* AuthErrorCode.NEED_CONFIRMATION */, json);
        }
        if (response.ok && !('errorMessage' in json)) {
            return json;
        }
        else {
            const errorMessage = response.ok ? json.errorMessage : json.error.message;
            const [serverErrorCode, serverErrorMessage] = errorMessage.split(' : ');
            if (serverErrorCode === "FEDERATED_USER_ID_ALREADY_LINKED" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */) {
                throw _makeTaggedError(auth, "credential-already-in-use" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */, json);
            }
            else if (serverErrorCode === "EMAIL_EXISTS" /* ServerError.EMAIL_EXISTS */) {
                throw _makeTaggedError(auth, "email-already-in-use" /* AuthErrorCode.EMAIL_EXISTS */, json);
            }
            else if (serverErrorCode === "USER_DISABLED" /* ServerError.USER_DISABLED */) {
                throw _makeTaggedError(auth, "user-disabled" /* AuthErrorCode.USER_DISABLED */, json);
            }
            const authError = errorMap[serverErrorCode] ||
                serverErrorCode
                    .toLowerCase()
                    .replace(/[_\s]+/g, '-');
            if (serverErrorMessage) {
                throw _errorWithCustomMessage(auth, authError, serverErrorMessage);
            }
            else {
                _fail(auth, authError);
            }
        }
    }
    catch (e) {
        if (e instanceof FirebaseError) {
            throw e;
        }
        // Changing this to a different error code will log user out when there is a network error
        // because we treat any error other than NETWORK_REQUEST_FAILED as token is invalid.
        // https://github.com/firebase/firebase-js-sdk/blob/4fbc73610d70be4e0852e7de63a39cb7897e8546/packages/auth/src/core/auth/auth_impl.ts#L309-L316
        _fail(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */, { 'message': String(e) });
    }
}
async function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {
    const serverResponse = (await _performApiRequest(auth, method, path, request, customErrorMap));
    if ('mfaPendingCredential' in serverResponse) {
        _fail(auth, "multi-factor-auth-required" /* AuthErrorCode.MFA_REQUIRED */, {
            _serverResponse: serverResponse
        });
    }
    return serverResponse;
}
function _getFinalTarget(auth, host, path, query) {
    const base = `${host}${path}?${query}`;
    if (!auth.config.emulator) {
        return `${auth.config.apiScheme}://${base}`;
    }
    return _emulatorUrl(auth.config, base);
}
class NetworkTimeout {
    constructor(auth) {
        this.auth = auth;
        // Node timers and browser timers are fundamentally incompatible, but we
        // don't care about the value here
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.timer = null;
        this.promise = new Promise((_, reject) => {
            this.timer = setTimeout(() => {
                return reject(_createError(this.auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));
            }, DEFAULT_API_TIMEOUT_MS.get());
        });
    }
    clearNetworkTimeout() {
        clearTimeout(this.timer);
    }
}
function _makeTaggedError(auth, code, response) {
    const errorParams = {
        appName: auth.name
    };
    if (response.email) {
        errorParams.email = response.email;
    }
    if (response.phoneNumber) {
        errorParams.phoneNumber = response.phoneNumber;
    }
    const error = _createError(auth, code, errorParams);
    // We know customData is defined on error because errorParams is defined
    error.customData._tokenResponse = response;
    return error;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function deleteAccount(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:delete" /* Endpoint.DELETE_ACCOUNT */, request);
}
async function deleteLinkedAccounts(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:update" /* Endpoint.SET_ACCOUNT_INFO */, request);
}
async function getAccountInfo(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:lookup" /* Endpoint.GET_ACCOUNT_INFO */, request);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function utcTimestampToDateString(utcTimestamp) {
    if (!utcTimestamp) {
        return undefined;
    }
    try {
        // Convert to date object.
        const date = new Date(Number(utcTimestamp));
        // Test date is valid.
        if (!isNaN(date.getTime())) {
            // Convert to UTC date string.
            return date.toUTCString();
        }
    }
    catch (e) {
        // Do nothing. undefined will be returned.
    }
    return undefined;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service.
 *
 * @remarks
 * Returns the current token if it has not expired or if it will not expire in the next five
 * minutes. Otherwise, this will refresh the token and return a new one.
 *
 * @param user - The user.
 * @param forceRefresh - Force refresh regardless of token expiration.
 *
 * @public
 */
function getIdToken(user, forceRefresh = false) {
    return getModularInstance(user).getIdToken(forceRefresh);
}
/**
 * Returns a deserialized JSON Web Token (JWT) used to identify the user to a Firebase service.
 *
 * @remarks
 * Returns the current token if it has not expired or if it will not expire in the next five
 * minutes. Otherwise, this will refresh the token and return a new one.
 *
 * @param user - The user.
 * @param forceRefresh - Force refresh regardless of token expiration.
 *
 * @public
 */
async function getIdTokenResult(user, forceRefresh = false) {
    const userInternal = index_esm2017_getModularInstance(user);
    const token = await userInternal.getIdToken(forceRefresh);
    const claims = _parseToken(token);
    _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    const firebase = typeof claims.firebase === 'object' ? claims.firebase : undefined;
    const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_provider'];
    return {
        claims,
        token,
        authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),
        issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),
        expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),
        signInProvider: signInProvider || null,
        signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_second_factor']) || null
    };
}
function secondsStringToMilliseconds(seconds) {
    return Number(seconds) * 1000;
}
function _parseToken(token) {
    const [algorithm, payload, signature] = token.split('.');
    if (algorithm === undefined ||
        payload === undefined ||
        signature === undefined) {
        _logError('JWT malformed, contained fewer than 3 sections');
        return null;
    }
    try {
        const decoded = base64Decode(payload);
        if (!decoded) {
            _logError('Failed to decode base64 JWT payload');
            return null;
        }
        return JSON.parse(decoded);
    }
    catch (e) {
        _logError('Caught error parsing JWT payload as JSON', e === null || e === void 0 ? void 0 : e.toString());
        return null;
    }
}
/**
 * Extract expiresIn TTL from a token by subtracting the expiration from the issuance.
 */
function _tokenExpiresIn(token) {
    const parsedToken = _parseToken(token);
    _assert(parsedToken, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    _assert(typeof parsedToken.exp !== 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    _assert(typeof parsedToken.iat !== 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    return Number(parsedToken.exp) - Number(parsedToken.iat);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _logoutIfInvalidated(user, promise, bypassAuthState = false) {
    if (bypassAuthState) {
        return promise;
    }
    try {
        return await promise;
    }
    catch (e) {
        if (e instanceof FirebaseError && isUserInvalidated(e)) {
            if (user.auth.currentUser === user) {
                await user.auth.signOut();
            }
        }
        throw e;
    }
}
function isUserInvalidated({ code }) {
    return (code === `auth/${"user-disabled" /* AuthErrorCode.USER_DISABLED */}` ||
        code === `auth/${"user-token-expired" /* AuthErrorCode.TOKEN_EXPIRED */}`);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProactiveRefresh {
    constructor(user) {
        this.user = user;
        this.isRunning = false;
        // Node timers and browser timers return fundamentally different types.
        // We don't actually care what the value is but TS won't accept unknown and
        // we can't cast properly in both environments.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.timerId = null;
        this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;
    }
    _start() {
        if (this.isRunning) {
            return;
        }
        this.isRunning = true;
        this.schedule();
    }
    _stop() {
        if (!this.isRunning) {
            return;
        }
        this.isRunning = false;
        if (this.timerId !== null) {
            clearTimeout(this.timerId);
        }
    }
    getInterval(wasError) {
        var _a;
        if (wasError) {
            const interval = this.errorBackoff;
            this.errorBackoff = Math.min(this.errorBackoff * 2, 960000 /* Duration.RETRY_BACKOFF_MAX */);
            return interval;
        }
        else {
            // Reset the error backoff
            this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;
            const expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;
            const interval = expTime - Date.now() - 300000 /* Duration.OFFSET */;
            return Math.max(0, interval);
        }
    }
    schedule(wasError = false) {
        if (!this.isRunning) {
            // Just in case...
            return;
        }
        const interval = this.getInterval(wasError);
        this.timerId = setTimeout(async () => {
            await this.iteration();
        }, interval);
    }
    async iteration() {
        try {
            await this.user.getIdToken(true);
        }
        catch (e) {
            // Only retry on network errors
            if ((e === null || e === void 0 ? void 0 : e.code) ===
                `auth/${"network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {
                this.schedule(/* wasError */ true);
            }
            return;
        }
        this.schedule();
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserMetadata {
    constructor(createdAt, lastLoginAt) {
        this.createdAt = createdAt;
        this.lastLoginAt = lastLoginAt;
        this._initializeTime();
    }
    _initializeTime() {
        this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);
        this.creationTime = utcTimestampToDateString(this.createdAt);
    }
    _copy(metadata) {
        this.createdAt = metadata.createdAt;
        this.lastLoginAt = metadata.lastLoginAt;
        this._initializeTime();
    }
    toJSON() {
        return {
            createdAt: this.createdAt,
            lastLoginAt: this.lastLoginAt
        };
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _reloadWithoutSaving(user) {
    var _a;
    const auth = user.auth;
    const idToken = await user.getIdToken();
    const response = await _logoutIfInvalidated(user, getAccountInfo(auth, { idToken }));
    _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    const coreAccount = response.users[0];
    user._notifyReloadListener(coreAccount);
    const newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length)
        ? extractProviderData(coreAccount.providerUserInfo)
        : [];
    const providerData = mergeProviderData(user.providerData, newProviderData);
    // Preserves the non-nonymous status of the stored user, even if no more
    // credentials (federated or email/password) are linked to the user. If
    // the user was previously anonymous, then use provider data to update.
    // On the other hand, if it was not anonymous before, it should never be
    // considered anonymous now.
    const oldIsAnonymous = user.isAnonymous;
    const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
    const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;
    const updates = {
        uid: coreAccount.localId,
        displayName: coreAccount.displayName || null,
        photoURL: coreAccount.photoUrl || null,
        email: coreAccount.email || null,
        emailVerified: coreAccount.emailVerified || false,
        phoneNumber: coreAccount.phoneNumber || null,
        tenantId: coreAccount.tenantId || null,
        providerData,
        metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
        isAnonymous
    };
    Object.assign(user, updates);
}
/**
 * Reloads user account data, if signed in.
 *
 * @param user - The user.
 *
 * @public
 */
async function reload(user) {
    const userInternal = index_esm2017_getModularInstance(user);
    await _reloadWithoutSaving(userInternal);
    // Even though the current user hasn't changed, update
    // current user will trigger a persistence update w/ the
    // new info.
    await userInternal.auth._persistUserIfCurrent(userInternal);
    userInternal.auth._notifyListenersIfCurrent(userInternal);
}
function mergeProviderData(original, newData) {
    const deduped = original.filter(o => !newData.some(n => n.providerId === o.providerId));
    return [...deduped, ...newData];
}
function extractProviderData(providers) {
    return providers.map((_a) => {
        var { providerId } = _a, provider = __rest(_a, ["providerId"]);
        return {
            providerId,
            uid: provider.rawId || '',
            displayName: provider.displayName || null,
            email: provider.email || null,
            phoneNumber: provider.phoneNumber || null,
            photoURL: provider.photoUrl || null
        };
    });
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function requestStsToken(auth, refreshToken) {
    const response = await _performFetchWithErrorHandling(auth, {}, async () => {
        const body = index_esm2017_querystring({
            'grant_type': 'refresh_token',
            'refresh_token': refreshToken
        }).slice(1);
        const { tokenApiHost, apiKey } = auth.config;
        const url = _getFinalTarget(auth, tokenApiHost, "/v1/token" /* Endpoint.TOKEN */, `key=${apiKey}`);
        const headers = await auth._getAdditionalHeaders();
        headers["Content-Type" /* HttpHeader.CONTENT_TYPE */] = 'application/x-www-form-urlencoded';
        return FetchProvider.fetch()(url, {
            method: "POST" /* HttpMethod.POST */,
            headers,
            body
        });
    });
    // The response comes back in snake_case. Convert to camel:
    return {
        accessToken: response.access_token,
        expiresIn: response.expires_in,
        refreshToken: response.refresh_token
    };
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * We need to mark this class as internal explicitly to exclude it in the public typings, because
 * it references AuthInternal which has a circular dependency with UserInternal.
 *
 * @internal
 */
class StsTokenManager {
    constructor() {
        this.refreshToken = null;
        this.accessToken = null;
        this.expirationTime = null;
    }
    get isExpired() {
        return (!this.expirationTime ||
            Date.now() > this.expirationTime - 30000 /* Buffer.TOKEN_REFRESH */);
    }
    updateFromServerResponse(response) {
        _assert(response.idToken, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        _assert(typeof response.idToken !== 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        _assert(typeof response.refreshToken !== 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const expiresIn = 'expiresIn' in response && typeof response.expiresIn !== 'undefined'
            ? Number(response.expiresIn)
            : _tokenExpiresIn(response.idToken);
        this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);
    }
    async getToken(auth, forceRefresh = false) {
        _assert(!this.accessToken || this.refreshToken, auth, "user-token-expired" /* AuthErrorCode.TOKEN_EXPIRED */);
        if (!forceRefresh && this.accessToken && !this.isExpired) {
            return this.accessToken;
        }
        if (this.refreshToken) {
            await this.refresh(auth, this.refreshToken);
            return this.accessToken;
        }
        return null;
    }
    clearRefreshToken() {
        this.refreshToken = null;
    }
    async refresh(auth, oldToken) {
        const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);
        this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));
    }
    updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {
        this.refreshToken = refreshToken || null;
        this.accessToken = accessToken || null;
        this.expirationTime = Date.now() + expiresInSec * 1000;
    }
    static fromJSON(appName, object) {
        const { refreshToken, accessToken, expirationTime } = object;
        const manager = new StsTokenManager();
        if (refreshToken) {
            _assert(typeof refreshToken === 'string', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */, {
                appName
            });
            manager.refreshToken = refreshToken;
        }
        if (accessToken) {
            _assert(typeof accessToken === 'string', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */, {
                appName
            });
            manager.accessToken = accessToken;
        }
        if (expirationTime) {
            _assert(typeof expirationTime === 'number', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */, {
                appName
            });
            manager.expirationTime = expirationTime;
        }
        return manager;
    }
    toJSON() {
        return {
            refreshToken: this.refreshToken,
            accessToken: this.accessToken,
            expirationTime: this.expirationTime
        };
    }
    _assign(stsTokenManager) {
        this.accessToken = stsTokenManager.accessToken;
        this.refreshToken = stsTokenManager.refreshToken;
        this.expirationTime = stsTokenManager.expirationTime;
    }
    _clone() {
        return Object.assign(new StsTokenManager(), this.toJSON());
    }
    _performRefresh() {
        return debugFail('not implemented');
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function assertStringOrUndefined(assertion, appName) {
    _assert(typeof assertion === 'string' || typeof assertion === 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */, { appName });
}
class UserImpl {
    constructor(_a) {
        var { uid, auth, stsTokenManager } = _a, opt = __rest(_a, ["uid", "auth", "stsTokenManager"]);
        // For the user object, provider is always Firebase.
        this.providerId = "firebase" /* ProviderId.FIREBASE */;
        this.proactiveRefresh = new ProactiveRefresh(this);
        this.reloadUserInfo = null;
        this.reloadListener = null;
        this.uid = uid;
        this.auth = auth;
        this.stsTokenManager = stsTokenManager;
        this.accessToken = stsTokenManager.accessToken;
        this.displayName = opt.displayName || null;
        this.email = opt.email || null;
        this.emailVerified = opt.emailVerified || false;
        this.phoneNumber = opt.phoneNumber || null;
        this.photoURL = opt.photoURL || null;
        this.isAnonymous = opt.isAnonymous || false;
        this.tenantId = opt.tenantId || null;
        this.providerData = opt.providerData ? [...opt.providerData] : [];
        this.metadata = new UserMetadata(opt.createdAt || undefined, opt.lastLoginAt || undefined);
    }
    async getIdToken(forceRefresh) {
        const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));
        _assert(accessToken, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        if (this.accessToken !== accessToken) {
            this.accessToken = accessToken;
            await this.auth._persistUserIfCurrent(this);
            this.auth._notifyListenersIfCurrent(this);
        }
        return accessToken;
    }
    getIdTokenResult(forceRefresh) {
        return getIdTokenResult(this, forceRefresh);
    }
    reload() {
        return reload(this);
    }
    _assign(user) {
        if (this === user) {
            return;
        }
        _assert(this.uid === user.uid, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        this.displayName = user.displayName;
        this.photoURL = user.photoURL;
        this.email = user.email;
        this.emailVerified = user.emailVerified;
        this.phoneNumber = user.phoneNumber;
        this.isAnonymous = user.isAnonymous;
        this.tenantId = user.tenantId;
        this.providerData = user.providerData.map(userInfo => (Object.assign({}, userInfo)));
        this.metadata._copy(user.metadata);
        this.stsTokenManager._assign(user.stsTokenManager);
    }
    _clone(auth) {
        const newUser = new UserImpl(Object.assign(Object.assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));
        newUser.metadata._copy(this.metadata);
        return newUser;
    }
    _onReload(callback) {
        // There should only ever be one listener, and that is a single instance of MultiFactorUser
        _assert(!this.reloadListener, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        this.reloadListener = callback;
        if (this.reloadUserInfo) {
            this._notifyReloadListener(this.reloadUserInfo);
            this.reloadUserInfo = null;
        }
    }
    _notifyReloadListener(userInfo) {
        if (this.reloadListener) {
            this.reloadListener(userInfo);
        }
        else {
            // If no listener is subscribed yet, save the result so it's available when they do subscribe
            this.reloadUserInfo = userInfo;
        }
    }
    _startProactiveRefresh() {
        this.proactiveRefresh._start();
    }
    _stopProactiveRefresh() {
        this.proactiveRefresh._stop();
    }
    async _updateTokensIfNecessary(response, reload = false) {
        let tokensRefreshed = false;
        if (response.idToken &&
            response.idToken !== this.stsTokenManager.accessToken) {
            this.stsTokenManager.updateFromServerResponse(response);
            tokensRefreshed = true;
        }
        if (reload) {
            await _reloadWithoutSaving(this);
        }
        await this.auth._persistUserIfCurrent(this);
        if (tokensRefreshed) {
            this.auth._notifyListenersIfCurrent(this);
        }
    }
    async delete() {
        const idToken = await this.getIdToken();
        await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));
        this.stsTokenManager.clearRefreshToken();
        // TODO: Determine if cancellable-promises are necessary to use in this class so that delete()
        //       cancels pending actions...
        return this.auth.signOut();
    }
    toJSON() {
        return Object.assign(Object.assign({ uid: this.uid, email: this.email || undefined, emailVerified: this.emailVerified, displayName: this.displayName || undefined, isAnonymous: this.isAnonymous, photoURL: this.photoURL || undefined, phoneNumber: this.phoneNumber || undefined, tenantId: this.tenantId || undefined, providerData: this.providerData.map(userInfo => (Object.assign({}, userInfo))), stsTokenManager: this.stsTokenManager.toJSON(), 
            // Redirect event ID must be maintained in case there is a pending
            // redirect event.
            _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { 
            // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):
            apiKey: this.auth.config.apiKey, appName: this.auth.name });
    }
    get refreshToken() {
        return this.stsTokenManager.refreshToken || '';
    }
    static _fromJSON(auth, object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : undefined;
        const email = (_b = object.email) !== null && _b !== void 0 ? _b : undefined;
        const phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : undefined;
        const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : undefined;
        const tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : undefined;
        const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : undefined;
        const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : undefined;
        const lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : undefined;
        const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;
        _assert(uid && plainObjectTokenManager, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);
        _assert(typeof uid === 'string', auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        assertStringOrUndefined(displayName, auth.name);
        assertStringOrUndefined(email, auth.name);
        _assert(typeof emailVerified === 'boolean', auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        _assert(typeof isAnonymous === 'boolean', auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        assertStringOrUndefined(phoneNumber, auth.name);
        assertStringOrUndefined(photoURL, auth.name);
        assertStringOrUndefined(tenantId, auth.name);
        assertStringOrUndefined(_redirectEventId, auth.name);
        assertStringOrUndefined(createdAt, auth.name);
        assertStringOrUndefined(lastLoginAt, auth.name);
        const user = new UserImpl({
            uid,
            auth,
            email,
            emailVerified,
            displayName,
            isAnonymous,
            photoURL,
            phoneNumber,
            tenantId,
            stsTokenManager,
            createdAt,
            lastLoginAt
        });
        if (providerData && Array.isArray(providerData)) {
            user.providerData = providerData.map(userInfo => (Object.assign({}, userInfo)));
        }
        if (_redirectEventId) {
            user._redirectEventId = _redirectEventId;
        }
        return user;
    }
    /**
     * Initialize a User from an idToken server response
     * @param auth
     * @param idTokenResponse
     */
    static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {
        const stsTokenManager = new StsTokenManager();
        stsTokenManager.updateFromServerResponse(idTokenResponse);
        // Initialize the Firebase Auth user.
        const user = new UserImpl({
            uid: idTokenResponse.localId,
            auth,
            stsTokenManager,
            isAnonymous
        });
        // Updates the user info and data and resolves with a user instance.
        await _reloadWithoutSaving(user);
        return user;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const instanceCache = new Map();
function _getInstance(cls) {
    debugAssert(cls instanceof Function, 'Expected a class definition');
    let instance = instanceCache.get(cls);
    if (instance) {
        debugAssert(instance instanceof cls, 'Instance stored in cache mismatched with class');
        return instance;
    }
    instance = new cls();
    instanceCache.set(cls, instance);
    return instance;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InMemoryPersistence {
    constructor() {
        this.type = "NONE" /* PersistenceType.NONE */;
        this.storage = {};
    }
    async _isAvailable() {
        return true;
    }
    async _set(key, value) {
        this.storage[key] = value;
    }
    async _get(key) {
        const value = this.storage[key];
        return value === undefined ? null : value;
    }
    async _remove(key) {
        delete this.storage[key];
    }
    _addListener(_key, _listener) {
        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers
        return;
    }
    _removeListener(_key, _listener) {
        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers
        return;
    }
}
InMemoryPersistence.type = 'NONE';
/**
 * An implementation of {@link Persistence} of type 'NONE'.
 *
 * @public
 */
const inMemoryPersistence = InMemoryPersistence;

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _persistenceKeyName(key, apiKey, appName) {
    return `${"firebase" /* Namespace.PERSISTENCE */}:${key}:${apiKey}:${appName}`;
}
class PersistenceUserManager {
    constructor(persistence, auth, userKey) {
        this.persistence = persistence;
        this.auth = auth;
        this.userKey = userKey;
        const { config, name } = this.auth;
        this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name);
        this.fullPersistenceKey = _persistenceKeyName("persistence" /* KeyName.PERSISTENCE_USER */, config.apiKey, name);
        this.boundEventHandler = auth._onStorageEvent.bind(auth);
        this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
    }
    setCurrentUser(user) {
        return this.persistence._set(this.fullUserKey, user.toJSON());
    }
    async getCurrentUser() {
        const blob = await this.persistence._get(this.fullUserKey);
        return blob ? UserImpl._fromJSON(this.auth, blob) : null;
    }
    removeCurrentUser() {
        return this.persistence._remove(this.fullUserKey);
    }
    savePersistenceForRedirect() {
        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
    }
    async setPersistence(newPersistence) {
        if (this.persistence === newPersistence) {
            return;
        }
        const currentUser = await this.getCurrentUser();
        await this.removeCurrentUser();
        this.persistence = newPersistence;
        if (currentUser) {
            return this.setCurrentUser(currentUser);
        }
    }
    delete() {
        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
    }
    static async create(auth, persistenceHierarchy, userKey = "authUser" /* KeyName.AUTH_USER */) {
        if (!persistenceHierarchy.length) {
            return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);
        }
        // Eliminate any persistences that are not available
        const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {
            if (await persistence._isAvailable()) {
                return persistence;
            }
            return undefined;
        }))).filter(persistence => persistence);
        // Fall back to the first persistence listed, or in memory if none available
        let selectedPersistence = availablePersistences[0] ||
            _getInstance(inMemoryPersistence);
        const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);
        // Pull out the existing user, setting the chosen persistence to that
        // persistence if the user exists.
        let userToMigrate = null;
        // Note, here we check for a user in _all_ persistences, not just the
        // ones deemed available. If we can migrate a user out of a broken
        // persistence, we will (but only if that persistence supports migration).
        for (const persistence of persistenceHierarchy) {
            try {
                const blob = await persistence._get(key);
                if (blob) {
                    const user = UserImpl._fromJSON(auth, blob); // throws for unparsable blob (wrong format)
                    if (persistence !== selectedPersistence) {
                        userToMigrate = user;
                    }
                    selectedPersistence = persistence;
                    break;
                }
            }
            catch (_a) { }
        }
        // If we find the user in a persistence that does support migration, use
        // that migration path (of only persistences that support migration)
        const migrationHierarchy = availablePersistences.filter(p => p._shouldAllowMigration);
        // If the persistence does _not_ allow migration, just finish off here
        if (!selectedPersistence._shouldAllowMigration ||
            !migrationHierarchy.length) {
            return new PersistenceUserManager(selectedPersistence, auth, userKey);
        }
        selectedPersistence = migrationHierarchy[0];
        if (userToMigrate) {
            // This normally shouldn't throw since chosenPersistence.isAvailable() is true, but if it does
            // we'll just let it bubble to surface the error.
            await selectedPersistence._set(key, userToMigrate.toJSON());
        }
        // Attempt to clear the key in other persistences but ignore errors. This helps prevent issues
        // such as users getting stuck with a previous account after signing out and refreshing the tab.
        await Promise.all(persistenceHierarchy.map(async (persistence) => {
            if (persistence !== selectedPersistence) {
                try {
                    await persistence._remove(key);
                }
                catch (_a) { }
            }
        }));
        return new PersistenceUserManager(selectedPersistence, auth, userKey);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Determine the browser for the purposes of reporting usage to the API
 */
function _getBrowserName(userAgent) {
    const ua = userAgent.toLowerCase();
    if (ua.includes('opera/') || ua.includes('opr/') || ua.includes('opios/')) {
        return "Opera" /* BrowserName.OPERA */;
    }
    else if (_isIEMobile(ua)) {
        // Windows phone IEMobile browser.
        return "IEMobile" /* BrowserName.IEMOBILE */;
    }
    else if (ua.includes('msie') || ua.includes('trident/')) {
        return "IE" /* BrowserName.IE */;
    }
    else if (ua.includes('edge/')) {
        return "Edge" /* BrowserName.EDGE */;
    }
    else if (_isFirefox(ua)) {
        return "Firefox" /* BrowserName.FIREFOX */;
    }
    else if (ua.includes('silk/')) {
        return "Silk" /* BrowserName.SILK */;
    }
    else if (_isBlackBerry(ua)) {
        // Blackberry browser.
        return "Blackberry" /* BrowserName.BLACKBERRY */;
    }
    else if (_isWebOS(ua)) {
        // WebOS default browser.
        return "Webos" /* BrowserName.WEBOS */;
    }
    else if (_isSafari(ua)) {
        return "Safari" /* BrowserName.SAFARI */;
    }
    else if ((ua.includes('chrome/') || _isChromeIOS(ua)) &&
        !ua.includes('edge/')) {
        return "Chrome" /* BrowserName.CHROME */;
    }
    else if (_isAndroid(ua)) {
        // Android stock browser.
        return "Android" /* BrowserName.ANDROID */;
    }
    else {
        // Most modern browsers have name/version at end of user agent string.
        const re = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/;
        const matches = userAgent.match(re);
        if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {
            return matches[1];
        }
    }
    return "Other" /* BrowserName.OTHER */;
}
function _isFirefox(ua = index_esm2017_getUA()) {
    return /firefox\//i.test(ua);
}
function _isSafari(userAgent = index_esm2017_getUA()) {
    const ua = userAgent.toLowerCase();
    return (ua.includes('safari/') &&
        !ua.includes('chrome/') &&
        !ua.includes('crios/') &&
        !ua.includes('android'));
}
function _isChromeIOS(ua = index_esm2017_getUA()) {
    return /crios\//i.test(ua);
}
function _isIEMobile(ua = index_esm2017_getUA()) {
    return /iemobile/i.test(ua);
}
function _isAndroid(ua = index_esm2017_getUA()) {
    return /android/i.test(ua);
}
function _isBlackBerry(ua = index_esm2017_getUA()) {
    return /blackberry/i.test(ua);
}
function _isWebOS(ua = index_esm2017_getUA()) {
    return /webos/i.test(ua);
}
function _isIOS(ua = index_esm2017_getUA()) {
    return (/iphone|ipad|ipod/i.test(ua) ||
        (/macintosh/i.test(ua) && /mobile/i.test(ua)));
}
function _isIOS7Or8(ua = getUA()) {
    return (/(iPad|iPhone|iPod).*OS 7_\d/i.test(ua) ||
        /(iPad|iPhone|iPod).*OS 8_\d/i.test(ua));
}
function _isIOSStandalone(ua = index_esm2017_getUA()) {
    var _a;
    return _isIOS(ua) && !!((_a = window.navigator) === null || _a === void 0 ? void 0 : _a.standalone);
}
function _isIE10() {
    return isIE() && document.documentMode === 10;
}
function _isMobileBrowser(ua = index_esm2017_getUA()) {
    // TODO: implement getBrowserName equivalent for OS.
    return (_isIOS(ua) ||
        _isAndroid(ua) ||
        _isWebOS(ua) ||
        _isBlackBerry(ua) ||
        /windows phone/i.test(ua) ||
        _isIEMobile(ua));
}
function _isIframe() {
    try {
        // Check that the current window is not the top window.
        // If so, return true.
        return !!(window && window !== window.top);
    }
    catch (e) {
        return false;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Determine the SDK version string
 */
function _getClientVersion(clientPlatform, frameworks = []) {
    let reportedPlatform;
    switch (clientPlatform) {
        case "Browser" /* ClientPlatform.BROWSER */:
            // In a browser environment, report the browser name.
            reportedPlatform = _getBrowserName(index_esm2017_getUA());
            break;
        case "Worker" /* ClientPlatform.WORKER */:
            // Technically a worker runs from a browser but we need to differentiate a
            // worker from a browser.
            // For example: Chrome-Worker/JsCore/4.9.1/FirebaseCore-web.
            reportedPlatform = `${_getBrowserName(index_esm2017_getUA())}-${clientPlatform}`;
            break;
        default:
            reportedPlatform = clientPlatform;
    }
    const reportedFrameworks = frameworks.length
        ? frameworks.join(',')
        : 'FirebaseCore-web'; /* default value if no other framework is used */
    return `${reportedPlatform}/${"JsCore" /* ClientImplementation.CORE */}/${SDK_VERSION}/${reportedFrameworks}`;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getRecaptchaParams(auth) {
    return ((await _performApiRequest(auth, "GET" /* HttpMethod.GET */, "/v1/recaptchaParams" /* Endpoint.GET_RECAPTCHA_PARAM */)).recaptchaSiteKey || '');
}
async function getRecaptchaConfig(auth, request) {
    return _performApiRequest(auth, "GET" /* HttpMethod.GET */, "/v2/recaptchaConfig" /* Endpoint.GET_RECAPTCHA_CONFIG */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isV2(grecaptcha) {
    return (grecaptcha !== undefined &&
        grecaptcha.getResponse !== undefined);
}
function isEnterprise(grecaptcha) {
    return (grecaptcha !== undefined &&
        grecaptcha.enterprise !== undefined);
}
class RecaptchaConfig {
    constructor(response) {
        /**
         * The reCAPTCHA site key.
         */
        this.siteKey = '';
        /**
         * The reCAPTCHA enablement status of the {@link EmailAuthProvider} for the current tenant.
         */
        this.emailPasswordEnabled = false;
        if (response.recaptchaKey === undefined) {
            throw new Error('recaptchaKey undefined');
        }
        // Example response.recaptchaKey: "projects/proj123/keys/sitekey123"
        this.siteKey = response.recaptchaKey.split('/')[3];
        this.emailPasswordEnabled = response.recaptchaEnforcementState.some(enforcementState => enforcementState.provider === 'EMAIL_PASSWORD_PROVIDER' &&
            enforcementState.enforcementState !== 'OFF');
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getScriptParentElement() {
    var _a, _b;
    return (_b = (_a = document.getElementsByTagName('head')) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : document;
}
function _loadJS(url) {
    // TODO: consider adding timeout support & cancellation
    return new Promise((resolve, reject) => {
        const el = document.createElement('script');
        el.setAttribute('src', url);
        el.onload = resolve;
        el.onerror = e => {
            const error = _createError("internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
            error.customData = e;
            reject(error);
        };
        el.type = 'text/javascript';
        el.charset = 'UTF-8';
        getScriptParentElement().appendChild(el);
    });
}
function _generateCallbackName(prefix) {
    return `__${prefix}${Math.floor(Math.random() * 1000000)}`;
}

/* eslint-disable @typescript-eslint/no-require-imports */
const RECAPTCHA_ENTERPRISE_URL = 'https://www.google.com/recaptcha/enterprise.js?render=';
const RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = 'recaptcha-enterprise';
const FAKE_TOKEN = 'NO_RECAPTCHA';
class RecaptchaEnterpriseVerifier {
    /**
     *
     * @param authExtern - The corresponding Firebase {@link Auth} instance.
     *
     */
    constructor(authExtern) {
        /**
         * Identifies the type of application verifier (e.g. "recaptcha-enterprise").
         */
        this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;
        this.auth = _castAuth(authExtern);
    }
    /**
     * Executes the verification process.
     *
     * @returns A Promise for a token that can be used to assert the validity of a request.
     */
    async verify(action = 'verify', forceRefresh = false) {
        async function retrieveSiteKey(auth) {
            if (!forceRefresh) {
                if (auth.tenantId == null && auth._agentRecaptchaConfig != null) {
                    return auth._agentRecaptchaConfig.siteKey;
                }
                if (auth.tenantId != null &&
                    auth._tenantRecaptchaConfigs[auth.tenantId] !== undefined) {
                    return auth._tenantRecaptchaConfigs[auth.tenantId].siteKey;
                }
            }
            return new Promise(async (resolve, reject) => {
                getRecaptchaConfig(auth, {
                    clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */,
                    version: "RECAPTCHA_ENTERPRISE" /* RecaptchaVersion.ENTERPRISE */
                })
                    .then(response => {
                    if (response.recaptchaKey === undefined) {
                        reject(new Error('recaptcha Enterprise site key undefined'));
                    }
                    else {
                        const config = new RecaptchaConfig(response);
                        if (auth.tenantId == null) {
                            auth._agentRecaptchaConfig = config;
                        }
                        else {
                            auth._tenantRecaptchaConfigs[auth.tenantId] = config;
                        }
                        return resolve(config.siteKey);
                    }
                })
                    .catch(error => {
                    reject(error);
                });
            });
        }
        function retrieveRecaptchaToken(siteKey, resolve, reject) {
            const grecaptcha = window.grecaptcha;
            if (isEnterprise(grecaptcha)) {
                grecaptcha.enterprise.ready(() => {
                    grecaptcha.enterprise
                        .execute(siteKey, { action })
                        .then(token => {
                        resolve(token);
                    })
                        .catch(() => {
                        resolve(FAKE_TOKEN);
                    });
                });
            }
            else {
                reject(Error('No reCAPTCHA enterprise script loaded.'));
            }
        }
        return new Promise((resolve, reject) => {
            retrieveSiteKey(this.auth)
                .then(siteKey => {
                if (!forceRefresh && isEnterprise(window.grecaptcha)) {
                    retrieveRecaptchaToken(siteKey, resolve, reject);
                }
                else {
                    if (typeof window === 'undefined') {
                        reject(new Error('RecaptchaVerifier is only supported in browser'));
                        return;
                    }
                    _loadJS(RECAPTCHA_ENTERPRISE_URL + siteKey)
                        .then(() => {
                        retrieveRecaptchaToken(siteKey, resolve, reject);
                    })
                        .catch(error => {
                        reject(error);
                    });
                }
            })
                .catch(error => {
                reject(error);
            });
        });
    }
}
async function injectRecaptchaFields(auth, request, action, captchaResp = false) {
    const verifier = new RecaptchaEnterpriseVerifier(auth);
    let captchaResponse;
    try {
        captchaResponse = await verifier.verify(action);
    }
    catch (error) {
        captchaResponse = await verifier.verify(action, true);
    }
    const newRequest = Object.assign({}, request);
    if (!captchaResp) {
        Object.assign(newRequest, { captchaResponse });
    }
    else {
        Object.assign(newRequest, { 'captchaResp': captchaResponse });
    }
    Object.assign(newRequest, { 'clientType': "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */ });
    Object.assign(newRequest, {
        'recaptchaVersion': "RECAPTCHA_ENTERPRISE" /* RecaptchaVersion.ENTERPRISE */
    });
    return newRequest;
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthMiddlewareQueue {
    constructor(auth) {
        this.auth = auth;
        this.queue = [];
    }
    pushCallback(callback, onAbort) {
        // The callback could be sync or async. Wrap it into a
        // function that is always async.
        const wrappedCallback = (user) => new Promise((resolve, reject) => {
            try {
                const result = callback(user);
                // Either resolve with existing promise or wrap a non-promise
                // return value into a promise.
                resolve(result);
            }
            catch (e) {
                // Sync callback throws.
                reject(e);
            }
        });
        // Attach the onAbort if present
        wrappedCallback.onAbort = onAbort;
        this.queue.push(wrappedCallback);
        const index = this.queue.length - 1;
        return () => {
            // Unsubscribe. Replace with no-op. Do not remove from array, or it will disturb
            // indexing of other elements.
            this.queue[index] = () => Promise.resolve();
        };
    }
    async runMiddleware(nextUser) {
        if (this.auth.currentUser === nextUser) {
            return;
        }
        // While running the middleware, build a temporary stack of onAbort
        // callbacks to call if one middleware callback rejects.
        const onAbortStack = [];
        try {
            for (const beforeStateCallback of this.queue) {
                await beforeStateCallback(nextUser);
                // Only push the onAbort if the callback succeeds
                if (beforeStateCallback.onAbort) {
                    onAbortStack.push(beforeStateCallback.onAbort);
                }
            }
        }
        catch (e) {
            // Run all onAbort, with separate try/catch to ignore any errors and
            // continue
            onAbortStack.reverse();
            for (const onAbort of onAbortStack) {
                try {
                    onAbort();
                }
                catch (_) {
                    /* swallow error */
                }
            }
            throw this.auth._errorFactory.create("login-blocked" /* AuthErrorCode.LOGIN_BLOCKED */, {
                originalMessage: e === null || e === void 0 ? void 0 : e.message
            });
        }
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthImpl {
    constructor(app, heartbeatServiceProvider, appCheckServiceProvider, config) {
        this.app = app;
        this.heartbeatServiceProvider = heartbeatServiceProvider;
        this.appCheckServiceProvider = appCheckServiceProvider;
        this.config = config;
        this.currentUser = null;
        this.emulatorConfig = null;
        this.operations = Promise.resolve();
        this.authStateSubscription = new Subscription(this);
        this.idTokenSubscription = new Subscription(this);
        this.beforeStateQueue = new AuthMiddlewareQueue(this);
        this.redirectUser = null;
        this.isProactiveRefreshEnabled = false;
        // Any network calls will set this to true and prevent subsequent emulator
        // initialization
        this._canInitEmulator = true;
        this._isInitialized = false;
        this._deleted = false;
        this._initializationPromise = null;
        this._popupRedirectResolver = null;
        this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;
        this._agentRecaptchaConfig = null;
        this._tenantRecaptchaConfigs = {};
        // Tracks the last notified UID for state change listeners to prevent
        // repeated calls to the callbacks. Undefined means it's never been
        // called, whereas null means it's been called with a signed out user
        this.lastNotifiedUid = undefined;
        this.languageCode = null;
        this.tenantId = null;
        this.settings = { appVerificationDisabledForTesting: false };
        this.frameworks = [];
        this.name = app.name;
        this.clientVersion = config.sdkClientVersion;
    }
    _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {
        if (popupRedirectResolver) {
            this._popupRedirectResolver = _getInstance(popupRedirectResolver);
        }
        // Have to check for app deletion throughout initialization (after each
        // promise resolution)
        this._initializationPromise = this.queue(async () => {
            var _a, _b;
            if (this._deleted) {
                return;
            }
            this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);
            if (this._deleted) {
                return;
            }
            // Initialize the resolver early if necessary (only applicable to web:
            // this will cause the iframe to load immediately in certain cases)
            if ((_a = this._popupRedirectResolver) === null || _a === void 0 ? void 0 : _a._shouldInitProactively) {
                // If this fails, don't halt auth loading
                try {
                    await this._popupRedirectResolver._initialize(this);
                }
                catch (e) {
                    /* Ignore the error */
                }
            }
            await this.initializeCurrentUser(popupRedirectResolver);
            this.lastNotifiedUid = ((_b = this.currentUser) === null || _b === void 0 ? void 0 : _b.uid) || null;
            if (this._deleted) {
                return;
            }
            this._isInitialized = true;
        });
        return this._initializationPromise;
    }
    /**
     * If the persistence is changed in another window, the user manager will let us know
     */
    async _onStorageEvent() {
        if (this._deleted) {
            return;
        }
        const user = await this.assertedPersistence.getCurrentUser();
        if (!this.currentUser && !user) {
            // No change, do nothing (was signed out and remained signed out).
            return;
        }
        // If the same user is to be synchronized.
        if (this.currentUser && user && this.currentUser.uid === user.uid) {
            // Data update, simply copy data changes.
            this._currentUser._assign(user);
            // If tokens changed from previous user tokens, this will trigger
            // notifyAuthListeners_.
            await this.currentUser.getIdToken();
            return;
        }
        // Update current Auth state. Either a new login or logout.
        // Skip blocking callbacks, they should not apply to a change in another tab.
        await this._updateCurrentUser(user, /* skipBeforeStateCallbacks */ true);
    }
    async initializeCurrentUser(popupRedirectResolver) {
        var _a;
        // First check to see if we have a pending redirect event.
        const previouslyStoredUser = (await this.assertedPersistence.getCurrentUser());
        let futureCurrentUser = previouslyStoredUser;
        let needsTocheckMiddleware = false;
        if (popupRedirectResolver && this.config.authDomain) {
            await this.getOrInitRedirectPersistenceManager();
            const redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;
            const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;
            const result = await this.tryRedirectSignIn(popupRedirectResolver);
            // If the stored user (i.e. the old "currentUser") has a redirectId that
            // matches the redirect user, then we want to initially sign in with the
            // new user object from result.
            // TODO(samgho): More thoroughly test all of this
            if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) &&
                (result === null || result === void 0 ? void 0 : result.user)) {
                futureCurrentUser = result.user;
                needsTocheckMiddleware = true;
            }
        }
        // If no user in persistence, there is no current user. Set to null.
        if (!futureCurrentUser) {
            return this.directlySetCurrentUser(null);
        }
        if (!futureCurrentUser._redirectEventId) {
            // This isn't a redirect link operation, we can reload and bail.
            // First though, ensure that we check the middleware is happy.
            if (needsTocheckMiddleware) {
                try {
                    await this.beforeStateQueue.runMiddleware(futureCurrentUser);
                }
                catch (e) {
                    futureCurrentUser = previouslyStoredUser;
                    // We know this is available since the bit is only set when the
                    // resolver is available
                    this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(e));
                }
            }
            if (futureCurrentUser) {
                return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);
            }
            else {
                return this.directlySetCurrentUser(null);
            }
        }
        _assert(this._popupRedirectResolver, this, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        await this.getOrInitRedirectPersistenceManager();
        // If the redirect user's event ID matches the current user's event ID,
        // DO NOT reload the current user, otherwise they'll be cleared from storage.
        // This is important for the reauthenticateWithRedirect() flow.
        if (this.redirectUser &&
            this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {
            return this.directlySetCurrentUser(futureCurrentUser);
        }
        return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);
    }
    async tryRedirectSignIn(redirectResolver) {
        // The redirect user needs to be checked (and signed in if available)
        // during auth initialization. All of the normal sign in and link/reauth
        // flows call back into auth and push things onto the promise queue. We
        // need to await the result of the redirect sign in *inside the promise
        // queue*. This presents a problem: we run into deadlock. See:
        //    ┌> [Initialization] ─────┐
        //    ┌> [<other queue tasks>] │
        //    └─ [getRedirectResult] <─┘
        //    where [] are tasks on the queue and arrows denote awaits
        // Initialization will never complete because it's waiting on something
        // that's waiting for initialization to complete!
        //
        // Instead, this method calls getRedirectResult() (stored in
        // _completeRedirectFn) with an optional parameter that instructs all of
        // the underlying auth operations to skip anything that mutates auth state.
        let result = null;
        try {
            // We know this._popupRedirectResolver is set since redirectResolver
            // is passed in. The _completeRedirectFn expects the unwrapped extern.
            result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);
        }
        catch (e) {
            // Swallow any errors here; the code can retrieve them in
            // getRedirectResult().
            await this._setRedirectUser(null);
        }
        return result;
    }
    async reloadAndSetCurrentUserOrClear(user) {
        try {
            await _reloadWithoutSaving(user);
        }
        catch (e) {
            if ((e === null || e === void 0 ? void 0 : e.code) !==
                `auth/${"network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {
                // Something's wrong with the user's token. Log them out and remove
                // them from storage
                return this.directlySetCurrentUser(null);
            }
        }
        return this.directlySetCurrentUser(user);
    }
    useDeviceLanguage() {
        this.languageCode = _getUserLanguage();
    }
    async _delete() {
        this._deleted = true;
    }
    async updateCurrentUser(userExtern) {
        // The public updateCurrentUser method needs to make a copy of the user,
        // and also check that the project matches
        const user = userExtern
            ? index_esm2017_getModularInstance(userExtern)
            : null;
        if (user) {
            _assert(user.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token" /* AuthErrorCode.INVALID_AUTH */);
        }
        return this._updateCurrentUser(user && user._clone(this));
    }
    async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {
        if (this._deleted) {
            return;
        }
        if (user) {
            _assert(this.tenantId === user.tenantId, this, "tenant-id-mismatch" /* AuthErrorCode.TENANT_ID_MISMATCH */);
        }
        if (!skipBeforeStateCallbacks) {
            await this.beforeStateQueue.runMiddleware(user);
        }
        return this.queue(async () => {
            await this.directlySetCurrentUser(user);
            this.notifyAuthListeners();
        });
    }
    async signOut() {
        // Run first, to block _setRedirectUser() if any callbacks fail.
        await this.beforeStateQueue.runMiddleware(null);
        // Clear the redirect user when signOut is called
        if (this.redirectPersistenceManager || this._popupRedirectResolver) {
            await this._setRedirectUser(null);
        }
        // Prevent callbacks from being called again in _updateCurrentUser, as
        // they were already called in the first line.
        return this._updateCurrentUser(null, /* skipBeforeStateCallbacks */ true);
    }
    setPersistence(persistence) {
        return this.queue(async () => {
            await this.assertedPersistence.setPersistence(_getInstance(persistence));
        });
    }
    async initializeRecaptchaConfig() {
        const response = await getRecaptchaConfig(this, {
            clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */,
            version: "RECAPTCHA_ENTERPRISE" /* RecaptchaVersion.ENTERPRISE */
        });
        const config = new RecaptchaConfig(response);
        if (this.tenantId == null) {
            this._agentRecaptchaConfig = config;
        }
        else {
            this._tenantRecaptchaConfigs[this.tenantId] = config;
        }
        if (config.emailPasswordEnabled) {
            const verifier = new RecaptchaEnterpriseVerifier(this);
            void verifier.verify();
        }
    }
    _getRecaptchaConfig() {
        if (this.tenantId == null) {
            return this._agentRecaptchaConfig;
        }
        else {
            return this._tenantRecaptchaConfigs[this.tenantId];
        }
    }
    _getPersistence() {
        return this.assertedPersistence.persistence.type;
    }
    _updateErrorMap(errorMap) {
        this._errorFactory = new ErrorFactory('auth', 'Firebase', errorMap());
    }
    onAuthStateChanged(nextOrObserver, error, completed) {
        return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);
    }
    beforeAuthStateChanged(callback, onAbort) {
        return this.beforeStateQueue.pushCallback(callback, onAbort);
    }
    onIdTokenChanged(nextOrObserver, error, completed) {
        return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);
    }
    toJSON() {
        var _a;
        return {
            apiKey: this.config.apiKey,
            authDomain: this.config.authDomain,
            appName: this.name,
            currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()
        };
    }
    async _setRedirectUser(user, popupRedirectResolver) {
        const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);
        return user === null
            ? redirectManager.removeCurrentUser()
            : redirectManager.setCurrentUser(user);
    }
    async getOrInitRedirectPersistenceManager(popupRedirectResolver) {
        if (!this.redirectPersistenceManager) {
            const resolver = (popupRedirectResolver && _getInstance(popupRedirectResolver)) ||
                this._popupRedirectResolver;
            _assert(resolver, this, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
            this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], "redirectUser" /* KeyName.REDIRECT_USER */);
            this.redirectUser =
                await this.redirectPersistenceManager.getCurrentUser();
        }
        return this.redirectPersistenceManager;
    }
    async _redirectUserForId(id) {
        var _a, _b;
        // Make sure we've cleared any pending persistence actions if we're not in
        // the initializer
        if (this._isInitialized) {
            await this.queue(async () => { });
        }
        if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id) {
            return this._currentUser;
        }
        if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {
            return this.redirectUser;
        }
        return null;
    }
    async _persistUserIfCurrent(user) {
        if (user === this.currentUser) {
            return this.queue(async () => this.directlySetCurrentUser(user));
        }
    }
    /** Notifies listeners only if the user is current */
    _notifyListenersIfCurrent(user) {
        if (user === this.currentUser) {
            this.notifyAuthListeners();
        }
    }
    _key() {
        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
    }
    _startProactiveRefresh() {
        this.isProactiveRefreshEnabled = true;
        if (this.currentUser) {
            this._currentUser._startProactiveRefresh();
        }
    }
    _stopProactiveRefresh() {
        this.isProactiveRefreshEnabled = false;
        if (this.currentUser) {
            this._currentUser._stopProactiveRefresh();
        }
    }
    /** Returns the current user cast as the internal type */
    get _currentUser() {
        return this.currentUser;
    }
    notifyAuthListeners() {
        var _a, _b;
        if (!this._isInitialized) {
            return;
        }
        this.idTokenSubscription.next(this.currentUser);
        const currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;
        if (this.lastNotifiedUid !== currentUid) {
            this.lastNotifiedUid = currentUid;
            this.authStateSubscription.next(this.currentUser);
        }
    }
    registerStateListener(subscription, nextOrObserver, error, completed) {
        if (this._deleted) {
            return () => { };
        }
        const cb = typeof nextOrObserver === 'function'
            ? nextOrObserver
            : nextOrObserver.next.bind(nextOrObserver);
        const promise = this._isInitialized
            ? Promise.resolve()
            : this._initializationPromise;
        _assert(promise, this, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        // The callback needs to be called asynchronously per the spec.
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        promise.then(() => cb(this.currentUser));
        if (typeof nextOrObserver === 'function') {
            return subscription.addObserver(nextOrObserver, error, completed);
        }
        else {
            return subscription.addObserver(nextOrObserver);
        }
    }
    /**
     * Unprotected (from race conditions) method to set the current user. This
     * should only be called from within a queued callback. This is necessary
     * because the queue shouldn't rely on another queued callback.
     */
    async directlySetCurrentUser(user) {
        if (this.currentUser && this.currentUser !== user) {
            this._currentUser._stopProactiveRefresh();
        }
        if (user && this.isProactiveRefreshEnabled) {
            user._startProactiveRefresh();
        }
        this.currentUser = user;
        if (user) {
            await this.assertedPersistence.setCurrentUser(user);
        }
        else {
            await this.assertedPersistence.removeCurrentUser();
        }
    }
    queue(action) {
        // In case something errors, the callback still should be called in order
        // to keep the promise chain alive
        this.operations = this.operations.then(action, action);
        return this.operations;
    }
    get assertedPersistence() {
        _assert(this.persistenceManager, this, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        return this.persistenceManager;
    }
    _logFramework(framework) {
        if (!framework || this.frameworks.includes(framework)) {
            return;
        }
        this.frameworks.push(framework);
        // Sort alphabetically so that "FirebaseCore-web,FirebaseUI-web" and
        // "FirebaseUI-web,FirebaseCore-web" aren't viewed as different.
        this.frameworks.sort();
        this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());
    }
    _getFrameworks() {
        return this.frameworks;
    }
    async _getAdditionalHeaders() {
        var _a;
        // Additional headers on every request
        const headers = {
            ["X-Client-Version" /* HttpHeader.X_CLIENT_VERSION */]: this.clientVersion
        };
        if (this.app.options.appId) {
            headers["X-Firebase-gmpid" /* HttpHeader.X_FIREBASE_GMPID */] = this.app.options.appId;
        }
        // If the heartbeat service exists, add the heartbeat string
        const heartbeatsHeader = await ((_a = this.heartbeatServiceProvider
            .getImmediate({
            optional: true
        })) === null || _a === void 0 ? void 0 : _a.getHeartbeatsHeader());
        if (heartbeatsHeader) {
            headers["X-Firebase-Client" /* HttpHeader.X_FIREBASE_CLIENT */] = heartbeatsHeader;
        }
        // If the App Check service exists, add the App Check token in the headers
        const appCheckToken = await this._getAppCheckToken();
        if (appCheckToken) {
            headers["X-Firebase-AppCheck" /* HttpHeader.X_FIREBASE_APP_CHECK */] = appCheckToken;
        }
        return headers;
    }
    async _getAppCheckToken() {
        var _a;
        const appCheckTokenResult = await ((_a = this.appCheckServiceProvider
            .getImmediate({ optional: true })) === null || _a === void 0 ? void 0 : _a.getToken());
        if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {
            // Context: appCheck.getToken() will never throw even if an error happened.
            // In the error case, a dummy token will be returned along with an error field describing
            // the error. In general, we shouldn't care about the error condition and just use
            // the token (actual or dummy) to send requests.
            _logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`);
        }
        return appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token;
    }
}
/**
 * Method to be used to cast down to our private implmentation of Auth.
 * It will also handle unwrapping from the compat type if necessary
 *
 * @param auth Auth object passed in from developer
 */
function _castAuth(auth) {
    return index_esm2017_getModularInstance(auth);
}
/** Helper class to wrap subscriber logic */
class Subscription {
    constructor(auth) {
        this.auth = auth;
        this.observer = null;
        this.addObserver = createSubscribe(observer => (this.observer = observer));
    }
    get next() {
        _assert(this.observer, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        return this.observer.next.bind(this.observer);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Initializes an {@link Auth} instance with fine-grained control over
 * {@link Dependencies}.
 *
 * @remarks
 *
 * This function allows more control over the {@link Auth} instance than
 * {@link getAuth}. `getAuth` uses platform-specific defaults to supply
 * the {@link Dependencies}. In general, `getAuth` is the easiest way to
 * initialize Auth and works for most use cases. Use `initializeAuth` if you
 * need control over which persistence layer is used, or to minimize bundle
 * size if you're not using either `signInWithPopup` or `signInWithRedirect`.
 *
 * For example, if your app only uses anonymous accounts and you only want
 * accounts saved for the current session, initialize `Auth` with:
 *
 * ```js
 * const auth = initializeAuth(app, {
 *   persistence: browserSessionPersistence,
 *   popupRedirectResolver: undefined,
 * });
 * ```
 *
 * @public
 */
function initializeAuth(app, deps) {
    const provider = _getProvider(app, 'auth');
    if (provider.isInitialized()) {
        const auth = provider.getImmediate();
        const initialOptions = provider.getOptions();
        if (deepEqual(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {
            return auth;
        }
        else {
            _fail(auth, "already-initialized" /* AuthErrorCode.ALREADY_INITIALIZED */);
        }
    }
    const auth = provider.initialize({ options: deps });
    return auth;
}
function _initializeAuthInstance(auth, deps) {
    const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];
    const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);
    if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {
        auth._updateErrorMap(deps.errorMap);
    }
    // This promise is intended to float; auth initialization happens in the
    // background, meanwhile the auth object may be used by the app.
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);
}

/**
 * Changes the {@link Auth} instance to communicate with the Firebase Auth Emulator, instead of production
 * Firebase Auth services.
 *
 * @remarks
 * This must be called synchronously immediately following the first call to
 * {@link initializeAuth}.  Do not use with production credentials as emulator
 * traffic is not encrypted.
 *
 *
 * @example
 * ```javascript
 * connectAuthEmulator(auth, 'http://127.0.0.1:9099', { disableWarnings: true });
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param url - The URL at which the emulator is running (eg, 'http://localhost:9099').
 * @param options - Optional. `options.disableWarnings` defaults to `false`. Set it to
 * `true` to disable the warning banner attached to the DOM.
 *
 * @public
 */
function connectAuthEmulator(auth, url, options) {
    const authInternal = _castAuth(auth);
    _assert(authInternal._canInitEmulator, authInternal, "emulator-config-failed" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */);
    _assert(/^https?:\/\//.test(url), authInternal, "invalid-emulator-scheme" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */);
    const disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);
    const protocol = extractProtocol(url);
    const { host, port } = extractHostAndPort(url);
    const portStr = port === null ? '' : `:${port}`;
    // Always replace path with "/" (even if input url had no path at all, or had a different one).
    authInternal.config.emulator = { url: `${protocol}//${host}${portStr}/` };
    authInternal.settings.appVerificationDisabledForTesting = true;
    authInternal.emulatorConfig = Object.freeze({
        host,
        port,
        protocol: protocol.replace(':', ''),
        options: Object.freeze({ disableWarnings })
    });
    if (!disableWarnings) {
        emitEmulatorWarning();
    }
}
function extractProtocol(url) {
    const protocolEnd = url.indexOf(':');
    return protocolEnd < 0 ? '' : url.substr(0, protocolEnd + 1);
}
function extractHostAndPort(url) {
    const protocol = extractProtocol(url);
    const authority = /(\/\/)?([^?#/]+)/.exec(url.substr(protocol.length)); // Between // and /, ? or #.
    if (!authority) {
        return { host: '', port: null };
    }
    const hostAndPort = authority[2].split('@').pop() || ''; // Strip out "username:password@".
    const bracketedIPv6 = /^(\[[^\]]+\])(:|$)/.exec(hostAndPort);
    if (bracketedIPv6) {
        const host = bracketedIPv6[1];
        return { host, port: parsePort(hostAndPort.substr(host.length + 1)) };
    }
    else {
        const [host, port] = hostAndPort.split(':');
        return { host, port: parsePort(port) };
    }
}
function parsePort(portStr) {
    if (!portStr) {
        return null;
    }
    const port = Number(portStr);
    if (isNaN(port)) {
        return null;
    }
    return port;
}
function emitEmulatorWarning() {
    function attachBanner() {
        const el = document.createElement('p');
        const sty = el.style;
        el.innerText =
            'Running in emulator mode. Do not use with production credentials.';
        sty.position = 'fixed';
        sty.width = '100%';
        sty.backgroundColor = '#ffffff';
        sty.border = '.1em solid #000000';
        sty.color = '#b50000';
        sty.bottom = '0px';
        sty.left = '0px';
        sty.margin = '0px';
        sty.zIndex = '10000';
        sty.textAlign = 'center';
        el.classList.add('firebase-emulator-warning');
        document.body.appendChild(el);
    }
    if (typeof console !== 'undefined' && typeof console.info === 'function') {
        console.info('WARNING: You are using the Auth Emulator,' +
            ' which is intended for local testing only.  Do not use with' +
            ' production credentials.');
    }
    if (typeof window !== 'undefined' && typeof document !== 'undefined') {
        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', attachBanner);
        }
        else {
            attachBanner();
        }
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface that represents the credentials returned by an {@link AuthProvider}.
 *
 * @remarks
 * Implementations specify the details about each auth provider's credential requirements.
 *
 * @public
 */
class AuthCredential {
    /** @internal */
    constructor(
    /**
     * The authentication provider ID for the credential.
     *
     * @remarks
     * For example, 'facebook.com', or 'google.com'.
     */
    providerId, 
    /**
     * The authentication sign in method for the credential.
     *
     * @remarks
     * For example, {@link SignInMethod}.EMAIL_PASSWORD, or
     * {@link SignInMethod}.EMAIL_LINK. This corresponds to the sign-in method
     * identifier as returned in {@link fetchSignInMethodsForEmail}.
     */
    signInMethod) {
        this.providerId = providerId;
        this.signInMethod = signInMethod;
    }
    /**
     * Returns a JSON-serializable representation of this object.
     *
     * @returns a JSON-serializable representation of this object.
     */
    toJSON() {
        return debugFail('not implemented');
    }
    /** @internal */
    _getIdTokenResponse(_auth) {
        return debugFail('not implemented');
    }
    /** @internal */
    _linkToIdToken(_auth, _idToken) {
        return debugFail('not implemented');
    }
    /** @internal */
    _getReauthenticationResolver(_auth) {
        return debugFail('not implemented');
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function resetPassword(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:resetPassword" /* Endpoint.RESET_PASSWORD */, _addTidIfNecessary(auth, request));
}
async function updateEmailPassword(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:update" /* Endpoint.SET_ACCOUNT_INFO */, request);
}
async function applyActionCode$1(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:update" /* Endpoint.SET_ACCOUNT_INFO */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithPassword(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithPassword" /* Endpoint.SIGN_IN_WITH_PASSWORD */, _addTidIfNecessary(auth, request));
}
async function sendOobCode(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:sendOobCode" /* Endpoint.SEND_OOB_CODE */, _addTidIfNecessary(auth, request));
}
async function sendEmailVerification$1(auth, request) {
    return sendOobCode(auth, request);
}
async function sendPasswordResetEmail$1(auth, request) {
    return sendOobCode(auth, request);
}
async function sendSignInLinkToEmail$1(auth, request) {
    return sendOobCode(auth, request);
}
async function verifyAndChangeEmail(auth, request) {
    return sendOobCode(auth, request);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithEmailLink$1(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithEmailLink" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));
}
async function signInWithEmailLinkForLinking(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithEmailLink" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface that represents the credentials returned by {@link EmailAuthProvider} for
 * {@link ProviderId}.PASSWORD
 *
 * @remarks
 * Covers both {@link SignInMethod}.EMAIL_PASSWORD and
 * {@link SignInMethod}.EMAIL_LINK.
 *
 * @public
 */
class EmailAuthCredential extends AuthCredential {
    /** @internal */
    constructor(
    /** @internal */
    _email, 
    /** @internal */
    _password, signInMethod, 
    /** @internal */
    _tenantId = null) {
        super("password" /* ProviderId.PASSWORD */, signInMethod);
        this._email = _email;
        this._password = _password;
        this._tenantId = _tenantId;
    }
    /** @internal */
    static _fromEmailAndPassword(email, password) {
        return new EmailAuthCredential(email, password, "password" /* SignInMethod.EMAIL_PASSWORD */);
    }
    /** @internal */
    static _fromEmailAndCode(email, oobCode, tenantId = null) {
        return new EmailAuthCredential(email, oobCode, "emailLink" /* SignInMethod.EMAIL_LINK */, tenantId);
    }
    /** {@inheritdoc AuthCredential.toJSON} */
    toJSON() {
        return {
            email: this._email,
            password: this._password,
            signInMethod: this.signInMethod,
            tenantId: this._tenantId
        };
    }
    /**
     * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.
     *
     * @param json - Either `object` or the stringified representation of the object. When string is
     * provided, `JSON.parse` would be called first.
     *
     * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.
     */
    static fromJSON(json) {
        const obj = typeof json === 'string' ? JSON.parse(json) : json;
        if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {
            if (obj.signInMethod === "password" /* SignInMethod.EMAIL_PASSWORD */) {
                return this._fromEmailAndPassword(obj.email, obj.password);
            }
            else if (obj.signInMethod === "emailLink" /* SignInMethod.EMAIL_LINK */) {
                return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);
            }
        }
        return null;
    }
    /** @internal */
    async _getIdTokenResponse(auth) {
        var _a;
        switch (this.signInMethod) {
            case "password" /* SignInMethod.EMAIL_PASSWORD */:
                const request = {
                    returnSecureToken: true,
                    email: this._email,
                    password: this._password,
                    clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */
                };
                if ((_a = auth._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.emailPasswordEnabled) {
                    const requestWithRecaptcha = await injectRecaptchaFields(auth, request, "signInWithPassword" /* RecaptchaActionName.SIGN_IN_WITH_PASSWORD */);
                    return signInWithPassword(auth, requestWithRecaptcha);
                }
                else {
                    return signInWithPassword(auth, request).catch(async (error) => {
                        if (error.code === `auth/${"missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {
                            console.log('Sign-in with email address and password is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-in flow.');
                            const requestWithRecaptcha = await injectRecaptchaFields(auth, request, "signInWithPassword" /* RecaptchaActionName.SIGN_IN_WITH_PASSWORD */);
                            return signInWithPassword(auth, requestWithRecaptcha);
                        }
                        else {
                            return Promise.reject(error);
                        }
                    });
                }
            case "emailLink" /* SignInMethod.EMAIL_LINK */:
                return signInWithEmailLink$1(auth, {
                    email: this._email,
                    oobCode: this._password
                });
            default:
                _fail(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        }
    }
    /** @internal */
    async _linkToIdToken(auth, idToken) {
        switch (this.signInMethod) {
            case "password" /* SignInMethod.EMAIL_PASSWORD */:
                return updateEmailPassword(auth, {
                    idToken,
                    returnSecureToken: true,
                    email: this._email,
                    password: this._password
                });
            case "emailLink" /* SignInMethod.EMAIL_LINK */:
                return signInWithEmailLinkForLinking(auth, {
                    idToken,
                    email: this._email,
                    oobCode: this._password
                });
            default:
                _fail(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        }
    }
    /** @internal */
    _getReauthenticationResolver(auth) {
        return this._getIdTokenResponse(auth);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithIdp(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithIdp" /* Endpoint.SIGN_IN_WITH_IDP */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IDP_REQUEST_URI$1 = 'http://localhost';
/**
 * Represents the OAuth credentials returned by an {@link OAuthProvider}.
 *
 * @remarks
 * Implementations specify the details about each auth provider's credential requirements.
 *
 * @public
 */
class OAuthCredential extends AuthCredential {
    constructor() {
        super(...arguments);
        this.pendingToken = null;
    }
    /** @internal */
    static _fromParams(params) {
        const cred = new OAuthCredential(params.providerId, params.signInMethod);
        if (params.idToken || params.accessToken) {
            // OAuth 2 and either ID token or access token.
            if (params.idToken) {
                cred.idToken = params.idToken;
            }
            if (params.accessToken) {
                cred.accessToken = params.accessToken;
            }
            // Add nonce if available and no pendingToken is present.
            if (params.nonce && !params.pendingToken) {
                cred.nonce = params.nonce;
            }
            if (params.pendingToken) {
                cred.pendingToken = params.pendingToken;
            }
        }
        else if (params.oauthToken && params.oauthTokenSecret) {
            // OAuth 1 and OAuth token with token secret
            cred.accessToken = params.oauthToken;
            cred.secret = params.oauthTokenSecret;
        }
        else {
            _fail("argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        }
        return cred;
    }
    /** {@inheritdoc AuthCredential.toJSON}  */
    toJSON() {
        return {
            idToken: this.idToken,
            accessToken: this.accessToken,
            secret: this.secret,
            nonce: this.nonce,
            pendingToken: this.pendingToken,
            providerId: this.providerId,
            signInMethod: this.signInMethod
        };
    }
    /**
     * Static method to deserialize a JSON representation of an object into an
     * {@link  AuthCredential}.
     *
     * @param json - Input can be either Object or the stringified representation of the object.
     * When string is provided, JSON.parse would be called first.
     *
     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
     */
    static fromJSON(json) {
        const obj = typeof json === 'string' ? JSON.parse(json) : json;
        const { providerId, signInMethod } = obj, rest = __rest(obj, ["providerId", "signInMethod"]);
        if (!providerId || !signInMethod) {
            return null;
        }
        const cred = new OAuthCredential(providerId, signInMethod);
        cred.idToken = rest.idToken || undefined;
        cred.accessToken = rest.accessToken || undefined;
        cred.secret = rest.secret;
        cred.nonce = rest.nonce;
        cred.pendingToken = rest.pendingToken || null;
        return cred;
    }
    /** @internal */
    _getIdTokenResponse(auth) {
        const request = this.buildRequest();
        return signInWithIdp(auth, request);
    }
    /** @internal */
    _linkToIdToken(auth, idToken) {
        const request = this.buildRequest();
        request.idToken = idToken;
        return signInWithIdp(auth, request);
    }
    /** @internal */
    _getReauthenticationResolver(auth) {
        const request = this.buildRequest();
        request.autoCreate = false;
        return signInWithIdp(auth, request);
    }
    buildRequest() {
        const request = {
            requestUri: IDP_REQUEST_URI$1,
            returnSecureToken: true
        };
        if (this.pendingToken) {
            request.pendingToken = this.pendingToken;
        }
        else {
            const postBody = {};
            if (this.idToken) {
                postBody['id_token'] = this.idToken;
            }
            if (this.accessToken) {
                postBody['access_token'] = this.accessToken;
            }
            if (this.secret) {
                postBody['oauth_token_secret'] = this.secret;
            }
            postBody['providerId'] = this.providerId;
            if (this.nonce && !this.pendingToken) {
                postBody['nonce'] = this.nonce;
            }
            request.postBody = index_esm2017_querystring(postBody);
        }
        return request;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function sendPhoneVerificationCode(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:sendVerificationCode" /* Endpoint.SEND_VERIFICATION_CODE */, _addTidIfNecessary(auth, request));
}
async function signInWithPhoneNumber$1(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithPhoneNumber" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));
}
async function linkWithPhoneNumber$1(auth, request) {
    const response = await _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithPhoneNumber" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));
    if (response.temporaryProof) {
        throw _makeTaggedError(auth, "account-exists-with-different-credential" /* AuthErrorCode.NEED_CONFIRMATION */, response);
    }
    return response;
}
const VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = {
    ["USER_NOT_FOUND" /* ServerError.USER_NOT_FOUND */]: "user-not-found" /* AuthErrorCode.USER_DELETED */
};
async function verifyPhoneNumberForExisting(auth, request) {
    const apiRequest = Object.assign(Object.assign({}, request), { operation: 'REAUTH' });
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithPhoneNumber" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Represents the credentials returned by {@link PhoneAuthProvider}.
 *
 * @public
 */
class PhoneAuthCredential extends AuthCredential {
    constructor(params) {
        super("phone" /* ProviderId.PHONE */, "phone" /* SignInMethod.PHONE */);
        this.params = params;
    }
    /** @internal */
    static _fromVerification(verificationId, verificationCode) {
        return new PhoneAuthCredential({ verificationId, verificationCode });
    }
    /** @internal */
    static _fromTokenResponse(phoneNumber, temporaryProof) {
        return new PhoneAuthCredential({ phoneNumber, temporaryProof });
    }
    /** @internal */
    _getIdTokenResponse(auth) {
        return signInWithPhoneNumber$1(auth, this._makeVerificationRequest());
    }
    /** @internal */
    _linkToIdToken(auth, idToken) {
        return linkWithPhoneNumber$1(auth, Object.assign({ idToken }, this._makeVerificationRequest()));
    }
    /** @internal */
    _getReauthenticationResolver(auth) {
        return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());
    }
    /** @internal */
    _makeVerificationRequest() {
        const { temporaryProof, phoneNumber, verificationId, verificationCode } = this.params;
        if (temporaryProof && phoneNumber) {
            return { temporaryProof, phoneNumber };
        }
        return {
            sessionInfo: verificationId,
            code: verificationCode
        };
    }
    /** {@inheritdoc AuthCredential.toJSON} */
    toJSON() {
        const obj = {
            providerId: this.providerId
        };
        if (this.params.phoneNumber) {
            obj.phoneNumber = this.params.phoneNumber;
        }
        if (this.params.temporaryProof) {
            obj.temporaryProof = this.params.temporaryProof;
        }
        if (this.params.verificationCode) {
            obj.verificationCode = this.params.verificationCode;
        }
        if (this.params.verificationId) {
            obj.verificationId = this.params.verificationId;
        }
        return obj;
    }
    /** Generates a phone credential based on a plain object or a JSON string. */
    static fromJSON(json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        const { verificationId, verificationCode, phoneNumber, temporaryProof } = json;
        if (!verificationCode &&
            !verificationId &&
            !phoneNumber &&
            !temporaryProof) {
            return null;
        }
        return new PhoneAuthCredential({
            verificationId,
            verificationCode,
            phoneNumber,
            temporaryProof
        });
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Maps the mode string in action code URL to Action Code Info operation.
 *
 * @param mode
 */
function parseMode(mode) {
    switch (mode) {
        case 'recoverEmail':
            return "RECOVER_EMAIL" /* ActionCodeOperation.RECOVER_EMAIL */;
        case 'resetPassword':
            return "PASSWORD_RESET" /* ActionCodeOperation.PASSWORD_RESET */;
        case 'signIn':
            return "EMAIL_SIGNIN" /* ActionCodeOperation.EMAIL_SIGNIN */;
        case 'verifyEmail':
            return "VERIFY_EMAIL" /* ActionCodeOperation.VERIFY_EMAIL */;
        case 'verifyAndChangeEmail':
            return "VERIFY_AND_CHANGE_EMAIL" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */;
        case 'revertSecondFactorAddition':
            return "REVERT_SECOND_FACTOR_ADDITION" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */;
        default:
            return null;
    }
}
/**
 * Helper to parse FDL links
 *
 * @param url
 */
function parseDeepLink(url) {
    const link = querystringDecode(extractQuerystring(url))['link'];
    // Double link case (automatic redirect).
    const doubleDeepLink = link
        ? querystringDecode(extractQuerystring(link))['deep_link_id']
        : null;
    // iOS custom scheme links.
    const iOSDeepLink = querystringDecode(extractQuerystring(url))['deep_link_id'];
    const iOSDoubleDeepLink = iOSDeepLink
        ? querystringDecode(extractQuerystring(iOSDeepLink))['link']
        : null;
    return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
/**
 * A utility class to parse email action URLs such as password reset, email verification,
 * email link sign in, etc.
 *
 * @public
 */
class ActionCodeURL {
    /**
     * @param actionLink - The link from which to extract the URL.
     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
     *
     * @internal
     */
    constructor(actionLink) {
        var _a, _b, _c, _d, _e, _f;
        const searchParams = querystringDecode(extractQuerystring(actionLink));
        const apiKey = (_a = searchParams["apiKey" /* QueryField.API_KEY */]) !== null && _a !== void 0 ? _a : null;
        const code = (_b = searchParams["oobCode" /* QueryField.CODE */]) !== null && _b !== void 0 ? _b : null;
        const operation = parseMode((_c = searchParams["mode" /* QueryField.MODE */]) !== null && _c !== void 0 ? _c : null);
        // Validate API key, code and mode.
        _assert(apiKey && code && operation, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        this.apiKey = apiKey;
        this.operation = operation;
        this.code = code;
        this.continueUrl = (_d = searchParams["continueUrl" /* QueryField.CONTINUE_URL */]) !== null && _d !== void 0 ? _d : null;
        this.languageCode = (_e = searchParams["languageCode" /* QueryField.LANGUAGE_CODE */]) !== null && _e !== void 0 ? _e : null;
        this.tenantId = (_f = searchParams["tenantId" /* QueryField.TENANT_ID */]) !== null && _f !== void 0 ? _f : null;
    }
    /**
     * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,
     * otherwise returns null.
     *
     * @param link  - The email action link string.
     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
     *
     * @public
     */
    static parseLink(link) {
        const actionLink = parseDeepLink(link);
        try {
            return new ActionCodeURL(actionLink);
        }
        catch (_a) {
            return null;
        }
    }
}
/**
 * Parses the email action link string and returns an {@link ActionCodeURL} if
 * the link is valid, otherwise returns null.
 *
 * @public
 */
function parseActionCodeURL(link) {
    return ActionCodeURL.parseLink(link);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating {@link EmailAuthCredential}.
 *
 * @public
 */
class EmailAuthProvider {
    constructor() {
        /**
         * Always set to {@link ProviderId}.PASSWORD, even for email link.
         */
        this.providerId = EmailAuthProvider.PROVIDER_ID;
    }
    /**
     * Initialize an {@link AuthCredential} using an email and password.
     *
     * @example
     * ```javascript
     * const authCredential = EmailAuthProvider.credential(email, password);
     * const userCredential = await signInWithCredential(auth, authCredential);
     * ```
     *
     * @example
     * ```javascript
     * const userCredential = await signInWithEmailAndPassword(auth, email, password);
     * ```
     *
     * @param email - Email address.
     * @param password - User account password.
     * @returns The auth provider credential.
     */
    static credential(email, password) {
        return EmailAuthCredential._fromEmailAndPassword(email, password);
    }
    /**
     * Initialize an {@link AuthCredential} using an email and an email link after a sign in with
     * email link operation.
     *
     * @example
     * ```javascript
     * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);
     * const userCredential = await signInWithCredential(auth, authCredential);
     * ```
     *
     * @example
     * ```javascript
     * await sendSignInLinkToEmail(auth, email);
     * // Obtain emailLink from user.
     * const userCredential = await signInWithEmailLink(auth, email, emailLink);
     * ```
     *
     * @param auth - The {@link Auth} instance used to verify the link.
     * @param email - Email address.
     * @param emailLink - Sign-in email link.
     * @returns - The auth provider credential.
     */
    static credentialWithLink(email, emailLink) {
        const actionCodeUrl = ActionCodeURL.parseLink(emailLink);
        _assert(actionCodeUrl, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);
    }
}
/**
 * Always set to {@link ProviderId}.PASSWORD, even for email link.
 */
EmailAuthProvider.PROVIDER_ID = "password" /* ProviderId.PASSWORD */;
/**
 * Always set to {@link SignInMethod}.EMAIL_PASSWORD.
 */
EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = "password" /* SignInMethod.EMAIL_PASSWORD */;
/**
 * Always set to {@link SignInMethod}.EMAIL_LINK.
 */
EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = "emailLink" /* SignInMethod.EMAIL_LINK */;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The base class for all Federated providers (OAuth (including OIDC), SAML).
 *
 * This class is not meant to be instantiated directly.
 *
 * @public
 */
class FederatedAuthProvider {
    /**
     * Constructor for generic OAuth providers.
     *
     * @param providerId - Provider for which credentials should be generated.
     */
    constructor(providerId) {
        this.providerId = providerId;
        /** @internal */
        this.defaultLanguageCode = null;
        /** @internal */
        this.customParameters = {};
    }
    /**
     * Set the language gode.
     *
     * @param languageCode - language code
     */
    setDefaultLanguage(languageCode) {
        this.defaultLanguageCode = languageCode;
    }
    /**
     * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in
     * operations.
     *
     * @remarks
     * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,
     * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.
     *
     * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.
     */
    setCustomParameters(customOAuthParameters) {
        this.customParameters = customOAuthParameters;
        return this;
    }
    /**
     * Retrieve the current list of {@link CustomParameters}.
     */
    getCustomParameters() {
        return this.customParameters;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Common code to all OAuth providers. This is separate from the
 * {@link OAuthProvider} so that child providers (like
 * {@link GoogleAuthProvider}) don't inherit the `credential` instance method.
 * Instead, they rely on a static `credential` method.
 */
class BaseOAuthProvider extends FederatedAuthProvider {
    constructor() {
        super(...arguments);
        /** @internal */
        this.scopes = [];
    }
    /**
     * Add an OAuth scope to the credential.
     *
     * @param scope - Provider OAuth scope to add.
     */
    addScope(scope) {
        // If not already added, add scope to list.
        if (!this.scopes.includes(scope)) {
            this.scopes.push(scope);
        }
        return this;
    }
    /**
     * Retrieve the current list of OAuth scopes.
     */
    getScopes() {
        return [...this.scopes];
    }
}
/**
 * Provider for generating generic {@link OAuthCredential}.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new OAuthProvider('google.com');
 * // Start a sign in process for an unauthenticated user.
 * provider.addScope('profile');
 * provider.addScope('email');
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a OAuth Access Token for the provider.
 *   const credential = provider.credentialFromResult(auth, result);
 *   const token = credential.accessToken;
 * }
 * ```
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new OAuthProvider('google.com');
 * provider.addScope('profile');
 * provider.addScope('email');
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a OAuth Access Token for the provider.
 * const credential = provider.credentialFromResult(auth, result);
 * const token = credential.accessToken;
 * ```
 * @public
 */
class OAuthProvider extends (/* unused pure expression or super */ null && (BaseOAuthProvider)) {
    /**
     * Creates an {@link OAuthCredential} from a JSON string or a plain object.
     * @param json - A plain object or a JSON string
     */
    static credentialFromJSON(json) {
        const obj = typeof json === 'string' ? JSON.parse(json) : json;
        _assert('providerId' in obj && 'signInMethod' in obj, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        return OAuthCredential._fromParams(obj);
    }
    /**
     * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.
     *
     * @remarks
     * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of
     * the raw nonce must match the nonce field in the ID token.
     *
     * @example
     * ```javascript
     * // `googleUser` from the onsuccess Google Sign In callback.
     * // Initialize a generate OAuth provider with a `google.com` providerId.
     * const provider = new OAuthProvider('google.com');
     * const credential = provider.credential({
     *   idToken: googleUser.getAuthResponse().id_token,
     * });
     * const result = await signInWithCredential(credential);
     * ```
     *
     * @param params - Either the options object containing the ID token, access token and raw nonce
     * or the ID token string.
     */
    credential(params) {
        return this._credential(Object.assign(Object.assign({}, params), { nonce: params.rawNonce }));
    }
    /** An internal credential method that accepts more permissive options */
    _credential(params) {
        _assert(params.idToken || params.accessToken, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        // For OAuthCredential, sign in method is same as providerId.
        return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), { providerId: this.providerId, signInMethod: this.providerId }));
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return OAuthProvider.oauthCredentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return OAuthProvider.oauthCredentialFromTaggedObject((error.customData || {}));
    }
    static oauthCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse) {
            return null;
        }
        const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce, providerId } = tokenResponse;
        if (!oauthAccessToken &&
            !oauthTokenSecret &&
            !oauthIdToken &&
            !pendingToken) {
            return null;
        }
        if (!providerId) {
            return null;
        }
        try {
            return new OAuthProvider(providerId)._credential({
                idToken: oauthIdToken,
                accessToken: oauthAccessToken,
                nonce,
                pendingToken
            });
        }
        catch (e) {
            return null;
        }
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.FACEBOOK.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new FacebookAuthProvider();
 * // Start a sign in process for an unauthenticated user.
 * provider.addScope('user_birthday');
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Facebook Access Token.
 *   const credential = FacebookAuthProvider.credentialFromResult(result);
 *   const token = credential.accessToken;
 * }
 * ```
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new FacebookAuthProvider();
 * provider.addScope('user_birthday');
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a Facebook Access Token.
 * const credential = FacebookAuthProvider.credentialFromResult(result);
 * const token = credential.accessToken;
 * ```
 *
 * @public
 */
class FacebookAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("facebook.com" /* ProviderId.FACEBOOK */);
    }
    /**
     * Creates a credential for Facebook.
     *
     * @example
     * ```javascript
     * // `event` from the Facebook auth.authResponseChange callback.
     * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);
     * const result = await signInWithCredential(credential);
     * ```
     *
     * @param accessToken - Facebook access token.
     */
    static credential(accessToken) {
        return OAuthCredential._fromParams({
            providerId: FacebookAuthProvider.PROVIDER_ID,
            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
            accessToken
        });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return FacebookAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return FacebookAuthProvider.credentialFromTaggedObject((error.customData || {}));
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {
            return null;
        }
        if (!tokenResponse.oauthAccessToken) {
            return null;
        }
        try {
            return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);
        }
        catch (_a) {
            return null;
        }
    }
}
/** Always set to {@link SignInMethod}.FACEBOOK. */
FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = "facebook.com" /* SignInMethod.FACEBOOK */;
/** Always set to {@link ProviderId}.FACEBOOK. */
FacebookAuthProvider.PROVIDER_ID = "facebook.com" /* ProviderId.FACEBOOK */;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating an an {@link OAuthCredential} for {@link ProviderId}.GOOGLE.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new GoogleAuthProvider();
 * // Start a sign in process for an unauthenticated user.
 * provider.addScope('profile');
 * provider.addScope('email');
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Google Access Token.
 *   const credential = GoogleAuthProvider.credentialFromResult(result);
 *   const token = credential.accessToken;
 * }
 * ```
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new GoogleAuthProvider();
 * provider.addScope('profile');
 * provider.addScope('email');
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a Google Access Token.
 * const credential = GoogleAuthProvider.credentialFromResult(result);
 * const token = credential.accessToken;
 * ```
 *
 * @public
 */
class GoogleAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("google.com" /* ProviderId.GOOGLE */);
        this.addScope('profile');
    }
    /**
     * Creates a credential for Google. At least one of ID token and access token is required.
     *
     * @example
     * ```javascript
     * // \`googleUser\` from the onsuccess Google Sign In callback.
     * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);
     * const result = await signInWithCredential(credential);
     * ```
     *
     * @param idToken - Google ID token.
     * @param accessToken - Google access token.
     */
    static credential(idToken, accessToken) {
        return OAuthCredential._fromParams({
            providerId: GoogleAuthProvider.PROVIDER_ID,
            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,
            idToken,
            accessToken
        });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return GoogleAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return GoogleAuthProvider.credentialFromTaggedObject((error.customData || {}));
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse) {
            return null;
        }
        const { oauthIdToken, oauthAccessToken } = tokenResponse;
        if (!oauthIdToken && !oauthAccessToken) {
            // This could be an oauth 1 credential or a phone credential
            return null;
        }
        try {
            return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);
        }
        catch (_a) {
            return null;
        }
    }
}
/** Always set to {@link SignInMethod}.GOOGLE. */
GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = "google.com" /* SignInMethod.GOOGLE */;
/** Always set to {@link ProviderId}.GOOGLE. */
GoogleAuthProvider.PROVIDER_ID = "google.com" /* ProviderId.GOOGLE */;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GITHUB.
 *
 * @remarks
 * GitHub requires an OAuth 2.0 redirect, so you can either handle the redirect directly, or use
 * the {@link signInWithPopup} handler:
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new GithubAuthProvider();
 * // Start a sign in process for an unauthenticated user.
 * provider.addScope('repo');
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Github Access Token.
 *   const credential = GithubAuthProvider.credentialFromResult(result);
 *   const token = credential.accessToken;
 * }
 * ```
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new GithubAuthProvider();
 * provider.addScope('repo');
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a Github Access Token.
 * const credential = GithubAuthProvider.credentialFromResult(result);
 * const token = credential.accessToken;
 * ```
 * @public
 */
class GithubAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("github.com" /* ProviderId.GITHUB */);
    }
    /**
     * Creates a credential for Github.
     *
     * @param accessToken - Github access token.
     */
    static credential(accessToken) {
        return OAuthCredential._fromParams({
            providerId: GithubAuthProvider.PROVIDER_ID,
            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,
            accessToken
        });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return GithubAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return GithubAuthProvider.credentialFromTaggedObject((error.customData || {}));
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {
            return null;
        }
        if (!tokenResponse.oauthAccessToken) {
            return null;
        }
        try {
            return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);
        }
        catch (_a) {
            return null;
        }
    }
}
/** Always set to {@link SignInMethod}.GITHUB. */
GithubAuthProvider.GITHUB_SIGN_IN_METHOD = "github.com" /* SignInMethod.GITHUB */;
/** Always set to {@link ProviderId}.GITHUB. */
GithubAuthProvider.PROVIDER_ID = "github.com" /* ProviderId.GITHUB */;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IDP_REQUEST_URI = 'http://localhost';
/**
 * @public
 */
class SAMLAuthCredential extends (/* unused pure expression or super */ null && (AuthCredential)) {
    /** @internal */
    constructor(providerId, pendingToken) {
        super(providerId, providerId);
        this.pendingToken = pendingToken;
    }
    /** @internal */
    _getIdTokenResponse(auth) {
        const request = this.buildRequest();
        return signInWithIdp(auth, request);
    }
    /** @internal */
    _linkToIdToken(auth, idToken) {
        const request = this.buildRequest();
        request.idToken = idToken;
        return signInWithIdp(auth, request);
    }
    /** @internal */
    _getReauthenticationResolver(auth) {
        const request = this.buildRequest();
        request.autoCreate = false;
        return signInWithIdp(auth, request);
    }
    /** {@inheritdoc AuthCredential.toJSON}  */
    toJSON() {
        return {
            signInMethod: this.signInMethod,
            providerId: this.providerId,
            pendingToken: this.pendingToken
        };
    }
    /**
     * Static method to deserialize a JSON representation of an object into an
     * {@link  AuthCredential}.
     *
     * @param json - Input can be either Object or the stringified representation of the object.
     * When string is provided, JSON.parse would be called first.
     *
     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
     */
    static fromJSON(json) {
        const obj = typeof json === 'string' ? JSON.parse(json) : json;
        const { providerId, signInMethod, pendingToken } = obj;
        if (!providerId ||
            !signInMethod ||
            !pendingToken ||
            providerId !== signInMethod) {
            return null;
        }
        return new SAMLAuthCredential(providerId, pendingToken);
    }
    /**
     * Helper static method to avoid exposing the constructor to end users.
     *
     * @internal
     */
    static _create(providerId, pendingToken) {
        return new SAMLAuthCredential(providerId, pendingToken);
    }
    buildRequest() {
        return {
            requestUri: IDP_REQUEST_URI,
            returnSecureToken: true,
            pendingToken: this.pendingToken
        };
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SAML_PROVIDER_PREFIX = 'saml.';
/**
 * An {@link AuthProvider} for SAML.
 *
 * @public
 */
class SAMLAuthProvider extends (/* unused pure expression or super */ null && (FederatedAuthProvider)) {
    /**
     * Constructor. The providerId must start with "saml."
     * @param providerId - SAML provider ID.
     */
    constructor(providerId) {
        _assert(providerId.startsWith(SAML_PROVIDER_PREFIX), "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        super(providerId);
    }
    /**
     * Generates an {@link AuthCredential} from a {@link UserCredential} after a
     * successful SAML flow completes.
     *
     * @remarks
     *
     * For example, to get an {@link AuthCredential}, you could write the
     * following code:
     *
     * ```js
     * const userCredential = await signInWithPopup(auth, samlProvider);
     * const credential = SAMLAuthProvider.credentialFromResult(userCredential);
     * ```
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return SAMLAuthProvider.samlCredentialFromTaggedObject((error.customData || {}));
    }
    /**
     * Creates an {@link AuthCredential} from a JSON string or a plain object.
     * @param json - A plain object or a JSON string
     */
    static credentialFromJSON(json) {
        const credential = SAMLAuthCredential.fromJSON(json);
        _assert(credential, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        return credential;
    }
    static samlCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse) {
            return null;
        }
        const { pendingToken, providerId } = tokenResponse;
        if (!pendingToken || !providerId) {
            return null;
        }
        try {
            return SAMLAuthCredential._create(providerId, pendingToken);
        }
        catch (e) {
            return null;
        }
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.TWITTER.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new TwitterAuthProvider();
 * // Start a sign in process for an unauthenticated user.
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Twitter Access Token and Secret.
 *   const credential = TwitterAuthProvider.credentialFromResult(result);
 *   const token = credential.accessToken;
 *   const secret = credential.secret;
 * }
 * ```
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new TwitterAuthProvider();
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a Twitter Access Token and Secret.
 * const credential = TwitterAuthProvider.credentialFromResult(result);
 * const token = credential.accessToken;
 * const secret = credential.secret;
 * ```
 *
 * @public
 */
class TwitterAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("twitter.com" /* ProviderId.TWITTER */);
    }
    /**
     * Creates a credential for Twitter.
     *
     * @param token - Twitter access token.
     * @param secret - Twitter secret.
     */
    static credential(token, secret) {
        return OAuthCredential._fromParams({
            providerId: TwitterAuthProvider.PROVIDER_ID,
            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,
            oauthToken: token,
            oauthTokenSecret: secret
        });
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        return TwitterAuthProvider.credentialFromTaggedObject(userCredential);
    }
    /**
     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
     * thrown during a sign-in, link, or reauthenticate operation.
     *
     * @param userCredential - The user credential.
     */
    static credentialFromError(error) {
        return TwitterAuthProvider.credentialFromTaggedObject((error.customData || {}));
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse) {
            return null;
        }
        const { oauthAccessToken, oauthTokenSecret } = tokenResponse;
        if (!oauthAccessToken || !oauthTokenSecret) {
            return null;
        }
        try {
            return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);
        }
        catch (_a) {
            return null;
        }
    }
}
/** Always set to {@link SignInMethod}.TWITTER. */
TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = "twitter.com" /* SignInMethod.TWITTER */;
/** Always set to {@link ProviderId}.TWITTER. */
TwitterAuthProvider.PROVIDER_ID = "twitter.com" /* ProviderId.TWITTER */;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signUp(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signUp" /* Endpoint.SIGN_UP */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserCredentialImpl {
    constructor(params) {
        this.user = params.user;
        this.providerId = params.providerId;
        this._tokenResponse = params._tokenResponse;
        this.operationType = params.operationType;
    }
    static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {
        const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);
        const providerId = providerIdForResponse(idTokenResponse);
        const userCred = new UserCredentialImpl({
            user,
            providerId,
            _tokenResponse: idTokenResponse,
            operationType
        });
        return userCred;
    }
    static async _forOperation(user, operationType, response) {
        await user._updateTokensIfNecessary(response, /* reload */ true);
        const providerId = providerIdForResponse(response);
        return new UserCredentialImpl({
            user,
            providerId,
            _tokenResponse: response,
            operationType
        });
    }
}
function providerIdForResponse(response) {
    if (response.providerId) {
        return response.providerId;
    }
    if ('phoneNumber' in response) {
        return "phone" /* ProviderId.PHONE */;
    }
    return null;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Asynchronously signs in as an anonymous user.
 *
 * @remarks
 * If there is already an anonymous user signed in, that user will be returned; otherwise, a
 * new anonymous user identity will be created and returned.
 *
 * @param auth - The {@link Auth} instance.
 *
 * @public
 */
async function signInAnonymously(auth) {
    var _a;
    const authInternal = _castAuth(auth);
    await authInternal._initializationPromise;
    if ((_a = authInternal.currentUser) === null || _a === void 0 ? void 0 : _a.isAnonymous) {
        // If an anonymous user is already signed in, no need to sign them in again.
        return new UserCredentialImpl({
            user: authInternal.currentUser,
            providerId: null,
            operationType: "signIn" /* OperationType.SIGN_IN */
        });
    }
    const response = await signUp(authInternal, {
        returnSecureToken: true
    });
    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn" /* OperationType.SIGN_IN */, response, true);
    await authInternal._updateCurrentUser(userCredential.user);
    return userCredential;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiFactorError extends FirebaseError {
    constructor(auth, error, operationType, user) {
        var _a;
        super(error.code, error.message);
        this.operationType = operationType;
        this.user = user;
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, MultiFactorError.prototype);
        this.customData = {
            appName: auth.name,
            tenantId: (_a = auth.tenantId) !== null && _a !== void 0 ? _a : undefined,
            _serverResponse: error.customData._serverResponse,
            operationType
        };
    }
    static _fromErrorAndOperation(auth, error, operationType, user) {
        return new MultiFactorError(auth, error, operationType, user);
    }
}
function _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {
    const idTokenProvider = operationType === "reauthenticate" /* OperationType.REAUTHENTICATE */
        ? credential._getReauthenticationResolver(auth)
        : credential._getIdTokenResponse(auth);
    return idTokenProvider.catch(error => {
        if (error.code === `auth/${"multi-factor-auth-required" /* AuthErrorCode.MFA_REQUIRED */}`) {
            throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);
        }
        throw error;
    });
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Takes a set of UserInfo provider data and converts it to a set of names
 */
function providerDataAsNames(providerData) {
    return new Set(providerData
        .map(({ providerId }) => providerId)
        .filter(pid => !!pid));
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Unlinks a provider from a user account.
 *
 * @param user - The user.
 * @param providerId - The provider to unlink.
 *
 * @public
 */
async function unlink(user, providerId) {
    const userInternal = getModularInstance(user);
    await _assertLinkedStatus(true, userInternal, providerId);
    const { providerUserInfo } = await deleteLinkedAccounts(userInternal.auth, {
        idToken: await userInternal.getIdToken(),
        deleteProvider: [providerId]
    });
    const providersLeft = providerDataAsNames(providerUserInfo || []);
    userInternal.providerData = userInternal.providerData.filter(pd => providersLeft.has(pd.providerId));
    if (!providersLeft.has("phone" /* ProviderId.PHONE */)) {
        userInternal.phoneNumber = null;
    }
    await userInternal.auth._persistUserIfCurrent(userInternal);
    return userInternal;
}
async function _link$1(user, credential, bypassAuthState = false) {
    const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);
    return UserCredentialImpl._forOperation(user, "link" /* OperationType.LINK */, response);
}
async function _assertLinkedStatus(expected, user, provider) {
    await _reloadWithoutSaving(user);
    const providerIds = providerDataAsNames(user.providerData);
    const code = expected === false
        ? "provider-already-linked" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */
        : "no-such-provider" /* AuthErrorCode.NO_SUCH_PROVIDER */;
    _assert(providerIds.has(provider) === expected, user.auth, code);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _reauthenticate(user, credential, bypassAuthState = false) {
    const { auth } = user;
    const operationType = "reauthenticate" /* OperationType.REAUTHENTICATE */;
    try {
        const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);
        _assert(response.idToken, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const parsed = _parseToken(response.idToken);
        _assert(parsed, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const { sub: localId } = parsed;
        _assert(user.uid === localId, auth, "user-mismatch" /* AuthErrorCode.USER_MISMATCH */);
        return UserCredentialImpl._forOperation(user, operationType, response);
    }
    catch (e) {
        // Convert user deleted error into user mismatch
        if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${"user-not-found" /* AuthErrorCode.USER_DELETED */}`) {
            _fail(auth, "user-mismatch" /* AuthErrorCode.USER_MISMATCH */);
        }
        throw e;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _signInWithCredential(auth, credential, bypassAuthState = false) {
    const operationType = "signIn" /* OperationType.SIGN_IN */;
    const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);
    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);
    if (!bypassAuthState) {
        await auth._updateCurrentUser(userCredential.user);
    }
    return userCredential;
}
/**
 * Asynchronously signs in with the given credentials.
 *
 * @remarks
 * An {@link AuthProvider} can be used to generate the credential.
 *
 * @param auth - The {@link Auth} instance.
 * @param credential - The auth credential.
 *
 * @public
 */
async function signInWithCredential(auth, credential) {
    return _signInWithCredential(_castAuth(auth), credential);
}
/**
 * Links the user account with the given credentials.
 *
 * @remarks
 * An {@link AuthProvider} can be used to generate the credential.
 *
 * @param user - The user.
 * @param credential - The auth credential.
 *
 * @public
 */
async function linkWithCredential(user, credential) {
    const userInternal = getModularInstance(user);
    await _assertLinkedStatus(false, userInternal, credential.providerId);
    return _link$1(userInternal, credential);
}
/**
 * Re-authenticates a user using a fresh credential.
 *
 * @remarks
 * Use before operations such as {@link updatePassword} that require tokens from recent sign-in
 * attempts. This method can be used to recover from a `CREDENTIAL_TOO_OLD_LOGIN_AGAIN` error
 * or a `TOKEN_EXPIRED` error.
 *
 * @param user - The user.
 * @param credential - The auth credential.
 *
 * @public
 */
async function reauthenticateWithCredential(user, credential) {
    return _reauthenticate(getModularInstance(user), credential);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithCustomToken$1(auth, request) {
    return _performSignInRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:signInWithCustomToken" /* Endpoint.SIGN_IN_WITH_CUSTOM_TOKEN */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Asynchronously signs in using a custom token.
 *
 * @remarks
 * Custom tokens are used to integrate Firebase Auth with existing auth systems, and must
 * be generated by an auth backend using the
 * {@link https://firebase.google.com/docs/reference/admin/node/admin.auth.Auth#createcustomtoken | createCustomToken}
 * method in the {@link https://firebase.google.com/docs/auth/admin | Admin SDK} .
 *
 * Fails with an error if the token is invalid, expired, or not accepted by the Firebase Auth service.
 *
 * @param auth - The {@link Auth} instance.
 * @param customToken - The custom token to sign in with.
 *
 * @public
 */
async function signInWithCustomToken(auth, customToken) {
    const authInternal = _castAuth(auth);
    const response = await signInWithCustomToken$1(authInternal, {
        token: customToken,
        returnSecureToken: true
    });
    const cred = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn" /* OperationType.SIGN_IN */, response);
    await authInternal._updateCurrentUser(cred.user);
    return cred;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiFactorInfoImpl {
    constructor(factorId, response) {
        this.factorId = factorId;
        this.uid = response.mfaEnrollmentId;
        this.enrollmentTime = new Date(response.enrolledAt).toUTCString();
        this.displayName = response.displayName;
    }
    static _fromServerResponse(auth, enrollment) {
        if ('phoneInfo' in enrollment) {
            return PhoneMultiFactorInfoImpl._fromServerResponse(auth, enrollment);
        }
        else if ('totpInfo' in enrollment) {
            return TotpMultiFactorInfoImpl._fromServerResponse(auth, enrollment);
        }
        return _fail(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    }
}
class PhoneMultiFactorInfoImpl extends (/* unused pure expression or super */ null && (MultiFactorInfoImpl)) {
    constructor(response) {
        super("phone" /* FactorId.PHONE */, response);
        this.phoneNumber = response.phoneInfo;
    }
    static _fromServerResponse(_auth, enrollment) {
        return new PhoneMultiFactorInfoImpl(enrollment);
    }
}
class TotpMultiFactorInfoImpl extends (/* unused pure expression or super */ null && (MultiFactorInfoImpl)) {
    constructor(response) {
        super("totp" /* FactorId.TOTP */, response);
    }
    static _fromServerResponse(_auth, enrollment) {
        return new TotpMultiFactorInfoImpl(enrollment);
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {
    var _a;
    _assert(((_a = actionCodeSettings.url) === null || _a === void 0 ? void 0 : _a.length) > 0, auth, "invalid-continue-uri" /* AuthErrorCode.INVALID_CONTINUE_URI */);
    _assert(typeof actionCodeSettings.dynamicLinkDomain === 'undefined' ||
        actionCodeSettings.dynamicLinkDomain.length > 0, auth, "invalid-dynamic-link-domain" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */);
    request.continueUrl = actionCodeSettings.url;
    request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
    request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;
    if (actionCodeSettings.iOS) {
        _assert(actionCodeSettings.iOS.bundleId.length > 0, auth, "missing-ios-bundle-id" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */);
        request.iOSBundleId = actionCodeSettings.iOS.bundleId;
    }
    if (actionCodeSettings.android) {
        _assert(actionCodeSettings.android.packageName.length > 0, auth, "missing-android-pkg-name" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */);
        request.androidInstallApp = actionCodeSettings.android.installApp;
        request.androidMinimumVersionCode =
            actionCodeSettings.android.minimumVersion;
        request.androidPackageName = actionCodeSettings.android.packageName;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Sends a password reset email to the given email address.
 *
 * @remarks
 * To complete the password reset, call {@link confirmPasswordReset} with the code supplied in
 * the email sent to the user, along with the new password specified by the user.
 *
 * @example
 * ```javascript
 * const actionCodeSettings = {
 *   url: 'https://www.example.com/?email=user@example.com',
 *   iOS: {
 *      bundleId: 'com.example.ios'
 *   },
 *   android: {
 *     packageName: 'com.example.android',
 *     installApp: true,
 *     minimumVersion: '12'
 *   },
 *   handleCodeInApp: true
 * };
 * await sendPasswordResetEmail(auth, 'user@example.com', actionCodeSettings);
 * // Obtain code from user.
 * await confirmPasswordReset('user@example.com', code);
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param email - The user's email address.
 * @param actionCodeSettings - The {@link ActionCodeSettings}.
 *
 * @public
 */
async function sendPasswordResetEmail(auth, email, actionCodeSettings) {
    var _a;
    const authInternal = _castAuth(auth);
    const request = {
        requestType: "PASSWORD_RESET" /* ActionCodeOperation.PASSWORD_RESET */,
        email,
        clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */
    };
    if ((_a = authInternal._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.emailPasswordEnabled) {
        const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "getOobCode" /* RecaptchaActionName.GET_OOB_CODE */, true);
        if (actionCodeSettings) {
            _setActionCodeSettingsOnRequest(authInternal, requestWithRecaptcha, actionCodeSettings);
        }
        await sendPasswordResetEmail$1(authInternal, requestWithRecaptcha);
    }
    else {
        if (actionCodeSettings) {
            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);
        }
        await sendPasswordResetEmail$1(authInternal, request)
            .catch(async (error) => {
            if (error.code === `auth/${"missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {
                console.log('Password resets are protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the password reset flow.');
                const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "getOobCode" /* RecaptchaActionName.GET_OOB_CODE */, true);
                if (actionCodeSettings) {
                    _setActionCodeSettingsOnRequest(authInternal, requestWithRecaptcha, actionCodeSettings);
                }
                await sendPasswordResetEmail$1(authInternal, requestWithRecaptcha);
            }
            else {
                return Promise.reject(error);
            }
        });
    }
}
/**
 * Completes the password reset process, given a confirmation code and new password.
 *
 * @param auth - The {@link Auth} instance.
 * @param oobCode - A confirmation code sent to the user.
 * @param newPassword - The new password.
 *
 * @public
 */
async function confirmPasswordReset(auth, oobCode, newPassword) {
    await resetPassword(getModularInstance(auth), {
        oobCode,
        newPassword
    });
    // Do not return the email.
}
/**
 * Applies a verification code sent to the user by email or other out-of-band mechanism.
 *
 * @param auth - The {@link Auth} instance.
 * @param oobCode - A verification code sent to the user.
 *
 * @public
 */
async function applyActionCode(auth, oobCode) {
    await applyActionCode$1(getModularInstance(auth), { oobCode });
}
/**
 * Checks a verification code sent to the user by email or other out-of-band mechanism.
 *
 * @returns metadata about the code.
 *
 * @param auth - The {@link Auth} instance.
 * @param oobCode - A verification code sent to the user.
 *
 * @public
 */
async function checkActionCode(auth, oobCode) {
    const authModular = getModularInstance(auth);
    const response = await resetPassword(authModular, { oobCode });
    // Email could be empty only if the request type is EMAIL_SIGNIN or
    // VERIFY_AND_CHANGE_EMAIL.
    // New email should not be empty if the request type is
    // VERIFY_AND_CHANGE_EMAIL.
    // Multi-factor info could not be empty if the request type is
    // REVERT_SECOND_FACTOR_ADDITION.
    const operation = response.requestType;
    _assert(operation, authModular, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    switch (operation) {
        case "EMAIL_SIGNIN" /* ActionCodeOperation.EMAIL_SIGNIN */:
            break;
        case "VERIFY_AND_CHANGE_EMAIL" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */:
            _assert(response.newEmail, authModular, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
            break;
        case "REVERT_SECOND_FACTOR_ADDITION" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */:
            _assert(response.mfaInfo, authModular, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        // fall through
        default:
            _assert(response.email, authModular, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    }
    // The multi-factor info for revert second factor addition
    let multiFactorInfo = null;
    if (response.mfaInfo) {
        multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);
    }
    return {
        data: {
            email: (response.requestType === "VERIFY_AND_CHANGE_EMAIL" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */
                ? response.newEmail
                : response.email) || null,
            previousEmail: (response.requestType === "VERIFY_AND_CHANGE_EMAIL" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */
                ? response.email
                : response.newEmail) || null,
            multiFactorInfo
        },
        operation
    };
}
/**
 * Checks a password reset code sent to the user by email or other out-of-band mechanism.
 *
 * @returns the user's email address if valid.
 *
 * @param auth - The {@link Auth} instance.
 * @param code - A verification code sent to the user.
 *
 * @public
 */
async function verifyPasswordResetCode(auth, code) {
    const { data } = await checkActionCode(getModularInstance(auth), code);
    // Email should always be present since a code was sent to it
    return data.email;
}
/**
 * Creates a new user account associated with the specified email address and password.
 *
 * @remarks
 * On successful creation of the user account, this user will also be signed in to your application.
 *
 * User account creation can fail if the account already exists or the password is invalid.
 *
 * Note: The email address acts as a unique identifier for the user and enables an email-based
 * password reset. This function will create a new user account and set the initial user password.
 *
 * @param auth - The {@link Auth} instance.
 * @param email - The user's email address.
 * @param password - The user's chosen password.
 *
 * @public
 */
async function createUserWithEmailAndPassword(auth, email, password) {
    var _a;
    const authInternal = _castAuth(auth);
    const request = {
        returnSecureToken: true,
        email,
        password,
        clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */
    };
    let signUpResponse;
    if ((_a = authInternal._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.emailPasswordEnabled) {
        const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "signUpPassword" /* RecaptchaActionName.SIGN_UP_PASSWORD */);
        signUpResponse = signUp(authInternal, requestWithRecaptcha);
    }
    else {
        signUpResponse = signUp(authInternal, request).catch(async (error) => {
            if (error.code === `auth/${"missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {
                console.log('Sign-up is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-up flow.');
                const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "signUpPassword" /* RecaptchaActionName.SIGN_UP_PASSWORD */);
                return signUp(authInternal, requestWithRecaptcha);
            }
            else {
                return Promise.reject(error);
            }
        });
    }
    const response = await signUpResponse.catch(error => {
        return Promise.reject(error);
    });
    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn" /* OperationType.SIGN_IN */, response);
    await authInternal._updateCurrentUser(userCredential.user);
    return userCredential;
}
/**
 * Asynchronously signs in using an email and password.
 *
 * @remarks
 * Fails with an error if the email address and password do not match.
 *
 * Note: The user's password is NOT the password used to access the user's email account. The
 * email address serves as a unique identifier for the user, and the password is used to access
 * the user's account in your Firebase project. See also: {@link createUserWithEmailAndPassword}.
 *
 * @param auth - The {@link Auth} instance.
 * @param email - The users email address.
 * @param password - The users password.
 *
 * @public
 */
function signInWithEmailAndPassword(auth, email, password) {
    return signInWithCredential(getModularInstance(auth), EmailAuthProvider.credential(email, password));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Sends a sign-in email link to the user with the specified email.
 *
 * @remarks
 * The sign-in operation has to always be completed in the app unlike other out of band email
 * actions (password reset and email verifications). This is because, at the end of the flow,
 * the user is expected to be signed in and their Auth state persisted within the app.
 *
 * To complete sign in with the email link, call {@link signInWithEmailLink} with the email
 * address and the email link supplied in the email sent to the user.
 *
 * @example
 * ```javascript
 * const actionCodeSettings = {
 *   url: 'https://www.example.com/?email=user@example.com',
 *   iOS: {
 *      bundleId: 'com.example.ios'
 *   },
 *   android: {
 *     packageName: 'com.example.android',
 *     installApp: true,
 *     minimumVersion: '12'
 *   },
 *   handleCodeInApp: true
 * };
 * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);
 * // Obtain emailLink from the user.
 * if(isSignInWithEmailLink(auth, emailLink)) {
 *   await signInWithEmailLink(auth, 'user@example.com', emailLink);
 * }
 * ```
 *
 * @param authInternal - The {@link Auth} instance.
 * @param email - The user's email address.
 * @param actionCodeSettings - The {@link ActionCodeSettings}.
 *
 * @public
 */
async function sendSignInLinkToEmail(auth, email, actionCodeSettings) {
    var _a;
    const authInternal = _castAuth(auth);
    const request = {
        requestType: "EMAIL_SIGNIN" /* ActionCodeOperation.EMAIL_SIGNIN */,
        email,
        clientType: "CLIENT_TYPE_WEB" /* RecaptchaClientType.WEB */
    };
    function setActionCodeSettings(request, actionCodeSettings) {
        _assert(actionCodeSettings.handleCodeInApp, authInternal, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        if (actionCodeSettings) {
            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);
        }
    }
    if ((_a = authInternal._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.emailPasswordEnabled) {
        const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "getOobCode" /* RecaptchaActionName.GET_OOB_CODE */, true);
        setActionCodeSettings(requestWithRecaptcha, actionCodeSettings);
        await sendSignInLinkToEmail$1(authInternal, requestWithRecaptcha);
    }
    else {
        setActionCodeSettings(request, actionCodeSettings);
        await sendSignInLinkToEmail$1(authInternal, request)
            .catch(async (error) => {
            if (error.code === `auth/${"missing-recaptcha-token" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {
                console.log('Email link sign-in is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-in flow.');
                const requestWithRecaptcha = await injectRecaptchaFields(authInternal, request, "getOobCode" /* RecaptchaActionName.GET_OOB_CODE */, true);
                setActionCodeSettings(requestWithRecaptcha, actionCodeSettings);
                await sendSignInLinkToEmail$1(authInternal, requestWithRecaptcha);
            }
            else {
                return Promise.reject(error);
            }
        });
    }
}
/**
 * Checks if an incoming link is a sign-in with email link suitable for {@link signInWithEmailLink}.
 *
 * @param auth - The {@link Auth} instance.
 * @param emailLink - The link sent to the user's email address.
 *
 * @public
 */
function isSignInWithEmailLink(auth, emailLink) {
    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);
    return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === "EMAIL_SIGNIN" /* ActionCodeOperation.EMAIL_SIGNIN */;
}
/**
 * Asynchronously signs in using an email and sign-in email link.
 *
 * @remarks
 * If no link is passed, the link is inferred from the current URL.
 *
 * Fails with an error if the email address is invalid or OTP in email link expires.
 *
 * Note: Confirm the link is a sign-in email link before calling this method firebase.auth.Auth.isSignInWithEmailLink.
 *
 * @example
 * ```javascript
 * const actionCodeSettings = {
 *   url: 'https://www.example.com/?email=user@example.com',
 *   iOS: {
 *      bundleId: 'com.example.ios'
 *   },
 *   android: {
 *     packageName: 'com.example.android',
 *     installApp: true,
 *     minimumVersion: '12'
 *   },
 *   handleCodeInApp: true
 * };
 * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);
 * // Obtain emailLink from the user.
 * if(isSignInWithEmailLink(auth, emailLink)) {
 *   await signInWithEmailLink(auth, 'user@example.com', emailLink);
 * }
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param email - The user's email address.
 * @param emailLink - The link sent to the user's email address.
 *
 * @public
 */
async function signInWithEmailLink(auth, email, emailLink) {
    const authModular = getModularInstance(auth);
    const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());
    // Check if the tenant ID in the email link matches the tenant ID on Auth
    // instance.
    _assert(credential._tenantId === (authModular.tenantId || null), authModular, "tenant-id-mismatch" /* AuthErrorCode.TENANT_ID_MISMATCH */);
    return signInWithCredential(authModular, credential);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function createAuthUri(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:createAuthUri" /* Endpoint.CREATE_AUTH_URI */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Gets the list of possible sign in methods for the given email address.
 *
 * @remarks
 * This is useful to differentiate methods of sign-in for the same provider, eg.
 * {@link EmailAuthProvider} which has 2 methods of sign-in,
 * {@link SignInMethod}.EMAIL_PASSWORD and
 * {@link SignInMethod}.EMAIL_LINK.
 *
 * @param auth - The {@link Auth} instance.
 * @param email - The user's email address.
 *
 * @public
 */
async function fetchSignInMethodsForEmail(auth, email) {
    // createAuthUri returns an error if continue URI is not http or https.
    // For environments like Cordova, Chrome extensions, native frameworks, file
    // systems, etc, use http://localhost as continue URL.
    const continueUri = _isHttpOrHttps() ? _getCurrentUrl() : 'http://localhost';
    const request = {
        identifier: email,
        continueUri
    };
    const { signinMethods } = await createAuthUri(getModularInstance(auth), request);
    return signinMethods || [];
}
/**
 * Sends a verification email to a user.
 *
 * @remarks
 * The verification process is completed by calling {@link applyActionCode}.
 *
 * @example
 * ```javascript
 * const actionCodeSettings = {
 *   url: 'https://www.example.com/?email=user@example.com',
 *   iOS: {
 *      bundleId: 'com.example.ios'
 *   },
 *   android: {
 *     packageName: 'com.example.android',
 *     installApp: true,
 *     minimumVersion: '12'
 *   },
 *   handleCodeInApp: true
 * };
 * await sendEmailVerification(user, actionCodeSettings);
 * // Obtain code from the user.
 * await applyActionCode(auth, code);
 * ```
 *
 * @param user - The user.
 * @param actionCodeSettings - The {@link ActionCodeSettings}.
 *
 * @public
 */
async function sendEmailVerification(user, actionCodeSettings) {
    const userInternal = getModularInstance(user);
    const idToken = await user.getIdToken();
    const request = {
        requestType: "VERIFY_EMAIL" /* ActionCodeOperation.VERIFY_EMAIL */,
        idToken
    };
    if (actionCodeSettings) {
        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
    }
    const { email } = await sendEmailVerification$1(userInternal.auth, request);
    if (email !== user.email) {
        await user.reload();
    }
}
/**
 * Sends a verification email to a new email address.
 *
 * @remarks
 * The user's email will be updated to the new one after being verified.
 *
 * If you have a custom email action handler, you can complete the verification process by calling
 * {@link applyActionCode}.
 *
 * @example
 * ```javascript
 * const actionCodeSettings = {
 *   url: 'https://www.example.com/?email=user@example.com',
 *   iOS: {
 *      bundleId: 'com.example.ios'
 *   },
 *   android: {
 *     packageName: 'com.example.android',
 *     installApp: true,
 *     minimumVersion: '12'
 *   },
 *   handleCodeInApp: true
 * };
 * await verifyBeforeUpdateEmail(user, 'newemail@example.com', actionCodeSettings);
 * // Obtain code from the user.
 * await applyActionCode(auth, code);
 * ```
 *
 * @param user - The user.
 * @param newEmail - The new email address to be verified before update.
 * @param actionCodeSettings - The {@link ActionCodeSettings}.
 *
 * @public
 */
async function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {
    const userInternal = getModularInstance(user);
    const idToken = await user.getIdToken();
    const request = {
        requestType: "VERIFY_AND_CHANGE_EMAIL" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */,
        idToken,
        newEmail
    };
    if (actionCodeSettings) {
        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
    }
    const { email } = await verifyAndChangeEmail(userInternal.auth, request);
    if (email !== user.email) {
        // If the local copy of the email on user is outdated, reload the
        // user.
        await user.reload();
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function updateProfile$1(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v1/accounts:update" /* Endpoint.SET_ACCOUNT_INFO */, request);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Updates a user's profile data.
 *
 * @param user - The user.
 * @param profile - The profile's `displayName` and `photoURL` to update.
 *
 * @public
 */
async function updateProfile(user, { displayName, photoURL: photoUrl }) {
    if (displayName === undefined && photoUrl === undefined) {
        return;
    }
    const userInternal = getModularInstance(user);
    const idToken = await userInternal.getIdToken();
    const profileRequest = {
        idToken,
        displayName,
        photoUrl,
        returnSecureToken: true
    };
    const response = await _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest));
    userInternal.displayName = response.displayName || null;
    userInternal.photoURL = response.photoUrl || null;
    // Update the password provider as well
    const passwordProvider = userInternal.providerData.find(({ providerId }) => providerId === "password" /* ProviderId.PASSWORD */);
    if (passwordProvider) {
        passwordProvider.displayName = userInternal.displayName;
        passwordProvider.photoURL = userInternal.photoURL;
    }
    await userInternal._updateTokensIfNecessary(response);
}
/**
 * Updates the user's email address.
 *
 * @remarks
 * An email will be sent to the original email address (if it was set) that allows to revoke the
 * email address change, in order to protect them from account hijacking.
 *
 * Important: this is a security sensitive operation that requires the user to have recently signed
 * in. If this requirement isn't met, ask the user to authenticate again and then call
 * {@link reauthenticateWithCredential}.
 *
 * @param user - The user.
 * @param newEmail - The new email address.
 *
 * @public
 */
function updateEmail(user, newEmail) {
    return updateEmailOrPassword(getModularInstance(user), newEmail, null);
}
/**
 * Updates the user's password.
 *
 * @remarks
 * Important: this is a security sensitive operation that requires the user to have recently signed
 * in. If this requirement isn't met, ask the user to authenticate again and then call
 * {@link reauthenticateWithCredential}.
 *
 * @param user - The user.
 * @param newPassword - The new password.
 *
 * @public
 */
function updatePassword(user, newPassword) {
    return updateEmailOrPassword(getModularInstance(user), null, newPassword);
}
async function updateEmailOrPassword(user, email, password) {
    const { auth } = user;
    const idToken = await user.getIdToken();
    const request = {
        idToken,
        returnSecureToken: true
    };
    if (email) {
        request.email = email;
    }
    if (password) {
        request.password = password;
    }
    const response = await _logoutIfInvalidated(user, updateEmailPassword(auth, request));
    await user._updateTokensIfNecessary(response, /* reload */ true);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Parse the `AdditionalUserInfo` from the ID token response.
 *
 */
function _fromIdTokenResponse(idTokenResponse) {
    var _a, _b;
    if (!idTokenResponse) {
        return null;
    }
    const { providerId } = idTokenResponse;
    const profile = idTokenResponse.rawUserInfo
        ? JSON.parse(idTokenResponse.rawUserInfo)
        : {};
    const isNewUser = idTokenResponse.isNewUser ||
        idTokenResponse.kind === "identitytoolkit#SignupNewUserResponse" /* IdTokenResponseKind.SignupNewUser */;
    if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {
        const signInProvider = (_b = (_a = _parseToken(idTokenResponse.idToken)) === null || _a === void 0 ? void 0 : _a.firebase) === null || _b === void 0 ? void 0 : _b['sign_in_provider'];
        if (signInProvider) {
            const filteredProviderId = signInProvider !== "anonymous" /* ProviderId.ANONYMOUS */ &&
                signInProvider !== "custom" /* ProviderId.CUSTOM */
                ? signInProvider
                : null;
            // Uses generic class in accordance with the legacy SDK.
            return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);
        }
    }
    if (!providerId) {
        return null;
    }
    switch (providerId) {
        case "facebook.com" /* ProviderId.FACEBOOK */:
            return new FacebookAdditionalUserInfo(isNewUser, profile);
        case "github.com" /* ProviderId.GITHUB */:
            return new GithubAdditionalUserInfo(isNewUser, profile);
        case "google.com" /* ProviderId.GOOGLE */:
            return new GoogleAdditionalUserInfo(isNewUser, profile);
        case "twitter.com" /* ProviderId.TWITTER */:
            return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);
        case "custom" /* ProviderId.CUSTOM */:
        case "anonymous" /* ProviderId.ANONYMOUS */:
            return new GenericAdditionalUserInfo(isNewUser, null);
        default:
            return new GenericAdditionalUserInfo(isNewUser, providerId, profile);
    }
}
class GenericAdditionalUserInfo {
    constructor(isNewUser, providerId, profile = {}) {
        this.isNewUser = isNewUser;
        this.providerId = providerId;
        this.profile = profile;
    }
}
class FederatedAdditionalUserInfoWithUsername extends (/* unused pure expression or super */ null && (GenericAdditionalUserInfo)) {
    constructor(isNewUser, providerId, profile, username) {
        super(isNewUser, providerId, profile);
        this.username = username;
    }
}
class FacebookAdditionalUserInfo extends (/* unused pure expression or super */ null && (GenericAdditionalUserInfo)) {
    constructor(isNewUser, profile) {
        super(isNewUser, "facebook.com" /* ProviderId.FACEBOOK */, profile);
    }
}
class GithubAdditionalUserInfo extends (/* unused pure expression or super */ null && (FederatedAdditionalUserInfoWithUsername)) {
    constructor(isNewUser, profile) {
        super(isNewUser, "github.com" /* ProviderId.GITHUB */, profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === 'string' ? profile === null || profile === void 0 ? void 0 : profile.login : null);
    }
}
class GoogleAdditionalUserInfo extends (/* unused pure expression or super */ null && (GenericAdditionalUserInfo)) {
    constructor(isNewUser, profile) {
        super(isNewUser, "google.com" /* ProviderId.GOOGLE */, profile);
    }
}
class TwitterAdditionalUserInfo extends (/* unused pure expression or super */ null && (FederatedAdditionalUserInfoWithUsername)) {
    constructor(isNewUser, profile, screenName) {
        super(isNewUser, "twitter.com" /* ProviderId.TWITTER */, profile, screenName);
    }
}
/**
 * Extracts provider specific {@link AdditionalUserInfo} for the given credential.
 *
 * @param userCredential - The user credential.
 *
 * @public
 */
function getAdditionalUserInfo(userCredential) {
    const { user, _tokenResponse } = userCredential;
    if (user.isAnonymous && !_tokenResponse) {
        // Handle the special case where signInAnonymously() gets called twice.
        // No network call is made so there's nothing to actually fill this in
        return {
            providerId: null,
            isNewUser: false,
            profile: null
        };
    }
    return _fromIdTokenResponse(_tokenResponse);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Non-optional auth methods.
/**
 * Changes the type of persistence on the {@link Auth} instance for the currently saved
 * `Auth` session and applies this type of persistence for future sign-in requests, including
 * sign-in with redirect requests.
 *
 * @remarks
 * This makes it easy for a user signing in to specify whether their session should be
 * remembered or not. It also makes it easier to never persist the `Auth` state for applications
 * that are shared by other users or have sensitive data.
 *
 * @example
 * ```javascript
 * setPersistence(auth, browserSessionPersistence);
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param persistence - The {@link Persistence} to use.
 * @returns A `Promise` that resolves once the persistence change has completed
 *
 * @public
 */
function setPersistence(auth, persistence) {
    return getModularInstance(auth).setPersistence(persistence);
}
/**
 * Loads the reCAPTCHA configuration into the `Auth` instance.
 *
 * @remarks
 * This will load the reCAPTCHA config, which indicates whether the reCAPTCHA
 * verification flow should be triggered for each auth provider, into the
 * current Auth session.
 *
 * If initializeRecaptchaConfig() is not invoked, the auth flow will always start
 * without reCAPTCHA verification. If the provider is configured to require reCAPTCHA
 * verification, the SDK will transparently load the reCAPTCHA config and restart the
 * auth flows.
 *
 * Thus, by calling this optional method, you will reduce the latency of future auth flows.
 * Loading the reCAPTCHA config early will also enhance the signal collected by reCAPTCHA.
 *
 * @example
 * ```javascript
 * initializeRecaptchaConfig(auth);
 * ```
 *
 * @param auth - The {@link Auth} instance.
 *
 * @public
 */
function initializeRecaptchaConfig(auth) {
    const authInternal = _castAuth(auth);
    return authInternal.initializeRecaptchaConfig();
}
/**
 * Adds an observer for changes to the signed-in user's ID token.
 *
 * @remarks
 * This includes sign-in, sign-out, and token refresh events.
 * This will not be triggered automatically upon ID token expiration. Use {@link User.getIdToken} to refresh the ID token.
 *
 * @param auth - The {@link Auth} instance.
 * @param nextOrObserver - callback triggered on change.
 * @param error - Deprecated. This callback is never triggered. Errors
 * on signing in/out can be caught in promises returned from
 * sign-in/sign-out functions.
 * @param completed - Deprecated. This callback is never triggered.
 *
 * @public
 */
function onIdTokenChanged(auth, nextOrObserver, error, completed) {
    return index_esm2017_getModularInstance(auth).onIdTokenChanged(nextOrObserver, error, completed);
}
/**
 * Adds a blocking callback that runs before an auth state change
 * sets a new user.
 *
 * @param auth - The {@link Auth} instance.
 * @param callback - callback triggered before new user value is set.
 *   If this throws, it blocks the user from being set.
 * @param onAbort - callback triggered if a later `beforeAuthStateChanged()`
 *   callback throws, allowing you to undo any side effects.
 */
function beforeAuthStateChanged(auth, callback, onAbort) {
    return index_esm2017_getModularInstance(auth).beforeAuthStateChanged(callback, onAbort);
}
/**
 * Adds an observer for changes to the user's sign-in state.
 *
 * @remarks
 * To keep the old behavior, see {@link onIdTokenChanged}.
 *
 * @param auth - The {@link Auth} instance.
 * @param nextOrObserver - callback triggered on change.
 * @param error - Deprecated. This callback is never triggered. Errors
 * on signing in/out can be caught in promises returned from
 * sign-in/sign-out functions.
 * @param completed - Deprecated. This callback is never triggered.
 *
 * @public
 */
function onAuthStateChanged(auth, nextOrObserver, error, completed) {
    return getModularInstance(auth).onAuthStateChanged(nextOrObserver, error, completed);
}
/**
 * Sets the current language to the default device/browser preference.
 *
 * @param auth - The {@link Auth} instance.
 *
 * @public
 */
function useDeviceLanguage(auth) {
    getModularInstance(auth).useDeviceLanguage();
}
/**
 * Asynchronously sets the provided user as {@link Auth.currentUser} on the
 * {@link Auth} instance.
 *
 * @remarks
 * A new instance copy of the user provided will be made and set as currentUser.
 *
 * This will trigger {@link onAuthStateChanged} and {@link onIdTokenChanged} listeners
 * like other sign in methods.
 *
 * The operation fails with an error if the user to be updated belongs to a different Firebase
 * project.
 *
 * @param auth - The {@link Auth} instance.
 * @param user - The new {@link User}.
 *
 * @public
 */
function updateCurrentUser(auth, user) {
    return getModularInstance(auth).updateCurrentUser(user);
}
/**
 * Signs out the current user.
 *
 * @param auth - The {@link Auth} instance.
 *
 * @public
 */
function signOut(auth) {
    return getModularInstance(auth).signOut();
}
/**
 * Deletes and signs out the user.
 *
 * @remarks
 * Important: this is a security-sensitive operation that requires the user to have recently
 * signed in. If this requirement isn't met, ask the user to authenticate again and then call
 * {@link reauthenticateWithCredential}.
 *
 * @param user - The user.
 *
 * @public
 */
async function deleteUser(user) {
    return getModularInstance(user).delete();
}

class MultiFactorSessionImpl {
    constructor(type, credential, auth) {
        this.type = type;
        this.credential = credential;
        this.auth = auth;
    }
    static _fromIdtoken(idToken, auth) {
        return new MultiFactorSessionImpl("enroll" /* MultiFactorSessionType.ENROLL */, idToken, auth);
    }
    static _fromMfaPendingCredential(mfaPendingCredential) {
        return new MultiFactorSessionImpl("signin" /* MultiFactorSessionType.SIGN_IN */, mfaPendingCredential);
    }
    toJSON() {
        const key = this.type === "enroll" /* MultiFactorSessionType.ENROLL */
            ? 'idToken'
            : 'pendingCredential';
        return {
            multiFactorSession: {
                [key]: this.credential
            }
        };
    }
    static fromJSON(obj) {
        var _a, _b;
        if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {
            if ((_a = obj.multiFactorSession) === null || _a === void 0 ? void 0 : _a.pendingCredential) {
                return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);
            }
            else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {
                return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);
            }
        }
        return null;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiFactorResolverImpl {
    constructor(session, hints, signInResolver) {
        this.session = session;
        this.hints = hints;
        this.signInResolver = signInResolver;
    }
    /** @internal */
    static _fromError(authExtern, error) {
        const auth = _castAuth(authExtern);
        const serverResponse = error.customData._serverResponse;
        const hints = (serverResponse.mfaInfo || []).map(enrollment => MultiFactorInfoImpl._fromServerResponse(auth, enrollment));
        _assert(serverResponse.mfaPendingCredential, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);
        return new MultiFactorResolverImpl(session, hints, async (assertion) => {
            const mfaResponse = await assertion._process(auth, session);
            // Clear out the unneeded fields from the old login response
            delete serverResponse.mfaInfo;
            delete serverResponse.mfaPendingCredential;
            // Use in the new token & refresh token in the old response
            const idTokenResponse = Object.assign(Object.assign({}, serverResponse), { idToken: mfaResponse.idToken, refreshToken: mfaResponse.refreshToken });
            // TODO: we should collapse this switch statement into UserCredentialImpl._forOperation and have it support the SIGN_IN case
            switch (error.operationType) {
                case "signIn" /* OperationType.SIGN_IN */:
                    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse);
                    await auth._updateCurrentUser(userCredential.user);
                    return userCredential;
                case "reauthenticate" /* OperationType.REAUTHENTICATE */:
                    _assert(error.user, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                    return UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse);
                default:
                    _fail(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
            }
        });
    }
    async resolveSignIn(assertionExtern) {
        const assertion = assertionExtern;
        return this.signInResolver(assertion);
    }
}
/**
 * Provides a {@link MultiFactorResolver} suitable for completion of a
 * multi-factor flow.
 *
 * @param auth - The {@link Auth} instance.
 * @param error - The {@link MultiFactorError} raised during a sign-in, or
 * reauthentication operation.
 *
 * @public
 */
function getMultiFactorResolver(auth, error) {
    var _a;
    const authModular = getModularInstance(auth);
    const errorInternal = error;
    _assert(error.customData.operationType, authModular, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
    _assert((_a = errorInternal.customData._serverResponse) === null || _a === void 0 ? void 0 : _a.mfaPendingCredential, authModular, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
    return MultiFactorResolverImpl._fromError(authModular, errorInternal);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function startEnrollPhoneMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaEnrollment:start" /* Endpoint.START_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));
}
function finalizeEnrollPhoneMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaEnrollment:finalize" /* Endpoint.FINALIZE_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));
}
function startEnrollTotpMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaEnrollment:start" /* Endpoint.START_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));
}
function finalizeEnrollTotpMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaEnrollment:finalize" /* Endpoint.FINALIZE_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));
}
function withdrawMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaEnrollment:withdraw" /* Endpoint.WITHDRAW_MFA */, _addTidIfNecessary(auth, request));
}

class MultiFactorUserImpl {
    constructor(user) {
        this.user = user;
        this.enrolledFactors = [];
        user._onReload(userInfo => {
            if (userInfo.mfaInfo) {
                this.enrolledFactors = userInfo.mfaInfo.map(enrollment => MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment));
            }
        });
    }
    static _fromUser(user) {
        return new MultiFactorUserImpl(user);
    }
    async getSession() {
        return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken(), this.user.auth);
    }
    async enroll(assertionExtern, displayName) {
        const assertion = assertionExtern;
        const session = (await this.getSession());
        const finalizeMfaResponse = await _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName));
        // New tokens will be issued after enrollment of the new second factors.
        // They need to be updated on the user.
        await this.user._updateTokensIfNecessary(finalizeMfaResponse);
        // The user needs to be reloaded to get the new multi-factor information
        // from server. USER_RELOADED event will be triggered and `enrolledFactors`
        // will be updated.
        return this.user.reload();
    }
    async unenroll(infoOrUid) {
        const mfaEnrollmentId = typeof infoOrUid === 'string' ? infoOrUid : infoOrUid.uid;
        const idToken = await this.user.getIdToken();
        try {
            const idTokenResponse = await _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {
                idToken,
                mfaEnrollmentId
            }));
            // Remove the second factor from the user's list.
            this.enrolledFactors = this.enrolledFactors.filter(({ uid }) => uid !== mfaEnrollmentId);
            // Depending on whether the backend decided to revoke the user's session,
            // the tokenResponse may be empty. If the tokens were not updated (and they
            // are now invalid), reloading the user will discover this and invalidate
            // the user's state accordingly.
            await this.user._updateTokensIfNecessary(idTokenResponse);
            await this.user.reload();
        }
        catch (e) {
            throw e;
        }
    }
}
const multiFactorUserCache = new WeakMap();
/**
 * The {@link MultiFactorUser} corresponding to the user.
 *
 * @remarks
 * This is used to access all multi-factor properties and operations related to the user.
 *
 * @param user - The user.
 *
 * @public
 */
function multiFactor(user) {
    const userModular = getModularInstance(user);
    if (!multiFactorUserCache.has(userModular)) {
        multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));
    }
    return multiFactorUserCache.get(userModular);
}

const STORAGE_AVAILABLE_KEY = '__sak';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// There are two different browser persistence types: local and session.
// Both have the same implementation but use a different underlying storage
// object.
class BrowserPersistenceClass {
    constructor(storageRetriever, type) {
        this.storageRetriever = storageRetriever;
        this.type = type;
    }
    _isAvailable() {
        try {
            if (!this.storage) {
                return Promise.resolve(false);
            }
            this.storage.setItem(STORAGE_AVAILABLE_KEY, '1');
            this.storage.removeItem(STORAGE_AVAILABLE_KEY);
            return Promise.resolve(true);
        }
        catch (_a) {
            return Promise.resolve(false);
        }
    }
    _set(key, value) {
        this.storage.setItem(key, JSON.stringify(value));
        return Promise.resolve();
    }
    _get(key) {
        const json = this.storage.getItem(key);
        return Promise.resolve(json ? JSON.parse(json) : null);
    }
    _remove(key) {
        this.storage.removeItem(key);
        return Promise.resolve();
    }
    get storage() {
        return this.storageRetriever();
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _iframeCannotSyncWebStorage() {
    const ua = index_esm2017_getUA();
    return _isSafari(ua) || _isIOS(ua);
}
// The polling period in case events are not supported
const _POLLING_INTERVAL_MS$1 = 1000;
// The IE 10 localStorage cross tab synchronization delay in milliseconds
const IE10_LOCAL_STORAGE_SYNC_DELAY = 10;
class BrowserLocalPersistence extends BrowserPersistenceClass {
    constructor() {
        super(() => window.localStorage, "LOCAL" /* PersistenceType.LOCAL */);
        this.boundEventHandler = (event, poll) => this.onStorageEvent(event, poll);
        this.listeners = {};
        this.localCache = {};
        // setTimeout return value is platform specific
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.pollTimer = null;
        // Safari or iOS browser and embedded in an iframe.
        this.safariLocalStorageNotSynced = _iframeCannotSyncWebStorage() && _isIframe();
        // Whether to use polling instead of depending on window events
        this.fallbackToPolling = _isMobileBrowser();
        this._shouldAllowMigration = true;
    }
    forAllChangedKeys(cb) {
        // Check all keys with listeners on them.
        for (const key of Object.keys(this.listeners)) {
            // Get value from localStorage.
            const newValue = this.storage.getItem(key);
            const oldValue = this.localCache[key];
            // If local map value does not match, trigger listener with storage event.
            // Differentiate this simulated event from the real storage event.
            if (newValue !== oldValue) {
                cb(key, oldValue, newValue);
            }
        }
    }
    onStorageEvent(event, poll = false) {
        // Key would be null in some situations, like when localStorage is cleared
        if (!event.key) {
            this.forAllChangedKeys((key, _oldValue, newValue) => {
                this.notifyListeners(key, newValue);
            });
            return;
        }
        const key = event.key;
        // Check the mechanism how this event was detected.
        // The first event will dictate the mechanism to be used.
        if (poll) {
            // Environment detects storage changes via polling.
            // Remove storage event listener to prevent possible event duplication.
            this.detachListener();
        }
        else {
            // Environment detects storage changes via storage event listener.
            // Remove polling listener to prevent possible event duplication.
            this.stopPolling();
        }
        // Safari embedded iframe. Storage event will trigger with the delta
        // changes but no changes will be applied to the iframe localStorage.
        if (this.safariLocalStorageNotSynced) {
            // Get current iframe page value.
            const storedValue = this.storage.getItem(key);
            // Value not synchronized, synchronize manually.
            if (event.newValue !== storedValue) {
                if (event.newValue !== null) {
                    // Value changed from current value.
                    this.storage.setItem(key, event.newValue);
                }
                else {
                    // Current value deleted.
                    this.storage.removeItem(key);
                }
            }
            else if (this.localCache[key] === event.newValue && !poll) {
                // Already detected and processed, do not trigger listeners again.
                return;
            }
        }
        const triggerListeners = () => {
            // Keep local map up to date in case storage event is triggered before
            // poll.
            const storedValue = this.storage.getItem(key);
            if (!poll && this.localCache[key] === storedValue) {
                // Real storage event which has already been detected, do nothing.
                // This seems to trigger in some IE browsers for some reason.
                return;
            }
            this.notifyListeners(key, storedValue);
        };
        const storedValue = this.storage.getItem(key);
        if (_isIE10() &&
            storedValue !== event.newValue &&
            event.newValue !== event.oldValue) {
            // IE 10 has this weird bug where a storage event would trigger with the
            // correct key, oldValue and newValue but localStorage.getItem(key) does
            // not yield the updated value until a few milliseconds. This ensures
            // this recovers from that situation.
            setTimeout(triggerListeners, IE10_LOCAL_STORAGE_SYNC_DELAY);
        }
        else {
            triggerListeners();
        }
    }
    notifyListeners(key, value) {
        this.localCache[key] = value;
        const listeners = this.listeners[key];
        if (listeners) {
            for (const listener of Array.from(listeners)) {
                listener(value ? JSON.parse(value) : value);
            }
        }
    }
    startPolling() {
        this.stopPolling();
        this.pollTimer = setInterval(() => {
            this.forAllChangedKeys((key, oldValue, newValue) => {
                this.onStorageEvent(new StorageEvent('storage', {
                    key,
                    oldValue,
                    newValue
                }), 
                /* poll */ true);
            });
        }, _POLLING_INTERVAL_MS$1);
    }
    stopPolling() {
        if (this.pollTimer) {
            clearInterval(this.pollTimer);
            this.pollTimer = null;
        }
    }
    attachListener() {
        window.addEventListener('storage', this.boundEventHandler);
    }
    detachListener() {
        window.removeEventListener('storage', this.boundEventHandler);
    }
    _addListener(key, listener) {
        if (Object.keys(this.listeners).length === 0) {
            // Whether browser can detect storage event when it had already been pushed to the background.
            // This may happen in some mobile browsers. A localStorage change in the foreground window
            // will not be detected in the background window via the storage event.
            // This was detected in iOS 7.x mobile browsers
            if (this.fallbackToPolling) {
                this.startPolling();
            }
            else {
                this.attachListener();
            }
        }
        if (!this.listeners[key]) {
            this.listeners[key] = new Set();
            // Populate the cache to avoid spuriously triggering on first poll.
            this.localCache[key] = this.storage.getItem(key);
        }
        this.listeners[key].add(listener);
    }
    _removeListener(key, listener) {
        if (this.listeners[key]) {
            this.listeners[key].delete(listener);
            if (this.listeners[key].size === 0) {
                delete this.listeners[key];
            }
        }
        if (Object.keys(this.listeners).length === 0) {
            this.detachListener();
            this.stopPolling();
        }
    }
    // Update local cache on base operations:
    async _set(key, value) {
        await super._set(key, value);
        this.localCache[key] = JSON.stringify(value);
    }
    async _get(key) {
        const value = await super._get(key);
        this.localCache[key] = JSON.stringify(value);
        return value;
    }
    async _remove(key) {
        await super._remove(key);
        delete this.localCache[key];
    }
}
BrowserLocalPersistence.type = 'LOCAL';
/**
 * An implementation of {@link Persistence} of type `LOCAL` using `localStorage`
 * for the underlying storage.
 *
 * @public
 */
const browserLocalPersistence = BrowserLocalPersistence;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserSessionPersistence extends BrowserPersistenceClass {
    constructor() {
        super(() => window.sessionStorage, "SESSION" /* PersistenceType.SESSION */);
    }
    _addListener(_key, _listener) {
        // Listeners are not supported for session storage since it cannot be shared across windows
        return;
    }
    _removeListener(_key, _listener) {
        // Listeners are not supported for session storage since it cannot be shared across windows
        return;
    }
}
BrowserSessionPersistence.type = 'SESSION';
/**
 * An implementation of {@link Persistence} of `SESSION` using `sessionStorage`
 * for the underlying storage.
 *
 * @public
 */
const browserSessionPersistence = BrowserSessionPersistence;

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Shim for Promise.allSettled, note the slightly different format of `fulfilled` vs `status`.
 *
 * @param promises - Array of promises to wait on.
 */
function _allSettled(promises) {
    return Promise.all(promises.map(async (promise) => {
        try {
            const value = await promise;
            return {
                fulfilled: true,
                value
            };
        }
        catch (reason) {
            return {
                fulfilled: false,
                reason
            };
        }
    }));
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface class for receiving messages.
 *
 */
class Receiver {
    constructor(eventTarget) {
        this.eventTarget = eventTarget;
        this.handlersMap = {};
        this.boundEventHandler = this.handleEvent.bind(this);
    }
    /**
     * Obtain an instance of a Receiver for a given event target, if none exists it will be created.
     *
     * @param eventTarget - An event target (such as window or self) through which the underlying
     * messages will be received.
     */
    static _getInstance(eventTarget) {
        // The results are stored in an array since objects can't be keys for other
        // objects. In addition, setting a unique property on an event target as a
        // hash map key may not be allowed due to CORS restrictions.
        const existingInstance = this.receivers.find(receiver => receiver.isListeningto(eventTarget));
        if (existingInstance) {
            return existingInstance;
        }
        const newInstance = new Receiver(eventTarget);
        this.receivers.push(newInstance);
        return newInstance;
    }
    isListeningto(eventTarget) {
        return this.eventTarget === eventTarget;
    }
    /**
     * Fans out a MessageEvent to the appropriate listeners.
     *
     * @remarks
     * Sends an {@link Status.ACK} upon receipt and a {@link Status.DONE} once all handlers have
     * finished processing.
     *
     * @param event - The MessageEvent.
     *
     */
    async handleEvent(event) {
        const messageEvent = event;
        const { eventId, eventType, data } = messageEvent.data;
        const handlers = this.handlersMap[eventType];
        if (!(handlers === null || handlers === void 0 ? void 0 : handlers.size)) {
            return;
        }
        messageEvent.ports[0].postMessage({
            status: "ack" /* _Status.ACK */,
            eventId,
            eventType
        });
        const promises = Array.from(handlers).map(async (handler) => handler(messageEvent.origin, data));
        const response = await _allSettled(promises);
        messageEvent.ports[0].postMessage({
            status: "done" /* _Status.DONE */,
            eventId,
            eventType,
            response
        });
    }
    /**
     * Subscribe an event handler for a particular event.
     *
     * @param eventType - Event name to subscribe to.
     * @param eventHandler - The event handler which should receive the events.
     *
     */
    _subscribe(eventType, eventHandler) {
        if (Object.keys(this.handlersMap).length === 0) {
            this.eventTarget.addEventListener('message', this.boundEventHandler);
        }
        if (!this.handlersMap[eventType]) {
            this.handlersMap[eventType] = new Set();
        }
        this.handlersMap[eventType].add(eventHandler);
    }
    /**
     * Unsubscribe an event handler from a particular event.
     *
     * @param eventType - Event name to unsubscribe from.
     * @param eventHandler - Optinoal event handler, if none provided, unsubscribe all handlers on this event.
     *
     */
    _unsubscribe(eventType, eventHandler) {
        if (this.handlersMap[eventType] && eventHandler) {
            this.handlersMap[eventType].delete(eventHandler);
        }
        if (!eventHandler || this.handlersMap[eventType].size === 0) {
            delete this.handlersMap[eventType];
        }
        if (Object.keys(this.handlersMap).length === 0) {
            this.eventTarget.removeEventListener('message', this.boundEventHandler);
        }
    }
}
Receiver.receivers = [];

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _generateEventId(prefix = '', digits = 10) {
    let random = '';
    for (let i = 0; i < digits; i++) {
        random += Math.floor(Math.random() * 10);
    }
    return prefix + random;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface for sending messages and waiting for a completion response.
 *
 */
class Sender {
    constructor(target) {
        this.target = target;
        this.handlers = new Set();
    }
    /**
     * Unsubscribe the handler and remove it from our tracking Set.
     *
     * @param handler - The handler to unsubscribe.
     */
    removeMessageHandler(handler) {
        if (handler.messageChannel) {
            handler.messageChannel.port1.removeEventListener('message', handler.onMessage);
            handler.messageChannel.port1.close();
        }
        this.handlers.delete(handler);
    }
    /**
     * Send a message to the Receiver located at {@link target}.
     *
     * @remarks
     * We'll first wait a bit for an ACK , if we get one we will wait significantly longer until the
     * receiver has had a chance to fully process the event.
     *
     * @param eventType - Type of event to send.
     * @param data - The payload of the event.
     * @param timeout - Timeout for waiting on an ACK from the receiver.
     *
     * @returns An array of settled promises from all the handlers that were listening on the receiver.
     */
    async _send(eventType, data, timeout = 50 /* _TimeoutDuration.ACK */) {
        const messageChannel = typeof MessageChannel !== 'undefined' ? new MessageChannel() : null;
        if (!messageChannel) {
            throw new Error("connection_unavailable" /* _MessageError.CONNECTION_UNAVAILABLE */);
        }
        // Node timers and browser timers return fundamentally different types.
        // We don't actually care what the value is but TS won't accept unknown and
        // we can't cast properly in both environments.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let completionTimer;
        let handler;
        return new Promise((resolve, reject) => {
            const eventId = _generateEventId('', 20);
            messageChannel.port1.start();
            const ackTimer = setTimeout(() => {
                reject(new Error("unsupported_event" /* _MessageError.UNSUPPORTED_EVENT */));
            }, timeout);
            handler = {
                messageChannel,
                onMessage(event) {
                    const messageEvent = event;
                    if (messageEvent.data.eventId !== eventId) {
                        return;
                    }
                    switch (messageEvent.data.status) {
                        case "ack" /* _Status.ACK */:
                            // The receiver should ACK first.
                            clearTimeout(ackTimer);
                            completionTimer = setTimeout(() => {
                                reject(new Error("timeout" /* _MessageError.TIMEOUT */));
                            }, 3000 /* _TimeoutDuration.COMPLETION */);
                            break;
                        case "done" /* _Status.DONE */:
                            // Once the receiver's handlers are finished we will get the results.
                            clearTimeout(completionTimer);
                            resolve(messageEvent.data.response);
                            break;
                        default:
                            clearTimeout(ackTimer);
                            clearTimeout(completionTimer);
                            reject(new Error("invalid_response" /* _MessageError.INVALID_RESPONSE */));
                            break;
                    }
                }
            };
            this.handlers.add(handler);
            messageChannel.port1.addEventListener('message', handler.onMessage);
            this.target.postMessage({
                eventType,
                eventId,
                data
            }, [messageChannel.port2]);
        }).finally(() => {
            if (handler) {
                this.removeMessageHandler(handler);
            }
        });
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Lazy accessor for window, since the compat layer won't tree shake this out,
 * we need to make sure not to mess with window unless we have to
 */
function _window() {
    return window;
}
function _setWindowLocation(url) {
    _window().location.href = url;
}

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _isWorker() {
    return (typeof _window()['WorkerGlobalScope'] !== 'undefined' &&
        typeof _window()['importScripts'] === 'function');
}
async function _getActiveServiceWorker() {
    if (!(navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker)) {
        return null;
    }
    try {
        const registration = await navigator.serviceWorker.ready;
        return registration.active;
    }
    catch (_a) {
        return null;
    }
}
function _getServiceWorkerController() {
    var _a;
    return ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker) === null || _a === void 0 ? void 0 : _a.controller) || null;
}
function _getWorkerGlobalScope() {
    return _isWorker() ? self : null;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const index_e3d5d3f4_DB_NAME = 'firebaseLocalStorageDb';
const index_e3d5d3f4_DB_VERSION = 1;
const DB_OBJECTSTORE_NAME = 'firebaseLocalStorage';
const DB_DATA_KEYPATH = 'fbase_key';
/**
 * Promise wrapper for IDBRequest
 *
 * Unfortunately we can't cleanly extend Promise<T> since promises are not callable in ES6
 *
 */
class DBPromise {
    constructor(request) {
        this.request = request;
    }
    toPromise() {
        return new Promise((resolve, reject) => {
            this.request.addEventListener('success', () => {
                resolve(this.request.result);
            });
            this.request.addEventListener('error', () => {
                reject(this.request.error);
            });
        });
    }
}
function getObjectStore(db, isReadWrite) {
    return db
        .transaction([DB_OBJECTSTORE_NAME], isReadWrite ? 'readwrite' : 'readonly')
        .objectStore(DB_OBJECTSTORE_NAME);
}
function _deleteDatabase() {
    const request = indexedDB.deleteDatabase(index_e3d5d3f4_DB_NAME);
    return new DBPromise(request).toPromise();
}
function _openDatabase() {
    const request = indexedDB.open(index_e3d5d3f4_DB_NAME, index_e3d5d3f4_DB_VERSION);
    return new Promise((resolve, reject) => {
        request.addEventListener('error', () => {
            reject(request.error);
        });
        request.addEventListener('upgradeneeded', () => {
            const db = request.result;
            try {
                db.createObjectStore(DB_OBJECTSTORE_NAME, { keyPath: DB_DATA_KEYPATH });
            }
            catch (e) {
                reject(e);
            }
        });
        request.addEventListener('success', async () => {
            const db = request.result;
            // Strange bug that occurs in Firefox when multiple tabs are opened at the
            // same time. The only way to recover seems to be deleting the database
            // and re-initializing it.
            // https://github.com/firebase/firebase-js-sdk/issues/634
            if (!db.objectStoreNames.contains(DB_OBJECTSTORE_NAME)) {
                // Need to close the database or else you get a `blocked` event
                db.close();
                await _deleteDatabase();
                resolve(await _openDatabase());
            }
            else {
                resolve(db);
            }
        });
    });
}
async function _putObject(db, key, value) {
    const request = getObjectStore(db, true).put({
        [DB_DATA_KEYPATH]: key,
        value
    });
    return new DBPromise(request).toPromise();
}
async function getObject(db, key) {
    const request = getObjectStore(db, false).get(key);
    const data = await new DBPromise(request).toPromise();
    return data === undefined ? null : data.value;
}
function _deleteObject(db, key) {
    const request = getObjectStore(db, true).delete(key);
    return new DBPromise(request).toPromise();
}
const _POLLING_INTERVAL_MS = 800;
const _TRANSACTION_RETRY_COUNT = 3;
class IndexedDBLocalPersistence {
    constructor() {
        this.type = "LOCAL" /* PersistenceType.LOCAL */;
        this._shouldAllowMigration = true;
        this.listeners = {};
        this.localCache = {};
        // setTimeout return value is platform specific
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.pollTimer = null;
        this.pendingWrites = 0;
        this.receiver = null;
        this.sender = null;
        this.serviceWorkerReceiverAvailable = false;
        this.activeServiceWorker = null;
        // Fire & forget the service worker registration as it may never resolve
        this._workerInitializationPromise =
            this.initializeServiceWorkerMessaging().then(() => { }, () => { });
    }
    async _openDb() {
        if (this.db) {
            return this.db;
        }
        this.db = await _openDatabase();
        return this.db;
    }
    async _withRetries(op) {
        let numAttempts = 0;
        while (true) {
            try {
                const db = await this._openDb();
                return await op(db);
            }
            catch (e) {
                if (numAttempts++ > _TRANSACTION_RETRY_COUNT) {
                    throw e;
                }
                if (this.db) {
                    this.db.close();
                    this.db = undefined;
                }
                // TODO: consider adding exponential backoff
            }
        }
    }
    /**
     * IndexedDB events do not propagate from the main window to the worker context.  We rely on a
     * postMessage interface to send these events to the worker ourselves.
     */
    async initializeServiceWorkerMessaging() {
        return _isWorker() ? this.initializeReceiver() : this.initializeSender();
    }
    /**
     * As the worker we should listen to events from the main window.
     */
    async initializeReceiver() {
        this.receiver = Receiver._getInstance(_getWorkerGlobalScope());
        // Refresh from persistence if we receive a KeyChanged message.
        this.receiver._subscribe("keyChanged" /* _EventType.KEY_CHANGED */, async (_origin, data) => {
            const keys = await this._poll();
            return {
                keyProcessed: keys.includes(data.key)
            };
        });
        // Let the sender know that we are listening so they give us more timeout.
        this.receiver._subscribe("ping" /* _EventType.PING */, async (_origin, _data) => {
            return ["keyChanged" /* _EventType.KEY_CHANGED */];
        });
    }
    /**
     * As the main window, we should let the worker know when keys change (set and remove).
     *
     * @remarks
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/ready | ServiceWorkerContainer.ready}
     * may not resolve.
     */
    async initializeSender() {
        var _a, _b;
        // Check to see if there's an active service worker.
        this.activeServiceWorker = await _getActiveServiceWorker();
        if (!this.activeServiceWorker) {
            return;
        }
        this.sender = new Sender(this.activeServiceWorker);
        // Ping the service worker to check what events they can handle.
        const results = await this.sender._send("ping" /* _EventType.PING */, {}, 800 /* _TimeoutDuration.LONG_ACK */);
        if (!results) {
            return;
        }
        if (((_a = results[0]) === null || _a === void 0 ? void 0 : _a.fulfilled) &&
            ((_b = results[0]) === null || _b === void 0 ? void 0 : _b.value.includes("keyChanged" /* _EventType.KEY_CHANGED */))) {
            this.serviceWorkerReceiverAvailable = true;
        }
    }
    /**
     * Let the worker know about a changed key, the exact key doesn't technically matter since the
     * worker will just trigger a full sync anyway.
     *
     * @remarks
     * For now, we only support one service worker per page.
     *
     * @param key - Storage key which changed.
     */
    async notifyServiceWorker(key) {
        if (!this.sender ||
            !this.activeServiceWorker ||
            _getServiceWorkerController() !== this.activeServiceWorker) {
            return;
        }
        try {
            await this.sender._send("keyChanged" /* _EventType.KEY_CHANGED */, { key }, 
            // Use long timeout if receiver has previously responded to a ping from us.
            this.serviceWorkerReceiverAvailable
                ? 800 /* _TimeoutDuration.LONG_ACK */
                : 50 /* _TimeoutDuration.ACK */);
        }
        catch (_a) {
            // This is a best effort approach. Ignore errors.
        }
    }
    async _isAvailable() {
        try {
            if (!indexedDB) {
                return false;
            }
            const db = await _openDatabase();
            await _putObject(db, STORAGE_AVAILABLE_KEY, '1');
            await _deleteObject(db, STORAGE_AVAILABLE_KEY);
            return true;
        }
        catch (_a) { }
        return false;
    }
    async _withPendingWrite(write) {
        this.pendingWrites++;
        try {
            await write();
        }
        finally {
            this.pendingWrites--;
        }
    }
    async _set(key, value) {
        return this._withPendingWrite(async () => {
            await this._withRetries((db) => _putObject(db, key, value));
            this.localCache[key] = value;
            return this.notifyServiceWorker(key);
        });
    }
    async _get(key) {
        const obj = (await this._withRetries((db) => getObject(db, key)));
        this.localCache[key] = obj;
        return obj;
    }
    async _remove(key) {
        return this._withPendingWrite(async () => {
            await this._withRetries((db) => _deleteObject(db, key));
            delete this.localCache[key];
            return this.notifyServiceWorker(key);
        });
    }
    async _poll() {
        // TODO: check if we need to fallback if getAll is not supported
        const result = await this._withRetries((db) => {
            const getAllRequest = getObjectStore(db, false).getAll();
            return new DBPromise(getAllRequest).toPromise();
        });
        if (!result) {
            return [];
        }
        // If we have pending writes in progress abort, we'll get picked up on the next poll
        if (this.pendingWrites !== 0) {
            return [];
        }
        const keys = [];
        const keysInResult = new Set();
        for (const { fbase_key: key, value } of result) {
            keysInResult.add(key);
            if (JSON.stringify(this.localCache[key]) !== JSON.stringify(value)) {
                this.notifyListeners(key, value);
                keys.push(key);
            }
        }
        for (const localKey of Object.keys(this.localCache)) {
            if (this.localCache[localKey] && !keysInResult.has(localKey)) {
                // Deleted
                this.notifyListeners(localKey, null);
                keys.push(localKey);
            }
        }
        return keys;
    }
    notifyListeners(key, newValue) {
        this.localCache[key] = newValue;
        const listeners = this.listeners[key];
        if (listeners) {
            for (const listener of Array.from(listeners)) {
                listener(newValue);
            }
        }
    }
    startPolling() {
        this.stopPolling();
        this.pollTimer = setInterval(async () => this._poll(), _POLLING_INTERVAL_MS);
    }
    stopPolling() {
        if (this.pollTimer) {
            clearInterval(this.pollTimer);
            this.pollTimer = null;
        }
    }
    _addListener(key, listener) {
        if (Object.keys(this.listeners).length === 0) {
            this.startPolling();
        }
        if (!this.listeners[key]) {
            this.listeners[key] = new Set();
            // Populate the cache to avoid spuriously triggering on first poll.
            void this._get(key); // This can happen in the background async and we can return immediately.
        }
        this.listeners[key].add(listener);
    }
    _removeListener(key, listener) {
        if (this.listeners[key]) {
            this.listeners[key].delete(listener);
            if (this.listeners[key].size === 0) {
                delete this.listeners[key];
            }
        }
        if (Object.keys(this.listeners).length === 0) {
            this.stopPolling();
        }
    }
}
IndexedDBLocalPersistence.type = 'LOCAL';
/**
 * An implementation of {@link Persistence} of type `LOCAL` using `indexedDB`
 * for the underlying storage.
 *
 * @public
 */
const indexedDBLocalPersistence = IndexedDBLocalPersistence;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function startSignInPhoneMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaSignIn:start" /* Endpoint.START_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));
}
function finalizeSignInPhoneMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaSignIn:finalize" /* Endpoint.FINALIZE_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));
}
function finalizeSignInTotpMfa(auth, request) {
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaSignIn:finalize" /* Endpoint.FINALIZE_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _SOLVE_TIME_MS = 500;
const _EXPIRATION_TIME_MS = 60000;
const _WIDGET_ID_START = 1000000000000;
class MockReCaptcha {
    constructor(auth) {
        this.auth = auth;
        this.counter = _WIDGET_ID_START;
        this._widgets = new Map();
    }
    render(container, parameters) {
        const id = this.counter;
        this._widgets.set(id, new MockWidget(container, this.auth.name, parameters || {}));
        this.counter++;
        return id;
    }
    reset(optWidgetId) {
        var _a;
        const id = optWidgetId || _WIDGET_ID_START;
        void ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a.delete());
        this._widgets.delete(id);
    }
    getResponse(optWidgetId) {
        var _a;
        const id = optWidgetId || _WIDGET_ID_START;
        return ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a.getResponse()) || '';
    }
    async execute(optWidgetId) {
        var _a;
        const id = optWidgetId || _WIDGET_ID_START;
        void ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a.execute());
        return '';
    }
}
class MockWidget {
    constructor(containerOrId, appName, params) {
        this.params = params;
        this.timerId = null;
        this.deleted = false;
        this.responseToken = null;
        this.clickHandler = () => {
            this.execute();
        };
        const container = typeof containerOrId === 'string'
            ? document.getElementById(containerOrId)
            : containerOrId;
        _assert(container, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */, { appName });
        this.container = container;
        this.isVisible = this.params.size !== 'invisible';
        if (this.isVisible) {
            this.execute();
        }
        else {
            this.container.addEventListener('click', this.clickHandler);
        }
    }
    getResponse() {
        this.checkIfDeleted();
        return this.responseToken;
    }
    delete() {
        this.checkIfDeleted();
        this.deleted = true;
        if (this.timerId) {
            clearTimeout(this.timerId);
            this.timerId = null;
        }
        this.container.removeEventListener('click', this.clickHandler);
    }
    execute() {
        this.checkIfDeleted();
        if (this.timerId) {
            return;
        }
        this.timerId = window.setTimeout(() => {
            this.responseToken = generateRandomAlphaNumericString(50);
            const { callback, 'expired-callback': expiredCallback } = this.params;
            if (callback) {
                try {
                    callback(this.responseToken);
                }
                catch (e) { }
            }
            this.timerId = window.setTimeout(() => {
                this.timerId = null;
                this.responseToken = null;
                if (expiredCallback) {
                    try {
                        expiredCallback();
                    }
                    catch (e) { }
                }
                if (this.isVisible) {
                    this.execute();
                }
            }, _EXPIRATION_TIME_MS);
        }, _SOLVE_TIME_MS);
    }
    checkIfDeleted() {
        if (this.deleted) {
            throw new Error('reCAPTCHA mock was already deleted!');
        }
    }
}
function generateRandomAlphaNumericString(len) {
    const chars = [];
    const allowedChars = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    for (let i = 0; i < len; i++) {
        chars.push(allowedChars.charAt(Math.floor(Math.random() * allowedChars.length)));
    }
    return chars.join('');
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ReCaptcha will load using the same callback, so the callback function needs
// to be kept around
const _JSLOAD_CALLBACK = _generateCallbackName('rcb');
const NETWORK_TIMEOUT_DELAY = new Delay(30000, 60000);
const RECAPTCHA_BASE = 'https://www.google.com/recaptcha/api.js?';
/**
 * Loader for the GReCaptcha library. There should only ever be one of this.
 */
class ReCaptchaLoaderImpl {
    constructor() {
        var _a;
        this.hostLanguage = '';
        this.counter = 0;
        /**
         * Check for `render()` method. `window.grecaptcha` will exist if the Enterprise
         * version of the ReCAPTCHA script was loaded by someone else (e.g. App Check) but
         * `window.grecaptcha.render()` will not. Another load will add it.
         */
        this.librarySeparatelyLoaded = !!((_a = _window().grecaptcha) === null || _a === void 0 ? void 0 : _a.render);
    }
    load(auth, hl = '') {
        _assert(isHostLanguageValid(hl), auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        if (this.shouldResolveImmediately(hl) && isV2(_window().grecaptcha)) {
            return Promise.resolve(_window().grecaptcha);
        }
        return new Promise((resolve, reject) => {
            const networkTimeout = _window().setTimeout(() => {
                reject(_createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));
            }, NETWORK_TIMEOUT_DELAY.get());
            _window()[_JSLOAD_CALLBACK] = () => {
                _window().clearTimeout(networkTimeout);
                delete _window()[_JSLOAD_CALLBACK];
                const recaptcha = _window().grecaptcha;
                if (!recaptcha || !isV2(recaptcha)) {
                    reject(_createError(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */));
                    return;
                }
                // Wrap the greptcha render function so that we know if the developer has
                // called it separately
                const render = recaptcha.render;
                recaptcha.render = (container, params) => {
                    const widgetId = render(container, params);
                    this.counter++;
                    return widgetId;
                };
                this.hostLanguage = hl;
                resolve(recaptcha);
            };
            const url = `${RECAPTCHA_BASE}?${querystring({
                onload: _JSLOAD_CALLBACK,
                render: 'explicit',
                hl
            })}`;
            _loadJS(url).catch(() => {
                clearTimeout(networkTimeout);
                reject(_createError(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */));
            });
        });
    }
    clearedOneInstance() {
        this.counter--;
    }
    shouldResolveImmediately(hl) {
        var _a;
        // We can resolve immediately if:
        //   • grecaptcha is already defined AND (
        //     1. the requested language codes are the same OR
        //     2. there exists already a ReCaptcha on the page
        //     3. the library was already loaded by the app
        // In cases (2) and (3), we _can't_ reload as it would break the recaptchas
        // that are already in the page
        return (!!((_a = _window().grecaptcha) === null || _a === void 0 ? void 0 : _a.render) &&
            (hl === this.hostLanguage ||
                this.counter > 0 ||
                this.librarySeparatelyLoaded));
    }
}
function isHostLanguageValid(hl) {
    return hl.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(hl);
}
class MockReCaptchaLoaderImpl {
    async load(auth) {
        return new MockReCaptcha(auth);
    }
    clearedOneInstance() { }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RECAPTCHA_VERIFIER_TYPE = 'recaptcha';
const DEFAULT_PARAMS = {
    theme: 'light',
    type: 'image'
};
/**
 * An {@link https://www.google.com/recaptcha/ | reCAPTCHA}-based application verifier.
 *
 * @public
 */
class RecaptchaVerifier {
    /**
     *
     * @param containerOrId - The reCAPTCHA container parameter.
     *
     * @remarks
     * This has different meaning depending on whether the reCAPTCHA is hidden or visible. For a
     * visible reCAPTCHA the container must be empty. If a string is used, it has to correspond to
     * an element ID. The corresponding element must also must be in the DOM at the time of
     * initialization.
     *
     * @param parameters - The optional reCAPTCHA parameters.
     *
     * @remarks
     * Check the reCAPTCHA docs for a comprehensive list. All parameters are accepted except for
     * the sitekey. Firebase Auth backend provisions a reCAPTCHA for each project and will
     * configure this upon rendering. For an invisible reCAPTCHA, a size key must have the value
     * 'invisible'.
     *
     * @param authExtern - The corresponding Firebase {@link Auth} instance.
     */
    constructor(containerOrId, parameters = Object.assign({}, DEFAULT_PARAMS), authExtern) {
        this.parameters = parameters;
        /**
         * The application verifier type.
         *
         * @remarks
         * For a reCAPTCHA verifier, this is 'recaptcha'.
         */
        this.type = RECAPTCHA_VERIFIER_TYPE;
        this.destroyed = false;
        this.widgetId = null;
        this.tokenChangeListeners = new Set();
        this.renderPromise = null;
        this.recaptcha = null;
        this.auth = _castAuth(authExtern);
        this.isInvisible = this.parameters.size === 'invisible';
        _assert(typeof document !== 'undefined', this.auth, "operation-not-supported-in-this-environment" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);
        const container = typeof containerOrId === 'string'
            ? document.getElementById(containerOrId)
            : containerOrId;
        _assert(container, this.auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        this.container = container;
        this.parameters.callback = this.makeTokenCallback(this.parameters.callback);
        this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting
            ? new MockReCaptchaLoaderImpl()
            : new ReCaptchaLoaderImpl();
        this.validateStartingState();
        // TODO: Figure out if sdk version is needed
    }
    /**
     * Waits for the user to solve the reCAPTCHA and resolves with the reCAPTCHA token.
     *
     * @returns A Promise for the reCAPTCHA token.
     */
    async verify() {
        this.assertNotDestroyed();
        const id = await this.render();
        const recaptcha = this.getAssertedRecaptcha();
        const response = recaptcha.getResponse(id);
        if (response) {
            return response;
        }
        return new Promise(resolve => {
            const tokenChange = (token) => {
                if (!token) {
                    return; // Ignore token expirations.
                }
                this.tokenChangeListeners.delete(tokenChange);
                resolve(token);
            };
            this.tokenChangeListeners.add(tokenChange);
            if (this.isInvisible) {
                recaptcha.execute(id);
            }
        });
    }
    /**
     * Renders the reCAPTCHA widget on the page.
     *
     * @returns A Promise that resolves with the reCAPTCHA widget ID.
     */
    render() {
        try {
            this.assertNotDestroyed();
        }
        catch (e) {
            // This method returns a promise. Since it's not async (we want to return the
            // _same_ promise if rendering is still occurring), the API surface should
            // reject with the error rather than just throw
            return Promise.reject(e);
        }
        if (this.renderPromise) {
            return this.renderPromise;
        }
        this.renderPromise = this.makeRenderPromise().catch(e => {
            this.renderPromise = null;
            throw e;
        });
        return this.renderPromise;
    }
    /** @internal */
    _reset() {
        this.assertNotDestroyed();
        if (this.widgetId !== null) {
            this.getAssertedRecaptcha().reset(this.widgetId);
        }
    }
    /**
     * Clears the reCAPTCHA widget from the page and destroys the instance.
     */
    clear() {
        this.assertNotDestroyed();
        this.destroyed = true;
        this._recaptchaLoader.clearedOneInstance();
        if (!this.isInvisible) {
            this.container.childNodes.forEach(node => {
                this.container.removeChild(node);
            });
        }
    }
    validateStartingState() {
        _assert(!this.parameters.sitekey, this.auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        _assert(this.isInvisible || !this.container.hasChildNodes(), this.auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        _assert(typeof document !== 'undefined', this.auth, "operation-not-supported-in-this-environment" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);
    }
    makeTokenCallback(existing) {
        return token => {
            this.tokenChangeListeners.forEach(listener => listener(token));
            if (typeof existing === 'function') {
                existing(token);
            }
            else if (typeof existing === 'string') {
                const globalFunc = _window()[existing];
                if (typeof globalFunc === 'function') {
                    globalFunc(token);
                }
            }
        };
    }
    assertNotDestroyed() {
        _assert(!this.destroyed, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    }
    async makeRenderPromise() {
        await this.init();
        if (!this.widgetId) {
            let container = this.container;
            if (!this.isInvisible) {
                const guaranteedEmpty = document.createElement('div');
                container.appendChild(guaranteedEmpty);
                container = guaranteedEmpty;
            }
            this.widgetId = this.getAssertedRecaptcha().render(container, this.parameters);
        }
        return this.widgetId;
    }
    async init() {
        _assert(_isHttpOrHttps() && !_isWorker(), this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        await domReady();
        this.recaptcha = await this._recaptchaLoader.load(this.auth, this.auth.languageCode || undefined);
        const siteKey = await getRecaptchaParams(this.auth);
        _assert(siteKey, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        this.parameters.sitekey = siteKey;
    }
    getAssertedRecaptcha() {
        _assert(this.recaptcha, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        return this.recaptcha;
    }
}
function domReady() {
    let resolver = null;
    return new Promise(resolve => {
        if (document.readyState === 'complete') {
            resolve();
            return;
        }
        // Document not ready, wait for load before resolving.
        // Save resolver, so we can remove listener in case it was externally
        // cancelled.
        resolver = () => resolve();
        window.addEventListener('load', resolver);
    }).catch(e => {
        if (resolver) {
            window.removeEventListener('load', resolver);
        }
        throw e;
    });
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ConfirmationResultImpl {
    constructor(verificationId, onConfirmation) {
        this.verificationId = verificationId;
        this.onConfirmation = onConfirmation;
    }
    confirm(verificationCode) {
        const authCredential = PhoneAuthCredential._fromVerification(this.verificationId, verificationCode);
        return this.onConfirmation(authCredential);
    }
}
/**
 * Asynchronously signs in using a phone number.
 *
 * @remarks
 * This method sends a code via SMS to the given
 * phone number, and returns a {@link ConfirmationResult}. After the user
 * provides the code sent to their phone, call {@link ConfirmationResult.confirm}
 * with the code to sign the user in.
 *
 * For abuse prevention, this method also requires a {@link ApplicationVerifier}.
 * This SDK includes a reCAPTCHA-based implementation, {@link RecaptchaVerifier}.
 * This function can work on other platforms that do not support the
 * {@link RecaptchaVerifier} (like React Native), but you need to use a
 * third-party {@link ApplicationVerifier} implementation.
 *
 * @example
 * ```javascript
 * // 'recaptcha-container' is the ID of an element in the DOM.
 * const applicationVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container');
 * const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
 * // Obtain a verificationCode from the user.
 * const credential = await confirmationResult.confirm(verificationCode);
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
 * @param appVerifier - The {@link ApplicationVerifier}.
 *
 * @public
 */
async function signInWithPhoneNumber(auth, phoneNumber, appVerifier) {
    const authInternal = _castAuth(auth);
    const verificationId = await _verifyPhoneNumber(authInternal, phoneNumber, getModularInstance(appVerifier));
    return new ConfirmationResultImpl(verificationId, cred => signInWithCredential(authInternal, cred));
}
/**
 * Links the user account with the given phone number.
 *
 * @param user - The user.
 * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
 * @param appVerifier - The {@link ApplicationVerifier}.
 *
 * @public
 */
async function linkWithPhoneNumber(user, phoneNumber, appVerifier) {
    const userInternal = getModularInstance(user);
    await _assertLinkedStatus(false, userInternal, "phone" /* ProviderId.PHONE */);
    const verificationId = await _verifyPhoneNumber(userInternal.auth, phoneNumber, getModularInstance(appVerifier));
    return new ConfirmationResultImpl(verificationId, cred => linkWithCredential(userInternal, cred));
}
/**
 * Re-authenticates a user using a fresh phone credential.
 *
 * @remarks Use before operations such as {@link updatePassword} that require tokens from recent sign-in attempts.
 *
 * @param user - The user.
 * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
 * @param appVerifier - The {@link ApplicationVerifier}.
 *
 * @public
 */
async function reauthenticateWithPhoneNumber(user, phoneNumber, appVerifier) {
    const userInternal = getModularInstance(user);
    const verificationId = await _verifyPhoneNumber(userInternal.auth, phoneNumber, getModularInstance(appVerifier));
    return new ConfirmationResultImpl(verificationId, cred => reauthenticateWithCredential(userInternal, cred));
}
/**
 * Returns a verification ID to be used in conjunction with the SMS code that is sent.
 *
 */
async function _verifyPhoneNumber(auth, options, verifier) {
    var _a;
    const recaptchaToken = await verifier.verify();
    try {
        _assert(typeof recaptchaToken === 'string', auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        _assert(verifier.type === RECAPTCHA_VERIFIER_TYPE, auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        let phoneInfoOptions;
        if (typeof options === 'string') {
            phoneInfoOptions = {
                phoneNumber: options
            };
        }
        else {
            phoneInfoOptions = options;
        }
        if ('session' in phoneInfoOptions) {
            const session = phoneInfoOptions.session;
            if ('phoneNumber' in phoneInfoOptions) {
                _assert(session.type === "enroll" /* MultiFactorSessionType.ENROLL */, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                const response = await startEnrollPhoneMfa(auth, {
                    idToken: session.credential,
                    phoneEnrollmentInfo: {
                        phoneNumber: phoneInfoOptions.phoneNumber,
                        recaptchaToken
                    }
                });
                return response.phoneSessionInfo.sessionInfo;
            }
            else {
                _assert(session.type === "signin" /* MultiFactorSessionType.SIGN_IN */, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                const mfaEnrollmentId = ((_a = phoneInfoOptions.multiFactorHint) === null || _a === void 0 ? void 0 : _a.uid) ||
                    phoneInfoOptions.multiFactorUid;
                _assert(mfaEnrollmentId, auth, "missing-multi-factor-info" /* AuthErrorCode.MISSING_MFA_INFO */);
                const response = await startSignInPhoneMfa(auth, {
                    mfaPendingCredential: session.credential,
                    mfaEnrollmentId,
                    phoneSignInInfo: {
                        recaptchaToken
                    }
                });
                return response.phoneResponseInfo.sessionInfo;
            }
        }
        else {
            const { sessionInfo } = await sendPhoneVerificationCode(auth, {
                phoneNumber: phoneInfoOptions.phoneNumber,
                recaptchaToken
            });
            return sessionInfo;
        }
    }
    finally {
        verifier._reset();
    }
}
/**
 * Updates the user's phone number.
 *
 * @example
 * ```
 * // 'recaptcha-container' is the ID of an element in the DOM.
 * const applicationVerifier = new RecaptchaVerifier('recaptcha-container');
 * const provider = new PhoneAuthProvider(auth);
 * const verificationId = await provider.verifyPhoneNumber('+16505550101', applicationVerifier);
 * // Obtain the verificationCode from the user.
 * const phoneCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
 * await updatePhoneNumber(user, phoneCredential);
 * ```
 *
 * @param user - The user.
 * @param credential - A credential authenticating the new phone number.
 *
 * @public
 */
async function updatePhoneNumber(user, credential) {
    await _link$1(getModularInstance(user), credential);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating an {@link PhoneAuthCredential}.
 *
 * @example
 * ```javascript
 * // 'recaptcha-container' is the ID of an element in the DOM.
 * const applicationVerifier = new RecaptchaVerifier('recaptcha-container');
 * const provider = new PhoneAuthProvider(auth);
 * const verificationId = await provider.verifyPhoneNumber('+16505550101', applicationVerifier);
 * // Obtain the verificationCode from the user.
 * const phoneCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
 * const userCredential = await signInWithCredential(auth, phoneCredential);
 * ```
 *
 * @public
 */
class PhoneAuthProvider {
    /**
     * @param auth - The Firebase {@link Auth} instance in which sign-ins should occur.
     *
     */
    constructor(auth) {
        /** Always set to {@link ProviderId}.PHONE. */
        this.providerId = PhoneAuthProvider.PROVIDER_ID;
        this.auth = _castAuth(auth);
    }
    /**
     *
     * Starts a phone number authentication flow by sending a verification code to the given phone
     * number.
     *
     * @example
     * ```javascript
     * const provider = new PhoneAuthProvider(auth);
     * const verificationId = await provider.verifyPhoneNumber(phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const authCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
     * const userCredential = await signInWithCredential(auth, authCredential);
     * ```
     *
     * @example
     * An alternative flow is provided using the `signInWithPhoneNumber` method.
     * ```javascript
     * const confirmationResult = signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const userCredential = confirmationResult.confirm(verificationCode);
     * ```
     *
     * @param phoneInfoOptions - The user's {@link PhoneInfoOptions}. The phone number should be in
     * E.164 format (e.g. +16505550101).
     * @param applicationVerifier - For abuse prevention, this method also requires a
     * {@link ApplicationVerifier}. This SDK includes a reCAPTCHA-based implementation,
     * {@link RecaptchaVerifier}.
     *
     * @returns A Promise for a verification ID that can be passed to
     * {@link PhoneAuthProvider.credential} to identify this flow..
     */
    verifyPhoneNumber(phoneOptions, applicationVerifier) {
        return _verifyPhoneNumber(this.auth, phoneOptions, index_esm2017_getModularInstance(applicationVerifier));
    }
    /**
     * Creates a phone auth credential, given the verification ID from
     * {@link PhoneAuthProvider.verifyPhoneNumber} and the code that was sent to the user's
     * mobile device.
     *
     * @example
     * ```javascript
     * const provider = new PhoneAuthProvider(auth);
     * const verificationId = provider.verifyPhoneNumber(phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const authCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
     * const userCredential = signInWithCredential(auth, authCredential);
     * ```
     *
     * @example
     * An alternative flow is provided using the `signInWithPhoneNumber` method.
     * ```javascript
     * const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const userCredential = await confirmationResult.confirm(verificationCode);
     * ```
     *
     * @param verificationId - The verification ID returned from {@link PhoneAuthProvider.verifyPhoneNumber}.
     * @param verificationCode - The verification code sent to the user's mobile device.
     *
     * @returns The auth provider credential.
     */
    static credential(verificationId, verificationCode) {
        return PhoneAuthCredential._fromVerification(verificationId, verificationCode);
    }
    /**
     * Generates an {@link AuthCredential} from a {@link UserCredential}.
     * @param userCredential - The user credential.
     */
    static credentialFromResult(userCredential) {
        const credential = userCredential;
        return PhoneAuthProvider.credentialFromTaggedObject(credential);
    }
    /**
     * Returns an {@link AuthCredential} when passed an error.
     *
     * @remarks
     *
     * This method works for errors like
     * `auth/account-exists-with-different-credentials`. This is useful for
     * recovering when attempting to set a user's phone number but the number
     * in question is already tied to another account. For example, the following
     * code tries to update the current user's phone number, and if that
     * fails, links the user with the account associated with that number:
     *
     * ```js
     * const provider = new PhoneAuthProvider(auth);
     * const verificationId = await provider.verifyPhoneNumber(number, verifier);
     * try {
     *   const code = ''; // Prompt the user for the verification code
     *   await updatePhoneNumber(
     *       auth.currentUser,
     *       PhoneAuthProvider.credential(verificationId, code));
     * } catch (e) {
     *   if ((e as FirebaseError)?.code === 'auth/account-exists-with-different-credential') {
     *     const cred = PhoneAuthProvider.credentialFromError(e);
     *     await linkWithCredential(auth.currentUser, cred);
     *   }
     * }
     *
     * // At this point, auth.currentUser.phoneNumber === number.
     * ```
     *
     * @param error - The error to generate a credential from.
     */
    static credentialFromError(error) {
        return PhoneAuthProvider.credentialFromTaggedObject((error.customData || {}));
    }
    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
        if (!tokenResponse) {
            return null;
        }
        const { phoneNumber, temporaryProof } = tokenResponse;
        if (phoneNumber && temporaryProof) {
            return PhoneAuthCredential._fromTokenResponse(phoneNumber, temporaryProof);
        }
        return null;
    }
}
/** Always set to {@link ProviderId}.PHONE. */
PhoneAuthProvider.PROVIDER_ID = "phone" /* ProviderId.PHONE */;
/** Always set to {@link SignInMethod}.PHONE. */
PhoneAuthProvider.PHONE_SIGN_IN_METHOD = "phone" /* SignInMethod.PHONE */;

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Chooses a popup/redirect resolver to use. This prefers the override (which
 * is directly passed in), and falls back to the property set on the auth
 * object. If neither are available, this function errors w/ an argument error.
 */
function _withDefaultResolver(auth, resolverOverride) {
    if (resolverOverride) {
        return _getInstance(resolverOverride);
    }
    _assert(auth._popupRedirectResolver, auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
    return auth._popupRedirectResolver;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IdpCredential extends AuthCredential {
    constructor(params) {
        super("custom" /* ProviderId.CUSTOM */, "custom" /* ProviderId.CUSTOM */);
        this.params = params;
    }
    _getIdTokenResponse(auth) {
        return signInWithIdp(auth, this._buildIdpRequest());
    }
    _linkToIdToken(auth, idToken) {
        return signInWithIdp(auth, this._buildIdpRequest(idToken));
    }
    _getReauthenticationResolver(auth) {
        return signInWithIdp(auth, this._buildIdpRequest());
    }
    _buildIdpRequest(idToken) {
        const request = {
            requestUri: this.params.requestUri,
            sessionId: this.params.sessionId,
            postBody: this.params.postBody,
            tenantId: this.params.tenantId,
            pendingToken: this.params.pendingToken,
            returnSecureToken: true,
            returnIdpCredential: true
        };
        if (idToken) {
            request.idToken = idToken;
        }
        return request;
    }
}
function _signIn(params) {
    return _signInWithCredential(params.auth, new IdpCredential(params), params.bypassAuthState);
}
function _reauth(params) {
    const { auth, user } = params;
    _assert(user, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    return _reauthenticate(user, new IdpCredential(params), params.bypassAuthState);
}
async function _link(params) {
    const { auth, user } = params;
    _assert(user, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    return _link$1(user, new IdpCredential(params), params.bypassAuthState);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Popup event manager. Handles the popup's entire lifecycle; listens to auth
 * events
 */
class AbstractPopupRedirectOperation {
    constructor(auth, filter, resolver, user, bypassAuthState = false) {
        this.auth = auth;
        this.resolver = resolver;
        this.user = user;
        this.bypassAuthState = bypassAuthState;
        this.pendingPromise = null;
        this.eventManager = null;
        this.filter = Array.isArray(filter) ? filter : [filter];
    }
    execute() {
        return new Promise(async (resolve, reject) => {
            this.pendingPromise = { resolve, reject };
            try {
                this.eventManager = await this.resolver._initialize(this.auth);
                await this.onExecution();
                this.eventManager.registerConsumer(this);
            }
            catch (e) {
                this.reject(e);
            }
        });
    }
    async onAuthEvent(event) {
        const { urlResponse, sessionId, postBody, tenantId, error, type } = event;
        if (error) {
            this.reject(error);
            return;
        }
        const params = {
            auth: this.auth,
            requestUri: urlResponse,
            sessionId: sessionId,
            tenantId: tenantId || undefined,
            postBody: postBody || undefined,
            user: this.user,
            bypassAuthState: this.bypassAuthState
        };
        try {
            this.resolve(await this.getIdpTask(type)(params));
        }
        catch (e) {
            this.reject(e);
        }
    }
    onError(error) {
        this.reject(error);
    }
    getIdpTask(type) {
        switch (type) {
            case "signInViaPopup" /* AuthEventType.SIGN_IN_VIA_POPUP */:
            case "signInViaRedirect" /* AuthEventType.SIGN_IN_VIA_REDIRECT */:
                return _signIn;
            case "linkViaPopup" /* AuthEventType.LINK_VIA_POPUP */:
            case "linkViaRedirect" /* AuthEventType.LINK_VIA_REDIRECT */:
                return _link;
            case "reauthViaPopup" /* AuthEventType.REAUTH_VIA_POPUP */:
            case "reauthViaRedirect" /* AuthEventType.REAUTH_VIA_REDIRECT */:
                return _reauth;
            default:
                _fail(this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        }
    }
    resolve(cred) {
        debugAssert(this.pendingPromise, 'Pending promise was never set');
        this.pendingPromise.resolve(cred);
        this.unregisterAndCleanUp();
    }
    reject(error) {
        debugAssert(this.pendingPromise, 'Pending promise was never set');
        this.pendingPromise.reject(error);
        this.unregisterAndCleanUp();
    }
    unregisterAndCleanUp() {
        if (this.eventManager) {
            this.eventManager.unregisterConsumer(this);
        }
        this.pendingPromise = null;
        this.cleanUp();
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _POLL_WINDOW_CLOSE_TIMEOUT = new Delay(2000, 10000);
/**
 * Authenticates a Firebase client using a popup-based OAuth authentication flow.
 *
 * @remarks
 * If succeeds, returns the signed in user along with the provider's credential. If sign in was
 * unsuccessful, returns an error object containing additional information about the error.
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new FacebookAuthProvider();
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a Facebook Access Token.
 * const credential = provider.credentialFromResult(auth, result);
 * const token = credential.accessToken;
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 *
 * @public
 */
async function signInWithPopup(auth, provider, resolver) {
    const authInternal = _castAuth(auth);
    _assertInstanceOf(auth, provider, FederatedAuthProvider);
    const resolverInternal = _withDefaultResolver(authInternal, resolver);
    const action = new PopupOperation(authInternal, "signInViaPopup" /* AuthEventType.SIGN_IN_VIA_POPUP */, provider, resolverInternal);
    return action.executeNotNull();
}
/**
 * Reauthenticates the current user with the specified {@link OAuthProvider} using a pop-up based
 * OAuth flow.
 *
 * @remarks
 * If the reauthentication is successful, the returned result will contain the user and the
 * provider's credential.
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new FacebookAuthProvider();
 * const result = await signInWithPopup(auth, provider);
 * // Reauthenticate using a popup.
 * await reauthenticateWithPopup(result.user, provider);
 * ```
 *
 * @param user - The user.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 * @public
 */
async function reauthenticateWithPopup(user, provider, resolver) {
    const userInternal = getModularInstance(user);
    _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
    const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
    const action = new PopupOperation(userInternal.auth, "reauthViaPopup" /* AuthEventType.REAUTH_VIA_POPUP */, provider, resolverInternal, userInternal);
    return action.executeNotNull();
}
/**
 * Links the authenticated provider to the user account using a pop-up based OAuth flow.
 *
 * @remarks
 * If the linking is successful, the returned result will contain the user and the provider's credential.
 *
 *
 * @example
 * ```javascript
 * // Sign in using some other provider.
 * const result = await signInWithEmailAndPassword(auth, email, password);
 * // Link using a popup.
 * const provider = new FacebookAuthProvider();
 * await linkWithPopup(result.user, provider);
 * ```
 *
 * @param user - The user.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 * @public
 */
async function linkWithPopup(user, provider, resolver) {
    const userInternal = getModularInstance(user);
    _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
    const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
    const action = new PopupOperation(userInternal.auth, "linkViaPopup" /* AuthEventType.LINK_VIA_POPUP */, provider, resolverInternal, userInternal);
    return action.executeNotNull();
}
/**
 * Popup event manager. Handles the popup's entire lifecycle; listens to auth
 * events
 *
 */
class PopupOperation extends AbstractPopupRedirectOperation {
    constructor(auth, filter, provider, resolver, user) {
        super(auth, filter, resolver, user);
        this.provider = provider;
        this.authWindow = null;
        this.pollId = null;
        if (PopupOperation.currentPopupAction) {
            PopupOperation.currentPopupAction.cancel();
        }
        PopupOperation.currentPopupAction = this;
    }
    async executeNotNull() {
        const result = await this.execute();
        _assert(result, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        return result;
    }
    async onExecution() {
        debugAssert(this.filter.length === 1, 'Popup operations only handle one event');
        const eventId = _generateEventId();
        this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], // There's always one, see constructor
        eventId);
        this.authWindow.associatedEvent = eventId;
        // Check for web storage support and origin validation _after_ the popup is
        // loaded. These operations are slow (~1 second or so) Rather than
        // waiting on them before opening the window, optimistically open the popup
        // and check for storage support at the same time. If storage support is
        // not available, this will cause the whole thing to reject properly. It
        // will also close the popup, but since the promise has already rejected,
        // the popup closed by user poll will reject into the void.
        this.resolver._originValidation(this.auth).catch(e => {
            this.reject(e);
        });
        this.resolver._isIframeWebStorageSupported(this.auth, isSupported => {
            if (!isSupported) {
                this.reject(_createError(this.auth, "web-storage-unsupported" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */));
            }
        });
        // Handle user closure. Notice this does *not* use await
        this.pollUserCancellation();
    }
    get eventId() {
        var _a;
        return ((_a = this.authWindow) === null || _a === void 0 ? void 0 : _a.associatedEvent) || null;
    }
    cancel() {
        this.reject(_createError(this.auth, "cancelled-popup-request" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */));
    }
    cleanUp() {
        if (this.authWindow) {
            this.authWindow.close();
        }
        if (this.pollId) {
            window.clearTimeout(this.pollId);
        }
        this.authWindow = null;
        this.pollId = null;
        PopupOperation.currentPopupAction = null;
    }
    pollUserCancellation() {
        const poll = () => {
            var _a, _b;
            if ((_b = (_a = this.authWindow) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.closed) {
                // Make sure that there is sufficient time for whatever action to
                // complete. The window could have closed but the sign in network
                // call could still be in flight. This is specifically true for
                // Firefox or if the opener is in an iframe, in which case the oauth
                // helper closes the popup.
                this.pollId = window.setTimeout(() => {
                    this.pollId = null;
                    this.reject(_createError(this.auth, "popup-closed-by-user" /* AuthErrorCode.POPUP_CLOSED_BY_USER */));
                }, 8000 /* _Timeout.AUTH_EVENT */);
                return;
            }
            this.pollId = window.setTimeout(poll, _POLL_WINDOW_CLOSE_TIMEOUT.get());
        };
        poll();
    }
}
// Only one popup is ever shown at once. The lifecycle of the current popup
// can be managed / cancelled by the constructor.
PopupOperation.currentPopupAction = null;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PENDING_REDIRECT_KEY = 'pendingRedirect';
// We only get one redirect outcome for any one auth, so just store it
// in here.
const redirectOutcomeMap = new Map();
class RedirectAction extends AbstractPopupRedirectOperation {
    constructor(auth, resolver, bypassAuthState = false) {
        super(auth, [
            "signInViaRedirect" /* AuthEventType.SIGN_IN_VIA_REDIRECT */,
            "linkViaRedirect" /* AuthEventType.LINK_VIA_REDIRECT */,
            "reauthViaRedirect" /* AuthEventType.REAUTH_VIA_REDIRECT */,
            "unknown" /* AuthEventType.UNKNOWN */
        ], resolver, undefined, bypassAuthState);
        this.eventId = null;
    }
    /**
     * Override the execute function; if we already have a redirect result, then
     * just return it.
     */
    async execute() {
        let readyOutcome = redirectOutcomeMap.get(this.auth._key());
        if (!readyOutcome) {
            try {
                const hasPendingRedirect = await _getAndClearPendingRedirectStatus(this.resolver, this.auth);
                const result = hasPendingRedirect ? await super.execute() : null;
                readyOutcome = () => Promise.resolve(result);
            }
            catch (e) {
                readyOutcome = () => Promise.reject(e);
            }
            redirectOutcomeMap.set(this.auth._key(), readyOutcome);
        }
        // If we're not bypassing auth state, the ready outcome should be set to
        // null.
        if (!this.bypassAuthState) {
            redirectOutcomeMap.set(this.auth._key(), () => Promise.resolve(null));
        }
        return readyOutcome();
    }
    async onAuthEvent(event) {
        if (event.type === "signInViaRedirect" /* AuthEventType.SIGN_IN_VIA_REDIRECT */) {
            return super.onAuthEvent(event);
        }
        else if (event.type === "unknown" /* AuthEventType.UNKNOWN */) {
            // This is a sentinel value indicating there's no pending redirect
            this.resolve(null);
            return;
        }
        if (event.eventId) {
            const user = await this.auth._redirectUserForId(event.eventId);
            if (user) {
                this.user = user;
                return super.onAuthEvent(event);
            }
            else {
                this.resolve(null);
            }
        }
    }
    async onExecution() { }
    cleanUp() { }
}
async function _getAndClearPendingRedirectStatus(resolver, auth) {
    const key = pendingRedirectKey(auth);
    const persistence = resolverPersistence(resolver);
    if (!(await persistence._isAvailable())) {
        return false;
    }
    const hasPendingRedirect = (await persistence._get(key)) === 'true';
    await persistence._remove(key);
    return hasPendingRedirect;
}
async function _setPendingRedirectStatus(resolver, auth) {
    return resolverPersistence(resolver)._set(pendingRedirectKey(auth), 'true');
}
function _clearRedirectOutcomes() {
    redirectOutcomeMap.clear();
}
function _overrideRedirectResult(auth, result) {
    redirectOutcomeMap.set(auth._key(), result);
}
function resolverPersistence(resolver) {
    return _getInstance(resolver._redirectPersistence);
}
function pendingRedirectKey(auth) {
    return _persistenceKeyName(PENDING_REDIRECT_KEY, auth.config.apiKey, auth.name);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Authenticates a Firebase client using a full-page redirect flow.
 *
 * @remarks
 * To handle the results and errors for this operation, refer to {@link getRedirectResult}.
 * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices
 * | best practices} when using {@link signInWithRedirect}.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new FacebookAuthProvider();
 * // You can add additional scopes to the provider:
 * provider.addScope('user_birthday');
 * // Start a sign in process for an unauthenticated user.
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Facebook Access Token.
 *   const credential = provider.credentialFromResult(auth, result);
 *   const token = credential.accessToken;
 * }
 * // As this API can be used for sign-in, linking and reauthentication,
 * // check the operationType to determine what triggered this redirect
 * // operation.
 * const operationType = result.operationType;
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 * @public
 */
function signInWithRedirect(auth, provider, resolver) {
    return _signInWithRedirect(auth, provider, resolver);
}
async function _signInWithRedirect(auth, provider, resolver) {
    const authInternal = _castAuth(auth);
    _assertInstanceOf(auth, provider, FederatedAuthProvider);
    // Wait for auth initialization to complete, this will process pending redirects and clear the
    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new
    // redirect and creating a PENDING_REDIRECT_KEY entry.
    await authInternal._initializationPromise;
    const resolverInternal = _withDefaultResolver(authInternal, resolver);
    await _setPendingRedirectStatus(resolverInternal, authInternal);
    return resolverInternal._openRedirect(authInternal, provider, "signInViaRedirect" /* AuthEventType.SIGN_IN_VIA_REDIRECT */);
}
/**
 * Reauthenticates the current user with the specified {@link OAuthProvider} using a full-page redirect flow.
 * @remarks
 * To handle the results and errors for this operation, refer to {@link getRedirectResult}.
 * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices
 * | best practices} when using {@link reauthenticateWithRedirect}.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new FacebookAuthProvider();
 * const result = await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * // Reauthenticate using a redirect.
 * await reauthenticateWithRedirect(result.user, provider);
 * // This will again trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * ```
 *
 * @param user - The user.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 * @public
 */
function reauthenticateWithRedirect(user, provider, resolver) {
    return _reauthenticateWithRedirect(user, provider, resolver);
}
async function _reauthenticateWithRedirect(user, provider, resolver) {
    const userInternal = getModularInstance(user);
    _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
    // Wait for auth initialization to complete, this will process pending redirects and clear the
    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new
    // redirect and creating a PENDING_REDIRECT_KEY entry.
    await userInternal.auth._initializationPromise;
    // Allow the resolver to error before persisting the redirect user
    const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
    await _setPendingRedirectStatus(resolverInternal, userInternal.auth);
    const eventId = await prepareUserForRedirect(userInternal);
    return resolverInternal._openRedirect(userInternal.auth, provider, "reauthViaRedirect" /* AuthEventType.REAUTH_VIA_REDIRECT */, eventId);
}
/**
 * Links the {@link OAuthProvider} to the user account using a full-page redirect flow.
 * @remarks
 * To handle the results and errors for this operation, refer to {@link getRedirectResult}.
 * Follow the {@link https://firebase.google.com/docs/auth/web/redirect-best-practices
 * | best practices} when using {@link linkWithRedirect}.
 *
 * @example
 * ```javascript
 * // Sign in using some other provider.
 * const result = await signInWithEmailAndPassword(auth, email, password);
 * // Link using a redirect.
 * const provider = new FacebookAuthProvider();
 * await linkWithRedirect(result.user, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * ```
 *
 * @param user - The user.
 * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
 * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 *
 * @public
 */
function linkWithRedirect(user, provider, resolver) {
    return _linkWithRedirect(user, provider, resolver);
}
async function _linkWithRedirect(user, provider, resolver) {
    const userInternal = getModularInstance(user);
    _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
    // Wait for auth initialization to complete, this will process pending redirects and clear the
    // PENDING_REDIRECT_KEY in persistence. This should be completed before starting a new
    // redirect and creating a PENDING_REDIRECT_KEY entry.
    await userInternal.auth._initializationPromise;
    // Allow the resolver to error before persisting the redirect user
    const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
    await _assertLinkedStatus(false, userInternal, provider.providerId);
    await _setPendingRedirectStatus(resolverInternal, userInternal.auth);
    const eventId = await prepareUserForRedirect(userInternal);
    return resolverInternal._openRedirect(userInternal.auth, provider, "linkViaRedirect" /* AuthEventType.LINK_VIA_REDIRECT */, eventId);
}
/**
 * Returns a {@link UserCredential} from the redirect-based sign-in flow.
 *
 * @remarks
 * If sign-in succeeded, returns the signed in user. If sign-in was unsuccessful, fails with an
 * error. If no redirect operation was called, returns `null`.
 *
 * @example
 * ```javascript
 * // Sign in using a redirect.
 * const provider = new FacebookAuthProvider();
 * // You can add additional scopes to the provider:
 * provider.addScope('user_birthday');
 * // Start a sign in process for an unauthenticated user.
 * await signInWithRedirect(auth, provider);
 * // This will trigger a full page redirect away from your app
 *
 * // After returning from the redirect when your app initializes you can obtain the result
 * const result = await getRedirectResult(auth);
 * if (result) {
 *   // This is the signed-in user
 *   const user = result.user;
 *   // This gives you a Facebook Access Token.
 *   const credential = provider.credentialFromResult(auth, result);
 *   const token = credential.accessToken;
 * }
 * // As this API can be used for sign-in, linking and reauthentication,
 * // check the operationType to determine what triggered this redirect
 * // operation.
 * const operationType = result.operationType;
 * ```
 *
 * @param auth - The {@link Auth} instance.
 * @param resolver - An instance of {@link PopupRedirectResolver}, optional
 * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
 *
 * @public
 */
async function getRedirectResult(auth, resolver) {
    await _castAuth(auth)._initializationPromise;
    return _getRedirectResult(auth, resolver, false);
}
async function _getRedirectResult(auth, resolverExtern, bypassAuthState = false) {
    const authInternal = _castAuth(auth);
    const resolver = _withDefaultResolver(authInternal, resolverExtern);
    const action = new RedirectAction(authInternal, resolver, bypassAuthState);
    const result = await action.execute();
    if (result && !bypassAuthState) {
        delete result.user._redirectEventId;
        await authInternal._persistUserIfCurrent(result.user);
        await authInternal._setRedirectUser(null, resolverExtern);
    }
    return result;
}
async function prepareUserForRedirect(user) {
    const eventId = _generateEventId(`${user.uid}:::`);
    user._redirectEventId = eventId;
    await user.auth._setRedirectUser(user);
    await user.auth._persistUserIfCurrent(user);
    return eventId;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// The amount of time to store the UIDs of seen events; this is
// set to 10 min by default
const EVENT_DUPLICATION_CACHE_DURATION_MS = 10 * 60 * 1000;
class AuthEventManager {
    constructor(auth) {
        this.auth = auth;
        this.cachedEventUids = new Set();
        this.consumers = new Set();
        this.queuedRedirectEvent = null;
        this.hasHandledPotentialRedirect = false;
        this.lastProcessedEventTime = Date.now();
    }
    registerConsumer(authEventConsumer) {
        this.consumers.add(authEventConsumer);
        if (this.queuedRedirectEvent &&
            this.isEventForConsumer(this.queuedRedirectEvent, authEventConsumer)) {
            this.sendToConsumer(this.queuedRedirectEvent, authEventConsumer);
            this.saveEventToCache(this.queuedRedirectEvent);
            this.queuedRedirectEvent = null;
        }
    }
    unregisterConsumer(authEventConsumer) {
        this.consumers.delete(authEventConsumer);
    }
    onEvent(event) {
        // Check if the event has already been handled
        if (this.hasEventBeenHandled(event)) {
            return false;
        }
        let handled = false;
        this.consumers.forEach(consumer => {
            if (this.isEventForConsumer(event, consumer)) {
                handled = true;
                this.sendToConsumer(event, consumer);
                this.saveEventToCache(event);
            }
        });
        if (this.hasHandledPotentialRedirect || !isRedirectEvent(event)) {
            // If we've already seen a redirect before, or this is a popup event,
            // bail now
            return handled;
        }
        this.hasHandledPotentialRedirect = true;
        // If the redirect wasn't handled, hang on to it
        if (!handled) {
            this.queuedRedirectEvent = event;
            handled = true;
        }
        return handled;
    }
    sendToConsumer(event, consumer) {
        var _a;
        if (event.error && !isNullRedirectEvent(event)) {
            const code = ((_a = event.error.code) === null || _a === void 0 ? void 0 : _a.split('auth/')[1]) ||
                "internal-error" /* AuthErrorCode.INTERNAL_ERROR */;
            consumer.onError(_createError(this.auth, code));
        }
        else {
            consumer.onAuthEvent(event);
        }
    }
    isEventForConsumer(event, consumer) {
        const eventIdMatches = consumer.eventId === null ||
            (!!event.eventId && event.eventId === consumer.eventId);
        return consumer.filter.includes(event.type) && eventIdMatches;
    }
    hasEventBeenHandled(event) {
        if (Date.now() - this.lastProcessedEventTime >=
            EVENT_DUPLICATION_CACHE_DURATION_MS) {
            this.cachedEventUids.clear();
        }
        return this.cachedEventUids.has(eventUid(event));
    }
    saveEventToCache(event) {
        this.cachedEventUids.add(eventUid(event));
        this.lastProcessedEventTime = Date.now();
    }
}
function eventUid(e) {
    return [e.type, e.eventId, e.sessionId, e.tenantId].filter(v => v).join('-');
}
function isNullRedirectEvent({ type, error }) {
    return (type === "unknown" /* AuthEventType.UNKNOWN */ &&
        (error === null || error === void 0 ? void 0 : error.code) === `auth/${"no-auth-event" /* AuthErrorCode.NO_AUTH_EVENT */}`);
}
function isRedirectEvent(event) {
    switch (event.type) {
        case "signInViaRedirect" /* AuthEventType.SIGN_IN_VIA_REDIRECT */:
        case "linkViaRedirect" /* AuthEventType.LINK_VIA_REDIRECT */:
        case "reauthViaRedirect" /* AuthEventType.REAUTH_VIA_REDIRECT */:
            return true;
        case "unknown" /* AuthEventType.UNKNOWN */:
            return isNullRedirectEvent(event);
        default:
            return false;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _getProjectConfig(auth, request = {}) {
    return _performApiRequest(auth, "GET" /* HttpMethod.GET */, "/v1/projects" /* Endpoint.GET_PROJECT_CONFIG */, request);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IP_ADDRESS_REGEX = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
const HTTP_REGEX = /^https?/;
async function _validateOrigin(auth) {
    // Skip origin validation if we are in an emulated environment
    if (auth.config.emulator) {
        return;
    }
    const { authorizedDomains } = await _getProjectConfig(auth);
    for (const domain of authorizedDomains) {
        try {
            if (matchDomain(domain)) {
                return;
            }
        }
        catch (_a) {
            // Do nothing if there's a URL error; just continue searching
        }
    }
    // In the old SDK, this error also provides helpful messages.
    _fail(auth, "unauthorized-domain" /* AuthErrorCode.INVALID_ORIGIN */);
}
function matchDomain(expected) {
    const currentUrl = _getCurrentUrl();
    const { protocol, hostname } = new URL(currentUrl);
    if (expected.startsWith('chrome-extension://')) {
        const ceUrl = new URL(expected);
        if (ceUrl.hostname === '' && hostname === '') {
            // For some reason we're not parsing chrome URLs properly
            return (protocol === 'chrome-extension:' &&
                expected.replace('chrome-extension://', '') ===
                    currentUrl.replace('chrome-extension://', ''));
        }
        return protocol === 'chrome-extension:' && ceUrl.hostname === hostname;
    }
    if (!HTTP_REGEX.test(protocol)) {
        return false;
    }
    if (IP_ADDRESS_REGEX.test(expected)) {
        // The domain has to be exactly equal to the pattern, as an IP domain will
        // only contain the IP, no extra character.
        return hostname === expected;
    }
    // Dots in pattern should be escaped.
    const escapedDomainPattern = expected.replace(/\./g, '\\.');
    // Non ip address domains.
    // domain.com = *.domain.com OR domain.com
    const re = new RegExp('^(.+\\.' + escapedDomainPattern + '|' + escapedDomainPattern + ')$', 'i');
    return re.test(hostname);
}

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NETWORK_TIMEOUT = new Delay(30000, 60000);
/**
 * Reset unlaoded GApi modules. If gapi.load fails due to a network error,
 * it will stop working after a retrial. This is a hack to fix this issue.
 */
function resetUnloadedGapiModules() {
    // Clear last failed gapi.load state to force next gapi.load to first
    // load the failed gapi.iframes module.
    // Get gapix.beacon context.
    const beacon = _window().___jsl;
    // Get current hint.
    if (beacon === null || beacon === void 0 ? void 0 : beacon.H) {
        // Get gapi hint.
        for (const hint of Object.keys(beacon.H)) {
            // Requested modules.
            beacon.H[hint].r = beacon.H[hint].r || [];
            // Loaded modules.
            beacon.H[hint].L = beacon.H[hint].L || [];
            // Set requested modules to a copy of the loaded modules.
            beacon.H[hint].r = [...beacon.H[hint].L];
            // Clear pending callbacks.
            if (beacon.CP) {
                for (let i = 0; i < beacon.CP.length; i++) {
                    // Remove all failed pending callbacks.
                    beacon.CP[i] = null;
                }
            }
        }
    }
}
function loadGapi(auth) {
    return new Promise((resolve, reject) => {
        var _a, _b, _c;
        // Function to run when gapi.load is ready.
        function loadGapiIframe() {
            // The developer may have tried to previously run gapi.load and failed.
            // Run this to fix that.
            resetUnloadedGapiModules();
            gapi.load('gapi.iframes', {
                callback: () => {
                    resolve(gapi.iframes.getContext());
                },
                ontimeout: () => {
                    // The above reset may be sufficient, but having this reset after
                    // failure ensures that if the developer calls gapi.load after the
                    // connection is re-established and before another attempt to embed
                    // the iframe, it would work and would not be broken because of our
                    // failed attempt.
                    // Timeout when gapi.iframes.Iframe not loaded.
                    resetUnloadedGapiModules();
                    reject(_createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));
                },
                timeout: NETWORK_TIMEOUT.get()
            });
        }
        if ((_b = (_a = _window().gapi) === null || _a === void 0 ? void 0 : _a.iframes) === null || _b === void 0 ? void 0 : _b.Iframe) {
            // If gapi.iframes.Iframe available, resolve.
            resolve(gapi.iframes.getContext());
        }
        else if (!!((_c = _window().gapi) === null || _c === void 0 ? void 0 : _c.load)) {
            // Gapi loader ready, load gapi.iframes.
            loadGapiIframe();
        }
        else {
            // Create a new iframe callback when this is called so as not to overwrite
            // any previous defined callback. This happens if this method is called
            // multiple times in parallel and could result in the later callback
            // overwriting the previous one. This would end up with a iframe
            // timeout.
            const cbName = _generateCallbackName('iframefcb');
            // GApi loader not available, dynamically load platform.js.
            _window()[cbName] = () => {
                // GApi loader should be ready.
                if (!!gapi.load) {
                    loadGapiIframe();
                }
                else {
                    // Gapi loader failed, throw error.
                    reject(_createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));
                }
            };
            // Load GApi loader.
            return _loadJS(`https://apis.google.com/js/api.js?onload=${cbName}`)
                .catch(e => reject(e));
        }
    }).catch(error => {
        // Reset cached promise to allow for retrial.
        cachedGApiLoader = null;
        throw error;
    });
}
let cachedGApiLoader = null;
function _loadGapi(auth) {
    cachedGApiLoader = cachedGApiLoader || loadGapi(auth);
    return cachedGApiLoader;
}

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PING_TIMEOUT = new Delay(5000, 15000);
const IFRAME_PATH = '__/auth/iframe';
const EMULATED_IFRAME_PATH = 'emulator/auth/iframe';
const IFRAME_ATTRIBUTES = {
    style: {
        position: 'absolute',
        top: '-100px',
        width: '1px',
        height: '1px'
    },
    'aria-hidden': 'true',
    tabindex: '-1'
};
// Map from apiHost to endpoint ID for passing into iframe. In current SDK, apiHost can be set to
// anything (not from a list of endpoints with IDs as in legacy), so this is the closest we can get.
const EID_FROM_APIHOST = new Map([
    ["identitytoolkit.googleapis.com" /* DefaultConfig.API_HOST */, 'p'],
    ['staging-identitytoolkit.sandbox.googleapis.com', 's'],
    ['test-identitytoolkit.sandbox.googleapis.com', 't'] // test
]);
function getIframeUrl(auth) {
    const config = auth.config;
    _assert(config.authDomain, auth, "auth-domain-config-required" /* AuthErrorCode.MISSING_AUTH_DOMAIN */);
    const url = config.emulator
        ? _emulatorUrl(config, EMULATED_IFRAME_PATH)
        : `https://${auth.config.authDomain}/${IFRAME_PATH}`;
    const params = {
        apiKey: config.apiKey,
        appName: auth.name,
        v: SDK_VERSION
    };
    const eid = EID_FROM_APIHOST.get(auth.config.apiHost);
    if (eid) {
        params.eid = eid;
    }
    const frameworks = auth._getFrameworks();
    if (frameworks.length) {
        params.fw = frameworks.join(',');
    }
    return `${url}?${index_esm2017_querystring(params).slice(1)}`;
}
async function _openIframe(auth) {
    const context = await _loadGapi(auth);
    const gapi = _window().gapi;
    _assert(gapi, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
    return context.open({
        where: document.body,
        url: getIframeUrl(auth),
        messageHandlersFilter: gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
        attributes: IFRAME_ATTRIBUTES,
        dontclear: true
    }, (iframe) => new Promise(async (resolve, reject) => {
        await iframe.restyle({
            // Prevent iframe from closing on mouse out.
            setHideOnLeave: false
        });
        const networkError = _createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */);
        // Confirm iframe is correctly loaded.
        // To fallback on failure, set a timeout.
        const networkErrorTimer = _window().setTimeout(() => {
            reject(networkError);
        }, PING_TIMEOUT.get());
        // Clear timer and resolve pending iframe ready promise.
        function clearTimerAndResolve() {
            _window().clearTimeout(networkErrorTimer);
            resolve(iframe);
        }
        // This returns an IThenable. However the reject part does not call
        // when the iframe is not loaded.
        iframe.ping(clearTimerAndResolve).then(clearTimerAndResolve, () => {
            reject(networkError);
        });
    }));
}

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BASE_POPUP_OPTIONS = {
    location: 'yes',
    resizable: 'yes',
    statusbar: 'yes',
    toolbar: 'no'
};
const DEFAULT_WIDTH = 500;
const DEFAULT_HEIGHT = 600;
const TARGET_BLANK = '_blank';
const FIREFOX_EMPTY_URL = 'http://localhost';
class AuthPopup {
    constructor(window) {
        this.window = window;
        this.associatedEvent = null;
    }
    close() {
        if (this.window) {
            try {
                this.window.close();
            }
            catch (e) { }
        }
    }
}
function _open(auth, url, name, width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT) {
    const top = Math.max((window.screen.availHeight - height) / 2, 0).toString();
    const left = Math.max((window.screen.availWidth - width) / 2, 0).toString();
    let target = '';
    const options = Object.assign(Object.assign({}, BASE_POPUP_OPTIONS), { width: width.toString(), height: height.toString(), top,
        left });
    // Chrome iOS 7 and 8 is returning an undefined popup win when target is
    // specified, even though the popup is not necessarily blocked.
    const ua = index_esm2017_getUA().toLowerCase();
    if (name) {
        target = _isChromeIOS(ua) ? TARGET_BLANK : name;
    }
    if (_isFirefox(ua)) {
        // Firefox complains when invalid URLs are popped out. Hacky way to bypass.
        url = url || FIREFOX_EMPTY_URL;
        // Firefox disables by default scrolling on popup windows, which can create
        // issues when the user has many Google accounts, for instance.
        options.scrollbars = 'yes';
    }
    const optionsString = Object.entries(options).reduce((accum, [key, value]) => `${accum}${key}=${value},`, '');
    if (_isIOSStandalone(ua) && target !== '_self') {
        openAsNewWindowIOS(url || '', target);
        return new AuthPopup(null);
    }
    // about:blank getting sanitized causing browsers like IE/Edge to display
    // brief error message before redirecting to handler.
    const newWin = window.open(url || '', target, optionsString);
    _assert(newWin, auth, "popup-blocked" /* AuthErrorCode.POPUP_BLOCKED */);
    // Flaky on IE edge, encapsulate with a try and catch.
    try {
        newWin.focus();
    }
    catch (e) { }
    return new AuthPopup(newWin);
}
function openAsNewWindowIOS(url, target) {
    const el = document.createElement('a');
    el.href = url;
    el.target = target;
    const click = document.createEvent('MouseEvent');
    click.initMouseEvent('click', true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 1, null);
    el.dispatchEvent(click);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * URL for Authentication widget which will initiate the OAuth handshake
 *
 * @internal
 */
const WIDGET_PATH = '__/auth/handler';
/**
 * URL for emulated environment
 *
 * @internal
 */
const EMULATOR_WIDGET_PATH = 'emulator/auth/handler';
/**
 * Fragment name for the App Check token that gets passed to the widget
 *
 * @internal
 */
const FIREBASE_APP_CHECK_FRAGMENT_ID = encodeURIComponent('fac');
async function _getRedirectUrl(auth, provider, authType, redirectUrl, eventId, additionalParams) {
    _assert(auth.config.authDomain, auth, "auth-domain-config-required" /* AuthErrorCode.MISSING_AUTH_DOMAIN */);
    _assert(auth.config.apiKey, auth, "invalid-api-key" /* AuthErrorCode.INVALID_API_KEY */);
    const params = {
        apiKey: auth.config.apiKey,
        appName: auth.name,
        authType,
        redirectUrl,
        v: SDK_VERSION,
        eventId
    };
    if (provider instanceof FederatedAuthProvider) {
        provider.setDefaultLanguage(auth.languageCode);
        params.providerId = provider.providerId || '';
        if (!isEmpty(provider.getCustomParameters())) {
            params.customParameters = JSON.stringify(provider.getCustomParameters());
        }
        // TODO set additionalParams from the provider as well?
        for (const [key, value] of Object.entries(additionalParams || {})) {
            params[key] = value;
        }
    }
    if (provider instanceof BaseOAuthProvider) {
        const scopes = provider.getScopes().filter(scope => scope !== '');
        if (scopes.length > 0) {
            params.scopes = scopes.join(',');
        }
    }
    if (auth.tenantId) {
        params.tid = auth.tenantId;
    }
    // TODO: maybe set eid as endipointId
    // TODO: maybe set fw as Frameworks.join(",")
    const paramsDict = params;
    for (const key of Object.keys(paramsDict)) {
        if (paramsDict[key] === undefined) {
            delete paramsDict[key];
        }
    }
    // Sets the App Check token to pass to the widget
    const appCheckToken = await auth._getAppCheckToken();
    const appCheckTokenFragment = appCheckToken
        ? `#${FIREBASE_APP_CHECK_FRAGMENT_ID}=${encodeURIComponent(appCheckToken)}`
        : '';
    // Start at index 1 to skip the leading '&' in the query string
    return `${getHandlerBase(auth)}?${index_esm2017_querystring(paramsDict).slice(1)}${appCheckTokenFragment}`;
}
function getHandlerBase({ config }) {
    if (!config.emulator) {
        return `https://${config.authDomain}/${WIDGET_PATH}`;
    }
    return _emulatorUrl(config, EMULATOR_WIDGET_PATH);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The special web storage event
 *
 */
const WEB_STORAGE_SUPPORT_KEY = 'webStorageSupport';
class BrowserPopupRedirectResolver {
    constructor() {
        this.eventManagers = {};
        this.iframes = {};
        this.originValidationPromises = {};
        this._redirectPersistence = browserSessionPersistence;
        this._completeRedirectFn = _getRedirectResult;
        this._overrideRedirectResult = _overrideRedirectResult;
    }
    // Wrapping in async even though we don't await anywhere in order
    // to make sure errors are raised as promise rejections
    async _openPopup(auth, provider, authType, eventId) {
        var _a;
        debugAssert((_a = this.eventManagers[auth._key()]) === null || _a === void 0 ? void 0 : _a.manager, '_initialize() not called before _openPopup()');
        const url = await _getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId);
        return _open(auth, url, _generateEventId());
    }
    async _openRedirect(auth, provider, authType, eventId) {
        await this._originValidation(auth);
        const url = await _getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId);
        _setWindowLocation(url);
        return new Promise(() => { });
    }
    _initialize(auth) {
        const key = auth._key();
        if (this.eventManagers[key]) {
            const { manager, promise } = this.eventManagers[key];
            if (manager) {
                return Promise.resolve(manager);
            }
            else {
                debugAssert(promise, 'If manager is not set, promise should be');
                return promise;
            }
        }
        const promise = this.initAndGetManager(auth);
        this.eventManagers[key] = { promise };
        // If the promise is rejected, the key should be removed so that the
        // operation can be retried later.
        promise.catch(() => {
            delete this.eventManagers[key];
        });
        return promise;
    }
    async initAndGetManager(auth) {
        const iframe = await _openIframe(auth);
        const manager = new AuthEventManager(auth);
        iframe.register('authEvent', (iframeEvent) => {
            _assert(iframeEvent === null || iframeEvent === void 0 ? void 0 : iframeEvent.authEvent, auth, "invalid-auth-event" /* AuthErrorCode.INVALID_AUTH_EVENT */);
            // TODO: Consider splitting redirect and popup events earlier on
            const handled = manager.onEvent(iframeEvent.authEvent);
            return { status: handled ? "ACK" /* GapiOutcome.ACK */ : "ERROR" /* GapiOutcome.ERROR */ };
        }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
        this.eventManagers[auth._key()] = { manager };
        this.iframes[auth._key()] = iframe;
        return manager;
    }
    _isIframeWebStorageSupported(auth, cb) {
        const iframe = this.iframes[auth._key()];
        iframe.send(WEB_STORAGE_SUPPORT_KEY, { type: WEB_STORAGE_SUPPORT_KEY }, result => {
            var _a;
            const isSupported = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a[WEB_STORAGE_SUPPORT_KEY];
            if (isSupported !== undefined) {
                cb(!!isSupported);
            }
            _fail(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
    }
    _originValidation(auth) {
        const key = auth._key();
        if (!this.originValidationPromises[key]) {
            this.originValidationPromises[key] = _validateOrigin(auth);
        }
        return this.originValidationPromises[key];
    }
    get _shouldInitProactively() {
        // Mobile browsers and Safari need to optimistically initialize
        return _isMobileBrowser() || _isSafari() || _isIOS();
    }
}
/**
 * An implementation of {@link PopupRedirectResolver} suitable for browser
 * based applications.
 *
 * @public
 */
const browserPopupRedirectResolver = BrowserPopupRedirectResolver;

class MultiFactorAssertionImpl {
    constructor(factorId) {
        this.factorId = factorId;
    }
    _process(auth, session, displayName) {
        switch (session.type) {
            case "enroll" /* MultiFactorSessionType.ENROLL */:
                return this._finalizeEnroll(auth, session.credential, displayName);
            case "signin" /* MultiFactorSessionType.SIGN_IN */:
                return this._finalizeSignIn(auth, session.credential);
            default:
                return debugFail('unexpected MultiFactorSessionType');
        }
    }
}

/**
 * {@inheritdoc PhoneMultiFactorAssertion}
 *
 * @public
 */
class PhoneMultiFactorAssertionImpl extends MultiFactorAssertionImpl {
    constructor(credential) {
        super("phone" /* FactorId.PHONE */);
        this.credential = credential;
    }
    /** @internal */
    static _fromCredential(credential) {
        return new PhoneMultiFactorAssertionImpl(credential);
    }
    /** @internal */
    _finalizeEnroll(auth, idToken, displayName) {
        return finalizeEnrollPhoneMfa(auth, {
            idToken,
            displayName,
            phoneVerificationInfo: this.credential._makeVerificationRequest()
        });
    }
    /** @internal */
    _finalizeSignIn(auth, mfaPendingCredential) {
        return finalizeSignInPhoneMfa(auth, {
            mfaPendingCredential,
            phoneVerificationInfo: this.credential._makeVerificationRequest()
        });
    }
}
/**
 * Provider for generating a {@link PhoneMultiFactorAssertion}.
 *
 * @public
 */
class PhoneMultiFactorGenerator {
    constructor() { }
    /**
     * Provides a {@link PhoneMultiFactorAssertion} to confirm ownership of the phone second factor.
     *
     * @param phoneAuthCredential - A credential provided by {@link PhoneAuthProvider.credential}.
     * @returns A {@link PhoneMultiFactorAssertion} which can be used with
     * {@link MultiFactorResolver.resolveSignIn}
     */
    static assertion(credential) {
        return PhoneMultiFactorAssertionImpl._fromCredential(credential);
    }
}
/**
 * The identifier of the phone second factor: `phone`.
 */
PhoneMultiFactorGenerator.FACTOR_ID = 'phone';

/**
 * Provider for generating a {@link TotpMultiFactorAssertion}.
 *
 * @public
 */
class TotpMultiFactorGenerator {
    /**
     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of
     * the TOTP (time-based one-time password) second factor.
     * This assertion is used to complete enrollment in TOTP second factor.
     *
     * @param secret A {@link TotpSecret} containing the shared secret key and other TOTP parameters.
     * @param oneTimePassword One-time password from TOTP App.
     * @returns A {@link TotpMultiFactorAssertion} which can be used with
     * {@link MultiFactorUser.enroll}.
     */
    static assertionForEnrollment(secret, oneTimePassword) {
        return TotpMultiFactorAssertionImpl._fromSecret(secret, oneTimePassword);
    }
    /**
     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of the TOTP second factor.
     * This assertion is used to complete signIn with TOTP as the second factor.
     *
     * @param enrollmentId identifies the enrolled TOTP second factor.
     * @param oneTimePassword One-time password from TOTP App.
     * @returns A {@link TotpMultiFactorAssertion} which can be used with
     * {@link MultiFactorResolver.resolveSignIn}.
     */
    static assertionForSignIn(enrollmentId, oneTimePassword) {
        return TotpMultiFactorAssertionImpl._fromEnrollmentId(enrollmentId, oneTimePassword);
    }
    /**
     * Returns a promise to {@link TotpSecret} which contains the TOTP shared secret key and other parameters.
     * Creates a TOTP secret as part of enrolling a TOTP second factor.
     * Used for generating a QR code URL or inputting into a TOTP app.
     * This method uses the auth instance corresponding to the user in the multiFactorSession.
     *
     * @param session The {@link MultiFactorSession} that the user is part of.
     * @returns A promise to {@link TotpSecret}.
     */
    static async generateSecret(session) {
        const mfaSession = session;
        _assert(typeof mfaSession.auth !== 'undefined', "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        const response = await startEnrollTotpMfa(mfaSession.auth, {
            idToken: mfaSession.credential,
            totpEnrollmentInfo: {}
        });
        return TotpSecret._fromStartTotpMfaEnrollmentResponse(response, mfaSession.auth);
    }
}
/**
 * The identifier of the TOTP second factor: `totp`.
 */
TotpMultiFactorGenerator.FACTOR_ID = "totp" /* FactorId.TOTP */;
class TotpMultiFactorAssertionImpl extends MultiFactorAssertionImpl {
    constructor(otp, enrollmentId, secret) {
        super("totp" /* FactorId.TOTP */);
        this.otp = otp;
        this.enrollmentId = enrollmentId;
        this.secret = secret;
    }
    /** @internal */
    static _fromSecret(secret, otp) {
        return new TotpMultiFactorAssertionImpl(otp, undefined, secret);
    }
    /** @internal */
    static _fromEnrollmentId(enrollmentId, otp) {
        return new TotpMultiFactorAssertionImpl(otp, enrollmentId);
    }
    /** @internal */
    async _finalizeEnroll(auth, idToken, displayName) {
        _assert(typeof this.secret !== 'undefined', auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        return finalizeEnrollTotpMfa(auth, {
            idToken,
            displayName,
            totpVerificationInfo: this.secret._makeTotpVerificationInfo(this.otp)
        });
    }
    /** @internal */
    async _finalizeSignIn(auth, mfaPendingCredential) {
        _assert(this.enrollmentId !== undefined && this.otp !== undefined, auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        const totpVerificationInfo = { verificationCode: this.otp };
        return finalizeSignInTotpMfa(auth, {
            mfaPendingCredential,
            mfaEnrollmentId: this.enrollmentId,
            totpVerificationInfo
        });
    }
}
/**
 * Provider for generating a {@link TotpMultiFactorAssertion}.
 *
 * Stores the shared secret key and other parameters to generate time-based OTPs.
 * Implements methods to retrieve the shared secret key and generate a QR code URL.
 * @public
 */
class TotpSecret {
    // The public members are declared outside the constructor so the docs can be generated.
    constructor(secretKey, hashingAlgorithm, codeLength, codeIntervalSeconds, enrollmentCompletionDeadline, sessionInfo, auth) {
        this.sessionInfo = sessionInfo;
        this.auth = auth;
        this.secretKey = secretKey;
        this.hashingAlgorithm = hashingAlgorithm;
        this.codeLength = codeLength;
        this.codeIntervalSeconds = codeIntervalSeconds;
        this.enrollmentCompletionDeadline = enrollmentCompletionDeadline;
    }
    /** @internal */
    static _fromStartTotpMfaEnrollmentResponse(response, auth) {
        return new TotpSecret(response.totpSessionInfo.sharedSecretKey, response.totpSessionInfo.hashingAlgorithm, response.totpSessionInfo.verificationCodeLength, response.totpSessionInfo.periodSec, new Date(response.totpSessionInfo.finalizeEnrollmentTime).toUTCString(), response.totpSessionInfo.sessionInfo, auth);
    }
    /** @internal */
    _makeTotpVerificationInfo(otp) {
        return { sessionInfo: this.sessionInfo, verificationCode: otp };
    }
    /**
     * Returns a QR code URL as described in
     * https://github.com/google/google-authenticator/wiki/Key-Uri-Format
     * This can be displayed to the user as a QR code to be scanned into a TOTP app like Google Authenticator.
     * If the optional parameters are unspecified, an accountName of <userEmail> and issuer of <firebaseAppName> are used.
     *
     * @param accountName the name of the account/app along with a user identifier.
     * @param issuer issuer of the TOTP (likely the app name).
     * @returns A QR code URL string.
     */
    generateQrCodeUrl(accountName, issuer) {
        var _a;
        let useDefaults = false;
        if (_isEmptyString(accountName) || _isEmptyString(issuer)) {
            useDefaults = true;
        }
        if (useDefaults) {
            if (_isEmptyString(accountName)) {
                accountName = ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.email) || 'unknownuser';
            }
            if (_isEmptyString(issuer)) {
                issuer = this.auth.name;
            }
        }
        return `otpauth://totp/${issuer}:${accountName}?secret=${this.secretKey}&issuer=${issuer}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`;
    }
}
/** @internal */
function _isEmptyString(input) {
    return typeof input === 'undefined' || (input === null || input === void 0 ? void 0 : input.length) === 0;
}

var index_e3d5d3f4_name = "@firebase/auth";
var index_e3d5d3f4_version = "0.23.2";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthInterop {
    constructor(auth) {
        this.auth = auth;
        this.internalListeners = new Map();
    }
    getUid() {
        var _a;
        this.assertAuthConfigured();
        return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;
    }
    async getToken(forceRefresh) {
        this.assertAuthConfigured();
        await this.auth._initializationPromise;
        if (!this.auth.currentUser) {
            return null;
        }
        const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);
        return { accessToken };
    }
    addAuthTokenListener(listener) {
        this.assertAuthConfigured();
        if (this.internalListeners.has(listener)) {
            return;
        }
        const unsubscribe = this.auth.onIdTokenChanged(user => {
            listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);
        });
        this.internalListeners.set(listener, unsubscribe);
        this.updateProactiveRefresh();
    }
    removeAuthTokenListener(listener) {
        this.assertAuthConfigured();
        const unsubscribe = this.internalListeners.get(listener);
        if (!unsubscribe) {
            return;
        }
        this.internalListeners.delete(listener);
        unsubscribe();
        this.updateProactiveRefresh();
    }
    assertAuthConfigured() {
        _assert(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */);
    }
    updateProactiveRefresh() {
        if (this.internalListeners.size > 0) {
            this.auth._startProactiveRefresh();
        }
        else {
            this.auth._stopProactiveRefresh();
        }
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getVersionForPlatform(clientPlatform) {
    switch (clientPlatform) {
        case "Node" /* ClientPlatform.NODE */:
            return 'node';
        case "ReactNative" /* ClientPlatform.REACT_NATIVE */:
            return 'rn';
        case "Worker" /* ClientPlatform.WORKER */:
            return 'webworker';
        case "Cordova" /* ClientPlatform.CORDOVA */:
            return 'cordova';
        default:
            return undefined;
    }
}
/** @internal */
function registerAuth(clientPlatform) {
    _registerComponent(new Component("auth" /* _ComponentName.AUTH */, (container, { options: deps }) => {
        const app = container.getProvider('app').getImmediate();
        const heartbeatServiceProvider = container.getProvider('heartbeat');
        const appCheckServiceProvider = container.getProvider('app-check-internal');
        const { apiKey, authDomain } = app.options;
        _assert(apiKey && !apiKey.includes(':'), "invalid-api-key" /* AuthErrorCode.INVALID_API_KEY */, { appName: app.name });
        const config = {
            apiKey,
            authDomain,
            clientPlatform,
            apiHost: "identitytoolkit.googleapis.com" /* DefaultConfig.API_HOST */,
            tokenApiHost: "securetoken.googleapis.com" /* DefaultConfig.TOKEN_API_HOST */,
            apiScheme: "https" /* DefaultConfig.API_SCHEME */,
            sdkClientVersion: _getClientVersion(clientPlatform)
        };
        const authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);
        _initializeAuthInstance(authInstance, deps);
        return authInstance;
    }, "PUBLIC" /* ComponentType.PUBLIC */)
        /**
         * Auth can only be initialized by explicitly calling getAuth() or initializeAuth()
         * For why we do this, See go/firebase-next-auth-init
         */
        .setInstantiationMode("EXPLICIT" /* InstantiationMode.EXPLICIT */)
        /**
         * Because all firebase products that depend on auth depend on auth-internal directly,
         * we need to initialize auth-internal after auth is initialized to make it available to other firebase products.
         */
        .setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {
        const authInternalProvider = container.getProvider("auth-internal" /* _ComponentName.AUTH_INTERNAL */);
        authInternalProvider.initialize();
    }));
    _registerComponent(new Component("auth-internal" /* _ComponentName.AUTH_INTERNAL */, container => {
        const auth = _castAuth(container.getProvider("auth" /* _ComponentName.AUTH */).getImmediate());
        return (auth => new AuthInterop(auth))(auth);
    }, "PRIVATE" /* ComponentType.PRIVATE */).setInstantiationMode("EXPLICIT" /* InstantiationMode.EXPLICIT */));
    registerVersion(index_e3d5d3f4_name, index_e3d5d3f4_version, getVersionForPlatform(clientPlatform));
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(index_e3d5d3f4_name, index_e3d5d3f4_version, 'esm2017');
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ID_TOKEN_MAX_AGE = 5 * 60;
const authIdTokenMaxAge = getExperimentalSetting('authIdTokenMaxAge') || DEFAULT_ID_TOKEN_MAX_AGE;
let lastPostedIdToken = null;
const mintCookieFactory = (url) => async (user) => {
    const idTokenResult = user && (await user.getIdTokenResult());
    const idTokenAge = idTokenResult &&
        (new Date().getTime() - Date.parse(idTokenResult.issuedAtTime)) / 1000;
    if (idTokenAge && idTokenAge > authIdTokenMaxAge) {
        return;
    }
    // Specifically trip null => undefined when logged out, to delete any existing cookie
    const idToken = idTokenResult === null || idTokenResult === void 0 ? void 0 : idTokenResult.token;
    if (lastPostedIdToken === idToken) {
        return;
    }
    lastPostedIdToken = idToken;
    await fetch(url, {
        method: idToken ? 'POST' : 'DELETE',
        headers: idToken
            ? {
                'Authorization': `Bearer ${idToken}`
            }
            : {}
    });
};
/**
 * Returns the Auth instance associated with the provided {@link @firebase/app#FirebaseApp}.
 * If no instance exists, initializes an Auth instance with platform-specific default dependencies.
 *
 * @param app - The Firebase App.
 *
 * @public
 */
function getAuth(app = getApp()) {
    const provider = _getProvider(app, 'auth');
    if (provider.isInitialized()) {
        return provider.getImmediate();
    }
    const auth = initializeAuth(app, {
        popupRedirectResolver: browserPopupRedirectResolver,
        persistence: [
            indexedDBLocalPersistence,
            browserLocalPersistence,
            browserSessionPersistence
        ]
    });
    const authTokenSyncUrl = getExperimentalSetting('authTokenSyncURL');
    if (authTokenSyncUrl) {
        const mintCookie = mintCookieFactory(authTokenSyncUrl);
        beforeAuthStateChanged(auth, mintCookie, () => mintCookie(auth.currentUser));
        onIdTokenChanged(auth, user => mintCookie(user));
    }
    const authEmulatorHost = getDefaultEmulatorHost('auth');
    if (authEmulatorHost) {
        connectAuthEmulator(auth, `http://${authEmulatorHost}`);
    }
    return auth;
}
registerAuth("Browser" /* ClientPlatform.BROWSER */);



;// CONCATENATED MODULE: ./node_modules/@firebase/auth/dist/esm2017/index.js







;// CONCATENATED MODULE: ./node_modules/firebase/auth/dist/esm/index.esm.js


;// CONCATENATED MODULE: ./node_modules/firebase/app/dist/esm/index.esm.js



var index_esm_name = "firebase";
var index_esm_version = "9.23.0";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerVersion(index_esm_name, index_esm_version, 'app');

;// CONCATENATED MODULE: ./src/dropbox_auth.ts




const firebaseConfig = {
    apiKey: 'AIzaSyDwtcPjQMj3JAy9d7wwjib19eywvGfdV3A',
    authDomain: 'splunge-390110.firebaseapp.com',
    projectId: 'splunge-390110',
    storageBucket: 'splunge-390110.appspot.com',
    messagingSenderId: '1041542736895',
    appId: '1:1041542736895:web:663b9c5ab38f8295eb95ca',
};
let firebase_app;
let firebase_auth;
function getCurrentUser(auth) {
    return new Promise((resolve, reject) => {
        const unsubscribe = auth.onAuthStateChanged((user) => {
            unsubscribe();
            resolve(user);
        }, reject);
    });
}
class DropboxAuther {
    CLIENT_ID = 'jxpyhv2cqozub0c';
    REDIRECT_URI = 'http://localhost:8080/';
    dbx;
    dbxAuth;
    authed = false;
    firebase_user;
    async init() {
        if (true) {
            this.REDIRECT_URI = 'https://wrightwriter.github.io/splunge/';
        }
        firebase_app = initializeApp(firebaseConfig);
        firebase_auth = getAuth(firebase_app);
        this.firebase_user = await getCurrentUser(firebase_auth);
        this.dbxAuth = new Dropbox_sdk_min.DropboxAuth({
            clientId: this.CLIENT_ID,
        });
        if (this.firebase_user) {
            const id_token = await firebase_auth.currentUser?.getIdToken(true);
            let res = await (await fetch('https://us-central1-splunge-390110.cloudfunctions.net/getDropboxCode' + `?id_token=${id_token}`)).json();
            const access_token = res.token;
            this.dbxAuth.setAccessToken(access_token);
            this.dbx = new Dropbox_sdk_min.Dropbox({
                auth: this.dbxAuth,
            });
            let files = await this.dbx.filesListFolder({
                path: '',
            });
            this.authed = true;
        }
    }
    constructor() { }
    parseQueryString(str) {
        const ret = Object.create(null);
        if (typeof str !== 'string') {
            return ret;
        }
        str = str.trim().replace(/^(\?|#|&)/, '');
        if (!str) {
            return ret;
        }
        str.split('&').forEach((param) => {
            const parts = param.replace(/\+/g, ' ').split('=');
            let key = parts.shift();
            let val = parts.length > 0 ? parts.join('=') : undefined;
            key = decodeURIComponent(key);
            val = val === undefined ? null : decodeURIComponent(val);
            if (ret[key] === undefined) {
                ret[key] = val;
            }
            else if (Array.isArray(ret[key])) {
                ret[key].push(val);
            }
            else {
                ret[key] = [ret[key], val];
            }
        });
        return ret;
    }
    async doAuth() {
        try {
            const url_response = await fetch('https://us-central1-splunge-390110.cloudfunctions.net/getAuthenticationUrl' + `?url=${window.location.href}`);
            let url = await url_response.json();
            url = url['auth_url'];
            window.location.href = url;
        }
        catch (error) {
            console.error(error);
        }
    }
    async try_init_dropbox() {
        let code = undefined;
        const getCodeFromUrl = () => {
            code = this.parseQueryString(window.location.search).code;
            return code;
        };
        const hasRedirectedFromAuth = () => {
            return !!getCodeFromUrl();
        };
        let redirectedFromAuth = hasRedirectedFromAuth();
        if (redirectedFromAuth) {
            const url = new URL(window.location.href);
            const body = {};
            for (let key of url.searchParams.keys()) {
                if (url.searchParams.getAll(key).length > 1) {
                    body[key] = url.searchParams.getAll(key);
                }
                else {
                    body[key] = url.searchParams.get(key);
                }
            }
            window.history.replaceState &&
                window.history.replaceState(null, '', window.location.pathname +
                    window.location.search.replace(/[?&]code=[^&]+/, '').replace(/^&/, '?') +
                    window.location.hash);
            body['redirect_url'] = window.location.href;
            const res = await fetch('https://us-central1-splunge-390110.cloudfunctions.net/exchangeDropboxCode' +
                `?redirect_url=${window.location.href}` +
                `&code=${body['code']}`);
            const data = await res.json();
            signInWithCustomToken(firebase_auth, data.token);
        }
        return;
    }
}

;// CONCATENATED MODULE: ./src/components/GalleryWidget.svelte
/* src/components/GalleryWidget.svelte generated by Svelte v4.0.1 */


const { Error: Error_1, console: console_1 } = globals;
















const GalleryWidget_svelte_file = "src/components/GalleryWidget.svelte";

function GalleryWidget_svelte_add_css(target) {
	append_styles(target, "svelte-1pzoxsa", "#canvas-preview-img.svelte-1pzoxsa.svelte-1pzoxsa{height:12rem}.hide.svelte-1pzoxsa.svelte-1pzoxsa{display:none}#gallery-container::-webkit-scrollbar{background:black}#gallery-container::-webkit-scrollbar-track{background:grey}#gallery-container::-webkit-scrollbar-thumb{background:white}#db-login-button.svelte-1pzoxsa.svelte-1pzoxsa{font-size:3rem;border-radius:0px;margin-bottom:2rem;cursor:pointer}#db-login-button.svelte-1pzoxsa.svelte-1pzoxsa:active{filter:invert(1)}#size-modal.svelte-1pzoxsa.svelte-1pzoxsa{position:fixed;display:flex;flex-direction:column;align-items:center;width:100vw;height:100vh;left:0;top:0;z-index:101;background:black;justify-content:center}#gallery-container-outer.svelte-1pzoxsa.svelte-1pzoxsa{position:fixed;display:flex;flex-direction:column;align-items:center;width:100vw;height:100vh;left:0;top:0;z-index:100;background:black}#gallery-container-outer.svelte-1pzoxsa #gallery-container.svelte-1pzoxsa{overflow-y:overlay;scrollbar-gutter:stable both-edges;margin-top:1rem;height:100%;max-width:40rem;width:100%;display:flex;flex-direction:column;align-items:center}#gallery-container-outer.svelte-1pzoxsa #gallery-container #top-bar.svelte-1pzoxsa{margin-bottom:1rem;width:100%;font-size:2rem;display:flex;justify-content:space-between}#gallery-container-outer.svelte-1pzoxsa #gallery-container #top-bar #project-title.svelte-1pzoxsa{margin-left:0.5rem}#gallery-container-outer.svelte-1pzoxsa #gallery-container #options-bar.svelte-1pzoxsa{align-items:center;margin-bottom:1rem;width:100%;font-size:2rem;display:flex;justify-content:space-between}#gallery-container-outer.svelte-1pzoxsa #gallery-container #options-bar .svelte-1pzoxsa{font-size:0.95rem}#gallery-container-outer.svelte-1pzoxsa #gallery-container #options-bar .svelte-1pzoxsa svg{fill:white}#gallery-container-outer.svelte-1pzoxsa #gallery-container #options-bar #button.svelte-1pzoxsa{display:flex;cursor:pointer;padding:0rem 0.2rem}#gallery-container-outer.svelte-1pzoxsa #gallery-container #options-bar #button.svelte-1pzoxsa svg{height:100%}#gallery-container-outer.svelte-1pzoxsa #gallery-container #options-bar #button.svelte-1pzoxsa:active{filter:invert(1);background:black}#gallery-container-outer.svelte-1pzoxsa #gallery-container .ok-button.svelte-1pzoxsa svg{transform:scale(0.96) !important}#gallery-container-outer.svelte-1pzoxsa #gallery-container #back-button.svelte-1pzoxsa>svg{transform:scale(1.5) translate(0.2rem, 0px);fill:white;width:3rem;aspect-ratio:1/1;cursor:pointer}#gallery-container-outer.svelte-1pzoxsa #gallery-container #back-button.svelte-1pzoxsa>svg:active{filter:invert(1);background:black}#gallery-container-outer.svelte-1pzoxsa #gallery-container #gallery-elements.svelte-1pzoxsa{width:100%;display:grid;grid-template-columns:repeat(3, 1fr);gap:10px;grid-auto-rows:minmax(100px, auto)}#gallery-container-outer.svelte-1pzoxsa #gallery-container #gallery-elements #element.svelte-1pzoxsa{cursor:pointer;user-select:none}#gallery-container-outer.svelte-1pzoxsa #gallery-container #gallery-elements #element #element-name.svelte-1pzoxsa{margin-bottom:0.5rem}#gallery-container-outer.svelte-1pzoxsa #gallery-container #gallery-elements #element.svelte-1pzoxsa:active{background:white}#gallery-container-outer.svelte-1pzoxsa #gallery-container #gallery-elements #element:active .svelte-1pzoxsa{color:black}#gallery-container-outer.svelte-1pzoxsa #gallery-container #current-project.svelte-1pzoxsa{display:flex;justify-content:space-between;width:100%;margin-bottom:1rem}#gallery-container-outer.svelte-1pzoxsa #gallery-container #current-project #project-options.svelte-1pzoxsa{display:flex;flex-direction:column;justify-content:space-between}#gallery-container-outer.svelte-1pzoxsa #gallery-container #current-project #project-options .svelte-1pzoxsa{font-size:1.3rem}#gallery-container-outer.svelte-1pzoxsa #gallery-container #current-project #project-options #project-save-button-title.svelte-1pzoxsa{margin-right:0.5rem}#gallery-container-outer.svelte-1pzoxsa #gallery-container #current-project #project-options #project-save-button.svelte-1pzoxsa{margin-right:1.5rem;cursor:pointer;justify-content:flex-end;display:flex;flex-direction:row;align-items:center;height:2rem;max-width:30rem;width:100%}#gallery-container-outer.svelte-1pzoxsa #gallery-container #current-project #project-options #project-save-button.svelte-1pzoxsa:active{filter:invert(1);background:black}#gallery-container-outer.svelte-1pzoxsa #gallery-container #current-project #project-options #project-save-button .icon.svelte-1pzoxsa{width:2rem}#gallery-container-outer.svelte-1pzoxsa #gallery-container #current-project #project-options #project-save-button .svelte-1pzoxsa{font-size:1rem}#gallery-container-outer.svelte-1pzoxsa #gallery-container #current-project #project-options #project-save-button.svelte-1pzoxsa svg{aspect-ratio:1/1;fill:white}.knob-container.svelte-1pzoxsa.svelte-1pzoxsa{cursor:pointer;aspect-ratio:1/1;height:100%;margin-left:0.5rem;margin-right:0.5rem;margin-bottom:auto;margin-top:auto;pointer-events:all;user-select:none;width:unset}.knob-container.svelte-1pzoxsa.svelte-1pzoxsa:hover{cursor:pointer}.knob.svelte-1pzoxsa.svelte-1pzoxsa{display:block;aspect-ratio:1/1;height:100%;padding:0;color:var(--text-color);fill:white;width:unset;max-width:unset;transform-origin:50% 50%}.knob.svelte-1pzoxsa.svelte-1pzoxsa:active{filter:invert(1);background:black}.knob.svelte-1pzoxsa svg{fill:white;width:100%;height:100%}.knob-container.svelte-1pzoxsa.svelte-1pzoxsa{box-sizing:border-box;-webkit-box-sizing:border-box;aspect-ratio:1/1;height:100%;display:flex;justify-content:center;align-items:center;margin-right:1rem;pointer-events:all;user-select:none;margin-bottom:auto;margin-top:auto;margin-right:0rem}.knob.svelte-1pzoxsa.svelte-1pzoxsa{cursor:pointer;display:block;aspect-ratio:1/1;height:100%;padding:0;color:var(--text-color);transform-origin:50% 50%}.knob.svelte-1pzoxsa.svelte-1pzoxsa:active{filter:invert(1);background:black}.knob.svelte-1pzoxsa svg{fill:white;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FsbGVyeVdpZGdldC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBOFhrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJHYWxsZXJ5V2lkZ2V0LnN2ZWx0ZSJdfQ== */");
}

function GalleryWidget_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[38] = list[i];
	child_ctx[40] = i;
	return child_ctx;
}

// (18:1) {#if $gallery_open}
function GalleryWidget_svelte_create_if_block(ctx) {
	let div27;
	let div26;
	let div2;
	let div0;
	let t1;
	let div1;
	let t2;
	let div13;
	let img;
	let img_src_value;
	let t3;
	let div12;
	let div5;
	let div3;
	let t5;
	let div4;
	let t6;
	let div8;
	let div6;
	let t8;
	let div7;
	let t9;
	let div11;
	let div9;
	let t10_value = /*format_time*/ ctx[15](/*current_project*/ ctx[0].id) + "";
	let t10;
	let t11;
	let div10;
	let t12;
	let div24;
	let div15;
	let div14;
	let t14;
	let html_tag;
	let t15;
	let div17;
	let div16;
	let t17;
	let html_tag_1;
	let t18;
	let div23;
	let div18;
	let t19;
	let div19;
	let t21;
	let div20;
	let t22_value = floor(/*resize_widget_canvas_size*/ ctx[13][0]) + "";
	let t22;
	let t23;
	let t24_value = floor(/*resize_widget_canvas_size*/ ctx[13][1]) + "";
	let t24;
	let t25;
	let div21;
	let div21_style_value;
	let t26;
	let div22;
	let div23_style_value;
	let t27;
	let button;
	let t29;
	let div25;
	let div27_intro;
	let mounted;
	let dispose;
	let each_value = ensure_array_like_dev(/*gallery_elements*/ ctx[12]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = GalleryWidget_svelte_create_each_block(GalleryWidget_svelte_get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div27 = dom_element("div");
			div26 = dom_element("div");
			div2 = dom_element("div");
			div0 = dom_element("div");
			div0.textContent = "Project";
			t1 = space();
			div1 = dom_element("div");
			t2 = space();
			div13 = dom_element("div");
			img = dom_element("img");
			t3 = space();
			div12 = dom_element("div");
			div5 = dom_element("div");
			div3 = dom_element("div");
			div3.textContent = "Save to dropbox";
			t5 = space();
			div4 = dom_element("div");
			t6 = space();
			div8 = dom_element("div");
			div6 = dom_element("div");
			div6.textContent = "Download";
			t8 = space();
			div7 = dom_element("div");
			t9 = space();
			div11 = dom_element("div");
			div9 = dom_element("div");
			t10 = dom_text(t10_value);
			t11 = space();
			div10 = dom_element("div");
			t12 = space();
			div24 = dom_element("div");
			div15 = dom_element("div");
			div14 = dom_element("div");
			div14.textContent = "New file";
			t14 = space();
			html_tag = new HtmlTag(false);
			t15 = space();
			div17 = dom_element("div");
			div16 = dom_element("div");
			div16.textContent = "Resize";
			t17 = space();
			html_tag_1 = new HtmlTag(false);
			t18 = space();
			div23 = dom_element("div");
			div18 = dom_element("div");
			t19 = space();
			div19 = dom_element("div");
			div19.textContent = "Resize canvas";
			t21 = space();
			div20 = dom_element("div");
			t22 = dom_text(t22_value);
			t23 = dom_text(" x ");
			t24 = dom_text(t24_value);
			t25 = space();
			div21 = dom_element("div");
			t26 = space();
			div22 = dom_element("div");
			t27 = space();
			button = dom_element("button");
			button.textContent = "LOG INTO DROPBOX";
			t29 = space();
			div25 = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div0, "id", "project-title");
			attr_dev(div0, "class", "svelte-1pzoxsa");
			add_location(div0, GalleryWidget_svelte_file, 21, 5, 574);
			attr_dev(div1, "id", "back-button");
			attr_dev(div1, "role", "button");
			attr_dev(div1, "tabindex", "0");
			attr_dev(div1, "class", "svelte-1pzoxsa");
			add_location(div1, GalleryWidget_svelte_file, 22, 5, 617);
			attr_dev(div2, "id", "top-bar");
			attr_dev(div2, "class", "svelte-1pzoxsa");
			add_location(div2, GalleryWidget_svelte_file, 20, 4, 550);
			if (!src_url_equal(img.src, img_src_value = /*canvas_image_src*/ ctx[9])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "id", "canvas-preview-img");
			attr_dev(img, "alt", "");
			attr_dev(img, "class", "svelte-1pzoxsa");
			add_location(img, GalleryWidget_svelte_file, 33, 5, 867);
			attr_dev(div3, "id", "project-save-button-title");
			attr_dev(div3, "class", "svelte-1pzoxsa");
			add_location(div3, GalleryWidget_svelte_file, 36, 7, 1059);
			attr_dev(div4, "class", "icon svelte-1pzoxsa");
			set_style(div4, "transform", "translate(0px,0.2rem)");
			add_location(div4, GalleryWidget_svelte_file, 37, 7, 1124);
			attr_dev(div5, "id", "project-save-button");
			attr_dev(div5, "role", "button");
			attr_dev(div5, "tabindex", "0");
			attr_dev(div5, "class", "svelte-1pzoxsa");
			add_location(div5, GalleryWidget_svelte_file, 35, 6, 967);
			attr_dev(div6, "id", "project-save-button-title");
			attr_dev(div6, "class", "svelte-1pzoxsa");
			add_location(div6, GalleryWidget_svelte_file, 50, 7, 1666);
			attr_dev(div7, "class", "icon svelte-1pzoxsa");
			set_style(div7, "transform", "scale(1.34)");
			add_location(div7, GalleryWidget_svelte_file, 51, 7, 1724);
			attr_dev(div8, "id", "project-save-button");
			attr_dev(div8, "role", "button");
			attr_dev(div8, "tabindex", "0");
			attr_dev(div8, "class", "svelte-1pzoxsa");
			add_location(div8, GalleryWidget_svelte_file, 49, 6, 1574);
			attr_dev(div9, "id", "project-save-button-title");
			attr_dev(div9, "class", "svelte-1pzoxsa");
			add_location(div9, GalleryWidget_svelte_file, 56, 7, 1888);
			attr_dev(div10, "class", "icon svelte-1pzoxsa");
			add_location(div10, GalleryWidget_svelte_file, 57, 7, 1971);
			attr_dev(div11, "id", "project-save-button");
			attr_dev(div11, "class", "date svelte-1pzoxsa");
			add_location(div11, GalleryWidget_svelte_file, 55, 6, 1837);
			attr_dev(div12, "id", "project-options");
			attr_dev(div12, "class", "svelte-1pzoxsa");
			add_location(div12, GalleryWidget_svelte_file, 34, 5, 934);
			attr_dev(div13, "id", "current-project");
			attr_dev(div13, "class", "svelte-1pzoxsa");
			add_location(div13, GalleryWidget_svelte_file, 32, 4, 835);
			attr_dev(div14, "class", "svelte-1pzoxsa");
			add_location(div14, GalleryWidget_svelte_file, 76, 6, 2470);
			html_tag.a = null;
			attr_dev(div15, "id", "button");
			attr_dev(div15, "role", "button");
			attr_dev(div15, "tabindex", "0");
			attr_dev(div15, "class", "svelte-1pzoxsa");
			add_location(div15, GalleryWidget_svelte_file, 65, 5, 2098);
			attr_dev(div16, "draggable", "false");
			attr_dev(div16, "class", "svelte-1pzoxsa");
			add_location(div16, GalleryWidget_svelte_file, 88, 6, 2806);
			html_tag_1.a = null;
			attr_dev(div17, "id", "button");
			attr_dev(div17, "role", "button");
			attr_dev(div17, "tabindex", "0");
			attr_dev(div17, "class", "svelte-1pzoxsa");
			add_location(div17, GalleryWidget_svelte_file, 81, 5, 2547);
			attr_dev(div18, "id", "back-button");
			attr_dev(div18, "role", "button");
			attr_dev(div18, "tabindex", "0");
			set_style(div18, "margin-bottom", "0.45rem");
			attr_dev(div18, "class", "svelte-1pzoxsa");
			add_location(div18, GalleryWidget_svelte_file, 94, 6, 2977);
			set_style(div19, "margin-bottom", "1rem");
			attr_dev(div19, "class", "svelte-1pzoxsa");
			add_location(div19, GalleryWidget_svelte_file, 104, 6, 3203);
			set_style(div20, "margin-bottom", "1rem");
			attr_dev(div20, "class", "svelte-1pzoxsa");
			add_location(div20, GalleryWidget_svelte_file, 107, 6, 3278);

			attr_dev(div21, "style", div21_style_value = `
							background: white;
							width: 10rem;
							aspect-ratio: 1/${/*resize_widget_canvas_size*/ ctx[13][1] / /*resize_widget_canvas_size*/ ctx[13][0]}
						`);

			attr_dev(div21, "class", "svelte-1pzoxsa");
			add_location(div21, GalleryWidget_svelte_file, 110, 6, 3419);
			attr_dev(div22, "role", "button");
			attr_dev(div22, "tabindex", "0");
			attr_dev(div22, "id", "back-button");
			attr_dev(div22, "class", "ok-button svelte-1pzoxsa");
			set_style(div22, "margin-top", "1.14rem");
			add_location(div22, GalleryWidget_svelte_file, 116, 6, 3638);
			attr_dev(div23, "id", "size-modal");
			attr_dev(div23, "style", div23_style_value = /*size_modal_opened*/ ctx[6] ? "" : "display: none;");
			attr_dev(div23, "class", "svelte-1pzoxsa");
			add_location(div23, GalleryWidget_svelte_file, 93, 5, 2899);
			attr_dev(div24, "id", "options-bar");
			attr_dev(div24, "class", "svelte-1pzoxsa");
			add_location(div24, GalleryWidget_svelte_file, 64, 4, 2070);
			attr_dev(button, "id", "db-login-button");
			attr_dev(button, "class", "svelte-1pzoxsa");
			toggle_class(button, "hide", /*authed*/ ctx[11]);
			add_location(button, GalleryWidget_svelte_file, 135, 4, 4256);
			attr_dev(div25, "id", "gallery-elements");
			attr_dev(div25, "class", "svelte-1pzoxsa");
			add_location(div25, GalleryWidget_svelte_file, 138, 4, 4392);
			attr_dev(div26, "id", "gallery-container");
			attr_dev(div26, "class", "svelte-1pzoxsa");
			add_location(div26, GalleryWidget_svelte_file, 19, 3, 517);
			attr_dev(div27, "id", "gallery-container-outer");
			attr_dev(div27, "class", "svelte-1pzoxsa");
			add_location(div27, GalleryWidget_svelte_file, 18, 2, 453);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div27, anchor);
			append_dev(div27, div26);
			append_dev(div26, div2);
			append_dev(div2, div0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			div1.innerHTML = (forbid_default());
			append_dev(div26, t2);
			append_dev(div26, div13);
			append_dev(div13, img);
			append_dev(div13, t3);
			append_dev(div13, div12);
			append_dev(div12, div5);
			append_dev(div5, div3);
			append_dev(div5, t5);
			append_dev(div5, div4);
			div4.innerHTML = (capture_default());
			append_dev(div12, t6);
			append_dev(div12, div8);
			append_dev(div8, div6);
			append_dev(div8, t8);
			append_dev(div8, div7);
			div7.innerHTML = (download_default());
			append_dev(div12, t9);
			append_dev(div12, div11);
			append_dev(div11, div9);
			append_dev(div9, t10);
			append_dev(div11, t11);
			append_dev(div11, div10);
			div10.innerHTML = (time_default());
			append_dev(div26, t12);
			append_dev(div26, div24);
			append_dev(div24, div15);
			append_dev(div15, div14);
			append_dev(div15, t14);
			html_tag.m((launch_default()), div15);
			append_dev(div24, t15);
			append_dev(div24, div17);
			append_dev(div17, div16);
			append_dev(div17, t17);
			html_tag_1.m((resize_default()), div17);
			append_dev(div24, t18);
			append_dev(div24, div23);
			append_dev(div23, div18);
			div18.innerHTML = (forbid_default());
			append_dev(div23, t19);
			append_dev(div23, div19);
			append_dev(div23, t21);
			append_dev(div23, div20);
			append_dev(div20, t22);
			append_dev(div20, t23);
			append_dev(div20, t24);
			append_dev(div23, t25);
			append_dev(div23, div21);
			append_dev(div23, t26);
			append_dev(div23, div22);
			div22.innerHTML = (ok_default());
			append_dev(div26, t27);
			append_dev(div26, button);
			append_dev(div26, t29);
			append_dev(div26, div25);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div25, null);
				}
			}

			if (!mounted) {
				dispose = [
					listen_dev(div1, "click", /*click_handler_1*/ ctx[22], false, false, false, false),
					listen_dev(div5, "click", /*save_to_dropbox*/ ctx[18], false, false, false, false),
					listen_dev(div8, "click", /*download_image*/ ctx[17], false, false, false, false),
					listen_dev(div15, "click", /*click_handler_2*/ ctx[23], false, false, false, false),
					listen_dev(div17, "click", /*click_handler_3*/ ctx[24], false, false, false, false),
					listen_dev(div18, "click", /*click_handler_4*/ ctx[25], false, false, false, false),
					listen_dev(div21, "pointerdown", /*resize_widget_pointer_down*/ ctx[19], false, false, false, false),
					listen_dev(div22, "click", /*click_handler_5*/ ctx[26], false, false, false, false),
					listen_dev(button, "click", /*click_handler_6*/ ctx[27], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*canvas_image_src*/ 512 && !src_url_equal(img.src, img_src_value = /*canvas_image_src*/ ctx[9])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*current_project*/ 1 && t10_value !== (t10_value = /*format_time*/ ctx[15](/*current_project*/ ctx[0].id) + "")) set_data_dev(t10, t10_value);
			if (dirty[0] & /*resize_widget_canvas_size*/ 8192 && t22_value !== (t22_value = floor(/*resize_widget_canvas_size*/ ctx[13][0]) + "")) set_data_dev(t22, t22_value);
			if (dirty[0] & /*resize_widget_canvas_size*/ 8192 && t24_value !== (t24_value = floor(/*resize_widget_canvas_size*/ ctx[13][1]) + "")) set_data_dev(t24, t24_value);

			if (dirty[0] & /*resize_widget_canvas_size*/ 8192 && div21_style_value !== (div21_style_value = `
							background: white;
							width: 10rem;
							aspect-ratio: 1/${/*resize_widget_canvas_size*/ ctx[13][1] / /*resize_widget_canvas_size*/ ctx[13][0]}
						`)) {
				attr_dev(div21, "style", div21_style_value);
			}

			if (dirty[0] & /*size_modal_opened*/ 64 && div23_style_value !== (div23_style_value = /*size_modal_opened*/ ctx[6] ? "" : "display: none;")) {
				attr_dev(div23, "style", div23_style_value);
			}

			if (dirty[0] & /*authed*/ 2048) {
				toggle_class(button, "hide", /*authed*/ ctx[11]);
			}

			if (dirty[0] & /*gallery_elements, current_project, is_safe_to_switch_to_new_project, dbx, load_project, format_time*/ 37937) {
				each_value = ensure_array_like_dev(/*gallery_elements*/ ctx[12]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = GalleryWidget_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = GalleryWidget_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div25, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (local) {
				if (!div27_intro) {
					scheduler_add_render_callback(() => {
						div27_intro = create_in_transition(div27, fade, { duration: 200 });
						div27_intro.start();
					});
				}
			}
		},
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div27);
			}

			destroy_each(each_blocks, detaching);
			mounted = false;
			utils_run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: GalleryWidget_svelte_create_if_block.name,
		type: "if",
		source: "(18:1) {#if $gallery_open}",
		ctx
	});

	return block;
}

// (140:5) {#each gallery_elements as element, i}
function GalleryWidget_svelte_create_each_block(ctx) {
	let div1;
	let div0;
	let t0_value = /*format_time*/ ctx[15](/*element*/ ctx[38].name) + "";
	let t0;
	let t1;
	let img;
	let img_src_value;
	let t2;
	let div1_style_value;
	let mounted;
	let dispose;

	function click_handler_7() {
		return /*click_handler_7*/ ctx[28](/*element*/ ctx[38]);
	}

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			t0 = dom_text(t0_value);
			t1 = space();
			img = dom_element("img");
			t2 = space();
			attr_dev(div0, "id", "element-name");
			attr_dev(div0, "class", "svelte-1pzoxsa");
			add_location(div0, GalleryWidget_svelte_file, 159, 7, 5216);
			attr_dev(img, "draggable", "false");
			if (!src_url_equal(img.src, img_src_value = /*element*/ ctx[38].image_src)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "id", "canvas-preview-img");
			attr_dev(img, "alt", "");
			attr_dev(img, "class", "svelte-1pzoxsa");
			add_location(img, GalleryWidget_svelte_file, 162, 7, 5297);
			attr_dev(div1, "id", "element");
			attr_dev(div1, "role", "button");
			attr_dev(div1, "tabindex", "0");

			attr_dev(div1, "style", div1_style_value = Number(/*element*/ ctx[38].name) === /*current_project*/ ctx[0].id
			? "border: 0.1rem solid white;"
			: "");

			attr_dev(div1, "class", "svelte-1pzoxsa");
			add_location(div1, GalleryWidget_svelte_file, 140, 6, 4470);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t0);
			append_dev(div1, t1);
			append_dev(div1, img);
			append_dev(div1, t2);

			if (!mounted) {
				dispose = listen_dev(div1, "click", click_handler_7, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*gallery_elements*/ 4096 && t0_value !== (t0_value = /*format_time*/ ctx[15](/*element*/ ctx[38].name) + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*gallery_elements*/ 4096 && !src_url_equal(img.src, img_src_value = /*element*/ ctx[38].image_src)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*gallery_elements, current_project*/ 4097 && div1_style_value !== (div1_style_value = Number(/*element*/ ctx[38].name) === /*current_project*/ ctx[0].id
			? "border: 0.1rem solid white;"
			: "")) {
				attr_dev(div1, "style", div1_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: GalleryWidget_svelte_create_each_block.name,
		type: "each",
		source: "(140:5) {#each gallery_elements as element, i}",
		ctx
	});

	return block;
}

function GalleryWidget_svelte_create_fragment(ctx) {
	let div1;
	let div0;
	let t;
	let mounted;
	let dispose;
	let if_block = /*$gallery_open*/ ctx[14] && GalleryWidget_svelte_create_if_block(ctx);

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			t = space();
			if (if_block) if_block.c();
			attr_dev(div0, "class", "knob svelte-1pzoxsa");
			attr_dev(div0, "role", "button");
			attr_dev(div0, "tabindex", "0");
			add_location(div0, GalleryWidget_svelte_file, 3, 1, 60);
			attr_dev(div1, "class", "knob-container svelte-1pzoxsa");
			add_location(div1, GalleryWidget_svelte_file, 2, 0, 30);
		},
		l: function claim(nodes) {
			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			div0.innerHTML = (solve_default());
			append_dev(div1, t);
			if (if_block) if_block.m(div1, null);

			if (!mounted) {
				dispose = listen_dev(div0, "click", /*click_handler*/ ctx[21], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*$gallery_open*/ ctx[14]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*$gallery_open*/ 16384) {
						transitions_transition_in(if_block, 1);
					}
				} else {
					if_block = GalleryWidget_svelte_create_if_block(ctx);
					if_block.c();
					transitions_transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			transitions_transition_in(if_block);
		},
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: GalleryWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const resize_widget_pixel_range = 200;
const GalleryWidget_svelte_min = 0;
const GalleryWidget_svelte_max = 4;

function GalleryWidget_svelte_instance($$self, $$props, $$invalidate) {
	let valueRange;
	let $gallery_open;
	validate_store(gallery_open, 'gallery_open');
	component_subscribe($$self, gallery_open, $$value => $$invalidate(14, $gallery_open = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('GalleryWidget', slots, []);
	let { current_project } = $$props;
	let { get_current_canvas_as_image } = $$props;
	let { resize_project } = $$props;
	let { new_project } = $$props;
	let { load_project } = $$props;
	let { project_has_been_modified } = $$props;

	const format_time = t => {
		return new Date(Number(t)).toLocaleString('en-GB', {
			hourCycle: 'h23',
			day: "2-digit",
			month: "2-digit",
			year: "numeric",
			hour: "2-digit",
			minute: "2-digit"
		}).replace(',', '');
	};

	let size_modal_opened = false;
	let canvas_image = undefined;
	let canvas_image_blob = undefined;
	let canvas_image_src = '';

	class Element {
		name;
		image_src;

		constructor(name, image_src) {
			this.name = name;
			this.image_src = image_src;
		}
	}

	let dbx;
	const dbx_auther = new DropboxAuther();
	let authed = false;
	let gallery_elements = [];

	const log_into_dropbox = async () => {
		await dbx_auther.doAuth();
	};

	const is_safe_to_switch_to_new_project = async () => {
		let project_is_saved_to_dropbox = false;

		if (!dbx_auther.authed) {
			project_is_saved_to_dropbox = true;
		} else {
			let response = await dbx.filesListFolder({ path: '' });

			for (let element of response.result.entries) {
				let proj_name = Number(element.name.slice(0, -5));

				if (proj_name === current_project.id) {
					project_is_saved_to_dropbox = true;
					break;
				}
			}
		}

		if (project_has_been_modified || !project_is_saved_to_dropbox) {
			return false;
		} else {
			return true;
		}
	};

	const download_image = async () => {
		const link = document.createElement('a');
		link.href = canvas_image.src;
		link.download = current_project.id + '.png';
		link.click();
	};

	const refetch_canvases = async () => {
		let response = await dbx.filesListFolder({ path: '' });
		console.log(response);
		$$invalidate(12, gallery_elements = []);

		for (let element of response.result.entries) {
			if (element.name.endsWith(".json")) {
				let proj_name = element.name.slice(0, -5);
				let image = await dbx.filesDownload({ path: '/' + proj_name + '.png' });
				let binary = image.result.fileBlob;

				const blobToDataURL = blob => {
					return new Promise((resolve, reject) => {
							const reader = new FileReader();
							reader.onload = _e => resolve(reader.result);
							reader.onerror = _e => reject(reader.error);
							reader.onabort = _e => reject(new Error("Read aborted"));
							reader.readAsDataURL(blob);
						});
				};

				$$invalidate(12, gallery_elements = [...gallery_elements, new Element(proj_name, await blobToDataURL(binary))]);
			}
		}
	};

	const save_to_dropbox = async () => {
		floating_modal_message.set("Starting upload to dropbox.");

		let r = await dbx.filesUpload({
			path: '/' + current_project.id + '.json',
			contents: JSON.stringify(current_project),
			mode: "overwrite"
		});

		r = await dbx.filesUpload({
			path: '/' + current_project.id + '.png',
			contents: await (await fetch(canvas_image.src)).blob(),
			mode: "overwrite"
		});

		floating_modal_message.set("Upload to dropbox succesful.");
		$$invalidate(20, project_has_been_modified = false);
		await refetch_canvases();
	};

	let resize_widget_canvas_size = [0, 0];
	let resize_widget_start_y = 0;
	let resize_wdiget_start_value = [0, 0];
	let resize_widget_start_x = 0;

	function resize_widget_pointer_move({ clientX, clientY }) {
		let valueDiffY = valueRange * (resize_widget_start_y - clientY) / resize_widget_pixel_range;
		let valueDiffX = valueRange * (resize_widget_start_x - clientX) / resize_widget_pixel_range;
		$$invalidate(13, resize_widget_canvas_size[0] = resize_wdiget_start_value[0] - valueDiffX * 1000, resize_widget_canvas_size);
		$$invalidate(13, resize_widget_canvas_size[1] = resize_wdiget_start_value[1] + valueDiffY * 1000, resize_widget_canvas_size);
	}

	function resize_widget_pointer_down(e) {
		let { clientX, clientY } = e;
		console.log('down');
		resize_widget_start_y = clientY;
		resize_widget_start_x = clientX;
		resize_wdiget_start_value = [...resize_widget_canvas_size];
		window.addEventListener('pointermove', resize_widget_pointer_move);
		window.addEventListener('pointerup', resize_widget_pointer_up);
		e.stopPropagation();
	}

	function resize_widget_pointer_up() {
		window.removeEventListener('pointermove', resize_widget_pointer_move);
		window.removeEventListener('pointerup', resize_widget_pointer_up);
	}

	onMount(async () => {
		await dbx_auther.init();
		await dbx_auther.try_init_dropbox();
		$$invalidate(11, authed = dbx_auther.authed);
		$$invalidate(10, dbx = dbx_auther.dbx);

		if (authed) {
			refetch_canvases();
		}
	});

	$$self.$$.on_mount.push(function () {
		if (current_project === undefined && !('current_project' in $$props || $$self.$$.bound[$$self.$$.props['current_project']])) {
			console_1.warn("<GalleryWidget> was created without expected prop 'current_project'");
		}

		if (get_current_canvas_as_image === undefined && !('get_current_canvas_as_image' in $$props || $$self.$$.bound[$$self.$$.props['get_current_canvas_as_image']])) {
			console_1.warn("<GalleryWidget> was created without expected prop 'get_current_canvas_as_image'");
		}

		if (resize_project === undefined && !('resize_project' in $$props || $$self.$$.bound[$$self.$$.props['resize_project']])) {
			console_1.warn("<GalleryWidget> was created without expected prop 'resize_project'");
		}

		if (new_project === undefined && !('new_project' in $$props || $$self.$$.bound[$$self.$$.props['new_project']])) {
			console_1.warn("<GalleryWidget> was created without expected prop 'new_project'");
		}

		if (load_project === undefined && !('load_project' in $$props || $$self.$$.bound[$$self.$$.props['load_project']])) {
			console_1.warn("<GalleryWidget> was created without expected prop 'load_project'");
		}

		if (project_has_been_modified === undefined && !('project_has_been_modified' in $$props || $$self.$$.bound[$$self.$$.props['project_has_been_modified']])) {
			console_1.warn("<GalleryWidget> was created without expected prop 'project_has_been_modified'");
		}
	});

	const writable_props = [
		'current_project',
		'get_current_canvas_as_image',
		'resize_project',
		'new_project',
		'load_project',
		'project_has_been_modified'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<GalleryWidget> was created with unknown prop '${key}'`);
	});

	const click_handler = async () => {
		// gallery_open = !gallery_open
		gallery_open.set(true);

		let [_canvas_image, blob] = await get_current_canvas_as_image();
		$$invalidate(7, canvas_image = _canvas_image);
		$$invalidate(9, canvas_image_src = canvas_image.src);
		$$invalidate(8, canvas_image_blob = blob);
		console.log(canvas_image.src);
	};

	const click_handler_1 = () => {
		// gallery_open = !gallery_open
		gallery_open.set(false);
	};

	const click_handler_2 = async () => {
		let safe = await is_safe_to_switch_to_new_project();

		safe = safe
		? safe
		: confirm('Are you sure you want to create another project? This one is not saved.');

		if (safe) {
			new_project();

			// gallery_open = false
			gallery_open.set(false);
		}
	};

	const click_handler_3 = async () => {
		$$invalidate(6, size_modal_opened = true);
		$$invalidate(13, resize_widget_canvas_size[0] = current_project.canvasRes[0], resize_widget_canvas_size);
		$$invalidate(13, resize_widget_canvas_size[1] = current_project.canvasRes[1], resize_widget_canvas_size);
	};

	const click_handler_4 = () => {
		$$invalidate(6, size_modal_opened = false);
	};

	const click_handler_5 = () => {
		$$invalidate(13, resize_widget_canvas_size[0] = floor(resize_widget_canvas_size[0]), resize_widget_canvas_size);
		$$invalidate(13, resize_widget_canvas_size[1] = floor(resize_widget_canvas_size[1]), resize_widget_canvas_size);
		resize_project(resize_widget_canvas_size);
		$$invalidate(6, size_modal_opened = false);

		// gallery_open = false
		gallery_open.set(false);
	};

	const click_handler_6 = async () => await log_into_dropbox();

	const click_handler_7 = async element => {
		let safe = await is_safe_to_switch_to_new_project();

		safe = safe
		? safe
		: confirm('Are you sure you want to switch to another project? This one is not saved.');

		if (safe) {
			let proj = await dbx.filesDownload({ path: '/' + element.name + '.json' });

			// @ts-ignore
			let binary = await proj.result.fileBlob.text();

			let binary_json = JSON.parse(binary);
			load_project(binary_json);

			// gallery_open = false
			gallery_open.set(false);
		}
	};

	$$self.$$set = $$props => {
		if ('current_project' in $$props) $$invalidate(0, current_project = $$props.current_project);
		if ('get_current_canvas_as_image' in $$props) $$invalidate(1, get_current_canvas_as_image = $$props.get_current_canvas_as_image);
		if ('resize_project' in $$props) $$invalidate(2, resize_project = $$props.resize_project);
		if ('new_project' in $$props) $$invalidate(3, new_project = $$props.new_project);
		if ('load_project' in $$props) $$invalidate(4, load_project = $$props.load_project);
		if ('project_has_been_modified' in $$props) $$invalidate(20, project_has_been_modified = $$props.project_has_been_modified);
	};

	$$self.$capture_state = () => ({
		solveIcon: (solve_default()),
		launchIcon: (launch_default()),
		resizeIcon: (resize_default()),
		forbidIcon: (forbid_default()),
		okIcon: (ok_default()),
		captureIcon: (capture_default()),
		downloadIcon: (download_default()),
		timeIcon: (time_default()),
		Dropbox: Dropbox_sdk_min.Dropbox,
		DropboxAuth: Dropbox_sdk_min.DropboxAuth,
		onMount: onMount,
		DropboxAuther: DropboxAuther,
		floating_modal_message: floating_modal_message,
		gallery_open: gallery_open,
		fade: fade,
		floor: floor,
		current_project,
		get_current_canvas_as_image,
		resize_project,
		new_project,
		load_project,
		project_has_been_modified,
		format_time,
		size_modal_opened,
		canvas_image,
		canvas_image_blob,
		canvas_image_src,
		Element,
		dbx,
		dbx_auther,
		authed,
		gallery_elements,
		log_into_dropbox,
		is_safe_to_switch_to_new_project,
		download_image,
		refetch_canvases,
		save_to_dropbox,
		resize_widget_pixel_range,
		min: GalleryWidget_svelte_min,
		max: GalleryWidget_svelte_max,
		resize_widget_canvas_size,
		resize_widget_start_y,
		resize_wdiget_start_value,
		resize_widget_start_x,
		resize_widget_pointer_move,
		resize_widget_pointer_down,
		resize_widget_pointer_up,
		valueRange,
		$gallery_open
	});

	$$self.$inject_state = $$props => {
		if ('current_project' in $$props) $$invalidate(0, current_project = $$props.current_project);
		if ('get_current_canvas_as_image' in $$props) $$invalidate(1, get_current_canvas_as_image = $$props.get_current_canvas_as_image);
		if ('resize_project' in $$props) $$invalidate(2, resize_project = $$props.resize_project);
		if ('new_project' in $$props) $$invalidate(3, new_project = $$props.new_project);
		if ('load_project' in $$props) $$invalidate(4, load_project = $$props.load_project);
		if ('project_has_been_modified' in $$props) $$invalidate(20, project_has_been_modified = $$props.project_has_been_modified);
		if ('size_modal_opened' in $$props) $$invalidate(6, size_modal_opened = $$props.size_modal_opened);
		if ('canvas_image' in $$props) $$invalidate(7, canvas_image = $$props.canvas_image);
		if ('canvas_image_blob' in $$props) $$invalidate(8, canvas_image_blob = $$props.canvas_image_blob);
		if ('canvas_image_src' in $$props) $$invalidate(9, canvas_image_src = $$props.canvas_image_src);
		if ('dbx' in $$props) $$invalidate(10, dbx = $$props.dbx);
		if ('authed' in $$props) $$invalidate(11, authed = $$props.authed);
		if ('gallery_elements' in $$props) $$invalidate(12, gallery_elements = $$props.gallery_elements);
		if ('resize_widget_canvas_size' in $$props) $$invalidate(13, resize_widget_canvas_size = $$props.resize_widget_canvas_size);
		if ('resize_widget_start_y' in $$props) resize_widget_start_y = $$props.resize_widget_start_y;
		if ('resize_wdiget_start_value' in $$props) resize_wdiget_start_value = $$props.resize_wdiget_start_value;
		if ('resize_widget_start_x' in $$props) resize_widget_start_x = $$props.resize_widget_start_x;
		if ('valueRange' in $$props) valueRange = $$props.valueRange;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$: valueRange = GalleryWidget_svelte_max - GalleryWidget_svelte_min;

	return [
		current_project,
		get_current_canvas_as_image,
		resize_project,
		new_project,
		load_project,
		is_safe_to_switch_to_new_project,
		size_modal_opened,
		canvas_image,
		canvas_image_blob,
		canvas_image_src,
		dbx,
		authed,
		gallery_elements,
		resize_widget_canvas_size,
		$gallery_open,
		format_time,
		log_into_dropbox,
		download_image,
		save_to_dropbox,
		resize_widget_pointer_down,
		project_has_been_modified,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		click_handler_7
	];
}

class GalleryWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			GalleryWidget_svelte_instance,
			GalleryWidget_svelte_create_fragment,
			safe_not_equal,
			{
				current_project: 0,
				get_current_canvas_as_image: 1,
				resize_project: 2,
				new_project: 3,
				load_project: 4,
				project_has_been_modified: 20,
				is_safe_to_switch_to_new_project: 5
			},
			GalleryWidget_svelte_add_css,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GalleryWidget",
			options,
			id: GalleryWidget_svelte_create_fragment.name
		});
	}

	get current_project() {
		return this.$$.ctx[0];
	}

	set current_project(current_project) {
		this.$$set({ current_project });
		scheduler_flush();
	}

	get get_current_canvas_as_image() {
		return this.$$.ctx[1];
	}

	set get_current_canvas_as_image(get_current_canvas_as_image) {
		this.$$set({ get_current_canvas_as_image });
		scheduler_flush();
	}

	get resize_project() {
		return this.$$.ctx[2];
	}

	set resize_project(resize_project) {
		this.$$set({ resize_project });
		scheduler_flush();
	}

	get new_project() {
		return this.$$.ctx[3];
	}

	set new_project(new_project) {
		this.$$set({ new_project });
		scheduler_flush();
	}

	get load_project() {
		return this.$$.ctx[4];
	}

	set load_project(load_project) {
		this.$$set({ load_project });
		scheduler_flush();
	}

	get project_has_been_modified() {
		return this.$$.ctx[20];
	}

	set project_has_been_modified(project_has_been_modified) {
		this.$$set({ project_has_been_modified });
		scheduler_flush();
	}

	get is_safe_to_switch_to_new_project() {
		return this.$$.ctx[5];
	}

	set is_safe_to_switch_to_new_project(value) {
		throw new Error_1("<GalleryWidget>: Cannot set read-only property 'is_safe_to_switch_to_new_project'");
	}
}

/* harmony default export */ const GalleryWidget_svelte = (GalleryWidget);
;// CONCATENATED MODULE: ./src/components/FloatingModal.svelte
/* src/components/FloatingModal.svelte generated by Svelte v4.0.1 */




const FloatingModal_svelte_file = "src/components/FloatingModal.svelte";

function FloatingModal_svelte_add_css(target) {
	append_styles(target, "svelte-mamaeg", ".svelte-mamaeg.svelte-mamaeg{pointer-events:none}#floating-modal.svelte-mamaeg.svelte-mamaeg{position:fixed;width:fit-content;height:fit-content;top:50%;left:50%;transform:translate(-50%, -50%);z-index:100}#floating-modal.svelte-mamaeg #text.svelte-mamaeg{backdrop-filter:blur(0.3rem) invert(0.3);padding:1rem;border-radius:0.5rem;pointer-events:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmxvYXRpbmdNb2RhbC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBMkNrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJGbG9hdGluZ01vZGFsLnN2ZWx0ZSJdfQ== */");
}

function FloatingModal_svelte_create_fragment(ctx) {
	let div1;
	let div0;
	let t;
	let div0_style_value;

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			t = dom_text(/*displayed_message*/ ctx[0]);
			attr_dev(div0, "id", "text");

			attr_dev(div0, "style", div0_style_value = `opacity: ${/*opacity*/ ctx[2]};
    transition: opacity ${/*fading_in*/ ctx[1] ? fade_in_t : fade_out_t}s;`);

			attr_dev(div0, "class", "svelte-mamaeg");
			add_location(div0, FloatingModal_svelte_file, 34, 3, 750);
			attr_dev(div1, "id", "floating-modal");
			attr_dev(div1, "class", "svelte-mamaeg");
			add_location(div1, FloatingModal_svelte_file, 33, 2, 721);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*displayed_message*/ 1) set_data_dev(t, /*displayed_message*/ ctx[0]);

			if (dirty & /*opacity, fading_in*/ 6 && div0_style_value !== (div0_style_value = `opacity: ${/*opacity*/ ctx[2]};
    transition: opacity ${/*fading_in*/ ctx[1] ? fade_in_t : fade_out_t}s;`)) {
				attr_dev(div0, "style", div0_style_value);
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: FloatingModal_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const display_time = 1;
const fade_in_t = 0.2;
const fade_out_t = 1;

function FloatingModal_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FloatingModal', slots, []);
	let displayed_message = undefined;
	let fading_in = true;
	let opacity = 0;

	floating_modal_message.subscribe(message => {
		if (message) {
			$$invalidate(0, displayed_message = message);
			$$invalidate(2, opacity = 1);
			$$invalidate(1, fading_in = true);

			setTimeout(
				() => {
					$$invalidate(2, opacity = 0);
					$$invalidate(1, fading_in = false);

					setTimeout(
						() => {
							$$invalidate(0, displayed_message = undefined);
						},
						fade_out_t * 1000
					);
				},
				display_time * 1000
			);

			floating_modal_message.set(undefined);
		}
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FloatingModal> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		floating_modal_message: floating_modal_message,
		displayed_message,
		display_time,
		fade_in_t,
		fade_out_t,
		fading_in,
		opacity
	});

	$$self.$inject_state = $$props => {
		if ('displayed_message' in $$props) $$invalidate(0, displayed_message = $$props.displayed_message);
		if ('fading_in' in $$props) $$invalidate(1, fading_in = $$props.fading_in);
		if ('opacity' in $$props) $$invalidate(2, opacity = $$props.opacity);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [displayed_message, fading_in, opacity];
}

class FloatingModal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, FloatingModal_svelte_instance, FloatingModal_svelte_create_fragment, safe_not_equal, {}, FloatingModal_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FloatingModal",
			options,
			id: FloatingModal_svelte_create_fragment.name
		});
	}
}

/* harmony default export */ const FloatingModal_svelte = (FloatingModal);
// EXTERNAL MODULE: ./public/plug.svg
var plug = __webpack_require__(6801);
var plug_default = /*#__PURE__*/__webpack_require__.n(plug);
;// CONCATENATED MODULE: ./src/components/PickColourWidget.svelte
/* src/components/PickColourWidget.svelte generated by Svelte v4.0.1 */




const PickColourWidget_svelte_file = "src/components/PickColourWidget.svelte";

function PickColourWidget_svelte_add_css(target) {
	append_styles(target, "svelte-1am3xlt", ".picking.svelte-1am3xlt{filter:invert(1);background:black}.knob-container.svelte-1am3xlt{cursor:pointer;aspect-ratio:1/1;height:100%;margin-left:0.5rem;margin-right:0.5rem;margin-bottom:auto;margin-top:auto;pointer-events:all;user-select:none;width:unset}.knob-container.svelte-1am3xlt:hover{cursor:pointer}.knob.svelte-1am3xlt{display:block;aspect-ratio:1/1;height:100%;padding:0;color:var(--text-color);fill:white;width:unset;max-width:unset;transform-origin:50% 50%}.knob.svelte-1am3xlt:active{filter:invert(1);background:black}.knob.svelte-1am3xlt svg{fill:white;width:100%;height:100%}.knob-container.svelte-1am3xlt{z-index:0 !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGlja0NvbG91cldpZGdldC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBc0NrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJQaWNrQ29sb3VyV2lkZ2V0LnN2ZWx0ZSJdfQ== */");
}

function PickColourWidget_svelte_create_fragment(ctx) {
	let div1;
	let div0;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			attr_dev(div0, "class", "knob svelte-1am3xlt");
			toggle_class(div0, "picking", /*picking*/ ctx[0]);
			add_location(div0, PickColourWidget_svelte_file, 3, 1, 115);
			attr_dev(div1, "class", "knob-container svelte-1am3xlt");
			add_location(div1, PickColourWidget_svelte_file, 2, 0, 30);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			div0.innerHTML = (plug_default());
			/*div1_binding*/ ctx[5](div1);

			if (!mounted) {
				dispose = listen_dev(div1, "pointerdown", /*pointerDown*/ ctx[2], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*picking*/ 1) {
				toggle_class(div0, "picking", /*picking*/ ctx[0]);
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			/*div1_binding*/ ctx[5](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: PickColourWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function PickColourWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PickColourWidget', slots, []);
	let { pick_from_canvas } = $$props;
	let pickerElement;
	let { picking = false } = $$props;
	let { just_finished_pick = false } = $$props;

	function pointerMove({ clientX, clientY }) {
		pick_from_canvas();
	}

	const pointerUp = () => {
		$$invalidate(0, picking = false);
		$$invalidate(3, just_finished_pick = true);
		window.removeEventListener('pointermove', pointerMove);
		window.removeEventListener('pointerup', pointerUp);
	};

	const pointerDown = e => {
		$$invalidate(0, picking = true);
		window.addEventListener('pointermove', pointerMove);
		window.addEventListener('pointerup', pointerUp);
		e.stopPropagation();
	};

	$$self.$$.on_mount.push(function () {
		if (pick_from_canvas === undefined && !('pick_from_canvas' in $$props || $$self.$$.bound[$$self.$$.props['pick_from_canvas']])) {
			console.warn("<PickColourWidget> was created without expected prop 'pick_from_canvas'");
		}
	});

	const writable_props = ['pick_from_canvas', 'picking', 'just_finished_pick'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PickColourWidget> was created with unknown prop '${key}'`);
	});

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			pickerElement = $$value;
			$$invalidate(1, pickerElement);
		});
	}

	$$self.$$set = $$props => {
		if ('pick_from_canvas' in $$props) $$invalidate(4, pick_from_canvas = $$props.pick_from_canvas);
		if ('picking' in $$props) $$invalidate(0, picking = $$props.picking);
		if ('just_finished_pick' in $$props) $$invalidate(3, just_finished_pick = $$props.just_finished_pick);
	};

	$$self.$capture_state = () => ({
		pickIcon: (plug_default()),
		pick_from_canvas,
		pickerElement,
		picking,
		just_finished_pick,
		pointerMove,
		pointerUp,
		pointerDown
	});

	$$self.$inject_state = $$props => {
		if ('pick_from_canvas' in $$props) $$invalidate(4, pick_from_canvas = $$props.pick_from_canvas);
		if ('pickerElement' in $$props) $$invalidate(1, pickerElement = $$props.pickerElement);
		if ('picking' in $$props) $$invalidate(0, picking = $$props.picking);
		if ('just_finished_pick' in $$props) $$invalidate(3, just_finished_pick = $$props.just_finished_pick);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		picking,
		pickerElement,
		pointerDown,
		just_finished_pick,
		pick_from_canvas,
		div1_binding
	];
}

class PickColourWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			PickColourWidget_svelte_instance,
			PickColourWidget_svelte_create_fragment,
			safe_not_equal,
			{
				pick_from_canvas: 4,
				picking: 0,
				just_finished_pick: 3
			},
			PickColourWidget_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PickColourWidget",
			options,
			id: PickColourWidget_svelte_create_fragment.name
		});
	}

	get pick_from_canvas() {
		return this.$$.ctx[4];
	}

	set pick_from_canvas(pick_from_canvas) {
		this.$$set({ pick_from_canvas });
		scheduler_flush();
	}

	get picking() {
		return this.$$.ctx[0];
	}

	set picking(picking) {
		this.$$set({ picking });
		scheduler_flush();
	}

	get just_finished_pick() {
		return this.$$.ctx[3];
	}

	set just_finished_pick(just_finished_pick) {
		this.$$set({ just_finished_pick });
		scheduler_flush();
	}
}

/* harmony default export */ const PickColourWidget_svelte = (PickColourWidget);
;// CONCATENATED MODULE: ./src/components/TextureWidget.svelte
/* src/components/TextureWidget.svelte generated by Svelte v4.0.1 */



const TextureWidget_svelte_file = "src/components/TextureWidget.svelte";

function TextureWidget_svelte_add_css(target) {
	append_styles(target, "svelte-1u541fl", "img.svelte-1u541fl.svelte-1u541fl.svelte-1u541fl:active{filter:invert(1);background:black}.knob-container-container.svelte-1u541fl.svelte-1u541fl.svelte-1u541fl{z-index:99;aspect-ratio:1/1;margin-bottom:auto;margin-top:auto;margin-right:1.5rem;display:block;flex-direction:column;justify-content:center;align-items:center;pointer-events:all;user-select:none;cursor:pointer;min-width:7rem;border:1px solid white;min-width:0px;aspect-ratio:1/1;height:100%}.knob-container-container.svelte-1u541fl #dropdown.svelte-1u541fl.svelte-1u541fl{display:flex;flex-direction:column;position:static;height:unset;background:black}.knob-container-container.svelte-1u541fl #dropdown.svelte-1u541fl>img.svelte-1u541fl{z-index:10000000;aspect-ratio:1/1;width:100%}.knob-container-container.svelte-1u541fl>img.svelte-1u541fl.svelte-1u541fl{aspect-ratio:1/1;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dHVyZVdpZGdldC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBa0NrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUZXh0dXJlV2lkZ2V0LnN2ZWx0ZSJdfQ== */");
}

function TextureWidget_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[7] = i;
	return child_ctx;
}

// (9:1) {#if dropdown_toggled}
function TextureWidget_svelte_create_if_block(ctx) {
	let div;
	let each_value = ensure_array_like_dev(/*brush_textures*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = TextureWidget_svelte_create_each_block(TextureWidget_svelte_get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "id", "dropdown");
			attr_dev(div, "class", "svelte-1u541fl");
			add_location(div, TextureWidget_svelte_file, 9, 2, 235);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*brush_textures, selected_brush_texture, dropdown_toggled*/ 7) {
				each_value = ensure_array_like_dev(/*brush_textures*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = TextureWidget_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = TextureWidget_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: TextureWidget_svelte_create_if_block.name,
		type: "if",
		source: "(9:1) {#if dropdown_toggled}",
		ctx
	});

	return block;
}

// (12:4) {#if texture !== selected_brush_texture}
function create_if_block_1(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[4](/*texture*/ ctx[5]);
	}

	const block = {
		c: function create() {
			img = dom_element("img");
			if (!src_url_equal(img.src, img_src_value = /*texture*/ ctx[5].path)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "class", "svelte-1u541fl");
			add_location(img, TextureWidget_svelte_file, 12, 5, 345);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);

			if (!mounted) {
				dispose = listen_dev(img, "click", click_handler_1, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*brush_textures*/ 2 && !src_url_equal(img.src, img_src_value = /*texture*/ ctx[5].path)) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(12:4) {#if texture !== selected_brush_texture}",
		ctx
	});

	return block;
}

// (11:3) {#each brush_textures as texture, i}
function TextureWidget_svelte_create_each_block(ctx) {
	let if_block_anchor;
	let if_block = /*texture*/ ctx[5] !== /*selected_brush_texture*/ ctx[0] && create_if_block_1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*texture*/ ctx[5] !== /*selected_brush_texture*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: TextureWidget_svelte_create_each_block.name,
		type: "each",
		source: "(11:3) {#each brush_textures as texture, i}",
		ctx
	});

	return block;
}

function TextureWidget_svelte_create_fragment(ctx) {
	let div;
	let img;
	let img_src_value;
	let t;
	let mounted;
	let dispose;
	let if_block = /*dropdown_toggled*/ ctx[2] && TextureWidget_svelte_create_if_block(ctx);

	const block = {
		c: function create() {
			div = dom_element("div");
			img = dom_element("img");
			t = space();
			if (if_block) if_block.c();

			if (!src_url_equal(img.src, img_src_value = /*selected_brush_texture*/ ctx[0]
			? /*selected_brush_texture*/ ctx[0].path
			: '')) attr_dev(img, "src", img_src_value);

			attr_dev(img, "class", "svelte-1u541fl");
			add_location(img, TextureWidget_svelte_file, 3, 1, 70);
			attr_dev(div, "class", "knob-container-container svelte-1u541fl");
			add_location(div, TextureWidget_svelte_file, 2, 0, 30);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
			append_dev(div, t);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = listen_dev(img, "click", /*click_handler*/ ctx[3], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*selected_brush_texture*/ 1 && !src_url_equal(img.src, img_src_value = /*selected_brush_texture*/ ctx[0]
			? /*selected_brush_texture*/ ctx[0].path
			: '')) {
				attr_dev(img, "src", img_src_value);
			}

			if (/*dropdown_toggled*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = TextureWidget_svelte_create_if_block(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: TextureWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function TextureWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('TextureWidget', slots, []);
	let { brush_textures } = $$props;
	let { selected_brush_texture } = $$props;
	let dropdown_toggled = false;

	$$self.$$.on_mount.push(function () {
		if (brush_textures === undefined && !('brush_textures' in $$props || $$self.$$.bound[$$self.$$.props['brush_textures']])) {
			console.warn("<TextureWidget> was created without expected prop 'brush_textures'");
		}

		if (selected_brush_texture === undefined && !('selected_brush_texture' in $$props || $$self.$$.bound[$$self.$$.props['selected_brush_texture']])) {
			console.warn("<TextureWidget> was created without expected prop 'selected_brush_texture'");
		}
	});

	const writable_props = ['brush_textures', 'selected_brush_texture'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextureWidget> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(2, dropdown_toggled = !dropdown_toggled);
	};

	const click_handler_1 = texture => {
		$$invalidate(0, selected_brush_texture = texture);
		$$invalidate(2, dropdown_toggled = false);
	};

	$$self.$$set = $$props => {
		if ('brush_textures' in $$props) $$invalidate(1, brush_textures = $$props.brush_textures);
		if ('selected_brush_texture' in $$props) $$invalidate(0, selected_brush_texture = $$props.selected_brush_texture);
	};

	$$self.$capture_state = () => ({
		brush_textures,
		selected_brush_texture,
		dropdown_toggled
	});

	$$self.$inject_state = $$props => {
		if ('brush_textures' in $$props) $$invalidate(1, brush_textures = $$props.brush_textures);
		if ('selected_brush_texture' in $$props) $$invalidate(0, selected_brush_texture = $$props.selected_brush_texture);
		if ('dropdown_toggled' in $$props) $$invalidate(2, dropdown_toggled = $$props.dropdown_toggled);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		selected_brush_texture,
		brush_textures,
		dropdown_toggled,
		click_handler,
		click_handler_1
	];
}

class TextureWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			TextureWidget_svelte_instance,
			TextureWidget_svelte_create_fragment,
			safe_not_equal,
			{
				brush_textures: 1,
				selected_brush_texture: 0
			},
			TextureWidget_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TextureWidget",
			options,
			id: TextureWidget_svelte_create_fragment.name
		});
	}

	get brush_textures() {
		return this.$$.ctx[1];
	}

	set brush_textures(brush_textures) {
		this.$$set({ brush_textures });
		scheduler_flush();
	}

	get selected_brush_texture() {
		return this.$$.ctx[0];
	}

	set selected_brush_texture(selected_brush_texture) {
		this.$$set({ selected_brush_texture });
		scheduler_flush();
	}
}

/* harmony default export */ const TextureWidget_svelte = (TextureWidget);
;// CONCATENATED MODULE: ./src/components/BlendingColourSpaceWidget.svelte
/* src/components/BlendingColourSpaceWidget.svelte generated by Svelte v4.0.1 */


const { Object: BlendingColourSpaceWidget_svelte_Object_1 } = globals;


const BlendingColourSpaceWidget_svelte_file = "src/components/BlendingColourSpaceWidget.svelte";

function BlendingColourSpaceWidget_svelte_add_css(target) {
	append_styles(target, "svelte-1ojy4hv", "div.svelte-1ojy4hv.svelte-1ojy4hv.svelte-1ojy4hv:active{filter:invert(1);background:black}.knob-container-container.svelte-1ojy4hv.svelte-1ojy4hv.svelte-1ojy4hv{z-index:0 !important;margin-bottom:auto;margin-top:auto;margin-right:1.5rem;display:block;flex-direction:column;justify-content:center;align-items:center;pointer-events:all;user-select:none;cursor:pointer;min-width:7rem;border:1px solid white;min-width:0px}.knob-container-container.svelte-1ojy4hv #dropdown.svelte-1ojy4hv.svelte-1ojy4hv{display:flex;flex-direction:column;position:static;height:unset;background:black}.knob-container-container.svelte-1ojy4hv #dropdown.svelte-1ojy4hv>div.svelte-1ojy4hv{border:1px solid white;z-index:10000000;width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmxlbmRpbmdDb2xvdXJTcGFjZVdpZGdldC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBcUNrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJCbGVuZGluZ0NvbG91clNwYWNlV2lkZ2V0LnN2ZWx0ZSJdfQ== */");
}

function BlendingColourSpaceWidget_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[6] = i;
	return child_ctx;
}

// (4:1) {#if !dropdown_toggled}
function create_if_block_2(ctx) {
	let div0;
	let t1;
	let div1;
	let t2_value = BlendingColourSpace[/*selected_colour_space*/ ctx[0]] + "";
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div0 = dom_element("div");
			div0.textContent = "Blend space";
			t1 = space();
			div1 = dom_element("div");
			t2 = dom_text(t2_value);
			set_style(div0, "border", "none");
			attr_dev(div0, "class", "svelte-1ojy4hv");
			add_location(div0, BlendingColourSpaceWidget_svelte_file, 4, 1, 118);
			set_style(div1, "border", "1px solid white");
			attr_dev(div1, "class", "svelte-1ojy4hv");
			add_location(div1, BlendingColourSpaceWidget_svelte_file, 5, 1, 164);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, t2);

			if (!mounted) {
				dispose = listen_dev(div1, "click", /*click_handler*/ ctx[2], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selected_colour_space*/ 1 && t2_value !== (t2_value = BlendingColourSpace[/*selected_colour_space*/ ctx[0]] + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div0);
				detach_dev(t1);
				detach_dev(div1);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(4:1) {#if !dropdown_toggled}",
		ctx
	});

	return block;
}

// (10:1) {#if dropdown_toggled}
function BlendingColourSpaceWidget_svelte_create_if_block(ctx) {
	let div;
	let each_value = ensure_array_like_dev(Object.keys(BlendingColourSpace));
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = BlendingColourSpaceWidget_svelte_create_each_block(BlendingColourSpaceWidget_svelte_get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "id", "dropdown");
			attr_dev(div, "class", "svelte-1ojy4hv");
			add_location(div, BlendingColourSpaceWidget_svelte_file, 10, 2, 332);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*Object, BlendingColourSpace, selected_colour_space, dropdown_toggled, isNaN*/ 3) {
				each_value = ensure_array_like_dev(Object.keys(BlendingColourSpace));
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = BlendingColourSpaceWidget_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = BlendingColourSpaceWidget_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BlendingColourSpaceWidget_svelte_create_if_block.name,
		type: "if",
		source: "(10:1) {#if dropdown_toggled}",
		ctx
	});

	return block;
}

// (13:4) {#if isNaN(BlendingColourSpace[colour_space])}
function BlendingColourSpaceWidget_svelte_create_if_block_1(ctx) {
	let div;
	let t0_value = BlendingColourSpace[/*colour_space*/ ctx[4]] + "";
	let t0;
	let t1;
	let div_style_value;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[3](/*colour_space*/ ctx[4]);
	}

	const block = {
		c: function create() {
			div = dom_element("div");
			t0 = dom_text(t0_value);
			t1 = space();
			attr_dev(div, "role", "button");
			attr_dev(div, "tabindex", "0");

			attr_dev(div, "style", div_style_value = // @ts-ignore
			/*colour_space*/ ctx[4] === /*selected_colour_space*/ ctx[0]
			? "background: black; filter: invert(1);"
			: "");

			attr_dev(div, "class", "svelte-1ojy4hv");
			add_location(div, BlendingColourSpaceWidget_svelte_file, 13, 5, 471);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (!mounted) {
				dispose = listen_dev(div, "click", click_handler_1, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*selected_colour_space*/ 1 && div_style_value !== (div_style_value = // @ts-ignore
			/*colour_space*/ ctx[4] === /*selected_colour_space*/ ctx[0]
			? "background: black; filter: invert(1);"
			: "")) {
				attr_dev(div, "style", div_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BlendingColourSpaceWidget_svelte_create_if_block_1.name,
		type: "if",
		source: "(13:4) {#if isNaN(BlendingColourSpace[colour_space])}",
		ctx
	});

	return block;
}

// (12:3) {#each Object.keys(BlendingColourSpace) as colour_space, i}
function BlendingColourSpaceWidget_svelte_create_each_block(ctx) {
	let show_if = isNaN(BlendingColourSpace[/*colour_space*/ ctx[4]]);
	let if_block_anchor;
	let if_block = show_if && BlendingColourSpaceWidget_svelte_create_if_block_1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (show_if) if_block.p(ctx, dirty);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BlendingColourSpaceWidget_svelte_create_each_block.name,
		type: "each",
		source: "(12:3) {#each Object.keys(BlendingColourSpace) as colour_space, i}",
		ctx
	});

	return block;
}

function BlendingColourSpaceWidget_svelte_create_fragment(ctx) {
	let div;
	let t;
	let if_block0 = !/*dropdown_toggled*/ ctx[1] && create_if_block_2(ctx);
	let if_block1 = /*dropdown_toggled*/ ctx[1] && BlendingColourSpaceWidget_svelte_create_if_block(ctx);

	const block = {
		c: function create() {
			div = dom_element("div");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "knob-container-container svelte-1ojy4hv");
			set_style(div, "border", "none");
			add_location(div, BlendingColourSpaceWidget_svelte_file, 2, 0, 30);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t);
			if (if_block1) if_block1.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (!/*dropdown_toggled*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*dropdown_toggled*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = BlendingColourSpaceWidget_svelte_create_if_block(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: BlendingColourSpaceWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function BlendingColourSpaceWidget_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BlendingColourSpaceWidget', slots, []);
	let { selected_colour_space } = $$props;
	let dropdown_toggled = false;

	$$self.$$.on_mount.push(function () {
		if (selected_colour_space === undefined && !('selected_colour_space' in $$props || $$self.$$.bound[$$self.$$.props['selected_colour_space']])) {
			console.warn("<BlendingColourSpaceWidget> was created without expected prop 'selected_colour_space'");
		}
	});

	const writable_props = ['selected_colour_space'];

	BlendingColourSpaceWidget_svelte_Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BlendingColourSpaceWidget> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(1, dropdown_toggled = true);
	};

	const click_handler_1 = colour_space => {
		// @ts-ignore
		$$invalidate(0, selected_colour_space = colour_space);

		$$invalidate(1, dropdown_toggled = false);
	};

	$$self.$$set = $$props => {
		if ('selected_colour_space' in $$props) $$invalidate(0, selected_colour_space = $$props.selected_colour_space);
	};

	$$self.$capture_state = () => ({
		BlendingColourSpace: BlendingColourSpace,
		BrushType: BrushType,
		selected_colour_space,
		dropdown_toggled
	});

	$$self.$inject_state = $$props => {
		if ('selected_colour_space' in $$props) $$invalidate(0, selected_colour_space = $$props.selected_colour_space);
		if ('dropdown_toggled' in $$props) $$invalidate(1, dropdown_toggled = $$props.dropdown_toggled);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [selected_colour_space, dropdown_toggled, click_handler, click_handler_1];
}

class BlendingColourSpaceWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, BlendingColourSpaceWidget_svelte_instance, BlendingColourSpaceWidget_svelte_create_fragment, safe_not_equal, { selected_colour_space: 0 }, BlendingColourSpaceWidget_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BlendingColourSpaceWidget",
			options,
			id: BlendingColourSpaceWidget_svelte_create_fragment.name
		});
	}

	get selected_colour_space() {
		return this.$$.ctx[0];
	}

	set selected_colour_space(selected_colour_space) {
		this.$$set({ selected_colour_space });
		scheduler_flush();
	}
}

/* harmony default export */ const BlendingColourSpaceWidget_svelte = (BlendingColourSpaceWidget);
;// CONCATENATED MODULE: ./src/components/RGBSliders.svelte
/* src/components/RGBSliders.svelte generated by Svelte v4.0.1 */




const RGBSliders_svelte_file = "src/components/RGBSliders.svelte";

function RGBSliders_svelte_add_css(target) {
	append_styles(target, "svelte-10dal0e", ".knob-container-container.svelte-10dal0e.svelte-10dal0e{margin-left:0px;margin-right:0px;aspect-ratio:2/1;height:100%;width:14rem;display:flex;flex-direction:row;justify-content:center;align-items:center;pointer-events:all;user-select:none}.knob-container.svelte-10dal0e.svelte-10dal0e{height:100%;width:100%;margin-right:auto}.knob-container.svelte-10dal0e .inner.svelte-10dal0e{transform-origin:left;height:100%;width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUkdCU2xpZGVycy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBMEZrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJSR0JTbGlkZXJzLnN2ZWx0ZSJdfQ== */");
}

function RGBSliders_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[16] = list;
	child_ctx[17] = i;
	return child_ctx;
}

// (60:4) {#if i !== 3}
function RGBSliders_svelte_create_if_block(ctx) {
	let div1;
	let div0;
	let div0_style_value;
	let i = /*i*/ ctx[17];
	let t;
	let mounted;
	let dispose;
	const assign_div0 = () => /*div0_binding*/ ctx[5](div0, i);
	const unassign_div0 = () => /*div0_binding*/ ctx[5](null, i);

	function pointerdown_handler(...args) {
		return /*pointerdown_handler*/ ctx[6](/*i*/ ctx[17], ...args);
	}

	const assign_div1 = () => /*div1_binding*/ ctx[7](div1, i);
	const unassign_div1 = () => /*div1_binding*/ ctx[7](null, i);

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			t = space();
			attr_dev(div0, "class", "inner svelte-10dal0e");

			attr_dev(div0, "style", div0_style_value = /*i*/ ctx[17] === 0
			? "background: rgba(255,0,0,1);"
			: /*i*/ ctx[17] === 1
				? "background: rgba(0,255,0,1);"
				: "background: rgba(0,0,255,1);");

			add_location(div0, RGBSliders_svelte_file, 79, 9, 1729);
			attr_dev(div1, "class", "knob-container svelte-10dal0e");
			add_location(div1, RGBSliders_svelte_file, 71, 6, 1529);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			assign_div0();
			append_dev(div1, t);
			assign_div1();

			if (!mounted) {
				dispose = listen_dev(div1, "pointerdown", pointerdown_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (i !== /*i*/ ctx[17]) {
				unassign_div0();
				i = /*i*/ ctx[17];
				assign_div0();
			}

			if (i !== /*i*/ ctx[17]) {
				unassign_div1();
				i = /*i*/ ctx[17];
				assign_div1();
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			unassign_div0();
			unassign_div1();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: RGBSliders_svelte_create_if_block.name,
		type: "if",
		source: "(60:4) {#if i !== 3}",
		ctx
	});

	return block;
}

// (59:2) {#each colour as col_element, i}
function RGBSliders_svelte_create_each_block(ctx) {
	let if_block_anchor;
	let if_block = /*i*/ ctx[17] !== 3 && RGBSliders_svelte_create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*i*/ ctx[17] !== 3) if_block.p(ctx, dirty);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: RGBSliders_svelte_create_each_block.name,
		type: "each",
		source: "(59:2) {#each colour as col_element, i}",
		ctx
	});

	return block;
}

function RGBSliders_svelte_create_fragment(ctx) {
	let div;
	let each_value = ensure_array_like_dev(/*colour*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = RGBSliders_svelte_create_each_block(RGBSliders_svelte_get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "draggable", "false");
			attr_dev(div, "class", "knob-container-container svelte-10dal0e");
			add_location(div, RGBSliders_svelte_file, 66, 0, 1397);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*elements, colour_idx, pointerDown, inners, colour*/ 31) {
				each_value = ensure_array_like_dev(/*colour*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = RGBSliders_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = RGBSliders_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: RGBSliders_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function RGBSliders_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('RGBSliders', slots, []);
	let { colour } = $$props;
	let colour_idx = 0;
	let elements = [0, 0, 0];
	let inners = [0, 0, 0];
	let startY = 0;
	let startX = 0;
	let startValue = 0;

	const clamp = (num, min, max) => {
		return Math.max(min, Math.min(num, max));
	};

	const update_style = idx => {
		$$invalidate(3, inners[idx].style.transform = `scaleX(${colour[idx]})`, inners);
	};

	const pointerMove = ({ clientX, clientY }) => {
		let scale = 0.25 / elements[colour_idx].clientWidth;
		let valueDiff = -(startX - clientX) * scale;
		$$invalidate(0, colour[colour_idx] = clamp(startValue + valueDiff, 0, 1), colour);
		update_style(colour_idx);
	};

	const pointerDown = e => {
		let { clientX, clientY } = e;
		startY = clientY;
		startX = clientX;
		startValue = colour[colour_idx];
		update_style(colour_idx);
		window.addEventListener('pointermove', pointerMove);
		window.addEventListener('pointerup', pointerUp);
	};

	const pointerUp = () => {
		window.removeEventListener('pointermove', pointerMove);
		window.removeEventListener('pointerup', pointerUp);
	};

	onMount(() => {
		update_style(0);
		update_style(1);
		update_style(2);
	});

	$$self.$$.on_mount.push(function () {
		if (colour === undefined && !('colour' in $$props || $$self.$$.bound[$$self.$$.props['colour']])) {
			console.warn("<RGBSliders> was created without expected prop 'colour'");
		}
	});

	const writable_props = ['colour'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RGBSliders> was created with unknown prop '${key}'`);
	});

	function div0_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inners[i] = $$value;
			$$invalidate(3, inners);
		});
	}

	const pointerdown_handler = (i, e) => {
		$$invalidate(2, colour_idx = i);
		pointerDown(e);
		e.stopPropagation();
	};

	function div1_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elements[i] = $$value;
			$$invalidate(1, elements);
		});
	}

	$$self.$$set = $$props => {
		if ('colour' in $$props) $$invalidate(0, colour = $$props.colour);
	};

	$$self.$capture_state = () => ({
		onMount: onMount,
		colour,
		colour_idx,
		elements,
		inners,
		startY,
		startX,
		startValue,
		clamp,
		update_style,
		pointerMove,
		pointerDown,
		pointerUp
	});

	$$self.$inject_state = $$props => {
		if ('colour' in $$props) $$invalidate(0, colour = $$props.colour);
		if ('colour_idx' in $$props) $$invalidate(2, colour_idx = $$props.colour_idx);
		if ('elements' in $$props) $$invalidate(1, elements = $$props.elements);
		if ('inners' in $$props) $$invalidate(3, inners = $$props.inners);
		if ('startY' in $$props) startY = $$props.startY;
		if ('startX' in $$props) startX = $$props.startX;
		if ('startValue' in $$props) startValue = $$props.startValue;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*colour, elements*/ 3) {
			$: {
				if (colour[0] && isNaN(elements[0])) update_style(0);
			}
		}

		if ($$self.$$.dirty & /*colour, elements*/ 3) {
			$: {
				if (colour[1] && isNaN(elements[1])) update_style(1);
			}
		}

		if ($$self.$$.dirty & /*colour, elements*/ 3) {
			$: {
				if (colour[2] && isNaN(elements[2])) update_style(2);
			}
		}
	};

	return [
		colour,
		elements,
		colour_idx,
		inners,
		pointerDown,
		div0_binding,
		pointerdown_handler,
		div1_binding
	];
}

class RGBSliders extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, RGBSliders_svelte_instance, RGBSliders_svelte_create_fragment, safe_not_equal, { colour: 0 }, RGBSliders_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RGBSliders",
			options,
			id: RGBSliders_svelte_create_fragment.name
		});
	}

	get colour() {
		return this.$$.ctx[0];
	}

	set colour(colour) {
		this.$$set({ colour });
		scheduler_flush();
	}
}

/* harmony default export */ const RGBSliders_svelte = (RGBSliders);
// EXTERNAL MODULE: ./node_modules/chroma-js/chroma.js
var chroma = __webpack_require__(6302);
var chroma_default = /*#__PURE__*/__webpack_require__.n(chroma);
;// CONCATENATED MODULE: ./src/components/ColourDisplay.svelte
/* src/components/ColourDisplay.svelte generated by Svelte v4.0.1 */







const ColourDisplay_svelte_file = "src/components/ColourDisplay.svelte";

function ColourDisplay_svelte_add_css(target) {
	append_styles(target, "svelte-657qph", ".knob-container.svelte-657qph.svelte-657qph{box-sizing:border-box;-webkit-box-sizing:border-box;width:10rem;margin-right:0.5rem;aspect-ratio:1/1;display:flex;background-color:var(--color);height:100%;align-items:center;justify-content:space-around}.knob-container.svelte-657qph.svelte-657qph:hover{cursor:pointer}.knob-container.svelte-657qph>div.svelte-657qph{width:100%;height:100%;text-align:center;user-select:none;filter:invert(1);filter:grayscale(1);color:black}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29sb3VyRGlzcGxheS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBMkdrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDb2xvdXJEaXNwbGF5LnN2ZWx0ZSJdfQ== */");
}

// (72:1) {#if dragging}
function ColourDisplay_svelte_create_if_block(ctx) {
	let div0;
	let t0;
	let div0_style_value;
	let div0_transition;
	let t1;
	let div1;
	let t2;
	let div1_style_value;
	let current;

	const block = {
		c: function create() {
			div0 = dom_element("div");
			t0 = dom_text("V/H");
			t1 = space();
			div1 = dom_element("div");
			t2 = dom_text("V/S");
			attr_dev(div0, "style", div0_style_value = `opacity: ${/*is_vs_adjusting*/ ctx[2] ? 0.5 : 1};`);
			attr_dev(div0, "class", "svelte-657qph");
			add_location(div0, ColourDisplay_svelte_file, 98, 1, 2602);
			attr_dev(div1, "style", div1_style_value = `opacity: ${/*is_vs_adjusting*/ ctx[2] ? 1 : 0.5};`);
			attr_dev(div1, "class", "svelte-657qph");
			add_location(div1, ColourDisplay_svelte_file, 101, 1, 2706);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, t2);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*is_vs_adjusting*/ 4 && div0_style_value !== (div0_style_value = `opacity: ${/*is_vs_adjusting*/ ctx[2] ? 0.5 : 1};`)) {
				attr_dev(div0, "style", div0_style_value);
			}

			if (!current || dirty & /*is_vs_adjusting*/ 4 && div1_style_value !== (div1_style_value = `opacity: ${/*is_vs_adjusting*/ ctx[2] ? 1 : 0.5};`)) {
				attr_dev(div1, "style", div1_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;

			if (local) {
				scheduler_add_render_callback(() => {
					if (!current) return;
					if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, { duration: 200 }, true);
					div0_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			if (local) {
				if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, { duration: 200 }, false);
				div0_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div0);
				detach_dev(t1);
				detach_dev(div1);
			}

			if (detaching && div0_transition) div0_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: ColourDisplay_svelte_create_if_block.name,
		type: "if",
		source: "(72:1) {#if dragging}",
		ctx
	});

	return block;
}

function ColourDisplay_svelte_create_fragment(ctx) {
	let div;
	let mounted;
	let dispose;
	let if_block = /*dragging*/ ctx[0] && ColourDisplay_svelte_create_if_block(ctx);

	const block = {
		c: function create() {
			div = dom_element("div");
			if (if_block) if_block.c();
			attr_dev(div, "draggable", "false");
			attr_dev(div, "class", "knob-container svelte-657qph");
			add_location(div, ColourDisplay_svelte_file, 96, 0, 2486);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			/*div_binding*/ ctx[7](div);

			if (!mounted) {
				dispose = listen_dev(div, "pointerdown", /*pointerDown*/ ctx[3], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*dragging*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*dragging*/ 1) {
						transitions_transition_in(if_block, 1);
					}
				} else {
					if_block = ColourDisplay_svelte_create_if_block(ctx);
					if_block.c();
					transitions_transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				transitions_group_outros();

				transitions_transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				transitions_check_outros();
			}
		},
		i: function intro(local) {
			transitions_transition_in(if_block);
		},
		o: function outro(local) {
			transitions_transition_out(if_block);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block) if_block.d();
			/*div_binding*/ ctx[7](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: ColourDisplay_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function ColourDisplay_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ColourDisplay', slots, []);
	let { colour } = $$props;
	let container;

	const re_render_colour = (colour_r, colour_g, colour_b) => {
		if (container) {
			container.style.setProperty('--color', `rgba(${255 * Math.pow(colour_r, 0.45454545454545454545)}, ${255 * Math.pow(colour_g, 0.45454545454545454545)}, ${255 * Math.pow(colour_b, 0.45454545454545454545)}, ${255 * Math.pow(1.0, 0.45454545454545454545)})`);
		}
	};

	const update_display = (colour_r, colour_g, colour_b) => {
		re_render_colour(colour_r, colour_g, colour_b);
	};

	let { dragging = false } = $$props;
	let { stopped_dragging = false } = $$props;
	let startValue = [0, 0];
	let is_vs_adjusting = false;
	let prevX = 0;
	let prevY = 0;

	const chroma_gl = col => {
		return chroma_default().gl(col[0], col[1], col[2]);
	};

	const chroma_oklch = col => {
		return chroma_default().oklch(col[0], col[1], col[2]);
	};

	const pointerMove = ({ clientX, clientY }) => {
		const scale = 1. / min(document.documentElement.clientWidth, document.documentElement.clientHeight);
		const valueDiffY = -(clientY - prevY);
		const valueDiffX = clientX - prevX;
		prevX = clientX;
		prevY = clientY;
		let col = chroma_gl(colour).oklch();
		col[0] += valueDiffY * 1.0 * scale;

		if (is_vs_adjusting) {
			col[1] += valueDiffX * 0.5 * scale;
		} else {
			col[2] += valueDiffX * 360 * 1.0 * scale;
		}

		col[0] = wmath_clamp(col[0], 0, 1);
		col[1] = wmath_clamp(col[1], 0, 1);
		col[2] = _0b5vr_experimental_esm_mod(col[2], 360);
		col = chroma_oklch(col).gl();
		$$invalidate(4, colour[0] = col[0], colour);
		$$invalidate(4, colour[1] = col[1], colour);
		$$invalidate(4, colour[2] = col[2], colour);
	};

	const pointerDown = e => {
		$$invalidate(0, dragging = true);
		const { clientX, clientY } = e;
		prevY = clientY;
		prevX = clientX;
		startValue = [colour[0], colour[1], colour[2], 1];
		const rect = container.getBoundingClientRect();
		const x_relative_to_element = (e.clientX - rect.left) / rect.width;
		$$invalidate(2, is_vs_adjusting = x_relative_to_element > 0.5);
		window.addEventListener('pointermove', pointerMove);
		window.addEventListener('pointerup', pointerUp);
		e.stopPropagation();
	};

	const pointerUp = () => {
		$$invalidate(0, dragging = false);
		$$invalidate(5, stopped_dragging = true);
		window.removeEventListener('pointermove', pointerMove);
		window.removeEventListener('pointerup', pointerUp);
	};

	$$self.$$.on_mount.push(function () {
		if (colour === undefined && !('colour' in $$props || $$self.$$.bound[$$self.$$.props['colour']])) {
			console.warn("<ColourDisplay> was created without expected prop 'colour'");
		}
	});

	const writable_props = ['colour', 'dragging', 'stopped_dragging'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ColourDisplay> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(1, container);
		});
	}

	$$self.$$set = $$props => {
		if ('colour' in $$props) $$invalidate(4, colour = $$props.colour);
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
		if ('stopped_dragging' in $$props) $$invalidate(5, stopped_dragging = $$props.stopped_dragging);
	};

	$$self.$capture_state = () => ({
		mod: _0b5vr_experimental_esm_mod,
		chroma: (chroma_default()),
		clamp: wmath_clamp,
		min: min,
		fade: fade,
		colour,
		container,
		re_render_colour,
		update_display,
		dragging,
		stopped_dragging,
		startValue,
		is_vs_adjusting,
		prevX,
		prevY,
		chroma_gl,
		chroma_oklch,
		pointerMove,
		pointerDown,
		pointerUp
	});

	$$self.$inject_state = $$props => {
		if ('colour' in $$props) $$invalidate(4, colour = $$props.colour);
		if ('container' in $$props) $$invalidate(1, container = $$props.container);
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
		if ('stopped_dragging' in $$props) $$invalidate(5, stopped_dragging = $$props.stopped_dragging);
		if ('startValue' in $$props) startValue = $$props.startValue;
		if ('is_vs_adjusting' in $$props) $$invalidate(2, is_vs_adjusting = $$props.is_vs_adjusting);
		if ('prevX' in $$props) prevX = $$props.prevX;
		if ('prevY' in $$props) prevY = $$props.prevY;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*colour*/ 16) {
			$: re_render_colour(colour[0], colour[1], colour[2]);
		}
	};

	return [
		dragging,
		container,
		is_vs_adjusting,
		pointerDown,
		colour,
		stopped_dragging,
		update_display,
		div_binding
	];
}

class ColourDisplay extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			ColourDisplay_svelte_instance,
			ColourDisplay_svelte_create_fragment,
			safe_not_equal,
			{
				colour: 4,
				update_display: 6,
				dragging: 0,
				stopped_dragging: 5
			},
			ColourDisplay_svelte_add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ColourDisplay",
			options,
			id: ColourDisplay_svelte_create_fragment.name
		});
	}

	get colour() {
		return this.$$.ctx[4];
	}

	set colour(colour) {
		this.$$set({ colour });
		scheduler_flush();
	}

	get update_display() {
		return this.$$.ctx[6];
	}

	set update_display(value) {
		throw new Error("<ColourDisplay>: Cannot set read-only property 'update_display'");
	}

	get dragging() {
		return this.$$.ctx[0];
	}

	set dragging(dragging) {
		this.$$set({ dragging });
		scheduler_flush();
	}

	get stopped_dragging() {
		return this.$$.ctx[5];
	}

	set stopped_dragging(stopped_dragging) {
		this.$$set({ stopped_dragging });
		scheduler_flush();
	}
}

/* harmony default export */ const ColourDisplay_svelte = (ColourDisplay);
;// CONCATENATED MODULE: ./src/components/FourIconsWidget.svelte
/* src/components/FourIconsWidget.svelte generated by Svelte v4.0.1 */




const FourIconsWidget_svelte_file = "src/components/FourIconsWidget.svelte";

function FourIconsWidget_svelte_add_css(target) {
	append_styles(target, "svelte-luwy0", "#four-icons.svelte-luwy0{height:100%;aspect-ratio:1/1;display:grid;grid-template-columns:2fr 1fr;grid-template-rows:1fr 1fr;width:5rem;transform:scale(0.7);transform-origin:top}#four-icons.svelte-luwy0>div:not(:first-of-type){height:100%;max-height:unset;margin:0}#four-icons.svelte-luwy0>div:first-of-type{grid-column:1/-1}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm91ckljb25zV2lkZ2V0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFZa0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRm91ckljb25zV2lkZ2V0LnN2ZWx0ZSJdfQ== */");
}

function FourIconsWidget_svelte_create_fragment(ctx) {
	let div;
	let div_style_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	const block = {
		c: function create() {
			div = dom_element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "id", "four-icons");
			attr_dev(div, "style", div_style_value = /*$gallery_open*/ ctx[0] ? "display: contents;" : "");
			attr_dev(div, "class", "svelte-luwy0");
			add_location(div, FourIconsWidget_svelte_file, 8, 0, 98);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*$gallery_open*/ 1 && div_style_value !== (div_style_value = /*$gallery_open*/ ctx[0] ? "display: contents;" : "")) {
				attr_dev(div, "style", div_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: FourIconsWidget_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function FourIconsWidget_svelte_instance($$self, $$props, $$invalidate) {
	let $gallery_open;
	validate_store(gallery_open, 'gallery_open');
	component_subscribe($$self, gallery_open, $$value => $$invalidate(0, $gallery_open = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FourIconsWidget', slots, ['default']);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FourIconsWidget> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ gallery_open: gallery_open, $gallery_open });
	return [$gallery_open, $$scope, slots];
}

class FourIconsWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, FourIconsWidget_svelte_instance, FourIconsWidget_svelte_create_fragment, safe_not_equal, {}, FourIconsWidget_svelte_add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FourIconsWidget",
			options,
			id: FourIconsWidget_svelte_create_fragment.name
		});
	}
}

/* harmony default export */ const FourIconsWidget_svelte = (FourIconsWidget);
;// CONCATENATED MODULE: ./src/IO.ts

class IO {
    keys = new Map();
    touches = {};
    two_finger_pinch_prev = false;
    two_finger_pinch = false;
    just_finished_pinch = false;
    just_started_pinch = false;
    touches_starting_positions = new Float32Array(4);
    touches_starting_mid_point = new Float32Array(2);
    touches_starting_length = 0;
    touches_mid_point_prev = new Float32Array(2);
    pinch_pos = new Float32Array(2);
    pinch_zoom = 0;
    mouse_pos = Float32Array.from([0, 0]);
    delta_mouse_pos = Float32Array.from([0, 0]);
    mouse_pos_prev = Float32Array.from([0, 0]);
    mouse_down = false;
    _mouse_positions_during_last_frame = new Float32Array(50);
    _mouse_positions_during_last_frame_b = new Float32Array(50);
    _mouse_positions_during_last_frame_cnt = 0;
    _mouse_positions_during_last_frame_cnt_b = 0;
    mouse_positions_arr_idx = 0;
    get mouse_positions_during_last_frame() {
        return this.mouse_positions_arr_idx === 0
            ? this._mouse_positions_during_last_frame
            : this._mouse_positions_during_last_frame_b;
    }
    get mouse_positions_during_last_frame_cnt() {
        return this.mouse_positions_arr_idx === 0
            ? this._mouse_positions_during_last_frame_cnt
            : this._mouse_positions_during_last_frame_cnt_b;
    }
    pointerType = 'mouse';
    mouse_down_prev = false;
    mouse_just_unpressed = false;
    mouse_just_pressed = false;
    mouse_just_moved = false;
    mmb_just_unpressed = false;
    mmb_just_pressed = false;
    mmb_down = false;
    mouse_wheel = 0;
    pressure = 0.0;
    tilt = [0, 0];
    tick() {
        this.delta_mouse_pos[0] = this.mouse_pos[0] - this.mouse_pos_prev[0];
        this.delta_mouse_pos[1] = this.mouse_pos[1] - this.mouse_pos_prev[1];
        this.mouse_pos_prev[0] = this.mouse_pos[0];
        this.mouse_pos_prev[1] = this.mouse_pos[1];
        if (this.mouse_positions_arr_idx === 0) {
            this._mouse_positions_during_last_frame_cnt = 0;
        }
        else {
            this._mouse_positions_during_last_frame_cnt_b = 0;
        }
        this.mouse_positions_arr_idx = 1 - this.mouse_positions_arr_idx;
        if (this.two_finger_pinch === false && this.two_finger_pinch_prev === true) {
            this.just_finished_pinch = true;
        }
        else if (this.two_finger_pinch === true && this.two_finger_pinch_prev === false) {
            this.just_started_pinch = true;
        }
        if (this.mouse_down !== this.mouse_down_prev) {
            if (this.mouse_down) {
                this.mouse_just_pressed = true;
            }
            else {
                this.mouse_just_unpressed = true;
            }
        }
    }
    tick_end() {
        this.mouse_just_pressed = false;
        this.mouse_just_unpressed = false;
        this.mouse_just_moved = false;
        this.mouse_down_prev = this.mouse_down;
        this.mmb_just_unpressed = false;
        this.mmb_just_pressed = false;
        this.mouse_wheel = 0;
        this.two_finger_pinch_prev = this.two_finger_pinch;
        this.just_finished_pinch = false;
        this.just_started_pinch = false;
        Object.values(this.keys).forEach((key) => {
            key.just_unpressed = false;
            key.just_pressed = false;
        });
    }
    getKey(code) {
        const key = this.keys[code];
        if (key) {
            return key;
        }
        else {
            return { down: false, just_pressed: false, just_unpressed: false };
        }
    }
    constructor() {
        window.addEventListener('keydown', (event) => {
            this.keys[event.code] = { down: true, just_pressed: true, just_unpressed: false };
            if (event.code === 'AltLeft')
                event.preventDefault();
        });
        window.addEventListener('keyup', (event) => {
            let just_unpressed = false;
            if (this.getKey(event.code).down)
                just_unpressed = true;
            this.keys[event.code] = { down: false, just_pressed: false, just_unpressed: just_unpressed };
        });
        window.addEventListener('wheel', (e) => {
            this.mouse_wheel = e.deltaY < 0 ? 1 : e.deltaY > 0 ? -1 : 0;
        });
        window.addEventListener('mouseup', (e) => {
            if (e.button === 1) {
                this.mmb_down = false;
                this.mmb_just_unpressed = true;
            }
        });
        window.addEventListener('mousedown', (e) => {
            if (e.button === 1) {
                this.mmb_down = true;
                this.mmb_just_pressed = true;
                e.preventDefault();
            }
        });
        window.addEventListener('focus', () => {
            const l_alt = this.getKey('AltLeft');
            if (l_alt.down) {
                l_alt.just_unpressed = true;
                l_alt.down = false;
            }
        });
        window.addEventListener('pointermove', (e) => {
            const getRelativeMousePosition = (event, target) => {
                target = target || event.target;
                const rect = target.getBoundingClientRect();
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top,
                };
            };
            const getNoPaddingNoBorderCanvasRelativeMousePosition = (event, target) => {
                target = target || event.target;
                const pos = getRelativeMousePosition(event, target);
                pos.x = (pos.x * target.width) / target.clientWidth;
                pos.y = (pos.y * target.height) / target.clientHeight;
                return pos;
            };
            const gl = window.gl;
            const pos = getNoPaddingNoBorderCanvasRelativeMousePosition(e, gl.canvas);
            const x = (pos.x / gl.canvas.width) * 2 - 1;
            const y = (pos.y / gl.canvas.height) * -2 + 1;
            this.mouse_pos[0] = x;
            this.mouse_pos[1] = y;
            const is_back = this.mouse_positions_arr_idx === 0;
            const positions = is_back ? this._mouse_positions_during_last_frame_b : this._mouse_positions_during_last_frame;
            const idx = is_back ? this._mouse_positions_during_last_frame_cnt_b : this._mouse_positions_during_last_frame_cnt;
            positions[idx * 2] = x;
            positions[idx * 2 + 1] = y;
            if (is_back)
                this._mouse_positions_during_last_frame_cnt_b++;
            else
                this._mouse_positions_during_last_frame_cnt++;
            this.pressure = e.pointerType === 'mouse' ? 1 : e.pressure ?? this.pressure;
            this.mouse_just_moved = true;
            this.tilt[0] = e.pointerType === 'mouse' ? 0 : e.altitudeAngle ?? this.tilt[0];
            this.tilt[1] = e.pointerType === 'mouse' ? 0 : e.azimuthAngle ?? this.tilt[1];
        });
        const canvas_element = document.querySelector('canvas');
        canvas_element.addEventListener('touchstart', (e) => {
            for (let i = 0; i < e.targetTouches.length; i++) {
                const touch = e.targetTouches[i];
                const touch_id = touch.identifier;
                this.touches[touch_id] = [touch.clientX, touch.clientY];
            }
        });
        const length = (ax, ay, bx, by) => {
            return sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by));
        };
        canvas_element.addEventListener('touchmove', (e) => {
            if (e.targetTouches.length === 2) {
                if (this.two_finger_pinch === false) {
                    this.touches_starting_positions[0] = e.targetTouches[0].clientX;
                    this.touches_starting_positions[1] = e.targetTouches[0].clientY;
                    this.touches_starting_positions[2] = e.targetTouches[1].clientX;
                    this.touches_starting_positions[3] = e.targetTouches[1].clientY;
                    this.touches_starting_mid_point[0] = e.targetTouches[0].clientX * 0.5 + e.targetTouches[1].clientX * 0.5;
                    this.touches_starting_mid_point[1] = e.targetTouches[0].clientY * 0.5 + e.targetTouches[1].clientY * 0.5;
                    this.pinch_zoom = 0;
                    this.touches_starting_length = length(e.targetTouches[0].clientX, e.targetTouches[0].clientY, e.targetTouches[1].clientX, e.targetTouches[1].clientY);
                    this.touches_mid_point_prev[0] = this.touches_starting_mid_point[0];
                    this.touches_mid_point_prev[1] = this.touches_starting_mid_point[1];
                    this.pinch_pos[0] = 0;
                    this.pinch_pos[1] = 0;
                }
                this.two_finger_pinch = true;
                const mid_point_x = e.targetTouches[0].clientX * 0.5 + e.targetTouches[1].clientX * 0.5;
                const mid_point_y = e.targetTouches[0].clientY * 0.5 + e.targetTouches[1].clientY * 0.5;
                const len = length(e.targetTouches[0].clientX, e.targetTouches[0].clientY, e.targetTouches[1].clientX, e.targetTouches[1].clientY);
                const res = min(window.innerWidth, window.innerHeight);
                this.pinch_zoom = ((len - this.touches_starting_length) / res) * 4;
                this.pinch_pos[0] += (((mid_point_x - this.touches_mid_point_prev[0]) / res) * 2) / window.zoom[0];
                this.pinch_pos[1] += (((mid_point_y - this.touches_mid_point_prev[1]) / res) * 2) / window.zoom[0];
                this.touches_mid_point_prev[0] = mid_point_x;
                this.touches_mid_point_prev[1] = mid_point_y;
            }
            else {
                if (this.two_finger_pinch === true) {
                    this.two_finger_pinch = false;
                }
            }
        });
        const touch_end = (e) => {
            for (const id in Object.keys(this.touches)) {
                delete this.touches[id];
            }
            this.two_finger_pinch = false;
        };
        canvas_element.addEventListener('touchcancel', (e) => {
            touch_end(e);
        });
        canvas_element.addEventListener('touchend', (e) => {
            touch_end(e);
        });
        canvas_element.addEventListener('pointerdown', (e) => {
            this.pointerType = e.pointerType;
            if (e.pointerType === 'mouse' && e.button !== 0)
                return;
            this.mouse_down = true;
        });
        window.addEventListener('pointerup', () => {
            this.mouse_down = false;
        });
    }
}

// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js
var earcut = __webpack_require__(720);
// EXTERNAL MODULE: ./node_modules/libtess/libtess.min.js
var libtess_min = __webpack_require__(2587);
var libtess_min_default = /*#__PURE__*/__webpack_require__.n(libtess_min);
;// CONCATENATED MODULE: ./src/gl/Buffer.ts


class UBO {
    buff;
    uniforms = [];
    constructor() {
        this.buff = new VertexBuffer(0, gl.FLOAT, 96, gl.UNIFORM_BUFFER);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, this.buff.buff);
    }
}
class VertexBuffer {
    buff;
    cpu_buff;
    type;
    usage;
    stride;
    single_vert_sz;
    sz;
    max_sz;
    constructor(single_vert_sz, type = gl.FLOAT, max_size = 10000000, usage = gl.ARRAY_BUFFER) {
        this.buff = gl.createBuffer();
        this.usage = usage;
        gl.bindBuffer(usage, this.buff);
        this.type = type;
        this.single_vert_sz = single_vert_sz;
        this.max_sz = max_size;
        this.stride = 0;
        if (type === gl.FLOAT) {
            this.cpu_buff = new Float32Array(max_size);
        }
        else if (type === gl.INT) {
            this.cpu_buff = new Int32Array(max_size);
        }
        else {
            this.cpu_buff = new Uint32Array(max_size);
        }
        gl.bufferData(usage, this.cpu_buff.byteLength, gl.DYNAMIC_DRAW);
        this.sz = 0;
    }
    bindToAttrib(idx, params = undefined) {
        if (params) {
            gl.bindBuffer(this.usage, this.buff);
            gl.vertexAttribPointer(idx, params.vert_sz ?? this.single_vert_sz, params.type ?? this.type, false, params.stride ?? this.stride, params.offset ?? 0);
        }
        else {
            gl.bindBuffer(this.usage, this.buff);
            gl.vertexAttribPointer(idx, this.single_vert_sz, this.type, false, this.stride, 0);
        }
    }
    push_vert(vert) {
        if (vert.length !== this.single_vert_sz) {
        }
        for (let v of vert) {
            this.cpu_buff[this.sz++] = v;
        }
    }
    upload_external_array(input_buff) {
        if (input_buff instanceof Array) {
            gl.bindBuffer(this.usage, this.buff);
            let _buff = Float32Array.from(input_buff);
            this.sz = _buff.length;
            const sz_in_bytes = _buff.byteLength;
            gl.bufferSubData(this.usage, 0, _buff);
            pause_on_gl_error();
        }
        else {
            gl.bindBuffer(this.usage, this.buff);
            const sz_in_bytes = input_buff.byteLength;
            gl.bufferSubData(this.usage, 0, input_buff);
            pause_on_gl_error();
        }
    }
    upload() {
        gl.bindBuffer(this.usage, this.buff);
        const sz_in_bytes = this.sz * this.cpu_buff.BYTES_PER_ELEMENT;
        gl.bufferSubData(this.usage, 0, this.cpu_buff, 0, sz_in_bytes);
        pause_on_gl_error();
    }
}

;// CONCATENATED MODULE: ./src/gl/ShaderProgram.ts

class ShaderProgram {
    program;
    loadShader(type, source) {
        source = source.replaceAll('export default "', ``);
        source = source.replaceAll('";', ``);
        source = source.replaceAll('"', ``);
        source = source.replaceAll(`\\n`, `
		`);
        source = source.replace(/(.*)(#version 300 es)[\t\s]*/g, `$2
			`);
        source = source.replaceAll(/(#define .+)[\t\s]*/g, `
		$1
		`);
        source = source.replaceAll(/	+precision highp float;/gm, `precision highp float;
			`);
        source = source.replaceAll(`\\t`, `	`);
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(`An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`);
            console.error(source);
        }
        return shader;
    }
    constructor(vs, fs) {
        const vertexShader = this.loadShader(gl.VERTEX_SHADER, vs);
        const fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fs);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error(`Unable to initialize the shader program: ${gl.getProgramInfoLog(shaderProgram)}`);
            console.error(vs);
            console.error(fs);
        }
        this.program = shaderProgram;
        gl.useProgram(this.program);
        gl.uniformBlockBinding(this.program, 0, 0);
    }
    use() {
        gl.useProgram(this.program);
    }
    setUniformVec(name, vec) {
        if (vec.length == 2)
            gl.uniform2fv(gl.getUniformLocation(this.program, name), vec);
        else if (vec.length == 3)
            gl.uniform3fv(gl.getUniformLocation(this.program, name), vec);
        else if (vec.length == 4)
            gl.uniform4fv(gl.getUniformLocation(this.program, name), vec);
    }
    setUniformFloat(name, value) {
        gl.uniform1f(gl.getUniformLocation(this.program, name), value);
    }
    setUniformInt(name, value) {
        gl.uniform1i(gl.getUniformLocation(this.program, name), value);
    }
    setUniformTexture(name, texture, binding = 0) {
        gl.activeTexture(gl.TEXTURE0 + binding);
        gl.bindTexture(gl.TEXTURE_2D, texture.tex);
        gl.uniform1i(gl.getUniformLocation(this.program, name), binding);
    }
}

;// CONCATENATED MODULE: ./src/gl/Thing.ts


class Thing {
    vao;
    buffs;
    shader;
    prim_type;
    constructor(buffs, prim_type = gl.TRIANGLES, shader) {
        this.prim_type = prim_type;
        this.shader = shader;
        this.vao = gl.createVertexArray();
        this.buffs = [...buffs];
        gl.bindVertexArray(this.vao);
        let i = 0;
        for (let buff of this.buffs) {
            gl.enableVertexAttribArray(i);
            buff.bindToAttrib(i);
            i++;
        }
    }
    static draw_external_buffs_and_shader(buffs, shader, params) {
        shader.use();
        let i = 0;
        params.prim_type = params.prim_type ?? gl.TRIANGLES;
        params.draw_cnt = params.draw_cnt ?? buffs[0].buff.sz / buffs[0].buff.single_vert_sz;
        if (params.prim_type === gl.TRIANGLES) {
            gl.drawArrays(gl.TRIANGLES, 0, params.draw_cnt);
            console.log('DREW');
            console.log(params.draw_cnt);
        }
        else {
            alert('bleep bloop errrorrr');
        }
    }
    upload_all_buffs() {
        for (let buff of this.buffs) {
            buff.upload();
        }
    }
    draw_with_external_shader(shader) {
        shader.use();
        if (this.prim_type === gl.TRIANGLES) {
            let draw_cnt = this.buffs[0].sz / this.buffs[0].single_vert_sz;
            gl.drawArrays(this.prim_type, 0, draw_cnt);
        }
        else {
            alert('bleep bloop errrorrr');
        }
    }
    draw(offs = 0) {
        this.draw_with_external_shader(this.shader);
    }
}

;// CONCATENATED MODULE: ./src/drawer.ts








const tessy = (function initTesselator() {
    function vertexCallback(data, polyVertArray) {
        polyVertArray[polyVertArray.length] = data[0];
        polyVertArray[polyVertArray.length] = data[1];
    }
    function begincallback(type) {
        if (type !== (libtess_min_default()).primitiveType.GL_TRIANGLES) {
            console.log('expected TRIANGLES but got type: ' + type);
        }
    }
    function errorcallback(errno) {
        console.log('error callback');
        console.log('error number: ' + errno);
    }
    function combinecallback(coords, data, weight) {
        return [coords[0], coords[1], coords[2]];
    }
    function edgeCallback(flag) {
    }
    const tessy = new (libtess_min_default()).GluTesselator();
    tessy.gluTessCallback((libtess_min_default()).gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
    tessy.gluTessCallback((libtess_min_default()).gluEnum.GLU_TESS_BEGIN, begincallback);
    tessy.gluTessCallback((libtess_min_default()).gluEnum.GLU_TESS_ERROR, errorcallback);
    tessy.gluTessCallback((libtess_min_default()).gluEnum.GLU_TESS_COMBINE, combinecallback);
    tessy.gluTessCallback((libtess_min_default()).gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);
    return tessy;
})();
function triangulate(contours) {
    tessy.gluTessNormal(0, 0, 1);
    const triangleVerts = [];
    tessy.gluTessBeginPolygon(triangleVerts);
    for (let i = 0; i < contours.length; i++) {
        tessy.gluTessBeginContour();
        let contour = contours[i];
        for (let j = 0; j < contour.length; j += 2) {
            const coords = [contour[j], contour[j + 1], 0];
            tessy.gluTessVertex(coords, coords);
        }
        tessy.gluTessEndContour();
    }
    tessy.gluTessEndPolygon();
    return triangleVerts;
}
const get_subarray = (arr, offs_begin, offs_end) => {
    return [arr.subarray(offs_begin, offs_end), offs_end - 1];
};
const get_circ_pos_from_ang = (a) => {
    const c = cos(-a);
    const s = sin(-a);
    return [c, s];
};
let drawer_gl;
class Drawer {
    canvas_tex;
    default_framebuffer;
    brush_buffer;
    zoom = 0;
    panning = [0, 0];
    t = 0;
    idx = 0;
    temp_array_a = new Float32Array(1_000_00);
    temp_array_b = new Float32Array(1_000_00);
    recorded_drawcalls = [];
    constructor(_gl, canvas_tex, default_framebuffer) {
        this.canvas_tex = canvas_tex;
        this.default_framebuffer = default_framebuffer;
        drawer_gl = _gl;
    }
    reset() {
        this.idx = 0;
        this.recorded_drawcalls.length = 0;
        this.brush_buffer.buffs[0].sz = 0;
        this.brush_buffer.buffs[1].sz = 0;
    }
    fill_buff_for_blob_brush(stroke) {
        const brush_buffer = this.brush_buffer;
        const iters = stroke.positions.length / 2 - 1;
        let aspect_correction = [0, 0];
        if (this.canvas_tex.res[0] > this.canvas_tex.res[1]) {
            aspect_correction[0] = this.canvas_tex.res[1] / this.canvas_tex.res[0];
            aspect_correction[1] = 1;
        }
        else {
            aspect_correction[0] = 1;
            aspect_correction[1] = this.canvas_tex.res[0] / this.canvas_tex.res[1];
        }
        const add_ang_to_pos = (pos, ang_x, ang_y, positive, sz_x, sz_y) => {
            if (positive) {
                pos[0] += ang_x[0] * sz_x * aspect_correction[0];
                pos[1] += ang_x[1] * sz_x * aspect_correction[1];
                pos[0] += ang_y[0] * sz_y * aspect_correction[0];
                pos[1] += ang_y[1] * sz_y * aspect_correction[1];
            }
            else {
                pos[0] -= ang_x[0] * sz_x * aspect_correction[0];
                pos[1] -= ang_x[1] * sz_x * aspect_correction[1];
                pos[0] += ang_y[0] * sz_y * aspect_correction[0];
                pos[1] += ang_y[1] * sz_y * aspect_correction[1];
            }
            return pos;
        };
        let idx = brush_buffer.buffs[0].sz;
        for (let i = 0; i < iters; i++) {
            let sz_x = stroke.sizes[i * 2] / 2;
            let sz_y = stroke.sizes[i * 2 + 1] / 2;
            let ang_x = get_circ_pos_from_ang(stroke.rotations[i * 2 + 1]);
            let ang_y = [ang_x[1], -ang_x[0]];
            let curr_pos = [stroke.positions[i * 2], stroke.positions[i * 2 + 1]];
            let curr_pos_left = add_ang_to_pos([...curr_pos], ang_x, ang_y, true, sz_x, sz_y);
            let curr_pos_right = add_ang_to_pos([...curr_pos], ang_x, ang_y, false, sz_x, sz_y);
            let next_pos_left = [...curr_pos_left];
            let next_pos_right = [...curr_pos_right];
            next_pos_left[0] -= ang_y[0] * sz_y * aspect_correction[0] * 2;
            next_pos_left[1] -= ang_y[1] * sz_y * aspect_correction[1] * 2;
            next_pos_right[0] -= ang_y[0] * sz_y * aspect_correction[0] * 2;
            next_pos_right[1] -= ang_y[1] * sz_y * aspect_correction[1] * 2;
            let curr_col = [stroke.colours[i * 3], stroke.colours[i * 3 + 1], stroke.colours[i * 3 + 2]];
            let curr_opacity = stroke.opacities[i];
            const curr_v = i / iters;
            const next_v = (i + 1) / iters;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
        }
        brush_buffer.buffs[0].sz += iters * 6 * 4;
        brush_buffer.buffs[1].sz += iters * 6 * 4;
        this.recorded_drawcalls.push(this.brush_buffer.buffs[0].sz);
    }
    fill_buff_for_long_brush(stroke) {
        const brush_buffer = this.brush_buffer;
        const iters = stroke.positions.length / 2 - 1;
        let aspect_correction = [0, 0];
        if (this.canvas_tex.res[0] > this.canvas_tex.res[1]) {
            aspect_correction[0] = this.canvas_tex.res[1] / this.canvas_tex.res[0];
            aspect_correction[1] = 1;
        }
        else {
            aspect_correction[0] = 1;
            aspect_correction[1] = this.canvas_tex.res[0] / this.canvas_tex.res[1];
        }
        const add_ang_to_pos = (pos, ang_offs, positive, amt, aspect_correction) => {
            if (positive) {
                pos[0] += ang_offs[0] * amt * aspect_correction[0];
                pos[1] += ang_offs[1] * amt * aspect_correction[1];
            }
            else {
                pos[0] -= ang_offs[0] * amt * aspect_correction[0];
                pos[1] -= ang_offs[1] * amt * aspect_correction[1];
            }
            return pos;
        };
        let idx = brush_buffer.buffs[0].sz;
        for (let i = 0; i < iters; i++) {
            let curr_sz = stroke.sizes[i * 2];
            let next_sz = stroke.sizes[i * 2 + 2];
            let curr_ang = get_circ_pos_from_ang(stroke.rotations[i * 2 + 1]);
            let next_ang = get_circ_pos_from_ang(stroke.rotations[i * 2 + 3]);
            let curr_pos = [stroke.positions[i * 2], stroke.positions[i * 2 + 1]];
            let next_pos = [stroke.positions[i * 2 + 2], stroke.positions[i * 2 + 3]];
            let curr_pos_left = add_ang_to_pos([...curr_pos], curr_ang, true, curr_sz, aspect_correction);
            let curr_pos_right = add_ang_to_pos([...curr_pos], curr_ang, false, curr_sz, aspect_correction);
            let next_pos_left = add_ang_to_pos([...next_pos], next_ang, true, next_sz, aspect_correction);
            let next_pos_right = add_ang_to_pos([...next_pos], next_ang, false, next_sz, aspect_correction);
            let curr_col = [stroke.colours[i * 3], stroke.colours[i * 3 + 1], stroke.colours[i * 3 + 2]];
            let curr_opacity = stroke.opacities[i];
            let next_col = [stroke.colours[i * 3 + 3], stroke.colours[i * 3 + 4], stroke.colours[i * 3 + 5]];
            let next_opacity = stroke.opacities[i + 1];
            const curr_v = i / iters;
            const next_v = (i + 1) / iters;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = next_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = curr_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = curr_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_left[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = next_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_opacity;
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_right[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[0];
            brush_buffer.buffs[0].cpu_buff[idx] = next_pos_right[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[1];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_col[2];
            brush_buffer.buffs[0].cpu_buff[idx] = next_v;
            brush_buffer.buffs[1].cpu_buff[idx++] = next_opacity;
        }
        brush_buffer.buffs[0].sz += iters * 6 * 4;
        brush_buffer.buffs[1].sz += iters * 6 * 4;
        this.recorded_drawcalls.push(this.brush_buffer.buffs[0].sz);
    }
    fill_buff_for_triangulated_brush(stroke) {
        const brush_buffer = this.brush_buffer;
        const { colours, opacities, positions } = stroke;
        const iters = positions.length / 2 - 1;
        let idx = brush_buffer.buffs[0].sz;
        for (let i = 0; i < iters; i++) {
            let u = 0;
            let v = 0;
            brush_buffer.buffs[0].cpu_buff[idx] = positions[0];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[0];
            brush_buffer.buffs[0].cpu_buff[idx] = positions[1];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[1];
            brush_buffer.buffs[0].cpu_buff[idx] = i / (iters + 1);
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[2];
            brush_buffer.buffs[0].cpu_buff[idx] = 0;
            brush_buffer.buffs[1].cpu_buff[idx++] = opacities[1];
            brush_buffer.buffs[0].cpu_buff[idx] = positions[i * 2];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3];
            brush_buffer.buffs[0].cpu_buff[idx] = positions[i * 2 + 1];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3 + 1];
            brush_buffer.buffs[0].cpu_buff[idx] = i / (iters + 1);
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3 + 2];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = opacities[i];
            brush_buffer.buffs[0].cpu_buff[idx] = positions[i * 2 + 2];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3 + 3];
            brush_buffer.buffs[0].cpu_buff[idx] = positions[i * 2 + 3];
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3 + 4];
            brush_buffer.buffs[0].cpu_buff[idx] = (i + 1) / (iters + 1);
            brush_buffer.buffs[1].cpu_buff[idx++] = colours[i * 3 + 5];
            brush_buffer.buffs[0].cpu_buff[idx] = 1;
            brush_buffer.buffs[1].cpu_buff[idx++] = opacities[i + 1];
        }
        brush_buffer.buffs[0].sz += iters * 3 * 4;
        brush_buffer.buffs[1].sz += iters * 3 * 4;
        this.recorded_drawcalls.push(this.brush_buffer.buffs[0].sz);
    }
    push_any_stroke(stroke) {
        if (stroke.brush_type === BrushType.Blobs) {
            this.fill_buff_for_blob_brush(stroke);
        }
        else if (stroke.brush_type === BrushType.Long) {
            this.fill_buff_for_long_brush(stroke);
        }
        else if (stroke.brush_type === BrushType.Tri) {
            this.fill_buff_for_triangulated_brush(stroke);
        }
    }
    draw_stroke_idx(idx) {
        const draw_start = idx === 0 ? 0 : this.recorded_drawcalls[idx - 1];
        const draw_cnt = idx === 0 ? this.recorded_drawcalls[0] : this.recorded_drawcalls[idx] - this.recorded_drawcalls[idx - 1];
        drawer_gl.drawArrays(drawer_gl.TRIANGLES, draw_start / 4, draw_cnt / 4);
    }
}

;// CONCATENATED MODULE: ./src/components/App.svelte
/* src/components/App.svelte generated by Svelte v4.0.1 */


const { Object: App_svelte_Object_1, console: App_svelte_console_1 } = globals;



































const App_svelte_file = "src/components/App.svelte";

function App_svelte_add_css(target) {
	append_styles(target, "svelte-b54tbn", "*{color:white;font-family:\"JetBrains Mono\";font-weight:900}main.svelte-b54tbn.svelte-b54tbn.svelte-b54tbn{width:100%;height:100%;display:flex;flex-direction:column}main.svelte-b54tbn #bar-container.svelte-b54tbn.svelte-b54tbn{width:100%;position:absolute;display:flex;flex-direction:column}main.svelte-b54tbn #bar-container #bar.svelte-b54tbn.svelte-b54tbn{z-index:0;flex-wrap:wrap;background:black;width:100%;display:flex;align-items:center}main.svelte-b54tbn #bar-container #bar.svelte-b54tbn>div{max-height:4rem;height:100%;margin-right:0.25rem;z-index:1}main.svelte-b54tbn #bar-container #bar.svelte-b54tbn>div:not(:first-of-type){margin-left:0.25rem}main.svelte-b54tbn #bar-container #bar.svelte-b54tbn>.svelte-b54tbn:last-of-type{margin-left:auto;margin-right:0px}main.svelte-b54tbn canvas.svelte-b54tbn.svelte-b54tbn{width:100%;height:100%;display:block;margin:auto;padding:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXBwLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL3NwbHVuZ2Uvc3BsdW5nZS9zcmMvY29tcG9uZW50cy9BcHAuc3ZlbHRlIl19 */");
}

// (67:2) <SemiModal bind:this={chaosSemiModal} knob={chaosKnob}>
function create_default_slot_2(ctx) {
	let knob0;
	let updating_value;
	let t0;
	let knob1;
	let updating_value_1;
	let t1;
	let knob2;
	let updating_value_2;
	let t2;
	let knob3;
	let updating_value_3;
	let current;

	function knob0_value_binding_1(value) {
		/*knob0_value_binding_1*/ ctx[61](value);
	}

	let knob0_props = { title: 'Chaos L' };

	if (/*curr_brush*/ ctx[25].chaos_lch[0] !== void 0) {
		knob0_props.value = /*curr_brush*/ ctx[25].chaos_lch[0];
	}

	knob0 = new Knob_svelte({ props: knob0_props, $$inline: true });
	binding_callbacks.push(() => bind(knob0, 'value', knob0_value_binding_1));

	function knob1_value_binding_1(value) {
		/*knob1_value_binding_1*/ ctx[62](value);
	}

	let knob1_props = { title: 'Chaos C' };

	if (/*curr_brush*/ ctx[25].chaos_lch[1] !== void 0) {
		knob1_props.value = /*curr_brush*/ ctx[25].chaos_lch[1];
	}

	knob1 = new Knob_svelte({ props: knob1_props, $$inline: true });
	binding_callbacks.push(() => bind(knob1, 'value', knob1_value_binding_1));

	function knob2_value_binding_1(value) {
		/*knob2_value_binding_1*/ ctx[63](value);
	}

	let knob2_props = { title: 'Chaos H' };

	if (/*curr_brush*/ ctx[25].chaos_lch[2] !== void 0) {
		knob2_props.value = /*curr_brush*/ ctx[25].chaos_lch[2];
	}

	knob2 = new Knob_svelte({ props: knob2_props, $$inline: true });
	binding_callbacks.push(() => bind(knob2, 'value', knob2_value_binding_1));

	function knob3_value_binding(value) {
		/*knob3_value_binding*/ ctx[64](value);
	}

	let knob3_props = { title: 'Chaos Speed' };

	if (/*curr_brush*/ ctx[25].chaos_speed !== void 0) {
		knob3_props.value = /*curr_brush*/ ctx[25].chaos_speed;
	}

	knob3 = new Knob_svelte({ props: knob3_props, $$inline: true });
	binding_callbacks.push(() => bind(knob3, 'value', knob3_value_binding));

	const block = {
		c: function create() {
			create_component(knob0.$$.fragment);
			t0 = space();
			create_component(knob1.$$.fragment);
			t1 = space();
			create_component(knob2.$$.fragment);
			t2 = space();
			create_component(knob3.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(knob0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(knob1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(knob2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(knob3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const knob0_changes = {};

			if (!updating_value && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value = true;
				knob0_changes.value = /*curr_brush*/ ctx[25].chaos_lch[0];
				add_flush_callback(() => updating_value = false);
			}

			knob0.$set(knob0_changes);
			const knob1_changes = {};

			if (!updating_value_1 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_1 = true;
				knob1_changes.value = /*curr_brush*/ ctx[25].chaos_lch[1];
				add_flush_callback(() => updating_value_1 = false);
			}

			knob1.$set(knob1_changes);
			const knob2_changes = {};

			if (!updating_value_2 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_2 = true;
				knob2_changes.value = /*curr_brush*/ ctx[25].chaos_lch[2];
				add_flush_callback(() => updating_value_2 = false);
			}

			knob2.$set(knob2_changes);
			const knob3_changes = {};

			if (!updating_value_3 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_3 = true;
				knob3_changes.value = /*curr_brush*/ ctx[25].chaos_speed;
				add_flush_callback(() => updating_value_3 = false);
			}

			knob3.$set(knob3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(knob0.$$.fragment, local);
			transitions_transition_in(knob1.$$.fragment, local);
			transitions_transition_in(knob2.$$.fragment, local);
			transitions_transition_in(knob3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(knob0.$$.fragment, local);
			transitions_transition_out(knob1.$$.fragment, local);
			transitions_transition_out(knob2.$$.fragment, local);
			transitions_transition_out(knob3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
				detach_dev(t2);
			}

			destroy_component(knob0, detaching);
			destroy_component(knob1, detaching);
			destroy_component(knob2, detaching);
			destroy_component(knob3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(67:2) <SemiModal bind:this={chaosSemiModal} knob={chaosKnob}>",
		ctx
	});

	return block;
}

// (73:2) <SemiModal bind:this={dynamicsSemiModal} knob={dynamicsKnob}>
function create_default_slot_1(ctx) {
	let knob0;
	let updating_value;
	let t0;
	let knob1;
	let updating_value_1;
	let t1;
	let knob2;
	let updating_value_2;
	let t2;
	let knob3;
	let updating_value_3;
	let t3;
	let knob4;
	let updating_value_4;
	let t4;
	let knob5;
	let updating_value_5;
	let current;

	function knob0_value_binding_2(value) {
		/*knob0_value_binding_2*/ ctx[66](value);
	}

	let knob0_props = { title: 'Opacity min' };

	if (/*curr_brush*/ ctx[25].stroke_opacity_dynamics[0] !== void 0) {
		knob0_props.value = /*curr_brush*/ ctx[25].stroke_opacity_dynamics[0];
	}

	knob0 = new Knob_svelte({ props: knob0_props, $$inline: true });
	binding_callbacks.push(() => bind(knob0, 'value', knob0_value_binding_2));

	function knob1_value_binding_2(value) {
		/*knob1_value_binding_2*/ ctx[67](value);
	}

	let knob1_props = { title: 'Opacity max' };

	if (/*curr_brush*/ ctx[25].stroke_opacity_dynamics[1] !== void 0) {
		knob1_props.value = /*curr_brush*/ ctx[25].stroke_opacity_dynamics[1];
	}

	knob1 = new Knob_svelte({ props: knob1_props, $$inline: true });
	binding_callbacks.push(() => bind(knob1, 'value', knob1_value_binding_2));

	function knob2_value_binding_2(value) {
		/*knob2_value_binding_2*/ ctx[68](value);
	}

	let knob2_props = { title: 'Size min' };

	if (/*curr_brush*/ ctx[25].stroke_size_dynamics[0] !== void 0) {
		knob2_props.value = /*curr_brush*/ ctx[25].stroke_size_dynamics[0];
	}

	knob2 = new Knob_svelte({ props: knob2_props, $$inline: true });
	binding_callbacks.push(() => bind(knob2, 'value', knob2_value_binding_2));

	function knob3_value_binding_1(value) {
		/*knob3_value_binding_1*/ ctx[69](value);
	}

	let knob3_props = { title: 'Size max' };

	if (/*curr_brush*/ ctx[25].stroke_size_dynamics[1] !== void 0) {
		knob3_props.value = /*curr_brush*/ ctx[25].stroke_size_dynamics[1];
	}

	knob3 = new Knob_svelte({ props: knob3_props, $$inline: true });
	binding_callbacks.push(() => bind(knob3, 'value', knob3_value_binding_1));

	function knob4_value_binding(value) {
		/*knob4_value_binding*/ ctx[70](value);
	}

	let knob4_props = { title: 'Rot jitt' };

	if (/*curr_brush*/ ctx[25].rot_jitter !== void 0) {
		knob4_props.value = /*curr_brush*/ ctx[25].rot_jitter;
	}

	knob4 = new Knob_svelte({ props: knob4_props, $$inline: true });
	binding_callbacks.push(() => bind(knob4, 'value', knob4_value_binding));

	function knob5_value_binding(value) {
		/*knob5_value_binding*/ ctx[71](value);
	}

	let knob5_props = { title: 'Pos jitt' };

	if (/*curr_brush*/ ctx[25].pos_jitter !== void 0) {
		knob5_props.value = /*curr_brush*/ ctx[25].pos_jitter;
	}

	knob5 = new Knob_svelte({ props: knob5_props, $$inline: true });
	binding_callbacks.push(() => bind(knob5, 'value', knob5_value_binding));

	const block = {
		c: function create() {
			create_component(knob0.$$.fragment);
			t0 = space();
			create_component(knob1.$$.fragment);
			t1 = space();
			create_component(knob2.$$.fragment);
			t2 = space();
			create_component(knob3.$$.fragment);
			t3 = space();
			create_component(knob4.$$.fragment);
			t4 = space();
			create_component(knob5.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(knob0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(knob1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(knob2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(knob3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(knob4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(knob5, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const knob0_changes = {};

			if (!updating_value && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value = true;
				knob0_changes.value = /*curr_brush*/ ctx[25].stroke_opacity_dynamics[0];
				add_flush_callback(() => updating_value = false);
			}

			knob0.$set(knob0_changes);
			const knob1_changes = {};

			if (!updating_value_1 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_1 = true;
				knob1_changes.value = /*curr_brush*/ ctx[25].stroke_opacity_dynamics[1];
				add_flush_callback(() => updating_value_1 = false);
			}

			knob1.$set(knob1_changes);
			const knob2_changes = {};

			if (!updating_value_2 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_2 = true;
				knob2_changes.value = /*curr_brush*/ ctx[25].stroke_size_dynamics[0];
				add_flush_callback(() => updating_value_2 = false);
			}

			knob2.$set(knob2_changes);
			const knob3_changes = {};

			if (!updating_value_3 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_3 = true;
				knob3_changes.value = /*curr_brush*/ ctx[25].stroke_size_dynamics[1];
				add_flush_callback(() => updating_value_3 = false);
			}

			knob3.$set(knob3_changes);
			const knob4_changes = {};

			if (!updating_value_4 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_4 = true;
				knob4_changes.value = /*curr_brush*/ ctx[25].rot_jitter;
				add_flush_callback(() => updating_value_4 = false);
			}

			knob4.$set(knob4_changes);
			const knob5_changes = {};

			if (!updating_value_5 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_5 = true;
				knob5_changes.value = /*curr_brush*/ ctx[25].pos_jitter;
				add_flush_callback(() => updating_value_5 = false);
			}

			knob5.$set(knob5_changes);
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(knob0.$$.fragment, local);
			transitions_transition_in(knob1.$$.fragment, local);
			transitions_transition_in(knob2.$$.fragment, local);
			transitions_transition_in(knob3.$$.fragment, local);
			transitions_transition_in(knob4.$$.fragment, local);
			transitions_transition_in(knob5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(knob0.$$.fragment, local);
			transitions_transition_out(knob1.$$.fragment, local);
			transitions_transition_out(knob2.$$.fragment, local);
			transitions_transition_out(knob3.$$.fragment, local);
			transitions_transition_out(knob4.$$.fragment, local);
			transitions_transition_out(knob5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
				detach_dev(t2);
				detach_dev(t3);
				detach_dev(t4);
			}

			destroy_component(knob0, detaching);
			destroy_component(knob1, detaching);
			destroy_component(knob2, detaching);
			destroy_component(knob3, detaching);
			destroy_component(knob4, detaching);
			destroy_component(knob5, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(73:2) <SemiModal bind:this={dynamicsSemiModal} knob={dynamicsKnob}>",
		ctx
	});

	return block;
}

// (81:2) <SemiModal bind:this={texDynamicsSemiModal} knob={texDynamicsKnob}>
function create_default_slot(ctx) {
	let knob0;
	let updating_value;
	let t0;
	let knob1;
	let updating_value_1;
	let t1;
	let knob2;
	let updating_value_2;
	let t2;
	let knob3;
	let updating_value_3;
	let t3;
	let knob4;
	let updating_value_4;
	let t4;
	let knob5;
	let updating_value_5;
	let t5;
	let knob6;
	let updating_value_6;
	let t6;
	let texturewidget;
	let updating_brush_textures;
	let updating_selected_brush_texture;
	let current;

	function knob0_value_binding_3(value) {
		/*knob0_value_binding_3*/ ctx[73](value);
	}

	let knob0_props = { title: 'Stretch X' };

	if (/*curr_brush*/ ctx[25].tex_stretch[0] !== void 0) {
		knob0_props.value = /*curr_brush*/ ctx[25].tex_stretch[0];
	}

	knob0 = new Knob_svelte({ props: knob0_props, $$inline: true });
	binding_callbacks.push(() => bind(knob0, 'value', knob0_value_binding_3));

	function knob1_value_binding_3(value) {
		/*knob1_value_binding_3*/ ctx[74](value);
	}

	let knob1_props = { title: 'Stretch Y' };

	if (/*curr_brush*/ ctx[25].tex_stretch[1] !== void 0) {
		knob1_props.value = /*curr_brush*/ ctx[25].tex_stretch[1];
	}

	knob1 = new Knob_svelte({ props: knob1_props, $$inline: true });
	binding_callbacks.push(() => bind(knob1, 'value', knob1_value_binding_3));

	function knob2_value_binding_3(value) {
		/*knob2_value_binding_3*/ ctx[75](value);
	}

	let knob2_props = { title: 'Noise Stretch X' };

	if (/*curr_brush*/ ctx[25].noise_stretch[0] !== void 0) {
		knob2_props.value = /*curr_brush*/ ctx[25].noise_stretch[0];
	}

	knob2 = new Knob_svelte({ props: knob2_props, $$inline: true });
	binding_callbacks.push(() => bind(knob2, 'value', knob2_value_binding_3));

	function knob3_value_binding_2(value) {
		/*knob3_value_binding_2*/ ctx[76](value);
	}

	let knob3_props = { title: 'Noise Stretch Y' };

	if (/*curr_brush*/ ctx[25].noise_stretch[1] !== void 0) {
		knob3_props.value = /*curr_brush*/ ctx[25].noise_stretch[1];
	}

	knob3 = new Knob_svelte({ props: knob3_props, $$inline: true });
	binding_callbacks.push(() => bind(knob3, 'value', knob3_value_binding_2));

	function knob4_value_binding_1(value) {
		/*knob4_value_binding_1*/ ctx[77](value);
	}

	let knob4_props = { title: 'Tex V' };

	if (/*curr_brush*/ ctx[25].tex_lch_dynamics[0] !== void 0) {
		knob4_props.value = /*curr_brush*/ ctx[25].tex_lch_dynamics[0];
	}

	knob4 = new Knob_svelte({ props: knob4_props, $$inline: true });
	binding_callbacks.push(() => bind(knob4, 'value', knob4_value_binding_1));

	function knob5_value_binding_1(value) {
		/*knob5_value_binding_1*/ ctx[78](value);
	}

	let knob5_props = { title: 'Tex S' };

	if (/*curr_brush*/ ctx[25].tex_lch_dynamics[1] !== void 0) {
		knob5_props.value = /*curr_brush*/ ctx[25].tex_lch_dynamics[1];
	}

	knob5 = new Knob_svelte({ props: knob5_props, $$inline: true });
	binding_callbacks.push(() => bind(knob5, 'value', knob5_value_binding_1));

	function knob6_value_binding(value) {
		/*knob6_value_binding*/ ctx[79](value);
	}

	let knob6_props = { title: 'Tex H' };

	if (/*curr_brush*/ ctx[25].tex_lch_dynamics[2] !== void 0) {
		knob6_props.value = /*curr_brush*/ ctx[25].tex_lch_dynamics[2];
	}

	knob6 = new Knob_svelte({ props: knob6_props, $$inline: true });
	binding_callbacks.push(() => bind(knob6, 'value', knob6_value_binding));

	function texturewidget_brush_textures_binding(value) {
		/*texturewidget_brush_textures_binding*/ ctx[80](value);
	}

	function texturewidget_selected_brush_texture_binding(value) {
		/*texturewidget_selected_brush_texture_binding*/ ctx[81](value);
	}

	let texturewidget_props = {};

	if (/*brush_textures*/ ctx[19] !== void 0) {
		texturewidget_props.brush_textures = /*brush_textures*/ ctx[19];
	}

	if (/*curr_brush*/ ctx[25].selected_brush_texture !== void 0) {
		texturewidget_props.selected_brush_texture = /*curr_brush*/ ctx[25].selected_brush_texture;
	}

	texturewidget = new TextureWidget_svelte({
			props: texturewidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(texturewidget, 'brush_textures', texturewidget_brush_textures_binding));
	binding_callbacks.push(() => bind(texturewidget, 'selected_brush_texture', texturewidget_selected_brush_texture_binding));

	const block = {
		c: function create() {
			create_component(knob0.$$.fragment);
			t0 = space();
			create_component(knob1.$$.fragment);
			t1 = space();
			create_component(knob2.$$.fragment);
			t2 = space();
			create_component(knob3.$$.fragment);
			t3 = space();
			create_component(knob4.$$.fragment);
			t4 = space();
			create_component(knob5.$$.fragment);
			t5 = space();
			create_component(knob6.$$.fragment);
			t6 = space();
			create_component(texturewidget.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(knob0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(knob1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(knob2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(knob3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(knob4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(knob5, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(knob6, target, anchor);
			insert_dev(target, t6, anchor);
			mount_component(texturewidget, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const knob0_changes = {};

			if (!updating_value && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value = true;
				knob0_changes.value = /*curr_brush*/ ctx[25].tex_stretch[0];
				add_flush_callback(() => updating_value = false);
			}

			knob0.$set(knob0_changes);
			const knob1_changes = {};

			if (!updating_value_1 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_1 = true;
				knob1_changes.value = /*curr_brush*/ ctx[25].tex_stretch[1];
				add_flush_callback(() => updating_value_1 = false);
			}

			knob1.$set(knob1_changes);
			const knob2_changes = {};

			if (!updating_value_2 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_2 = true;
				knob2_changes.value = /*curr_brush*/ ctx[25].noise_stretch[0];
				add_flush_callback(() => updating_value_2 = false);
			}

			knob2.$set(knob2_changes);
			const knob3_changes = {};

			if (!updating_value_3 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_3 = true;
				knob3_changes.value = /*curr_brush*/ ctx[25].noise_stretch[1];
				add_flush_callback(() => updating_value_3 = false);
			}

			knob3.$set(knob3_changes);
			const knob4_changes = {};

			if (!updating_value_4 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_4 = true;
				knob4_changes.value = /*curr_brush*/ ctx[25].tex_lch_dynamics[0];
				add_flush_callback(() => updating_value_4 = false);
			}

			knob4.$set(knob4_changes);
			const knob5_changes = {};

			if (!updating_value_5 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_5 = true;
				knob5_changes.value = /*curr_brush*/ ctx[25].tex_lch_dynamics[1];
				add_flush_callback(() => updating_value_5 = false);
			}

			knob5.$set(knob5_changes);
			const knob6_changes = {};

			if (!updating_value_6 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_6 = true;
				knob6_changes.value = /*curr_brush*/ ctx[25].tex_lch_dynamics[2];
				add_flush_callback(() => updating_value_6 = false);
			}

			knob6.$set(knob6_changes);
			const texturewidget_changes = {};

			if (!updating_brush_textures && dirty[0] & /*brush_textures*/ 524288) {
				updating_brush_textures = true;
				texturewidget_changes.brush_textures = /*brush_textures*/ ctx[19];
				add_flush_callback(() => updating_brush_textures = false);
			}

			if (!updating_selected_brush_texture && dirty[0] & /*curr_brush*/ 33554432) {
				updating_selected_brush_texture = true;
				texturewidget_changes.selected_brush_texture = /*curr_brush*/ ctx[25].selected_brush_texture;
				add_flush_callback(() => updating_selected_brush_texture = false);
			}

			texturewidget.$set(texturewidget_changes);
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(knob0.$$.fragment, local);
			transitions_transition_in(knob1.$$.fragment, local);
			transitions_transition_in(knob2.$$.fragment, local);
			transitions_transition_in(knob3.$$.fragment, local);
			transitions_transition_in(knob4.$$.fragment, local);
			transitions_transition_in(knob5.$$.fragment, local);
			transitions_transition_in(knob6.$$.fragment, local);
			transitions_transition_in(texturewidget.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(knob0.$$.fragment, local);
			transitions_transition_out(knob1.$$.fragment, local);
			transitions_transition_out(knob2.$$.fragment, local);
			transitions_transition_out(knob3.$$.fragment, local);
			transitions_transition_out(knob4.$$.fragment, local);
			transitions_transition_out(knob5.$$.fragment, local);
			transitions_transition_out(knob6.$$.fragment, local);
			transitions_transition_out(texturewidget.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
				detach_dev(t2);
				detach_dev(t3);
				detach_dev(t4);
				detach_dev(t5);
				detach_dev(t6);
			}

			destroy_component(knob0, detaching);
			destroy_component(knob1, detaching);
			destroy_component(knob2, detaching);
			destroy_component(knob3, detaching);
			destroy_component(knob4, detaching);
			destroy_component(knob5, detaching);
			destroy_component(knob6, detaching);
			destroy_component(texturewidget, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(81:2) <SemiModal bind:this={texDynamicsSemiModal} knob={texDynamicsKnob}>",
		ctx
	});

	return block;
}

function App_svelte_create_fragment(ctx) {
	let main;
	let div2;
	let div1;
	let knob0;
	let updating_value;
	let t0;
	let knob1;
	let updating_value_1;
	let t1;
	let knob2;
	let updating_value_2;
	let t2;
	let brushsizewidget;
	let updating_brush_sz;
	let updating_dragging;
	let updating_stopped_dragging;
	let t3;
	let div0;
	let rgbsliders;
	let updating_colour;
	let t4;
	let colourdisplay;
	let updating_colour_1;
	let updating_update_display;
	let t5;
	let brushtypewidget;
	let updating_curr_brush;
	let t6;
	let brushpresetwidget;
	let updating_brush_presets;
	let updating_selected_brush_preset;
	let t7;
	let undoredowidget;
	let t8;
	let gallerywidget;
	let updating_current_project;
	let updating_resize_project;
	let updating_project_has_been_modified;
	let updating_is_safe_to_switch_to_new_project;
	let t9;
	let pickcolourwidget;
	let updating_picking;
	let updating_just_finished_pick;
	let t10;
	let blendingcolourspacewidget;
	let updating_selected_colour_space;
	let t11;
	let floatingmodal;
	let t12;
	let semimodal0;
	let t13;
	let semimodal1;
	let t14;
	let semimodal2;
	let t15;
	let canvas;
	let current;
	let mounted;
	let dispose;

	function knob0_value_binding(value) {
		/*knob0_value_binding*/ ctx[32](value);
	}

	let knob0_props = {
		title: 'Chaos',
		triggerModal: /*openModal*/ ctx[30],
		modal: /*chaosSemiModal*/ ctx[1]
	};

	if (/*curr_brush*/ ctx[25].chaos !== void 0) {
		knob0_props.value = /*curr_brush*/ ctx[25].chaos;
	}

	knob0 = new Knob_svelte({ props: knob0_props, $$inline: true });
	/*knob0_binding*/ ctx[31](knob0);
	binding_callbacks.push(() => bind(knob0, 'value', knob0_value_binding));

	function knob1_value_binding(value) {
		/*knob1_value_binding*/ ctx[34](value);
	}

	let knob1_props = {
		title: 'Dynamics',
		triggerModal: /*openModal*/ ctx[30],
		modal: /*dynamicsSemiModal*/ ctx[2]
	};

	if (/*curr_brush*/ ctx[25].dynamics !== void 0) {
		knob1_props.value = /*curr_brush*/ ctx[25].dynamics;
	}

	knob1 = new Knob_svelte({ props: knob1_props, $$inline: true });
	/*knob1_binding*/ ctx[33](knob1);
	binding_callbacks.push(() => bind(knob1, 'value', knob1_value_binding));

	function knob2_value_binding(value) {
		/*knob2_value_binding*/ ctx[36](value);
	}

	let knob2_props = {
		title: 'Tex',
		triggerModal: /*openModal*/ ctx[30],
		modal: /*texDynamicsSemiModal*/ ctx[3]
	};

	if (/*curr_brush*/ ctx[25].tex_dynamics !== void 0) {
		knob2_props.value = /*curr_brush*/ ctx[25].tex_dynamics;
	}

	knob2 = new Knob_svelte({ props: knob2_props, $$inline: true });
	/*knob2_binding*/ ctx[35](knob2);
	binding_callbacks.push(() => bind(knob2, 'value', knob2_value_binding));

	function brushsizewidget_brush_sz_binding(value) {
		/*brushsizewidget_brush_sz_binding*/ ctx[37](value);
	}

	function brushsizewidget_dragging_binding(value) {
		/*brushsizewidget_dragging_binding*/ ctx[38](value);
	}

	function brushsizewidget_stopped_dragging_binding(value) {
		/*brushsizewidget_stopped_dragging_binding*/ ctx[39](value);
	}

	let brushsizewidget_props = {};

	if (/*brush_sz*/ ctx[24] !== void 0) {
		brushsizewidget_props.brush_sz = /*brush_sz*/ ctx[24];
	}

	if (/*brush_size_widget_dragging*/ ctx[7] !== void 0) {
		brushsizewidget_props.dragging = /*brush_size_widget_dragging*/ ctx[7];
	}

	if (/*brush_size_widget_stopped_dragging*/ ctx[8] !== void 0) {
		brushsizewidget_props.stopped_dragging = /*brush_size_widget_stopped_dragging*/ ctx[8];
	}

	brushsizewidget = new BrushSizeWidget_svelte({
			props: brushsizewidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(brushsizewidget, 'brush_sz', brushsizewidget_brush_sz_binding));
	binding_callbacks.push(() => bind(brushsizewidget, 'dragging', brushsizewidget_dragging_binding));
	binding_callbacks.push(() => bind(brushsizewidget, 'stopped_dragging', brushsizewidget_stopped_dragging_binding));

	function rgbsliders_colour_binding(value) {
		/*rgbsliders_colour_binding*/ ctx[40](value);
	}

	let rgbsliders_props = {};

	if (/*stroke_col*/ ctx[23] !== void 0) {
		rgbsliders_props.colour = /*stroke_col*/ ctx[23];
	}

	rgbsliders = new RGBSliders_svelte({ props: rgbsliders_props, $$inline: true });
	binding_callbacks.push(() => bind(rgbsliders, 'colour', rgbsliders_colour_binding));

	function colourdisplay_colour_binding(value) {
		/*colourdisplay_colour_binding*/ ctx[41](value);
	}

	function colourdisplay_update_display_binding(value) {
		/*colourdisplay_update_display_binding*/ ctx[42](value);
	}

	let colourdisplay_props = {};

	if (/*stroke_col*/ ctx[23] !== void 0) {
		colourdisplay_props.colour = /*stroke_col*/ ctx[23];
	}

	if (/*trigger_colour_display_update*/ ctx[28] !== void 0) {
		colourdisplay_props.update_display = /*trigger_colour_display_update*/ ctx[28];
	}

	colourdisplay = new ColourDisplay_svelte({
			props: colourdisplay_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(colourdisplay, 'colour', colourdisplay_colour_binding));
	binding_callbacks.push(() => bind(colourdisplay, 'update_display', colourdisplay_update_display_binding));

	function brushtypewidget_curr_brush_binding(value) {
		/*brushtypewidget_curr_brush_binding*/ ctx[45](value);
	}

	let brushtypewidget_props = {};

	if (/*curr_brush*/ ctx[25] !== void 0) {
		brushtypewidget_props.curr_brush = /*curr_brush*/ ctx[25];
	}

	brushtypewidget = new BrushTypeWidget_svelte({
			props: brushtypewidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(brushtypewidget, 'curr_brush', brushtypewidget_curr_brush_binding));

	function brushpresetwidget_brush_presets_binding(value) {
		/*brushpresetwidget_brush_presets_binding*/ ctx[46](value);
	}

	function brushpresetwidget_selected_brush_preset_binding(value) {
		/*brushpresetwidget_selected_brush_preset_binding*/ ctx[47](value);
	}

	let brushpresetwidget_props = {};

	if (/*brush_presets*/ ctx[18] !== void 0) {
		brushpresetwidget_props.brush_presets = /*brush_presets*/ ctx[18];
	}

	if (/*curr_brush*/ ctx[25] !== void 0) {
		brushpresetwidget_props.selected_brush_preset = /*curr_brush*/ ctx[25];
	}

	brushpresetwidget = new BrushPresetWidget_svelte({
			props: brushpresetwidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(brushpresetwidget, 'brush_presets', brushpresetwidget_brush_presets_binding));
	binding_callbacks.push(() => bind(brushpresetwidget, 'selected_brush_preset', brushpresetwidget_selected_brush_preset_binding));

	undoredowidget = new UndoRedoWidget_svelte({
			props: {
				undo: /*func*/ ctx[48],
				redo: /*func_1*/ ctx[49]
			},
			$$inline: true
		});

	function gallerywidget_current_project_binding(value) {
		/*gallerywidget_current_project_binding*/ ctx[53](value);
	}

	function gallerywidget_resize_project_binding(value) {
		/*gallerywidget_resize_project_binding*/ ctx[54](value);
	}

	function gallerywidget_project_has_been_modified_binding(value) {
		/*gallerywidget_project_has_been_modified_binding*/ ctx[55](value);
	}

	function gallerywidget_is_safe_to_switch_to_new_project_binding(value) {
		/*gallerywidget_is_safe_to_switch_to_new_project_binding*/ ctx[56](value);
	}

	let gallerywidget_props = {
		get_current_canvas_as_image: /*func_2*/ ctx[50],
		new_project: /*func_3*/ ctx[51],
		load_project: /*func_4*/ ctx[52]
	};

	if (/*project*/ ctx[20] !== void 0) {
		gallerywidget_props.current_project = /*project*/ ctx[20];
	}

	if (/*resize_project*/ ctx[27] !== void 0) {
		gallerywidget_props.resize_project = /*resize_project*/ ctx[27];
	}

	if (/*project_has_been_modified*/ ctx[16] !== void 0) {
		gallerywidget_props.project_has_been_modified = /*project_has_been_modified*/ ctx[16];
	}

	if (/*is_safe_to_switch_to_new_project*/ ctx[17] !== void 0) {
		gallerywidget_props.is_safe_to_switch_to_new_project = /*is_safe_to_switch_to_new_project*/ ctx[17];
	}

	gallerywidget = new GalleryWidget_svelte({
			props: gallerywidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(gallerywidget, 'current_project', gallerywidget_current_project_binding));
	binding_callbacks.push(() => bind(gallerywidget, 'resize_project', gallerywidget_resize_project_binding));
	binding_callbacks.push(() => bind(gallerywidget, 'project_has_been_modified', gallerywidget_project_has_been_modified_binding));
	binding_callbacks.push(() => bind(gallerywidget, 'is_safe_to_switch_to_new_project', gallerywidget_is_safe_to_switch_to_new_project_binding));

	function pickcolourwidget_picking_binding(value) {
		/*pickcolourwidget_picking_binding*/ ctx[58](value);
	}

	function pickcolourwidget_just_finished_pick_binding(value) {
		/*pickcolourwidget_just_finished_pick_binding*/ ctx[59](value);
	}

	let pickcolourwidget_props = { pick_from_canvas: /*func_5*/ ctx[57] };

	if (/*picking*/ ctx[14] !== void 0) {
		pickcolourwidget_props.picking = /*picking*/ ctx[14];
	}

	if (/*just_finished_pick*/ ctx[15] !== void 0) {
		pickcolourwidget_props.just_finished_pick = /*just_finished_pick*/ ctx[15];
	}

	pickcolourwidget = new PickColourWidget_svelte({
			props: pickcolourwidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(pickcolourwidget, 'picking', pickcolourwidget_picking_binding));
	binding_callbacks.push(() => bind(pickcolourwidget, 'just_finished_pick', pickcolourwidget_just_finished_pick_binding));

	function blendingcolourspacewidget_selected_colour_space_binding(value) {
		/*blendingcolourspacewidget_selected_colour_space_binding*/ ctx[60](value);
	}

	let blendingcolourspacewidget_props = {};

	if (/*blending_colour_space*/ ctx[26] !== void 0) {
		blendingcolourspacewidget_props.selected_colour_space = /*blending_colour_space*/ ctx[26];
	}

	blendingcolourspacewidget = new BlendingColourSpaceWidget_svelte({
			props: blendingcolourspacewidget_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(blendingcolourspacewidget, 'selected_colour_space', blendingcolourspacewidget_selected_colour_space_binding));
	floatingmodal = new FloatingModal_svelte({ $$inline: true });

	let semimodal0_props = {
		knob: /*chaosKnob*/ ctx[4],
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	};

	semimodal0 = new SemiModal_svelte({ props: semimodal0_props, $$inline: true });
	/*semimodal0_binding*/ ctx[65](semimodal0);

	let semimodal1_props = {
		knob: /*dynamicsKnob*/ ctx[5],
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	};

	semimodal1 = new SemiModal_svelte({ props: semimodal1_props, $$inline: true });
	/*semimodal1_binding*/ ctx[72](semimodal1);

	let semimodal2_props = {
		knob: /*texDynamicsKnob*/ ctx[6],
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	semimodal2 = new SemiModal_svelte({ props: semimodal2_props, $$inline: true });
	/*semimodal2_binding*/ ctx[82](semimodal2);

	const block = {
		c: function create() {
			main = dom_element("main");
			div2 = dom_element("div");
			div1 = dom_element("div");
			create_component(knob0.$$.fragment);
			t0 = space();
			create_component(knob1.$$.fragment);
			t1 = space();
			create_component(knob2.$$.fragment);
			t2 = space();
			create_component(brushsizewidget.$$.fragment);
			t3 = space();
			div0 = dom_element("div");
			create_component(rgbsliders.$$.fragment);
			t4 = space();
			create_component(colourdisplay.$$.fragment);
			t5 = space();
			create_component(brushtypewidget.$$.fragment);
			t6 = space();
			create_component(brushpresetwidget.$$.fragment);
			t7 = space();
			create_component(undoredowidget.$$.fragment);
			t8 = space();
			create_component(gallerywidget.$$.fragment);
			t9 = space();
			create_component(pickcolourwidget.$$.fragment);
			t10 = space();
			create_component(blendingcolourspacewidget.$$.fragment);
			t11 = space();
			create_component(floatingmodal.$$.fragment);
			t12 = space();
			create_component(semimodal0.$$.fragment);
			t13 = space();
			create_component(semimodal1.$$.fragment);
			t14 = space();
			create_component(semimodal2.$$.fragment);
			t15 = space();
			canvas = dom_element("canvas");
			set_style(div0, "height", "100%");
			set_style(div0, "display", "flex");
			set_style(div0, "aspect-ratio", "6/1");
			attr_dev(div0, "class", "svelte-b54tbn");
			add_location(div0, App_svelte_file, 21, 3, 669);
			attr_dev(div1, "id", "bar");
			attr_dev(div1, "class", "svelte-b54tbn");
			add_location(div1, App_svelte_file, 2, 2, 35);
			attr_dev(div2, "id", "bar-container");
			attr_dev(div2, "class", "svelte-b54tbn");
			add_location(div2, App_svelte_file, 1, 1, 8);
			attr_dev(canvas, "id", "canvas");
			attr_dev(canvas, "class", "svelte-b54tbn");
			add_location(canvas, App_svelte_file, 91, 1, 3918);
			attr_dev(main, "class", "svelte-b54tbn");
			add_location(main, App_svelte_file, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div2);
			append_dev(div2, div1);
			mount_component(knob0, div1, null);
			append_dev(div1, t0);
			mount_component(knob1, div1, null);
			append_dev(div1, t1);
			mount_component(knob2, div1, null);
			append_dev(div1, t2);
			mount_component(brushsizewidget, div1, null);
			append_dev(div1, t3);
			append_dev(div1, div0);
			mount_component(rgbsliders, div0, null);
			append_dev(div0, t4);
			mount_component(colourdisplay, div0, null);
			append_dev(div1, t5);
			mount_component(brushtypewidget, div1, null);
			append_dev(div1, t6);
			mount_component(brushpresetwidget, div1, null);
			append_dev(div1, t7);
			mount_component(undoredowidget, div1, null);
			append_dev(div1, t8);
			mount_component(gallerywidget, div1, null);
			append_dev(div1, t9);
			mount_component(pickcolourwidget, div1, null);
			append_dev(div1, t10);
			mount_component(blendingcolourspacewidget, div1, null);
			append_dev(div1, t11);
			mount_component(floatingmodal, div1, null);
			append_dev(div2, t12);
			mount_component(semimodal0, div2, null);
			append_dev(div2, t13);
			mount_component(semimodal1, div2, null);
			append_dev(div2, t14);
			mount_component(semimodal2, div2, null);
			append_dev(main, t15);
			append_dev(main, canvas);
			/*canvas_binding*/ ctx[83](canvas);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "pointerenter", /*pointerenter_handler*/ ctx[43], false, false, false, false),
					listen_dev(div0, "pointerleave", /*pointerleave_handler*/ ctx[44], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const knob0_changes = {};
			if (dirty[0] & /*chaosSemiModal*/ 2) knob0_changes.modal = /*chaosSemiModal*/ ctx[1];

			if (!updating_value && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value = true;
				knob0_changes.value = /*curr_brush*/ ctx[25].chaos;
				add_flush_callback(() => updating_value = false);
			}

			knob0.$set(knob0_changes);
			const knob1_changes = {};
			if (dirty[0] & /*dynamicsSemiModal*/ 4) knob1_changes.modal = /*dynamicsSemiModal*/ ctx[2];

			if (!updating_value_1 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_1 = true;
				knob1_changes.value = /*curr_brush*/ ctx[25].dynamics;
				add_flush_callback(() => updating_value_1 = false);
			}

			knob1.$set(knob1_changes);
			const knob2_changes = {};
			if (dirty[0] & /*texDynamicsSemiModal*/ 8) knob2_changes.modal = /*texDynamicsSemiModal*/ ctx[3];

			if (!updating_value_2 && dirty[0] & /*curr_brush*/ 33554432) {
				updating_value_2 = true;
				knob2_changes.value = /*curr_brush*/ ctx[25].tex_dynamics;
				add_flush_callback(() => updating_value_2 = false);
			}

			knob2.$set(knob2_changes);
			const brushsizewidget_changes = {};

			if (!updating_brush_sz && dirty[0] & /*brush_sz*/ 16777216) {
				updating_brush_sz = true;
				brushsizewidget_changes.brush_sz = /*brush_sz*/ ctx[24];
				add_flush_callback(() => updating_brush_sz = false);
			}

			if (!updating_dragging && dirty[0] & /*brush_size_widget_dragging*/ 128) {
				updating_dragging = true;
				brushsizewidget_changes.dragging = /*brush_size_widget_dragging*/ ctx[7];
				add_flush_callback(() => updating_dragging = false);
			}

			if (!updating_stopped_dragging && dirty[0] & /*brush_size_widget_stopped_dragging*/ 256) {
				updating_stopped_dragging = true;
				brushsizewidget_changes.stopped_dragging = /*brush_size_widget_stopped_dragging*/ ctx[8];
				add_flush_callback(() => updating_stopped_dragging = false);
			}

			brushsizewidget.$set(brushsizewidget_changes);
			const rgbsliders_changes = {};

			if (!updating_colour && dirty[0] & /*stroke_col*/ 8388608) {
				updating_colour = true;
				rgbsliders_changes.colour = /*stroke_col*/ ctx[23];
				add_flush_callback(() => updating_colour = false);
			}

			rgbsliders.$set(rgbsliders_changes);
			const colourdisplay_changes = {};

			if (!updating_colour_1 && dirty[0] & /*stroke_col*/ 8388608) {
				updating_colour_1 = true;
				colourdisplay_changes.colour = /*stroke_col*/ ctx[23];
				add_flush_callback(() => updating_colour_1 = false);
			}

			if (!updating_update_display && dirty[0] & /*trigger_colour_display_update*/ 268435456) {
				updating_update_display = true;
				colourdisplay_changes.update_display = /*trigger_colour_display_update*/ ctx[28];
				add_flush_callback(() => updating_update_display = false);
			}

			colourdisplay.$set(colourdisplay_changes);
			const brushtypewidget_changes = {};

			if (!updating_curr_brush && dirty[0] & /*curr_brush*/ 33554432) {
				updating_curr_brush = true;
				brushtypewidget_changes.curr_brush = /*curr_brush*/ ctx[25];
				add_flush_callback(() => updating_curr_brush = false);
			}

			brushtypewidget.$set(brushtypewidget_changes);
			const brushpresetwidget_changes = {};

			if (!updating_brush_presets && dirty[0] & /*brush_presets*/ 262144) {
				updating_brush_presets = true;
				brushpresetwidget_changes.brush_presets = /*brush_presets*/ ctx[18];
				add_flush_callback(() => updating_brush_presets = false);
			}

			if (!updating_selected_brush_preset && dirty[0] & /*curr_brush*/ 33554432) {
				updating_selected_brush_preset = true;
				brushpresetwidget_changes.selected_brush_preset = /*curr_brush*/ ctx[25];
				add_flush_callback(() => updating_selected_brush_preset = false);
			}

			brushpresetwidget.$set(brushpresetwidget_changes);
			const undoredowidget_changes = {};
			if (dirty[0] & /*undo_pending*/ 1024) undoredowidget_changes.undo = /*func*/ ctx[48];
			if (dirty[0] & /*redo_pending*/ 2048) undoredowidget_changes.redo = /*func_1*/ ctx[49];
			undoredowidget.$set(undoredowidget_changes);
			const gallerywidget_changes = {};
			if (dirty[0] & /*canvas_read_tex*/ 4194304) gallerywidget_changes.get_current_canvas_as_image = /*func_2*/ ctx[50];
			if (dirty[0] & /*new_project_pending*/ 512) gallerywidget_changes.new_project = /*func_3*/ ctx[51];
			if (dirty[0] & /*project_pending_load*/ 2097152) gallerywidget_changes.load_project = /*func_4*/ ctx[52];

			if (!updating_current_project && dirty[0] & /*project*/ 1048576) {
				updating_current_project = true;
				gallerywidget_changes.current_project = /*project*/ ctx[20];
				add_flush_callback(() => updating_current_project = false);
			}

			if (!updating_resize_project && dirty[0] & /*resize_project*/ 134217728) {
				updating_resize_project = true;
				gallerywidget_changes.resize_project = /*resize_project*/ ctx[27];
				add_flush_callback(() => updating_resize_project = false);
			}

			if (!updating_project_has_been_modified && dirty[0] & /*project_has_been_modified*/ 65536) {
				updating_project_has_been_modified = true;
				gallerywidget_changes.project_has_been_modified = /*project_has_been_modified*/ ctx[16];
				add_flush_callback(() => updating_project_has_been_modified = false);
			}

			if (!updating_is_safe_to_switch_to_new_project && dirty[0] & /*is_safe_to_switch_to_new_project*/ 131072) {
				updating_is_safe_to_switch_to_new_project = true;
				gallerywidget_changes.is_safe_to_switch_to_new_project = /*is_safe_to_switch_to_new_project*/ ctx[17];
				add_flush_callback(() => updating_is_safe_to_switch_to_new_project = false);
			}

			gallerywidget.$set(gallerywidget_changes);
			const pickcolourwidget_changes = {};

			if (!updating_picking && dirty[0] & /*picking*/ 16384) {
				updating_picking = true;
				pickcolourwidget_changes.picking = /*picking*/ ctx[14];
				add_flush_callback(() => updating_picking = false);
			}

			if (!updating_just_finished_pick && dirty[0] & /*just_finished_pick*/ 32768) {
				updating_just_finished_pick = true;
				pickcolourwidget_changes.just_finished_pick = /*just_finished_pick*/ ctx[15];
				add_flush_callback(() => updating_just_finished_pick = false);
			}

			pickcolourwidget.$set(pickcolourwidget_changes);
			const blendingcolourspacewidget_changes = {};

			if (!updating_selected_colour_space && dirty[0] & /*blending_colour_space*/ 67108864) {
				updating_selected_colour_space = true;
				blendingcolourspacewidget_changes.selected_colour_space = /*blending_colour_space*/ ctx[26];
				add_flush_callback(() => updating_selected_colour_space = false);
			}

			blendingcolourspacewidget.$set(blendingcolourspacewidget_changes);
			const semimodal0_changes = {};
			if (dirty[0] & /*chaosKnob*/ 16) semimodal0_changes.knob = /*chaosKnob*/ ctx[4];

			if (dirty[0] & /*curr_brush*/ 33554432 | dirty[3] & /*$$scope*/ 32768) {
				semimodal0_changes.$$scope = { dirty, ctx };
			}

			semimodal0.$set(semimodal0_changes);
			const semimodal1_changes = {};
			if (dirty[0] & /*dynamicsKnob*/ 32) semimodal1_changes.knob = /*dynamicsKnob*/ ctx[5];

			if (dirty[0] & /*curr_brush*/ 33554432 | dirty[3] & /*$$scope*/ 32768) {
				semimodal1_changes.$$scope = { dirty, ctx };
			}

			semimodal1.$set(semimodal1_changes);
			const semimodal2_changes = {};
			if (dirty[0] & /*texDynamicsKnob*/ 64) semimodal2_changes.knob = /*texDynamicsKnob*/ ctx[6];

			if (dirty[0] & /*brush_textures, curr_brush*/ 34078720 | dirty[3] & /*$$scope*/ 32768) {
				semimodal2_changes.$$scope = { dirty, ctx };
			}

			semimodal2.$set(semimodal2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(knob0.$$.fragment, local);
			transitions_transition_in(knob1.$$.fragment, local);
			transitions_transition_in(knob2.$$.fragment, local);
			transitions_transition_in(brushsizewidget.$$.fragment, local);
			transitions_transition_in(rgbsliders.$$.fragment, local);
			transitions_transition_in(colourdisplay.$$.fragment, local);
			transitions_transition_in(brushtypewidget.$$.fragment, local);
			transitions_transition_in(brushpresetwidget.$$.fragment, local);
			transitions_transition_in(undoredowidget.$$.fragment, local);
			transitions_transition_in(gallerywidget.$$.fragment, local);
			transitions_transition_in(pickcolourwidget.$$.fragment, local);
			transitions_transition_in(blendingcolourspacewidget.$$.fragment, local);
			transitions_transition_in(floatingmodal.$$.fragment, local);
			transitions_transition_in(semimodal0.$$.fragment, local);
			transitions_transition_in(semimodal1.$$.fragment, local);
			transitions_transition_in(semimodal2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(knob0.$$.fragment, local);
			transitions_transition_out(knob1.$$.fragment, local);
			transitions_transition_out(knob2.$$.fragment, local);
			transitions_transition_out(brushsizewidget.$$.fragment, local);
			transitions_transition_out(rgbsliders.$$.fragment, local);
			transitions_transition_out(colourdisplay.$$.fragment, local);
			transitions_transition_out(brushtypewidget.$$.fragment, local);
			transitions_transition_out(brushpresetwidget.$$.fragment, local);
			transitions_transition_out(undoredowidget.$$.fragment, local);
			transitions_transition_out(gallerywidget.$$.fragment, local);
			transitions_transition_out(pickcolourwidget.$$.fragment, local);
			transitions_transition_out(blendingcolourspacewidget.$$.fragment, local);
			transitions_transition_out(floatingmodal.$$.fragment, local);
			transitions_transition_out(semimodal0.$$.fragment, local);
			transitions_transition_out(semimodal1.$$.fragment, local);
			transitions_transition_out(semimodal2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(main);
			}

			/*knob0_binding*/ ctx[31](null);
			destroy_component(knob0);
			/*knob1_binding*/ ctx[33](null);
			destroy_component(knob1);
			/*knob2_binding*/ ctx[35](null);
			destroy_component(knob2);
			destroy_component(brushsizewidget);
			destroy_component(rgbsliders);
			destroy_component(colourdisplay);
			destroy_component(brushtypewidget);
			destroy_component(brushpresetwidget);
			destroy_component(undoredowidget);
			destroy_component(gallerywidget);
			destroy_component(pickcolourwidget);
			destroy_component(blendingcolourspacewidget);
			destroy_component(floatingmodal);
			/*semimodal0_binding*/ ctx[65](null);
			destroy_component(semimodal0);
			/*semimodal1_binding*/ ctx[72](null);
			destroy_component(semimodal1);
			/*semimodal2_binding*/ ctx[82](null);
			destroy_component(semimodal2);
			/*canvas_binding*/ ctx[83](null);
			mounted = false;
			utils_run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: App_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const undo_cache_steps = 25;

function App_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('App', slots, []);
	let canvasElement;
	let chaosSemiModal;
	let dynamicsSemiModal;
	let texDynamicsSemiModal;
	let modals = [];
	let chaosKnob;
	let dynamicsKnob;
	let texDynamicsKnob;
	let brush_size_widget_dragging;
	let brush_size_widget_stopped_dragging;
	let new_project_pending = false;
	let undo_pending = false;
	let redo_pending = false;
	let mouse_over_colour_picker = false;
	let mouse_over_colour_picker_finished = false;
	let picking;
	let just_finished_pick;
	let picked_col = [0, 0, 0];
	let project_has_been_modified = false;
	let is_safe_to_switch_to_new_project;
	let full_redraw_needed = false;
	const zoom = window.zoom = Float32Array.from([1]);
	let desired_zoom = 1;
	const panning_temp_pinch = new Float32Array(2);
	let panning = new Float32Array(2);
	let brush_presets = [];

	for (let i = 0; i < 6; i++) {
		brush_presets.push(new BrushPreset());
	}

	let brush_textures = [];
	const hash = new Hash();
	let io;
	let gl;
	let project = new Project();
	let project_pending_load;
	let default_framebuffer;
	let canvas_fb;
	let canvas_read_tex;
	let temp_undo_fb;
	let drawer;
	let ubo;
	let stroke_col = [0.5, 0.4, 0.3, 1];
	let stroke_opacity = 0;
	let brush_rot = [0, 0];
	let brush_pos_ndc_screen = [0, 0];
	let brush_pos_ndc_canvas = [0, 0];
	let brush_sz = [1, 0.2];
	let curr_brush = brush_presets[0];
	let blending_colour_space = BlendingColourSpace.OkLCH;
	let brush_params_mat = new Float32Array(16);
	let resize_project;
	let trigger_colour_display_update;

	const set_shared_uniforms = () => {
		ubo.buff.sz = 0;
		ubo.buff.cpu_buff[0] = canvas_fb._textures[0].res[0];
		ubo.buff.cpu_buff[1] = canvas_fb._textures[0].res[1];
		ubo.buff.cpu_buff[2] = default_framebuffer.textures[0].res[0];
		ubo.buff.cpu_buff[3] = default_framebuffer.textures[0].res[1];
		ubo.buff.cpu_buff[4] = isOnMobile ? 1 : 0;
		ubo.buff.upload();
	};

	const pick_from_canvas = () => {
		let coord = Utils.texture_NDC_to_texture_pixel_coords(Utils.screen_NDC_to_canvas_NDC([...io.mouse_pos], default_framebuffer.textures[0], canvas_read_tex, zoom[0], panning), canvas_read_tex);
		let c = canvas_read_tex.read_back_pixel(coord);
		picked_col = [...c];
		picked_col[0] = c[0] / 255;
		picked_col[1] = c[1] / 255;
		picked_col[2] = c[2] / 255;
		picked_col[0] = pow(picked_col[0], 0.45454545454545);
		picked_col[1] = pow(picked_col[1], 0.45454545454545);
		picked_col[2] = pow(picked_col[2], 0.45454545454545);
		picked_col.pop();
		return c;
	};

	const openModal = modal => {
		for (let m of modals) {
			if (m === modal) {
				if (m.hidden) {
					m.hidden = false;
					m.knob.modalHidden = false;
				} else {
					m.hidden = true;
					m.knob.modalHidden = true;
				}
			} else {
				m.hidden = true;
				m.knob.modalHidden = true;
			}
		}
	};

	const init_web_gl = () => {
		window.isOnMobile = Utils.isOnMobile();

		window.gl = gl = canvasElement.getContext('webgl2', {
			preserveDrawingBuffer: true,
			alpha: false,
			premultipliedAlpha: false,
			antialias: true
		});

		gl.getExtension('OES_texture_float');
		gl.getExtension('OES_texture_float_linear');
		gl.getExtension('EXT_color_buffer_float');
		gl.debugEnabled = "production" === 'development';
		gl.debugEnabled = false;
		init_gl_error_handling();
		const userAgentRes = [canvasElement.clientWidth, canvasElement.clientWidth];
		default_framebuffer = Object.create(Framebuffer.prototype);
		default_framebuffer.default = true;
		default_framebuffer.pongable = false;
		default_framebuffer.needs_pong = false;
		default_framebuffer.pong_idx = 0;
		default_framebuffer._fb = null;
		default_framebuffer._textures = [Object.create(Texture.prototype)];
		default_framebuffer.textures[0].res = [...userAgentRes];
		default_framebuffer.bind();

		canvas_fb = new Framebuffer([
				new Texture([project.canvasRes[0], project.canvasRes[1]], gl.RGBA16F, !isOnMobile)
			],
		true);

		temp_undo_fb = new Framebuffer([
				new Texture([project.canvasRes[0], project.canvasRes[1]], gl.RGBA16F, false)
			],
		false);

		ubo = new UBO();
		window.ubo = ubo;

		resizeIfNeeded(
			canvasElement,
			default_framebuffer,
			userAgentRes,
			e => {
				
			},
			() => {
				set_shared_uniforms();
			}
		);

		set_shared_uniforms();
		gl.disable(gl.CULL_FACE);
		gl.disable(gl.DEPTH_TEST);
		gl.enable(gl.BLEND);
		gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
	};

	const init_other_stuff = async () => {
		window.addEventListener("dragstart", event => {
			event.preventDefault();
		});

		if ("wakeLock" in navigator) {
			try {
				const wakeLock = await navigator.wakeLock.request("screen");
			} catch(_) {
				
			}
		}

		io = new IO();
		document.addEventListener('contextmenu', event => event.preventDefault());
		window.history.pushState(null, null, window.location.href);

		window.addEventListener('popstate', () => {
			window.history.pushState(null, null, window.location.href);
		});

		brush_textures.push(await BrushTexture.create((__webpack_require__(1468)/* ["default"] */ .Z), 0));
		brush_textures.push(await BrushTexture.create((__webpack_require__(6555)/* ["default"] */ .Z), 1));
		brush_textures.push(await BrushTexture.create((__webpack_require__(6258)/* ["default"] */ .Z), 2));
		brush_textures.push(await BrushTexture.create((__webpack_require__(5954)/* ["default"] */ .Z), 3));
		brush_textures.push(await BrushTexture.create((__webpack_require__(4493)/* ["default"] */ .Z), 4));
		brush_textures.push(await BrushTexture.create((__webpack_require__(4830)/* ["default"] */ .Z), 5));
		brush_textures.push(await BrushTexture.create((__webpack_require__(5179)/* ["default"] */ .Z), 6));
		$$invalidate(19, brush_textures = [...brush_textures]);

		for (let brush of brush_presets) {
			brush.selected_brush_texture = brush_textures[0];
		}

		modals = [chaosSemiModal, dynamicsSemiModal, texDynamicsSemiModal];
	};

	onMount(async () => {
		init_web_gl();
		await init_other_stuff();
		default_framebuffer.bind();
		default_framebuffer.clear([0, 0, 0, 1]);
		canvas_fb.clear([0, 0, 0, 0]);
		canvas_fb.pong();
		canvas_fb.back_textures[0].bind_to_unit(1);
		canvas_fb.clear([0, 0, 0, 0]);

		const temp_stroke_fb = new Framebuffer([
				new Texture([project.canvasRes[0], project.canvasRes[1]], gl.RGBA16F, !isOnMobile)
			]);

		temp_stroke_fb.clear([0, 0, 0, 0]);

		const init_texture_uniforms = program => {
			program.setUniformTexture('temp_tex', temp_stroke_fb.textures[0], 0);
			program.setUniformTexture('canvas_back', canvas_fb.back_textures[0], 1);
			program.setUniformTexture('canvas_b', canvas_fb._textures[0], 2);
			program.setUniformTexture('canvas_a', canvas_fb._back_textures[0], 3);
			const brush_tex_start_idx = 5;

			brush_textures.forEach((brush_tex, i) => {
				const name = `brush_texture[${i}]`;
				console.log(name);
				const brush_textures_loc = gl.getUniformLocation(program.program, name);
				brush_tex.gpu_tex.bind_to_unit(brush_tex_start_idx + i);
				gl.uniform1i(brush_textures_loc, brush_tex_start_idx + i);
			});

			gl.activeTexture(gl.TEXTURE0);
		};

		const brush_preview_program = new ShaderProgram(__webpack_require__(9083), __webpack_require__(8180));
		const colour_preview_program = new ShaderProgram(__webpack_require__(9346), __webpack_require__(2527));
		const picker_program = new ShaderProgram(__webpack_require__(4950), __webpack_require__(3045));
		const composite_stroke_to_canvas_program = new ShaderProgram(__webpack_require__(7529), __webpack_require__(2082));
		const composite_stroke_to_canvas_b_program = new ShaderProgram(__webpack_require__(7529), __webpack_require__(6727));
		const post_canvas_program = new ShaderProgram(__webpack_require__(2199), __webpack_require__(2975));
		post_canvas_program.zoom_loc = gl.getUniformLocation(post_canvas_program.program, "zoom");
		post_canvas_program.panning_loc = gl.getUniformLocation(post_canvas_program.program, "panning");
		post_canvas_program.blending_colour_space_loc = gl.getUniformLocation(post_canvas_program.program, "blending_colour_space");
		const brush_long_program = new ShaderProgram(__webpack_require__(5522), __webpack_require__(5200));
		brush_preview_program.use();
		init_texture_uniforms(brush_preview_program);
		colour_preview_program.use();
		init_texture_uniforms(colour_preview_program);
		picker_program.use();
		init_texture_uniforms(picker_program);
		composite_stroke_to_canvas_program.use();
		init_texture_uniforms(composite_stroke_to_canvas_program);
		composite_stroke_to_canvas_b_program.use();
		init_texture_uniforms(composite_stroke_to_canvas_b_program);
		composite_stroke_to_canvas_program.blending_colour_space_loc = gl.getUniformLocation(composite_stroke_to_canvas_program.program, "blending_colour_space");
		composite_stroke_to_canvas_b_program.blending_colour_space_loc = gl.getUniformLocation(composite_stroke_to_canvas_b_program.program, "blending_colour_space");
		post_canvas_program.use();
		init_texture_uniforms(post_canvas_program);
		brush_long_program.use();
		init_texture_uniforms(brush_long_program);
		brush_long_program.brush_params_loc = gl.getUniformLocation(brush_long_program.program, "brush_params");
		let frame = 0;
		$$invalidate(22, canvas_read_tex = canvas_fb.textures[0]);
		let brush_buffer = new Thing([new VertexBuffer(4, gl.FLOAT), new VertexBuffer(4, gl.FLOAT)], gl.TRIANGLES, brush_long_program);
		gl.bindVertexArray(brush_buffer.vao);
		let t = 0;
		let delta_t = 0;
		let redraw_needed = false;
		let redo_history_length = 0;
		let brush_stroke = new BrushStroke(curr_brush.selected_brush_type, new DrawParams(curr_brush.tex_dynamics, curr_brush.tex_lch_dynamics, curr_brush.noise_stretch, curr_brush.tex_stretch, BlendingColourSpace.Pigments), curr_brush.selected_brush_texture);
		drawer = new Drawer(gl, canvas_fb.textures[0], default_framebuffer);

		const composite_stroke = () => {
			canvas_fb.bind();
			canvas_fb.clear();

			const comp_program = canvas_fb.pong_idx === 0
			? composite_stroke_to_canvas_program
			: composite_stroke_to_canvas_b_program;

			if (canvas_fb.pong_idx === 0) {
				
			}

			comp_program.use();
			gl.uniform1i(comp_program.blending_colour_space_loc, blending_colour_space);
			canvas_fb.back_textures[0].bind_to_unit(1);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			temp_stroke_fb.clear();
		};

		const draw_n_strokes = (start_idx, end_idx, full_redraw = false) => {
			let k = 0;
			drawer.brush_buffer = brush_buffer;
			drawer.reset();
			start_idx = start_idx ?? 0;
			end_idx = end_idx ?? project.brush_strokes.length;

			for (k = start_idx; k < end_idx; k++) {
				drawer.push_any_stroke(project.brush_strokes[k]);
			}

			drawer.brush_buffer.upload_all_buffs();
			const brush_shader = drawer.brush_buffer.shader;
			brush_shader.use();
			let prev_colour_space = -1;
			let prev_colour_space_b = -1;
			let prev_brush_tex_idx = -1;
			let prev_hsv_dynamics = [-9999, -9999, -9999];
			let prev_noise_stretch = [-9999, -9999];
			let prev_tex_stretch = [-9999, -9999];
			gl.useProgram(composite_stroke_to_canvas_program.program);
			canvas_fb._textures[0].bind_to_unit(2);
			canvas_fb._back_textures[0].bind_to_unit(3);
			gl.activeTexture(gl.TEXTURE15);
			let comp_program = composite_stroke_to_canvas_program;
			gl.clearColor(0, 0, 0, 0);
			gl.viewport(0, 0, project.canvasRes[0], project.canvasRes[1]);
			k = start_idx;
			let j = 0;

			for (let amogus of drawer.recorded_drawcalls) {
				const new_noise_stretch = project.brush_strokes[k].draw_params.noise_stretch;
				const new_tex_stretch = project.brush_strokes[k].draw_params.tex_stretch;
				const new_hsv_dynamics = project.brush_strokes[k].draw_params.tex_lch_dynamics;
				const new_brush_tex_idx = project.brush_strokes[k].brush_texture.idx;
				const new_col_space = project.brush_strokes[k].draw_params.blending_colour_space;
				gl.bindFramebuffer(gl.FRAMEBUFFER, temp_stroke_fb.fb);
				gl.clear(gl.COLOR_BUFFER_BIT);
				brush_shader.use();

				if (new_brush_tex_idx !== prev_brush_tex_idx || prev_hsv_dynamics[0] !== new_hsv_dynamics[0] || prev_hsv_dynamics[1] !== new_hsv_dynamics[1] || prev_hsv_dynamics[2] !== new_hsv_dynamics[2] || prev_noise_stretch[0] !== new_noise_stretch[0] || prev_noise_stretch[1] !== new_noise_stretch[1] || prev_tex_stretch[0] !== new_tex_stretch[0] || prev_tex_stretch[1] !== new_tex_stretch[1]) {
					brush_params_mat[0] = new_brush_tex_idx;
					brush_params_mat[1] = new_hsv_dynamics[0];
					brush_params_mat[2] = new_hsv_dynamics[1];
					brush_params_mat[3] = new_hsv_dynamics[2];
					brush_params_mat[4] = new_noise_stretch[0];
					brush_params_mat[5] = new_noise_stretch[1];
					brush_params_mat[6] = new_tex_stretch[0];
					brush_params_mat[7] = new_tex_stretch[1];
					gl.uniformMatrix4fv(brush_shader.brush_params_loc, false, brush_params_mat);
				}

				drawer.draw_stroke_idx(j);
				gl.bindFramebuffer(gl.FRAMEBUFFER, canvas_fb.fb);

				comp_program = canvas_fb.pong_idx === 0
				? composite_stroke_to_canvas_program
				: composite_stroke_to_canvas_b_program;

				comp_program.use();

				if (canvas_fb.pong_idx === 0) {
					if (new_col_space !== prev_colour_space) {
						gl.uniform1i(comp_program.blending_colour_space_loc, prev_colour_space = new_col_space);
					}
				} else {
					if (new_col_space !== prev_colour_space_b) {
						gl.uniform1i(comp_program.blending_colour_space_loc, prev_colour_space_b = new_col_space);
					}
				}

				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				canvas_fb.pong();

				if (full_redraw && j === end_idx - end_idx % undo_cache_steps - 1) {
					copy_fb_to_fb(canvas_fb.fb_back, temp_undo_fb.fb, canvas_fb._textures[0].res);
				}

				prev_hsv_dynamics[0] = new_hsv_dynamics[0];
				prev_hsv_dynamics[1] = new_hsv_dynamics[1];
				prev_hsv_dynamics[2] = new_hsv_dynamics[2];
				prev_noise_stretch[0] = new_noise_stretch[0];
				prev_noise_stretch[1] = new_noise_stretch[1];
				prev_tex_stretch[0] = new_tex_stretch[0];
				prev_tex_stretch[1] = new_tex_stretch[1];
				k++;
				j++;
			}

			redraw_needed = true;
			temp_stroke_fb.clear();
		};

		const redraw_whole_project = () => {
			console.log('REDRAW EVERYTHING');
			console.time("REDRAW ALL");
			canvas_fb.clear();
			canvas_fb.pong();
			canvas_fb.back_textures[0].bind_to_unit(1);
			canvas_fb.clear();
			temp_stroke_fb.clear();
			draw_n_strokes(0, project.brush_strokes.length - redo_history_length, true);
			console.timeEnd("REDRAW ALL");
		};

		$$invalidate(27, resize_project = new_sz => {
			$$invalidate(20, project.canvasRes = [...new_sz], project);
			temp_stroke_fb.textures[0].resize(new_sz);
			canvas_fb.back_textures[0].resize(new_sz);
			canvas_fb.textures[0].resize(new_sz);
			canvas_fb.recreate();
			canvas_fb.back_textures[0].bind_to_unit(1);
			temp_stroke_fb.recreate();
			temp_stroke_fb.textures[0].bind_to_unit(0);
			temp_undo_fb.textures[0].resize(new_sz);
			temp_undo_fb.recreate();
			set_shared_uniforms();
			full_redraw_needed = true;
			$$invalidate(16, project_has_been_modified = false);
			redo_history_length = 0;
		});

		let load_project = new_project => {
			$$invalidate(20, project = new Project());
			$$invalidate(16, project_has_been_modified = false);
			redo_history_length = 0;

			for (let key of Object.keys(new_project)) {
				$$invalidate(20, project[key] = new_project[key], project);
			}

			$$invalidate(20, project.canvasRes = [...new_project.canvasRes], project);
			resize_project(project.canvasRes);
			redraw_whole_project();
		};

		let local_storage_proj = localStorage.getItem('project');

		if (local_storage_proj) {
			local_storage_proj = JSON.parse(local_storage_proj);
			load_project(local_storage_proj);
		} else {
			load_project(new Project());
		}

		const handle_input_actions = () => {
			if (io.getKey('AltLeft').down) {
				if (io.getKey('AltLeft').just_pressed) {
					$$invalidate(14, picking = true);
				}

				pick_from_canvas();
			} else if (io.getKey('AltLeft').just_unpressed) {
				$$invalidate(15, just_finished_pick = true);
				$$invalidate(14, picking = false);
			}

			if (mouse_over_colour_picker || mouse_over_colour_picker_finished) {
				redraw_needed = true;
			}

			if (io.just_finished_pinch) {
				zoom[0] = desired_zoom = pow(2, log2(desired_zoom) + io.pinch_zoom);
			}

			if (io.two_finger_pinch) {
				redraw_needed = true;
				zoom[0] = pow(2, log2(desired_zoom) + io.pinch_zoom);

				if (io.just_started_pinch) {
					panning_temp_pinch[0] = panning[0];
					panning_temp_pinch[1] = panning[1];
				}

				panning[0] = panning_temp_pinch[0] + io.pinch_pos[0];
				panning[1] = panning_temp_pinch[1] - io.pinch_pos[1];
			} else if (abs(desired_zoom - zoom[0]) > 0.001) {
				redraw_needed = true;
				zoom[0] = mix(zoom[0], desired_zoom, delta_t * 20);
			}

			if (frame === 0 || picking || just_finished_pick || io.mouse_wheel || io.mmb_down) {
				redraw_needed = true;

				if (just_finished_pick) {
					let coords = Utils.screen_NDC_to_canvas_NDC([...io.mouse_pos], default_framebuffer.textures[0], canvas_fb._textures[0], zoom[0], panning);

					if (coords[0] > -1 && coords[0] < 1 && coords[1] > -1 && coords[1] < 1) {
						$$invalidate(23, stroke_col[0] = picked_col[0], stroke_col);
						$$invalidate(23, stroke_col[1] = picked_col[1], stroke_col);
						$$invalidate(23, stroke_col[2] = picked_col[2], stroke_col);
						Utils.gamma_correct(stroke_col, true, true);
						$$invalidate(23, stroke_col[3] = 1, stroke_col);
						trigger_colour_display_update(stroke_col[0], stroke_col[1], stroke_col[2]);
					}

					console.log(coords);
					$$invalidate(15, just_finished_pick = false);
					$$invalidate(14, picking = false);
					console.log("finished pick");
				}

				if (io.mmb_down) {
					panning[0] += io.delta_mouse_pos[0] / zoom[0];
					panning[1] += io.delta_mouse_pos[1] / zoom[0];
				}

				if (io.mouse_wheel) {
					if (io.mouse_wheel > 0) {
						desired_zoom *= 1.2;
					} else {
						desired_zoom /= 1.2;
					}
				}
			}

			let l_ctrl_down = io.getKey('ControlLeft').down;
			let l_shift_down = io.getKey('ShiftLeft').down;
			let z_just_pressed = io.getKey('KeyZ').just_pressed;
			const idx_before = project.brush_strokes.length - redo_history_length;

			if (redo_pending || l_shift_down && l_ctrl_down && z_just_pressed) {
				redo_history_length -= 1;
				const idx_now = idx_before + 1;

				if (redo_history_length >= 0) {
					if (idx_now % undo_cache_steps === 0) {
						temp_stroke_fb.clear();
						draw_n_strokes(idx_before, idx_before + 1);
						copy_fb_to_fb(canvas_fb.fb_back, temp_undo_fb.fb, canvas_fb.textures[0].res);
					} else {
						temp_stroke_fb.clear();
						draw_n_strokes(idx_before, idx_before + 1);
					}
				} else {
					redo_history_length = 0;
					floating_modal_message.set("Last redo");
				}
			} else if (undo_pending || l_ctrl_down && z_just_pressed) {
				redo_history_length += 1;
				const idx_now = idx_before - 1;

				if (redo_history_length <= project.brush_strokes.length) {
					if (idx_before % undo_cache_steps === 0) {
						canvas_fb.clear();
						canvas_fb.pong();
						canvas_fb.back_textures[0].bind_to_unit(1);
						canvas_fb.clear();
						temp_stroke_fb.clear();
						draw_n_strokes(0, idx_before - undo_cache_steps);
						copy_fb_to_fb(canvas_fb.fb_back, temp_undo_fb.fb, canvas_fb.textures[0].res);
						temp_stroke_fb.clear();
						draw_n_strokes(idx_before - undo_cache_steps, project.brush_strokes.length - redo_history_length);
					} else {
						copy_fb_to_fb(temp_undo_fb.fb, canvas_fb.fb_back, canvas_fb.textures[0].res);
						canvas_fb.back_textures[0].bind_to_unit(1);
						temp_stroke_fb.clear();
						const undo_mod_offs = idx_now % undo_cache_steps;
						draw_n_strokes(idx_now - undo_mod_offs, project.brush_strokes.length - redo_history_length);
					}

					gl.activeTexture(gl.TEXTURE15);
				} else {
					redo_history_length -= 1;
					floating_modal_message.set("Last undo");
				}
			}
		};

		const record_stroke = () => {
			if (io.mouse_just_pressed && !(redo_pending || undo_pending)) {
				brush_stroke = new BrushStroke(curr_brush.selected_brush_type,
				new DrawParams(curr_brush.tex_dynamics,
					curr_brush.tex_lch_dynamics,
					curr_brush.noise_stretch,
					[
							curr_brush.tex_stretch[0] * 20.,
							curr_brush.tex_stretch[1] * 2. * 20.
						],
					blending_colour_space),
				curr_brush.selected_brush_texture);

				for (let i = 0; i < redo_history_length; i++) {
					project.brush_strokes.pop();
				}

				redo_history_length = 0;
			}

			brush_rot = [...io.tilt];

			for (let i = 0; i < io.mouse_positions_during_last_frame_cnt; i++) {
				brush_pos_ndc_screen = [
					io.mouse_positions_during_last_frame[i * 2],
					io.mouse_positions_during_last_frame[i * 2 + 1]
				];

				brush_pos_ndc_canvas = Utils.screen_NDC_to_canvas_NDC(brush_pos_ndc_screen, default_framebuffer.textures[0], canvas_read_tex, zoom[0], panning);

				if (curr_brush.pos_jitter > 0.01) {
					brush_pos_ndc_canvas[0] += curr_brush.pos_jitter * (2 * hash.valueNoiseSmooth(t * 100 + 251, 2) - 1);
					brush_pos_ndc_canvas[1] += curr_brush.pos_jitter * (2 * hash.valueNoiseSmooth(t * 100 + 1251, 2) - 1);
				}

				let col = [...stroke_col];

				if (curr_brush.chaos > 0.01) {
					const chroma_gl = col => {
						return chroma_default().gl(col[0], col[1], col[2]);
					};

					const chroma_oklch = col => {
						return chroma_default().oklch(col[0], col[1], col[2]);
					};

					col = chroma_gl(col).oklch();
					const c = col[1];
					let hue_jitt_amt = (1 - pow(c, 0.2) * 1.2) * 4;
					hue_jitt_amt = max(hue_jitt_amt, 0);
					hue_jitt_amt += pow(smoothstep(0., 1., 1 - c), 57.) * 2.2;
					col[0] += (-0.5 + hash.valueNoiseSmooth(t * 100 * curr_brush.chaos_speed, 2)) * curr_brush.chaos * curr_brush.chaos_lch[0];
					col[1] += (-0.5 + hash.valueNoiseSmooth(t * 100 * curr_brush.chaos_speed + 100, 2)) * curr_brush.chaos * curr_brush.chaos_lch[1];
					col[2] += hue_jitt_amt * (-0.5 + hash.valueNoiseSmooth(t * 100 * curr_brush.chaos_speed + 200, 2)) * 300 * curr_brush.chaos * curr_brush.chaos_lch[2];
					col[0] = clamp(col[0], 0, 1);
					col[1] = clamp(col[1], 0, 1);
					col[2] = _0b5vr_experimental_esm_mod(col[2], 360);
					col = chroma_oklch(col).gl();
				}

				{
					stroke_opacity = lerp(curr_brush.stroke_opacity_dynamics[0], curr_brush.stroke_opacity_dynamics[1], io.pressure);
				}

				if (curr_brush.rot_jitter > 0.01) {
					brush_rot[1] += 10 * curr_brush.rot_jitter * (2 * hash.valueNoiseSmooth(t * 10 + 100, 2) - 1);
				}

				let sz = [...brush_sz];
				let size_pressure_weight = lerp(curr_brush.stroke_size_dynamics[0], curr_brush.stroke_size_dynamics[1], io.pressure);
				let size_tilt_weight = lerp(0.4, 1, io.tilt[0] / tau);
				sz[0] *= size_pressure_weight * size_tilt_weight;
				sz[1] *= size_pressure_weight * size_tilt_weight;
				brush_stroke.push_stroke(brush_pos_ndc_canvas, brush_rot, sz, stroke_opacity, col);
			}
		};

		const draw = _t => {
			redraw_needed = false;
			const new_t = _t / 1000;
			delta_t = new_t - t;
			t = new_t;

			resizeIfNeeded(
				canvasElement,
				default_framebuffer,
				default_framebuffer._textures[0].res,
				v => {
					redraw_needed = v;
				},
				() => {
					set_shared_uniforms();
				}
			);

			io.tick();

			if (new_project_pending) {
				load_project(new Project());
				$$invalidate(9, new_project_pending = false);
			}

			if (project_pending_load) {
				load_project(project_pending_load);
				$$invalidate(21, project_pending_load = undefined);
			}

			if (full_redraw_needed) {
				redraw_whole_project();
			}

			handle_input_actions();

			if ((io.mouse_just_pressed || io.mouse_down && io.mouse_just_moved) && io.pointerType !== 'touch') {
				$$invalidate(16, project_has_been_modified = true);
				redraw_needed = true;
				record_stroke();
				temp_stroke_fb.clear();
				temp_stroke_fb.bind();
				drawer.brush_buffer = brush_buffer;
				drawer.reset();
				drawer.push_any_stroke(brush_stroke);
				drawer.brush_buffer.upload_all_buffs();
				const brush_shader = drawer.brush_buffer.shader;
				brush_shader.use();
				brush_params_mat[0] = curr_brush.selected_brush_texture.idx;
				brush_params_mat[1] = brush_stroke.draw_params.tex_lch_dynamics[0];
				brush_params_mat[2] = brush_stroke.draw_params.tex_lch_dynamics[1];
				brush_params_mat[3] = brush_stroke.draw_params.tex_lch_dynamics[2];
				brush_params_mat[4] = brush_stroke.draw_params.noise_stretch[0];
				brush_params_mat[5] = brush_stroke.draw_params.noise_stretch[1];
				brush_params_mat[6] = brush_stroke.draw_params.tex_stretch[0];
				brush_params_mat[7] = brush_stroke.draw_params.tex_stretch[1];
				gl.uniformMatrix4fv(brush_shader.brush_params_loc, false, brush_params_mat);
				drawer.draw_stroke_idx(0);
			}

			if (io.mouse_just_unpressed && io.pointerType !== 'touch' && !(undo_pending || redo_pending)) {
				if (frame % 15 === 0 || !isOnMobile) {
					localStorage.setItem('project', JSON.stringify(project));
				}

				project.push_stroke(brush_stroke);
				redraw_needed = true;
				composite_stroke();
				canvas_fb.pong();
				canvas_fb.back_textures[0].bind_to_unit(1);

				if (project.brush_strokes.length % undo_cache_steps === 0) {
					copy_fb_to_fb(canvas_fb.fb_back, temp_undo_fb.fb, canvas_fb.textures[0].res);
				}
			}

			if (brush_size_widget_dragging || brush_size_widget_stopped_dragging) redraw_needed = true;

			if (redraw_needed) {
				if (canvas_fb._textures[0].mipmapped) {
					gl.bindTexture(gl.TEXTURE_2D, canvas_fb._textures[0].tex);
					gl.generateMipmap(gl.TEXTURE_2D);
					gl.bindTexture(gl.TEXTURE_2D, canvas_fb._back_textures[0].tex);
					gl.generateMipmap(gl.TEXTURE_2D);
					gl.bindTexture(gl.TEXTURE_2D, null);
				}

				if (temp_stroke_fb.textures[0].mipmapped) {
					gl.bindTexture(gl.TEXTURE_2D, temp_stroke_fb.textures[0].tex);
					gl.generateMipmap(gl.TEXTURE_2D);
					gl.bindTexture(gl.TEXTURE_2D, null);
				}

				gl.viewport(0, 0, default_framebuffer._textures[0].res[0], default_framebuffer._textures[0].res[1]);
				gl.bindFramebuffer(gl.FRAMEBUFFER, default_framebuffer.fb);
				gl.clear(gl.COLOR_BUFFER_BIT);
				Framebuffer.currently_bound = default_framebuffer;
				post_canvas_program.use();
				gl.uniform1f(post_canvas_program.zoom_loc, zoom);
				gl.uniform2fv(post_canvas_program.panning_loc, panning);
				gl.uniform1i(post_canvas_program.blending_colour_space_loc, blending_colour_space);
				canvas_fb.back_textures[0].bind_to_unit(1);
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

				if (mouse_over_colour_picker && !brush_size_widget_dragging) {
					colour_preview_program.use();
					colour_preview_program.setUniformVec("brush_sz", brush_sz);
					colour_preview_program.setUniformVec("colour", stroke_col);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				}

				if (brush_size_widget_dragging) {
					brush_preview_program.use();
					brush_preview_program.setUniformFloat("zoom", zoom[0]);
					brush_preview_program.setUniformVec("brush_sz", brush_sz);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				}

				if (picking) {
					picker_program.use();
					picker_program.setUniformVec('picked_col', picked_col);
					picker_program.setUniformVec('picker_pos', [...io.mouse_pos]);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				}
			}

			print_on_gl_error();
			$$invalidate(8, brush_size_widget_stopped_dragging = false);
			$$invalidate(11, redo_pending = false);
			$$invalidate(10, undo_pending = false);
			full_redraw_needed = false;
			$$invalidate(13, mouse_over_colour_picker_finished = false);
			io.tick_end();
			frame++;

			for (let framebuffer of Framebuffer.framebuffers) {
				if (framebuffer.needs_pong) {
					framebuffer.pong();
				}
			}

			requestAnimationFrame(draw);
		};

		(() => {
			draw(0);
		})();
	});

	onDestroy(() => {
		
	});

	const writable_props = [];

	App_svelte_Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') App_svelte_console_1.warn(`<App> was created with unknown prop '${key}'`);
	});

	function knob0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			chaosKnob = $$value;
			$$invalidate(4, chaosKnob);
		});
	}

	function knob0_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.chaos, value)) {
			curr_brush.chaos = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			dynamicsKnob = $$value;
			$$invalidate(5, dynamicsKnob);
		});
	}

	function knob1_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.dynamics, value)) {
			curr_brush.dynamics = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			texDynamicsKnob = $$value;
			$$invalidate(6, texDynamicsKnob);
		});
	}

	function knob2_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.tex_dynamics, value)) {
			curr_brush.tex_dynamics = value;
			$$invalidate(25, curr_brush);
		}
	}

	function brushsizewidget_brush_sz_binding(value) {
		brush_sz = value;
		$$invalidate(24, brush_sz);
	}

	function brushsizewidget_dragging_binding(value) {
		brush_size_widget_dragging = value;
		$$invalidate(7, brush_size_widget_dragging);
	}

	function brushsizewidget_stopped_dragging_binding(value) {
		brush_size_widget_stopped_dragging = value;
		$$invalidate(8, brush_size_widget_stopped_dragging);
	}

	function rgbsliders_colour_binding(value) {
		stroke_col = value;
		$$invalidate(23, stroke_col);
	}

	function colourdisplay_colour_binding(value) {
		stroke_col = value;
		$$invalidate(23, stroke_col);
	}

	function colourdisplay_update_display_binding(value) {
		trigger_colour_display_update = value;
		$$invalidate(28, trigger_colour_display_update);
	}

	const pointerenter_handler = () => {
		$$invalidate(12, mouse_over_colour_picker = true);
	};

	const pointerleave_handler = () => {
		$$invalidate(12, mouse_over_colour_picker = false);
		$$invalidate(13, mouse_over_colour_picker_finished = true);
	};

	function brushtypewidget_curr_brush_binding(value) {
		curr_brush = value;
		$$invalidate(25, curr_brush);
	}

	function brushpresetwidget_brush_presets_binding(value) {
		brush_presets = value;
		$$invalidate(18, brush_presets);
	}

	function brushpresetwidget_selected_brush_preset_binding(value) {
		curr_brush = value;
		$$invalidate(25, curr_brush);
	}

	const func = () => {
		$$invalidate(10, undo_pending = true);
	};

	const func_1 = () => {
		$$invalidate(11, redo_pending = true);
	};

	const func_2 = async () => {
		let [img, blob] = await canvas_read_tex.read_back_image(true);
		return [img, blob];
	};

	const func_3 = () => {
		$$invalidate(9, new_project_pending = true);
	};

	const func_4 = project => {
		$$invalidate(21, project_pending_load = project);
	};

	function gallerywidget_current_project_binding(value) {
		project = value;
		$$invalidate(20, project);
	}

	function gallerywidget_resize_project_binding(value) {
		resize_project = value;
		$$invalidate(27, resize_project);
	}

	function gallerywidget_project_has_been_modified_binding(value) {
		project_has_been_modified = value;
		$$invalidate(16, project_has_been_modified);
	}

	function gallerywidget_is_safe_to_switch_to_new_project_binding(value) {
		is_safe_to_switch_to_new_project = value;
		$$invalidate(17, is_safe_to_switch_to_new_project);
	}

	const func_5 = () => pick_from_canvas();

	function pickcolourwidget_picking_binding(value) {
		picking = value;
		$$invalidate(14, picking);
	}

	function pickcolourwidget_just_finished_pick_binding(value) {
		just_finished_pick = value;
		$$invalidate(15, just_finished_pick);
	}

	function blendingcolourspacewidget_selected_colour_space_binding(value) {
		blending_colour_space = value;
		$$invalidate(26, blending_colour_space);
	}

	function knob0_value_binding_1(value) {
		if ($$self.$$.not_equal(curr_brush.chaos_lch[0], value)) {
			curr_brush.chaos_lch[0] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob1_value_binding_1(value) {
		if ($$self.$$.not_equal(curr_brush.chaos_lch[1], value)) {
			curr_brush.chaos_lch[1] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob2_value_binding_1(value) {
		if ($$self.$$.not_equal(curr_brush.chaos_lch[2], value)) {
			curr_brush.chaos_lch[2] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob3_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.chaos_speed, value)) {
			curr_brush.chaos_speed = value;
			$$invalidate(25, curr_brush);
		}
	}

	function semimodal0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			chaosSemiModal = $$value;
			$$invalidate(1, chaosSemiModal);
		});
	}

	function knob0_value_binding_2(value) {
		if ($$self.$$.not_equal(curr_brush.stroke_opacity_dynamics[0], value)) {
			curr_brush.stroke_opacity_dynamics[0] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob1_value_binding_2(value) {
		if ($$self.$$.not_equal(curr_brush.stroke_opacity_dynamics[1], value)) {
			curr_brush.stroke_opacity_dynamics[1] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob2_value_binding_2(value) {
		if ($$self.$$.not_equal(curr_brush.stroke_size_dynamics[0], value)) {
			curr_brush.stroke_size_dynamics[0] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob3_value_binding_1(value) {
		if ($$self.$$.not_equal(curr_brush.stroke_size_dynamics[1], value)) {
			curr_brush.stroke_size_dynamics[1] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob4_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.rot_jitter, value)) {
			curr_brush.rot_jitter = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob5_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.pos_jitter, value)) {
			curr_brush.pos_jitter = value;
			$$invalidate(25, curr_brush);
		}
	}

	function semimodal1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			dynamicsSemiModal = $$value;
			$$invalidate(2, dynamicsSemiModal);
		});
	}

	function knob0_value_binding_3(value) {
		if ($$self.$$.not_equal(curr_brush.tex_stretch[0], value)) {
			curr_brush.tex_stretch[0] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob1_value_binding_3(value) {
		if ($$self.$$.not_equal(curr_brush.tex_stretch[1], value)) {
			curr_brush.tex_stretch[1] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob2_value_binding_3(value) {
		if ($$self.$$.not_equal(curr_brush.noise_stretch[0], value)) {
			curr_brush.noise_stretch[0] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob3_value_binding_2(value) {
		if ($$self.$$.not_equal(curr_brush.noise_stretch[1], value)) {
			curr_brush.noise_stretch[1] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob4_value_binding_1(value) {
		if ($$self.$$.not_equal(curr_brush.tex_lch_dynamics[0], value)) {
			curr_brush.tex_lch_dynamics[0] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob5_value_binding_1(value) {
		if ($$self.$$.not_equal(curr_brush.tex_lch_dynamics[1], value)) {
			curr_brush.tex_lch_dynamics[1] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function knob6_value_binding(value) {
		if ($$self.$$.not_equal(curr_brush.tex_lch_dynamics[2], value)) {
			curr_brush.tex_lch_dynamics[2] = value;
			$$invalidate(25, curr_brush);
		}
	}

	function texturewidget_brush_textures_binding(value) {
		brush_textures = value;
		$$invalidate(19, brush_textures);
	}

	function texturewidget_selected_brush_texture_binding(value) {
		if ($$self.$$.not_equal(curr_brush.selected_brush_texture, value)) {
			curr_brush.selected_brush_texture = value;
			$$invalidate(25, curr_brush);
		}
	}

	function semimodal2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			texDynamicsSemiModal = $$value;
			$$invalidate(3, texDynamicsSemiModal);
		});
	}

	function canvas_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvasElement = $$value;
			$$invalidate(0, canvasElement);
		});
	}

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		floating_modal_message: floating_modal_message,
		resizeDefaultFramebufferIfNeeded: resizeIfNeeded,
		print_on_gl_error: print_on_gl_error,
		init_gl_error_handling: init_gl_error_handling,
		copy_fb_to_texture: copy_fb_to_texture,
		copy_fb_to_fb: copy_fb_to_fb,
		Knob: Knob_svelte,
		BrushSizeWidget: BrushSizeWidget_svelte,
		BrushTypeWidget: BrushTypeWidget_svelte,
		BrushPresetWidget: BrushPresetWidget_svelte,
		UndoRedoWidget: UndoRedoWidget_svelte,
		GalleryWidget: GalleryWidget_svelte,
		FloatingModal: FloatingModal_svelte,
		PickColourWidget: PickColourWidget_svelte,
		TextureWidget: TextureWidget_svelte,
		BlendingColourSpaceWidget: BlendingColourSpaceWidget_svelte,
		RGBSliders: RGBSliders_svelte,
		ColourDisplay: ColourDisplay_svelte,
		SemiModal: SemiModal_svelte,
		FourIconsWidget: FourIconsWidget_svelte,
		IO: IO,
		chroma: (chroma_default()),
		Hash: Hash,
		abs: abs,
		pow: pow,
		tau: tau,
		mix: mix,
		max: max,
		log2: log2,
		clamp: clamp,
		lerp: lerp,
		mod: _0b5vr_experimental_esm_mod,
		smoothstep: smoothstep,
		BrushTexture: BrushTexture,
		Project: Project,
		Utils: Utils,
		BlendingColourSpace: BlendingColourSpace,
		BrushPreset: BrushPreset,
		BrushStroke: BrushStroke,
		DrawParams: DrawParams,
		Drawer: Drawer,
		Framebuffer: Framebuffer,
		VertexBuffer: VertexBuffer,
		UBO: UBO,
		Texture: Texture,
		ShaderProgram: ShaderProgram,
		Thing: Thing,
		canvasElement,
		chaosSemiModal,
		dynamicsSemiModal,
		texDynamicsSemiModal,
		modals,
		chaosKnob,
		dynamicsKnob,
		texDynamicsKnob,
		brush_size_widget_dragging,
		brush_size_widget_stopped_dragging,
		new_project_pending,
		undo_pending,
		redo_pending,
		mouse_over_colour_picker,
		mouse_over_colour_picker_finished,
		picking,
		just_finished_pick,
		picked_col,
		project_has_been_modified,
		is_safe_to_switch_to_new_project,
		full_redraw_needed,
		zoom,
		desired_zoom,
		panning_temp_pinch,
		panning,
		brush_presets,
		brush_textures,
		undo_cache_steps,
		hash,
		io,
		gl,
		project,
		project_pending_load,
		default_framebuffer,
		canvas_fb,
		canvas_read_tex,
		temp_undo_fb,
		drawer,
		ubo,
		stroke_col,
		stroke_opacity,
		brush_rot,
		brush_pos_ndc_screen,
		brush_pos_ndc_canvas,
		brush_sz,
		curr_brush,
		blending_colour_space,
		brush_params_mat,
		resize_project,
		trigger_colour_display_update,
		set_shared_uniforms,
		pick_from_canvas,
		openModal,
		init_web_gl,
		init_other_stuff
	});

	$$self.$inject_state = $$props => {
		if ('canvasElement' in $$props) $$invalidate(0, canvasElement = $$props.canvasElement);
		if ('chaosSemiModal' in $$props) $$invalidate(1, chaosSemiModal = $$props.chaosSemiModal);
		if ('dynamicsSemiModal' in $$props) $$invalidate(2, dynamicsSemiModal = $$props.dynamicsSemiModal);
		if ('texDynamicsSemiModal' in $$props) $$invalidate(3, texDynamicsSemiModal = $$props.texDynamicsSemiModal);
		if ('modals' in $$props) modals = $$props.modals;
		if ('chaosKnob' in $$props) $$invalidate(4, chaosKnob = $$props.chaosKnob);
		if ('dynamicsKnob' in $$props) $$invalidate(5, dynamicsKnob = $$props.dynamicsKnob);
		if ('texDynamicsKnob' in $$props) $$invalidate(6, texDynamicsKnob = $$props.texDynamicsKnob);
		if ('brush_size_widget_dragging' in $$props) $$invalidate(7, brush_size_widget_dragging = $$props.brush_size_widget_dragging);
		if ('brush_size_widget_stopped_dragging' in $$props) $$invalidate(8, brush_size_widget_stopped_dragging = $$props.brush_size_widget_stopped_dragging);
		if ('new_project_pending' in $$props) $$invalidate(9, new_project_pending = $$props.new_project_pending);
		if ('undo_pending' in $$props) $$invalidate(10, undo_pending = $$props.undo_pending);
		if ('redo_pending' in $$props) $$invalidate(11, redo_pending = $$props.redo_pending);
		if ('mouse_over_colour_picker' in $$props) $$invalidate(12, mouse_over_colour_picker = $$props.mouse_over_colour_picker);
		if ('mouse_over_colour_picker_finished' in $$props) $$invalidate(13, mouse_over_colour_picker_finished = $$props.mouse_over_colour_picker_finished);
		if ('picking' in $$props) $$invalidate(14, picking = $$props.picking);
		if ('just_finished_pick' in $$props) $$invalidate(15, just_finished_pick = $$props.just_finished_pick);
		if ('picked_col' in $$props) picked_col = $$props.picked_col;
		if ('project_has_been_modified' in $$props) $$invalidate(16, project_has_been_modified = $$props.project_has_been_modified);
		if ('is_safe_to_switch_to_new_project' in $$props) $$invalidate(17, is_safe_to_switch_to_new_project = $$props.is_safe_to_switch_to_new_project);
		if ('full_redraw_needed' in $$props) full_redraw_needed = $$props.full_redraw_needed;
		if ('desired_zoom' in $$props) desired_zoom = $$props.desired_zoom;
		if ('panning' in $$props) panning = $$props.panning;
		if ('brush_presets' in $$props) $$invalidate(18, brush_presets = $$props.brush_presets);
		if ('brush_textures' in $$props) $$invalidate(19, brush_textures = $$props.brush_textures);
		if ('io' in $$props) io = $$props.io;
		if ('gl' in $$props) gl = $$props.gl;
		if ('project' in $$props) $$invalidate(20, project = $$props.project);
		if ('project_pending_load' in $$props) $$invalidate(21, project_pending_load = $$props.project_pending_load);
		if ('default_framebuffer' in $$props) default_framebuffer = $$props.default_framebuffer;
		if ('canvas_fb' in $$props) canvas_fb = $$props.canvas_fb;
		if ('canvas_read_tex' in $$props) $$invalidate(22, canvas_read_tex = $$props.canvas_read_tex);
		if ('temp_undo_fb' in $$props) temp_undo_fb = $$props.temp_undo_fb;
		if ('drawer' in $$props) drawer = $$props.drawer;
		if ('ubo' in $$props) ubo = $$props.ubo;
		if ('stroke_col' in $$props) $$invalidate(23, stroke_col = $$props.stroke_col);
		if ('stroke_opacity' in $$props) stroke_opacity = $$props.stroke_opacity;
		if ('brush_rot' in $$props) brush_rot = $$props.brush_rot;
		if ('brush_pos_ndc_screen' in $$props) brush_pos_ndc_screen = $$props.brush_pos_ndc_screen;
		if ('brush_pos_ndc_canvas' in $$props) brush_pos_ndc_canvas = $$props.brush_pos_ndc_canvas;
		if ('brush_sz' in $$props) $$invalidate(24, brush_sz = $$props.brush_sz);
		if ('curr_brush' in $$props) $$invalidate(25, curr_brush = $$props.curr_brush);
		if ('blending_colour_space' in $$props) $$invalidate(26, blending_colour_space = $$props.blending_colour_space);
		if ('brush_params_mat' in $$props) brush_params_mat = $$props.brush_params_mat;
		if ('resize_project' in $$props) $$invalidate(27, resize_project = $$props.resize_project);
		if ('trigger_colour_display_update' in $$props) $$invalidate(28, trigger_colour_display_update = $$props.trigger_colour_display_update);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		canvasElement,
		chaosSemiModal,
		dynamicsSemiModal,
		texDynamicsSemiModal,
		chaosKnob,
		dynamicsKnob,
		texDynamicsKnob,
		brush_size_widget_dragging,
		brush_size_widget_stopped_dragging,
		new_project_pending,
		undo_pending,
		redo_pending,
		mouse_over_colour_picker,
		mouse_over_colour_picker_finished,
		picking,
		just_finished_pick,
		project_has_been_modified,
		is_safe_to_switch_to_new_project,
		brush_presets,
		brush_textures,
		project,
		project_pending_load,
		canvas_read_tex,
		stroke_col,
		brush_sz,
		curr_brush,
		blending_colour_space,
		resize_project,
		trigger_colour_display_update,
		pick_from_canvas,
		openModal,
		knob0_binding,
		knob0_value_binding,
		knob1_binding,
		knob1_value_binding,
		knob2_binding,
		knob2_value_binding,
		brushsizewidget_brush_sz_binding,
		brushsizewidget_dragging_binding,
		brushsizewidget_stopped_dragging_binding,
		rgbsliders_colour_binding,
		colourdisplay_colour_binding,
		colourdisplay_update_display_binding,
		pointerenter_handler,
		pointerleave_handler,
		brushtypewidget_curr_brush_binding,
		brushpresetwidget_brush_presets_binding,
		brushpresetwidget_selected_brush_preset_binding,
		func,
		func_1,
		func_2,
		func_3,
		func_4,
		gallerywidget_current_project_binding,
		gallerywidget_resize_project_binding,
		gallerywidget_project_has_been_modified_binding,
		gallerywidget_is_safe_to_switch_to_new_project_binding,
		func_5,
		pickcolourwidget_picking_binding,
		pickcolourwidget_just_finished_pick_binding,
		blendingcolourspacewidget_selected_colour_space_binding,
		knob0_value_binding_1,
		knob1_value_binding_1,
		knob2_value_binding_1,
		knob3_value_binding,
		semimodal0_binding,
		knob0_value_binding_2,
		knob1_value_binding_2,
		knob2_value_binding_2,
		knob3_value_binding_1,
		knob4_value_binding,
		knob5_value_binding,
		semimodal1_binding,
		knob0_value_binding_3,
		knob1_value_binding_3,
		knob2_value_binding_3,
		knob3_value_binding_2,
		knob4_value_binding_1,
		knob5_value_binding_1,
		knob6_value_binding,
		texturewidget_brush_textures_binding,
		texturewidget_selected_brush_texture_binding,
		semimodal2_binding,
		canvas_binding
	];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, App_svelte_instance, App_svelte_create_fragment, safe_not_equal, {}, App_svelte_add_css, [-1, -1, -1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: App_svelte_create_fragment.name
		});
	}
}

/* harmony default export */ const App_svelte = (App);
;// CONCATENATED MODULE: ./src/index.ts



const app = new App_svelte({
    target: document.body,
    props: {},
});
/* harmony default export */ const src = ((/* unused pure expression or super */ null && (app)));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRixtR0FBbUc7QUFDbkcsbUdBQW1HO0FBQ25HLG1HQUFtRztBQUNuRyxtR0FBbUc7QUFDbkcsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtDQUFrQyxFQUFFLGFBQWEsRUFBRTtBQUNuRCxtQ0FBbUMsRUFBRSxhQUFhLEVBQUU7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0EsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMkY7QUFDM0YsbUdBQW1HO0FBQ25HLG1HQUFtRztBQUNuRyxtR0FBbUc7QUFDbkcsbUdBQW1HO0FBQ25HLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUU7QUFDckU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUM7QUFDekMseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckU7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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SUFDTCxPQUFRO0FBQUEsSUFBSyxPQUFRO0FBQUEsSUFBSyxPQUFRO0FBQUEsSUFBSztBQUFBLElBQ3ZDLE9BQVE7QUFBQSxJQUFLLE9BQVE7QUFBQSxJQUFLLE9BQVE7QUFBQSxJQUFLO0FBQUEsSUFDdkMsT0FBUTtBQUFBLElBQUssT0FBUTtBQUFBLElBQUssT0FBUTtBQUFBLElBQUs7QUFBQSxJQUN2QztBQUFBLElBQUs7QUFBQSxJQUFLO0FBQUEsSUFBSztBQUFBO0FBQUE7OztBQ1BaLHFCQUFzQixHQUE0QjtBQUN2RCxRQUNFLE1BQU0sRUFBSSxJQUFLLE1BQU0sRUFBSSxJQUFLLE1BQU0sRUFBSSxJQUFLLE1BQU0sRUFBSSxJQUN2RCxNQUFNLEVBQUksSUFBSyxNQUFNLEVBQUksSUFBSyxNQUFNLEVBQUksSUFBSyxNQUFNLEVBQUksSUFDdkQsTUFBTSxFQUFJLElBQUssTUFBTSxFQUFJLElBQUssTUFBTSxFQUFHLEtBQU0sTUFBTSxFQUFHLEtBQ3RELE1BQU0sRUFBRyxLQUFNLE1BQU0sRUFBRyxLQUFNLE1BQU0sRUFBRyxLQUFNLE1BQU0sRUFBRyxLQUN0RCxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxLQUN0RCxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxLQUN0RCxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxLQUN0RCxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxLQUN0RCxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxLQUN0RCxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUV4RCxRQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBRTlFLE1BQUssUUFBUSxHQUFNO0FBQUUsV0FBTyxTQUFVLEdBQUc7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LEVBQUksSUFBSyxNQUFNLEVBQUksSUFBSyxNQUFNLEVBQUksSUFBSyxNQUFNLEVBQUksSUFDdkQsTUFBTSxFQUFJLElBQUssTUFBTSxFQUFJLElBQUssTUFBTSxFQUFJLElBQUssTUFBTSxFQUFJLElBQ3ZELE1BQU0sRUFBSSxJQUFLLE1BQU0sRUFBSSxJQUFLLE1BQU0sRUFBRyxLQUFNLE1BQU0sRUFBRyxLQUN0RCxNQUFNLEVBQUcsS0FBTSxNQUFNLEVBQUcsS0FBTSxNQUFNLEVBQUcsS0FBTSxNQUFNLEVBQUcsS0FDdEQsTUFBTSxFQUFJLElBQUssTUFBTSxFQUFJLElBQUssTUFBTSxFQUFJLElBQUssTUFBTSxFQUFJLElBQ3ZELE1BQU0sRUFBSSxJQUFLLE1BQU0sRUFBSSxJQUFLLE1BQU0sRUFBSSxJQUFLLE1BQU0sRUFBSSxJQUN2RCxNQUFNLEVBQUksSUFBSyxNQUFNLEVBQUksSUFBSyxNQUFNLEVBQUcsS0FBTSxNQUFNLEVBQUcsS0FDdEQsTUFBTSxFQUFHLEtBQU0sTUFBTSxFQUFHLEtBQU0sTUFBTSxFQUFHLEtBQU0sTUFBTSxFQUFHO0FBRXhELFNBQU87QUFBQSxJQUNMLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU07QUFBQSxJQUMxQyxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBQUEsSUFDMUMsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU07QUFBQSxJQUUxQyxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBQUEsSUFDMUMsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLElBQzFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU07QUFBQSxJQUMxQyxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBQUEsSUFFMUMsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFB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QyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUNELE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDaEIsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2YsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDZixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDZixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2YsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNaLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuRixDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNqQixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFDRCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2pCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNqQixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNmLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNmLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFDRCxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNuQixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUM3QixDQUFDO0lBQ0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDckIsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlFLENBQUM7SUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNsQixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUM3QixDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDbEIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBQ0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2YsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBQ0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2YsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFDRCxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDZixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBQ0QsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xCLE9BQU8sTUFBTSxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFDRCxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDbEIsT0FBTyxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUNELE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDaEIsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7SUFDRCxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMxQixNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDZCxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUNELE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNkLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUU7UUFDdEIsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBQ0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUU7UUFDdkIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ2hCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNwRixDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUNoQixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDcEYsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDaEIsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BGLENBQUM7SUFDRCxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDZixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0UsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xGLENBQUM7Q0FDRDs7O0FDMVl5QztBQUNOO0FBQ0s7QUFFbEMsTUFBTSxPQUFPO0lBRW5CLEdBQUcsQ0FBYztJQUNqQixlQUFlLENBQVE7SUFDdkIsTUFBTSxDQUFRO0lBQ2QsSUFBSSxDQUFRO0lBQ1osR0FBRyxDQUFlO0lBRVYsUUFBUSxDQUFTO0lBQ3pCLFNBQVMsQ0FBUztJQUNWLFVBQVUsQ0FBUTtJQUUxQixZQUFZLEdBQWEsRUFBRSxrQkFBMEIsRUFBRSxDQUFDLElBQUksRUFBRSxTQUFTLEdBQUcsS0FBSyxFQUFFLGFBQXFCLENBQUM7UUFDdEcsTUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFNLEVBQUUsQ0FBUSxFQUFXLEVBQUU7WUFDNUMsSUFBSSxFQUFFLEdBQUcsS0FBSztZQUNkLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtnQkFDZixJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQ1osRUFBRSxHQUFHLElBQUk7aUJBRVQ7WUFDRixDQUFDLENBQUM7WUFDRixPQUFPLEVBQUU7UUFDVixDQUFDO1FBQ0QsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQyxlQUFlLEdBQUcsZUFBZTtRQUV0QyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVM7UUFDMUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVO1FBRTVCLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV2RixJQUFJLFFBQVEsR0FBRyxDQUFDO1FBQ2hCLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7WUFDM0gsUUFBUSxHQUFHLENBQUM7U0FDWjtRQUNELElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7WUFDbkgsUUFBUSxHQUFHLENBQUM7U0FDWjtRQUVELElBQUksQ0FBQyxNQUFNLEdBQUcsUUFBUSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUc7UUFDL0MsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsYUFBYTtRQUV2RCxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7WUFDdkcsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsWUFBWTtTQUMzQjtRQUNELElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLE1BQU0sRUFBRSxF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LEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1lBSXBELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1lBSXBELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDdEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDdEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1lBSXBELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1lBSXBELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDdEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDdEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1lBSXBELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ25ELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxZQUFZO1NBQ3BEO1FBQ0QsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksS0FBSyxH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QUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsWUFBWTtZQUlwRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNO1lBQzVDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsWUFBWTtZQUlwRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ3RELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ3RELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNO1lBQzVDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsWUFBWTtZQUtwRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNO1lBQzVDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsWUFBWTtZQUlwRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ3RELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ3RELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNO1lBQzVDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsWUFBWTtZQUlwRCxZQUFZ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QUMsQ0FBQyxDQUFDO1lBQ2xELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFDdkMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBV3BELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3RELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzFELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzFELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDckQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDMUQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztZQUN2QyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFVcEQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzFELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzFELFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMxRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMxRCxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDM0QsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDMUQsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztZQUN2QyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFD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QUMxQixVQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztHQUE3QixVQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs7Ozs7OzBCQUM3QixVQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztHQUE3QixVQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs7Ozs7OzBCQUM3QixVQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztHQUE3QixVQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs7Ozs7O0VBQ1gsY0FBYzs7Ozs7MEJBQStCLFVBQVUsQ0FBQyxzQkFBc0I7R0FBakMsVUFBVSxDQUFDLHNCQUFzQjs7Ozs7OztHQVI3RixvQkFBb0I7Ozs7Ozs7R0FXWixhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNGRDtBQUNoQjtBQUVhO0FBRXpDLE1BQU0sR0FBRyxHQUFHLElBQUksVUFBRyxDQUFDO0lBQ25CLE1BQU0sRUFBRSxRQUFRLENBQUMsSUFBSTtJQUNyQixLQUFLLEVBQUUsRUFBRTtDQUNULENBQUM7QUFFRiwwQ0FBZSxtREFBRyIsInNvdXJjZXMiOlsid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvc3R5bGUuY3NzIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvaW1hZ2VzL2Jyb3cud2VicCIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2ltYWdlcy9jaGFyY29hbC53ZWJwIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvaW1hZ2VzL2NpcmNsZS53ZWJwIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvaW1hZ2VzL2dyYWRpZW50X2JvdHRvbV90b190b3Aud2VicCIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2ltYWdlcy9vaWxfMDEud2VicCIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2ltYWdlcy9vaWxfdGFwZXIud2VicCIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2ltYWdlcy9zcXVhcmUud2VicCIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFVybC5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9kcm9wYm94L2Rpc3QvRHJvcGJveC1zZGsubWluLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9saWJ0ZXNzL2xpYnRlc3MubWluLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9icnVzaC1ibG9icy5zdmciLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9icnVzaC1sb25nLnN2ZyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2JydXNoLXRyaWFuZ2xlcy5zdmciLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9jYXB0dXJlLnN2ZyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2NvcHkuc3ZnIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvZG93bmxvYWQuc3ZnIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvZm9yYmlkLnN2ZyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL2xhdW5jaC5zdmciLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9vay5zdmciLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3B1YmxpYy9wbHVnLnN2ZyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL3JlZG8uc3ZnIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvcmVzaXplLnN2ZyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL3NvbHZlLnN2ZyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vcHVibGljL3RpbWUuc3ZnIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvdW5kby5zdmciLCJ3ZWJwYWNrOi8vc3BsdW5nZS9pZ25vcmVkfC9ob21lL3J1bm5lci93b3JrL3NwbHVuZ2Uvc3BsdW5nZS9ub2RlX21vZHVsZXMvZHJvcGJveC9kaXN0fGNyeXB0byIsIndlYnBhY2s6Ly9zcGx1bmdlL2lnbm9yZWR8L2hvbWUvcnVubmVyL3dvcmsvc3BsdW5nZS9zcGx1bmdlL25vZGVfbW9kdWxlcy9kcm9wYm94L2Rpc3R8dXRpbCIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL2Nocm9tYS1qcy9jaHJvbWEuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9zcGx1bmdlL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3NwbHVuZ2Uvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3NwbHVuZ2Uvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9zcGx1bmdlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vc3BsdW5nZS93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9zcGx1bmdlL3dlYnBhY2svcnVudGltZS9qc29ucCBjaHVuayBsb2FkaW5nIiwid2VicGFjazovL3NwbHVuZ2Uvd2VicGFjay9ydW50aW1lL25vbmNlIiwid2VicGFjazovL3NwbHVuZ2UvLi9wdWJsaWMvc3R5bGUuY3NzP2NlYzciLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvbG9vcC5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9nbG9iYWxzLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL1Jlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2RvbS5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9zdHlsZV9tYW5hZ2VyLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2FuaW1hdGlvbnMuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvbGlmZWN5Y2xlLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3NjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC90cmFuc2l0aW9ucy5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9hd2FpdF9ibG9jay5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9lYWNoLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9zaGFyZWQvYm9vbGVhbl9hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3Nzci5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3NoYXJlZC92ZXJzaW9uLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2Rldi5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9kaXNjbG9zZS12ZXJzaW9uL2luZGV4LmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2luZGV4LmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL3N0b3JlL2luZGV4LmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvc3RvcmUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9hbGdvcml0aG0vYmluYXJ5U2VhcmNoLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvYWxnb3JpdGhtL3RyYXZlcnNlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvYXJyYXkvYXJyYXlSYW5nZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2FycmF5L2FycmF5U2VyaWFsLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvYXJyYXkvYXJyYXlTZXQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9hcnJheS9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9hcnJheS91dGlscy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL0NEUy9DRFMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9DbG9jay9DbG9jay50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL0Nsb2NrL0Nsb2NrRnJhbWUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9DbG9jay9DbG9ja1JlYWx0aW1lLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvY29sb3IvY29sb3JGcm9tQXRhcmlTVC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9jb2xvci9jb2xvckhTVjJSR0IudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9jb2xvci9jb2xvclRvSGV4LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWMvdmVjRG90LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvY29sb3IvY29sb3JUdXJiby50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2NvbG9yL2VvdGZSZWM3MDkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9jb2xvci9vZXRmUmVjNzA5LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvZGFnL2RhZ0VkZ2VzUGFyZW50cy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2RhZy9kYWdFZGdlc0FuY2VzdG9ycy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL2RhZy9kYWdFZGdlc0NoaWxkcmVuLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvZGFnL2RhZ0VkZ2VzRGVzY2VuZGFudHMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9kYWcvZGFnRWRnZXNQYXJlbnQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9kYWcvZGFnRWRnZXNSZXNvbHZlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvZWR0L2VkdC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL0V4cFNtb290aC9FeHBTbW9vdGgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9Qb29sL1Bvb2wudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9HUFVUaW1lci9HUFVUaW1lci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL0hpc3RvcnlNZWFuQ2FsY3VsYXRvci9IaXN0b3J5TWVhbkNhbGN1bGF0b3IudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9IaXN0b3J5TWVhbkNhbGN1bGF0b3IvSGlzdG9yeVBlcmNlbnRpbGVDYWxjdWxhdG9yLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvSGlzdG9yeU1lYW5DYWxjdWxhdG9yL0hpc3RvcnlNZWRpYW5DYWxjdWxhdG9yLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvTWFwT2ZTZXQvTWFwT2ZTZXQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYy92ZWNBYnMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYy92ZWNBZGQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYy92ZWNEaXZpZGUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYy92ZWNMZW5ndGgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYy92ZWNMZW5ndGhTcS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjL3ZlY01hbmhhdHRhbkxlbmd0aC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjL3ZlY011bHRpcGx5LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWMvdmVjTmVnLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWMvdmVjU2NhbGUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYy92ZWNOb3JtYWxpemUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYy92ZWNTdWIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYy9WZWN0b3IudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYzQvdmVjNEFwcGx5TWF0cml4NC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjMy92ZWMzQXBwbHlNYXRyaXg0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9xdWF0L3F1YXRJbnZlcnNlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9xdWF0L3F1YXRNdWx0aXBseS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjMy92ZWMzQXBwbHlRdWF0ZXJuaW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWMzL3ZlYzNDcm9zcy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjMy92ZWMzT3J0aG9Ob3JtYWxpemUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3ZlYzMvVmVjdG9yMy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvYm94My9ib3gzQ29udGFpbnNQb2ludC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvYm94My9Cb3gzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQzL21hdDNGcm9tTWF0NFRyYW5zcG9zZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0My9tYXQzSW52ZXJzZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0My9tYXQzQ3JlYXRlTm9ybWFsTWF0cml4LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQzL21hdDNEZXRlcm1pbmFudC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0My9tYXQzRnJvbU1hdDQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDMvbWF0M0Zyb21RdWF0ZXJuaW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQzL21hdDNNdWx0aXBseS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0My9tYXQzVHJhbnNwb3NlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQzL01hdHJpeDMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NEZyb21RdWF0ZXJuaW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQ0L21hdDRDb21wb3NlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQ0L21hdDREZXRlcm1pbmFudC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcXVhdC9xdWF0RnJvbU1hdHJpeDMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3F1YXQvcXVhdEZyb21NYXRyaXg0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQ0L21hdDREZWNvbXBvc2UudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NEZyb21NYXQzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQ0L21hdDRJbnZlcnNlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQ0L21hdDRMb29rQXQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NExvb2tBdEludmVyc2UudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NE11bHRpcGx5LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQ0L21hdDRQZXJzcGVjdGl2ZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0NC9tYXQ0Um90YXRpb25YLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQ0L21hdDRSb3RhdGlvblkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NFJvdGF0aW9uWi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0NC9tYXQ0U2NhbGUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NFNjYWxlU2NhbGFyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQ0L21hdDRUcmFuc2xhdGUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDQvbWF0NFRyYW5zcG9zZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0NC9NYXRyaXg0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9xdWF0L3F1YXRGcm9tQXhpc0FuZ2xlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9xdWF0L3F1YXRMb29rUm90YXRpb24udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3F1YXQvcXVhdE5vcm1hbGl6ZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcXVhdC9xdWF0Um90YXRpb25YLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9xdWF0L3F1YXRSb3RhdGlvblkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3F1YXQvcXVhdFJvdGF0aW9uWi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcXVhdC9xdWF0U2xlcnAudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3F1YXQvUXVhdGVybmlvbi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbW9kLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9zYW5pdGl6ZUFuZ2xlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9ldWxlci9ldWxlckZyb21NYXQzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9ldWxlci9ldWxlckZyb21NYXQ0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9ldWxlci9ldWxlckZyb21RdWF0ZXJuaW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9xdWF0L3F1YXRGcm9tRXVsZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL2V1bGVyL0V1bGVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9yYXkzL3JheTNEaXN0YW5jZVRvU3BoZXJlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9saW5lMy9saW5lM0RlbHRhLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9yYXkzL3JheTNGcm9tTGluZTMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3JheTMvUmF5My50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbGluZTMvbGluZTNBcHBseU1hdHJpeDQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL2xpbmUzL2xpbmUzQXQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL2xpbmUzL2xpbmUzQ2xvc2VzdFBvaW50VG9Qb2ludC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbGluZTMvbGluZTNEaXN0YW5jZVRvUG9pbnQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL2xpbmUzL0xpbmUzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9tYXQyL21hdDJEZXRlcm1pbmFudC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0Mi9tYXQySW52ZXJzZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0Mi9tYXQyTXVsdGlwbHkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL21hdDIvbWF0MlRyYW5zcG9zZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvbWF0Mi9NYXRyaXgyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWMzL3ZlYzNBcHBseU1hdHJpeDMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3BsYW5lMy9wbGFuZTNBcHBseU1hdHJpeDQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3BsYW5lMy9wbGFuZTNEaXN0YW5jZVRvUG9pbnQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3BsYW5lMy9wbGFuZTNOb3JtYWxpemUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3BsYW5lMy9QbGFuZTMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3BsYW5lMy9wbGFuZXMzQ29udGFpblBvaW50LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9wbGFuZTMvcGxhbmVzM0Zyb21Cb3gzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9wbGFuZTMvcGxhbmVzM0Zyb21Qcm9qZWN0aW9uTWF0cml4LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC9wbGFuZTMvcGxhbmVzM0ludGVyc2VjdEJveDMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3BsYW5lMy9wbGFuZXMzSW50ZXJzZWN0U3BoZXJlMy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvcGxhbmUzL1BsYW5lczMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3NwaGVyZTMvc3BoZXJlM0NvbnRhaW5zUG9pbnQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9tYXRoL3NwaGVyZTMvU3BoZXJlMy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL21hdGgvdmVjNC92ZWM0QXBwbHlNYXRyaXgzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvbWF0aC92ZWM0L1ZlY3RvcjQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9taWRpL21pZGlQYXJzZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL3Bva2VyL3Bva2VyUmFua3NCeVN0cmVuZ3RoLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvcG9rZXIvcG9rZXJTdWl0c0J5SW5kZXgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9wb2tlci9jcmVhdGVQb2tlckRlY2sudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9wb2tlci9wb2tlckhhbmRTdHJlbmd0aE1hcC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL3Bva2VyL3Bva2VyUmFua1N0cmVuZ3RoTWFwLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvcG9rZXIvcG9rZXJTdWl0SW5kZXhNYXAudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9wb2tlci9zb3J0UG9rZXJDYXJkc0J5UmFuay50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL3Bva2VyL2V2YWx1YXRlUG9rZXJIYW5kLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvcG9rZXIvcG9rZXJIYW5kc0J5U3RyZW5ndGgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9yZXRyeS9hc3luY1JldHJ5LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvcmV0cnkvcmV0cnkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy9zdG5pY2NjL3BhcnNlU1ROSUNDQy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL3N0bmljY2Mvc3RuaWNjY1RvU1ZHLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvU21vb3RoRGFtcC9TbW9vdGhEYW1wLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvU3dhcC9Td2FwLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvVGFwVGVtcG8vVGFwVGVtcG8udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AMGI1dnIvZXhwZXJpbWVudGFsL3NyYy90aW55c2VxL2NyZWF0ZVRpbnlzZXFQb2x5UmVhZGVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvdGlueXNlcS9jcmVhdGVUaW55c2VxUmVhZGVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvdGlueXNlcS90aW55c2VxRnJvbU1pZGlQYXJzZVJlc3VsdC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL1hvcnNoaWZ0L1hvcnNoaWZ0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMveXVnb3AvZ2V0WXVnb3BUZXh0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQDBiNXZyL2V4cGVyaW1lbnRhbC9zcmMvQmluYXJ5SGVhcC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0AwYjV2ci9leHBlcmltZW50YWwvc3JjL25vdGlmeU9ic2VydmVycy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL3dtYXRoLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvZ2wvVGV4dHVyZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2dsL0ZyYW1lYnVmZmVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvZ2xfdXRpbHMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvZWFzaW5nL2luZGV4LmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL3RyYW5zaXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL1NlbWlNb2RhbC5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL0tub2Iuc3ZlbHRlIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvY29tcG9uZW50cy9CcnVzaFNpemVXaWRnZXQuc3ZlbHRlIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvc3R1ZmYudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9icnVzaF9zdHJva2UudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL0JydXNoVHlwZVdpZGdldC5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL0JydXNoUHJlc2V0V2lkZ2V0LnN2ZWx0ZSIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2NvbXBvbmVudHMvVW5kb1JlZG9XaWRnZXQuc3ZlbHRlIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy9hc3NlcnQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvY3J5cHQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvZGVlcENvcHkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvZ2xvYmFsLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL2RlZmF1bHRzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL2RlZmVycmVkLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL2VtdWxhdG9yLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL2Vudmlyb25tZW50LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL2Vycm9ycy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy9qc29uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL2p3dC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy9vYmoudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvcHJvbWlzZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy9xdWVyeS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy9zaGExLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL3N1YnNjcmliZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy92YWxpZGF0aW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL3V0ZjgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvdXVpZC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL3NyYy9leHBvbmVudGlhbF9iYWNrb2ZmLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvc3JjL2Zvcm1hdHRlcnMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9zcmMvY29tcGF0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9zcmMvY29tcG9uZW50LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9zcmMvY29uc3RhbnRzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9zcmMvcHJvdmlkZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L3NyYy9jb21wb25lbnRfY29udGFpbmVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9zcmMvbG9nZ2VyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL3dyYXAtaWRiLXZhbHVlLmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9zcmMvcGxhdGZvcm1Mb2dnZXJTZXJ2aWNlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9zcmMvbG9nZ2VyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9zcmMvY29uc3RhbnRzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9zcmMvaW50ZXJuYWwudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL3NyYy9lcnJvcnMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL3NyYy9maXJlYmFzZUFwcC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvc3JjL2FwaS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvc3JjL2luZGV4ZWRkYi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvc3JjL2hlYXJ0YmVhdFNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL3NyYy9yZWdpc3RlckNvcmVDb21wb25lbnRzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYubWpzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL21vZGVsL2VudW1fbWFwcy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL2Vycm9ycy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3V0aWwvbG9nLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC9hc3NlcnQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91dGlsL2xvY2F0aW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC9uYXZpZ2F0b3IudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91dGlsL2RlbGF5LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC9lbXVsYXRvci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3V0aWwvZmV0Y2hfcHJvdmlkZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL2Vycm9ycy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL2FjY291bnRfbWFuYWdlbWVudC9hY2NvdW50LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC90aW1lLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXNlci9pZF90b2tlbl9yZXN1bHQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91c2VyL2ludmFsaWRhdGlvbi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3VzZXIvcHJvYWN0aXZlX3JlZnJlc2gudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91c2VyL3VzZXJfbWV0YWRhdGEudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91c2VyL3JlbG9hZC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvYXV0aGVudGljYXRpb24vdG9rZW4udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91c2VyL3Rva2VuX21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91c2VyL3VzZXJfaW1wbC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3V0aWwvaW5zdGFudGlhdG9yLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvcGVyc2lzdGVuY2UvaW5fbWVtb3J5LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvcGVyc2lzdGVuY2UvcGVyc2lzdGVuY2VfdXNlcl9tYW5hZ2VyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC9icm93c2VyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXRpbC92ZXJzaW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2FwaS9hdXRoZW50aWNhdGlvbi9yZWNhcHRjaGEudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9yZWNhcHRjaGEvcmVjYXB0Y2hhLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvbG9hZF9qcy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL3JlY2FwdGNoYS9yZWNhcHRjaGFfZW50ZXJwcmlzZV92ZXJpZmllci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL2F1dGgvbWlkZGxld2FyZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL2F1dGgvYXV0aF9pbXBsLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvYXV0aC9pbml0aWFsaXplLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvYXV0aC9lbXVsYXRvci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL2NyZWRlbnRpYWxzL2F1dGhfY3JlZGVudGlhbC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L2VtYWlsX2FuZF9wYXNzd29yZC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvYXV0aGVudGljYXRpb24vZW1haWxfYW5kX3Bhc3N3b3JkLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2FwaS9hdXRoZW50aWNhdGlvbi9lbWFpbF9saW5rLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvY3JlZGVudGlhbHMvZW1haWwudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL2F1dGhlbnRpY2F0aW9uL2lkcC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL2NyZWRlbnRpYWxzL29hdXRoLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2FwaS9hdXRoZW50aWNhdGlvbi9zbXMudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9jcmVkZW50aWFscy9waG9uZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL2FjdGlvbl9jb2RlX3VybC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3Byb3ZpZGVycy9lbWFpbC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3Byb3ZpZGVycy9mZWRlcmF0ZWQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9wcm92aWRlcnMvb2F1dGgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9wcm92aWRlcnMvZmFjZWJvb2sudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9wcm92aWRlcnMvZ29vZ2xlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvcHJvdmlkZXJzL2dpdGh1Yi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL2NyZWRlbnRpYWxzL3NhbWwudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9wcm92aWRlcnMvc2FtbC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3Byb3ZpZGVycy90d2l0dGVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2FwaS9hdXRoZW50aWNhdGlvbi9zaWduX3VwLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXNlci91c2VyX2NyZWRlbnRpYWxfaW1wbC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3N0cmF0ZWdpZXMvYW5vbnltb3VzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL21mYS9tZmFfZXJyb3IudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91dGlsL3Byb3ZpZGVycy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3VzZXIvbGlua191bmxpbmsudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91c2VyL3JlYXV0aGVudGljYXRlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvc3RyYXRlZ2llcy9jcmVkZW50aWFsLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2FwaS9hdXRoZW50aWNhdGlvbi9jdXN0b21fdG9rZW4udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9zdHJhdGVnaWVzL2N1c3RvbV90b2tlbi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9tZmEvbWZhX2luZm8udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9zdHJhdGVnaWVzL2FjdGlvbl9jb2RlX3NldHRpbmdzLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvc3RyYXRlZ2llcy9lbWFpbF9hbmRfcGFzc3dvcmQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9zdHJhdGVnaWVzL2VtYWlsX2xpbmsudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL2F1dGhlbnRpY2F0aW9uL2NyZWF0ZV9hdXRoX3VyaS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3N0cmF0ZWdpZXMvZW1haWwudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL2FjY291bnRfbWFuYWdlbWVudC9wcm9maWxlLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvdXNlci9hY2NvdW50X2luZm8udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS91c2VyL2FkZGl0aW9uYWxfdXNlcl9pbmZvLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvbWZhL21mYV9zZXNzaW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL21mYS9tZmFfcmVzb2x2ZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL2FjY291bnRfbWFuYWdlbWVudC9tZmEudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvbWZhL21mYV91c2VyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvcGVyc2lzdGVuY2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9wZXJzaXN0ZW5jZS9icm93c2VyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvcGVyc2lzdGVuY2UvbG9jYWxfc3RvcmFnZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL3BlcnNpc3RlbmNlL3Nlc3Npb25fc3RvcmFnZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL21lc3NhZ2VjaGFubmVsL3Byb21pc2UudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9tZXNzYWdlY2hhbm5lbC9yZWNlaXZlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3V0aWwvZXZlbnRfaWQudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9tZXNzYWdlY2hhbm5lbC9zZW5kZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9hdXRoX3dpbmRvdy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL3V0aWwvd29ya2VyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvcGVyc2lzdGVuY2UvaW5kZXhlZF9kYi50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9hcGkvYXV0aGVudGljYXRpb24vbWZhLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvcmVjYXB0Y2hhL3JlY2FwdGNoYV9tb2NrLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvcmVjYXB0Y2hhL3JlY2FwdGNoYV9sb2FkZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9yZWNhcHRjaGEvcmVjYXB0Y2hhX3ZlcmlmaWVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvc3RyYXRlZ2llcy9waG9uZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL3Byb3ZpZGVycy9waG9uZS50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3V0aWwvcmVzb2x2ZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9zdHJhdGVnaWVzL2lkcC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3N0cmF0ZWdpZXMvYWJzdHJhY3RfcG9wdXBfcmVkaXJlY3Rfb3BlcmF0aW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvc3RyYXRlZ2llcy9wb3B1cC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3N0cmF0ZWdpZXMvcmVkaXJlY3QudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9zdHJhdGVnaWVzL3JlZGlyZWN0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL2NvcmUvYXV0aC9hdXRoX2V2ZW50X21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvYXBpL3Byb2plY3RfY29uZmlnL2dldF9wcm9qZWN0X2NvbmZpZy50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3V0aWwvdmFsaWRhdGVfb3JpZ2luLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvaWZyYW1lL2dhcGkudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvcGxhdGZvcm1fYnJvd3Nlci9pZnJhbWUvaWZyYW1lLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvdXRpbC9wb3B1cC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL3V0aWwvaGFuZGxlci50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9wbGF0Zm9ybV9icm93c2VyL3BvcHVwX3JlZGlyZWN0LnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL21mYS9tZmFfYXNzZXJ0aW9uLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvbWZhL2Fzc2VydGlvbnMvcGhvbmUudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvbWZhL2Fzc2VydGlvbnMvdG90cC50cyIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL3NyYy9jb3JlL2F1dGgvZmlyZWJhc2VfaW50ZXJuYWwudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9zcmMvY29yZS9hdXRoL3JlZ2lzdGVyLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvc3JjL3BsYXRmb3JtX2Jyb3dzZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9hcHAvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9kcm9wYm94X2F1dGgudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL0dhbGxlcnlXaWRnZXQuc3ZlbHRlIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvY29tcG9uZW50cy9GbG9hdGluZ01vZGFsLnN2ZWx0ZSIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2NvbXBvbmVudHMvUGlja0NvbG91cldpZGdldC5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL1RleHR1cmVXaWRnZXQuc3ZlbHRlIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvY29tcG9uZW50cy9CbGVuZGluZ0NvbG91clNwYWNlV2lkZ2V0LnN2ZWx0ZSIsIndlYnBhY2s6Ly9zcGx1bmdlLy4vc3JjL2NvbXBvbmVudHMvUkdCU2xpZGVycy5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL0NvbG91ckRpc3BsYXkuc3ZlbHRlIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvY29tcG9uZW50cy9Gb3VySWNvbnNXaWRnZXQuc3ZlbHRlIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvSU8udHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9nbC9CdWZmZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9nbC9TaGFkZXJQcm9ncmFtLnRzIiwid2VicGFjazovL3NwbHVuZ2UvLi9zcmMvZ2wvVGhpbmcudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9kcmF3ZXIudHMiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9jb21wb25lbnRzL0FwcC5zdmVsdGUiLCJ3ZWJwYWNrOi8vc3BsdW5nZS8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSBuZXcgVVJMKFwiLi9KZXRCcmFpbnNNb25vLVJlZ3VsYXIudHRmXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGBAZm9udC1mYWNlIHtcbiAgZm9udC1mYW1pbHk6IFwiSmV0QnJhaW5zIE1vbm9cIjtcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xuICBmb250LXdlaWdodDogNDAwO1xuICBzcmM6IHVybCgke19fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX199KSBmb3JtYXQoXCJ0cnVldHlwZVwiKTtcbn1cblxuKiB7XG4gIHVzZXItc2VsZWN0OiBub25lO1xuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xufVxuXG5ib2R5IHtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwO1xuICB3aWR0aDogMTAwdnc7XG4gIGhlaWdodDogMTAwdmg7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAvKiBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjazsgKi9cbiAgdG91Y2gtYWN0aW9uOiBub25lO1xuICBtYXJnaW46IDBweDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbn1cbmh0bWwge1xuICB0b3VjaC1hY3Rpb246IG5vbmU7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG59XG5cbmNhbnZhcyB7XG4gIG1heC13aWR0aDogMTAwJTtcbiAgbWF4LWhlaWdodDogMTAwJTtcbiAgLyogd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTsgKi9cbiAgdG91Y2gtYWN0aW9uOiBub25lO1xufVxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9wdWJsaWMvc3R5bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsNkJBQTZCO0VBQzdCLGtCQUFrQjtFQUNsQixnQkFBZ0I7RUFDaEIsK0RBQTBEO0FBQzVEOztBQUVBO0VBQ0UsaUJBQWlCO0VBQ2pCLHdDQUF3QztBQUMxQzs7QUFFQTtFQUNFLFNBQVM7RUFDVCxVQUFVO0VBQ1YsWUFBWTtFQUNaLGFBQWE7RUFDYixnQkFBZ0I7RUFDaEIsYUFBYTtFQUNiLG1CQUFtQjtFQUNuQix1QkFBdUI7RUFDdkIsNkJBQTZCO0VBQzdCLGtCQUFrQjtFQUNsQixXQUFXO0VBQ1gsV0FBVztFQUNYLFlBQVk7QUFDZDtBQUNBO0VBQ0Usa0JBQWtCO0VBQ2xCLFdBQVc7RUFDWCxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxlQUFlO0VBQ2YsZ0JBQWdCO0VBQ2hCO2lCQUNlO0VBQ2Ysa0JBQWtCO0FBQ3BCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJKZXRCcmFpbnMgTW9ub1xcXCI7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgc3JjOiB1cmwoXFxcIi4vSmV0QnJhaW5zTW9uby1SZWd1bGFyLnR0ZlxcXCIpIGZvcm1hdChcXFwidHJ1ZXR5cGVcXFwiKTtcXG59XFxuXFxuKiB7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcblxcbmJvZHkge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIHdpZHRoOiAxMDB2dztcXG4gIGhlaWdodDogMTAwdmg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIC8qIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyAqL1xcbiAgdG91Y2gtYWN0aW9uOiBub25lO1xcbiAgbWFyZ2luOiAwcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuaHRtbCB7XFxuICB0b3VjaC1hY3Rpb246IG5vbmU7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuXFxuY2FudmFzIHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIG1heC1oZWlnaHQ6IDEwMCU7XFxuICAvKiB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTsgKi9cXG4gIHRvdWNoLWFjdGlvbjogbm9uZTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsImV4cG9ydCBkZWZhdWx0IFwiLi9pbWFnZXMvYzllYzI3NDY2ZmVlYzY2MzljMGU3Y2RkNzk4ZTU3MDcud2VicFwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLi9pbWFnZXMvMTFkMTgxOWMzMjkwOTdiZDQyZDYxMmFmNTE5ODRlYmYud2VicFwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLi9pbWFnZXMvZjU4MjIxNGZmMzM1MGYxOTU3ZDJlNWY3MWFjNjA4OWMud2VicFwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLi9pbWFnZXMvZjA2OTMyYWM1MTZmN2M3MmNlODQ4ZGZlNWExNTU3Y2Eud2VicFwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLi9pbWFnZXMvZjc0NDIwNDFjYjlkNmRiMDJiN2Y4MGU5YTNhYTI5OGYud2VicFwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLi9pbWFnZXMvMmVlNWRkMmY3NjU0NDg5OWQ5MTc0NjRmMWM3ZWQ2ODcud2VicFwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLi9pbWFnZXMvMzIwZmM3YjdiMWE2NTg1ODhkNWIwMjBhOTBjM2VlMjYud2VicFwiOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIHVybCA9IFN0cmluZyh1cmwuX19lc01vZHVsZSA/IHVybC5kZWZhdWx0IDogdXJsKTtcblxuICAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cbiAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgfVxuICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgdXJsICs9IG9wdGlvbnMuaGFzaDtcbiAgfVxuXG4gIC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcbiAgaWYgKC9bXCInKCkgXFx0XFxuXXwoJTIwKS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSwgXCJcXFwiXCIpO1xuICB9XG4gIHJldHVybiB1cmw7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/dChleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sdCk6dCgoZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOmV8fHNlbGYpLkRyb3Bib3g9e30pfSh0aGlzLChmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiByKGUsdCl7Zm9yKHZhciByPTA7dC5sZW5ndGg+cjtyKyspe3ZhciBpPXRbcl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGkua2V5LGkpfX1mdW5jdGlvbiBpKGUsdCxpKXtyZXR1cm4gdCYmcihlLnByb3RvdHlwZSx0KSxpJiZyKGUsaSksZX1mdW5jdGlvbiBzKGUpe3JldHVybihzPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiBuKGUsdCl7cmV0dXJuKG49T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfWZ1bmN0aW9uIGEoKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaChlKXtyZXR1cm4hMX19ZnVuY3Rpb24gbyhlLHQscil7cmV0dXJuKG89YSgpP1JlZmxlY3QuY29uc3RydWN0OmZ1bmN0aW9uKGUsdCxyKXt2YXIgaT1bbnVsbF07aS5wdXNoLmFwcGx5KGksdCk7dmFyIHM9bmV3KEZ1bmN0aW9uLmJpbmQuYXBwbHkoZSxpKSk7cmV0dXJuIHImJm4ocyxyLnByb3RvdHlwZSksc30pLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiB1KGUpe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIE1hcD9uZXcgTWFwOnZvaWQgMDtyZXR1cm4odT1mdW5jdGlvbihlKXtpZihudWxsPT09ZXx8LTE9PT1GdW5jdGlvbi50b1N0cmluZy5jYWxsKGUpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpKXJldHVybiBlO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2lmKHZvaWQgMCE9PXQpe2lmKHQuaGFzKGUpKXJldHVybiB0LmdldChlKTt0LnNldChlLHIpfWZ1bmN0aW9uIHIoKXtyZXR1cm4gbyhlLGFyZ3VtZW50cyxzKHRoaXMpLmNvbnN0cnVjdG9yKX1yZXR1cm4gci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnIsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksbihyLGUpfSkoZSl9ZnVuY3Rpb24gYyhlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9mdW5jdGlvbihlKXtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gZX0oZSk6dH12YXIgcD1cImFwcFwiLGw9XCJ1c2VyXCIsZj1cInRlYW1cIixtPVwiZHJvcGJveGFwaS5jb21cIixoPVwiZHJvcGJveC5jb21cIixkPXthcGk6XCJhcGlcIixub3RpZnk6XCJib2x0XCIsY29udGVudDpcImFwaS1jb250ZW50XCJ9LF89e307ZnVuY3Rpb24gZyhlKXt2YXIgdD1cIjAwMFwiLmNvbmNhdChlLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7cmV0dXJuXCJcXFxcdVwiLmNvbmNhdCh0KX1fLmFjY291bnRTZXRQcm9maWxlUGhvdG89ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImFjY291bnQvc2V0X3Byb2ZpbGVfcGhvdG9cIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImFjY291bnRfaW5mby53cml0ZVwiKX0sXy5hdXRoVG9rZW5Gcm9tT2F1dGgxPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJhdXRoL3Rva2VuL2Zyb21fb2F1dGgxXCIsZSxcImFwcFwiLFwiYXBpXCIsXCJycGNcIixudWxsKX0sXy5hdXRoVG9rZW5SZXZva2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiYXV0aC90b2tlbi9yZXZva2VcIixudWxsLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixudWxsKX0sXy5jaGVja0FwcD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiY2hlY2svYXBwXCIsZSxcImFwcFwiLFwiYXBpXCIsXCJycGNcIixudWxsKX0sXy5jaGVja1VzZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImNoZWNrL3VzZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImFjY291bnRfaW5mby5yZWFkXCIpfSxfLmNvbnRhY3RzRGVsZXRlTWFudWFsQ29udGFjdHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiY29udGFjdHMvZGVsZXRlX21hbnVhbF9jb250YWN0c1wiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiY29udGFjdHMud3JpdGVcIil9LF8uY29udGFjdHNEZWxldGVNYW51YWxDb250YWN0c0JhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJjb250YWN0cy9kZWxldGVfbWFudWFsX2NvbnRhY3RzX2JhdGNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJjb250YWN0cy53cml0ZVwiKX0sXy5maWxlUHJvcGVydGllc1Byb3BlcnRpZXNBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy9wcm9wZXJ0aWVzL2FkZFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEud3JpdGVcIil9LF8uZmlsZVByb3BlcnRpZXNQcm9wZXJ0aWVzT3ZlcndyaXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3Byb3BlcnRpZXMvcHJvcGVydGllcy9vdmVyd3JpdGVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVQcm9wZXJ0aWVzUHJvcGVydGllc1JlbW92ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3Byb3BlcnRpZXMvcmVtb3ZlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlUHJvcGVydGllc1Byb3BlcnRpZXNTZWFyY2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy9wcm9wZXJ0aWVzL3NlYXJjaFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlUHJvcGVydGllc1Byb3BlcnRpZXNTZWFyY2hDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3Byb3BlcnRpZXMvc2VhcmNoL2NvbnRpbnVlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVQcm9wZXJ0aWVzUHJvcGVydGllc1VwZGF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3Byb3BlcnRpZXMvdXBkYXRlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlUHJvcGVydGllc1RlbXBsYXRlc0FkZEZvclRlYW09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy90ZW1wbGF0ZXMvYWRkX2Zvcl90ZWFtXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy50ZWFtX21ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVQcm9wZXJ0aWVzVGVtcGxhdGVzQWRkRm9yVXNlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3RlbXBsYXRlcy9hZGRfZm9yX3VzZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVQcm9wZXJ0aWVzVGVtcGxhdGVzR2V0Rm9yVGVhbT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3RlbXBsYXRlcy9nZXRfZm9yX3RlYW1cIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLnRlYW1fbWV0YWRhdGEud3JpdGVcIil9LF8uZmlsZVByb3BlcnRpZXNUZW1wbGF0ZXNHZXRGb3JVc2VyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3Byb3BlcnRpZXMvdGVtcGxhdGVzL2dldF9mb3JfdXNlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlUHJvcGVydGllc1RlbXBsYXRlc0xpc3RGb3JUZWFtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy90ZW1wbGF0ZXMvbGlzdF9mb3JfdGVhbVwiLG51bGwsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMudGVhbV9tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlUHJvcGVydGllc1RlbXBsYXRlc0xpc3RGb3JVc2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy90ZW1wbGF0ZXMvbGlzdF9mb3JfdXNlclwiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlUHJvcGVydGllc1RlbXBsYXRlc1JlbW92ZUZvclRlYW09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcHJvcGVydGllcy90ZW1wbGF0ZXMvcmVtb3ZlX2Zvcl90ZWFtXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy50ZWFtX21ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVQcm9wZXJ0aWVzVGVtcGxhdGVzUmVtb3ZlRm9yVXNlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3RlbXBsYXRlcy9yZW1vdmVfZm9yX3VzZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVQcm9wZXJ0aWVzVGVtcGxhdGVzVXBkYXRlRm9yVGVhbT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9wcm9wZXJ0aWVzL3RlbXBsYXRlcy91cGRhdGVfZm9yX3RlYW1cIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLnRlYW1fbWV0YWRhdGEud3JpdGVcIil9LF8uZmlsZVByb3BlcnRpZXNUZW1wbGF0ZXNVcGRhdGVGb3JVc2VyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3Byb3BlcnRpZXMvdGVtcGxhdGVzL3VwZGF0ZV9mb3JfdXNlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEud3JpdGVcIil9LF8uZmlsZVJlcXVlc3RzQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9yZXF1ZXN0cy9jb3VudFwiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZV9yZXF1ZXN0cy5yZWFkXCIpfSxfLmZpbGVSZXF1ZXN0c0NyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9yZXF1ZXN0cy9jcmVhdGVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVfcmVxdWVzdHMud3JpdGVcIil9LF8uZmlsZVJlcXVlc3RzRGVsZXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3JlcXVlc3RzL2RlbGV0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZV9yZXF1ZXN0cy53cml0ZVwiKX0sXy5maWxlUmVxdWVzdHNEZWxldGVBbGxDbG9zZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9yZXF1ZXN0cy9kZWxldGVfYWxsX2Nsb3NlZFwiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZV9yZXF1ZXN0cy53cml0ZVwiKX0sXy5maWxlUmVxdWVzdHNHZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcmVxdWVzdHMvZ2V0XCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlX3JlcXVlc3RzLnJlYWRcIil9LF8uZmlsZVJlcXVlc3RzTGlzdFYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3JlcXVlc3RzL2xpc3RfdjJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVfcmVxdWVzdHMucmVhZFwiKX0sXy5maWxlUmVxdWVzdHNMaXN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVfcmVxdWVzdHMvbGlzdFwiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZV9yZXF1ZXN0cy5yZWFkXCIpfSxfLmZpbGVSZXF1ZXN0c0xpc3RDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZV9yZXF1ZXN0cy9saXN0L2NvbnRpbnVlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlX3JlcXVlc3RzLnJlYWRcIil9LF8uZmlsZVJlcXVlc3RzVXBkYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlX3JlcXVlc3RzL3VwZGF0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZV9yZXF1ZXN0cy53cml0ZVwiKX0sXy5maWxlc0FscGhhR2V0TWV0YWRhdGE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2FscGhhL2dldF9tZXRhZGF0YVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlc0FscGhhVXBsb2FkPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9hbHBoYS91cGxvYWRcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwidXBsb2FkXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weVYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9jb3B5X3YyXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY29weVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0NvcHlCYXRjaFYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9jb3B5X2JhdGNoX3YyXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weUJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9jb3B5X2JhdGNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weUJhdGNoQ2hlY2tWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY29weV9iYXRjaC9jaGVja192MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0NvcHlCYXRjaENoZWNrPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9jb3B5X2JhdGNoL2NoZWNrXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weVJlZmVyZW5jZUdldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY29weV9yZWZlcmVuY2UvZ2V0XCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ29weVJlZmVyZW5jZVNhdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2NvcHlfcmVmZXJlbmNlL3NhdmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNDcmVhdGVGb2xkZXJWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY3JlYXRlX2ZvbGRlcl92MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0NyZWF0ZUZvbGRlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY3JlYXRlX2ZvbGRlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0NyZWF0ZUZvbGRlckJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9jcmVhdGVfZm9sZGVyX2JhdGNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzQ3JlYXRlRm9sZGVyQmF0Y2hDaGVjaz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvY3JlYXRlX2ZvbGRlcl9iYXRjaC9jaGVja1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0RlbGV0ZVYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9kZWxldGVfdjJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNEZWxldGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2RlbGV0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0RlbGV0ZUJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9kZWxldGVfYmF0Y2hcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNEZWxldGVCYXRjaENoZWNrPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9kZWxldGVfYmF0Y2gvY2hlY2tcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNEb3dubG9hZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZG93bmxvYWRcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwiZG93bmxvYWRcIixcImZpbGVzLmNvbnRlbnQucmVhZFwiKX0sXy5maWxlc0Rvd25sb2FkWmlwPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9kb3dubG9hZF96aXBcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwiZG93bmxvYWRcIixcImZpbGVzLmNvbnRlbnQucmVhZFwiKX0sXy5maWxlc0V4cG9ydD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZXhwb3J0XCIsZSxcInVzZXJcIixcImNvbnRlbnRcIixcImRvd25sb2FkXCIsXCJmaWxlcy5jb250ZW50LnJlYWRcIil9LF8uZmlsZXNHZXRGaWxlTG9ja0JhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9nZXRfZmlsZV9sb2NrX2JhdGNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LnJlYWRcIil9LF8uZmlsZXNHZXRNZXRhZGF0YT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZ2V0X21ldGFkYXRhXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVzR2V0UHJldmlldz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZ2V0X3ByZXZpZXdcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwiZG93bmxvYWRcIixcImZpbGVzLmNvbnRlbnQucmVhZFwiKX0sXy5maWxlc0dldFRlbXBvcmFyeUxpbms9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2dldF90ZW1wb3JhcnlfbGlua1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC5yZWFkXCIpfSxfLmZpbGVzR2V0VGVtcG9yYXJ5VXBsb2FkTGluaz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZ2V0X3RlbXBvcmFyeV91cGxvYWRfbGlua1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc0dldFRodW1ibmFpbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvZ2V0X3RodW1ibmFpbFwiLGUsXCJ1c2VyXCIsXCJjb250ZW50XCIsXCJkb3dubG9hZFwiLFwiZmlsZXMuY29udGVudC5yZWFkXCIpfSxfLmZpbGVzR2V0VGh1bWJuYWlsVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2dldF90aHVtYm5haWxfdjJcIixlLFwiYXBwLCB1c2VyXCIsXCJjb250ZW50XCIsXCJkb3dubG9hZFwiLFwiZmlsZXMuY29udGVudC5yZWFkXCIpfSxfLmZpbGVzR2V0VGh1bWJuYWlsQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2dldF90aHVtYm5haWxfYmF0Y2hcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LnJlYWRcIil9LF8uZmlsZXNMaXN0Rm9sZGVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9saXN0X2ZvbGRlclwiLGUsXCJhcHAsIHVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVzTGlzdEZvbGRlckNvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9saXN0X2ZvbGRlci9jb250aW51ZVwiLGUsXCJhcHAsIHVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVzTGlzdEZvbGRlckdldExhdGVzdEN1cnNvcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvbGlzdF9mb2xkZXIvZ2V0X2xhdGVzdF9jdXJzb3JcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLnJlYWRcIil9LF8uZmlsZXNMaXN0Rm9sZGVyTG9uZ3BvbGw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2xpc3RfZm9sZGVyL2xvbmdwb2xsXCIsZSxcIm5vYXV0aFwiLFwibm90aWZ5XCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLnJlYWRcIil9LF8uZmlsZXNMaXN0UmV2aXNpb25zPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9saXN0X3JldmlzaW9uc1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlc0xvY2tGaWxlQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL2xvY2tfZmlsZV9iYXRjaFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc01vdmVWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvbW92ZV92MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc01vdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL21vdmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNNb3ZlQmF0Y2hWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvbW92ZV9iYXRjaF92MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc01vdmVCYXRjaD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvbW92ZV9iYXRjaFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc01vdmVCYXRjaENoZWNrVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL21vdmVfYmF0Y2gvY2hlY2tfdjJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNNb3ZlQmF0Y2hDaGVjaz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvbW92ZV9iYXRjaC9jaGVja1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1BhcGVyQ3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9wYXBlci9jcmVhdGVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJ1cGxvYWRcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNQYXBlclVwZGF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvcGFwZXIvdXBkYXRlXCIsZSxcInVzZXJcIixcImFwaVwiLFwidXBsb2FkXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzUGVybWFuZW50bHlEZWxldGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Blcm1hbmVudGx5X2RlbGV0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMucGVybWFuZW50X2RlbGV0ZVwiKX0sXy5maWxlc1Byb3BlcnRpZXNBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Byb3BlcnRpZXMvYWRkXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlc1Byb3BlcnRpZXNPdmVyd3JpdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Byb3BlcnRpZXMvb3ZlcndyaXRlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlc1Byb3BlcnRpZXNSZW1vdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Byb3BlcnRpZXMvcmVtb3ZlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlc1Byb3BlcnRpZXNUZW1wbGF0ZUdldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvcHJvcGVydGllcy90ZW1wbGF0ZS9nZXRcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLnJlYWRcIil9LF8uZmlsZXNQcm9wZXJ0aWVzVGVtcGxhdGVMaXN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Byb3BlcnRpZXMvdGVtcGxhdGUvbGlzdFwiLG51bGwsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlc1Byb3BlcnRpZXNVcGRhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Byb3BlcnRpZXMvdXBkYXRlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlc1Jlc3RvcmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3Jlc3RvcmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNTYXZlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy9zYXZlX3VybFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1NhdmVVcmxDaGVja0pvYlN0YXR1cz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvc2F2ZV91cmwvY2hlY2tfam9iX3N0YXR1c1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1NlYXJjaD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvc2VhcmNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVzU2VhcmNoVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3NlYXJjaF92MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlc1NlYXJjaENvbnRpbnVlVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3NlYXJjaC9jb250aW51ZV92MlwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5maWxlc1RhZ3NBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3RhZ3MvYWRkXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS53cml0ZVwiKX0sXy5maWxlc1RhZ3NHZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3RhZ3MvZ2V0XCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5tZXRhZGF0YS5yZWFkXCIpfSxfLmZpbGVzVGFnc1JlbW92ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvdGFncy9yZW1vdmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLm1ldGFkYXRhLndyaXRlXCIpfSxfLmZpbGVzVW5sb2NrRmlsZUJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy91bmxvY2tfZmlsZV9iYXRjaFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1VwbG9hZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvdXBsb2FkXCIsZSxcInVzZXJcIixcImNvbnRlbnRcIixcInVwbG9hZFwiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1VwbG9hZFNlc3Npb25BcHBlbmRWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvdXBsb2FkX3Nlc3Npb24vYXBwZW5kX3YyXCIsZSxcInVzZXJcIixcImNvbnRlbnRcIixcInVwbG9hZFwiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1VwbG9hZFNlc3Npb25BcHBlbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3VwbG9hZF9zZXNzaW9uL2FwcGVuZFwiLGUsXCJ1c2VyXCIsXCJjb250ZW50XCIsXCJ1cGxvYWRcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNVcGxvYWRTZXNzaW9uRmluaXNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy91cGxvYWRfc2Vzc2lvbi9maW5pc2hcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwidXBsb2FkXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzVXBsb2FkU2Vzc2lvbkZpbmlzaEJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJmaWxlcy91cGxvYWRfc2Vzc2lvbi9maW5pc2hfYmF0Y2hcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8uZmlsZXNVcGxvYWRTZXNzaW9uRmluaXNoQmF0Y2hWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvdXBsb2FkX3Nlc3Npb24vZmluaXNoX2JhdGNoX3YyXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzVXBsb2FkU2Vzc2lvbkZpbmlzaEJhdGNoQ2hlY2s9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3VwbG9hZF9zZXNzaW9uL2ZpbmlzaF9iYXRjaC9jaGVja1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5maWxlc1VwbG9hZFNlc3Npb25TdGFydD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwiZmlsZXMvdXBsb2FkX3Nlc3Npb24vc3RhcnRcIixlLFwidXNlclwiLFwiY29udGVudFwiLFwidXBsb2FkXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLmZpbGVzVXBsb2FkU2Vzc2lvblN0YXJ0QmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcImZpbGVzL3VwbG9hZF9zZXNzaW9uL3N0YXJ0X2JhdGNoXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLm9wZW5pZFVzZXJpbmZvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJvcGVuaWQvdXNlcmluZm9cIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcIm9wZW5pZFwiKX0sXy5wYXBlckRvY3NBcmNoaXZlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL2FyY2hpdmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLmNvbnRlbnQud3JpdGVcIil9LF8ucGFwZXJEb2NzQ3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL2NyZWF0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInVwbG9hZFwiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5wYXBlckRvY3NEb3dubG9hZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwicGFwZXIvZG9jcy9kb3dubG9hZFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcImRvd25sb2FkXCIsXCJmaWxlcy5jb250ZW50LnJlYWRcIil9LF8ucGFwZXJEb2NzRm9sZGVyVXNlcnNMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL2ZvbGRlcl91c2Vycy9saXN0XCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLnJlYWRcIil9LF8ucGFwZXJEb2NzRm9sZGVyVXNlcnNMaXN0Q29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInBhcGVyL2RvY3MvZm9sZGVyX3VzZXJzL2xpc3QvY29udGludWVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5wYXBlckRvY3NHZXRGb2xkZXJJbmZvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL2dldF9mb2xkZXJfaW5mb1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnBhcGVyRG9jc0xpc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInBhcGVyL2RvY3MvbGlzdFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5wYXBlckRvY3NMaXN0Q29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInBhcGVyL2RvY3MvbGlzdC9jb250aW51ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMubWV0YWRhdGEucmVhZFwiKX0sXy5wYXBlckRvY3NQZXJtYW5lbnRseURlbGV0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwicGFwZXIvZG9jcy9wZXJtYW5lbnRseV9kZWxldGVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLnBlcm1hbmVudF9kZWxldGVcIil9LF8ucGFwZXJEb2NzU2hhcmluZ1BvbGljeUdldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwicGFwZXIvZG9jcy9zaGFyaW5nX3BvbGljeS9nZXRcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5wYXBlckRvY3NTaGFyaW5nUG9saWN5U2V0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL3NoYXJpbmdfcG9saWN5L3NldFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5wYXBlckRvY3NVcGRhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInBhcGVyL2RvY3MvdXBkYXRlXCIsZSxcInVzZXJcIixcImFwaVwiLFwidXBsb2FkXCIsXCJmaWxlcy5jb250ZW50LndyaXRlXCIpfSxfLnBhcGVyRG9jc1VzZXJzQWRkPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL3VzZXJzL2FkZFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5wYXBlckRvY3NVc2Vyc0xpc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInBhcGVyL2RvY3MvdXNlcnMvbGlzdFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnBhcGVyRG9jc1VzZXJzTGlzdENvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9kb2NzL3VzZXJzL2xpc3QvY29udGludWVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5wYXBlckRvY3NVc2Vyc1JlbW92ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwicGFwZXIvZG9jcy91c2Vycy9yZW1vdmVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8ucGFwZXJGb2xkZXJzQ3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJwYXBlci9mb2xkZXJzL2NyZWF0ZVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMuY29udGVudC53cml0ZVwiKX0sXy5zaGFyaW5nQWRkRmlsZU1lbWJlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9hZGRfZmlsZV9tZW1iZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ0FkZEZvbGRlck1lbWJlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9hZGRfZm9sZGVyX21lbWJlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nQ2hlY2tKb2JTdGF0dXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvY2hlY2tfam9iX3N0YXR1c1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nQ2hlY2tSZW1vdmVNZW1iZXJKb2JTdGF0dXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvY2hlY2tfcmVtb3ZlX21lbWJlcl9qb2Jfc3RhdHVzXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdDaGVja1NoYXJlSm9iU3RhdHVzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL2NoZWNrX3NoYXJlX2pvYl9zdGF0dXNcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ0NyZWF0ZVNoYXJlZExpbms9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvY3JlYXRlX3NoYXJlZF9saW5rXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdDcmVhdGVTaGFyZWRMaW5rV2l0aFNldHRpbmdzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL2NyZWF0ZV9zaGFyZWRfbGlua193aXRoX3NldHRpbmdzXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdHZXRGaWxlTWV0YWRhdGE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvZ2V0X2ZpbGVfbWV0YWRhdGFcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nR2V0RmlsZU1ldGFkYXRhQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvZ2V0X2ZpbGVfbWV0YWRhdGEvYmF0Y2hcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nR2V0Rm9sZGVyTWV0YWRhdGE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvZ2V0X2ZvbGRlcl9tZXRhZGF0YVwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnNoYXJpbmdHZXRTaGFyZWRMaW5rRmlsZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9nZXRfc2hhcmVkX2xpbmtfZmlsZVwiLGUsXCJ1c2VyXCIsXCJjb250ZW50XCIsXCJkb3dubG9hZFwiLFwic2hhcmluZy5yZWFkXCIpfSxfLnNoYXJpbmdHZXRTaGFyZWRMaW5rTWV0YWRhdGE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvZ2V0X3NoYXJlZF9saW5rX21ldGFkYXRhXCIsZSxcImFwcCwgdXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nR2V0U2hhcmVkTGlua3M9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvZ2V0X3NoYXJlZF9saW5rc1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnNoYXJpbmdMaXN0RmlsZU1lbWJlcnM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9maWxlX21lbWJlcnNcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdEZpbGVNZW1iZXJzQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9maWxlX21lbWJlcnMvYmF0Y2hcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdEZpbGVNZW1iZXJzQ29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9maWxlX21lbWJlcnMvY29udGludWVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdEZvbGRlck1lbWJlcnM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9mb2xkZXJfbWVtYmVyc1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnNoYXJpbmdMaXN0Rm9sZGVyTWVtYmVyc0NvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL2xpc3RfZm9sZGVyX21lbWJlcnMvY29udGludWVcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdEZvbGRlcnM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9mb2xkZXJzXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLnJlYWRcIil9LF8uc2hhcmluZ0xpc3RGb2xkZXJzQ29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbGlzdF9mb2xkZXJzL2NvbnRpbnVlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLnJlYWRcIil9LF8uc2hhcmluZ0xpc3RNb3VudGFibGVGb2xkZXJzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL2xpc3RfbW91bnRhYmxlX2ZvbGRlcnNcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdE1vdW50YWJsZUZvbGRlcnNDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9saXN0X21vdW50YWJsZV9mb2xkZXJzL2NvbnRpbnVlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLnJlYWRcIil9LF8uc2hhcmluZ0xpc3RSZWNlaXZlZEZpbGVzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL2xpc3RfcmVjZWl2ZWRfZmlsZXNcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy5zaGFyaW5nTGlzdFJlY2VpdmVkRmlsZXNDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9saXN0X3JlY2VpdmVkX2ZpbGVzL2NvbnRpbnVlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLnJlYWRcIil9LF8uc2hhcmluZ0xpc3RTaGFyZWRMaW5rcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9saXN0X3NoYXJlZF9saW5rc1wiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy5yZWFkXCIpfSxfLnNoYXJpbmdNb2RpZnlTaGFyZWRMaW5rU2V0dGluZ3M9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvbW9kaWZ5X3NoYXJlZF9saW5rX3NldHRpbmdzXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdNb3VudEZvbGRlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9tb3VudF9mb2xkZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ1JlbGlucXVpc2hGaWxlTWVtYmVyc2hpcD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9yZWxpbnF1aXNoX2ZpbGVfbWVtYmVyc2hpcFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nUmVsaW5xdWlzaEZvbGRlck1lbWJlcnNoaXA9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvcmVsaW5xdWlzaF9mb2xkZXJfbWVtYmVyc2hpcFwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nUmVtb3ZlRmlsZU1lbWJlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9yZW1vdmVfZmlsZV9tZW1iZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ1JlbW92ZUZpbGVNZW1iZXIyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL3JlbW92ZV9maWxlX21lbWJlcl8yXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdSZW1vdmVGb2xkZXJNZW1iZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvcmVtb3ZlX2ZvbGRlcl9tZW1iZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ1Jldm9rZVNoYXJlZExpbms9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvcmV2b2tlX3NoYXJlZF9saW5rXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdTZXRBY2Nlc3NJbmhlcml0YW5jZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9zZXRfYWNjZXNzX2luaGVyaXRhbmNlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdTaGFyZUZvbGRlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy9zaGFyZV9mb2xkZXJcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8uc2hhcmluZ1RyYW5zZmVyRm9sZGVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL3RyYW5zZmVyX2ZvbGRlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nVW5tb3VudEZvbGRlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwic2hhcmluZy91bm1vdW50X2ZvbGRlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nVW5zaGFyZUZpbGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvdW5zaGFyZV9maWxlXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdVbnNoYXJlRm9sZGVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL3Vuc2hhcmVfZm9sZGVyXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdVcGRhdGVGaWxlTWVtYmVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL3VwZGF0ZV9maWxlX21lbWJlclwiLGUsXCJ1c2VyXCIsXCJhcGlcIixcInJwY1wiLFwic2hhcmluZy53cml0ZVwiKX0sXy5zaGFyaW5nVXBkYXRlRm9sZGVyTWVtYmVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJzaGFyaW5nL3VwZGF0ZV9mb2xkZXJfbWVtYmVyXCIsZSxcInVzZXJcIixcImFwaVwiLFwicnBjXCIsXCJzaGFyaW5nLndyaXRlXCIpfSxfLnNoYXJpbmdVcGRhdGVGb2xkZXJQb2xpY3k9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInNoYXJpbmcvdXBkYXRlX2ZvbGRlcl9wb2xpY3lcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcud3JpdGVcIil9LF8udGVhbURldmljZXNMaXN0TWVtYmVyRGV2aWNlcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9kZXZpY2VzL2xpc3RfbWVtYmVyX2RldmljZXNcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInNlc3Npb25zLmxpc3RcIil9LF8udGVhbURldmljZXNMaXN0TWVtYmVyc0RldmljZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vZGV2aWNlcy9saXN0X21lbWJlcnNfZGV2aWNlc1wiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwic2Vzc2lvbnMubGlzdFwiKX0sXy50ZWFtRGV2aWNlc0xpc3RUZWFtRGV2aWNlcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9kZXZpY2VzL2xpc3RfdGVhbV9kZXZpY2VzXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJzZXNzaW9ucy5saXN0XCIpfSxfLnRlYW1EZXZpY2VzUmV2b2tlRGV2aWNlU2Vzc2lvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9kZXZpY2VzL3Jldm9rZV9kZXZpY2Vfc2Vzc2lvblwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwic2Vzc2lvbnMubW9kaWZ5XCIpfSxfLnRlYW1EZXZpY2VzUmV2b2tlRGV2aWNlU2Vzc2lvbkJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2RldmljZXMvcmV2b2tlX2RldmljZV9zZXNzaW9uX2JhdGNoXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJzZXNzaW9ucy5tb2RpZnlcIil9LF8udGVhbUZlYXR1cmVzR2V0VmFsdWVzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2ZlYXR1cmVzL2dldF92YWx1ZXNcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1faW5mby5yZWFkXCIpfSxfLnRlYW1HZXRJbmZvPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vZ2V0X2luZm9cIixudWxsLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1faW5mby5yZWFkXCIpfSxfLnRlYW1Hcm91cHNDcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vZ3JvdXBzL2NyZWF0ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLndyaXRlXCIpfSxfLnRlYW1Hcm91cHNEZWxldGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vZ3JvdXBzL2RlbGV0ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLndyaXRlXCIpfSxfLnRlYW1Hcm91cHNHZXRJbmZvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2dyb3Vwcy9nZXRfaW5mb1wiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLnJlYWRcIil9LF8udGVhbUdyb3Vwc0pvYlN0YXR1c0dldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9ncm91cHMvam9iX3N0YXR1cy9nZXRcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImdyb3Vwcy53cml0ZVwiKX0sXy50ZWFtR3JvdXBzTGlzdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9ncm91cHMvbGlzdFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLnJlYWRcIil9LF8udGVhbUdyb3Vwc0xpc3RDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9ncm91cHMvbGlzdC9jb250aW51ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLnJlYWRcIil9LF8udGVhbUdyb3Vwc01lbWJlcnNBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vZ3JvdXBzL21lbWJlcnMvYWRkXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJncm91cHMud3JpdGVcIil9LF8udGVhbUdyb3Vwc01lbWJlcnNMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2dyb3Vwcy9tZW1iZXJzL2xpc3RcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImdyb3Vwcy5yZWFkXCIpfSxfLnRlYW1Hcm91cHNNZW1iZXJzTGlzdENvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2dyb3Vwcy9tZW1iZXJzL2xpc3QvY29udGludWVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImdyb3Vwcy5yZWFkXCIpfSxfLnRlYW1Hcm91cHNNZW1iZXJzUmVtb3ZlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2dyb3Vwcy9tZW1iZXJzL3JlbW92ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZ3JvdXBzLndyaXRlXCIpfSxfLnRlYW1Hcm91cHNNZW1iZXJzU2V0QWNjZXNzVHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9ncm91cHMvbWVtYmVycy9zZXRfYWNjZXNzX3R5cGVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImdyb3Vwcy53cml0ZVwiKX0sXy50ZWFtR3JvdXBzVXBkYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2dyb3Vwcy91cGRhdGVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImdyb3Vwcy53cml0ZVwiKX0sXy50ZWFtTGVnYWxIb2xkc0NyZWF0ZVBvbGljeT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9sZWdhbF9ob2xkcy9jcmVhdGVfcG9saWN5XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuZ292ZXJuYW5jZS53cml0ZVwiKX0sXy50ZWFtTGVnYWxIb2xkc0dldFBvbGljeT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9sZWdhbF9ob2xkcy9nZXRfcG9saWN5XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuZ292ZXJuYW5jZS53cml0ZVwiKX0sXy50ZWFtTGVnYWxIb2xkc0xpc3RIZWxkUmV2aXNpb25zPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2xlZ2FsX2hvbGRzL2xpc3RfaGVsZF9yZXZpc2lvbnNcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5nb3Zlcm5hbmNlLndyaXRlXCIpfSxfLnRlYW1MZWdhbEhvbGRzTGlzdEhlbGRSZXZpc2lvbnNDb250aW51ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9sZWdhbF9ob2xkcy9saXN0X2hlbGRfcmV2aXNpb25zX2NvbnRpbnVlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuZ292ZXJuYW5jZS53cml0ZVwiKX0sXy50ZWFtTGVnYWxIb2xkc0xpc3RQb2xpY2llcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9sZWdhbF9ob2xkcy9saXN0X3BvbGljaWVzXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuZ292ZXJuYW5jZS53cml0ZVwiKX0sXy50ZWFtTGVnYWxIb2xkc1JlbGVhc2VQb2xpY3k9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbGVnYWxfaG9sZHMvcmVsZWFzZV9wb2xpY3lcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5nb3Zlcm5hbmNlLndyaXRlXCIpfSxfLnRlYW1MZWdhbEhvbGRzVXBkYXRlUG9saWN5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2xlZ2FsX2hvbGRzL3VwZGF0ZV9wb2xpY3lcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5nb3Zlcm5hbmNlLndyaXRlXCIpfSxfLnRlYW1MaW5rZWRBcHBzTGlzdE1lbWJlckxpbmtlZEFwcHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbGlua2VkX2FwcHMvbGlzdF9tZW1iZXJfbGlua2VkX2FwcHNcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInNlc3Npb25zLmxpc3RcIil9LF8udGVhbUxpbmtlZEFwcHNMaXN0TWVtYmVyc0xpbmtlZEFwcHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbGlua2VkX2FwcHMvbGlzdF9tZW1iZXJzX2xpbmtlZF9hcHBzXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJzZXNzaW9ucy5saXN0XCIpfSxfLnRlYW1MaW5rZWRBcHBzTGlzdFRlYW1MaW5rZWRBcHBzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL2xpbmtlZF9hcHBzL2xpc3RfdGVhbV9saW5rZWRfYXBwc1wiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwic2Vzc2lvbnMubGlzdFwiKX0sXy50ZWFtTGlua2VkQXBwc1Jldm9rZUxpbmtlZEFwcD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9saW5rZWRfYXBwcy9yZXZva2VfbGlua2VkX2FwcFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwic2Vzc2lvbnMubW9kaWZ5XCIpfSxfLnRlYW1MaW5rZWRBcHBzUmV2b2tlTGlua2VkQXBwQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbGlua2VkX2FwcHMvcmV2b2tlX2xpbmtlZF9hcHBfYmF0Y2hcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInNlc3Npb25zLm1vZGlmeVwiKX0sXy50ZWFtTWVtYmVyU3BhY2VMaW1pdHNFeGNsdWRlZFVzZXJzQWRkPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcl9zcGFjZV9saW1pdHMvZXhjbHVkZWRfdXNlcnMvYWRkXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJTcGFjZUxpbWl0c0V4Y2x1ZGVkVXNlcnNMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcl9zcGFjZV9saW1pdHMvZXhjbHVkZWRfdXNlcnMvbGlzdFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy5yZWFkXCIpfSxfLnRlYW1NZW1iZXJTcGFjZUxpbWl0c0V4Y2x1ZGVkVXNlcnNMaXN0Q29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVyX3NwYWNlX2xpbWl0cy9leGNsdWRlZF91c2Vycy9saXN0L2NvbnRpbnVlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlclNwYWNlTGltaXRzRXhjbHVkZWRVc2Vyc1JlbW92ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJfc3BhY2VfbGltaXRzL2V4Y2x1ZGVkX3VzZXJzL3JlbW92ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyU3BhY2VMaW1pdHNHZXRDdXN0b21RdW90YT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJfc3BhY2VfbGltaXRzL2dldF9jdXN0b21fcXVvdGFcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMucmVhZFwiKX0sXy50ZWFtTWVtYmVyU3BhY2VMaW1pdHNSZW1vdmVDdXN0b21RdW90YT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJfc3BhY2VfbGltaXRzL3JlbW92ZV9jdXN0b21fcXVvdGFcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlclNwYWNlTGltaXRzU2V0Q3VzdG9tUXVvdGE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVyX3NwYWNlX2xpbWl0cy9zZXRfY3VzdG9tX3F1b3RhXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNBZGRWMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL2FkZF92MlwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc0FkZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL2FkZFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc0FkZEpvYlN0YXR1c0dldFYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvYWRkL2pvYl9zdGF0dXMvZ2V0X3YyXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzQWRkSm9iU3RhdHVzR2V0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvYWRkL2pvYl9zdGF0dXMvZ2V0XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzRGVsZXRlUHJvZmlsZVBob3RvVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9kZWxldGVfcHJvZmlsZV9waG90b192MlwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc0RlbGV0ZVByb2ZpbGVQaG90bz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL2RlbGV0ZV9wcm9maWxlX3Bob3RvXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzR2V0QXZhaWxhYmxlVGVhbU1lbWJlclJvbGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9nZXRfYXZhaWxhYmxlX3RlYW1fbWVtYmVyX3JvbGVzXCIsbnVsbCxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNHZXRJbmZvVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9nZXRfaW5mb192MlwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy5yZWFkXCIpfSxfLnRlYW1NZW1iZXJzR2V0SW5mbz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL2dldF9pbmZvXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNMaXN0VjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9saXN0X3YyXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvbGlzdFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy5yZWFkXCIpfSxfLnRlYW1NZW1iZXJzTGlzdENvbnRpbnVlVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9saXN0L2NvbnRpbnVlX3YyXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNMaXN0Q29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9saXN0L2NvbnRpbnVlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLnJlYWRcIil9LF8udGVhbU1lbWJlcnNNb3ZlRm9ybWVyTWVtYmVyRmlsZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9tb3ZlX2Zvcm1lcl9tZW1iZXJfZmlsZXNcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNNb3ZlRm9ybWVyTWVtYmVyRmlsZXNKb2JTdGF0dXNDaGVjaz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL21vdmVfZm9ybWVyX21lbWJlcl9maWxlcy9qb2Jfc3RhdHVzL2NoZWNrXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzUmVjb3Zlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL3JlY292ZXJcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMuZGVsZXRlXCIpfSxfLnRlYW1NZW1iZXJzUmVtb3ZlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvcmVtb3ZlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLmRlbGV0ZVwiKX0sXy50ZWFtTWVtYmVyc1JlbW92ZUpvYlN0YXR1c0dldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL3JlbW92ZS9qb2Jfc3RhdHVzL2dldFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy5kZWxldGVcIil9LF8udGVhbU1lbWJlcnNTZWNvbmRhcnlFbWFpbHNBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9zZWNvbmRhcnlfZW1haWxzL2FkZFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc1NlY29uZGFyeUVtYWlsc0RlbGV0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL3NlY29uZGFyeV9lbWFpbHMvZGVsZXRlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzU2Vjb25kYXJ5RW1haWxzUmVzZW5kVmVyaWZpY2F0aW9uRW1haWxzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc2Vjb25kYXJ5X2VtYWlscy9yZXNlbmRfdmVyaWZpY2F0aW9uX2VtYWlsc1wiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc1NlbmRXZWxjb21lRW1haWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9zZW5kX3dlbGNvbWVfZW1haWxcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNTZXRBZG1pblBlcm1pc3Npb25zVjI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbWVtYmVycy9zZXRfYWRtaW5fcGVybWlzc2lvbnNfdjJcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNTZXRBZG1pblBlcm1pc3Npb25zPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc2V0X2FkbWluX3Blcm1pc3Npb25zXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzU2V0UHJvZmlsZVYyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc2V0X3Byb2ZpbGVfdjJcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNTZXRQcm9maWxlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc2V0X3Byb2ZpbGVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNTZXRQcm9maWxlUGhvdG9WMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL3NldF9wcm9maWxlX3Bob3RvX3YyXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJtZW1iZXJzLndyaXRlXCIpfSxfLnRlYW1NZW1iZXJzU2V0UHJvZmlsZVBob3RvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc2V0X3Byb2ZpbGVfcGhvdG9cIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcIm1lbWJlcnMud3JpdGVcIil9LF8udGVhbU1lbWJlcnNTdXNwZW5kPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL21lbWJlcnMvc3VzcGVuZFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTWVtYmVyc1Vuc3VzcGVuZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9tZW1iZXJzL3Vuc3VzcGVuZFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwibWVtYmVycy53cml0ZVwiKX0sXy50ZWFtTmFtZXNwYWNlc0xpc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vbmFtZXNwYWNlcy9saXN0XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEubWVtYmVyXCIpfSxfLnRlYW1OYW1lc3BhY2VzTGlzdENvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL25hbWVzcGFjZXMvbGlzdC9jb250aW51ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9kYXRhLm1lbWJlclwiKX0sXy50ZWFtUHJvcGVydGllc1RlbXBsYXRlQWRkPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3Byb3BlcnRpZXMvdGVtcGxhdGUvYWRkXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJmaWxlcy50ZWFtX21ldGFkYXRhLndyaXRlXCIpfSxfLnRlYW1Qcm9wZXJ0aWVzVGVtcGxhdGVHZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vcHJvcGVydGllcy90ZW1wbGF0ZS9nZXRcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLnRlYW1fbWV0YWRhdGEud3JpdGVcIil9LF8udGVhbVByb3BlcnRpZXNUZW1wbGF0ZUxpc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9wcm9wZXJ0aWVzL3RlbXBsYXRlL2xpc3RcIixudWxsLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImZpbGVzLnRlYW1fbWV0YWRhdGEud3JpdGVcIil9LF8udGVhbVByb3BlcnRpZXNUZW1wbGF0ZVVwZGF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9wcm9wZXJ0aWVzL3RlbXBsYXRlL3VwZGF0ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwiZmlsZXMudGVhbV9tZXRhZGF0YS53cml0ZVwiKX0sXy50ZWFtUmVwb3J0c0dldEFjdGl2aXR5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3JlcG9ydHMvZ2V0X2FjdGl2aXR5XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2luZm8ucmVhZFwiKX0sXy50ZWFtUmVwb3J0c0dldERldmljZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vcmVwb3J0cy9nZXRfZGV2aWNlc1wiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9pbmZvLnJlYWRcIil9LF8udGVhbVJlcG9ydHNHZXRNZW1iZXJzaGlwPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3JlcG9ydHMvZ2V0X21lbWJlcnNoaXBcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1faW5mby5yZWFkXCIpfSxfLnRlYW1SZXBvcnRzR2V0U3RvcmFnZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9yZXBvcnRzL2dldF9zdG9yYWdlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2luZm8ucmVhZFwiKX0sXy50ZWFtU2hhcmluZ0FsbG93bGlzdEFkZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS9zaGFyaW5nX2FsbG93bGlzdC9hZGRcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1faW5mby53cml0ZVwiKX0sXy50ZWFtU2hhcmluZ0FsbG93bGlzdExpc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vc2hhcmluZ19hbGxvd2xpc3QvbGlzdFwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9pbmZvLnJlYWRcIil9LF8udGVhbVNoYXJpbmdBbGxvd2xpc3RMaXN0Q29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vc2hhcmluZ19hbGxvd2xpc3QvbGlzdC9jb250aW51ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9pbmZvLnJlYWRcIil9LF8udGVhbVNoYXJpbmdBbGxvd2xpc3RSZW1vdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vc2hhcmluZ19hbGxvd2xpc3QvcmVtb3ZlXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2luZm8ud3JpdGVcIil9LF8udGVhbVRlYW1Gb2xkZXJBY3RpdmF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS90ZWFtX2ZvbGRlci9hY3RpdmF0ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9kYXRhLmNvbnRlbnQud3JpdGVcIil9LF8udGVhbVRlYW1Gb2xkZXJBcmNoaXZlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL2FyY2hpdmVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5jb250ZW50LndyaXRlXCIpfSxfLnRlYW1UZWFtRm9sZGVyQXJjaGl2ZUNoZWNrPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL2FyY2hpdmUvY2hlY2tcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5jb250ZW50LndyaXRlXCIpfSxfLnRlYW1UZWFtRm9sZGVyQ3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL2NyZWF0ZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9kYXRhLmNvbnRlbnQud3JpdGVcIil9LF8udGVhbVRlYW1Gb2xkZXJHZXRJbmZvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL2dldF9pbmZvXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuY29udGVudC5yZWFkXCIpfSxfLnRlYW1UZWFtRm9sZGVyTGlzdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS90ZWFtX2ZvbGRlci9saXN0XCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2RhdGEuY29udGVudC5yZWFkXCIpfSxfLnRlYW1UZWFtRm9sZGVyTGlzdENvbnRpbnVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL2xpc3QvY29udGludWVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5jb250ZW50LnJlYWRcIil9LF8udGVhbVRlYW1Gb2xkZXJQZXJtYW5lbnRseURlbGV0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidGVhbS90ZWFtX2ZvbGRlci9wZXJtYW5lbnRseV9kZWxldGVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5jb250ZW50LndyaXRlXCIpfSxfLnRlYW1UZWFtRm9sZGVyUmVuYW1lPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3RlYW1fZm9sZGVyL3JlbmFtZVwiLGUsXCJ0ZWFtXCIsXCJhcGlcIixcInJwY1wiLFwidGVhbV9kYXRhLmNvbnRlbnQud3JpdGVcIil9LF8udGVhbVRlYW1Gb2xkZXJVcGRhdGVTeW5jU2V0dGluZ3M9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW0vdGVhbV9mb2xkZXIvdXBkYXRlX3N5bmNfc2V0dGluZ3NcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcInRlYW1fZGF0YS5jb250ZW50LndyaXRlXCIpfSxfLnRlYW1Ub2tlbkdldEF1dGhlbnRpY2F0ZWRBZG1pbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtL3Rva2VuL2dldF9hdXRoZW50aWNhdGVkX2FkbWluXCIsbnVsbCxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJ0ZWFtX2luZm8ucmVhZFwiKX0sXy50ZWFtTG9nR2V0RXZlbnRzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ0ZWFtX2xvZy9nZXRfZXZlbnRzXCIsZSxcInRlYW1cIixcImFwaVwiLFwicnBjXCIsXCJldmVudHMucmVhZFwiKX0sXy50ZWFtTG9nR2V0RXZlbnRzQ29udGludWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInRlYW1fbG9nL2dldF9ldmVudHMvY29udGludWVcIixlLFwidGVhbVwiLFwiYXBpXCIsXCJycGNcIixcImV2ZW50cy5yZWFkXCIpfSxfLnVzZXJzRmVhdHVyZXNHZXRWYWx1ZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVxdWVzdChcInVzZXJzL2ZlYXR1cmVzL2dldF92YWx1ZXNcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImFjY291bnRfaW5mby5yZWFkXCIpfSxfLnVzZXJzR2V0QWNjb3VudD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidXNlcnMvZ2V0X2FjY291bnRcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy51c2Vyc0dldEFjY291bnRCYXRjaD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KFwidXNlcnMvZ2V0X2FjY291bnRfYmF0Y2hcIixlLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcInNoYXJpbmcucmVhZFwiKX0sXy51c2Vyc0dldEN1cnJlbnRBY2NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVxdWVzdChcInVzZXJzL2dldF9jdXJyZW50X2FjY291bnRcIixudWxsLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImFjY291bnRfaW5mby5yZWFkXCIpfSxfLnVzZXJzR2V0U3BhY2VVc2FnZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlcXVlc3QoXCJ1c2Vycy9nZXRfc3BhY2VfdXNhZ2VcIixudWxsLFwidXNlclwiLFwiYXBpXCIsXCJycGNcIixcImFjY291bnRfaW5mby5yZWFkXCIpfTt2YXIgcT1mdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06bSxyPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpcIi5cIjtyZXR1cm4gcj8odCE9PW0mJnZvaWQgMCE9PWRbZV0mJihlPWRbZV0scj1cIi1cIiksXCJodHRwczovL1wiLmNvbmNhdChlKS5jb25jYXQocikuY29uY2F0KHQsXCIvMi9cIikpOlwiaHR0cHM6Ly9cIi5jb25jYXQodCxcIi8yL1wiKX0sYj1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpoO3JldHVybiBlIT09aCYmKGU9XCJtZXRhLVwiLmNvbmNhdChlKSksXCJodHRwczovL1wiLmNvbmNhdChlLFwiL29hdXRoMi9hdXRob3JpemVcIil9LHY9ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06bSx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpcIi5cIixyPVwiYXBpXCI7cmV0dXJuIGUhPT1tJiYocj1kW3JdLHQ9XCItXCIpLFwiaHR0cHM6Ly9cIi5jb25jYXQocikuY29uY2F0KHQpLmNvbmNhdChlLFwiL29hdXRoMi90b2tlblwiKX07ZnVuY3Rpb24gdyhlKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSkucmVwbGFjZSgvW1xcdTAwN2YtXFx1ZmZmZl0vZyxnKX1mdW5jdGlvbiBrKGUpe3JldHVybiBuZXcgRGF0ZShEYXRlLm5vdygpKzFlMyplKX1mdW5jdGlvbiB5KCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlJiZzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGV8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBtb2R1bGV8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3d9ZnVuY3Rpb24gQSgpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3d9ZnVuY3Rpb24gUygpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSYmc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlfWZ1bmN0aW9uIEMoZSl7cmV0dXJuIGUudG9TdHJpbmcoXCJiYXNlNjRcIikucmVwbGFjZSgvXFwrL2csXCItXCIpLnJlcGxhY2UoL1xcLy9nLFwiX1wiKS5yZXBsYWNlKC89L2csXCJcIil9dmFyIFQsTCxNLFA9ZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiZuKGUsdCl9KHUsZSk7dmFyIHIsaSxvPShyPXUsaT1hKCksZnVuY3Rpb24oKXt2YXIgZSx0PXMocik7aWYoaSl7dmFyIG49cyh0aGlzKS5jb25zdHJ1Y3RvcjtlPVJlZmxlY3QuY29uc3RydWN0KHQsYXJndW1lbnRzLG4pfWVsc2UgZT10LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gYyh0aGlzLGUpfSk7ZnVuY3Rpb24gdShlLHIsaSl7dmFyIHM7cmV0dXJuIHQodGhpcyx1KSwocz1vLmNhbGwodGhpcyxcIlJlc3BvbnNlIGZhaWxlZCB3aXRoIGEgXCIuY29uY2F0KGUsXCIgY29kZVwiKSkpLm5hbWU9XCJEcm9wYm94UmVzcG9uc2VFcnJvclwiLHMuc3RhdHVzPWUscy5oZWFkZXJzPXIscy5lcnJvcj1pLHN9cmV0dXJuIHV9KHUoRXJyb3IpKSxSPWZ1bmN0aW9uIGUocixpLHMpe3QodGhpcyxlKSx0aGlzLnN0YXR1cz1yLHRoaXMuaGVhZGVycz1pLHRoaXMucmVzdWx0PXN9O2Z1bmN0aW9uIEYoZSl7cmV0dXJuIGUudGV4dCgpLnRoZW4oKGZ1bmN0aW9uKHQpe3ZhciByO3RyeXtyPUpTT04ucGFyc2UodCl9Y2F0Y2goZSl7cj10fXRocm93IG5ldyBQKGUuc3RhdHVzLGUuaGVhZGVycyxyKX0pKX1mdW5jdGlvbiBEKGUpe3JldHVybiBlLm9rP2UudGV4dCgpLnRoZW4oKGZ1bmN0aW9uKHQpe3ZhciByO3RyeXtyPUpTT04ucGFyc2UodCl9Y2F0Y2goZSl7cj10fXJldHVybiBuZXcgUihlLnN0YXR1cyxlLmhlYWRlcnMscil9KSk6RihlKX12YXIgRz1bXCJsZWdhY3lcIixcIm9mZmxpbmVcIixcIm9ubGluZVwiXSxVPVtcImNvZGVcIixcInRva2VuXCJdLHg9W1wibm9uZVwiLFwidXNlclwiLFwidGVhbVwiXSxFPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShyKXt0KHRoaXMsZSkscj1yfHx7fSxBKCk/KFQ9d2luZG93LmZldGNoLmJpbmQod2luZG93KSxMPXdpbmRvdy5jcnlwdG98fHdpbmRvdy5tc0NyeXB0byk6UygpPyhUPXNlbGYuZmV0Y2guYmluZChzZWxmKSxMPXNlbGYuY3J5cHRvKTooVD1yZXF1aXJlKFwibm9kZS1mZXRjaFwiKSxMPXJlcXVpcmUoXCJjcnlwdG9cIikpLE09XCJ1bmRlZmluZWRcIj09dHlwZW9mIFRleHRFbmNvZGVyP3JlcXVpcmUoXCJ1dGlsXCIpLlRleHRFbmNvZGVyOlRleHRFbmNvZGVyLHRoaXMuZmV0Y2g9ci5mZXRjaHx8VCx0aGlzLmFjY2Vzc1Rva2VuPXIuYWNjZXNzVG9rZW4sdGhpcy5hY2Nlc3NUb2tlbkV4cGlyZXNBdD1yLmFjY2Vzc1Rva2VuRXhwaXJlc0F0LHRoaXMucmVmcmVzaFRva2VuPXIucmVmcmVzaFRva2VuLHRoaXMuY2xpZW50SWQ9ci5jbGllbnRJZCx0aGlzLmNsaWVudFNlY3JldD1yLmNsaWVudFNlY3JldCx0aGlzLmRvbWFpbj1yLmRvbWFpbix0aGlzLmRvbWFpbkRlbGltaXRlcj1yLmRvbWFpbkRlbGltaXRlcix0aGlzLmN1c3RvbUhlYWRlcnM9ci5jdXN0b21IZWFkZXJzLHRoaXMuZGF0YU9uQm9keT1yLmRhdGFPbkJvZHl9cmV0dXJuIGkoZSxbe2tleTpcInNldEFjY2Vzc1Rva2VuXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5hY2Nlc3NUb2tlbj1lfX0se2tleTpcImdldEFjY2Vzc1Rva2VuXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbn19LHtrZXk6XCJzZXRDbGllbnRJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuY2xpZW50SWQ9ZX19LHtrZXk6XCJnZXRDbGllbnRJZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xpZW50SWR9fSx7a2V5Olwic2V0Q2xpZW50U2VjcmV0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5jbGllbnRTZWNyZXQ9ZX19LHtrZXk6XCJnZXRDbGllbnRTZWNyZXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsaWVudFNlY3JldH19LHtrZXk6XCJnZXRSZWZyZXNoVG9rZW5cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlZnJlc2hUb2tlbn19LHtrZXk6XCJzZXRSZWZyZXNoVG9rZW5cIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnJlZnJlc2hUb2tlbj1lfX0se2tleTpcImdldEFjY2Vzc1Rva2VuRXhwaXJlc0F0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbkV4cGlyZXNBdH19LHtrZXk6XCJzZXRBY2Nlc3NUb2tlbkV4cGlyZXNBdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuYWNjZXNzVG9rZW5FeHBpcmVzQXQ9ZX19LHtrZXk6XCJzZXRDb2RlVmVyaWZpZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmNvZGVWZXJpZmllcj1lfX0se2tleTpcImdldENvZGVWZXJpZmllclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29kZVZlcmlmaWVyfX0se2tleTpcImdlbmVyYXRlQ29kZUNoYWxsZW5nZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGUsdD10aGlzLHI9KG5ldyBNKS5lbmNvZGUodGhpcy5jb2RlVmVyaWZpZXIpO2lmKEEoKXx8UygpKXJldHVybiBMLnN1YnRsZS5kaWdlc3QoXCJTSEEtMjU2XCIscikudGhlbigoZnVuY3Rpb24ocil7dmFyIGk9YnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkocikpKTtlPUMoaSkuc3Vic3RyKDAsMTI4KSx0LmNvZGVDaGFsbGVuZ2U9ZX0pKTt2YXIgaT1MLmNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKHIpLmRpZ2VzdCgpO3JldHVybiBlPUMoaSksdGhpcy5jb2RlQ2hhbGxlbmdlPWUsUHJvbWlzZS5yZXNvbHZlKCl9fSx7a2V5OlwiZ2VuZXJhdGVQS0NFQ29kZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlO2lmKEEoKXx8UygpKXt2YXIgdD1uZXcgVWludDhBcnJheSgxMjgpLHI9TC5nZXRSYW5kb21WYWx1ZXModCk7ZT1DKGJ0b2EocikpLnN1YnN0cigwLDEyOCl9ZWxzZXtlPUMoTC5yYW5kb21CeXRlcygxMjgpKS5zdWJzdHIoMCwxMjgpfXJldHVybiB0aGlzLmNvZGVWZXJpZmllcj1lLHRoaXMuZ2VuZXJhdGVDb2RlQ2hhbGxlbmdlKCl9fSx7a2V5OlwiZ2V0QXV0aGVudGljYXRpb25VcmxcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByLGk9dGhpcyxzPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpcInRva2VuXCIsbj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106bnVsbCxhPWFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdP2FyZ3VtZW50c1s0XTpudWxsLG89YXJndW1lbnRzLmxlbmd0aD41JiZ2b2lkIDAhPT1hcmd1bWVudHNbNV0/YXJndW1lbnRzWzVdOlwibm9uZVwiLHU9YXJndW1lbnRzLmxlbmd0aD42JiZ2b2lkIDAhPT1hcmd1bWVudHNbNl0mJmFyZ3VtZW50c1s2XSxjPXRoaXMuZ2V0Q2xpZW50SWQoKSxwPWIodGhpcy5kb21haW4pO2lmKCFjKXRocm93IEVycm9yKFwiQSBjbGllbnQgaWQgaXMgcmVxdWlyZWQuIFlvdSBjYW4gc2V0IHRoZSBjbGllbnQgaWQgdXNpbmcgLnNldENsaWVudElkKCkuXCIpO2lmKFwiY29kZVwiIT09cyYmIWUpdGhyb3cgRXJyb3IoXCJBIHJlZGlyZWN0IHVyaSBpcyByZXF1aXJlZC5cIik7aWYoIVUuaW5jbHVkZXMocykpdGhyb3cgRXJyb3IoXCJBdXRob3JpemF0aW9uIHR5cGUgbXVzdCBiZSBjb2RlIG9yIHRva2VuXCIpO2lmKG4mJiFHLmluY2x1ZGVzKG4pKXRocm93IEVycm9yKFwiVG9rZW4gQWNjZXNzIFR5cGUgbXVzdCBiZSBsZWdhY3ksIG9mZmxpbmUsIG9yIG9ubGluZVwiKTtpZihhJiYhKGEgaW5zdGFuY2VvZiBBcnJheSkpdGhyb3cgRXJyb3IoXCJTY29wZSBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3NcIik7aWYoIXguaW5jbHVkZXMobykpdGhyb3cgRXJyb3IoXCJpbmNsdWRlR3JhbnRlZFNjb3BlcyBtdXN0IGJlIG5vbmUsIHVzZXIsIG9yIHRlYW1cIik7cmV0dXJuIHI9XCJjb2RlXCI9PT1zP1wiXCIuY29uY2F0KHAsXCI/cmVzcG9uc2VfdHlwZT1jb2RlJmNsaWVudF9pZD1cIikuY29uY2F0KGMpOlwiXCIuY29uY2F0KHAsXCI/cmVzcG9uc2VfdHlwZT10b2tlbiZjbGllbnRfaWQ9XCIpLmNvbmNhdChjKSxlJiYocis9XCImcmVkaXJlY3RfdXJpPVwiLmNvbmNhdChlKSksdCYmKHIrPVwiJnN0YXRlPVwiLmNvbmNhdCh0KSksbiYmKHIrPVwiJnRva2VuX2FjY2Vzc190eXBlPVwiLmNvbmNhdChuKSksYSYmKHIrPVwiJnNjb3BlPVwiLmNvbmNhdChhLmpvaW4oXCIgXCIpKSksXCJub25lXCIhPT1vJiYocis9XCImaW5jbHVkZV9ncmFudGVkX3Njb3Blcz1cIi5jb25jYXQobykpLHU/dGhpcy5nZW5lcmF0ZVBLQ0VDb2RlcygpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIHIrPVwiJmNvZGVfY2hhbGxlbmdlX21ldGhvZD1TMjU2XCIscis9XCImY29kZV9jaGFsbGVuZ2U9XCIuY29uY2F0KGkuY29kZUNoYWxsZW5nZSl9KSk6UHJvbWlzZS5yZXNvbHZlKHIpfX0se2tleTpcImdldEFjY2Vzc1Rva2VuRnJvbUNvZGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuZ2V0Q2xpZW50SWQoKSxpPXRoaXMuZ2V0Q2xpZW50U2VjcmV0KCk7aWYoIXIpdGhyb3cgRXJyb3IoXCJBIGNsaWVudCBpZCBpcyByZXF1aXJlZC4gWW91IGNhbiBzZXQgdGhlIGNsaWVudCBpZCB1c2luZyAuc2V0Q2xpZW50SWQoKS5cIik7dmFyIHM9dih0aGlzLmRvbWFpbix0aGlzLmRvbWFpbkRlbGltaXRlcik7aWYocys9XCI/Z3JhbnRfdHlwZT1hdXRob3JpemF0aW9uX2NvZGVcIixzKz1cIiZjb2RlPVwiLmNvbmNhdCh0KSxzKz1cIiZjbGllbnRfaWQ9XCIuY29uY2F0KHIpLGkpcys9XCImY2xpZW50X3NlY3JldD1cIi5jb25jYXQoaSk7ZWxzZXtpZighdGhpcy5jb2RlVmVyaWZpZXIpdGhyb3cgRXJyb3IoXCJZb3UgbXVzdCB1c2UgUEtDRSB3aGVuIGdlbmVyYXRpbmcgdGhlIGF1dGhvcml6YXRpb24gVVJMIHRvIG5vdCBpbmNsdWRlIGEgY2xpZW50IHNlY3JldFwiKTtzKz1cIiZjb2RlX3ZlcmlmaWVyPVwiLmNvbmNhdCh0aGlzLmNvZGVWZXJpZmllcil9ZSYmKHMrPVwiJnJlZGlyZWN0X3VyaT1cIi5jb25jYXQoZSkpO3JldHVybiB0aGlzLmZldGNoKHMse21ldGhvZDpcIlBPU1RcIixoZWFkZXJzOntcIkNvbnRlbnQtVHlwZVwiOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJ9fSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIEQoZSl9KSl9fSx7a2V5OlwiY2hlY2tBbmRSZWZyZXNoQWNjZXNzVG9rZW5cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuZ2V0UmVmcmVzaFRva2VuKCkmJnRoaXMuZ2V0Q2xpZW50SWQoKSx0PSF0aGlzLmdldEFjY2Vzc1Rva2VuRXhwaXJlc0F0KCl8fG5ldyBEYXRlKERhdGUubm93KCkrM2U1KT49dGhpcy5nZXRBY2Nlc3NUb2tlbkV4cGlyZXNBdCgpLHI9IXRoaXMuZ2V0QWNjZXNzVG9rZW4oKTtyZXR1cm4odHx8cikmJmU/dGhpcy5yZWZyZXNoQWNjZXNzVG9rZW4oKTpQcm9taXNlLnJlc29sdmUoKX19LHtrZXk6XCJyZWZyZXNoQWNjZXNzVG9rZW5cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06bnVsbCxyPXRoaXMuZ2V0Q2xpZW50SWQoKSxpPXRoaXMuZ2V0Q2xpZW50U2VjcmV0KCk7aWYoIXIpdGhyb3cgRXJyb3IoXCJBIGNsaWVudCBpZCBpcyByZXF1aXJlZC4gWW91IGNhbiBzZXQgdGhlIGNsaWVudCBpZCB1c2luZyAuc2V0Q2xpZW50SWQoKS5cIik7aWYodCYmISh0IGluc3RhbmNlb2YgQXJyYXkpKXRocm93IEVycm9yKFwiU2NvcGUgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzXCIpO3ZhciBzPXYodGhpcy5kb21haW4sdGhpcy5kb21haW5EZWxpbWl0ZXIpLG49e2hlYWRlcnM6e1wiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uXCJ9LG1ldGhvZDpcIlBPU1RcIn07aWYodGhpcy5kYXRhT25Cb2R5KXt2YXIgYT17Z3JhbnRfdHlwZTpcInJlZnJlc2hfdG9rZW5cIixjbGllbnRfaWQ6cixyZWZyZXNoX3Rva2VuOnRoaXMuZ2V0UmVmcmVzaFRva2VuKCl9O2kmJihhLmNsaWVudF9zZWNyZXQ9aSksdCYmKGEuc2NvcGU9dC5qb2luKFwiIFwiKSksbi5ib2R5PWF9ZWxzZSBzKz1cIj9ncmFudF90eXBlPXJlZnJlc2hfdG9rZW4mcmVmcmVzaF90b2tlbj1cIi5jb25jYXQodGhpcy5nZXRSZWZyZXNoVG9rZW4oKSkscys9XCImY2xpZW50X2lkPVwiLmNvbmNhdChyKSxpJiYocys9XCImY2xpZW50X3NlY3JldD1cIi5jb25jYXQoaSkpLHQmJihzKz1cIiZzY29wZT1cIi5jb25jYXQodC5qb2luKFwiIFwiKSkpO3JldHVybiB0aGlzLmZldGNoKHMsbikudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIEQoZSl9KSkudGhlbigoZnVuY3Rpb24odCl7ZS5zZXRBY2Nlc3NUb2tlbih0LnJlc3VsdC5hY2Nlc3NfdG9rZW4pLGUuc2V0QWNjZXNzVG9rZW5FeHBpcmVzQXQoayh0LnJlc3VsdC5leHBpcmVzX2luKSl9KSl9fV0pLGV9KCksQj1cInVuZGVmaW5lZFwiPT10eXBlb2YgYnRvYT9mdW5jdGlvbihlKXtyZXR1cm4gQnVmZmVyLmZyb20oZSkudG9TdHJpbmcoXCJiYXNlNjRcIil9OmJ0b2E7ZS5Ecm9wYm94PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShyKXt0KHRoaXMsZSksdGhpcy5hdXRoPShyPXJ8fHt9KS5hdXRoP3IuYXV0aDpuZXcgRShyKSx0aGlzLmZldGNoPXIuZmV0Y2h8fHRoaXMuYXV0aC5mZXRjaCx0aGlzLnNlbGVjdFVzZXI9ci5zZWxlY3RVc2VyLHRoaXMuc2VsZWN0QWRtaW49ci5zZWxlY3RBZG1pbix0aGlzLnBhdGhSb290PXIucGF0aFJvb3QsdGhpcy5kb21haW49ci5kb21haW58fHRoaXMuYXV0aC5kb21haW4sdGhpcy5kb21haW5EZWxpbWl0ZXI9ci5kb21haW5EZWxpbWl0ZXJ8fHRoaXMuYXV0aC5kb21haW5EZWxpbWl0ZXIsdGhpcy5jdXN0b21IZWFkZXJzPXIuY3VzdG9tSGVhZGVyc3x8dGhpcy5hdXRoLmN1c3RvbUhlYWRlcnMsT2JqZWN0LmFzc2lnbih0aGlzLF8pfXJldHVybiBpKGUsW3trZXk6XCJyZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsaSxzKXtzd2l0Y2gocyl7Y2FzZVwicnBjXCI6cmV0dXJuIHRoaXMucnBjUmVxdWVzdChlLHQscixpKTtjYXNlXCJkb3dubG9hZFwiOnJldHVybiB0aGlzLmRvd25sb2FkUmVxdWVzdChlLHQscixpKTtjYXNlXCJ1cGxvYWRcIjpyZXR1cm4gdGhpcy51cGxvYWRSZXF1ZXN0KGUsdCxyLGkpO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJlcXVlc3Qgc3R5bGU6IFwiLmNvbmNhdChzKSl9fX0se2tleTpcInJwY1JlcXVlc3RcIix2YWx1ZTpmdW5jdGlvbihlLHQscixpKXt2YXIgcz10aGlzO3JldHVybiB0aGlzLmF1dGguY2hlY2tBbmRSZWZyZXNoQWNjZXNzVG9rZW4oKS50aGVuKChmdW5jdGlvbigpe3ZhciBlPXttZXRob2Q6XCJQT1NUXCIsYm9keTp0P0pTT04uc3RyaW5naWZ5KHQpOm51bGwsaGVhZGVyczp7fX07cmV0dXJuIHQmJihlLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl09XCJhcHBsaWNhdGlvbi9qc29uXCIpLHMuc2V0QXV0aEhlYWRlcnMocixlKSxzLnNldENvbW1vbkhlYWRlcnMoZSksZX0pKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gcy5mZXRjaChxKGkscy5kb21haW4scy5kb21haW5EZWxpbWl0ZXIpK2UsdCl9KSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIEQoZSl9KSl9fSx7a2V5OlwiZG93bmxvYWRSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsaSl7dmFyIHM9dGhpcztyZXR1cm4gdGhpcy5hdXRoLmNoZWNrQW5kUmVmcmVzaEFjY2Vzc1Rva2VuKCkudGhlbigoZnVuY3Rpb24oKXt2YXIgZT17bWV0aG9kOlwiUE9TVFwiLGhlYWRlcnM6e1wiRHJvcGJveC1BUEktQXJnXCI6dyh0KX19O3JldHVybiBzLnNldEF1dGhIZWFkZXJzKHIsZSkscy5zZXRDb21tb25IZWFkZXJzKGUpLGV9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHMuZmV0Y2gocShpLHMuZG9tYWluLHMuZG9tYWluRGVsaW1pdGVyKStlLHQpfSkpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZS5vaz9uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7eSgpP2UuYmxvYigpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiB0KGUpfSkpOmUuYnVmZmVyKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIHQoZSl9KSl9KSkudGhlbigoZnVuY3Rpb24odCl7dmFyIHI9SlNPTi5wYXJzZShlLmhlYWRlcnMuZ2V0KFwiZHJvcGJveC1hcGktcmVzdWx0XCIpKTtyZXR1cm4geSgpP3IuZmlsZUJsb2I9dDpyLmZpbGVCaW5hcnk9dCxuZXcgUihlLnN0YXR1cyxlLmhlYWRlcnMscil9KSk6RihlKX0oZSl9KSl9fSx7a2V5OlwidXBsb2FkUmVxdWVzdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLGkpe3ZhciBzPXRoaXM7cmV0dXJuIHRoaXMuYXV0aC5jaGVja0FuZFJlZnJlc2hBY2Nlc3NUb2tlbigpLnRoZW4oKGZ1bmN0aW9uKCl7dmFyIGU9dC5jb250ZW50cztkZWxldGUgdC5jb250ZW50czt2YXIgaT17Ym9keTplLG1ldGhvZDpcIlBPU1RcIixoZWFkZXJzOntcIkNvbnRlbnQtVHlwZVwiOlwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXCJEcm9wYm94LUFQSS1BcmdcIjp3KHQpfX07cmV0dXJuIHMuc2V0QXV0aEhlYWRlcnMocixpKSxzLnNldENvbW1vbkhlYWRlcnMoaSksaX0pKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gcy5mZXRjaChxKGkscy5kb21haW4scy5kb21haW5EZWxpbWl0ZXIpK2UsdCl9KSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIEQoZSl9KSl9fSx7a2V5Olwic2V0QXV0aEhlYWRlcnNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKGUuc3BsaXQoXCIsXCIpLmxlbmd0aD4xKXt2YXIgcj1lLnJlcGxhY2UoXCIgXCIsXCJcIikuc3BsaXQoXCIsXCIpO3IuaW5jbHVkZXMobCkmJnRoaXMuYXV0aC5nZXRBY2Nlc3NUb2tlbigpP2U9bDpyLmluY2x1ZGVzKGYpJiZ0aGlzLmF1dGguZ2V0QWNjZXNzVG9rZW4oKT9lPWY6ci5pbmNsdWRlcyhwKSYmKGU9cCl9c3dpdGNoKGUpe2Nhc2UgcDppZih0aGlzLmF1dGguY2xpZW50SWQmJnRoaXMuYXV0aC5jbGllbnRTZWNyZXQpe3ZhciBpPUIoXCJcIi5jb25jYXQodGhpcy5hdXRoLmNsaWVudElkLFwiOlwiKS5jb25jYXQodGhpcy5hdXRoLmNsaWVudFNlY3JldCkpO3QuaGVhZGVycy5BdXRob3JpemF0aW9uPVwiQmFzaWMgXCIuY29uY2F0KGkpfWJyZWFrO2Nhc2UgZjpjYXNlIGw6dGhpcy5hdXRoLmdldEFjY2Vzc1Rva2VuKCkmJih0LmhlYWRlcnMuQXV0aG9yaXphdGlvbj1cIkJlYXJlciBcIi5jb25jYXQodGhpcy5hdXRoLmdldEFjY2Vzc1Rva2VuKCkpKTticmVhaztjYXNlXCJub2F1dGhcIjpjYXNlXCJjb29raWVcIjpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiVW5oYW5kbGVkIGF1dGggdHlwZTogXCIuY29uY2F0KGUpKX19fSx7a2V5Olwic2V0Q29tbW9uSGVhZGVyc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7KHRoaXMuc2VsZWN0VXNlciYmKGUuaGVhZGVyc1tcIkRyb3Bib3gtQVBJLVNlbGVjdC1Vc2VyXCJdPXRoaXMuc2VsZWN0VXNlciksdGhpcy5zZWxlY3RBZG1pbiYmKGUuaGVhZGVyc1tcIkRyb3Bib3gtQVBJLVNlbGVjdC1BZG1pblwiXT10aGlzLnNlbGVjdEFkbWluKSx0aGlzLnBhdGhSb290JiYoZS5oZWFkZXJzW1wiRHJvcGJveC1BUEktUGF0aC1Sb290XCJdPXRoaXMucGF0aFJvb3QpLHRoaXMuY3VzdG9tSGVhZGVycykmJk9iamVjdC5rZXlzKHRoaXMuY3VzdG9tSGVhZGVycykuZm9yRWFjaCgoZnVuY3Rpb24ocil7ZS5oZWFkZXJzW3JdPXQuY3VzdG9tSGVhZGVyc1tyXX0pKX19XSksZX0oKSxlLkRyb3Bib3hBdXRoPUUsZS5Ecm9wYm94UmVzcG9uc2U9UixlLkRyb3Bib3hSZXNwb25zZUVycm9yPVAsT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGVhcmN1dDtcblxuZnVuY3Rpb24gZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcblxuICAgIGRpbSA9IGRpbSB8fCAyO1xuXG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoLFxuICAgICAgICBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSxcbiAgICAgICAgdHJpYW5nbGVzID0gW107XG5cbiAgICBpZiAoIW91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYpIHJldHVybiB0cmlhbmdsZXM7XG5cbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcblxuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcbiAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcbiAgICAgICAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIGludlNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgICAgICBpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDMyNzY3IC8gaW52U2l6ZSA6IDA7XG4gICAgfVxuXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG4gICAgdmFyIGksIGxhc3Q7XG5cbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICAgIHByZXYsIG5leHQ7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0gfCAwKTtcblxuICAgICAgICAgICAgcmVtb3ZlTm9kZShlYXIpO1xuXG4gICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0ZXggbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuICAgIHZhciBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgeDAgPSBheCA8IGJ4ID8gKGF4IDwgY3ggPyBheCA6IGN4KSA6IChieCA8IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkwID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICB4MSA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTEgPSBheSA+IGJ5ID8gKGF5ID4gY3kgPyBheSA6IGN5KSA6IChieSA+IGN5ID8gYnkgOiBjeSk7XG5cbiAgICB2YXIgcCA9IGMubmV4dDtcbiAgICB3aGlsZSAocCAhPT0gYSkge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIHZhciBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgeDAgPSBheCA8IGJ4ID8gKGF4IDwgY3ggPyBheCA6IGN4KSA6IChieCA8IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkwID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICB4MSA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTEgPSBheSA+IGJ5ID8gKGF5ID4gY3kgPyBheSA6IGN5KSA6IChieSA+IGN5ID8gYnkgOiBjeSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIHZhciBtaW5aID0gek9yZGVyKHgwLCB5MCwgbWluWCwgbWluWSwgaW52U2l6ZSksXG4gICAgICAgIG1heFogPSB6T3JkZXIoeDEsIHkxLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBwID0gZWFyLnByZXZaLFxuICAgICAgICBuID0gZWFyLm5leHRaO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gYm90aCBkaXJlY3Rpb25zXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuXG4gICAgICAgIGlmIChuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG4gICAgd2hpbGUgKG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcbmZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBhID0gcC5wcmV2LFxuICAgICAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xuXG4gICAgICAgIGlmICghZXF1YWxzKGEsIGIpICYmIGludGVyc2VjdHMoYSwgcCwgcC5uZXh0LCBiKSAmJiBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkpIHtcblxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSB8IDApO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhwKTtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cblxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gICAgcmV0dXJuIGEueCAtIGIueDtcbn1cblxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBicmlkZ2UgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmICghYnJpZGdlKSB7XG4gICAgICAgIHJldHVybiBvdXRlck5vZGU7XG4gICAgfVxuXG4gICAgdmFyIGJyaWRnZVJldmVyc2UgPSBzcGxpdFBvbHlnb24oYnJpZGdlLCBob2xlKTtcblxuICAgIC8vIGZpbHRlciBjb2xsaW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgIGZpbHRlclBvaW50cyhicmlkZ2VSZXZlcnNlLCBicmlkZ2VSZXZlcnNlLm5leHQpO1xuICAgIHJldHVybiBmaWx0ZXJQb2ludHMoYnJpZGdlLCBicmlkZ2UubmV4dCk7XG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBwID0gb3V0ZXJOb2RlLFxuICAgICAgICBoeCA9IGhvbGUueCxcbiAgICAgICAgaHkgPSBob2xlLnksXG4gICAgICAgIHF4ID0gLUluZmluaXR5LFxuICAgICAgICBtO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICBkbyB7XG4gICAgICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHJldHVybiBtOyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsZWZ0bW9zdCBlbmRwb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBzdG9wID0gbSxcbiAgICAgICAgbXggPSBtLngsXG4gICAgICAgIG15ID0gbS55LFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgdGFuO1xuXG4gICAgcCA9IG07XG5cbiAgICBkbyB7XG4gICAgICAgIGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKGxvY2FsbHlJbnNpZGUocCwgaG9sZSkgJiZcbiAgICAgICAgICAgICAgICAodGFuIDwgdGFuTWluIHx8ICh0YW4gPT09IHRhbk1pbiAmJiAocC54ID4gbS54IHx8IChwLnggPT09IG0ueCAmJiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSkpKSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0b3ApO1xuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIHdoZXRoZXIgc2VjdG9yIGluIHZlcnRleCBtIGNvbnRhaW5zIHNlY3RvciBpbiB2ZXJ0ZXggcCBpbiB0aGUgc2FtZSBjb29yZGluYXRlc1xuZnVuY3Rpb24gc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkge1xuICAgIHJldHVybiBhcmVhKG0ucHJldiwgbSwgcC5wcmV2KSA8IDAgJiYgYXJlYShwLm5leHQsIG0sIG0ubmV4dCkgPCAwO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IDApIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9ICh4IC0gbWluWCkgKiBpbnZTaXplIHwgMDtcbiAgICB5ID0gKHkgLSBtaW5ZKSAqIGludlNpemUgfCAwO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCB8fCAocC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpKSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSA+PSAoYXggLSBweCkgKiAoY3kgLSBweSkgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpID49IChieCAtIHB4KSAqIChheSAtIHB5KSAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgPj0gKGN4IC0gcHgpICogKGJ5IC0gcHkpO1xufVxuXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiYgLy8gZG9uZXMndCBpbnRlcnNlY3Qgb3RoZXIgZWRnZXNcbiAgICAgICAgICAgKGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYikgJiYgLy8gbG9jYWxseSB2aXNpYmxlXG4gICAgICAgICAgICAoYXJlYShhLnByZXYsIGEsIGIucHJldikgfHwgYXJlYShhLCBiLnByZXYsIGIpKSB8fCAvLyBkb2VzIG5vdCBjcmVhdGUgb3Bwb3NpdGUtZmFjaW5nIHNlY3RvcnNcbiAgICAgICAgICAgIGVxdWFscyhhLCBiKSAmJiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA+IDAgJiYgYXJlYShiLnByZXYsIGIsIGIubmV4dCkgPiAwKTsgLy8gc3BlY2lhbCB6ZXJvLWxlbmd0aCBjYXNlXG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgdmFyIG8xID0gc2lnbihhcmVhKHAxLCBxMSwgcDIpKTtcbiAgICB2YXIgbzIgPSBzaWduKGFyZWEocDEsIHExLCBxMikpO1xuICAgIHZhciBvMyA9IHNpZ24oYXJlYShwMiwgcTIsIHAxKSk7XG4gICAgdmFyIG80ID0gc2lnbihhcmVhKHAyLCBxMiwgcTEpKTtcblxuICAgIGlmIChvMSAhPT0gbzIgJiYgbzMgIT09IG80KSByZXR1cm4gdHJ1ZTsgLy8gZ2VuZXJhbCBjYXNlXG5cbiAgICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBwMiBhcmUgY29sbGluZWFyIGFuZCBwMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBxMiBhcmUgY29sbGluZWFyIGFuZCBxMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzMgPT09IDAgJiYgb25TZWdtZW50KHAyLCBwMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBwMSBhcmUgY29sbGluZWFyIGFuZCBwMSBsaWVzIG9uIHAycTJcbiAgICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBxMSBhcmUgY29sbGluZWFyIGFuZCBxMSBsaWVzIG9uIHAycTJcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gZm9yIGNvbGxpbmVhciBwb2ludHMgcCwgcSwgciwgY2hlY2sgaWYgcG9pbnQgcSBsaWVzIG9uIHNlZ21lbnQgcHJcbmZ1bmN0aW9uIG9uU2VnbWVudChwLCBxLCByKSB7XG4gICAgcmV0dXJuIHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSAmJiBxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSk7XG59XG5cbmZ1bmN0aW9uIHNpZ24obnVtKSB7XG4gICAgcmV0dXJuIG51bSA+IDAgPyAxIDogbnVtIDwgMCA/IC0xIDogMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgcCA9IGE7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID9cbiAgICAgICAgYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxuICAgICAgICBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgICB2YXIgcCA9IGEsXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxuICAgICAgICBweCA9IChhLnggKyBiLngpIC8gMixcbiAgICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XG4gICAgZG8ge1xuICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxuICAgICAgICAgICAgICAgIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gICAgLy8gdmVydGV4IGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG4gICAgdGhpcy5pID0gaTtcblxuICAgIC8vIHZlcnRleCBjb29yZGluYXRlc1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSAwO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cblxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgaiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qXG5cbiBDb3B5cmlnaHQgMjAwMCwgU2lsaWNvbiBHcmFwaGljcywgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuIENvcHlyaWdodCAyMDE1LCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbiByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBpbmNsdWRpbmcgdGhlIGRhdGVzIG9mIGZpcnN0IHB1YmxpY2F0aW9uIGFuZFxuIGVpdGhlciB0aGlzIHBlcm1pc3Npb24gbm90aWNlIG9yIGEgcmVmZXJlbmNlIHRvIGh0dHA6Ly9vc3Muc2dpLmNvbS9wcm9qZWN0cy9GcmVlQi9cbiBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTFxuIFNJTElDT04gR1JBUEhJQ1MsIElOQy4gQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1JcbiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4gT3JpZ2luYWwgQ29kZS4gVGhlIE9yaWdpbmFsIENvZGUgaXM6IE9wZW5HTCBTYW1wbGUgSW1wbGVtZW50YXRpb24sXG4gVmVyc2lvbiAxLjIuMSwgcmVsZWFzZWQgSmFudWFyeSAyNiwgMjAwMCwgZGV2ZWxvcGVkIGJ5IFNpbGljb24gR3JhcGhpY3MsXG4gSW5jLiBUaGUgT3JpZ2luYWwgQ29kZSBpcyBDb3B5cmlnaHQgKGMpIDE5OTEtMjAwMCBTaWxpY29uIEdyYXBoaWNzLCBJbmMuXG4gQ29weXJpZ2h0IGluIGFueSBwb3J0aW9ucyBjcmVhdGVkIGJ5IHRoaXJkIHBhcnRpZXMgaXMgYXMgaW5kaWNhdGVkXG4gZWxzZXdoZXJlIGhlcmVpbi4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiovXG4ndXNlIHN0cmljdCc7dmFyIG47ZnVuY3Rpb24gdChhLGIpe3JldHVybiBhLmI9PT1iLmImJmEuYT09PWIuYX1mdW5jdGlvbiB1KGEsYil7cmV0dXJuIGEuYjxiLmJ8fGEuYj09PWIuYiYmYS5hPD1iLmF9ZnVuY3Rpb24gdihhLGIsYyl7dmFyIGQ9Yi5iLWEuYixlPWMuYi1iLmI7cmV0dXJuIDA8ZCtlP2Q8ZT9iLmEtYS5hK2QvKGQrZSkqKGEuYS1jLmEpOmIuYS1jLmErZS8oZCtlKSooYy5hLWEuYSk6MH1mdW5jdGlvbiB4KGEsYixjKXt2YXIgZD1iLmItYS5iLGU9Yy5iLWIuYjtyZXR1cm4gMDxkK2U/KGIuYS1jLmEpKmQrKGIuYS1hLmEpKmU6MH1mdW5jdGlvbiB6KGEsYil7cmV0dXJuIGEuYTxiLmF8fGEuYT09PWIuYSYmYS5iPD1iLmJ9ZnVuY3Rpb24gYWEoYSxiLGMpe3ZhciBkPWIuYS1hLmEsZT1jLmEtYi5hO3JldHVybiAwPGQrZT9kPGU/Yi5iLWEuYitkLyhkK2UpKihhLmItYy5iKTpiLmItYy5iK2UvKGQrZSkqKGMuYi1hLmIpOjB9XG5mdW5jdGlvbiBiYShhLGIsYyl7dmFyIGQ9Yi5hLWEuYSxlPWMuYS1iLmE7cmV0dXJuIDA8ZCtlPyhiLmItYy5iKSpkKyhiLmItYS5iKSplOjB9ZnVuY3Rpb24gY2EoYSl7cmV0dXJuIHUoYS5iLmEsYS5hKX1mdW5jdGlvbiBkYShhKXtyZXR1cm4gdShhLmEsYS5iLmEpfWZ1bmN0aW9uIEEoYSxiLGMsZCl7YT0wPmE/MDphO2M9MD5jPzA6YztyZXR1cm4gYTw9Yz8wPT09Yz8oYitkKS8yOmIrYS8oYStjKSooZC1iKTpkK2MvKGErYykqKGItZCl9O2Z1bmN0aW9uIGVhKGEpe3ZhciBiPUIoYS5iKTtDKGIsYS5jKTtDKGIuYixhLmMpO0QoYixhLmEpO3JldHVybiBifWZ1bmN0aW9uIEUoYSxiKXt2YXIgYz0hMSxkPSExO2EhPT1iJiYoYi5hIT09YS5hJiYoZD0hMCxGKGIuYSxhLmEpKSxiLmQhPT1hLmQmJihjPSEwLEcoYi5kLGEuZCkpLEgoYixhKSxkfHwoQyhiLGEuYSksYS5hLmM9YSksY3x8KEQoYixhLmQpLGEuZC5hPWEpKX1mdW5jdGlvbiBJKGEpe3ZhciBiPWEuYixjPSExO2EuZCE9PWEuYi5kJiYoYz0hMCxHKGEuZCxhLmIuZCkpO2EuYz09PWE/RihhLmEsbnVsbCk6KGEuYi5kLmE9SihhKSxhLmEuYz1hLmMsSChhLEooYSkpLGN8fEQoYSxhLmQpKTtiLmM9PT1iPyhGKGIuYSxudWxsKSxHKGIuZCxudWxsKSk6KGEuZC5hPUooYiksYi5hLmM9Yi5jLEgoYixKKGIpKSk7ZmEoYSl9XG5mdW5jdGlvbiBLKGEpe3ZhciBiPUIoYSksYz1iLmI7SChiLGEuZSk7Yi5hPWEuYi5hO0MoYyxiLmEpO2IuZD1jLmQ9YS5kO2I9Yi5iO0goYS5iLEooYS5iKSk7SChhLmIsYik7YS5iLmE9Yi5hO2IuYi5hLmM9Yi5iO2IuYi5kPWEuYi5kO2IuZj1hLmY7Yi5iLmY9YS5iLmY7cmV0dXJuIGJ9ZnVuY3Rpb24gTChhLGIpe3ZhciBjPSExLGQ9QihhKSxlPWQuYjtiLmQhPT1hLmQmJihjPSEwLEcoYi5kLGEuZCkpO0goZCxhLmUpO0goZSxiKTtkLmE9YS5iLmE7ZS5hPWIuYTtkLmQ9ZS5kPWEuZDthLmQuYT1lO2N8fEQoZCxhLmQpO3JldHVybiBkfWZ1bmN0aW9uIEIoYSl7dmFyIGI9bmV3IE0sYz1uZXcgTSxkPWEuYi5oO2MuaD1kO2QuYi5oPWI7Yi5oPWE7YS5iLmg9YztiLmI9YztiLmM9YjtiLmU9YztjLmI9YjtjLmM9YztyZXR1cm4gYy5lPWJ9ZnVuY3Rpb24gSChhLGIpe3ZhciBjPWEuYyxkPWIuYztjLmIuZT1iO2QuYi5lPWE7YS5jPWQ7Yi5jPWN9XG5mdW5jdGlvbiBDKGEsYil7dmFyIGM9Yi5mLGQ9bmV3IE4oYixjKTtjLmU9ZDtiLmY9ZDtjPWQuYz1hO2RvIGMuYT1kLGM9Yy5jO3doaWxlKGMhPT1hKX1mdW5jdGlvbiBEKGEsYil7dmFyIGM9Yi5kLGQ9bmV3IGdhKGIsYyk7Yy5iPWQ7Yi5kPWQ7ZC5hPWE7ZC5jPWIuYztjPWE7ZG8gYy5kPWQsYz1jLmU7d2hpbGUoYyE9PWEpfWZ1bmN0aW9uIGZhKGEpe3ZhciBiPWEuaDthPWEuYi5oO2IuYi5oPWE7YS5iLmg9Yn1mdW5jdGlvbiBGKGEsYil7dmFyIGM9YS5jLGQ9YztkbyBkLmE9YixkPWQuYzt3aGlsZShkIT09Yyk7Yz1hLmY7ZD1hLmU7ZC5mPWM7Yy5lPWR9ZnVuY3Rpb24gRyhhLGIpe3ZhciBjPWEuYSxkPWM7ZG8gZC5kPWIsZD1kLmU7d2hpbGUoZCE9PWMpO2M9YS5kO2Q9YS5iO2QuZD1jO2MuYj1kfTtmdW5jdGlvbiBoYShhKXt2YXIgYj0wO01hdGguYWJzKGFbMV0pPk1hdGguYWJzKGFbMF0pJiYoYj0xKTtNYXRoLmFicyhhWzJdKT5NYXRoLmFicyhhW2JdKSYmKGI9Mik7cmV0dXJuIGJ9O3ZhciBPPTQqMUUxNTA7ZnVuY3Rpb24gUChhLGIpe2EuZis9Yi5mO2EuYi5mKz1iLmIuZn1mdW5jdGlvbiBpYShhLGIsYyl7YT1hLmE7Yj1iLmE7Yz1jLmE7aWYoYi5iLmE9PT1hKXJldHVybiBjLmIuYT09PWE/dShiLmEsYy5hKT8wPj14KGMuYi5hLGIuYSxjLmEpOjA8PXgoYi5iLmEsYy5hLGIuYSk6MD49eChjLmIuYSxhLGMuYSk7aWYoYy5iLmE9PT1hKXJldHVybiAwPD14KGIuYi5hLGEsYi5hKTtiPXYoYi5iLmEsYSxiLmEpO2E9dihjLmIuYSxhLGMuYSk7cmV0dXJuIGI+PWF9ZnVuY3Rpb24gUShhKXthLmEuaT1udWxsO3ZhciBiPWEuZTtiLmEuYz1iLmM7Yi5jLmE9Yi5hO2EuZT1udWxsfWZ1bmN0aW9uIGphKGEsYil7SShhLmEpO2EuYz0hMTthLmE9YjtiLmk9YX1mdW5jdGlvbiBrYShhKXt2YXIgYj1hLmEuYTtkbyBhPVIoYSk7d2hpbGUoYS5hLmE9PT1iKTthLmMmJihiPUwoUyhhKS5hLmIsYS5hLmUpLGphKGEsYiksYT1SKGEpKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIGxhKGEsYixjKXt2YXIgZD1uZXcgbWE7ZC5hPWM7ZC5lPW5hKGEuZixiLmUsZCk7cmV0dXJuIGMuaT1kfWZ1bmN0aW9uIG9hKGEsYil7c3dpdGNoKGEucyl7Y2FzZSAxMDAxMzA6cmV0dXJuIDAhPT0oYiYxKTtjYXNlIDEwMDEzMTpyZXR1cm4gMCE9PWI7Y2FzZSAxMDAxMzI6cmV0dXJuIDA8YjtjYXNlIDEwMDEzMzpyZXR1cm4gMD5iO2Nhc2UgMTAwMTM0OnJldHVybiAyPD1ifHwtMj49Yn1yZXR1cm4hMX1mdW5jdGlvbiBwYShhKXt2YXIgYj1hLmEsYz1iLmQ7Yy5jPWEuZDtjLmE9YjtRKGEpfWZ1bmN0aW9uIFQoYSxiLGMpe2E9Yjtmb3IoYj1iLmE7YSE9PWM7KXthLmM9ITE7dmFyIGQ9UyhhKSxlPWQuYTtpZihlLmEhPT1iLmEpe2lmKCFkLmMpe3BhKGEpO2JyZWFrfWU9TChiLmMuYixlLmIpO2phKGQsZSl9Yi5jIT09ZSYmKEUoSihlKSxlKSxFKGIsZSkpO3BhKGEpO2I9ZC5hO2E9ZH1yZXR1cm4gYn1cbmZ1bmN0aW9uIFUoYSxiLGMsZCxlLGYpe3ZhciBnPSEwO2RvIGxhKGEsYixjLmIpLGM9Yy5jO3doaWxlKGMhPT1kKTtmb3IobnVsbD09PWUmJihlPVMoYikuYS5iLmMpOzspe2Q9UyhiKTtjPWQuYS5iO2lmKGMuYSE9PWUuYSlicmVhaztjLmMhPT1lJiYoRShKKGMpLGMpLEUoSihlKSxjKSk7ZC5mPWIuZi1jLmY7ZC5kPW9hKGEsZC5mKTtiLmI9ITA7IWcmJnFhKGEsYikmJihQKGMsZSksUShiKSxJKGUpKTtnPSExO2I9ZDtlPWN9Yi5iPSEwO2YmJnJhKGEsYil9ZnVuY3Rpb24gc2EoYSxiLGMsZCxlKXt2YXIgZj1bYi5nWzBdLGIuZ1sxXSxiLmdbMl1dO2IuZD1udWxsO2IuZD1hLm8/YS5vKGYsYyxkLGEuYyl8fG51bGw6bnVsbDtudWxsPT09Yi5kJiYoZT9hLm58fChWKGEsMTAwMTU2KSxhLm49ITApOmIuZD1jWzBdKX1cbmZ1bmN0aW9uIHRhKGEsYixjKXt2YXIgZD1bbnVsbCxudWxsLG51bGwsbnVsbF07ZFswXT1iLmEuZDtkWzFdPWMuYS5kO3NhKGEsYi5hLGQsWy41LC41LDAsMF0sITEpO0UoYixjKX1mdW5jdGlvbiB1YShhLGIsYyxkLGUpe3ZhciBmPU1hdGguYWJzKGIuYi1hLmIpK01hdGguYWJzKGIuYS1hLmEpLGc9TWF0aC5hYnMoYy5iLWEuYikrTWF0aC5hYnMoYy5hLWEuYSksaD1lKzE7ZFtlXT0uNSpnLyhmK2cpO2RbaF09LjUqZi8oZitnKTthLmdbMF0rPWRbZV0qYi5nWzBdK2RbaF0qYy5nWzBdO2EuZ1sxXSs9ZFtlXSpiLmdbMV0rZFtoXSpjLmdbMV07YS5nWzJdKz1kW2VdKmIuZ1syXStkW2hdKmMuZ1syXX1cbmZ1bmN0aW9uIHFhKGEsYil7dmFyIGM9UyhiKSxkPWIuYSxlPWMuYTtpZih1KGQuYSxlLmEpKXtpZigwPHgoZS5iLmEsZC5hLGUuYSkpcmV0dXJuITE7aWYoIXQoZC5hLGUuYSkpSyhlLmIpLEUoZCxKKGUpKSxiLmI9Yy5iPSEwO2Vsc2UgaWYoZC5hIT09ZS5hKXt2YXIgYz1hLmUsZj1kLmEuaDtpZigwPD1mKXt2YXIgYz1jLmIsZz1jLmQsaD1jLmUsaz1jLmMsbD1rW2ZdO2dbbF09Z1tjLmFdO2tbZ1tsXV09bDtsPD0tLWMuYSYmKDE+PWw/VyhjLGwpOnUoaFtnW2w+PjFdXSxoW2dbbF1dKT9XKGMsbCk6dmEoYyxsKSk7aFtmXT1udWxsO2tbZl09Yy5iO2MuYj1mfWVsc2UgZm9yKGMuY1stKGYrMSldPW51bGw7MDxjLmEmJm51bGw9PT1jLmNbYy5kW2MuYS0xXV07KS0tYy5hO3RhKGEsSihlKSxkKX19ZWxzZXtpZigwPngoZC5iLmEsZS5hLGQuYSkpcmV0dXJuITE7UihiKS5iPWIuYj0hMDtLKGQuYik7RShKKGUpLGQpfXJldHVybiEwfVxuZnVuY3Rpb24gd2EoYSxiKXt2YXIgYz1TKGIpLGQ9Yi5hLGU9Yy5hLGY9ZC5hLGc9ZS5hLGg9ZC5iLmEsaz1lLmIuYSxsPW5ldyBOO3goaCxhLmEsZik7eChrLGEuYSxnKTtpZihmPT09Z3x8TWF0aC5taW4oZi5hLGguYSk+TWF0aC5tYXgoZy5hLGsuYSkpcmV0dXJuITE7aWYodShmLGcpKXtpZigwPHgoayxmLGcpKXJldHVybiExfWVsc2UgaWYoMD54KGgsZyxmKSlyZXR1cm4hMTt2YXIgcj1oLHA9ZixxPWsseT1nLG0sdzt1KHIscCl8fChtPXIscj1wLHA9bSk7dShxLHkpfHwobT1xLHE9eSx5PW0pO3UocixxKXx8KG09cixyPXEscT1tLG09cCxwPXkseT1tKTt1KHEscCk/dShwLHkpPyhtPXYocixxLHApLHc9dihxLHAseSksMD5tK3cmJihtPS1tLHc9LXcpLGwuYj1BKG0scS5iLHcscC5iKSk6KG09eChyLHEscCksdz0teChyLHkscCksMD5tK3cmJihtPS1tLHc9LXcpLGwuYj1BKG0scS5iLHcseS5iKSk6bC5iPShxLmIrcC5iKS8yO3oocixwKXx8KG09cixyPXAscD1tKTt6KHEseSl8fFxuKG09cSxxPXkseT1tKTt6KHIscSl8fChtPXIscj1xLHE9bSxtPXAscD15LHk9bSk7eihxLHApP3oocCx5KT8obT1hYShyLHEscCksdz1hYShxLHAseSksMD5tK3cmJihtPS1tLHc9LXcpLGwuYT1BKG0scS5hLHcscC5hKSk6KG09YmEocixxLHApLHc9LWJhKHIseSxwKSwwPm0rdyYmKG09LW0sdz0tdyksbC5hPUEobSxxLmEsdyx5LmEpKTpsLmE9KHEuYStwLmEpLzI7dShsLGEuYSkmJihsLmI9YS5hLmIsbC5hPWEuYS5hKTtyPXUoZixnKT9mOmc7dShyLGwpJiYobC5iPXIuYixsLmE9ci5hKTtpZih0KGwsZil8fHQobCxnKSlyZXR1cm4gcWEoYSxiKSwhMTtpZighdChoLGEuYSkmJjA8PXgoaCxhLmEsbCl8fCF0KGssYS5hKSYmMD49eChrLGEuYSxsKSl7aWYoaz09PWEuYSlyZXR1cm4gSyhkLmIpLEUoZS5iLGQpLGI9a2EoYiksZD1TKGIpLmEsVChhLFMoYiksYyksVShhLGIsSihkKSxkLGQsITApLCEwO2lmKGg9PT1hLmEpe0soZS5iKTtFKGQuZSxKKGUpKTtmPWM9YjtnPWYuYS5iLmE7XG5kbyBmPVIoZik7d2hpbGUoZi5hLmIuYT09PWcpO2I9ZjtmPVMoYikuYS5iLmM7Yy5hPUooZSk7ZT1UKGEsYyxudWxsKTtVKGEsYixlLmMsZC5iLmMsZiwhMCk7cmV0dXJuITB9MDw9eChoLGEuYSxsKSYmKFIoYikuYj1iLmI9ITAsSyhkLmIpLGQuYS5iPWEuYS5iLGQuYS5hPWEuYS5hKTswPj14KGssYS5hLGwpJiYoYi5iPWMuYj0hMCxLKGUuYiksZS5hLmI9YS5hLmIsZS5hLmE9YS5hLmEpO3JldHVybiExfUsoZC5iKTtLKGUuYik7RShKKGUpLGQpO2QuYS5iPWwuYjtkLmEuYT1sLmE7ZC5hLmg9eGEoYS5lLGQuYSk7ZD1kLmE7ZT1bMCwwLDAsMF07bD1bZi5kLGguZCxnLmQsay5kXTtkLmdbMF09ZC5nWzFdPWQuZ1syXT0wO3VhKGQsZixoLGUsMCk7dWEoZCxnLGssZSwyKTtzYShhLGQsbCxlLCEwKTtSKGIpLmI9Yi5iPWMuYj0hMDtyZXR1cm4hMX1cbmZ1bmN0aW9uIHJhKGEsYil7Zm9yKHZhciBjPVMoYik7Oyl7Zm9yKDtjLmI7KWI9YyxjPVMoYyk7aWYoIWIuYiYmKGM9YixiPVIoYiksbnVsbD09PWJ8fCFiLmIpKWJyZWFrO2IuYj0hMTt2YXIgZD1iLmEsZT1jLmEsZjtpZihmPWQuYi5hIT09ZS5iLmEpYTp7Zj1iO3ZhciBnPVMoZiksaD1mLmEsaz1nLmEsbD12b2lkIDA7aWYodShoLmIuYSxrLmIuYSkpe2lmKDA+eChoLmIuYSxrLmIuYSxoLmEpKXtmPSExO2JyZWFrIGF9UihmKS5iPWYuYj0hMDtsPUsoaCk7RShrLmIsbCk7bC5kLmM9Zi5kfWVsc2V7aWYoMDx4KGsuYi5hLGguYi5hLGsuYSkpe2Y9ITE7YnJlYWsgYX1mLmI9Zy5iPSEwO2w9SyhrKTtFKGguZSxrLmIpO2wuYi5kLmM9Zi5kfWY9ITB9ZiYmKGMuYz8oUShjKSxJKGUpLGM9UyhiKSxlPWMuYSk6Yi5jJiYoUShiKSxJKGQpLGI9UihjKSxkPWIuYSkpO2lmKGQuYSE9PWUuYSlpZihkLmIuYT09PWUuYi5hfHxiLmN8fGMuY3x8ZC5iLmEhPT1hLmEmJmUuYi5hIT09YS5hKXFhKGEsXG5iKTtlbHNlIGlmKHdhKGEsYikpYnJlYWs7ZC5hPT09ZS5hJiZkLmIuYT09PWUuYi5hJiYoUChlLGQpLFEoYiksSShkKSxiPVIoYykpfX1cbmZ1bmN0aW9uIHlhKGEsYil7YS5hPWI7Zm9yKHZhciBjPWIuYztudWxsPT09Yy5pOylpZihjPWMuYyxjPT09Yi5jKXt2YXIgYz1hLGQ9YixlPW5ldyBtYTtlLmE9ZC5jLmI7dmFyIGY9Yy5mLGc9Zi5hO2RvIGc9Zy5hO3doaWxlKG51bGwhPT1nLmImJiFmLmMoZi5iLGUsZy5iKSk7dmFyIGY9Zy5iLGg9UyhmKSxlPWYuYSxnPWguYTtpZigwPT09eChlLmIuYSxkLGUuYSkpZT1mLmEsdChlLmEsZCl8fHQoZS5iLmEsZCl8fChLKGUuYiksZi5jJiYoSShlLmMpLGYuYz0hMSksRShkLmMsZSkseWEoYyxkKSk7ZWxzZXt2YXIgaz11KGcuYi5hLGUuYi5hKT9mOmgsaD12b2lkIDA7Zi5kfHxrLmM/KGs9PT1mP2g9TChkLmMuYixlLmUpOmg9TChnLmIuYy5iLGQuYykuYixrLmM/amEoayxoKTooZT1jLGY9bGEoYyxmLGgpLGYuZj1SKGYpLmYrZi5hLmYsZi5kPW9hKGUsZi5mKSkseWEoYyxkKSk6VShjLGYsZC5jLGQuYyxudWxsLCEwKX1yZXR1cm59Yz1rYShjLmkpO2U9UyhjKTtmPWUuYTtlPVQoYSxcbmUsbnVsbCk7aWYoZS5jPT09Zil7dmFyIGY9ZSxlPWYuYyxnPVMoYyksaD1jLmEsaz1nLmEsbD0hMTtoLmIuYSE9PWsuYi5hJiZ3YShhLGMpO3QoaC5hLGEuYSkmJihFKEooZSksaCksYz1rYShjKSxlPVMoYykuYSxUKGEsUyhjKSxnKSxsPSEwKTt0KGsuYSxhLmEpJiYoRShmLEooaykpLGY9VChhLGcsbnVsbCksbD0hMCk7bD9VKGEsYyxmLmMsZSxlLCEwKToodShrLmEsaC5hKT9kPUooayk6ZD1oLGQ9TChmLmMuYixkKSxVKGEsYyxkLGQuYyxkLmMsITEpLGQuYi5pLmM9ITAscmEoYSxjKSl9ZWxzZSBVKGEsYyxlLmMsZixmLCEwKX1mdW5jdGlvbiB6YShhLGIpe3ZhciBjPW5ldyBtYSxkPWVhKGEuYik7ZC5hLmI9TztkLmEuYT1iO2QuYi5hLmI9LU87ZC5iLmEuYT1iO2EuYT1kLmIuYTtjLmE9ZDtjLmY9MDtjLmQ9ITE7Yy5jPSExO2MuaD0hMDtjLmI9ITE7ZD1hLmY7ZD1uYShkLGQuYSxjKTtjLmU9ZH07ZnVuY3Rpb24gQWEoYSl7dGhpcy5hPW5ldyBCYTt0aGlzLmI9YTt0aGlzLmM9aWF9ZnVuY3Rpb24gbmEoYSxiLGMpe2RvIGI9Yi5jO3doaWxlKG51bGwhPT1iLmImJiFhLmMoYS5iLGIuYixjKSk7YT1uZXcgQmEoYyxiLmEsYik7Yi5hLmM9YTtyZXR1cm4gYi5hPWF9O2Z1bmN0aW9uIEJhKGEsYixjKXt0aGlzLmI9YXx8bnVsbDt0aGlzLmE9Ynx8dGhpczt0aGlzLmM9Y3x8dGhpc307ZnVuY3Rpb24gWCgpe3RoaXMuZD1ZO3RoaXMucD10aGlzLmI9dGhpcy5xPW51bGw7dGhpcy5qPVswLDAsMF07dGhpcy5zPTEwMDEzMDt0aGlzLm49ITE7dGhpcy5vPXRoaXMuYT10aGlzLmU9dGhpcy5mPW51bGw7dGhpcy5tPSExO3RoaXMuYz10aGlzLnI9dGhpcy5pPXRoaXMuaz10aGlzLmw9dGhpcy5oPW51bGx9dmFyIFk9MDtuPVgucHJvdG90eXBlO24ueD1mdW5jdGlvbigpe1oodGhpcyxZKX07bi5CPWZ1bmN0aW9uKGEsYil7c3dpdGNoKGEpe2Nhc2UgMTAwMTQyOnJldHVybjtjYXNlIDEwMDE0MDpzd2l0Y2goYil7Y2FzZSAxMDAxMzA6Y2FzZSAxMDAxMzE6Y2FzZSAxMDAxMzI6Y2FzZSAxMDAxMzM6Y2FzZSAxMDAxMzQ6dGhpcy5zPWI7cmV0dXJufWJyZWFrO2Nhc2UgMTAwMTQxOnRoaXMubT0hIWI7cmV0dXJuO2RlZmF1bHQ6Vih0aGlzLDEwMDkwMCk7cmV0dXJufVYodGhpcywxMDA5MDEpfTtcbm4ueT1mdW5jdGlvbihhKXtzd2l0Y2goYSl7Y2FzZSAxMDAxNDI6cmV0dXJuIDA7Y2FzZSAxMDAxNDA6cmV0dXJuIHRoaXMucztjYXNlIDEwMDE0MTpyZXR1cm4gdGhpcy5tO2RlZmF1bHQ6Vih0aGlzLDEwMDkwMCl9cmV0dXJuITF9O24uQT1mdW5jdGlvbihhLGIsYyl7dGhpcy5qWzBdPWE7dGhpcy5qWzFdPWI7dGhpcy5qWzJdPWN9O1xubi56PWZ1bmN0aW9uKGEsYil7dmFyIGM9Yj9iOm51bGw7c3dpdGNoKGEpe2Nhc2UgMTAwMTAwOmNhc2UgMTAwMTA2OnRoaXMuaD1jO2JyZWFrO2Nhc2UgMTAwMTA0OmNhc2UgMTAwMTEwOnRoaXMubD1jO2JyZWFrO2Nhc2UgMTAwMTAxOmNhc2UgMTAwMTA3OnRoaXMuaz1jO2JyZWFrO2Nhc2UgMTAwMTAyOmNhc2UgMTAwMTA4OnRoaXMuaT1jO2JyZWFrO2Nhc2UgMTAwMTAzOmNhc2UgMTAwMTA5OnRoaXMucD1jO2JyZWFrO2Nhc2UgMTAwMTA1OmNhc2UgMTAwMTExOnRoaXMubz1jO2JyZWFrO2Nhc2UgMTAwMTEyOnRoaXMucj1jO2JyZWFrO2RlZmF1bHQ6Vih0aGlzLDEwMDkwMCl9fTtcbm4uQz1mdW5jdGlvbihhLGIpe3ZhciBjPSExLGQ9WzAsMCwwXTtaKHRoaXMsMik7Zm9yKHZhciBlPTA7Mz5lOysrZSl7dmFyIGY9YVtlXTstMUUxNTA+ZiYmKGY9LTFFMTUwLGM9ITApOzFFMTUwPGYmJihmPTFFMTUwLGM9ITApO2RbZV09Zn1jJiZWKHRoaXMsMTAwMTU1KTtjPXRoaXMucTtudWxsPT09Yz8oYz1lYSh0aGlzLmIpLEUoYyxjLmIpKTooSyhjKSxjPWMuZSk7Yy5hLmQ9YjtjLmEuZ1swXT1kWzBdO2MuYS5nWzFdPWRbMV07Yy5hLmdbMl09ZFsyXTtjLmY9MTtjLmIuZj0tMTt0aGlzLnE9Y307bi51PWZ1bmN0aW9uKGEpe1oodGhpcyxZKTt0aGlzLmQ9MTt0aGlzLmI9bmV3IENhO3RoaXMuYz1hfTtuLnQ9ZnVuY3Rpb24oKXtaKHRoaXMsMSk7dGhpcy5kPTI7dGhpcy5xPW51bGx9O24udj1mdW5jdGlvbigpe1oodGhpcywyKTt0aGlzLmQ9MX07XG5uLnc9ZnVuY3Rpb24oKXtaKHRoaXMsMSk7dGhpcy5kPVk7dmFyIGE9dGhpcy5qWzBdLGI9dGhpcy5qWzFdLGM9dGhpcy5qWzJdLGQ9ITEsZT1bYSxiLGNdO2lmKDA9PT1hJiYwPT09YiYmMD09PWMpe2Zvcih2YXIgYj1bLTIqMUUxNTAsLTIqMUUxNTAsLTIqMUUxNTBdLGY9WzIqMUUxNTAsMioxRTE1MCwyKjFFMTUwXSxjPVtdLGc9W10sZD10aGlzLmIuYyxhPWQuZTthIT09ZDthPWEuZSlmb3IodmFyIGg9MDszPmg7KytoKXt2YXIgaz1hLmdbaF07azxmW2hdJiYoZltoXT1rLGdbaF09YSk7az5iW2hdJiYoYltoXT1rLGNbaF09YSl9YT0wO2JbMV0tZlsxXT5iWzBdLWZbMF0mJihhPTEpO2JbMl0tZlsyXT5iW2FdLWZbYV0mJihhPTIpO2lmKGZbYV0+PWJbYV0pZVswXT0wLGVbMV09MCxlWzJdPTE7ZWxzZXtiPTA7Zj1nW2FdO2M9Y1thXTtnPVswLDAsMF07Zj1bZi5nWzBdLWMuZ1swXSxmLmdbMV0tYy5nWzFdLGYuZ1syXS1jLmdbMl1dO2g9WzAsMCwwXTtmb3IoYT1kLmU7YSE9PWQ7YT1cbmEuZSloWzBdPWEuZ1swXS1jLmdbMF0saFsxXT1hLmdbMV0tYy5nWzFdLGhbMl09YS5nWzJdLWMuZ1syXSxnWzBdPWZbMV0qaFsyXS1mWzJdKmhbMV0sZ1sxXT1mWzJdKmhbMF0tZlswXSpoWzJdLGdbMl09ZlswXSpoWzFdLWZbMV0qaFswXSxrPWdbMF0qZ1swXStnWzFdKmdbMV0rZ1syXSpnWzJdLGs+YiYmKGI9ayxlWzBdPWdbMF0sZVsxXT1nWzFdLGVbMl09Z1syXSk7MD49YiYmKGVbMF09ZVsxXT1lWzJdPTAsZVtoYShmKV09MSl9ZD0hMH1nPWhhKGUpO2E9dGhpcy5iLmM7Yj0oZysxKSUzO2M9KGcrMiklMztnPTA8ZVtnXT8xOi0xO2ZvcihlPWEuZTtlIT09YTtlPWUuZSllLmI9ZS5nW2JdLGUuYT1nKmUuZ1tjXTtpZihkKXtlPTA7ZD10aGlzLmIuYTtmb3IoYT1kLmI7YSE9PWQ7YT1hLmIpaWYoYj1hLmEsISgwPj1iLmYpKXtkbyBlKz0oYi5hLmItYi5iLmEuYikqKGIuYS5hK2IuYi5hLmEpLGI9Yi5lO3doaWxlKGIhPT1hLmEpfWlmKDA+ZSlmb3IoZT10aGlzLmIuYyxkPWUuZTtkIT09XG5lO2Q9ZC5lKWQuYT0tZC5hfXRoaXMubj0hMTtlPXRoaXMuYi5iO2ZvcihhPWUuaDthIT09ZTthPWQpaWYoZD1hLmgsYj1hLmUsdChhLmEsYS5iLmEpJiZhLmUuZSE9PWEmJih0YSh0aGlzLGIsYSksSShhKSxhPWIsYj1hLmUpLGIuZT09PWEpe2lmKGIhPT1hKXtpZihiPT09ZHx8Yj09PWQuYilkPWQuaDtJKGIpfWlmKGE9PT1kfHxhPT09ZC5iKWQ9ZC5oO0koYSl9dGhpcy5lPWU9bmV3IERhO2Q9dGhpcy5iLmM7Zm9yKGE9ZC5lO2EhPT1kO2E9YS5lKWEuaD14YShlLGEpO0VhKGUpO3RoaXMuZj1uZXcgQWEodGhpcyk7emEodGhpcywtTyk7Zm9yKHphKHRoaXMsTyk7bnVsbCE9PShlPUZhKHRoaXMuZSkpOyl7Zm9yKDs7KXthOmlmKGE9dGhpcy5lLDA9PT1hLmEpZD1HYShhLmIpO2Vsc2UgaWYoZD1hLmNbYS5kW2EuYS0xXV0sMCE9PWEuYi5hJiYoYT1HYShhLmIpLHUoYSxkKSkpe2Q9YTticmVhayBhfWlmKG51bGw9PT1kfHwhdChkLGUpKWJyZWFrO2Q9RmEodGhpcy5lKTt0YSh0aGlzLGUuYyxcbmQuYyl9eWEodGhpcyxlKX10aGlzLmE9dGhpcy5mLmEuYS5iLmEuYTtmb3IoZT0wO251bGwhPT0oZD10aGlzLmYuYS5hLmIpOylkLmh8fCsrZSxRKGQpO3RoaXMuZj1udWxsO2U9dGhpcy5lO2UuYj1udWxsO2UuZD1udWxsO3RoaXMuZT1lLmM9bnVsbDtlPXRoaXMuYjtmb3IoYT1lLmEuYjthIT09ZS5hO2E9ZClkPWEuYixhPWEuYSxhLmUuZT09PWEmJihQKGEuYyxhKSxJKGEpKTtpZighdGhpcy5uKXtlPXRoaXMuYjtpZih0aGlzLm0pZm9yKGE9ZS5iLmg7YSE9PWUuYjthPWQpZD1hLmgsYS5iLmQuYyE9PWEuZC5jP2EuZj1hLmQuYz8xOi0xOkkoYSk7ZWxzZSBmb3IoYT1lLmEuYjthIT09ZS5hO2E9ZClpZihkPWEuYixhLmMpe2ZvcihhPWEuYTt1KGEuYi5hLGEuYSk7YT1hLmMuYik7Zm9yKDt1KGEuYSxhLmIuYSk7YT1hLmUpO2I9YS5jLmI7Zm9yKGM9dm9pZCAwO2EuZSE9PWI7KWlmKHUoYS5iLmEsYi5hKSl7Zm9yKDtiLmUhPT1hJiYoY2EoYi5lKXx8MD49eChiLmEsYi5iLmEsYi5lLmIuYSkpOyljPVxuTChiLmUsYiksYj1jLmI7Yj1iLmMuYn1lbHNle2Zvcig7Yi5lIT09YSYmKGRhKGEuYy5iKXx8MDw9eChhLmIuYSxhLmEsYS5jLmIuYSkpOyljPUwoYSxhLmMuYiksYT1jLmI7YT1hLmV9Zm9yKDtiLmUuZSE9PWE7KWM9TChiLmUsYiksYj1jLmJ9aWYodGhpcy5ofHx0aGlzLml8fHRoaXMua3x8dGhpcy5sKWlmKHRoaXMubSlmb3IoZT10aGlzLmIsZD1lLmEuYjtkIT09ZS5hO2Q9ZC5iKXtpZihkLmMpe3RoaXMuaCYmdGhpcy5oKDIsdGhpcy5jKTthPWQuYTtkbyB0aGlzLmsmJnRoaXMuayhhLmEuZCx0aGlzLmMpLGE9YS5lO3doaWxlKGEhPT1kLmEpO3RoaXMuaSYmdGhpcy5pKHRoaXMuYyl9fWVsc2V7ZT10aGlzLmI7ZD0hIXRoaXMubDthPSExO2I9LTE7Zm9yKGM9ZS5hLmQ7YyE9PWUuYTtjPWMuZClpZihjLmMpe2F8fCh0aGlzLmgmJnRoaXMuaCg0LHRoaXMuYyksYT0hMCk7Zz1jLmE7ZG8gZCYmKGY9Zy5iLmQuYz8wOjEsYiE9PWYmJihiPWYsdGhpcy5sJiZ0aGlzLmwoISFiLHRoaXMuYykpKSxcbnRoaXMuayYmdGhpcy5rKGcuYS5kLHRoaXMuYyksZz1nLmU7d2hpbGUoZyE9PWMuYSl9YSYmdGhpcy5pJiZ0aGlzLmkodGhpcy5jKX1pZih0aGlzLnIpe2U9dGhpcy5iO2ZvcihhPWUuYS5iO2EhPT1lLmE7YT1kKWlmKGQ9YS5iLCFhLmMpe2I9YS5hO2M9Yi5lO2c9dm9pZCAwO2RvIGc9YyxjPWcuZSxnLmQ9bnVsbCxudWxsPT09Zy5iLmQmJihnLmM9PT1nP0YoZy5hLG51bGwpOihnLmEuYz1nLmMsSChnLEooZykpKSxmPWcuYixmLmM9PT1mP0YoZi5hLG51bGwpOihmLmEuYz1mLmMsSChmLEooZikpKSxmYShnKSk7d2hpbGUoZyE9PWIpO2I9YS5kO2E9YS5iO2EuZD1iO2IuYj1hfXRoaXMucih0aGlzLmIpO3RoaXMuYz10aGlzLmI9bnVsbDtyZXR1cm59fXRoaXMuYj10aGlzLmM9bnVsbH07XG5mdW5jdGlvbiBaKGEsYil7aWYoYS5kIT09Yilmb3IoO2EuZCE9PWI7KWlmKGEuZDxiKXN3aXRjaChhLmQpe2Nhc2UgWTpWKGEsMTAwMTUxKTthLnUobnVsbCk7YnJlYWs7Y2FzZSAxOlYoYSwxMDAxNTIpLGEudCgpfWVsc2Ugc3dpdGNoKGEuZCl7Y2FzZSAyOlYoYSwxMDAxNTQpO2EudigpO2JyZWFrO2Nhc2UgMTpWKGEsMTAwMTUzKSxhLncoKX19ZnVuY3Rpb24gVihhLGIpe2EucCYmYS5wKGIsYS5jKX07ZnVuY3Rpb24gZ2EoYSxiKXt0aGlzLmI9YXx8dGhpczt0aGlzLmQ9Ynx8dGhpczt0aGlzLmE9bnVsbDt0aGlzLmM9ITF9O2Z1bmN0aW9uIE0oKXt0aGlzLmg9dGhpczt0aGlzLmk9dGhpcy5kPXRoaXMuYT10aGlzLmU9dGhpcy5jPXRoaXMuYj1udWxsO3RoaXMuZj0wfWZ1bmN0aW9uIEooYSl7cmV0dXJuIGEuYi5lfTtmdW5jdGlvbiBDYSgpe3RoaXMuYz1uZXcgTjt0aGlzLmE9bmV3IGdhO3RoaXMuYj1uZXcgTTt0aGlzLmQ9bmV3IE07dGhpcy5iLmI9dGhpcy5kO3RoaXMuZC5iPXRoaXMuYn07ZnVuY3Rpb24gTihhLGIpe3RoaXMuZT1hfHx0aGlzO3RoaXMuZj1ifHx0aGlzO3RoaXMuZD10aGlzLmM9bnVsbDt0aGlzLmc9WzAsMCwwXTt0aGlzLmg9dGhpcy5hPXRoaXMuYj0wfTtmdW5jdGlvbiBEYSgpe3RoaXMuYz1bXTt0aGlzLmQ9bnVsbDt0aGlzLmE9MDt0aGlzLmU9ITE7dGhpcy5iPW5ldyBIYX1mdW5jdGlvbiBFYShhKXthLmQ9W107Zm9yKHZhciBiPTA7YjxhLmE7YisrKWEuZFtiXT1iO2EuZC5zb3J0KGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiLGUpe3JldHVybiB1KGFbYl0sYVtlXSk/MTotMX19KGEuYykpO2EuZT0hMDtJYShhLmIpfWZ1bmN0aW9uIHhhKGEsYil7aWYoYS5lKXt2YXIgYz1hLmIsZD0rK2MuYTsyKmQ+Yy5mJiYoYy5mKj0yLGMuYz1KYShjLmMsYy5mKzEpKTt2YXIgZTswPT09Yy5iP2U9ZDooZT1jLmIsYy5iPWMuY1tjLmJdKTtjLmVbZV09YjtjLmNbZV09ZDtjLmRbZF09ZTtjLmgmJnZhKGMsZCk7cmV0dXJuIGV9Yz1hLmErKzthLmNbY109YjtyZXR1cm4tKGMrMSl9XG5mdW5jdGlvbiBGYShhKXtpZigwPT09YS5hKXJldHVybiBLYShhLmIpO3ZhciBiPWEuY1thLmRbYS5hLTFdXTtpZigwIT09YS5iLmEmJnUoR2EoYS5iKSxiKSlyZXR1cm4gS2EoYS5iKTtkby0tYS5hO3doaWxlKDA8YS5hJiZudWxsPT09YS5jW2EuZFthLmEtMV1dKTtyZXR1cm4gYn07ZnVuY3Rpb24gSGEoKXt0aGlzLmQ9SmEoWzBdLDMzKTt0aGlzLmU9W251bGwsbnVsbF07dGhpcy5jPVswLDBdO3RoaXMuYT0wO3RoaXMuZj0zMjt0aGlzLmI9MDt0aGlzLmg9ITE7dGhpcy5kWzFdPTF9ZnVuY3Rpb24gSmEoYSxiKXtmb3IodmFyIGM9QXJyYXkoYiksZD0wO2Q8YS5sZW5ndGg7ZCsrKWNbZF09YVtkXTtmb3IoO2Q8YjtkKyspY1tkXT0wO3JldHVybiBjfWZ1bmN0aW9uIElhKGEpe2Zvcih2YXIgYj1hLmE7MTw9YjstLWIpVyhhLGIpO2EuaD0hMH1mdW5jdGlvbiBHYShhKXtyZXR1cm4gYS5lW2EuZFsxXV19ZnVuY3Rpb24gS2EoYSl7dmFyIGI9YS5kLGM9YS5lLGQ9YS5jLGU9YlsxXSxmPWNbZV07MDxhLmEmJihiWzFdPWJbYS5hXSxkW2JbMV1dPTEsY1tlXT1udWxsLGRbZV09YS5iLGEuYj1lLDA8LS1hLmEmJlcoYSwxKSk7cmV0dXJuIGZ9XG5mdW5jdGlvbiBXKGEsYil7Zm9yKHZhciBjPWEuZCxkPWEuZSxlPWEuYyxmPWIsZz1jW2ZdOzspe3ZhciBoPWY8PDE7aDxhLmEmJnUoZFtjW2grMV1dLGRbY1toXV0pJiYoaCs9MSk7dmFyIGs9Y1toXTtpZihoPmEuYXx8dShkW2ddLGRba10pKXtjW2ZdPWc7ZVtnXT1mO2JyZWFrfWNbZl09aztlW2tdPWY7Zj1ofX1mdW5jdGlvbiB2YShhLGIpe2Zvcih2YXIgYz1hLmQsZD1hLmUsZT1hLmMsZj1iLGc9Y1tmXTs7KXt2YXIgaD1mPj4xLGs9Y1toXTtpZigwPT09aHx8dShkW2tdLGRbZ10pKXtjW2ZdPWc7ZVtnXT1mO2JyZWFrfWNbZl09aztlW2tdPWY7Zj1ofX07ZnVuY3Rpb24gbWEoKXt0aGlzLmU9dGhpcy5hPW51bGw7dGhpcy5mPTA7dGhpcy5jPXRoaXMuYj10aGlzLmg9dGhpcy5kPSExfWZ1bmN0aW9uIFMoYSl7cmV0dXJuIGEuZS5jLmJ9ZnVuY3Rpb24gUihhKXtyZXR1cm4gYS5lLmEuYn07dGhpcy5saWJ0ZXNzPXtHbHVUZXNzZWxhdG9yOlgsd2luZGluZ1J1bGU6e0dMVV9URVNTX1dJTkRJTkdfT0REOjEwMDEzMCxHTFVfVEVTU19XSU5ESU5HX05PTlpFUk86MTAwMTMxLEdMVV9URVNTX1dJTkRJTkdfUE9TSVRJVkU6MTAwMTMyLEdMVV9URVNTX1dJTkRJTkdfTkVHQVRJVkU6MTAwMTMzLEdMVV9URVNTX1dJTkRJTkdfQUJTX0dFUV9UV086MTAwMTM0fSxwcmltaXRpdmVUeXBlOntHTF9MSU5FX0xPT1A6MixHTF9UUklBTkdMRVM6NCxHTF9UUklBTkdMRV9TVFJJUDo1LEdMX1RSSUFOR0xFX0ZBTjo2fSxlcnJvclR5cGU6e0dMVV9URVNTX01JU1NJTkdfQkVHSU5fUE9MWUdPTjoxMDAxNTEsR0xVX1RFU1NfTUlTU0lOR19FTkRfUE9MWUdPTjoxMDAxNTMsR0xVX1RFU1NfTUlTU0lOR19CRUdJTl9DT05UT1VSOjEwMDE1MixHTFVfVEVTU19NSVNTSU5HX0VORF9DT05UT1VSOjEwMDE1NCxHTFVfVEVTU19DT09SRF9UT09fTEFSR0U6MTAwMTU1LEdMVV9URVNTX05FRURfQ09NQklORV9DQUxMQkFDSzoxMDAxNTZ9LFxuZ2x1RW51bTp7R0xVX1RFU1NfTUVTSDoxMDAxMTIsR0xVX1RFU1NfVE9MRVJBTkNFOjEwMDE0MixHTFVfVEVTU19XSU5ESU5HX1JVTEU6MTAwMTQwLEdMVV9URVNTX0JPVU5EQVJZX09OTFk6MTAwMTQxLEdMVV9JTlZBTElEX0VOVU06MTAwOTAwLEdMVV9JTlZBTElEX1ZBTFVFOjEwMDkwMSxHTFVfVEVTU19CRUdJTjoxMDAxMDAsR0xVX1RFU1NfVkVSVEVYOjEwMDEwMSxHTFVfVEVTU19FTkQ6MTAwMTAyLEdMVV9URVNTX0VSUk9SOjEwMDEwMyxHTFVfVEVTU19FREdFX0ZMQUc6MTAwMTA0LEdMVV9URVNTX0NPTUJJTkU6MTAwMTA1LEdMVV9URVNTX0JFR0lOX0RBVEE6MTAwMTA2LEdMVV9URVNTX1ZFUlRFWF9EQVRBOjEwMDEwNyxHTFVfVEVTU19FTkRfREFUQToxMDAxMDgsR0xVX1RFU1NfRVJST1JfREFUQToxMDAxMDksR0xVX1RFU1NfRURHRV9GTEFHX0RBVEE6MTAwMTEwLEdMVV9URVNTX0NPTUJJTkVfREFUQToxMDAxMTF9fTtYLnByb3RvdHlwZS5nbHVEZWxldGVUZXNzPVgucHJvdG90eXBlLng7XG5YLnByb3RvdHlwZS5nbHVUZXNzUHJvcGVydHk9WC5wcm90b3R5cGUuQjtYLnByb3RvdHlwZS5nbHVHZXRUZXNzUHJvcGVydHk9WC5wcm90b3R5cGUueTtYLnByb3RvdHlwZS5nbHVUZXNzTm9ybWFsPVgucHJvdG90eXBlLkE7WC5wcm90b3R5cGUuZ2x1VGVzc0NhbGxiYWNrPVgucHJvdG90eXBlLno7WC5wcm90b3R5cGUuZ2x1VGVzc1ZlcnRleD1YLnByb3RvdHlwZS5DO1gucHJvdG90eXBlLmdsdVRlc3NCZWdpblBvbHlnb249WC5wcm90b3R5cGUudTtYLnByb3RvdHlwZS5nbHVUZXNzQmVnaW5Db250b3VyPVgucHJvdG90eXBlLnQ7WC5wcm90b3R5cGUuZ2x1VGVzc0VuZENvbnRvdXI9WC5wcm90b3R5cGUudjtYLnByb3RvdHlwZS5nbHVUZXNzRW5kUG9seWdvbj1YLnByb3RvdHlwZS53OyBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHsgbW9kdWxlLmV4cG9ydHMgPSB0aGlzLmxpYnRlc3M7IH1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gdGhlIG9ubHkgcmVsaWFibGUgbWVhbnMgdG8gZ2V0IHRoZSBnbG9iYWwgb2JqZWN0IGlzXG5cdC8vIGBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpYFxuXHQvLyBIb3dldmVyLCB0aGlzIGNhdXNlcyBDU1AgdmlvbGF0aW9ucyBpbiBDaHJvbWUgYXBwcy5cblx0aWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gc2VsZjsgfVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHdpbmRvdzsgfVxuXHRpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfVxuXHR0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCcpO1xufVxuXG52YXIgZ2xvYmFsT2JqZWN0ID0gZ2V0R2xvYmFsKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGdsb2JhbE9iamVjdC5mZXRjaDtcblxuLy8gTmVlZGVkIGZvciBUeXBlU2NyaXB0IGFuZCBXZWJwYWNrLlxuaWYgKGdsb2JhbE9iamVjdC5mZXRjaCkge1xuXHRleHBvcnRzLmRlZmF1bHQgPSBnbG9iYWxPYmplY3QuZmV0Y2guYmluZChnbG9iYWxPYmplY3QpO1xufVxuXG5leHBvcnRzLkhlYWRlcnMgPSBnbG9iYWxPYmplY3QuSGVhZGVycztcbmV4cG9ydHMuUmVxdWVzdCA9IGdsb2JhbE9iamVjdC5SZXF1ZXN0O1xuZXhwb3J0cy5SZXNwb25zZSA9IGdsb2JhbE9iamVjdC5SZXNwb25zZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG4gIGNzcyArPSBvYmouY3NzO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9XG5cbiAgLy8gRm9yIG9sZCBJRVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge30sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfVxuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgaWQ9XFxcIkxheWVyXzFcXFwiIGRhdGEtbmFtZT1cXFwiTGF5ZXIgMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgNjg5IDQ1Ni4zXFxcIj48Y2lyY2xlIGN4PVxcXCI3OC45OVxcXCIgY3k9XFxcIjIyNi42M1xcXCIgcj1cXFwiNzguOTlcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcIjI5Ni41XFxcIiBjeT1cXFwiMzQ0LjVcXFwiIHI9XFxcIjExMS44XFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXCI1NDEuMzZcXFwiIGN5PVxcXCIxNDcuNjRcXFwiIHI9XFxcIjE0Ny42NFxcXCI+PC9jaXJjbGU+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBpZD1cXFwiTGF5ZXJfMVxcXCIgZGF0YS1uYW1lPVxcXCJMYXllciAxXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCA2MjMuOTggNTMyLjExXFxcIj48cGF0aCBkPVxcXCJNNTkxLjMxLDQ5NS4yNWM1Ny45LTE0MC42MS0yMjAuNzUtMzExLTM2Ni45MS03Ny40Mkw2NCwyMjguODlDNDA5LDQ0LjM0LDYwNS40MiwxNjAuNzIsNjY4LjE2LDMwOGM3MC4zNSwxNjUuMTEtNjEuMTgsMzQ1LTE2MywzNTYuODgtOTQuNywxMS4wOS0yMTQuOC01OC4wOS0yNDUuNTYtODQuNDVsODEuMjktMTU2UzUzMy40LDYzNS44Niw1OTEuMzEsNDk1LjI1WlxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoLTY0LjAyIC0xMzMuOTQpXFxcIj48L3BhdGg+PHBhdGggZD1cXFwiTTU5OCw0MjhcXFwiIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKC02NC4wMiAtMTMzLjk0KVxcXCI+PC9wYXRoPjwvc3ZnPlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgaWQ9XFxcIkxheWVyXzFcXFwiIGRhdGEtbmFtZT1cXFwiTGF5ZXIgMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgNTk2IDYxMFxcXCI+PHBhdGggZD1cXFwiTTYzNCw1NzIsMjE2LDczMiw5Miw0NzQsMzI4LDE3NGwzNjAtNTJcXFwiIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKC05MiAtMTIyKVxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcIk01OTgsNDI4XFxcIiB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtOTIgLTEyMilcXFwiPjwvcGF0aD48L3N2Zz5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGZpbGw9XFxcIiMwMDAwMDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjx0aXRsZT5jYXB0dXJlPC90aXRsZT48cGF0aCBkPVxcXCJNNCAydjI4aDI0di0yOGgtMjR6TTI0IDIyaC0xNnYtMTZoMTZ2MTZ6XFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBpZD1cXFwiTGF5ZXJfMVxcXCIgZGF0YS1uYW1lPVxcXCJMYXllciAxXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCA2MDAgNjAwXFxcIj48cGF0aCBkPVxcXCJNMzAwLDEwMFYyMDBINjAwVjUwMEg3MDBWMTAwWlxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoLTEwMCAtMTAwKVxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcIk0zMjgsNzAwVjYwMEgyMDBWNDcySDEwMFY3MDBaXFxcIiB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtMTAwIC0xMDApXFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBmaWxsPVxcXCIjMDAwMDAwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48dGl0bGU+ZG93bmxvYWQ8L3RpdGxlPjxwYXRoIGQ9XFxcIk0xNi4wMDEgMTkuMzE0bC04LjQ4NS04LjQ4NSAyLjgyOC0yLjgyOSA1LjY1NyA1LjY1NyA1LjY1Ny01LjY1NyAyLjgyOCAyLjgyOC04LjQ4NSA4LjQ4NnpNOCAyOGgxNnYtNGgtMTZ2NHpcXFwiPjwvcGF0aD48L3N2Zz5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGZpbGw9XFxcIiMwMDAwMDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjx0aXRsZT5mb3JiaWQ8L3RpdGxlPjxwYXRoIGQ9XFxcIk0xOC44MjggMTZsNC4yNDMgNC4yNDMtMi44MjggMi44MjgtNC4yNDMtNC4yNDMtNC4yNDMgNC4yNDMtMi44MjgtMi44MjggNC4yNDMtNC4yNDMtNC4yNDMtNC4yNDMgMi44MjgtMi44MjggNC4yNDMgNC4yNDMgNC4yNDMtNC4yNDMgMi44MjggMi44MjgtNC4yNDMgNC4yNDN6XFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBmaWxsPVxcXCIjMDAwMDAwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48dGl0bGU+bGF1bmNoPC90aXRsZT48cGF0aCBkPVxcXCJNMjQgMjRoLTZ2NGgtNHYtNGgtNmw0LTR2LTEzbDQtNCA0IDR2MTNsNCA0elxcXCI+PC9wYXRoPjwvc3ZnPlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgaWQ9XFxcIkxheWVyXzFcXFwiIGRhdGEtbmFtZT1cXFwiTGF5ZXIgMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgNTI1Ljg2IDQzMS45NVxcXCI+PHBhdGggZD1cXFwiTTM4NSw2MDcuMzgsMTQ4LjY0LDQyMi42Mmw2MS41Ny03OC44TDM2Ny43OCw0NjdsMjI4LTI5MS41N0w2NzQuNSwyMzdaXFxcIiB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtMTQ4LjY0IC0xNzUuNDMpXFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBmaWxsPVxcXCIjMDAwMDAwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48dGl0bGU+cGx1ZzwvdGl0bGU+PHBhdGggZD1cXFwiTTIyIDExdi04aC0xMnY4aC0ydjE0aDZ2NGg0di00aDZ2LTE0aC0yek0xOCAxMWgtNHYtNGg0djR6XFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBmaWxsPVxcXCIjMDAwMDAwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48dGl0bGU+cmVkbzwvdGl0bGU+PHBhdGggZD1cXFwiTTI4IDI0djRoLTI0di0yMGgxMC4wNzFsLTMuNjU3LTMuNjU0IDIuODI4LTIuODI2IDguNDg1IDguNDg1LTguNDg1IDguNDg0LTIuODI4LTIuODMgMy42NTctMy42NTloLTYuMDcxdjEyaDIwelxcXCI+PC9wYXRoPjwvc3ZnPlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgZmlsbD1cXFwiIzAwMDAwMFxcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHRpdGxlPnJlc2l6ZTwvdGl0bGU+PHBhdGggZD1cXFwiTTI4IDEydi04aC04djJoLTh2LTJoLTh2OGgydjhoLTJ2OGg4di0yaDh2Mmg4di04aC0ydi04aDJ6TTIyIDIwaC0ydjJoLTh2LTJoLTJ2LThoMnYtMmg4djJoMnY4elxcXCI+PC9wYXRoPjwvc3ZnPlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgZmlsbD1cXFwiIzAwMDAwMFxcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHRpdGxlPnNvbHZlPC90aXRsZT48cGF0aCBkPVxcXCJNMjggMTJ2NGgtNHY2aC02djRoLTR2LTRoLTZ2LTZoLTR2LTRoNHYtNmg2djRoNHYtNGg2djZoNHpcXFwiPjwvcGF0aD48L3N2Zz5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGZpbGw9XFxcIiMwMDAwMDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjx0aXRsZT50aW1lPC90aXRsZT48cGF0aCBkPVxcXCJNMjIgMThoLTh2LThoNHY0aDR2NHpNMzAgMnYyOGgtMjh2LTI4aDI4ek0yNiA2aC0yMHYyMGgyMHYtMjB6XFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBmaWxsPVxcXCIjMDAwMDAwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48dGl0bGU+dW5kbzwvdGl0bGU+PHBhdGggZD1cXFwiTTI4IDh2MjBoLTI0di00aDIwdi0xMmgtNi4wNzFsMy42NTcgMy42Ni0yLjgyOCAyLjgzLTguNDg1LTguNDg0IDguNDg1LTguNDg1IDIuODI4IDIuODI2LTMuNjU3IDMuNjUzaDEwLjA3MXpcXFwiPjwvcGF0aD48L3N2Zz5cIiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qKlxuICogY2hyb21hLmpzIC0gSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBjb2xvciBjb252ZXJzaW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE5LCBHcmVnb3IgQWlzY2hcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIFRoZSBuYW1lIEdyZWdvciBBaXNjaCBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gKiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHUkVHT1IgQUlTQ0ggT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLFxuICogQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gKiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBjaHJvbWEuanMgaW5jbHVkZXMgY29sb3JzIGZyb20gY29sb3JicmV3ZXIyLm9yZywgd2hpY2ggYXJlIHJlbGVhc2VkIHVuZGVyXG4gKiB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDAyIEN5bnRoaWEgQnJld2VyLCBNYXJrIEhhcnJvd2VyLFxuICogYW5kIFRoZSBQZW5uc3lsdmFuaWEgU3RhdGUgVW5pdmVyc2l0eS5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCxcbiAqIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljXG4gKiBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIE5hbWVkIGNvbG9ycyBhcmUgdGFrZW4gZnJvbSBYMTEgQ29sb3IgTmFtZXMuXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiAqXG4gKiBAcHJlc2VydmVcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5jaHJvbWEgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGxpbWl0JDIgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKCBtaW4gPT09IHZvaWQgMCApIG1pbj0wO1xuICAgICAgICBpZiAoIG1heCA9PT0gdm9pZCAwICkgbWF4PTE7XG5cbiAgICAgICAgcmV0dXJuIHggPCBtaW4gPyBtaW4gOiB4ID4gbWF4ID8gbWF4IDogeDtcbiAgICB9O1xuXG4gICAgdmFyIGxpbWl0JDEgPSBsaW1pdCQyO1xuXG4gICAgdmFyIGNsaXBfcmdiJDMgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICAgIHJnYi5fY2xpcHBlZCA9IGZhbHNlO1xuICAgICAgICByZ2IuX3VuY2xpcHBlZCA9IHJnYi5zbGljZSgwKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPD0zOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgMykge1xuICAgICAgICAgICAgICAgIGlmIChyZ2JbaV0gPCAwIHx8IHJnYltpXSA+IDI1NSkgeyByZ2IuX2NsaXBwZWQgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgcmdiW2ldID0gbGltaXQkMShyZ2JbaV0sIDAsIDI1NSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZ2JbaV0gPSBsaW1pdCQxKHJnYltpXSwgMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9O1xuXG4gICAgLy8gcG9ydGVkIGZyb20galF1ZXJ5J3MgJC50eXBlXG4gICAgdmFyIGNsYXNzVG9UeXBlID0ge307XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gWydCb29sZWFuJywgJ051bWJlcicsICdTdHJpbmcnLCAnRnVuY3Rpb24nLCAnQXJyYXknLCAnRGF0ZScsICdSZWdFeHAnLCAnVW5kZWZpbmVkJywgJ051bGwnXTsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICBjbGFzc1RvVHlwZVsoXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiKV0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHZhciB0eXBlJHAgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzVG9UeXBlW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiO1xuICAgIH07XG5cbiAgICB2YXIgdHlwZSRvID0gdHlwZSRwO1xuXG4gICAgdmFyIHVucGFjayRCID0gZnVuY3Rpb24gKGFyZ3MsIGtleU9yZGVyKSB7XG4gICAgICAgIGlmICgga2V5T3JkZXIgPT09IHZvaWQgMCApIGtleU9yZGVyPW51bGw7XG5cbiAgICBcdC8vIGlmIGNhbGxlZCB3aXRoIG1vcmUgdGhhbiAzIGFyZ3VtZW50cywgd2UgcmV0dXJuIHRoZSBhcmd1bWVudHNcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID49IDMpIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpOyB9XG4gICAgICAgIC8vIHdpdGggbGVzcyB0aGFuIDMgYXJncyB3ZSBjaGVjayBpZiBmaXJzdCBhcmcgaXMgb2JqZWN0XG4gICAgICAgIC8vIGFuZCB1c2UgdGhlIGtleU9yZGVyIHN0cmluZyB0byBleHRyYWN0IGFuZCBzb3J0IHByb3BlcnRpZXNcbiAgICBcdGlmICh0eXBlJG8oYXJnc1swXSkgPT0gJ29iamVjdCcgJiYga2V5T3JkZXIpIHtcbiAgICBcdFx0cmV0dXJuIGtleU9yZGVyLnNwbGl0KCcnKVxuICAgIFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGFyZ3NbMF1ba10gIT09IHVuZGVmaW5lZDsgfSlcbiAgICBcdFx0XHQubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBhcmdzWzBdW2tdOyB9KTtcbiAgICBcdH1cbiAgICBcdC8vIG90aGVyd2lzZSB3ZSBqdXN0IHJldHVybiB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICBcdC8vICh3aGljaCB3ZSBzdXBwb3NlIGlzIGFuIGFycmF5IG9mIGFyZ3MpXG4gICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH07XG5cbiAgICB2YXIgdHlwZSRuID0gdHlwZSRwO1xuXG4gICAgdmFyIGxhc3QkNCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIGwgPSBhcmdzLmxlbmd0aC0xO1xuICAgICAgICBpZiAodHlwZSRuKGFyZ3NbbF0pID09ICdzdHJpbmcnKSB7IHJldHVybiBhcmdzW2xdLnRvTG93ZXJDYXNlKCk7IH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHZhciBQSSQyID0gTWF0aC5QSTtcblxuICAgIHZhciB1dGlscyA9IHtcbiAgICBcdGNsaXBfcmdiOiBjbGlwX3JnYiQzLFxuICAgIFx0bGltaXQ6IGxpbWl0JDIsXG4gICAgXHR0eXBlOiB0eXBlJHAsXG4gICAgXHR1bnBhY2s6IHVucGFjayRCLFxuICAgIFx0bGFzdDogbGFzdCQ0LFxuICAgIFx0UEk6IFBJJDIsXG4gICAgXHRUV09QSTogUEkkMioyLFxuICAgIFx0UElUSElSRDogUEkkMi8zLFxuICAgIFx0REVHMlJBRDogUEkkMiAvIDE4MCxcbiAgICBcdFJBRDJERUc6IDE4MCAvIFBJJDJcbiAgICB9O1xuXG4gICAgdmFyIGlucHV0JGggPSB7XG4gICAgXHRmb3JtYXQ6IHt9LFxuICAgIFx0YXV0b2RldGVjdDogW11cbiAgICB9O1xuXG4gICAgdmFyIGxhc3QkMyA9IHV0aWxzLmxhc3Q7XG4gICAgdmFyIGNsaXBfcmdiJDIgPSB1dGlscy5jbGlwX3JnYjtcbiAgICB2YXIgdHlwZSRtID0gdXRpbHMudHlwZTtcbiAgICB2YXIgX2lucHV0ID0gaW5wdXQkaDtcblxuICAgIHZhciBDb2xvciREID0gZnVuY3Rpb24gQ29sb3IoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGUkbShhcmdzWzBdKSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGFyZ3NbMF0uY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgIGFyZ3NbMF0uY29uc3RydWN0b3IgPT09IHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIC8vIHRoZSBhcmd1bWVudCBpcyBhbHJlYWR5IGEgQ29sb3IgaW5zdGFuY2VcbiAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGFzdCBhcmd1bWVudCBjb3VsZCBiZSB0aGUgbW9kZVxuICAgICAgICB2YXIgbW9kZSA9IGxhc3QkMyhhcmdzKTtcbiAgICAgICAgdmFyIGF1dG9kZXRlY3QgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIW1vZGUpIHtcbiAgICAgICAgICAgIGF1dG9kZXRlY3QgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFfaW5wdXQuc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgX2lucHV0LmF1dG9kZXRlY3QgPSBfaW5wdXQuYXV0b2RldGVjdC5zb3J0KGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIGIucCAtIGEucDsgfSk7XG4gICAgICAgICAgICAgICAgX2lucHV0LnNvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdXRvLWRldGVjdCBmb3JtYXRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gX2lucHV0LmF1dG9kZXRlY3Q7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoayA9IGxpc3RbaV07XG5cbiAgICAgICAgICAgICAgICBtb2RlID0gY2hrLnRlc3QuYXBwbHkoY2hrLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSkgeyBicmVhazsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9pbnB1dC5mb3JtYXRbbW9kZV0pIHtcbiAgICAgICAgICAgIHZhciByZ2IgPSBfaW5wdXQuZm9ybWF0W21vZGVdLmFwcGx5KG51bGwsIGF1dG9kZXRlY3QgPyBhcmdzIDogYXJncy5zbGljZSgwLC0xKSk7XG4gICAgICAgICAgICBtZS5fcmdiID0gY2xpcF9yZ2IkMihyZ2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGZvcm1hdDogJythcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBhbHBoYSBjaGFubmVsXG4gICAgICAgIGlmIChtZS5fcmdiLmxlbmd0aCA9PT0gMykgeyBtZS5fcmdiLnB1c2goMSk7IH1cbiAgICB9O1xuXG4gICAgQ29sb3IkRC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIGlmICh0eXBlJG0odGhpcy5oZXgpID09ICdmdW5jdGlvbicpIHsgcmV0dXJuIHRoaXMuaGV4KCk7IH1cbiAgICAgICAgcmV0dXJuIChcIltcIiArICh0aGlzLl9yZ2Iuam9pbignLCcpKSArIFwiXVwiKTtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yXzEgPSBDb2xvciREO1xuXG4gICAgdmFyIGNocm9tYSRrID0gZnVuY3Rpb24gKCkge1xuICAgIFx0dmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBcdHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBcdHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBjaHJvbWEkay5Db2xvciwgWyBudWxsIF0uY29uY2F0KCBhcmdzKSApKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGsuQ29sb3IgPSBDb2xvcl8xO1xuICAgIGNocm9tYSRrLnZlcnNpb24gPSAnMi40LjInO1xuXG4gICAgdmFyIGNocm9tYV8xID0gY2hyb21hJGs7XG5cbiAgICB2YXIgdW5wYWNrJEEgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIG1heCQyID0gTWF0aC5tYXg7XG5cbiAgICB2YXIgcmdiMmNteWskMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJEEoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICByID0gciAvIDI1NTtcbiAgICAgICAgZyA9IGcgLyAyNTU7XG4gICAgICAgIGIgPSBiIC8gMjU1O1xuICAgICAgICB2YXIgayA9IDEgLSBtYXgkMihyLG1heCQyKGcsYikpO1xuICAgICAgICB2YXIgZiA9IGsgPCAxID8gMSAvICgxLWspIDogMDtcbiAgICAgICAgdmFyIGMgPSAoMS1yLWspICogZjtcbiAgICAgICAgdmFyIG0gPSAoMS1nLWspICogZjtcbiAgICAgICAgdmFyIHkgPSAoMS1iLWspICogZjtcbiAgICAgICAgcmV0dXJuIFtjLG0seSxrXTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJjbXlrXzEgPSByZ2IyY215ayQxO1xuXG4gICAgdmFyIHVucGFjayR6ID0gdXRpbHMudW5wYWNrO1xuXG4gICAgdmFyIGNteWsycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2skeihhcmdzLCAnY215aycpO1xuICAgICAgICB2YXIgYyA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBtID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIHkgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgayA9IGFyZ3NbM107XG4gICAgICAgIHZhciBhbHBoYSA9IGFyZ3MubGVuZ3RoID4gNCA/IGFyZ3NbNF0gOiAxO1xuICAgICAgICBpZiAoayA9PT0gMSkgeyByZXR1cm4gWzAsMCwwLGFscGhhXTsgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYyA+PSAxID8gMCA6IDI1NSAqICgxLWMpICogKDEtayksIC8vIHJcbiAgICAgICAgICAgIG0gPj0gMSA/IDAgOiAyNTUgKiAoMS1tKSAqICgxLWspLCAvLyBnXG4gICAgICAgICAgICB5ID49IDEgPyAwIDogMjU1ICogKDEteSkgKiAoMS1rKSwgLy8gYlxuICAgICAgICAgICAgYWxwaGFcbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgdmFyIGNteWsycmdiXzEgPSBjbXlrMnJnYjtcblxuICAgIHZhciBjaHJvbWEkaiA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciRDID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkZyA9IGlucHV0JGg7XG4gICAgdmFyIHVucGFjayR5ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJGwgPSB1dGlscy50eXBlO1xuXG4gICAgdmFyIHJnYjJjbXlrID0gcmdiMmNteWtfMTtcblxuICAgIENvbG9yJEMucHJvdG90eXBlLmNteWsgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJjbXlrKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSRqLmNteWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJEMsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydjbXlrJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCRnLmZvcm1hdC5jbXlrID0gY215azJyZ2JfMTtcblxuICAgIGlucHV0JGcuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skeShhcmdzLCAnY215aycpO1xuICAgICAgICAgICAgaWYgKHR5cGUkbChhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnY215ayc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB1bnBhY2skeCA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbGFzdCQyID0gdXRpbHMubGFzdDtcbiAgICB2YXIgcm5kID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIE1hdGgucm91bmQoYSoxMDApLzEwMDsgfTtcblxuICAgIC8qXG4gICAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICAgKiAtIGhzbDJjc3MoaCxzLGwpXG4gICAgICogLSBoc2wyY3NzKGgscyxsLGEpXG4gICAgICogLSBoc2wyY3NzKFtoLHMsbF0sIG1vZGUpXG4gICAgICogLSBoc2wyY3NzKFtoLHMsbCxhXSwgbW9kZSlcbiAgICAgKiAtIGhzbDJjc3Moe2gscyxsLGF9LCBtb2RlKVxuICAgICAqL1xuICAgIHZhciBoc2wyY3NzJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIGhzbGEgPSB1bnBhY2skeChhcmdzLCAnaHNsYScpO1xuICAgICAgICB2YXIgbW9kZSA9IGxhc3QkMihhcmdzKSB8fCAnbHNhJztcbiAgICAgICAgaHNsYVswXSA9IHJuZChoc2xhWzBdIHx8IDApO1xuICAgICAgICBoc2xhWzFdID0gcm5kKGhzbGFbMV0qMTAwKSArICclJztcbiAgICAgICAgaHNsYVsyXSA9IHJuZChoc2xhWzJdKjEwMCkgKyAnJSc7XG4gICAgICAgIGlmIChtb2RlID09PSAnaHNsYScgfHwgKGhzbGEubGVuZ3RoID4gMyAmJiBoc2xhWzNdPDEpKSB7XG4gICAgICAgICAgICBoc2xhWzNdID0gaHNsYS5sZW5ndGggPiAzID8gaHNsYVszXSA6IDE7XG4gICAgICAgICAgICBtb2RlID0gJ2hzbGEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHNsYS5sZW5ndGggPSAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobW9kZSArIFwiKFwiICsgKGhzbGEuam9pbignLCcpKSArIFwiKVwiKTtcbiAgICB9O1xuXG4gICAgdmFyIGhzbDJjc3NfMSA9IGhzbDJjc3MkMTtcblxuICAgIHZhciB1bnBhY2skdyA9IHV0aWxzLnVucGFjaztcblxuICAgIC8qXG4gICAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICAgKiAtIHJnYjJoc2wocixnLGIpXG4gICAgICogLSByZ2IyaHNsKHIsZyxiLGEpXG4gICAgICogLSByZ2IyaHNsKFtyLGcsYl0pXG4gICAgICogLSByZ2IyaHNsKFtyLGcsYixhXSlcbiAgICAgKiAtIHJnYjJoc2woe3IsZyxiLGF9KVxuICAgICAqL1xuICAgIHZhciByZ2IyaHNsJDMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayR3KGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgIHZhciByID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGcgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgYiA9IGFyZ3NbMl07XG5cbiAgICAgICAgciAvPSAyNTU7XG4gICAgICAgIGcgLz0gMjU1O1xuICAgICAgICBiIC89IDI1NTtcblxuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblxuICAgICAgICB2YXIgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICAgICAgdmFyIHMsIGg7XG5cbiAgICAgICAgaWYgKG1heCA9PT0gbWluKXtcbiAgICAgICAgICAgIHMgPSAwO1xuICAgICAgICAgICAgaCA9IE51bWJlci5OYU47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gbCA8IDAuNSA/IChtYXggLSBtaW4pIC8gKG1heCArIG1pbikgOiAobWF4IC0gbWluKSAvICgyIC0gbWF4IC0gbWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyID09IG1heCkgeyBoID0gKGcgLSBiKSAvIChtYXggLSBtaW4pOyB9XG4gICAgICAgIGVsc2UgaWYgKGcgPT0gbWF4KSB7IGggPSAyICsgKGIgLSByKSAvIChtYXggLSBtaW4pOyB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gbWF4KSB7IGggPSA0ICsgKHIgLSBnKSAvIChtYXggLSBtaW4pOyB9XG5cbiAgICAgICAgaCAqPSA2MDtcbiAgICAgICAgaWYgKGggPCAwKSB7IGggKz0gMzYwOyB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aD4zICYmIGFyZ3NbM10hPT11bmRlZmluZWQpIHsgcmV0dXJuIFtoLHMsbCxhcmdzWzNdXTsgfVxuICAgICAgICByZXR1cm4gW2gscyxsXTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJoc2xfMSA9IHJnYjJoc2wkMztcblxuICAgIHZhciB1bnBhY2skdiA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbGFzdCQxID0gdXRpbHMubGFzdDtcbiAgICB2YXIgaHNsMmNzcyA9IGhzbDJjc3NfMTtcbiAgICB2YXIgcmdiMmhzbCQyID0gcmdiMmhzbF8xO1xuICAgIHZhciByb3VuZCQ2ID0gTWF0aC5yb3VuZDtcblxuICAgIC8qXG4gICAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICAgKiAtIHJnYjJjc3MocixnLGIpXG4gICAgICogLSByZ2IyY3NzKHIsZyxiLGEpXG4gICAgICogLSByZ2IyY3NzKFtyLGcsYl0sIG1vZGUpXG4gICAgICogLSByZ2IyY3NzKFtyLGcsYixhXSwgbW9kZSlcbiAgICAgKiAtIHJnYjJjc3Moe3IsZyxiLGF9LCBtb2RlKVxuICAgICAqL1xuICAgIHZhciByZ2IyY3NzJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJnYmEgPSB1bnBhY2skdihhcmdzLCAncmdiYScpO1xuICAgICAgICB2YXIgbW9kZSA9IGxhc3QkMShhcmdzKSB8fCAncmdiJztcbiAgICAgICAgaWYgKG1vZGUuc3Vic3RyKDAsMykgPT0gJ2hzbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBoc2wyY3NzKHJnYjJoc2wkMihyZ2JhKSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmdiYVswXSA9IHJvdW5kJDYocmdiYVswXSk7XG4gICAgICAgIHJnYmFbMV0gPSByb3VuZCQ2KHJnYmFbMV0pO1xuICAgICAgICByZ2JhWzJdID0gcm91bmQkNihyZ2JhWzJdKTtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdyZ2JhJyB8fCAocmdiYS5sZW5ndGggPiAzICYmIHJnYmFbM108MSkpIHtcbiAgICAgICAgICAgIHJnYmFbM10gPSByZ2JhLmxlbmd0aCA+IDMgPyByZ2JhWzNdIDogMTtcbiAgICAgICAgICAgIG1vZGUgPSAncmdiYSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChtb2RlICsgXCIoXCIgKyAocmdiYS5zbGljZSgwLG1vZGU9PT0ncmdiJz8zOjQpLmpvaW4oJywnKSkgKyBcIilcIik7XG4gICAgfTtcblxuICAgIHZhciByZ2IyY3NzXzEgPSByZ2IyY3NzJDE7XG5cbiAgICB2YXIgdW5wYWNrJHUgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHJvdW5kJDUgPSBNYXRoLnJvdW5kO1xuXG4gICAgdmFyIGhzbDJyZ2IkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFzc2lnbjtcblxuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuICAgICAgICBhcmdzID0gdW5wYWNrJHUoYXJncywgJ2hzbCcpO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBzID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGwgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgcixnLGI7XG4gICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgICByID0gZyA9IGIgPSBsKjI1NTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0MyA9IFswLDAsMF07XG4gICAgICAgICAgICB2YXIgYyA9IFswLDAsMF07XG4gICAgICAgICAgICB2YXIgdDIgPSBsIDwgMC41ID8gbCAqICgxK3MpIDogbCtzLWwqcztcbiAgICAgICAgICAgIHZhciB0MSA9IDIgKiBsIC0gdDI7XG4gICAgICAgICAgICB2YXIgaF8gPSBoIC8gMzYwO1xuICAgICAgICAgICAgdDNbMF0gPSBoXyArIDEvMztcbiAgICAgICAgICAgIHQzWzFdID0gaF87XG4gICAgICAgICAgICB0M1syXSA9IGhfIC0gMS8zO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0M1tpXSA8IDApIHsgdDNbaV0gKz0gMTsgfVxuICAgICAgICAgICAgICAgIGlmICh0M1tpXSA+IDEpIHsgdDNbaV0gLT0gMTsgfVxuICAgICAgICAgICAgICAgIGlmICg2ICogdDNbaV0gPCAxKVxuICAgICAgICAgICAgICAgICAgICB7IGNbaV0gPSB0MSArICh0MiAtIHQxKSAqIDYgKiB0M1tpXTsgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKDIgKiB0M1tpXSA8IDEpXG4gICAgICAgICAgICAgICAgICAgIHsgY1tpXSA9IHQyOyB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoMyAqIHQzW2ldIDwgMilcbiAgICAgICAgICAgICAgICAgICAgeyBjW2ldID0gdDEgKyAodDIgLSB0MSkgKiAoKDIgLyAzKSAtIHQzW2ldKSAqIDY7IH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHsgY1tpXSA9IHQxOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoYXNzaWduID0gW3JvdW5kJDUoY1swXSoyNTUpLHJvdW5kJDUoY1sxXSoyNTUpLHJvdW5kJDUoY1syXSoyNTUpXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgLy8ga2VlcCBhbHBoYSBjaGFubmVsXG4gICAgICAgICAgICByZXR1cm4gW3IsZyxiLGFyZ3NbM11dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcixnLGIsMV07XG4gICAgfTtcblxuICAgIHZhciBoc2wycmdiXzEgPSBoc2wycmdiJDE7XG5cbiAgICB2YXIgaHNsMnJnYiA9IGhzbDJyZ2JfMTtcbiAgICB2YXIgaW5wdXQkZiA9IGlucHV0JGg7XG5cbiAgICB2YXIgUkVfUkdCID0gL15yZ2JcXChcXHMqKC0/XFxkKyksXFxzKigtP1xcZCspXFxzKixcXHMqKC0/XFxkKylcXHMqXFwpJC87XG4gICAgdmFyIFJFX1JHQkEgPSAvXnJnYmFcXChcXHMqKC0/XFxkKyksXFxzKigtP1xcZCspXFxzKixcXHMqKC0/XFxkKylcXHMqLFxccyooWzAxXXxbMDFdP1xcLlxcZCspXFwpJC87XG4gICAgdmFyIFJFX1JHQl9QQ1QgPSAvXnJnYlxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSUsXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgICB2YXIgUkVfUkdCQV9QQ1QgPSAvXnJnYmFcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooWzAxXXxbMDFdP1xcLlxcZCspXFwpJC87XG4gICAgdmFyIFJFX0hTTCA9IC9eaHNsXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwpJC87XG4gICAgdmFyIFJFX0hTTEEgPSAvXmhzbGFcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcblxuICAgIHZhciByb3VuZCQ0ID0gTWF0aC5yb3VuZDtcblxuICAgIHZhciBjc3MycmdiJDEgPSBmdW5jdGlvbiAoY3NzKSB7XG4gICAgICAgIGNzcyA9IGNzcy50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgdmFyIG07XG5cbiAgICAgICAgaWYgKGlucHV0JGYuZm9ybWF0Lm5hbWVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dCRmLmZvcm1hdC5uYW1lZChjc3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmdiKDI1MCwyMCwwKVxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfUkdCKSkpIHtcbiAgICAgICAgICAgIHZhciByZ2IgPSBtLnNsaWNlKDEsNCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8MzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmdiW2ldID0gK3JnYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJnYlszXSA9IDE7ICAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgICAgICByZXR1cm4gcmdiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmdiYSgyNTAsMjAsMCwwLjQpXG4gICAgICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9SR0JBKSkpIHtcbiAgICAgICAgICAgIHZhciByZ2IkMSA9IG0uc2xpY2UoMSw1KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMT0wOyBpJDE8NDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICByZ2IkMVtpJDFdID0gK3JnYiQxW2kkMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmdiJDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZ2IoMTAwJSwwJSwwJSlcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX1JHQl9QQ1QpKSkge1xuICAgICAgICAgICAgdmFyIHJnYiQyID0gbS5zbGljZSgxLDQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQyPTA7IGkkMjwzOyBpJDIrKykge1xuICAgICAgICAgICAgICAgIHJnYiQyW2kkMl0gPSByb3VuZCQ0KHJnYiQyW2kkMl0gKiAyLjU1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJnYiQyWzNdID0gMTsgIC8vIGRlZmF1bHQgYWxwaGFcbiAgICAgICAgICAgIHJldHVybiByZ2IkMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJnYmEoMTAwJSwwJSwwJSwwLjQpXG4gICAgICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9SR0JBX1BDVCkpKSB7XG4gICAgICAgICAgICB2YXIgcmdiJDMgPSBtLnNsaWNlKDEsNSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDM9MDsgaSQzPDM7IGkkMysrKSB7XG4gICAgICAgICAgICAgICAgcmdiJDNbaSQzXSA9IHJvdW5kJDQocmdiJDNbaSQzXSAqIDIuNTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmdiJDNbM10gPSArcmdiJDNbM107XG4gICAgICAgICAgICByZXR1cm4gcmdiJDM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoc2woMCwxMDAlLDUwJSlcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX0hTTCkpKSB7XG4gICAgICAgICAgICB2YXIgaHNsID0gbS5zbGljZSgxLDQpO1xuICAgICAgICAgICAgaHNsWzFdICo9IDAuMDE7XG4gICAgICAgICAgICBoc2xbMl0gKj0gMC4wMTtcbiAgICAgICAgICAgIHZhciByZ2IkNCA9IGhzbDJyZ2IoaHNsKTtcbiAgICAgICAgICAgIHJnYiQ0WzNdID0gMTtcbiAgICAgICAgICAgIHJldHVybiByZ2IkNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhzbGEoMCwxMDAlLDUwJSwwLjUpXG4gICAgICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9IU0xBKSkpIHtcbiAgICAgICAgICAgIHZhciBoc2wkMSA9IG0uc2xpY2UoMSw0KTtcbiAgICAgICAgICAgIGhzbCQxWzFdICo9IDAuMDE7XG4gICAgICAgICAgICBoc2wkMVsyXSAqPSAwLjAxO1xuICAgICAgICAgICAgdmFyIHJnYiQ1ID0gaHNsMnJnYihoc2wkMSk7XG4gICAgICAgICAgICByZ2IkNVszXSA9ICttWzRdOyAgLy8gZGVmYXVsdCBhbHBoYSA9IDFcbiAgICAgICAgICAgIHJldHVybiByZ2IkNTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjc3MycmdiJDEudGVzdCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBSRV9SR0IudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfUkdCQS50ZXN0KHMpIHx8XG4gICAgICAgICAgICBSRV9SR0JfUENULnRlc3QocykgfHxcbiAgICAgICAgICAgIFJFX1JHQkFfUENULnRlc3QocykgfHxcbiAgICAgICAgICAgIFJFX0hTTC50ZXN0KHMpIHx8XG4gICAgICAgICAgICBSRV9IU0xBLnRlc3Qocyk7XG4gICAgfTtcblxuICAgIHZhciBjc3MycmdiXzEgPSBjc3MycmdiJDE7XG5cbiAgICB2YXIgY2hyb21hJGkgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkQiA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JGUgPSBpbnB1dCRoO1xuICAgIHZhciB0eXBlJGsgPSB1dGlscy50eXBlO1xuXG4gICAgdmFyIHJnYjJjc3MgPSByZ2IyY3NzXzE7XG4gICAgdmFyIGNzczJyZ2IgPSBjc3MycmdiXzE7XG5cbiAgICBDb2xvciRCLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbihtb2RlKSB7XG4gICAgICAgIHJldHVybiByZ2IyY3NzKHRoaXMuX3JnYiwgbW9kZSk7XG4gICAgfTtcblxuICAgIGNocm9tYSRpLmNzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkQiwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2NzcyddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkZS5mb3JtYXQuY3NzID0gY3NzMnJnYjtcblxuICAgIGlucHV0JGUuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogNSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSByZXN0WyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3QubGVuZ3RoICYmIHR5cGUkayhoKSA9PT0gJ3N0cmluZycgJiYgY3NzMnJnYi50ZXN0KGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjc3MnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgQ29sb3IkQSA9IENvbG9yXzE7XG4gICAgdmFyIGNocm9tYSRoID0gY2hyb21hXzE7XG4gICAgdmFyIGlucHV0JGQgPSBpbnB1dCRoO1xuICAgIHZhciB1bnBhY2skdCA9IHV0aWxzLnVucGFjaztcblxuICAgIGlucHV0JGQuZm9ybWF0LmdsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZ2IgPSB1bnBhY2skdChhcmdzLCAncmdiYScpO1xuICAgICAgICByZ2JbMF0gKj0gMjU1O1xuICAgICAgICByZ2JbMV0gKj0gMjU1O1xuICAgICAgICByZ2JbMl0gKj0gMjU1O1xuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH07XG5cbiAgICBjaHJvbWEkaC5nbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkQSwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2dsJ10pICkpO1xuICAgIH07XG5cbiAgICBDb2xvciRBLnByb3RvdHlwZS5nbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmdiID0gdGhpcy5fcmdiO1xuICAgICAgICByZXR1cm4gW3JnYlswXS8yNTUsIHJnYlsxXS8yNTUsIHJnYlsyXS8yNTUsIHJnYlszXV07XG4gICAgfTtcblxuICAgIHZhciB1bnBhY2skcyA9IHV0aWxzLnVucGFjaztcblxuICAgIHZhciByZ2IyaGNnJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayRzKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgICAgICAgdmFyIGMgPSBkZWx0YSAqIDEwMCAvIDI1NTtcbiAgICAgICAgdmFyIF9nID0gbWluIC8gKDI1NSAtIGRlbHRhKSAqIDEwMDtcbiAgICAgICAgdmFyIGg7XG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICAgICAgaCA9IE51bWJlci5OYU47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAociA9PT0gbWF4KSB7IGggPSAoZyAtIGIpIC8gZGVsdGE7IH1cbiAgICAgICAgICAgIGlmIChnID09PSBtYXgpIHsgaCA9IDIrKGIgLSByKSAvIGRlbHRhOyB9XG4gICAgICAgICAgICBpZiAoYiA9PT0gbWF4KSB7IGggPSA0KyhyIC0gZykgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaCAqPSA2MDtcbiAgICAgICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbaCwgYywgX2ddO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmhjZ18xID0gcmdiMmhjZyQxO1xuXG4gICAgdmFyIHVucGFjayRyID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBmbG9vciQzID0gTWF0aC5mbG9vcjtcblxuICAgIC8qXG4gICAgICogdGhpcyBpcyBiYXNpY2FsbHkganVzdCBIU1Ygd2l0aCBzb21lIG1pbm9yIHR3ZWFrc1xuICAgICAqXG4gICAgICogaHVlLi4gWzAuLjM2MF1cbiAgICAgKiBjaHJvbWEgLi4gWzAuLjFdXG4gICAgICogZ3JheW5lc3MgLi4gWzAuLjFdXG4gICAgICovXG5cbiAgICB2YXIgaGNnMnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFzc2lnbiwgYXNzaWduJDEsIGFzc2lnbiQyLCBhc3NpZ24kMywgYXNzaWduJDQsIGFzc2lnbiQ1O1xuXG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG4gICAgICAgIGFyZ3MgPSB1bnBhY2skcihhcmdzLCAnaGNnJyk7XG4gICAgICAgIHZhciBoID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgX2cgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgcixnLGI7XG4gICAgICAgIF9nID0gX2cgKiAyNTU7XG4gICAgICAgIHZhciBfYyA9IGMgKiAyNTU7XG4gICAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgICAgICByID0gZyA9IGIgPSBfZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoID09PSAzNjApIHsgaCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChoID4gMzYwKSB7IGggLT0gMzYwOyB9XG4gICAgICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgICAgIGggLz0gNjA7XG4gICAgICAgICAgICB2YXIgaSA9IGZsb29yJDMoaCk7XG4gICAgICAgICAgICB2YXIgZiA9IGggLSBpO1xuICAgICAgICAgICAgdmFyIHAgPSBfZyAqICgxIC0gYyk7XG4gICAgICAgICAgICB2YXIgcSA9IHAgKyBfYyAqICgxIC0gZik7XG4gICAgICAgICAgICB2YXIgdCA9IHAgKyBfYyAqIGY7XG4gICAgICAgICAgICB2YXIgdiA9IHAgKyBfYztcbiAgICAgICAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogKGFzc2lnbiA9IFt2LCB0LCBwXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAoYXNzaWduJDEgPSBbcSwgdiwgcF0sIHIgPSBhc3NpZ24kMVswXSwgZyA9IGFzc2lnbiQxWzFdLCBiID0gYXNzaWduJDFbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgMjogKGFzc2lnbiQyID0gW3AsIHYsIHRdLCByID0gYXNzaWduJDJbMF0sIGcgPSBhc3NpZ24kMlsxXSwgYiA9IGFzc2lnbiQyWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDM6IChhc3NpZ24kMyA9IFtwLCBxLCB2XSwgciA9IGFzc2lnbiQzWzBdLCBnID0gYXNzaWduJDNbMV0sIGIgPSBhc3NpZ24kM1syXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSA0OiAoYXNzaWduJDQgPSBbdCwgcCwgdl0sIHIgPSBhc3NpZ24kNFswXSwgZyA9IGFzc2lnbiQ0WzFdLCBiID0gYXNzaWduJDRbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgNTogKGFzc2lnbiQ1ID0gW3YsIHAsIHFdLCByID0gYXNzaWduJDVbMF0sIGcgPSBhc3NpZ24kNVsxXSwgYiA9IGFzc2lnbiQ1WzJdKTsgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgICB9O1xuXG4gICAgdmFyIGhjZzJyZ2JfMSA9IGhjZzJyZ2I7XG5cbiAgICB2YXIgdW5wYWNrJHEgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkaiA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNocm9tYSRnID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHogPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCRjID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2IyaGNnID0gcmdiMmhjZ18xO1xuXG4gICAgQ29sb3Ikei5wcm90b3R5cGUuaGNnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IyaGNnKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSRnLmhjZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkeiwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hjZyddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkYy5mb3JtYXQuaGNnID0gaGNnMnJnYl8xO1xuXG4gICAgaW5wdXQkYy5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAxLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayRxKGFyZ3MsICdoY2cnKTtcbiAgICAgICAgICAgIGlmICh0eXBlJGooYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hjZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB1bnBhY2skcCA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbGFzdCA9IHV0aWxzLmxhc3Q7XG4gICAgdmFyIHJvdW5kJDMgPSBNYXRoLnJvdW5kO1xuXG4gICAgdmFyIHJnYjJoZXgkMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJHAoYXJncywgJ3JnYmEnKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgdmFyIGEgPSByZWZbM107XG4gICAgICAgIHZhciBtb2RlID0gbGFzdChhcmdzKSB8fCAnYXV0byc7XG4gICAgICAgIGlmIChhID09PSB1bmRlZmluZWQpIHsgYSA9IDE7IH1cbiAgICAgICAgaWYgKG1vZGUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgbW9kZSA9IGEgPCAxID8gJ3JnYmEnIDogJ3JnYic7XG4gICAgICAgIH1cbiAgICAgICAgciA9IHJvdW5kJDMocik7XG4gICAgICAgIGcgPSByb3VuZCQzKGcpO1xuICAgICAgICBiID0gcm91bmQkMyhiKTtcbiAgICAgICAgdmFyIHUgPSByIDw8IDE2IHwgZyA8PCA4IHwgYjtcbiAgICAgICAgdmFyIHN0ciA9IFwiMDAwMDAwXCIgKyB1LnRvU3RyaW5nKDE2KTsgLy8jLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoc3RyLmxlbmd0aCAtIDYpO1xuICAgICAgICB2YXIgaHhhID0gJzAnICsgcm91bmQkMyhhICogMjU1KS50b1N0cmluZygxNik7XG4gICAgICAgIGh4YSA9IGh4YS5zdWJzdHIoaHhhLmxlbmd0aCAtIDIpO1xuICAgICAgICBzd2l0Y2ggKG1vZGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAncmdiYSc6IHJldHVybiAoXCIjXCIgKyBzdHIgKyBoeGEpO1xuICAgICAgICAgICAgY2FzZSAnYXJnYic6IHJldHVybiAoXCIjXCIgKyBoeGEgKyBzdHIpO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIChcIiNcIiArIHN0cik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJnYjJoZXhfMSA9IHJnYjJoZXgkMjtcblxuICAgIHZhciBSRV9IRVggPSAvXiM/KFtBLUZhLWYwLTldezZ9fFtBLUZhLWYwLTldezN9KSQvO1xuICAgIHZhciBSRV9IRVhBID0gL14jPyhbQS1GYS1mMC05XXs4fXxbQS1GYS1mMC05XXs0fSkkLztcblxuICAgIHZhciBoZXgycmdiJDEgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgICAgIGlmIChoZXgubWF0Y2goUkVfSEVYKSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9wdGlvbmFsIGxlYWRpbmcgI1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDQgfHwgaGV4Lmxlbmd0aCA9PT0gNykge1xuICAgICAgICAgICAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgc2hvcnQtbm90YXRpb24gdG8gZnVsbCBzaXgtZGlnaXRcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXhbMF0raGV4WzBdK2hleFsxXStoZXhbMV0raGV4WzJdK2hleFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1ID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgICAgICB2YXIgciA9IHUgPj4gMTY7XG4gICAgICAgICAgICB2YXIgZyA9IHUgPj4gOCAmIDB4RkY7XG4gICAgICAgICAgICB2YXIgYiA9IHUgJiAweEZGO1xuICAgICAgICAgICAgcmV0dXJuIFtyLGcsYiwxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hdGNoIHJnYmEgaGV4IGZvcm1hdCwgZWcgI0ZGMDAwMDc3XG4gICAgICAgIGlmIChoZXgubWF0Y2goUkVfSEVYQSkpIHtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA1IHx8IGhleC5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3B0aW9uYWwgbGVhZGluZyAjXG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV4cGFuZCBzaG9ydC1ub3RhdGlvbiB0byBmdWxsIGVpZ2h0LWRpZ2l0XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGhleCA9IGhleC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4WzBdK2hleFswXStoZXhbMV0raGV4WzFdK2hleFsyXStoZXhbMl0raGV4WzNdK2hleFszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1JDEgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgICAgIHZhciByJDEgPSB1JDEgPj4gMjQgJiAweEZGO1xuICAgICAgICAgICAgdmFyIGckMSA9IHUkMSA+PiAxNiAmIDB4RkY7XG4gICAgICAgICAgICB2YXIgYiQxID0gdSQxID4+IDggJiAweEZGO1xuICAgICAgICAgICAgdmFyIGEgPSBNYXRoLnJvdW5kKCh1JDEgJiAweEZGKSAvIDB4RkYgKiAxMDApIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIFtyJDEsZyQxLGIkMSxhXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIHVzZWQgdG8gY2hlY2sgZm9yIGNzcyBjb2xvcnMgaGVyZVxuICAgICAgICAvLyBpZiBfaW5wdXQuY3NzPyBhbmQgcmdiID0gX2lucHV0LmNzcyBoZXhcbiAgICAgICAgLy8gICAgIHJldHVybiByZ2JcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwidW5rbm93biBoZXggY29sb3I6IFwiICsgaGV4KSk7XG4gICAgfTtcblxuICAgIHZhciBoZXgycmdiXzEgPSBoZXgycmdiJDE7XG5cbiAgICB2YXIgY2hyb21hJGYgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkeSA9IENvbG9yXzE7XG4gICAgdmFyIHR5cGUkaSA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGlucHV0JGIgPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJoZXgkMSA9IHJnYjJoZXhfMTtcblxuICAgIENvbG9yJHkucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJoZXgkMSh0aGlzLl9yZ2IsIG1vZGUpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkZi5oZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHksIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydoZXgnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JGIuZm9ybWF0LmhleCA9IGhleDJyZ2JfMTtcbiAgICBpbnB1dCRiLmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDQsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gPiAwICkgcmVzdFsgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgICAgICAgICAgaWYgKCFyZXN0Lmxlbmd0aCAmJiB0eXBlJGkoaCkgPT09ICdzdHJpbmcnICYmIFszLDQsNSw2LDcsOCw5XS5pbmRleE9mKGgubGVuZ3RoKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoZXgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJG8gPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIFRXT1BJJDIgPSB1dGlscy5UV09QSTtcbiAgICB2YXIgbWluJDIgPSBNYXRoLm1pbjtcbiAgICB2YXIgc3FydCQ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBhY29zID0gTWF0aC5hY29zO1xuXG4gICAgdmFyIHJnYjJoc2kkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAvKlxuICAgICAgICBib3Jyb3dlZCBmcm9tIGhlcmU6XG4gICAgICAgIGh0dHA6Ly9odW1tZXIuc3RhbmZvcmQuZWR1L211c2VpbmZvL2RvYy9leGFtcGxlcy9odW1kcnVtL2tleXNjYXBlMi9yZ2IyaHNpLmNwcFxuICAgICAgICAqL1xuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJG8oYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICByIC89IDI1NTtcbiAgICAgICAgZyAvPSAyNTU7XG4gICAgICAgIGIgLz0gMjU1O1xuICAgICAgICB2YXIgaDtcbiAgICAgICAgdmFyIG1pbl8gPSBtaW4kMihyLGcsYik7XG4gICAgICAgIHZhciBpID0gKHIrZytiKSAvIDM7XG4gICAgICAgIHZhciBzID0gaSA+IDAgPyAxIC0gbWluXy9pIDogMDtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIGggPSBOYU47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoID0gKChyLWcpKyhyLWIpKSAvIDI7XG4gICAgICAgICAgICBoIC89IHNxcnQkNCgoci1nKSooci1nKSArIChyLWIpKihnLWIpKTtcbiAgICAgICAgICAgIGggPSBhY29zKGgpO1xuICAgICAgICAgICAgaWYgKGIgPiBnKSB7XG4gICAgICAgICAgICAgICAgaCA9IFRXT1BJJDIgLSBoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaCAvPSBUV09QSSQyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbaCozNjAscyxpXTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJoc2lfMSA9IHJnYjJoc2kkMTtcblxuICAgIHZhciB1bnBhY2skbiA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbGltaXQgPSB1dGlscy5saW1pdDtcbiAgICB2YXIgVFdPUEkkMSA9IHV0aWxzLlRXT1BJO1xuICAgIHZhciBQSVRISVJEID0gdXRpbHMuUElUSElSRDtcbiAgICB2YXIgY29zJDQgPSBNYXRoLmNvcztcblxuICAgIC8qXG4gICAgICogaHVlIFswLi4zNjBdXG4gICAgICogc2F0dXJhdGlvbiBbMC4uMV1cbiAgICAgKiBpbnRlbnNpdHkgWzAuLjFdXG4gICAgICovXG4gICAgdmFyIGhzaTJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgLypcbiAgICAgICAgYm9ycm93ZWQgZnJvbSBoZXJlOlxuICAgICAgICBodHRwOi8vaHVtbWVyLnN0YW5mb3JkLmVkdS9tdXNlaW5mby9kb2MvZXhhbXBsZXMvaHVtZHJ1bS9rZXlzY2FwZTIvaHNpMnJnYi5jcHBcbiAgICAgICAgKi9cbiAgICAgICAgYXJncyA9IHVucGFjayRuKGFyZ3MsICdoc2knKTtcbiAgICAgICAgdmFyIGggPSBhcmdzWzBdO1xuICAgICAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBpID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHIsZyxiO1xuXG4gICAgICAgIGlmIChpc05hTihoKSkgeyBoID0gMDsgfVxuICAgICAgICBpZiAoaXNOYU4ocykpIHsgcyA9IDA7IH1cbiAgICAgICAgLy8gbm9ybWFsaXplIGh1ZVxuICAgICAgICBpZiAoaCA+IDM2MCkgeyBoIC09IDM2MDsgfVxuICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgaCAvPSAzNjA7XG4gICAgICAgIGlmIChoIDwgMS8zKSB7XG4gICAgICAgICAgICBiID0gKDEtcykvMztcbiAgICAgICAgICAgIHIgPSAoMStzKmNvcyQ0KFRXT1BJJDEqaCkvY29zJDQoUElUSElSRC1UV09QSSQxKmgpKS8zO1xuICAgICAgICAgICAgZyA9IDEgLSAoYityKTtcbiAgICAgICAgfSBlbHNlIGlmIChoIDwgMi8zKSB7XG4gICAgICAgICAgICBoIC09IDEvMztcbiAgICAgICAgICAgIHIgPSAoMS1zKS8zO1xuICAgICAgICAgICAgZyA9ICgxK3MqY29zJDQoVFdPUEkkMSpoKS9jb3MkNChQSVRISVJELVRXT1BJJDEqaCkpLzM7XG4gICAgICAgICAgICBiID0gMSAtIChyK2cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaCAtPSAyLzM7XG4gICAgICAgICAgICBnID0gKDEtcykvMztcbiAgICAgICAgICAgIGIgPSAoMStzKmNvcyQ0KFRXT1BJJDEqaCkvY29zJDQoUElUSElSRC1UV09QSSQxKmgpKS8zO1xuICAgICAgICAgICAgciA9IDEgLSAoZytiKTtcbiAgICAgICAgfVxuICAgICAgICByID0gbGltaXQoaSpyKjMpO1xuICAgICAgICBnID0gbGltaXQoaSpnKjMpO1xuICAgICAgICBiID0gbGltaXQoaSpiKjMpO1xuICAgICAgICByZXR1cm4gW3IqMjU1LCBnKjI1NSwgYioyNTUsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgICB9O1xuXG4gICAgdmFyIGhzaTJyZ2JfMSA9IGhzaTJyZ2I7XG5cbiAgICB2YXIgdW5wYWNrJG0gPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkaCA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNocm9tYSRlID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHggPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCRhID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2IyaHNpID0gcmdiMmhzaV8xO1xuXG4gICAgQ29sb3IkeC5wcm90b3R5cGUuaHNpID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IyaHNpKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSRlLmhzaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkeCwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hzaSddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkYS5mb3JtYXQuaHNpID0gaHNpMnJnYl8xO1xuXG4gICAgaW5wdXQkYS5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAyLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayRtKGFyZ3MsICdoc2knKTtcbiAgICAgICAgICAgIGlmICh0eXBlJGgoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hzaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB1bnBhY2skbCA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSRnID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2hyb21hJGQgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkdyA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JDkgPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJoc2wkMSA9IHJnYjJoc2xfMTtcblxuICAgIENvbG9yJHcucHJvdG90eXBlLmhzbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmdiMmhzbCQxKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSRkLmhzbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkdywgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hzbCddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkOS5mb3JtYXQuaHNsID0gaHNsMnJnYl8xO1xuXG4gICAgaW5wdXQkOS5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAyLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayRsKGFyZ3MsICdoc2wnKTtcbiAgICAgICAgICAgIGlmICh0eXBlJGcoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hzbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB1bnBhY2skayA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbWluJDEgPSBNYXRoLm1pbjtcbiAgICB2YXIgbWF4JDEgPSBNYXRoLm1heDtcblxuICAgIC8qXG4gICAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICAgKiAtIHJnYjJoc3YocixnLGIpXG4gICAgICogLSByZ2IyaHN2KFtyLGcsYl0pXG4gICAgICogLSByZ2IyaHN2KHtyLGcsYn0pXG4gICAgICovXG4gICAgdmFyIHJnYjJoc2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayRrKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgZyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBiID0gYXJnc1syXTtcbiAgICAgICAgdmFyIG1pbl8gPSBtaW4kMShyLCBnLCBiKTtcbiAgICAgICAgdmFyIG1heF8gPSBtYXgkMShyLCBnLCBiKTtcbiAgICAgICAgdmFyIGRlbHRhID0gbWF4XyAtIG1pbl87XG4gICAgICAgIHZhciBoLHMsdjtcbiAgICAgICAgdiA9IG1heF8gLyAyNTUuMDtcbiAgICAgICAgaWYgKG1heF8gPT09IDApIHtcbiAgICAgICAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gZGVsdGEgLyBtYXhfO1xuICAgICAgICAgICAgaWYgKHIgPT09IG1heF8pIHsgaCA9IChnIC0gYikgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaWYgKGcgPT09IG1heF8pIHsgaCA9IDIrKGIgLSByKSAvIGRlbHRhOyB9XG4gICAgICAgICAgICBpZiAoYiA9PT0gbWF4XykgeyBoID0gNCsociAtIGcpIC8gZGVsdGE7IH1cbiAgICAgICAgICAgIGggKj0gNjA7XG4gICAgICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2gsIHMsIHZdXG4gICAgfTtcblxuICAgIHZhciByZ2IyaHN2JDEgPSByZ2IyaHNsO1xuXG4gICAgdmFyIHVucGFjayRqID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBmbG9vciQyID0gTWF0aC5mbG9vcjtcblxuICAgIHZhciBoc3YycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXNzaWduLCBhc3NpZ24kMSwgYXNzaWduJDIsIGFzc2lnbiQzLCBhc3NpZ24kNCwgYXNzaWduJDU7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcbiAgICAgICAgYXJncyA9IHVucGFjayRqKGFyZ3MsICdoc3YnKTtcbiAgICAgICAgdmFyIGggPSBhcmdzWzBdO1xuICAgICAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciB2ID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHIsZyxiO1xuICAgICAgICB2ICo9IDI1NTtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIHIgPSBnID0gYiA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaCA9PT0gMzYwKSB7IGggPSAwOyB9XG4gICAgICAgICAgICBpZiAoaCA+IDM2MCkgeyBoIC09IDM2MDsgfVxuICAgICAgICAgICAgaWYgKGggPCAwKSB7IGggKz0gMzYwOyB9XG4gICAgICAgICAgICBoIC89IDYwO1xuXG4gICAgICAgICAgICB2YXIgaSA9IGZsb29yJDIoaCk7XG4gICAgICAgICAgICB2YXIgZiA9IGggLSBpO1xuICAgICAgICAgICAgdmFyIHAgPSB2ICogKDEgLSBzKTtcbiAgICAgICAgICAgIHZhciBxID0gdiAqICgxIC0gcyAqIGYpO1xuICAgICAgICAgICAgdmFyIHQgPSB2ICogKDEgLSBzICogKDEgLSBmKSk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogKGFzc2lnbiA9IFt2LCB0LCBwXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAoYXNzaWduJDEgPSBbcSwgdiwgcF0sIHIgPSBhc3NpZ24kMVswXSwgZyA9IGFzc2lnbiQxWzFdLCBiID0gYXNzaWduJDFbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgMjogKGFzc2lnbiQyID0gW3AsIHYsIHRdLCByID0gYXNzaWduJDJbMF0sIGcgPSBhc3NpZ24kMlsxXSwgYiA9IGFzc2lnbiQyWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDM6IChhc3NpZ24kMyA9IFtwLCBxLCB2XSwgciA9IGFzc2lnbiQzWzBdLCBnID0gYXNzaWduJDNbMV0sIGIgPSBhc3NpZ24kM1syXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSA0OiAoYXNzaWduJDQgPSBbdCwgcCwgdl0sIHIgPSBhc3NpZ24kNFswXSwgZyA9IGFzc2lnbiQ0WzFdLCBiID0gYXNzaWduJDRbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgNTogKGFzc2lnbiQ1ID0gW3YsIHAsIHFdLCByID0gYXNzaWduJDVbMF0sIGcgPSBhc3NpZ24kNVsxXSwgYiA9IGFzc2lnbiQ1WzJdKTsgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3IsZyxiLGFyZ3MubGVuZ3RoID4gMz9hcmdzWzNdOjFdO1xuICAgIH07XG5cbiAgICB2YXIgaHN2MnJnYl8xID0gaHN2MnJnYjtcblxuICAgIHZhciB1bnBhY2skaSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSRmID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2hyb21hJGMgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkdiA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JDggPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJoc3YgPSByZ2IyaHN2JDE7XG5cbiAgICBDb2xvciR2LnByb3RvdHlwZS5oc3YgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJoc3YodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGMuaHN2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR2LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaHN2J10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCQ4LmZvcm1hdC5oc3YgPSBoc3YycmdiXzE7XG5cbiAgICBpbnB1dCQ4LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJGkoYXJncywgJ2hzdicpO1xuICAgICAgICAgICAgaWYgKHR5cGUkZihhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaHN2JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGxhYkNvbnN0YW50cyA9IHtcbiAgICAgICAgLy8gQ29ycmVzcG9uZHMgcm91Z2hseSB0byBSR0IgYnJpZ2h0ZXIvZGFya2VyXG4gICAgICAgIEtuOiAxOCxcblxuICAgICAgICAvLyBENjUgc3RhbmRhcmQgcmVmZXJlbnRcbiAgICAgICAgWG46IDAuOTUwNDcwLFxuICAgICAgICBZbjogMSxcbiAgICAgICAgWm46IDEuMDg4ODMwLFxuXG4gICAgICAgIHQwOiAwLjEzNzkzMTAzNCwgIC8vIDQgLyAyOVxuICAgICAgICB0MTogMC4yMDY4OTY1NTIsICAvLyA2IC8gMjlcbiAgICAgICAgdDI6IDAuMTI4NDE4NTUsICAgLy8gMyAqIHQxICogdDFcbiAgICAgICAgdDM6IDAuMDA4ODU2NDUyLCAgLy8gdDEgKiB0MSAqIHQxXG4gICAgfTtcblxuICAgIHZhciBMQUJfQ09OU1RBTlRTJDMgPSBsYWJDb25zdGFudHM7XG4gICAgdmFyIHVucGFjayRoID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBwb3ckYSA9IE1hdGgucG93O1xuXG4gICAgdmFyIHJnYjJsYWIkMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJGgoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSByZ2IyeHl6KHIsZyxiKTtcbiAgICAgICAgdmFyIHggPSByZWYkMVswXTtcbiAgICAgICAgdmFyIHkgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIHogPSByZWYkMVsyXTtcbiAgICAgICAgdmFyIGwgPSAxMTYgKiB5IC0gMTY7XG4gICAgICAgIHJldHVybiBbbCA8IDAgPyAwIDogbCwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KV07XG4gICAgfTtcblxuICAgIHZhciByZ2JfeHl6ID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKChyIC89IDI1NSkgPD0gMC4wNDA0NSkgeyByZXR1cm4gciAvIDEyLjkyOyB9XG4gICAgICAgIHJldHVybiBwb3ckYSgociArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICAgIH07XG5cbiAgICB2YXIgeHl6X2xhYiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ID4gTEFCX0NPTlNUQU5UUyQzLnQzKSB7IHJldHVybiBwb3ckYSh0LCAxIC8gMyk7IH1cbiAgICAgICAgcmV0dXJuIHQgLyBMQUJfQ09OU1RBTlRTJDMudDIgKyBMQUJfQ09OU1RBTlRTJDMudDA7XG4gICAgfTtcblxuICAgIHZhciByZ2IyeHl6ID0gZnVuY3Rpb24gKHIsZyxiKSB7XG4gICAgICAgIHIgPSByZ2JfeHl6KHIpO1xuICAgICAgICBnID0gcmdiX3h5eihnKTtcbiAgICAgICAgYiA9IHJnYl94eXooYik7XG4gICAgICAgIHZhciB4ID0geHl6X2xhYigoMC40MTI0NTY0ICogciArIDAuMzU3NTc2MSAqIGcgKyAwLjE4MDQzNzUgKiBiKSAvIExBQl9DT05TVEFOVFMkMy5Ybik7XG4gICAgICAgIHZhciB5ID0geHl6X2xhYigoMC4yMTI2NzI5ICogciArIDAuNzE1MTUyMiAqIGcgKyAwLjA3MjE3NTAgKiBiKSAvIExBQl9DT05TVEFOVFMkMy5Zbik7XG4gICAgICAgIHZhciB6ID0geHl6X2xhYigoMC4wMTkzMzM5ICogciArIDAuMTE5MTkyMCAqIGcgKyAwLjk1MDMwNDEgKiBiKSAvIExBQl9DT05TVEFOVFMkMy5abik7XG4gICAgICAgIHJldHVybiBbeCx5LHpdO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmxhYl8xID0gcmdiMmxhYiQyO1xuXG4gICAgdmFyIExBQl9DT05TVEFOVFMkMiA9IGxhYkNvbnN0YW50cztcbiAgICB2YXIgdW5wYWNrJGcgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHBvdyQ5ID0gTWF0aC5wb3c7XG5cbiAgICAvKlxuICAgICAqIEwqIFswLi4xMDBdXG4gICAgICogYSBbLTEwMC4uMTAwXVxuICAgICAqIGIgWy0xMDAuLjEwMF1cbiAgICAgKi9cbiAgICB2YXIgbGFiMnJnYiQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2skZyhhcmdzLCAnbGFiJyk7XG4gICAgICAgIHZhciBsID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGEgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgYiA9IGFyZ3NbMl07XG4gICAgICAgIHZhciB4LHkseiwgcixnLGJfO1xuXG4gICAgICAgIHkgPSAobCArIDE2KSAvIDExNjtcbiAgICAgICAgeCA9IGlzTmFOKGEpID8geSA6IHkgKyBhIC8gNTAwO1xuICAgICAgICB6ID0gaXNOYU4oYikgPyB5IDogeSAtIGIgLyAyMDA7XG5cbiAgICAgICAgeSA9IExBQl9DT05TVEFOVFMkMi5ZbiAqIGxhYl94eXooeSk7XG4gICAgICAgIHggPSBMQUJfQ09OU1RBTlRTJDIuWG4gKiBsYWJfeHl6KHgpO1xuICAgICAgICB6ID0gTEFCX0NPTlNUQU5UUyQyLlpuICogbGFiX3h5eih6KTtcblxuICAgICAgICByID0geHl6X3JnYigzLjI0MDQ1NDIgKiB4IC0gMS41MzcxMzg1ICogeSAtIDAuNDk4NTMxNCAqIHopOyAgLy8gRDY1IC0+IHNSR0JcbiAgICAgICAgZyA9IHh5el9yZ2IoLTAuOTY5MjY2MCAqIHggKyAxLjg3NjAxMDggKiB5ICsgMC4wNDE1NTYwICogeik7XG4gICAgICAgIGJfID0geHl6X3JnYigwLjA1NTY0MzQgKiB4IC0gMC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopO1xuXG4gICAgICAgIHJldHVybiBbcixnLGJfLGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgICB9O1xuXG4gICAgdmFyIHh5el9yZ2IgPSBmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gMjU1ICogKHIgPD0gMC4wMDMwNCA/IDEyLjkyICogciA6IDEuMDU1ICogcG93JDkociwgMSAvIDIuNCkgLSAwLjA1NSlcbiAgICB9O1xuXG4gICAgdmFyIGxhYl94eXogPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+IExBQl9DT05TVEFOVFMkMi50MSA/IHQgKiB0ICogdCA6IExBQl9DT05TVEFOVFMkMi50MiAqICh0IC0gTEFCX0NPTlNUQU5UUyQyLnQwKVxuICAgIH07XG5cbiAgICB2YXIgbGFiMnJnYl8xID0gbGFiMnJnYiQxO1xuXG4gICAgdmFyIHVucGFjayRmID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJGUgPSB1dGlscy50eXBlO1xuICAgIHZhciBjaHJvbWEkYiA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciR1ID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkNyA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMmxhYiQxID0gcmdiMmxhYl8xO1xuXG4gICAgQ29sb3IkdS5wcm90b3R5cGUubGFiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IybGFiJDEodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGIubGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR1LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnbGFiJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCQ3LmZvcm1hdC5sYWIgPSBsYWIycmdiXzE7XG5cbiAgICBpbnB1dCQ3LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJGYoYXJncywgJ2xhYicpO1xuICAgICAgICAgICAgaWYgKHR5cGUkZShhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbGFiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayRlID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBSQUQyREVHID0gdXRpbHMuUkFEMkRFRztcbiAgICB2YXIgc3FydCQzID0gTWF0aC5zcXJ0O1xuICAgIHZhciBhdGFuMiQyID0gTWF0aC5hdGFuMjtcbiAgICB2YXIgcm91bmQkMiA9IE1hdGgucm91bmQ7XG5cbiAgICB2YXIgbGFiMmxjaCQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skZShhcmdzLCAnbGFiJyk7XG4gICAgICAgIHZhciBsID0gcmVmWzBdO1xuICAgICAgICB2YXIgYSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciBjID0gc3FydCQzKGEgKiBhICsgYiAqIGIpO1xuICAgICAgICB2YXIgaCA9IChhdGFuMiQyKGIsIGEpICogUkFEMkRFRyArIDM2MCkgJSAzNjA7XG4gICAgICAgIGlmIChyb3VuZCQyKGMqMTAwMDApID09PSAwKSB7IGggPSBOdW1iZXIuTmFOOyB9XG4gICAgICAgIHJldHVybiBbbCwgYywgaF07XG4gICAgfTtcblxuICAgIHZhciBsYWIybGNoXzEgPSBsYWIybGNoJDI7XG5cbiAgICB2YXIgdW5wYWNrJGQgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHJnYjJsYWIgPSByZ2IybGFiXzE7XG4gICAgdmFyIGxhYjJsY2gkMSA9IGxhYjJsY2hfMTtcblxuICAgIHZhciByZ2IybGNoJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayRkKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gcmdiMmxhYihyLGcsYik7XG4gICAgICAgIHZhciBsID0gcmVmJDFbMF07XG4gICAgICAgIHZhciBhID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBiXyA9IHJlZiQxWzJdO1xuICAgICAgICByZXR1cm4gbGFiMmxjaCQxKGwsYSxiXyk7XG4gICAgfTtcblxuICAgIHZhciByZ2IybGNoXzEgPSByZ2IybGNoJDE7XG5cbiAgICB2YXIgdW5wYWNrJGMgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIERFRzJSQUQgPSB1dGlscy5ERUcyUkFEO1xuICAgIHZhciBzaW4kMyA9IE1hdGguc2luO1xuICAgIHZhciBjb3MkMyA9IE1hdGguY29zO1xuXG4gICAgdmFyIGxjaDJsYWIkMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAvKlxuICAgICAgICBDb252ZXJ0IGZyb20gYSBxdWFsaXRhdGl2ZSBwYXJhbWV0ZXIgaCBhbmQgYSBxdWFudGl0YXRpdmUgcGFyYW1ldGVyIGwgdG8gYSAyNC1iaXQgcGl4ZWwuXG4gICAgICAgIFRoZXNlIGZvcm11bGFzIHdlcmUgaW52ZW50ZWQgYnkgRGF2aWQgRGFscnltcGxlIHRvIG9idGFpbiBtYXhpbXVtIGNvbnRyYXN0IHdpdGhvdXQgZ29pbmdcbiAgICAgICAgb3V0IG9mIGdhbXV0IGlmIHRoZSBwYXJhbWV0ZXJzIGFyZSBpbiB0aGUgcmFuZ2UgMC0xLlxuXG4gICAgICAgIEEgc2F0dXJhdGlvbiBtdWx0aXBsaWVyIHdhcyBhZGRlZCBieSBHcmVnb3IgQWlzY2hcbiAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayRjKGFyZ3MsICdsY2gnKTtcbiAgICAgICAgdmFyIGwgPSByZWZbMF07XG4gICAgICAgIHZhciBjID0gcmVmWzFdO1xuICAgICAgICB2YXIgaCA9IHJlZlsyXTtcbiAgICAgICAgaWYgKGlzTmFOKGgpKSB7IGggPSAwOyB9XG4gICAgICAgIGggPSBoICogREVHMlJBRDtcbiAgICAgICAgcmV0dXJuIFtsLCBjb3MkMyhoKSAqIGMsIHNpbiQzKGgpICogY11cbiAgICB9O1xuXG4gICAgdmFyIGxjaDJsYWJfMSA9IGxjaDJsYWIkMjtcblxuICAgIHZhciB1bnBhY2skYiA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbGNoMmxhYiQxID0gbGNoMmxhYl8xO1xuICAgIHZhciBsYWIycmdiID0gbGFiMnJnYl8xO1xuXG4gICAgdmFyIGxjaDJyZ2IkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJGIoYXJncywgJ2xjaCcpO1xuICAgICAgICB2YXIgbCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBjID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGggPSBhcmdzWzJdO1xuICAgICAgICB2YXIgcmVmID0gbGNoMmxhYiQxIChsLGMsaCk7XG4gICAgICAgIHZhciBMID0gcmVmWzBdO1xuICAgICAgICB2YXIgYSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGJfID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSBsYWIycmdiIChMLGEsYl8pO1xuICAgICAgICB2YXIgciA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZiQxWzJdO1xuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgICB9O1xuXG4gICAgdmFyIGxjaDJyZ2JfMSA9IGxjaDJyZ2IkMTtcblxuICAgIHZhciB1bnBhY2skYSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbGNoMnJnYiA9IGxjaDJyZ2JfMTtcblxuICAgIHZhciBoY2wycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciBoY2wgPSB1bnBhY2skYShhcmdzLCAnaGNsJykucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gbGNoMnJnYi5hcHBseSh2b2lkIDAsIGhjbCk7XG4gICAgfTtcblxuICAgIHZhciBoY2wycmdiXzEgPSBoY2wycmdiO1xuXG4gICAgdmFyIHVucGFjayQ5ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJGQgPSB1dGlscy50eXBlO1xuICAgIHZhciBjaHJvbWEkYSA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciR0ID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkNiA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMmxjaCA9IHJnYjJsY2hfMTtcblxuICAgIENvbG9yJHQucHJvdG90eXBlLmxjaCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmdiMmxjaCh0aGlzLl9yZ2IpOyB9O1xuICAgIENvbG9yJHQucHJvdG90eXBlLmhjbCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmdiMmxjaCh0aGlzLl9yZ2IpLnJldmVyc2UoKTsgfTtcblxuICAgIGNocm9tYSRhLmxjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkdCwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2xjaCddKSApKTtcbiAgICB9O1xuICAgIGNocm9tYSRhLmhjbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkdCwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hjbCddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkNi5mb3JtYXQubGNoID0gbGNoMnJnYl8xO1xuICAgIGlucHV0JDYuZm9ybWF0LmhjbCA9IGhjbDJyZ2JfMTtcblxuICAgIFsnbGNoJywnaGNsJ10uZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXR1cm4gaW5wdXQkNi5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAyLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayQ5KGFyZ3MsIG0pO1xuICAgICAgICAgICAgaWYgKHR5cGUkZChhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7IH0pO1xuXG4gICAgLyoqXG4gICAgXHRYMTEgY29sb3IgbmFtZXNcblxuICAgIFx0aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yXG4gICAgKi9cblxuICAgIHZhciB3M2N4MTEkMSA9IHtcbiAgICAgICAgYWxpY2VibHVlOiAnI2YwZjhmZicsXG4gICAgICAgIGFudGlxdWV3aGl0ZTogJyNmYWViZDcnLFxuICAgICAgICBhcXVhOiAnIzAwZmZmZicsXG4gICAgICAgIGFxdWFtYXJpbmU6ICcjN2ZmZmQ0JyxcbiAgICAgICAgYXp1cmU6ICcjZjBmZmZmJyxcbiAgICAgICAgYmVpZ2U6ICcjZjVmNWRjJyxcbiAgICAgICAgYmlzcXVlOiAnI2ZmZTRjNCcsXG4gICAgICAgIGJsYWNrOiAnIzAwMDAwMCcsXG4gICAgICAgIGJsYW5jaGVkYWxtb25kOiAnI2ZmZWJjZCcsXG4gICAgICAgIGJsdWU6ICcjMDAwMGZmJyxcbiAgICAgICAgYmx1ZXZpb2xldDogJyM4YTJiZTInLFxuICAgICAgICBicm93bjogJyNhNTJhMmEnLFxuICAgICAgICBidXJseXdvb2Q6ICcjZGViODg3JyxcbiAgICAgICAgY2FkZXRibHVlOiAnIzVmOWVhMCcsXG4gICAgICAgIGNoYXJ0cmV1c2U6ICcjN2ZmZjAwJyxcbiAgICAgICAgY2hvY29sYXRlOiAnI2QyNjkxZScsXG4gICAgICAgIGNvcmFsOiAnI2ZmN2Y1MCcsXG4gICAgICAgIGNvcm5mbG93ZXI6ICcjNjQ5NWVkJyxcbiAgICAgICAgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NWVkJyxcbiAgICAgICAgY29ybnNpbGs6ICcjZmZmOGRjJyxcbiAgICAgICAgY3JpbXNvbjogJyNkYzE0M2MnLFxuICAgICAgICBjeWFuOiAnIzAwZmZmZicsXG4gICAgICAgIGRhcmtibHVlOiAnIzAwMDA4YicsXG4gICAgICAgIGRhcmtjeWFuOiAnIzAwOGI4YicsXG4gICAgICAgIGRhcmtnb2xkZW5yb2Q6ICcjYjg4NjBiJyxcbiAgICAgICAgZGFya2dyYXk6ICcjYTlhOWE5JyxcbiAgICAgICAgZGFya2dyZWVuOiAnIzAwNjQwMCcsXG4gICAgICAgIGRhcmtncmV5OiAnI2E5YTlhOScsXG4gICAgICAgIGRhcmtraGFraTogJyNiZGI3NmInLFxuICAgICAgICBkYXJrbWFnZW50YTogJyM4YjAwOGInLFxuICAgICAgICBkYXJrb2xpdmVncmVlbjogJyM1NTZiMmYnLFxuICAgICAgICBkYXJrb3JhbmdlOiAnI2ZmOGMwMCcsXG4gICAgICAgIGRhcmtvcmNoaWQ6ICcjOTkzMmNjJyxcbiAgICAgICAgZGFya3JlZDogJyM4YjAwMDAnLFxuICAgICAgICBkYXJrc2FsbW9uOiAnI2U5OTY3YScsXG4gICAgICAgIGRhcmtzZWFncmVlbjogJyM4ZmJjOGYnLFxuICAgICAgICBkYXJrc2xhdGVibHVlOiAnIzQ4M2Q4YicsXG4gICAgICAgIGRhcmtzbGF0ZWdyYXk6ICcjMmY0ZjRmJyxcbiAgICAgICAgZGFya3NsYXRlZ3JleTogJyMyZjRmNGYnLFxuICAgICAgICBkYXJrdHVycXVvaXNlOiAnIzAwY2VkMScsXG4gICAgICAgIGRhcmt2aW9sZXQ6ICcjOTQwMGQzJyxcbiAgICAgICAgZGVlcHBpbms6ICcjZmYxNDkzJyxcbiAgICAgICAgZGVlcHNreWJsdWU6ICcjMDBiZmZmJyxcbiAgICAgICAgZGltZ3JheTogJyM2OTY5NjknLFxuICAgICAgICBkaW1ncmV5OiAnIzY5Njk2OScsXG4gICAgICAgIGRvZGdlcmJsdWU6ICcjMWU5MGZmJyxcbiAgICAgICAgZmlyZWJyaWNrOiAnI2IyMjIyMicsXG4gICAgICAgIGZsb3JhbHdoaXRlOiAnI2ZmZmFmMCcsXG4gICAgICAgIGZvcmVzdGdyZWVuOiAnIzIyOGIyMicsXG4gICAgICAgIGZ1Y2hzaWE6ICcjZmYwMGZmJyxcbiAgICAgICAgZ2FpbnNib3JvOiAnI2RjZGNkYycsXG4gICAgICAgIGdob3N0d2hpdGU6ICcjZjhmOGZmJyxcbiAgICAgICAgZ29sZDogJyNmZmQ3MDAnLFxuICAgICAgICBnb2xkZW5yb2Q6ICcjZGFhNTIwJyxcbiAgICAgICAgZ3JheTogJyM4MDgwODAnLFxuICAgICAgICBncmVlbjogJyMwMDgwMDAnLFxuICAgICAgICBncmVlbnllbGxvdzogJyNhZGZmMmYnLFxuICAgICAgICBncmV5OiAnIzgwODA4MCcsXG4gICAgICAgIGhvbmV5ZGV3OiAnI2YwZmZmMCcsXG4gICAgICAgIGhvdHBpbms6ICcjZmY2OWI0JyxcbiAgICAgICAgaW5kaWFucmVkOiAnI2NkNWM1YycsXG4gICAgICAgIGluZGlnbzogJyM0YjAwODInLFxuICAgICAgICBpdm9yeTogJyNmZmZmZjAnLFxuICAgICAgICBraGFraTogJyNmMGU2OGMnLFxuICAgICAgICBsYXNlcmxlbW9uOiAnI2ZmZmY1NCcsXG4gICAgICAgIGxhdmVuZGVyOiAnI2U2ZTZmYScsXG4gICAgICAgIGxhdmVuZGVyYmx1c2g6ICcjZmZmMGY1JyxcbiAgICAgICAgbGF3bmdyZWVuOiAnIzdjZmMwMCcsXG4gICAgICAgIGxlbW9uY2hpZmZvbjogJyNmZmZhY2QnLFxuICAgICAgICBsaWdodGJsdWU6ICcjYWRkOGU2JyxcbiAgICAgICAgbGlnaHRjb3JhbDogJyNmMDgwODAnLFxuICAgICAgICBsaWdodGN5YW46ICcjZTBmZmZmJyxcbiAgICAgICAgbGlnaHRnb2xkZW5yb2Q6ICcjZmFmYWQyJyxcbiAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjZmFmYWQyJyxcbiAgICAgICAgbGlnaHRncmF5OiAnI2QzZDNkMycsXG4gICAgICAgIGxpZ2h0Z3JlZW46ICcjOTBlZTkwJyxcbiAgICAgICAgbGlnaHRncmV5OiAnI2QzZDNkMycsXG4gICAgICAgIGxpZ2h0cGluazogJyNmZmI2YzEnLFxuICAgICAgICBsaWdodHNhbG1vbjogJyNmZmEwN2EnLFxuICAgICAgICBsaWdodHNlYWdyZWVuOiAnIzIwYjJhYScsXG4gICAgICAgIGxpZ2h0c2t5Ymx1ZTogJyM4N2NlZmEnLFxuICAgICAgICBsaWdodHNsYXRlZ3JheTogJyM3Nzg4OTknLFxuICAgICAgICBsaWdodHNsYXRlZ3JleTogJyM3Nzg4OTknLFxuICAgICAgICBsaWdodHN0ZWVsYmx1ZTogJyNiMGM0ZGUnLFxuICAgICAgICBsaWdodHllbGxvdzogJyNmZmZmZTAnLFxuICAgICAgICBsaW1lOiAnIzAwZmYwMCcsXG4gICAgICAgIGxpbWVncmVlbjogJyMzMmNkMzInLFxuICAgICAgICBsaW5lbjogJyNmYWYwZTYnLFxuICAgICAgICBtYWdlbnRhOiAnI2ZmMDBmZicsXG4gICAgICAgIG1hcm9vbjogJyM4MDAwMDAnLFxuICAgICAgICBtYXJvb24yOiAnIzdmMDAwMCcsXG4gICAgICAgIG1hcm9vbjM6ICcjYjAzMDYwJyxcbiAgICAgICAgbWVkaXVtYXF1YW1hcmluZTogJyM2NmNkYWEnLFxuICAgICAgICBtZWRpdW1ibHVlOiAnIzAwMDBjZCcsXG4gICAgICAgIG1lZGl1bW9yY2hpZDogJyNiYTU1ZDMnLFxuICAgICAgICBtZWRpdW1wdXJwbGU6ICcjOTM3MGRiJyxcbiAgICAgICAgbWVkaXVtc2VhZ3JlZW46ICcjM2NiMzcxJyxcbiAgICAgICAgbWVkaXVtc2xhdGVibHVlOiAnIzdiNjhlZScsXG4gICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnIzAwZmE5YScsXG4gICAgICAgIG1lZGl1bXR1cnF1b2lzZTogJyM0OGQxY2MnLFxuICAgICAgICBtZWRpdW12aW9sZXRyZWQ6ICcjYzcxNTg1JyxcbiAgICAgICAgbWlkbmlnaHRibHVlOiAnIzE5MTk3MCcsXG4gICAgICAgIG1pbnRjcmVhbTogJyNmNWZmZmEnLFxuICAgICAgICBtaXN0eXJvc2U6ICcjZmZlNGUxJyxcbiAgICAgICAgbW9jY2FzaW46ICcjZmZlNGI1JyxcbiAgICAgICAgbmF2YWpvd2hpdGU6ICcjZmZkZWFkJyxcbiAgICAgICAgbmF2eTogJyMwMDAwODAnLFxuICAgICAgICBvbGRsYWNlOiAnI2ZkZjVlNicsXG4gICAgICAgIG9saXZlOiAnIzgwODAwMCcsXG4gICAgICAgIG9saXZlZHJhYjogJyM2YjhlMjMnLFxuICAgICAgICBvcmFuZ2U6ICcjZmZhNTAwJyxcbiAgICAgICAgb3JhbmdlcmVkOiAnI2ZmNDUwMCcsXG4gICAgICAgIG9yY2hpZDogJyNkYTcwZDYnLFxuICAgICAgICBwYWxlZ29sZGVucm9kOiAnI2VlZThhYScsXG4gICAgICAgIHBhbGVncmVlbjogJyM5OGZiOTgnLFxuICAgICAgICBwYWxldHVycXVvaXNlOiAnI2FmZWVlZScsXG4gICAgICAgIHBhbGV2aW9sZXRyZWQ6ICcjZGI3MDkzJyxcbiAgICAgICAgcGFwYXlhd2hpcDogJyNmZmVmZDUnLFxuICAgICAgICBwZWFjaHB1ZmY6ICcjZmZkYWI5JyxcbiAgICAgICAgcGVydTogJyNjZDg1M2YnLFxuICAgICAgICBwaW5rOiAnI2ZmYzBjYicsXG4gICAgICAgIHBsdW06ICcjZGRhMGRkJyxcbiAgICAgICAgcG93ZGVyYmx1ZTogJyNiMGUwZTYnLFxuICAgICAgICBwdXJwbGU6ICcjODAwMDgwJyxcbiAgICAgICAgcHVycGxlMjogJyM3ZjAwN2YnLFxuICAgICAgICBwdXJwbGUzOiAnI2EwMjBmMCcsXG4gICAgICAgIHJlYmVjY2FwdXJwbGU6ICcjNjYzMzk5JyxcbiAgICAgICAgcmVkOiAnI2ZmMDAwMCcsXG4gICAgICAgIHJvc3licm93bjogJyNiYzhmOGYnLFxuICAgICAgICByb3lhbGJsdWU6ICcjNDE2OWUxJyxcbiAgICAgICAgc2FkZGxlYnJvd246ICcjOGI0NTEzJyxcbiAgICAgICAgc2FsbW9uOiAnI2ZhODA3MicsXG4gICAgICAgIHNhbmR5YnJvd246ICcjZjRhNDYwJyxcbiAgICAgICAgc2VhZ3JlZW46ICcjMmU4YjU3JyxcbiAgICAgICAgc2Vhc2hlbGw6ICcjZmZmNWVlJyxcbiAgICAgICAgc2llbm5hOiAnI2EwNTIyZCcsXG4gICAgICAgIHNpbHZlcjogJyNjMGMwYzAnLFxuICAgICAgICBza3libHVlOiAnIzg3Y2VlYicsXG4gICAgICAgIHNsYXRlYmx1ZTogJyM2YTVhY2QnLFxuICAgICAgICBzbGF0ZWdyYXk6ICcjNzA4MDkwJyxcbiAgICAgICAgc2xhdGVncmV5OiAnIzcwODA5MCcsXG4gICAgICAgIHNub3c6ICcjZmZmYWZhJyxcbiAgICAgICAgc3ByaW5nZ3JlZW46ICcjMDBmZjdmJyxcbiAgICAgICAgc3RlZWxibHVlOiAnIzQ2ODJiNCcsXG4gICAgICAgIHRhbjogJyNkMmI0OGMnLFxuICAgICAgICB0ZWFsOiAnIzAwODA4MCcsXG4gICAgICAgIHRoaXN0bGU6ICcjZDhiZmQ4JyxcbiAgICAgICAgdG9tYXRvOiAnI2ZmNjM0NycsXG4gICAgICAgIHR1cnF1b2lzZTogJyM0MGUwZDAnLFxuICAgICAgICB2aW9sZXQ6ICcjZWU4MmVlJyxcbiAgICAgICAgd2hlYXQ6ICcjZjVkZWIzJyxcbiAgICAgICAgd2hpdGU6ICcjZmZmZmZmJyxcbiAgICAgICAgd2hpdGVzbW9rZTogJyNmNWY1ZjUnLFxuICAgICAgICB5ZWxsb3c6ICcjZmZmZjAwJyxcbiAgICAgICAgeWVsbG93Z3JlZW46ICcjOWFjZDMyJ1xuICAgIH07XG5cbiAgICB2YXIgdzNjeDExXzEgPSB3M2N4MTEkMTtcblxuICAgIHZhciBDb2xvciRzID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkNSA9IGlucHV0JGg7XG4gICAgdmFyIHR5cGUkYyA9IHV0aWxzLnR5cGU7XG5cbiAgICB2YXIgdzNjeDExID0gdzNjeDExXzE7XG4gICAgdmFyIGhleDJyZ2IgPSBoZXgycmdiXzE7XG4gICAgdmFyIHJnYjJoZXggPSByZ2IyaGV4XzE7XG5cbiAgICBDb2xvciRzLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZXggPSByZ2IyaGV4KHRoaXMuX3JnYiwgJ3JnYicpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IE9iamVjdC5rZXlzKHczY3gxMSk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGxpc3RbaV07XG5cbiAgICAgICAgICAgIGlmICh3M2N4MTFbbl0gPT09IGhleCkgeyByZXR1cm4gbi50b0xvd2VyQ2FzZSgpOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleDtcbiAgICB9O1xuXG4gICAgaW5wdXQkNS5mb3JtYXQubmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodzNjeDExW25hbWVdKSB7IHJldHVybiBoZXgycmdiKHczY3gxMVtuYW1lXSk7IH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbG9yIG5hbWU6ICcrbmFtZSk7XG4gICAgfTtcblxuICAgIGlucHV0JDUuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogNSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSByZXN0WyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3QubGVuZ3RoICYmIHR5cGUkYyhoKSA9PT0gJ3N0cmluZycgJiYgdzNjeDExW2gudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25hbWVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayQ4ID0gdXRpbHMudW5wYWNrO1xuXG4gICAgdmFyIHJnYjJudW0kMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJDgoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICByZXR1cm4gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMm51bV8xID0gcmdiMm51bSQxO1xuXG4gICAgdmFyIHR5cGUkYiA9IHV0aWxzLnR5cGU7XG5cbiAgICB2YXIgbnVtMnJnYiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgaWYgKHR5cGUkYihudW0pID09IFwibnVtYmVyXCIgJiYgbnVtID49IDAgJiYgbnVtIDw9IDB4RkZGRkZGKSB7XG4gICAgICAgICAgICB2YXIgciA9IG51bSA+PiAxNjtcbiAgICAgICAgICAgIHZhciBnID0gKG51bSA+PiA4KSAmIDB4RkY7XG4gICAgICAgICAgICB2YXIgYiA9IG51bSAmIDB4RkY7XG4gICAgICAgICAgICByZXR1cm4gW3IsZyxiLDFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gbnVtIGNvbG9yOiBcIitudW0pO1xuICAgIH07XG5cbiAgICB2YXIgbnVtMnJnYl8xID0gbnVtMnJnYjtcblxuICAgIHZhciBjaHJvbWEkOSA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciRyID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkNCA9IGlucHV0JGg7XG4gICAgdmFyIHR5cGUkYSA9IHV0aWxzLnR5cGU7XG5cbiAgICB2YXIgcmdiMm51bSA9IHJnYjJudW1fMTtcblxuICAgIENvbG9yJHIucHJvdG90eXBlLm51bSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmdiMm51bSh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkOS5udW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHIsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydudW0nXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JDQuZm9ybWF0Lm51bSA9IG51bTJyZ2JfMTtcblxuICAgIGlucHV0JDQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogNSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlJGEoYXJnc1swXSkgPT09ICdudW1iZXInICYmIGFyZ3NbMF0gPj0gMCAmJiBhcmdzWzBdIDw9IDB4RkZGRkZGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgY2hyb21hJDggPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkcSA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JDMgPSBpbnB1dCRoO1xuICAgIHZhciB1bnBhY2skNyA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSQ5ID0gdXRpbHMudHlwZTtcbiAgICB2YXIgcm91bmQkMSA9IE1hdGgucm91bmQ7XG5cbiAgICBDb2xvciRxLnByb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbihybmQpIHtcbiAgICAgICAgaWYgKCBybmQgPT09IHZvaWQgMCApIHJuZD10cnVlO1xuXG4gICAgICAgIGlmIChybmQgPT09IGZhbHNlKSB7IHJldHVybiB0aGlzLl9yZ2Iuc2xpY2UoMCwzKTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsMykubWFwKHJvdW5kJDEpO1xuICAgIH07XG5cbiAgICBDb2xvciRxLnByb3RvdHlwZS5yZ2JhID0gZnVuY3Rpb24ocm5kKSB7XG4gICAgICAgIGlmICggcm5kID09PSB2b2lkIDAgKSBybmQ9dHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsNCkubWFwKGZ1bmN0aW9uICh2LGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpPDMgPyAocm5kID09PSBmYWxzZSA/IHYgOiByb3VuZCQxKHYpKSA6IHY7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjaHJvbWEkOC5yZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHEsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydyZ2InXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JDMuZm9ybWF0LnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmdiYSA9IHVucGFjayQ3KGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgIGlmIChyZ2JhWzNdID09PSB1bmRlZmluZWQpIHsgcmdiYVszXSA9IDE7IH1cbiAgICAgICAgcmV0dXJuIHJnYmE7XG4gICAgfTtcblxuICAgIGlucHV0JDMuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMyxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skNyhhcmdzLCAncmdiYScpO1xuICAgICAgICAgICAgaWYgKHR5cGUkOShhcmdzKSA9PT0gJ2FycmF5JyAmJiAoYXJncy5sZW5ndGggPT09IDMgfHxcbiAgICAgICAgICAgICAgICBhcmdzLmxlbmd0aCA9PT0gNCAmJiB0eXBlJDkoYXJnc1szXSkgPT0gJ251bWJlcicgJiYgYXJnc1szXSA+PSAwICYmIGFyZ3NbM10gPD0gMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogQmFzZWQgb24gaW1wbGVtZW50YXRpb24gYnkgTmVpbCBCYXJ0bGV0dFxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAgICAgKi9cblxuICAgIHZhciBsb2ckMSA9IE1hdGgubG9nO1xuXG4gICAgdmFyIHRlbXBlcmF0dXJlMnJnYiQxID0gZnVuY3Rpb24gKGtlbHZpbikge1xuICAgICAgICB2YXIgdGVtcCA9IGtlbHZpbiAvIDEwMDtcbiAgICAgICAgdmFyIHIsZyxiO1xuICAgICAgICBpZiAodGVtcCA8IDY2KSB7XG4gICAgICAgICAgICByID0gMjU1O1xuICAgICAgICAgICAgZyA9IHRlbXAgPCA2ID8gMCA6IC0xNTUuMjU0ODU1NjI3MDkxNzkgLSAwLjQ0NTk2OTUwNDY5NTc5MTMzICogKGcgPSB0ZW1wLTIpICsgMTA0LjQ5MjE2MTk5MzkzODg4ICogbG9nJDEoZyk7XG4gICAgICAgICAgICBiID0gdGVtcCA8IDIwID8gMCA6IC0yNTQuNzY5MzUxODQxMjA5MDIgKyAwLjgyNzQwOTYwNjQwMDczOTUgKiAoYiA9IHRlbXAtMTApICsgMTE1LjY3OTk0NDAxMDY2MTQ3ICogbG9nJDEoYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByID0gMzUxLjk3NjkwNTY2ODA1NjkzICsgMC4xMTQyMDY0NTM3ODQxNjUgKiAociA9IHRlbXAtNTUpIC0gNDAuMjUzNjYzMDkzMzIxMjcgKiBsb2ckMShyKTtcbiAgICAgICAgICAgIGcgPSAzMjUuNDQ5NDEyNTcxMTk3NCArIDAuMDc5NDM0NTY1MzY2NjIzNDIgKiAoZyA9IHRlbXAtNTApIC0gMjguMDg1Mjk2MzUwNzk1NyAqIGxvZyQxKGcpO1xuICAgICAgICAgICAgYiA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3IsZyxiLDFdO1xuICAgIH07XG5cbiAgICB2YXIgdGVtcGVyYXR1cmUycmdiXzEgPSB0ZW1wZXJhdHVyZTJyZ2IkMTtcblxuICAgIC8qXG4gICAgICogQmFzZWQgb24gaW1wbGVtZW50YXRpb24gYnkgTmVpbCBCYXJ0bGV0dFxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAgICAgKiovXG5cbiAgICB2YXIgdGVtcGVyYXR1cmUycmdiID0gdGVtcGVyYXR1cmUycmdiXzE7XG4gICAgdmFyIHVucGFjayQ2ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5cbiAgICB2YXIgcmdiMnRlbXBlcmF0dXJlJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJnYiA9IHVucGFjayQ2KGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZ2JbMF0sIGIgPSByZ2JbMl07XG4gICAgICAgIHZhciBtaW5UZW1wID0gMTAwMDtcbiAgICAgICAgdmFyIG1heFRlbXAgPSA0MDAwMDtcbiAgICAgICAgdmFyIGVwcyA9IDAuNDtcbiAgICAgICAgdmFyIHRlbXA7XG4gICAgICAgIHdoaWxlIChtYXhUZW1wIC0gbWluVGVtcCA+IGVwcykge1xuICAgICAgICAgICAgdGVtcCA9IChtYXhUZW1wICsgbWluVGVtcCkgKiAwLjU7XG4gICAgICAgICAgICB2YXIgcmdiJDEgPSB0ZW1wZXJhdHVyZTJyZ2IodGVtcCk7XG4gICAgICAgICAgICBpZiAoKHJnYiQxWzJdIC8gcmdiJDFbMF0pID49IChiIC8gcikpIHtcbiAgICAgICAgICAgICAgICBtYXhUZW1wID0gdGVtcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluVGVtcCA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdW5kKHRlbXApO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMnRlbXBlcmF0dXJlXzEgPSByZ2IydGVtcGVyYXR1cmUkMTtcblxuICAgIHZhciBjaHJvbWEkNyA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciRwID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkMiA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMnRlbXBlcmF0dXJlID0gcmdiMnRlbXBlcmF0dXJlXzE7XG5cbiAgICBDb2xvciRwLnByb3RvdHlwZS50ZW1wID1cbiAgICBDb2xvciRwLnByb3RvdHlwZS5rZWx2aW4gPVxuICAgIENvbG9yJHAucHJvdG90eXBlLnRlbXBlcmF0dXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IydGVtcGVyYXR1cmUodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJDcudGVtcCA9XG4gICAgY2hyb21hJDcua2VsdmluID1cbiAgICBjaHJvbWEkNy50ZW1wZXJhdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkcCwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ3RlbXAnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JDIuZm9ybWF0LnRlbXAgPVxuICAgIGlucHV0JDIuZm9ybWF0LmtlbHZpbiA9XG4gICAgaW5wdXQkMi5mb3JtYXQudGVtcGVyYXR1cmUgPSB0ZW1wZXJhdHVyZTJyZ2JfMTtcblxuICAgIHZhciB1bnBhY2skNSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgY2JydCA9IE1hdGguY2JydDtcbiAgICB2YXIgcG93JDggPSBNYXRoLnBvdztcbiAgICB2YXIgc2lnbiQxID0gTWF0aC5zaWduO1xuXG4gICAgdmFyIHJnYjJva2xhYiQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIC8vIE9LTGFiIGNvbG9yIHNwYWNlIGltcGxlbWVudGF0aW9uIHRha2VuIGZyb21cbiAgICAgICAgLy8gaHR0cHM6Ly9ib3R0b3Nzb24uZ2l0aHViLmlvL3Bvc3RzL29rbGFiL1xuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJDUoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSBbcmdiMmxyZ2IociAvIDI1NSksIHJnYjJscmdiKGcgLyAyNTUpLCByZ2IybHJnYihiIC8gMjU1KV07XG4gICAgICAgIHZhciBsciA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgbGcgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGxiID0gcmVmJDFbMl07XG4gICAgICAgIHZhciBsID0gY2JydCgwLjQxMjIyMTQ3MDggKiBsciArIDAuNTM2MzMyNTM2MyAqIGxnICsgMC4wNTE0NDU5OTI5ICogbGIpO1xuICAgICAgICB2YXIgbSA9IGNicnQoMC4yMTE5MDM0OTgyICogbHIgKyAwLjY4MDY5OTU0NTEgKiBsZyArIDAuMTA3Mzk2OTU2NiAqIGxiKTtcbiAgICAgICAgdmFyIHMgPSBjYnJ0KDAuMDg4MzAyNDYxOSAqIGxyICsgMC4yODE3MTg4Mzc2ICogbGcgKyAwLjYyOTk3ODcwMDUgKiBsYik7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDAuMjEwNDU0MjU1MyAqIGwgKyAwLjc5MzYxNzc4NSAqIG0gLSAwLjAwNDA3MjA0NjggKiBzLFxuICAgICAgICAgICAgMS45Nzc5OTg0OTUxICogbCAtIDIuNDI4NTkyMjA1ICogbSArIDAuNDUwNTkzNzA5OSAqIHMsXG4gICAgICAgICAgICAwLjAyNTkwNDAzNzEgKiBsICsgMC43ODI3NzE3NjYyICogbSAtIDAuODA4Njc1NzY2ICogc1xuICAgICAgICBdO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMm9rbGFiXzEgPSByZ2Iyb2tsYWIkMjtcblxuICAgIGZ1bmN0aW9uIHJnYjJscmdiKGMpIHtcbiAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKGMpO1xuICAgICAgICBpZiAoYWJzIDwgMC4wNDA0NSkge1xuICAgICAgICAgICAgcmV0dXJuIGMgLyAxMi45MjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHNpZ24kMShjKSB8fCAxKSAqIHBvdyQ4KChhYnMgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgICB9XG5cbiAgICB2YXIgdW5wYWNrJDQgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHBvdyQ3ID0gTWF0aC5wb3c7XG4gICAgdmFyIHNpZ24gPSBNYXRoLnNpZ247XG5cbiAgICAvKlxuICAgICAqIEwqIFswLi4xMDBdXG4gICAgICogYSBbLTEwMC4uMTAwXVxuICAgICAqIGIgWy0xMDAuLjEwMF1cbiAgICAgKi9cbiAgICB2YXIgb2tsYWIycmdiJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayQ0KGFyZ3MsICdsYWInKTtcbiAgICAgICAgdmFyIEwgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYSA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBiID0gYXJnc1syXTtcblxuICAgICAgICB2YXIgbCA9IHBvdyQ3KEwgKyAwLjM5NjMzNzc3NzQgKiBhICsgMC4yMTU4MDM3NTczICogYiwgMyk7XG4gICAgICAgIHZhciBtID0gcG93JDcoTCAtIDAuMTA1NTYxMzQ1OCAqIGEgLSAwLjA2Mzg1NDE3MjggKiBiLCAzKTtcbiAgICAgICAgdmFyIHMgPSBwb3ckNyhMIC0gMC4wODk0ODQxNzc1ICogYSAtIDEuMjkxNDg1NTQ4ICogYiwgMyk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDI1NSAqIGxyZ2IycmdiKCs0LjA3Njc0MTY2MjEgKiBsIC0gMy4zMDc3MTE1OTEzICogbSArIDAuMjMwOTY5OTI5MiAqIHMpLFxuICAgICAgICAgICAgMjU1ICogbHJnYjJyZ2IoLTEuMjY4NDM4MDA0NiAqIGwgKyAyLjYwOTc1NzQwMTEgKiBtIC0gMC4zNDEzMTkzOTY1ICogcyksXG4gICAgICAgICAgICAyNTUgKiBscmdiMnJnYigtMC4wMDQxOTYwODYzICogbCAtIDAuNzAzNDE4NjE0NyAqIG0gKyAxLjcwNzYxNDcwMSAqIHMpLFxuICAgICAgICAgICAgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFcbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgdmFyIG9rbGFiMnJnYl8xID0gb2tsYWIycmdiJDE7XG5cbiAgICBmdW5jdGlvbiBscmdiMnJnYihjKSB7XG4gICAgICAgIHZhciBhYnMgPSBNYXRoLmFicyhjKTtcbiAgICAgICAgaWYgKGFicyA+IDAuMDAzMTMwOCkge1xuICAgICAgICAgICAgcmV0dXJuIChzaWduKGMpIHx8IDEpICogKDEuMDU1ICogcG93JDcoYWJzLCAxIC8gMi40KSAtIDAuMDU1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYyAqIDEyLjkyO1xuICAgIH1cblxuICAgIHZhciB1bnBhY2skMyA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSQ4ID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2hyb21hJDYgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkbyA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JDEgPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJva2xhYiQxID0gcmdiMm9rbGFiXzE7XG5cbiAgICBDb2xvciRvLnByb3RvdHlwZS5va2xhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJva2xhYiQxKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSQ2Lm9rbGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRvLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnb2tsYWInXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JDEuZm9ybWF0Lm9rbGFiID0gb2tsYWIycmdiXzE7XG5cbiAgICBpbnB1dCQxLmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDMsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJDMoYXJncywgJ29rbGFiJyk7XG4gICAgICAgICAgICBpZiAodHlwZSQ4KGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdva2xhYic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB1bnBhY2skMiA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgcmdiMm9rbGFiID0gcmdiMm9rbGFiXzE7XG4gICAgdmFyIGxhYjJsY2ggPSBsYWIybGNoXzE7XG5cbiAgICB2YXIgcmdiMm9rbGNoJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayQyKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gcmdiMm9rbGFiKHIsIGcsIGIpO1xuICAgICAgICB2YXIgbCA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgYSA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgYl8gPSByZWYkMVsyXTtcbiAgICAgICAgcmV0dXJuIGxhYjJsY2gobCwgYSwgYl8pO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMm9rbGNoXzEgPSByZ2Iyb2tsY2gkMTtcblxuICAgIHZhciB1bnBhY2skMSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbGNoMmxhYiA9IGxjaDJsYWJfMTtcbiAgICB2YXIgb2tsYWIycmdiID0gb2tsYWIycmdiXzE7XG5cbiAgICB2YXIgb2tsY2gycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2skMShhcmdzLCAnbGNoJyk7XG4gICAgICAgIHZhciBsID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByZWYgPSBsY2gybGFiKGwsIGMsIGgpO1xuICAgICAgICB2YXIgTCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGEgPSByZWZbMV07XG4gICAgICAgIHZhciBiXyA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gb2tsYWIycmdiKEwsIGEsIGJfKTtcbiAgICAgICAgdmFyIHIgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGcgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGIgPSByZWYkMVsyXTtcbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG4gICAgfTtcblxuICAgIHZhciBva2xjaDJyZ2JfMSA9IG9rbGNoMnJnYjtcblxuICAgIHZhciB1bnBhY2sgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkNyA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNocm9tYSQ1ID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJG4gPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMm9rbGNoID0gcmdiMm9rbGNoXzE7XG5cbiAgICBDb2xvciRuLnByb3RvdHlwZS5va2xjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJva2xjaCh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkNS5va2xjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkbiwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ29rbGNoJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dC5mb3JtYXQub2tsY2ggPSBva2xjaDJyZ2JfMTtcblxuICAgIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDMsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdva2xjaCcpO1xuICAgICAgICAgICAgaWYgKHR5cGUkNyhhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnb2tsY2gnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgQ29sb3IkbSA9IENvbG9yXzE7XG4gICAgdmFyIHR5cGUkNiA9IHV0aWxzLnR5cGU7XG5cbiAgICBDb2xvciRtLnByb3RvdHlwZS5hbHBoYSA9IGZ1bmN0aW9uKGEsIG11dGF0ZSkge1xuICAgICAgICBpZiAoIG11dGF0ZSA9PT0gdm9pZCAwICkgbXV0YXRlPWZhbHNlO1xuXG4gICAgICAgIGlmIChhICE9PSB1bmRlZmluZWQgJiYgdHlwZSQ2KGEpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKG11dGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JnYlszXSA9IGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yJG0oW3RoaXMuX3JnYlswXSwgdGhpcy5fcmdiWzFdLCB0aGlzLl9yZ2JbMl0sIGFdLCAncmdiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JnYlszXTtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJGwgPSBDb2xvcl8xO1xuXG4gICAgQ29sb3IkbC5wcm90b3R5cGUuY2xpcHBlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmdiLl9jbGlwcGVkIHx8IGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkayA9IENvbG9yXzE7XG4gICAgdmFyIExBQl9DT05TVEFOVFMkMSA9IGxhYkNvbnN0YW50cztcblxuICAgIENvbG9yJGsucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIFx0aWYgKCBhbW91bnQgPT09IHZvaWQgMCApIGFtb3VudD0xO1xuXG4gICAgXHR2YXIgbWUgPSB0aGlzO1xuICAgIFx0dmFyIGxhYiA9IG1lLmxhYigpO1xuICAgIFx0bGFiWzBdIC09IExBQl9DT05TVEFOVFMkMS5LbiAqIGFtb3VudDtcbiAgICBcdHJldHVybiBuZXcgQ29sb3IkayhsYWIsICdsYWInKS5hbHBoYShtZS5hbHBoYSgpLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgQ29sb3Ikay5wcm90b3R5cGUuYnJpZ2h0ZW4gPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgICBcdGlmICggYW1vdW50ID09PSB2b2lkIDAgKSBhbW91bnQ9MTtcblxuICAgIFx0cmV0dXJuIHRoaXMuZGFya2VuKC1hbW91bnQpO1xuICAgIH07XG5cbiAgICBDb2xvciRrLnByb3RvdHlwZS5kYXJrZXIgPSBDb2xvciRrLnByb3RvdHlwZS5kYXJrZW47XG4gICAgQ29sb3Ikay5wcm90b3R5cGUuYnJpZ2h0ZXIgPSBDb2xvciRrLnByb3RvdHlwZS5icmlnaHRlbjtcblxuICAgIHZhciBDb2xvciRqID0gQ29sb3JfMTtcblxuICAgIENvbG9yJGoucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChtYykge1xuICAgICAgICB2YXIgcmVmID0gbWMuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIG1vZGUgPSByZWZbMF07XG4gICAgICAgIHZhciBjaGFubmVsID0gcmVmWzFdO1xuICAgICAgICB2YXIgc3JjID0gdGhpc1ttb2RlXSgpO1xuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgdmFyIGkgPSBtb2RlLmluZGV4T2YoY2hhbm5lbCkgLSAobW9kZS5zdWJzdHIoMCwgMikgPT09ICdvaycgPyAyIDogMCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7IHJldHVybiBzcmNbaV07IH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJ1bmtub3duIGNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgaW4gbW9kZSBcIiArIG1vZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJGkgPSBDb2xvcl8xO1xuICAgIHZhciB0eXBlJDUgPSB1dGlscy50eXBlO1xuICAgIHZhciBwb3ckNiA9IE1hdGgucG93O1xuXG4gICAgdmFyIEVQUyA9IDFlLTc7XG4gICAgdmFyIE1BWF9JVEVSID0gMjA7XG5cbiAgICBDb2xvciRpLnByb3RvdHlwZS5sdW1pbmFuY2UgPSBmdW5jdGlvbihsdW0pIHtcbiAgICAgICAgaWYgKGx1bSAhPT0gdW5kZWZpbmVkICYmIHR5cGUkNShsdW0pID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKGx1bSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBwdXJlIGJsYWNrXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciRpKFswLDAsMCx0aGlzLl9yZ2JbM11dLCAncmdiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobHVtID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHB1cmUgd2hpdGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yJGkoWzI1NSwyNTUsMjU1LHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgbmV3IGNvbG9yIHVzaW5nLi4uXG4gICAgICAgICAgICB2YXIgY3VyX2x1bSA9IHRoaXMubHVtaW5hbmNlKCk7XG4gICAgICAgICAgICB2YXIgbW9kZSA9ICdyZ2InO1xuICAgICAgICAgICAgdmFyIG1heF9pdGVyID0gTUFYX0lURVI7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xuICAgICAgICAgICAgICAgIHZhciBtaWQgPSBsb3cuaW50ZXJwb2xhdGUoaGlnaCwgMC41LCBtb2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgbG0gPSBtaWQubHVtaW5hbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGx1bSAtIGxtKSA8IEVQUyB8fCAhbWF4X2l0ZXItLSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSBlbm91Z2hcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxtID4gbHVtID8gdGVzdChsb3csIG1pZCkgOiB0ZXN0KG1pZCwgaGlnaCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcmdiID0gKGN1cl9sdW0gPiBsdW0gPyB0ZXN0KG5ldyBDb2xvciRpKFswLDAsMF0pLCB0aGlzKSA6IHRlc3QodGhpcywgbmV3IENvbG9yJGkoWzI1NSwyNTUsMjU1XSkpKS5yZ2IoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkaShyZ2IuY29uY2F0KCBbdGhpcy5fcmdiWzNdXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZ2IybHVtaW5hbmNlLmFwcGx5KHZvaWQgMCwgKHRoaXMuX3JnYikuc2xpY2UoMCwzKSk7XG4gICAgfTtcblxuXG4gICAgdmFyIHJnYjJsdW1pbmFuY2UgPSBmdW5jdGlvbiAocixnLGIpIHtcbiAgICAgICAgLy8gcmVsYXRpdmUgbHVtaW5hbmNlXG4gICAgICAgIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG4gICAgICAgIHIgPSBsdW1pbmFuY2VfeChyKTtcbiAgICAgICAgZyA9IGx1bWluYW5jZV94KGcpO1xuICAgICAgICBiID0gbHVtaW5hbmNlX3goYik7XG4gICAgICAgIHJldHVybiAwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGI7XG4gICAgfTtcblxuICAgIHZhciBsdW1pbmFuY2VfeCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHggLz0gMjU1O1xuICAgICAgICByZXR1cm4geCA8PSAwLjAzOTI4ID8geC8xMi45MiA6IHBvdyQ2KCh4KzAuMDU1KS8xLjA1NSwgMi40KTtcbiAgICB9O1xuXG4gICAgdmFyIGludGVycG9sYXRvciQxID0ge307XG5cbiAgICB2YXIgQ29sb3IkaCA9IENvbG9yXzE7XG4gICAgdmFyIHR5cGUkNCA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGludGVycG9sYXRvciA9IGludGVycG9sYXRvciQxO1xuXG4gICAgdmFyIG1peCQxID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgaWYgKCBmID09PSB2b2lkIDAgKSBmPTAuNTtcbiAgICAgICAgdmFyIHJlc3QgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDM7XG4gICAgICAgIHdoaWxlICggbGVuLS0gPiAwICkgcmVzdFsgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDMgXTtcblxuICAgICAgICB2YXIgbW9kZSA9IHJlc3RbMF0gfHwgJ2xyZ2InO1xuICAgICAgICBpZiAoIWludGVycG9sYXRvclttb2RlXSAmJiAhcmVzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZmlyc3Qgc3VwcG9ydGVkIG1vZGVcbiAgICAgICAgICAgIG1vZGUgPSBPYmplY3Qua2V5cyhpbnRlcnBvbGF0b3IpWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW50ZXJwb2xhdG9yW21vZGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiaW50ZXJwb2xhdGlvbiBtb2RlIFwiICsgbW9kZSArIFwiIGlzIG5vdCBkZWZpbmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSQ0KGNvbDEpICE9PSAnb2JqZWN0JykgeyBjb2wxID0gbmV3IENvbG9yJGgoY29sMSk7IH1cbiAgICAgICAgaWYgKHR5cGUkNChjb2wyKSAhPT0gJ29iamVjdCcpIHsgY29sMiA9IG5ldyBDb2xvciRoKGNvbDIpOyB9XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0b3JbbW9kZV0oY29sMSwgY29sMiwgZilcbiAgICAgICAgICAgIC5hbHBoYShjb2wxLmFscGhhKCkgKyBmICogKGNvbDIuYWxwaGEoKSAtIGNvbDEuYWxwaGEoKSkpO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkZyA9IENvbG9yXzE7XG4gICAgdmFyIG1peCA9IG1peCQxO1xuXG4gICAgQ29sb3IkZy5wcm90b3R5cGUubWl4ID1cbiAgICBDb2xvciRnLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKGNvbDIsIGYpIHtcbiAgICBcdGlmICggZiA9PT0gdm9pZCAwICkgZj0wLjU7XG4gICAgXHR2YXIgcmVzdCA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBcdHdoaWxlICggbGVuLS0gPiAwICkgcmVzdFsgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICAgIFx0cmV0dXJuIG1peC5hcHBseSh2b2lkIDAsIFsgdGhpcywgY29sMiwgZiBdLmNvbmNhdCggcmVzdCApKTtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJGYgPSBDb2xvcl8xO1xuXG4gICAgQ29sb3IkZi5wcm90b3R5cGUucHJlbXVsdGlwbHkgPSBmdW5jdGlvbihtdXRhdGUpIHtcbiAgICBcdGlmICggbXV0YXRlID09PSB2b2lkIDAgKSBtdXRhdGU9ZmFsc2U7XG5cbiAgICBcdHZhciByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgXHR2YXIgYSA9IHJnYlszXTtcbiAgICBcdGlmIChtdXRhdGUpIHtcbiAgICBcdFx0dGhpcy5fcmdiID0gW3JnYlswXSphLCByZ2JbMV0qYSwgcmdiWzJdKmEsIGFdO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcbiAgICBcdH0gZWxzZSB7XG4gICAgXHRcdHJldHVybiBuZXcgQ29sb3IkZihbcmdiWzBdKmEsIHJnYlsxXSphLCByZ2JbMl0qYSwgYV0sICdyZ2InKTtcbiAgICBcdH1cbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJGUgPSBDb2xvcl8xO1xuICAgIHZhciBMQUJfQ09OU1RBTlRTID0gbGFiQ29uc3RhbnRzO1xuXG4gICAgQ29sb3IkZS5wcm90b3R5cGUuc2F0dXJhdGUgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgICBcdGlmICggYW1vdW50ID09PSB2b2lkIDAgKSBhbW91bnQ9MTtcblxuICAgIFx0dmFyIG1lID0gdGhpcztcbiAgICBcdHZhciBsY2ggPSBtZS5sY2goKTtcbiAgICBcdGxjaFsxXSArPSBMQUJfQ09OU1RBTlRTLktuICogYW1vdW50O1xuICAgIFx0aWYgKGxjaFsxXSA8IDApIHsgbGNoWzFdID0gMDsgfVxuICAgIFx0cmV0dXJuIG5ldyBDb2xvciRlKGxjaCwgJ2xjaCcpLmFscGhhKG1lLmFscGhhKCksIHRydWUpO1xuICAgIH07XG5cbiAgICBDb2xvciRlLnByb3RvdHlwZS5kZXNhdHVyYXRlID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgXHRpZiAoIGFtb3VudCA9PT0gdm9pZCAwICkgYW1vdW50PTE7XG5cbiAgICBcdHJldHVybiB0aGlzLnNhdHVyYXRlKC1hbW91bnQpO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkZCA9IENvbG9yXzE7XG4gICAgdmFyIHR5cGUkMyA9IHV0aWxzLnR5cGU7XG5cbiAgICBDb2xvciRkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobWMsIHZhbHVlLCBtdXRhdGUpIHtcbiAgICAgICAgaWYgKCBtdXRhdGUgPT09IHZvaWQgMCApIG11dGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIHZhciByZWYgPSBtYy5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgbW9kZSA9IHJlZlswXTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSByZWZbMV07XG4gICAgICAgIHZhciBzcmMgPSB0aGlzW21vZGVdKCk7XG4gICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG1vZGUuaW5kZXhPZihjaGFubmVsKSAtIChtb2RlLnN1YnN0cigwLCAyKSA9PT0gJ29rJyA/IDIgOiAwKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSQzKHZhbHVlKSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldICs9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tpXSArPSArdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbaV0gKj0gK3ZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tpXSAvPSArdmFsdWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbaV0gPSArdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUkMyh2YWx1ZSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyY1tpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIHZhbHVlIGZvciBDb2xvci5zZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQ29sb3IkZChzcmMsIG1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtdXRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmdiID0gb3V0Ll9yZ2I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcInVua25vd24gY2hhbm5lbCBcIiArIGNoYW5uZWwgKyBcIiBpbiBtb2RlIFwiICsgbW9kZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkYyA9IENvbG9yXzE7XG5cbiAgICB2YXIgcmdiID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgdmFyIHh5ejAgPSBjb2wxLl9yZ2I7XG4gICAgICAgIHZhciB4eXoxID0gY29sMi5fcmdiO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yJGMoXG4gICAgICAgICAgICB4eXowWzBdICsgZiAqICh4eXoxWzBdLXh5ejBbMF0pLFxuICAgICAgICAgICAgeHl6MFsxXSArIGYgKiAoeHl6MVsxXS14eXowWzFdKSxcbiAgICAgICAgICAgIHh5ejBbMl0gKyBmICogKHh5ejFbMl0teHl6MFsyXSksXG4gICAgICAgICAgICAncmdiJ1xuICAgICAgICApXG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLnJnYiA9IHJnYjtcblxuICAgIHZhciBDb2xvciRiID0gQ29sb3JfMTtcbiAgICB2YXIgc3FydCQyID0gTWF0aC5zcXJ0O1xuICAgIHZhciBwb3ckNSA9IE1hdGgucG93O1xuXG4gICAgdmFyIGxyZ2IgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICB2YXIgcmVmID0gY29sMS5fcmdiO1xuICAgICAgICB2YXIgeDEgPSByZWZbMF07XG4gICAgICAgIHZhciB5MSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIHoxID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSBjb2wyLl9yZ2I7XG4gICAgICAgIHZhciB4MiA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgeTIgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIHoyID0gcmVmJDFbMl07XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IkYihcbiAgICAgICAgICAgIHNxcnQkMihwb3ckNSh4MSwyKSAqICgxLWYpICsgcG93JDUoeDIsMikgKiBmKSxcbiAgICAgICAgICAgIHNxcnQkMihwb3ckNSh5MSwyKSAqICgxLWYpICsgcG93JDUoeTIsMikgKiBmKSxcbiAgICAgICAgICAgIHNxcnQkMihwb3ckNSh6MSwyKSAqICgxLWYpICsgcG93JDUoejIsMikgKiBmKSxcbiAgICAgICAgICAgICdyZ2InXG4gICAgICAgIClcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEubHJnYiA9IGxyZ2I7XG5cbiAgICB2YXIgQ29sb3IkYSA9IENvbG9yXzE7XG5cbiAgICB2YXIgbGFiID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgdmFyIHh5ejAgPSBjb2wxLmxhYigpO1xuICAgICAgICB2YXIgeHl6MSA9IGNvbDIubGFiKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IkYShcbiAgICAgICAgICAgIHh5ejBbMF0gKyBmICogKHh5ejFbMF0teHl6MFswXSksXG4gICAgICAgICAgICB4eXowWzFdICsgZiAqICh4eXoxWzFdLXh5ejBbMV0pLFxuICAgICAgICAgICAgeHl6MFsyXSArIGYgKiAoeHl6MVsyXS14eXowWzJdKSxcbiAgICAgICAgICAgICdsYWInXG4gICAgICAgIClcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEubGFiID0gbGFiO1xuXG4gICAgdmFyIENvbG9yJDkgPSBDb2xvcl8xO1xuXG4gICAgdmFyIF9oc3ggPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZiwgbSkge1xuICAgICAgICB2YXIgYXNzaWduLCBhc3NpZ24kMTtcblxuICAgICAgICB2YXIgeHl6MCwgeHl6MTtcbiAgICAgICAgaWYgKG0gPT09ICdoc2wnKSB7XG4gICAgICAgICAgICB4eXowID0gY29sMS5oc2woKTtcbiAgICAgICAgICAgIHh5ejEgPSBjb2wyLmhzbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKG0gPT09ICdoc3YnKSB7XG4gICAgICAgICAgICB4eXowID0gY29sMS5oc3YoKTtcbiAgICAgICAgICAgIHh5ejEgPSBjb2wyLmhzdigpO1xuICAgICAgICB9IGVsc2UgaWYgKG0gPT09ICdoY2cnKSB7XG4gICAgICAgICAgICB4eXowID0gY29sMS5oY2coKTtcbiAgICAgICAgICAgIHh5ejEgPSBjb2wyLmhjZygpO1xuICAgICAgICB9IGVsc2UgaWYgKG0gPT09ICdoc2knKSB7XG4gICAgICAgICAgICB4eXowID0gY29sMS5oc2koKTtcbiAgICAgICAgICAgIHh5ejEgPSBjb2wyLmhzaSgpO1xuICAgICAgICB9IGVsc2UgaWYgKG0gPT09ICdsY2gnIHx8IG0gPT09ICdoY2wnKSB7XG4gICAgICAgICAgICBtID0gJ2hjbCc7XG4gICAgICAgICAgICB4eXowID0gY29sMS5oY2woKTtcbiAgICAgICAgICAgIHh5ejEgPSBjb2wyLmhjbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKG0gPT09ICdva2xjaCcpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLm9rbGNoKCkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIub2tsY2goKS5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHVlMCwgaHVlMSwgc2F0MCwgc2F0MSwgbGJ2MCwgbGJ2MTtcbiAgICAgICAgaWYgKG0uc3Vic3RyKDAsIDEpID09PSAnaCcgfHwgbSA9PT0gJ29rbGNoJykge1xuICAgICAgICAgICAgKGFzc2lnbiA9IHh5ejAsIGh1ZTAgPSBhc3NpZ25bMF0sIHNhdDAgPSBhc3NpZ25bMV0sIGxidjAgPSBhc3NpZ25bMl0pO1xuICAgICAgICAgICAgKGFzc2lnbiQxID0geHl6MSwgaHVlMSA9IGFzc2lnbiQxWzBdLCBzYXQxID0gYXNzaWduJDFbMV0sIGxidjEgPSBhc3NpZ24kMVsyXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2F0LCBodWUsIGxidiwgZGg7XG5cbiAgICAgICAgaWYgKCFpc05hTihodWUwKSAmJiAhaXNOYU4oaHVlMSkpIHtcbiAgICAgICAgICAgIC8vIGJvdGggY29sb3JzIGhhdmUgaHVlXG4gICAgICAgICAgICBpZiAoaHVlMSA+IGh1ZTAgJiYgaHVlMSAtIGh1ZTAgPiAxODApIHtcbiAgICAgICAgICAgICAgICBkaCA9IGh1ZTEgLSAoaHVlMCArIDM2MCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGh1ZTEgPCBodWUwICYmIGh1ZTAgLSBodWUxID4gMTgwKSB7XG4gICAgICAgICAgICAgICAgZGggPSBodWUxICsgMzYwIC0gaHVlMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGggPSBodWUxIC0gaHVlMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh1ZSA9IGh1ZTAgKyBmICogZGg7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKGh1ZTApKSB7XG4gICAgICAgICAgICBodWUgPSBodWUwO1xuICAgICAgICAgICAgaWYgKChsYnYxID09IDEgfHwgbGJ2MSA9PSAwKSAmJiBtICE9ICdoc3YnKSB7IHNhdCA9IHNhdDA7IH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNOYU4oaHVlMSkpIHtcbiAgICAgICAgICAgIGh1ZSA9IGh1ZTE7XG4gICAgICAgICAgICBpZiAoKGxidjAgPT0gMSB8fCBsYnYwID09IDApICYmIG0gIT0gJ2hzdicpIHsgc2F0ID0gc2F0MTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHVlID0gTnVtYmVyLk5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzYXQgPT09IHVuZGVmaW5lZCkgeyBzYXQgPSBzYXQwICsgZiAqIChzYXQxIC0gc2F0MCk7IH1cbiAgICAgICAgbGJ2ID0gbGJ2MCArIGYgKiAobGJ2MSAtIGxidjApO1xuICAgICAgICByZXR1cm4gbSA9PT0gJ29rbGNoJyA/IG5ldyBDb2xvciQ5KFtsYnYsIHNhdCwgaHVlXSwgbSkgOiBuZXcgQ29sb3IkOShbaHVlLCBzYXQsIGxidl0sIG0pO1xuICAgIH07XG5cbiAgICB2YXIgaW50ZXJwb2xhdGVfaHN4JDUgPSBfaHN4O1xuXG4gICAgdmFyIGxjaCA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgXHRyZXR1cm4gaW50ZXJwb2xhdGVfaHN4JDUoY29sMSwgY29sMiwgZiwgJ2xjaCcpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5sY2ggPSBsY2g7XG4gICAgaW50ZXJwb2xhdG9yJDEuaGNsID0gbGNoO1xuXG4gICAgdmFyIENvbG9yJDggPSBDb2xvcl8xO1xuXG4gICAgdmFyIG51bSA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHZhciBjMSA9IGNvbDEubnVtKCk7XG4gICAgICAgIHZhciBjMiA9IGNvbDIubnVtKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IkOChjMSArIGYgKiAoYzItYzEpLCAnbnVtJylcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEubnVtID0gbnVtO1xuXG4gICAgdmFyIGludGVycG9sYXRlX2hzeCQ0ID0gX2hzeDtcblxuICAgIHZhciBoY2cgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgIFx0cmV0dXJuIGludGVycG9sYXRlX2hzeCQ0KGNvbDEsIGNvbDIsIGYsICdoY2cnKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEuaGNnID0gaGNnO1xuXG4gICAgdmFyIGludGVycG9sYXRlX2hzeCQzID0gX2hzeDtcblxuICAgIHZhciBoc2kgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgIFx0cmV0dXJuIGludGVycG9sYXRlX2hzeCQzKGNvbDEsIGNvbDIsIGYsICdoc2knKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEuaHNpID0gaHNpO1xuXG4gICAgdmFyIGludGVycG9sYXRlX2hzeCQyID0gX2hzeDtcblxuICAgIHZhciBoc2wgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgIFx0cmV0dXJuIGludGVycG9sYXRlX2hzeCQyKGNvbDEsIGNvbDIsIGYsICdoc2wnKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEuaHNsID0gaHNsO1xuXG4gICAgdmFyIGludGVycG9sYXRlX2hzeCQxID0gX2hzeDtcblxuICAgIHZhciBoc3YgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgIFx0cmV0dXJuIGludGVycG9sYXRlX2hzeCQxKGNvbDEsIGNvbDIsIGYsICdoc3YnKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEuaHN2ID0gaHN2O1xuXG4gICAgdmFyIENvbG9yJDcgPSBDb2xvcl8xO1xuXG4gICAgdmFyIG9rbGFiID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgdmFyIHh5ejAgPSBjb2wxLm9rbGFiKCk7XG4gICAgICAgIHZhciB4eXoxID0gY29sMi5va2xhYigpO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yJDcoXG4gICAgICAgICAgICB4eXowWzBdICsgZiAqICh4eXoxWzBdIC0geHl6MFswXSksXG4gICAgICAgICAgICB4eXowWzFdICsgZiAqICh4eXoxWzFdIC0geHl6MFsxXSksXG4gICAgICAgICAgICB4eXowWzJdICsgZiAqICh4eXoxWzJdIC0geHl6MFsyXSksXG4gICAgICAgICAgICAnb2tsYWInXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLm9rbGFiID0gb2tsYWI7XG5cbiAgICB2YXIgaW50ZXJwb2xhdGVfaHN4ID0gX2hzeDtcblxuICAgIHZhciBva2xjaCA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZV9oc3goY29sMSwgY29sMiwgZiwgJ29rbGNoJyk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLm9rbGNoID0gb2tsY2g7XG5cbiAgICB2YXIgQ29sb3IkNiA9IENvbG9yXzE7XG4gICAgdmFyIGNsaXBfcmdiJDEgPSB1dGlscy5jbGlwX3JnYjtcbiAgICB2YXIgcG93JDQgPSBNYXRoLnBvdztcbiAgICB2YXIgc3FydCQxID0gTWF0aC5zcXJ0O1xuICAgIHZhciBQSSQxID0gTWF0aC5QSTtcbiAgICB2YXIgY29zJDIgPSBNYXRoLmNvcztcbiAgICB2YXIgc2luJDIgPSBNYXRoLnNpbjtcbiAgICB2YXIgYXRhbjIkMSA9IE1hdGguYXRhbjI7XG5cbiAgICB2YXIgYXZlcmFnZSA9IGZ1bmN0aW9uIChjb2xvcnMsIG1vZGUsIHdlaWdodHMpIHtcbiAgICAgICAgaWYgKCBtb2RlID09PSB2b2lkIDAgKSBtb2RlPSdscmdiJztcbiAgICAgICAgaWYgKCB3ZWlnaHRzID09PSB2b2lkIDAgKSB3ZWlnaHRzPW51bGw7XG5cbiAgICAgICAgdmFyIGwgPSBjb2xvcnMubGVuZ3RoO1xuICAgICAgICBpZiAoIXdlaWdodHMpIHsgd2VpZ2h0cyA9IEFycmF5LmZyb20obmV3IEFycmF5KGwpKS5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSk7IH1cbiAgICAgICAgLy8gbm9ybWFsaXplIHdlaWdodHNcbiAgICAgICAgdmFyIGsgPSBsIC8gd2VpZ2h0cy5yZWR1Y2UoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSArIGI7IH0pO1xuICAgICAgICB3ZWlnaHRzLmZvckVhY2goZnVuY3Rpb24gKHcsaSkgeyB3ZWlnaHRzW2ldICo9IGs7IH0pO1xuICAgICAgICAvLyBjb252ZXJ0IGNvbG9ycyB0byBDb2xvciBvYmplY3RzXG4gICAgICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5ldyBDb2xvciQ2KGMpOyB9KTtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdscmdiJykge1xuICAgICAgICAgICAgcmV0dXJuIF9hdmVyYWdlX2xyZ2IoY29sb3JzLCB3ZWlnaHRzKVxuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdCA9IGNvbG9ycy5zaGlmdCgpO1xuICAgICAgICB2YXIgeHl6ID0gZmlyc3QuZ2V0KG1vZGUpO1xuICAgICAgICB2YXIgY250ID0gW107XG4gICAgICAgIHZhciBkeCA9IDA7XG4gICAgICAgIHZhciBkeSA9IDA7XG4gICAgICAgIC8vIGluaXRpYWwgY29sb3JcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHh5ei5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeHl6W2ldID0gKHh5eltpXSB8fCAwKSAqIHdlaWdodHNbMF07XG4gICAgICAgICAgICBjbnQucHVzaChpc05hTih4eXpbaV0pID8gMCA6IHdlaWdodHNbMF0pO1xuICAgICAgICAgICAgaWYgKG1vZGUuY2hhckF0KGkpID09PSAnaCcgJiYgIWlzTmFOKHh5eltpXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgQSA9IHh5eltpXSAvIDE4MCAqIFBJJDE7XG4gICAgICAgICAgICAgICAgZHggKz0gY29zJDIoQSkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICAgICAgICAgIGR5ICs9IHNpbiQyKEEpICogd2VpZ2h0c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbHBoYSA9IGZpcnN0LmFscGhhKCkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICBjb2xvcnMuZm9yRWFjaChmdW5jdGlvbiAoYyxjaSkge1xuICAgICAgICAgICAgdmFyIHh5ejIgPSBjLmdldChtb2RlKTtcbiAgICAgICAgICAgIGFscGhhICs9IGMuYWxwaGEoKSAqIHdlaWdodHNbY2krMV07XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8eHl6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih4eXoyW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjbnRbaV0gKz0gd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUuY2hhckF0KGkpID09PSAnaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBBID0geHl6MltpXSAvIDE4MCAqIFBJJDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBkeCArPSBjb3MkMihBKSAqIHdlaWdodHNbY2krMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkeSArPSBzaW4kMihBKSAqIHdlaWdodHNbY2krMV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4eXpbaV0gKz0geHl6MltpXSAqIHdlaWdodHNbY2krMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkkMT0wOyBpJDE8eHl6Lmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmIChtb2RlLmNoYXJBdChpJDEpID09PSAnaCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgQSQxID0gYXRhbjIkMShkeSAvIGNudFtpJDFdLCBkeCAvIGNudFtpJDFdKSAvIFBJJDEgKiAxODA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKEEkMSA8IDApIHsgQSQxICs9IDM2MDsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChBJDEgPj0gMzYwKSB7IEEkMSAtPSAzNjA7IH1cbiAgICAgICAgICAgICAgICB4eXpbaSQxXSA9IEEkMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeHl6W2kkMV0gPSB4eXpbaSQxXS9jbnRbaSQxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhbHBoYSAvPSBsO1xuICAgICAgICByZXR1cm4gKG5ldyBDb2xvciQ2KHh5eiwgbW9kZSkpLmFscGhhKGFscGhhID4gMC45OTk5OSA/IDEgOiBhbHBoYSwgdHJ1ZSk7XG4gICAgfTtcblxuXG4gICAgdmFyIF9hdmVyYWdlX2xyZ2IgPSBmdW5jdGlvbiAoY29sb3JzLCB3ZWlnaHRzKSB7XG4gICAgICAgIHZhciBsID0gY29sb3JzLmxlbmd0aDtcbiAgICAgICAgdmFyIHh5eiA9IFswLDAsMCwwXTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgY29sb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29sID0gY29sb3JzW2ldO1xuICAgICAgICAgICAgdmFyIGYgPSB3ZWlnaHRzW2ldIC8gbDtcbiAgICAgICAgICAgIHZhciByZ2IgPSBjb2wuX3JnYjtcbiAgICAgICAgICAgIHh5elswXSArPSBwb3ckNChyZ2JbMF0sMikgKiBmO1xuICAgICAgICAgICAgeHl6WzFdICs9IHBvdyQ0KHJnYlsxXSwyKSAqIGY7XG4gICAgICAgICAgICB4eXpbMl0gKz0gcG93JDQocmdiWzJdLDIpICogZjtcbiAgICAgICAgICAgIHh5elszXSArPSByZ2JbM10gKiBmO1xuICAgICAgICB9XG4gICAgICAgIHh5elswXSA9IHNxcnQkMSh4eXpbMF0pO1xuICAgICAgICB4eXpbMV0gPSBzcXJ0JDEoeHl6WzFdKTtcbiAgICAgICAgeHl6WzJdID0gc3FydCQxKHh5elsyXSk7XG4gICAgICAgIGlmICh4eXpbM10gPiAwLjk5OTk5OTkpIHsgeHl6WzNdID0gMTsgfVxuICAgICAgICByZXR1cm4gbmV3IENvbG9yJDYoY2xpcF9yZ2IkMSh4eXopKTtcbiAgICB9O1xuXG4gICAgLy8gbWluaW1hbCBtdWx0aS1wdXJwb3NlIGludGVyZmFjZVxuXG4gICAgLy8gQHJlcXVpcmVzIHV0aWxzIGNvbG9yIGFuYWx5emVcblxuICAgIHZhciBjaHJvbWEkNCA9IGNocm9tYV8xO1xuICAgIHZhciB0eXBlJDIgPSB1dGlscy50eXBlO1xuXG4gICAgdmFyIHBvdyQzID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgc2NhbGUkMiA9IGZ1bmN0aW9uKGNvbG9ycykge1xuXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgIHZhciBfbW9kZSA9ICdyZ2InO1xuICAgICAgICB2YXIgX25hY29sID0gY2hyb21hJDQoJyNjY2MnKTtcbiAgICAgICAgdmFyIF9zcHJlYWQgPSAwO1xuICAgICAgICAvLyBjb25zdCBfZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9kb21haW4gPSBbMCwgMV07XG4gICAgICAgIHZhciBfcG9zID0gW107XG4gICAgICAgIHZhciBfcGFkZGluZyA9IFswLDBdO1xuICAgICAgICB2YXIgX2NsYXNzZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9jb2xvcnMgPSBbXTtcbiAgICAgICAgdmFyIF9vdXQgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9taW4gPSAwO1xuICAgICAgICB2YXIgX21heCA9IDE7XG4gICAgICAgIHZhciBfY29ycmVjdExpZ2h0bmVzcyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2NvbG9yQ2FjaGUgPSB7fTtcbiAgICAgICAgdmFyIF91c2VDYWNoZSA9IHRydWU7XG4gICAgICAgIHZhciBfZ2FtbWEgPSAxO1xuXG4gICAgICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgICAgIHZhciBzZXRDb2xvcnMgPSBmdW5jdGlvbihjb2xvcnMpIHtcbiAgICAgICAgICAgIGNvbG9ycyA9IGNvbG9ycyB8fCBbJyNmZmYnLCAnIzAwMCddO1xuICAgICAgICAgICAgaWYgKGNvbG9ycyAmJiB0eXBlJDIoY29sb3JzKSA9PT0gJ3N0cmluZycgJiYgY2hyb21hJDQuYnJld2VyICYmXG4gICAgICAgICAgICAgICAgY2hyb21hJDQuYnJld2VyW2NvbG9ycy50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgICAgICAgIGNvbG9ycyA9IGNocm9tYSQ0LmJyZXdlcltjb2xvcnMudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSQyKGNvbG9ycykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc2luZ2xlIGNvbG9yXG4gICAgICAgICAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzID0gW2NvbG9yc1swXSwgY29sb3JzWzBdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIGNvbG9yc1xuICAgICAgICAgICAgICAgIGNvbG9ycyA9IGNvbG9ycy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRvIGNocm9tYSBjbGFzc2VzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYz0wOyBjPGNvbG9ycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnNbY10gPSBjaHJvbWEkNChjb2xvcnNbY10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhdXRvLWZpbGwgY29sb3IgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBfcG9zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyQxPTA7IGMkMTxjb2xvcnMubGVuZ3RoOyBjJDErKykge1xuICAgICAgICAgICAgICAgICAgICBfcG9zLnB1c2goYyQxLyhjb2xvcnMubGVuZ3RoLTEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNldENhY2hlKCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbG9ycyA9IGNvbG9ycztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0Q2xhc3MgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKF9jbGFzc2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IF9jbGFzc2VzLmxlbmd0aC0xO1xuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IG4gJiYgdmFsdWUgPj0gX2NsYXNzZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaS0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRNYXBMaWdodG5lc3MgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfTtcbiAgICAgICAgdmFyIHRNYXBEb21haW4gPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfTtcblxuICAgICAgICAvLyBjb25zdCBjbGFzc2lmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gICAgIGxldCB2YWwgPSB2YWx1ZTtcbiAgICAgICAgLy8gICAgIGlmIChfY2xhc3Nlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIC8vICAgICAgICAgY29uc3QgbiA9IF9jbGFzc2VzLmxlbmd0aC0xO1xuICAgICAgICAvLyAgICAgICAgIGNvbnN0IGkgPSBnZXRDbGFzcyh2YWx1ZSk7XG4gICAgICAgIC8vICAgICAgICAgY29uc3QgbWluYyA9IF9jbGFzc2VzWzBdICsgKChfY2xhc3Nlc1sxXS1fY2xhc3Nlc1swXSkgKiAoMCArIChfc3ByZWFkICogMC41KSkpOyAgLy8gY2VudGVyIG9mIDFzdCBjbGFzc1xuICAgICAgICAvLyAgICAgICAgIGNvbnN0IG1heGMgPSBfY2xhc3Nlc1tuLTFdICsgKChfY2xhc3Nlc1tuXS1fY2xhc3Nlc1tuLTFdKSAqICgxIC0gKF9zcHJlYWQgKiAwLjUpKSk7ICAvLyBjZW50ZXIgb2YgbGFzdCBjbGFzc1xuICAgICAgICAvLyAgICAgICAgIHZhbCA9IF9taW4gKyAoKCgoX2NsYXNzZXNbaV0gKyAoKF9jbGFzc2VzW2krMV0gLSBfY2xhc3Nlc1tpXSkgKiAwLjUpKSAtIG1pbmMpIC8gKG1heGMtbWluYykpICogKF9tYXggLSBfbWluKSk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgICByZXR1cm4gdmFsO1xuICAgICAgICAvLyB9O1xuXG4gICAgICAgIHZhciBnZXRDb2xvciA9IGZ1bmN0aW9uKHZhbCwgYnlwYXNzTWFwKSB7XG4gICAgICAgICAgICB2YXIgY29sLCB0O1xuICAgICAgICAgICAgaWYgKGJ5cGFzc01hcCA9PSBudWxsKSB7IGJ5cGFzc01hcCA9IGZhbHNlOyB9XG4gICAgICAgICAgICBpZiAoaXNOYU4odmFsKSB8fCAodmFsID09PSBudWxsKSkgeyByZXR1cm4gX25hY29sOyB9XG4gICAgICAgICAgICBpZiAoIWJ5cGFzc01hcCkge1xuICAgICAgICAgICAgICAgIGlmIChfY2xhc3NlcyAmJiAoX2NsYXNzZXMubGVuZ3RoID4gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBnZXRDbGFzcyh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB0ID0gYyAvIChfY2xhc3Nlcy5sZW5ndGgtMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfbWF4ICE9PSBfbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgaW50ZXJwb2xhdGUgYmV0d2VlbiBtaW4vbWF4XG4gICAgICAgICAgICAgICAgICAgIHQgPSAodmFsIC0gX21pbikgLyAoX21heCAtIF9taW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdCA9IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG9tYWluIG1hcFxuICAgICAgICAgICAgdCA9IHRNYXBEb21haW4odCk7XG5cbiAgICAgICAgICAgIGlmICghYnlwYXNzTWFwKSB7XG4gICAgICAgICAgICAgICAgdCA9IHRNYXBMaWdodG5lc3ModCk7ICAvLyBsaWdodG5lc3MgY29ycmVjdGlvblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX2dhbW1hICE9PSAxKSB7IHQgPSBwb3ckMyh0LCBfZ2FtbWEpOyB9XG5cbiAgICAgICAgICAgIHQgPSBfcGFkZGluZ1swXSArICh0ICogKDEgLSBfcGFkZGluZ1swXSAtIF9wYWRkaW5nWzFdKSk7XG5cbiAgICAgICAgICAgIHQgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCB0KSk7XG5cbiAgICAgICAgICAgIHZhciBrID0gTWF0aC5mbG9vcih0ICogMTAwMDApO1xuXG4gICAgICAgICAgICBpZiAoX3VzZUNhY2hlICYmIF9jb2xvckNhY2hlW2tdKSB7XG4gICAgICAgICAgICAgICAgY29sID0gX2NvbG9yQ2FjaGVba107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlJDIoX2NvbG9ycykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9mb3IgaSBpbiBbMC4uX3Bvcy5sZW5ndGgtMV1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPF9wb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gX3Bvc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0IDw9IHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0ID49IHApICYmIChpID09PSAoX3Bvcy5sZW5ndGgtMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gX2NvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID4gcCAmJiB0IDwgX3Bvc1tpKzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICh0LXApLyhfcG9zW2krMV0tcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gY2hyb21hJDQuaW50ZXJwb2xhdGUoX2NvbG9yc1tpXSwgX2NvbG9yc1tpKzFdLCB0LCBfbW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUkMihfY29sb3JzKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JzKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3VzZUNhY2hlKSB7IF9jb2xvckNhY2hlW2tdID0gY29sOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXNldENhY2hlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX2NvbG9yQ2FjaGUgPSB7fTsgfTtcblxuICAgICAgICBzZXRDb2xvcnMoY29sb3JzKTtcblxuICAgICAgICAvLyBwdWJsaWMgaW50ZXJmYWNlXG5cbiAgICAgICAgdmFyIGYgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNocm9tYSQ0KGdldENvbG9yKHYpKTtcbiAgICAgICAgICAgIGlmIChfb3V0ICYmIGNbX291dF0pIHsgcmV0dXJuIGNbX291dF0oKTsgfSBlbHNlIHsgcmV0dXJuIGM7IH1cbiAgICAgICAgfTtcblxuICAgICAgICBmLmNsYXNzZXMgPSBmdW5jdGlvbihjbGFzc2VzKSB7XG4gICAgICAgICAgICBpZiAoY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUkMihjbGFzc2VzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICBfY2xhc3NlcyA9IGNsYXNzZXM7XG4gICAgICAgICAgICAgICAgICAgIF9kb21haW4gPSBbY2xhc3Nlc1swXSwgY2xhc3Nlc1tjbGFzc2VzLmxlbmd0aC0xXV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBjaHJvbWEkNC5hbmFseXplKF9kb21haW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzZXMgPSBbZC5taW4sIGQubWF4XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc2VzID0gY2hyb21hJDQubGltaXRzKGQsICdlJywgY2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2NsYXNzZXM7XG4gICAgICAgIH07XG5cblxuICAgICAgICBmLmRvbWFpbiA9IGZ1bmN0aW9uKGRvbWFpbikge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbWluID0gZG9tYWluWzBdO1xuICAgICAgICAgICAgX21heCA9IGRvbWFpbltkb21haW4ubGVuZ3RoLTFdO1xuICAgICAgICAgICAgX3BvcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGsgPSBfY29sb3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZG9tYWluLmxlbmd0aCA9PT0gaykgJiYgKF9taW4gIT09IF9tYXgpKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gQXJyYXkuZnJvbShkb21haW4pOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGxpc3RbaV07XG5cbiAgICAgICAgICAgICAgICAgIF9wb3MucHVzaCgoZC1fbWluKSAvIChfbWF4LV9taW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGM9MDsgYzxrOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX3Bvcy5wdXNoKGMvKGstMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGRvbWFpbiBtYXBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRPdXQgPSBkb21haW4ubWFwKGZ1bmN0aW9uIChkLGkpIHsgcmV0dXJuIGkvKGRvbWFpbi5sZW5ndGgtMSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdEJyZWFrcyA9IGRvbWFpbi5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIChkIC0gX21pbikgLyAoX21heCAtIF9taW4pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0QnJlYWtzLmV2ZXJ5KGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIHRPdXRbaV0gPT09IHZhbDsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRNYXBEb21haW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0IDw9IDAgfHwgdCA+PSAxKSB7IHJldHVybiB0OyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0ID49IHRCcmVha3NbaSsxXSkgeyBpKys7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9ICh0IC0gdEJyZWFrc1tpXSkgLyAodEJyZWFrc1tpKzFdIC0gdEJyZWFrc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IHRPdXRbaV0gKyBmICogKHRPdXRbaSsxXSAtIHRPdXRbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZG9tYWluID0gW19taW4sIF9tYXhdO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5tb2RlID0gZnVuY3Rpb24oX20pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9tb2RlID0gX207XG4gICAgICAgICAgICByZXNldENhY2hlKCk7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnJhbmdlID0gZnVuY3Rpb24oY29sb3JzLCBfcG9zKSB7XG4gICAgICAgICAgICBzZXRDb2xvcnMoY29sb3JzKTtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYub3V0ID0gZnVuY3Rpb24oX28pIHtcbiAgICAgICAgICAgIF9vdXQgPSBfbztcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuc3ByZWFkID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NwcmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zcHJlYWQgPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLmNvcnJlY3RMaWdodG5lc3MgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBpZiAodiA9PSBudWxsKSB7IHYgPSB0cnVlOyB9XG4gICAgICAgICAgICBfY29ycmVjdExpZ2h0bmVzcyA9IHY7XG4gICAgICAgICAgICByZXNldENhY2hlKCk7XG4gICAgICAgICAgICBpZiAoX2NvcnJlY3RMaWdodG5lc3MpIHtcbiAgICAgICAgICAgICAgICB0TWFwTGlnaHRuZXNzID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgTDAgPSBnZXRDb2xvcigwLCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEwxID0gZ2V0Q29sb3IoMSwgdHJ1ZSkubGFiKClbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2wgPSBMMCA+IEwxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTF9hY3R1YWwgPSBnZXRDb2xvcih0LCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIExfaWRlYWwgPSBMMCArICgoTDEgLSBMMCkgKiB0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIExfZGlmZiA9IExfYWN0dWFsIC0gTF9pZGVhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heF9pdGVyID0gMjA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoTWF0aC5hYnMoTF9kaWZmKSA+IDFlLTIpICYmIChtYXhfaXRlci0tID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9sKSB7IExfZGlmZiAqPSAtMTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMX2RpZmYgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQwID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCArPSAodDEgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gKHQwIC0gdCkgKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExfYWN0dWFsID0gZ2V0Q29sb3IodCwgdHJ1ZSkubGFiKClbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExfZGlmZiA9IExfYWN0dWFsIC0gTF9pZGVhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5wYWRkaW5nID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgaWYgKHAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlJDIocCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBbcCxwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3BhZGRpbmcgPSBwO1xuICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhZGRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5jb2xvcnMgPSBmdW5jdGlvbihudW1Db2xvcnMsIG91dCkge1xuICAgICAgICAgICAgLy8gSWYgbm8gYXJndW1lbnRzIGFyZSBnaXZlbiwgcmV0dXJuIHRoZSBvcmlnaW5hbCBjb2xvcnMgdGhhdCB3ZXJlIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHsgb3V0ID0gJ2hleCc7IH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29sb3JzLnNsaWNlKDApO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bUNvbG9ycyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtmKDAuNSldO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bUNvbG9ycyA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG0gPSBfZG9tYWluWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkZCA9IF9kb21haW5bMV0gLSBkbTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfX3JhbmdlX18oMCwgbnVtQ29sb3JzLCBmYWxzZSkubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBmKCBkbSArICgoaS8obnVtQ29sb3JzLTEpKSAqIGRkKSApOyB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcmV0dXJucyBhbGwgY29sb3JzIGJhc2VkIG9uIHRoZSBkZWZpbmVkIGNsYXNzZXNcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgc2FtcGxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChfY2xhc3NlcyAmJiAoX2NsYXNzZXMubGVuZ3RoID4gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGVuZCA9IF9jbGFzc2VzLmxlbmd0aCwgYXNjID0gMSA8PSBlbmQ7IGFzYyA/IGkgPCBlbmQgOiBpID4gZW5kOyBhc2MgPyBpKysgOiBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZXMucHVzaCgoX2NsYXNzZXNbaS0xXStfY2xhc3Nlc1tpXSkqMC41KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXMgPSBfZG9tYWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzYW1wbGVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZih2KTsgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaHJvbWEkNFtvdXRdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gY1tvdXRdKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBmLmNhY2hlID0gZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgaWYgKGMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF91c2VDYWNoZSA9IGM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdXNlQ2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5nYW1tYSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgIGlmIChnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfZ2FtbWEgPSBnO1xuICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dhbW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGYubm9kYXRhID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF9uYWNvbCA9IGNocm9tYSQ0KGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX25hY29sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfX3JhbmdlX18obGVmdCwgcmlnaHQsIGluY2x1c2l2ZSkge1xuICAgICAgdmFyIHJhbmdlID0gW107XG4gICAgICB2YXIgYXNjZW5kaW5nID0gbGVmdCA8IHJpZ2h0O1xuICAgICAgdmFyIGVuZCA9ICFpbmNsdXNpdmUgPyByaWdodCA6IGFzY2VuZGluZyA/IHJpZ2h0ICsgMSA6IHJpZ2h0IC0gMTtcbiAgICAgIGZvciAodmFyIGkgPSBsZWZ0OyBhc2NlbmRpbmcgPyBpIDwgZW5kIDogaSA+IGVuZDsgYXNjZW5kaW5nID8gaSsrIDogaS0tKSB7XG4gICAgICAgIHJhbmdlLnB1c2goaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBpbnRlcnBvbGF0ZXMgYmV0d2VlbiBhIHNldCBvZiBjb2xvcnMgdXppbmcgYSBiZXppZXIgc3BsaW5lXG4gICAgLy9cblxuICAgIC8vIEByZXF1aXJlcyB1dGlscyBsYWJcbiAgICB2YXIgQ29sb3IkNSA9IENvbG9yXzE7XG5cbiAgICB2YXIgc2NhbGUkMSA9IHNjYWxlJDI7XG5cbiAgICAvLyBudGggcm93IG9mIHRoZSBwYXNjYWwgdHJpYW5nbGVcbiAgICB2YXIgYmlub21fcm93ID0gZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgcm93ID0gWzEsIDFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIG5ld3JvdyA9IFsxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIG5ld3Jvd1tqXSA9IChyb3dbal0gfHwgMCkgKyByb3dbaiAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93ID0gbmV3cm93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfTtcblxuICAgIHZhciBiZXppZXIgPSBmdW5jdGlvbihjb2xvcnMpIHtcbiAgICAgICAgdmFyIGFzc2lnbiwgYXNzaWduJDEsIGFzc2lnbiQyO1xuXG4gICAgICAgIHZhciBJLCBsYWIwLCBsYWIxLCBsYWIyO1xuICAgICAgICBjb2xvcnMgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZXcgQ29sb3IkNShjKTsgfSk7XG4gICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgKGFzc2lnbiA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubGFiKCk7IH0pLCBsYWIwID0gYXNzaWduWzBdLCBsYWIxID0gYXNzaWduWzFdKTtcbiAgICAgICAgICAgIEkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYiA9IChbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBsYWIwW2ldICsgKHQgKiAobGFiMVtpXSAtIGxhYjBbaV0pKTsgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkNShsYWIsICdsYWInKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgLy8gcXVhZHJhdGljIGJlemllciBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAoYXNzaWduJDEgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmxhYigpOyB9KSwgbGFiMCA9IGFzc2lnbiQxWzBdLCBsYWIxID0gYXNzaWduJDFbMV0sIGxhYjIgPSBhc3NpZ24kMVsyXSk7XG4gICAgICAgICAgICBJID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWIgPSAoWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gKCgxLXQpKigxLXQpICogbGFiMFtpXSkgKyAoMiAqICgxLXQpICogdCAqIGxhYjFbaV0pICsgKHQgKiB0ICogbGFiMltpXSk7IH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yJDUobGFiLCAnbGFiJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbG9ycy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIC8vIGN1YmljIGJlemllciBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICB2YXIgbGFiMztcbiAgICAgICAgICAgIChhc3NpZ24kMiA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubGFiKCk7IH0pLCBsYWIwID0gYXNzaWduJDJbMF0sIGxhYjEgPSBhc3NpZ24kMlsxXSwgbGFiMiA9IGFzc2lnbiQyWzJdLCBsYWIzID0gYXNzaWduJDJbM10pO1xuICAgICAgICAgICAgSSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiID0gKFswLCAxLCAyXS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuICgoMS10KSooMS10KSooMS10KSAqIGxhYjBbaV0pICsgKDMgKiAoMS10KSAqICgxLXQpICogdCAqIGxhYjFbaV0pICsgKDMgKiAoMS10KSAqIHQgKiB0ICogbGFiMltpXSkgKyAodCp0KnQgKiBsYWIzW2ldKTsgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkNShsYWIsICdsYWInKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA+PSA1KSB7XG4gICAgICAgICAgICAvLyBnZW5lcmFsIGNhc2UgKGRlZ3JlZSBuIGJlemllcilcbiAgICAgICAgICAgIHZhciBsYWJzLCByb3csIG47XG4gICAgICAgICAgICBsYWJzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5sYWIoKTsgfSk7XG4gICAgICAgICAgICBuID0gY29sb3JzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICByb3cgPSBiaW5vbV9yb3cobik7XG4gICAgICAgICAgICBJID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdSA9IDEgLSB0O1xuICAgICAgICAgICAgICAgIHZhciBsYWIgPSAoWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gbGFicy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgZWwsIGopIHsgcmV0dXJuIChzdW0gKyByb3dbal0gKiBNYXRoLnBvdyggdSwgKG4gLSBqKSApICogTWF0aC5wb3coIHQsIGogKSAqIGVsW2ldKTsgfSwgMCk7IH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yJDUobGFiLCAnbGFiJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBwb2ludCBpbiBydW5uaW5nIGJlemllciB3aXRoIG9ubHkgb25lIGNvbG9yLlwiKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJO1xuICAgIH07XG5cbiAgICB2YXIgYmV6aWVyXzEgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gICAgICAgIHZhciBmID0gYmV6aWVyKGNvbG9ycyk7XG4gICAgICAgIGYuc2NhbGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzY2FsZSQxKGYpOyB9O1xuICAgICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBpbnRlcnBvbGF0ZXMgYmV0d2VlbiBhIHNldCBvZiBjb2xvcnMgdXppbmcgYSBiZXppZXIgc3BsaW5lXG4gICAgICogYmxlbmQgbW9kZSBmb3JtdWxhcyB0YWtlbiBmcm9tIGh0dHA6Ly93d3cudmVudHVyZS13YXJlLmNvbS9rZXZpbi9jb2RpbmcvbGV0cy1sZWFybi1tYXRoLXBob3Rvc2hvcC1ibGVuZC1tb2Rlcy9cbiAgICAgKi9cblxuICAgIHZhciBjaHJvbWEkMyA9IGNocm9tYV8xO1xuXG4gICAgdmFyIGJsZW5kID0gZnVuY3Rpb24gKGJvdHRvbSwgdG9wLCBtb2RlKSB7XG4gICAgICAgIGlmICghYmxlbmRbbW9kZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBibGVuZCBtb2RlICcgKyBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxlbmRbbW9kZV0oYm90dG9tLCB0b3ApO1xuICAgIH07XG5cbiAgICB2YXIgYmxlbmRfZiA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAoYm90dG9tLHRvcCkge1xuICAgICAgICAgICAgdmFyIGMwID0gY2hyb21hJDModG9wKS5yZ2IoKTtcbiAgICAgICAgICAgIHZhciBjMSA9IGNocm9tYSQzKGJvdHRvbSkucmdiKCk7XG4gICAgICAgICAgICByZXR1cm4gY2hyb21hJDMucmdiKGYoYzAsIGMxKSk7XG4gICAgICAgIH07IH07XG5cbiAgICB2YXIgZWFjaCA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAoYzAsIGMxKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBvdXRbMF0gPSBmKGMwWzBdLCBjMVswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSBmKGMwWzFdLCBjMVsxXSk7XG4gICAgICAgICAgICBvdXRbMl0gPSBmKGMwWzJdLCBjMVsyXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9OyB9O1xuXG4gICAgdmFyIG5vcm1hbCA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhOyB9O1xuICAgIHZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIGEgKiBiIC8gMjU1OyB9O1xuICAgIHZhciBkYXJrZW4gPSBmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBhID4gYiA/IGIgOiBhOyB9O1xuICAgIHZhciBsaWdodGVuID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYSA+IGIgPyBhIDogYjsgfTtcbiAgICB2YXIgc2NyZWVuID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gMjU1ICogKDEgLSAoMS1hLzI1NSkgKiAoMS1iLzI1NSkpOyB9O1xuICAgIHZhciBvdmVybGF5ID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYiA8IDEyOCA/IDIgKiBhICogYiAvIDI1NSA6IDI1NSAqICgxIC0gMiAqICgxIC0gYSAvIDI1NSApICogKCAxIC0gYiAvIDI1NSApKTsgfTtcbiAgICB2YXIgYnVybiA9IGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIDI1NSAqICgxIC0gKDEgLSBiIC8gMjU1KSAvIChhLzI1NSkpOyB9O1xuICAgIHZhciBkb2RnZSA9IGZ1bmN0aW9uIChhLGIpIHtcbiAgICAgICAgaWYgKGEgPT09IDI1NSkgeyByZXR1cm4gMjU1OyB9XG4gICAgICAgIGEgPSAyNTUgKiAoYiAvIDI1NSkgLyAoMSAtIGEgLyAyNTUpO1xuICAgICAgICByZXR1cm4gYSA+IDI1NSA/IDI1NSA6IGFcbiAgICB9O1xuXG4gICAgLy8gIyBhZGQgPSAoYSxiKSAtPlxuICAgIC8vICMgICAgIGlmIChhICsgYiA+IDI1NSkgdGhlbiAyNTUgZWxzZSBhICsgYlxuXG4gICAgYmxlbmQubm9ybWFsID0gYmxlbmRfZihlYWNoKG5vcm1hbCkpO1xuICAgIGJsZW5kLm11bHRpcGx5ID0gYmxlbmRfZihlYWNoKG11bHRpcGx5KSk7XG4gICAgYmxlbmQuc2NyZWVuID0gYmxlbmRfZihlYWNoKHNjcmVlbikpO1xuICAgIGJsZW5kLm92ZXJsYXkgPSBibGVuZF9mKGVhY2gob3ZlcmxheSkpO1xuICAgIGJsZW5kLmRhcmtlbiA9IGJsZW5kX2YoZWFjaChkYXJrZW4pKTtcbiAgICBibGVuZC5saWdodGVuID0gYmxlbmRfZihlYWNoKGxpZ2h0ZW4pKTtcbiAgICBibGVuZC5kb2RnZSA9IGJsZW5kX2YoZWFjaChkb2RnZSkpO1xuICAgIGJsZW5kLmJ1cm4gPSBibGVuZF9mKGVhY2goYnVybikpO1xuICAgIC8vIGJsZW5kLmFkZCA9IGJsZW5kX2YoZWFjaChhZGQpKTtcblxuICAgIHZhciBibGVuZF8xID0gYmxlbmQ7XG5cbiAgICAvLyBjdWJlaGVsaXggaW50ZXJwb2xhdGlvblxuICAgIC8vIGJhc2VkIG9uIEQuQS4gR3JlZW4gXCJBIGNvbG91ciBzY2hlbWUgZm9yIHRoZSBkaXNwbGF5IG9mIGFzdHJvbm9taWNhbCBpbnRlbnNpdHkgaW1hZ2VzXCJcbiAgICAvLyBodHRwOi8vYXN0cm9uLXNvYy5pbi9idWxsZXRpbi8xMUp1bmUvMjg5MzkyMDExLnBkZlxuXG4gICAgdmFyIHR5cGUkMSA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNsaXBfcmdiID0gdXRpbHMuY2xpcF9yZ2I7XG4gICAgdmFyIFRXT1BJID0gdXRpbHMuVFdPUEk7XG4gICAgdmFyIHBvdyQyID0gTWF0aC5wb3c7XG4gICAgdmFyIHNpbiQxID0gTWF0aC5zaW47XG4gICAgdmFyIGNvcyQxID0gTWF0aC5jb3M7XG4gICAgdmFyIGNocm9tYSQyID0gY2hyb21hXzE7XG5cbiAgICB2YXIgY3ViZWhlbGl4ID0gZnVuY3Rpb24oc3RhcnQsIHJvdGF0aW9ucywgaHVlLCBnYW1tYSwgbGlnaHRuZXNzKSB7XG4gICAgICAgIGlmICggc3RhcnQgPT09IHZvaWQgMCApIHN0YXJ0PTMwMDtcbiAgICAgICAgaWYgKCByb3RhdGlvbnMgPT09IHZvaWQgMCApIHJvdGF0aW9ucz0tMS41O1xuICAgICAgICBpZiAoIGh1ZSA9PT0gdm9pZCAwICkgaHVlPTE7XG4gICAgICAgIGlmICggZ2FtbWEgPT09IHZvaWQgMCApIGdhbW1hPTE7XG4gICAgICAgIGlmICggbGlnaHRuZXNzID09PSB2b2lkIDAgKSBsaWdodG5lc3M9WzAsMV07XG5cbiAgICAgICAgdmFyIGRoID0gMCwgZGw7XG4gICAgICAgIGlmICh0eXBlJDEobGlnaHRuZXNzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgZGwgPSBsaWdodG5lc3NbMV0gLSBsaWdodG5lc3NbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkbCA9IDA7XG4gICAgICAgICAgICBsaWdodG5lc3MgPSBbbGlnaHRuZXNzLCBsaWdodG5lc3NdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSBmdW5jdGlvbihmcmFjdCkge1xuICAgICAgICAgICAgdmFyIGEgPSBUV09QSSAqICgoKHN0YXJ0KzEyMCkvMzYwKSArIChyb3RhdGlvbnMgKiBmcmFjdCkpO1xuICAgICAgICAgICAgdmFyIGwgPSBwb3ckMihsaWdodG5lc3NbMF0gKyAoZGwgKiBmcmFjdCksIGdhbW1hKTtcbiAgICAgICAgICAgIHZhciBoID0gZGggIT09IDAgPyBodWVbMF0gKyAoZnJhY3QgKiBkaCkgOiBodWU7XG4gICAgICAgICAgICB2YXIgYW1wID0gKGggKiBsICogKDEtbCkpIC8gMjtcbiAgICAgICAgICAgIHZhciBjb3NfYSA9IGNvcyQxKGEpO1xuICAgICAgICAgICAgdmFyIHNpbl9hID0gc2luJDEoYSk7XG4gICAgICAgICAgICB2YXIgciA9IGwgKyAoYW1wICogKCgtMC4xNDg2MSAqIGNvc19hKSArICgxLjc4Mjc3KiBzaW5fYSkpKTtcbiAgICAgICAgICAgIHZhciBnID0gbCArIChhbXAgKiAoKC0wLjI5MjI3ICogY29zX2EpIC0gKDAuOTA2NDkqIHNpbl9hKSkpO1xuICAgICAgICAgICAgdmFyIGIgPSBsICsgKGFtcCAqICgrMS45NzI5NCAqIGNvc19hKSk7XG4gICAgICAgICAgICByZXR1cm4gY2hyb21hJDIoY2xpcF9yZ2IoW3IqMjU1LGcqMjU1LGIqMjU1LDFdKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5zdGFydCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIGlmICgocyA9PSBudWxsKSkgeyByZXR1cm4gc3RhcnQ7IH1cbiAgICAgICAgICAgIHN0YXJ0ID0gcztcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYucm90YXRpb25zID0gZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgaWYgKChyID09IG51bGwpKSB7IHJldHVybiByb3RhdGlvbnM7IH1cbiAgICAgICAgICAgIHJvdGF0aW9ucyA9IHI7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLmdhbW1hID0gZnVuY3Rpb24oZykge1xuICAgICAgICAgICAgaWYgKChnID09IG51bGwpKSB7IHJldHVybiBnYW1tYTsgfVxuICAgICAgICAgICAgZ2FtbWEgPSBnO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5odWUgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICBpZiAoKGggPT0gbnVsbCkpIHsgcmV0dXJuIGh1ZTsgfVxuICAgICAgICAgICAgaHVlID0gaDtcbiAgICAgICAgICAgIGlmICh0eXBlJDEoaHVlKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIGRoID0gaHVlWzFdIC0gaHVlWzBdO1xuICAgICAgICAgICAgICAgIGlmIChkaCA9PT0gMCkgeyBodWUgPSBodWVbMV07IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5saWdodG5lc3MgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICBpZiAoKGggPT0gbnVsbCkpIHsgcmV0dXJuIGxpZ2h0bmVzczsgfVxuICAgICAgICAgICAgaWYgKHR5cGUkMShoKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIGxpZ2h0bmVzcyA9IGg7XG4gICAgICAgICAgICAgICAgZGwgPSBoWzFdIC0gaFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlnaHRuZXNzID0gW2gsaF07XG4gICAgICAgICAgICAgICAgZGwgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5zY2FsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNocm9tYSQyLnNjYWxlKGYpOyB9O1xuXG4gICAgICAgIGYuaHVlKGh1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciQ0ID0gQ29sb3JfMTtcbiAgICB2YXIgZGlnaXRzID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG4gICAgdmFyIGZsb29yJDEgPSBNYXRoLmZsb29yO1xuICAgIHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIHZhciByYW5kb21fMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvZGUgPSAnIyc7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTw2OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgKz0gZGlnaXRzLmNoYXJBdChmbG9vciQxKHJhbmRvbSgpICogMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbG9yJDQoY29kZSwgJ2hleCcpO1xuICAgIH07XG5cbiAgICB2YXIgdHlwZSA9IHR5cGUkcDtcbiAgICB2YXIgbG9nID0gTWF0aC5sb2c7XG4gICAgdmFyIHBvdyQxID0gTWF0aC5wb3c7XG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuXG4gICAgdmFyIGFuYWx5emUgPSBmdW5jdGlvbiAoZGF0YSwga2V5KSB7XG4gICAgICAgIGlmICgga2V5ID09PSB2b2lkIDAgKSBrZXk9bnVsbDtcblxuICAgICAgICB2YXIgciA9IHtcbiAgICAgICAgICAgIG1pbjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIG1heDogTnVtYmVyLk1BWF9WQUxVRSotMSxcbiAgICAgICAgICAgIHN1bTogMCxcbiAgICAgICAgICAgIHZhbHVlczogW10sXG4gICAgICAgICAgICBjb3VudDogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZShkYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRhdGEgPSBPYmplY3QudmFsdWVzKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICYmIHR5cGUodmFsKSA9PT0gJ29iamVjdCcpIHsgdmFsID0gdmFsW2tleV07IH1cbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgICAgICByLnZhbHVlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgci5zdW0gKz0gdmFsO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPCByLm1pbikgeyByLm1pbiA9IHZhbDsgfVxuICAgICAgICAgICAgICAgIGlmICh2YWwgPiByLm1heCkgeyByLm1heCA9IHZhbDsgfVxuICAgICAgICAgICAgICAgIHIuY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgci5kb21haW4gPSBbci5taW4sIHIubWF4XTtcblxuICAgICAgICByLmxpbWl0cyA9IGZ1bmN0aW9uIChtb2RlLCBudW0pIHsgcmV0dXJuIGxpbWl0cyhyLCBtb2RlLCBudW0pOyB9O1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG5cblxuICAgIHZhciBsaW1pdHMgPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSwgbnVtKSB7XG4gICAgICAgIGlmICggbW9kZSA9PT0gdm9pZCAwICkgbW9kZT0nZXF1YWwnO1xuICAgICAgICBpZiAoIG51bSA9PT0gdm9pZCAwICkgbnVtPTc7XG5cbiAgICAgICAgaWYgKHR5cGUoZGF0YSkgPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgZGF0YSA9IGFuYWx5emUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbiA9IGRhdGEubWluO1xuICAgICAgICB2YXIgbWF4ID0gZGF0YS5tYXg7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBkYXRhLnZhbHVlcy5zb3J0KGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIGEtYjsgfSk7XG5cbiAgICAgICAgaWYgKG51bSA9PT0gMSkgeyByZXR1cm4gW21pbixtYXhdOyB9XG5cbiAgICAgICAgdmFyIGxpbWl0cyA9IFtdO1xuXG4gICAgICAgIGlmIChtb2RlLnN1YnN0cigwLDEpID09PSAnYycpIHsgLy8gY29udGludW91c1xuICAgICAgICAgICAgbGltaXRzLnB1c2gobWluKTtcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kZS5zdWJzdHIoMCwxKSA9PT0gJ2UnKSB7IC8vIGVxdWFsIGludGVydmFsXG4gICAgICAgICAgICBsaW1pdHMucHVzaChtaW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0xOyBpPG51bTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGltaXRzLnB1c2gobWluKygoaS9udW0pKihtYXgtbWluKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGltaXRzLnB1c2gobWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKG1vZGUuc3Vic3RyKDAsMSkgPT09ICdsJykgeyAvLyBsb2cgc2NhbGVcbiAgICAgICAgICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9nYXJpdGhtaWMgc2NhbGVzIGFyZSBvbmx5IHBvc3NpYmxlIGZvciB2YWx1ZXMgPiAwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluX2xvZyA9IE1hdGguTE9HMTBFICogbG9nKG1pbik7XG4gICAgICAgICAgICB2YXIgbWF4X2xvZyA9IE1hdGguTE9HMTBFICogbG9nKG1heCk7XG4gICAgICAgICAgICBsaW1pdHMucHVzaChtaW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxPTE7IGkkMTxudW07IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgbGltaXRzLnB1c2gocG93JDEoMTAsIG1pbl9sb2cgKyAoKGkkMS9udW0pICogKG1heF9sb2cgLSBtaW5fbG9nKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChtb2RlLnN1YnN0cigwLDEpID09PSAncScpIHsgLy8gcXVhbnRpbGUgc2NhbGVcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDI9MTsgaSQyPG51bTsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9ICgodmFsdWVzLmxlbmd0aC0xKSAqIGkkMikvbnVtO1xuICAgICAgICAgICAgICAgIHZhciBwYiA9IGZsb29yKHApO1xuICAgICAgICAgICAgICAgIGlmIChwYiA9PT0gcCkge1xuICAgICAgICAgICAgICAgICAgICBsaW1pdHMucHVzaCh2YWx1ZXNbcGJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBwID4gcGJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByID0gcCAtIHBiO1xuICAgICAgICAgICAgICAgICAgICBsaW1pdHMucHVzaCgodmFsdWVzW3BiXSooMS1wcikpICsgKHZhbHVlc1twYisxXSpwcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKG1vZGUuc3Vic3RyKDAsMSkgPT09ICdrJykgeyAvLyBrLW1lYW5zIGNsdXN0ZXJpbmdcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvblxuICAgICAgICAgICAgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2ZpZ3VlL3NvdXJjZS9icm93c2UvdHJ1bmsvZmlndWUuanMjMzM2XG4gICAgICAgICAgICBzaW1wbGlmaWVkIGZvciAxLWQgaW5wdXQgdmFsdWVzXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGNsdXN0ZXI7XG4gICAgICAgICAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXNzaWdubWVudHMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICB2YXIgY2x1c3RlclNpemVzID0gbmV3IEFycmF5KG51bSk7XG4gICAgICAgICAgICB2YXIgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBuYl9pdGVycyA9IDA7XG4gICAgICAgICAgICB2YXIgY2VudHJvaWRzID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gZ2V0IHNlZWQgdmFsdWVzXG4gICAgICAgICAgICBjZW50cm9pZHMgPSBbXTtcbiAgICAgICAgICAgIGNlbnRyb2lkcy5wdXNoKG1pbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDM9MTsgaSQzPG51bTsgaSQzKyspIHtcbiAgICAgICAgICAgICAgICBjZW50cm9pZHMucHVzaChtaW4gKyAoKGkkMy9udW0pICogKG1heC1taW4pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZW50cm9pZHMucHVzaChtYXgpO1xuXG4gICAgICAgICAgICB3aGlsZSAocmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzaWdubWVudCBzdGVwXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPG51bTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJTaXplc1tqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkND0wOyBpJDQ8bjsgaSQ0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2kkNF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5kaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlc3QgPSAodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiQxPTA7IGokMTxudW07IGokMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGFicyQxKGNlbnRyb2lkc1tqJDFdLXZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgbWluZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QgPSBqJDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyU2l6ZXNbYmVzdF0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzW2kkNF0gPSBiZXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNlbnRyb2lkcyBzdGVwXG4gICAgICAgICAgICAgICAgdmFyIG5ld0NlbnRyb2lkcyA9IG5ldyBBcnJheShudW0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGokMj0wOyBqJDI8bnVtOyBqJDIrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdDZW50cm9pZHNbaiQyXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkNT0wOyBpJDU8bjsgaSQ1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlciA9IGFzc2lnbm1lbnRzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDZW50cm9pZHNbY2x1c3Rlcl0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tjbHVzdGVyXSA9IHZhbHVlc1tpJDVdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2NsdXN0ZXJdICs9IHZhbHVlc1tpJDVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGokMz0wOyBqJDM8bnVtOyBqJDMrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdDZW50cm9pZHNbaiQzXSAqPSAxL2NsdXN0ZXJTaXplc1tqJDNdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNvbnZlcmdlbmNlXG4gICAgICAgICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQ0PTA7IGokNDxudW07IGokNCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDZW50cm9pZHNbaiQ0XSAhPT0gY2VudHJvaWRzW2okNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNlbnRyb2lkcyA9IG5ld0NlbnRyb2lkcztcbiAgICAgICAgICAgICAgICBuYl9pdGVycysrO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5iX2l0ZXJzID4gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmluaXNoZWQgay1tZWFucyBjbHVzdGVyaW5nXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCBwYXJ0IGlzIGJvcnJvd2VkIGZyb20gZ2FicmllbGZsb3IuaXRcbiAgICAgICAgICAgIHZhciBrQ2x1c3RlcnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGokNT0wOyBqJDU8bnVtOyBqJDUrKykge1xuICAgICAgICAgICAgICAgIGtDbHVzdGVyc1tqJDVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpJDY9MDsgaSQ2PG47IGkkNisrKSB7XG4gICAgICAgICAgICAgICAgY2x1c3RlciA9IGFzc2lnbm1lbnRzW2kkNl07XG4gICAgICAgICAgICAgICAga0NsdXN0ZXJzW2NsdXN0ZXJdLnB1c2godmFsdWVzW2kkNl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRtcEtNZWFuc0JyZWFrcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiQ2PTA7IGokNjxudW07IGokNisrKSB7XG4gICAgICAgICAgICAgICAgdG1wS01lYW5zQnJlYWtzLnB1c2goa0NsdXN0ZXJzW2okNl1bMF0pO1xuICAgICAgICAgICAgICAgIHRtcEtNZWFuc0JyZWFrcy5wdXNoKGtDbHVzdGVyc1tqJDZdW2tDbHVzdGVyc1tqJDZdLmxlbmd0aC0xXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0bXBLTWVhbnNCcmVha3MgPSB0bXBLTWVhbnNCcmVha3Muc29ydChmdW5jdGlvbiAoYSxiKXsgcmV0dXJuIGEtYjsgfSk7XG4gICAgICAgICAgICBsaW1pdHMucHVzaCh0bXBLTWVhbnNCcmVha3NbMF0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQ3PTE7IGkkNyA8IHRtcEtNZWFuc0JyZWFrcy5sZW5ndGg7IGkkNys9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHRtcEtNZWFuc0JyZWFrc1tpJDddO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odikgJiYgKGxpbWl0cy5pbmRleE9mKHYpID09PSAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGltaXRzLnB1c2godik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW1pdHM7XG4gICAgfTtcblxuICAgIHZhciBhbmFseXplXzEgPSB7YW5hbHl6ZTogYW5hbHl6ZSwgbGltaXRzOiBsaW1pdHN9O1xuXG4gICAgdmFyIENvbG9yJDMgPSBDb2xvcl8xO1xuXG5cbiAgICB2YXIgY29udHJhc3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAvLyBXQ0FHIGNvbnRyYXN0IHJhdGlvXG4gICAgICAgIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI2NvbnRyYXN0LXJhdGlvZGVmXG4gICAgICAgIGEgPSBuZXcgQ29sb3IkMyhhKTtcbiAgICAgICAgYiA9IG5ldyBDb2xvciQzKGIpO1xuICAgICAgICB2YXIgbDEgPSBhLmx1bWluYW5jZSgpO1xuICAgICAgICB2YXIgbDIgPSBiLmx1bWluYW5jZSgpO1xuICAgICAgICByZXR1cm4gbDEgPiBsMiA/IChsMSArIDAuMDUpIC8gKGwyICsgMC4wNSkgOiAobDIgKyAwLjA1KSAvIChsMSArIDAuMDUpO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkMiA9IENvbG9yXzE7XG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIHBvdyA9IE1hdGgucG93O1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbiAgICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIGNvcyA9IE1hdGguY29zO1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgZXhwID0gTWF0aC5leHA7XG4gICAgdmFyIFBJID0gTWF0aC5QSTtcblxuICAgIHZhciBkZWx0YUUgPSBmdW5jdGlvbihhLCBiLCBLbCwgS2MsIEtoKSB7XG4gICAgICAgIGlmICggS2wgPT09IHZvaWQgMCApIEtsPTE7XG4gICAgICAgIGlmICggS2MgPT09IHZvaWQgMCApIEtjPTE7XG4gICAgICAgIGlmICggS2ggPT09IHZvaWQgMCApIEtoPTE7XG5cbiAgICAgICAgLy8gRGVsdGEgRSAoQ0lFIDIwMDApXG4gICAgICAgIC8vIHNlZSBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0Vxbl9EZWx0YUVfQ0lFMjAwMC5odG1sXG4gICAgICAgIHZhciByYWQyZGVnID0gZnVuY3Rpb24ocmFkKSB7XG4gICAgICAgICAgICByZXR1cm4gMzYwICogcmFkIC8gKDIgKiBQSSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZWcycmFkID0gZnVuY3Rpb24oZGVnKSB7XG4gICAgICAgICAgICByZXR1cm4gKDIgKiBQSSAqIGRlZykgLyAzNjA7XG4gICAgICAgIH07XG4gICAgICAgIGEgPSBuZXcgQ29sb3IkMihhKTtcbiAgICAgICAgYiA9IG5ldyBDb2xvciQyKGIpO1xuICAgICAgICB2YXIgcmVmID0gQXJyYXkuZnJvbShhLmxhYigpKTtcbiAgICAgICAgdmFyIEwxID0gcmVmWzBdO1xuICAgICAgICB2YXIgYTEgPSByZWZbMV07XG4gICAgICAgIHZhciBiMSA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gQXJyYXkuZnJvbShiLmxhYigpKTtcbiAgICAgICAgdmFyIEwyID0gcmVmJDFbMF07XG4gICAgICAgIHZhciBhMiA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgYjIgPSByZWYkMVsyXTtcbiAgICAgICAgdmFyIGF2Z0wgPSAoTDEgKyBMMikvMjtcbiAgICAgICAgdmFyIEMxID0gc3FydChwb3coYTEsIDIpICsgcG93KGIxLCAyKSk7XG4gICAgICAgIHZhciBDMiA9IHNxcnQocG93KGEyLCAyKSArIHBvdyhiMiwgMikpO1xuICAgICAgICB2YXIgYXZnQyA9IChDMSArIEMyKS8yO1xuICAgICAgICB2YXIgRyA9IDAuNSooMS1zcXJ0KHBvdyhhdmdDLCA3KS8ocG93KGF2Z0MsIDcpICsgcG93KDI1LCA3KSkpKTtcbiAgICAgICAgdmFyIGExcCA9IGExKigxK0cpO1xuICAgICAgICB2YXIgYTJwID0gYTIqKDErRyk7XG4gICAgICAgIHZhciBDMXAgPSBzcXJ0KHBvdyhhMXAsIDIpICsgcG93KGIxLCAyKSk7XG4gICAgICAgIHZhciBDMnAgPSBzcXJ0KHBvdyhhMnAsIDIpICsgcG93KGIyLCAyKSk7XG4gICAgICAgIHZhciBhdmdDcCA9IChDMXAgKyBDMnApLzI7XG4gICAgICAgIHZhciBhcmN0YW4xID0gcmFkMmRlZyhhdGFuMihiMSwgYTFwKSk7XG4gICAgICAgIHZhciBhcmN0YW4yID0gcmFkMmRlZyhhdGFuMihiMiwgYTJwKSk7XG4gICAgICAgIHZhciBoMXAgPSBhcmN0YW4xID49IDAgPyBhcmN0YW4xIDogYXJjdGFuMSArIDM2MDtcbiAgICAgICAgdmFyIGgycCA9IGFyY3RhbjIgPj0gMCA/IGFyY3RhbjIgOiBhcmN0YW4yICsgMzYwO1xuICAgICAgICB2YXIgYXZnSHAgPSBhYnMoaDFwIC0gaDJwKSA+IDE4MCA/IChoMXAgKyBoMnAgKyAzNjApLzIgOiAoaDFwICsgaDJwKS8yO1xuICAgICAgICB2YXIgVCA9IDEgLSAwLjE3KmNvcyhkZWcycmFkKGF2Z0hwIC0gMzApKSArIDAuMjQqY29zKGRlZzJyYWQoMiphdmdIcCkpICsgMC4zMipjb3MoZGVnMnJhZCgzKmF2Z0hwICsgNikpIC0gMC4yKmNvcyhkZWcycmFkKDQqYXZnSHAgLSA2MykpO1xuICAgICAgICB2YXIgZGVsdGFIcCA9IGgycCAtIGgxcDtcbiAgICAgICAgZGVsdGFIcCA9IGFicyhkZWx0YUhwKSA8PSAxODAgPyBkZWx0YUhwIDogaDJwIDw9IGgxcCA/IGRlbHRhSHAgKyAzNjAgOiBkZWx0YUhwIC0gMzYwO1xuICAgICAgICBkZWx0YUhwID0gMipzcXJ0KEMxcCpDMnApKnNpbihkZWcycmFkKGRlbHRhSHApLzIpO1xuICAgICAgICB2YXIgZGVsdGFMID0gTDIgLSBMMTtcbiAgICAgICAgdmFyIGRlbHRhQ3AgPSBDMnAgLSBDMXA7ICAgIFxuICAgICAgICB2YXIgc2wgPSAxICsgKDAuMDE1KnBvdyhhdmdMIC0gNTAsIDIpKS9zcXJ0KDIwICsgcG93KGF2Z0wgLSA1MCwgMikpO1xuICAgICAgICB2YXIgc2MgPSAxICsgMC4wNDUqYXZnQ3A7XG4gICAgICAgIHZhciBzaCA9IDEgKyAwLjAxNSphdmdDcCpUO1xuICAgICAgICB2YXIgZGVsdGFUaGV0YSA9IDMwKmV4cCgtcG93KChhdmdIcCAtIDI3NSkvMjUsIDIpKTtcbiAgICAgICAgdmFyIFJjID0gMipzcXJ0KHBvdyhhdmdDcCwgNykvKHBvdyhhdmdDcCwgNykgKyBwb3coMjUsIDcpKSk7XG4gICAgICAgIHZhciBSdCA9IC1SYypzaW4oMipkZWcycmFkKGRlbHRhVGhldGEpKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNxcnQocG93KGRlbHRhTC8oS2wqc2wpLCAyKSArIHBvdyhkZWx0YUNwLyhLYypzYyksIDIpICsgcG93KGRlbHRhSHAvKEtoKnNoKSwgMikgKyBSdCooZGVsdGFDcC8oS2Mqc2MpKSooZGVsdGFIcC8oS2gqc2gpKSk7XG4gICAgICAgIHJldHVybiBtYXgoMCwgbWluKDEwMCwgcmVzdWx0KSk7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciQxID0gQ29sb3JfMTtcblxuICAgIC8vIHNpbXBsZSBFdWNsaWRlYW4gZGlzdGFuY2VcbiAgICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiLCBtb2RlKSB7XG4gICAgICAgIGlmICggbW9kZSA9PT0gdm9pZCAwICkgbW9kZT0nbGFiJztcblxuICAgICAgICAvLyBEZWx0YSBFIChDSUUgMTk3NilcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXF1YXRpb25zLmh0bWxcbiAgICAgICAgYSA9IG5ldyBDb2xvciQxKGEpO1xuICAgICAgICBiID0gbmV3IENvbG9yJDEoYik7XG4gICAgICAgIHZhciBsMSA9IGEuZ2V0KG1vZGUpO1xuICAgICAgICB2YXIgbDIgPSBiLmdldChtb2RlKTtcbiAgICAgICAgdmFyIHN1bV9zcSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgaW4gbDEpIHtcbiAgICAgICAgICAgIHZhciBkID0gKGwxW2ldIHx8IDApIC0gKGwyW2ldIHx8IDApO1xuICAgICAgICAgICAgc3VtX3NxICs9IGQqZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHN1bV9zcSk7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciA9IENvbG9yXzE7XG5cbiAgICB2YXIgdmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MpICkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzb21lIHByZS1kZWZpbmVkIGNvbG9yIHNjYWxlczpcbiAgICB2YXIgY2hyb21hJDEgPSBjaHJvbWFfMTtcblxuICAgIHZhciBzY2FsZSA9IHNjYWxlJDI7XG5cbiAgICB2YXIgc2NhbGVzID0ge1xuICAgIFx0Y29vbDogZnVuY3Rpb24gY29vbCgpIHsgcmV0dXJuIHNjYWxlKFtjaHJvbWEkMS5oc2woMTgwLDEsLjkpLCBjaHJvbWEkMS5oc2woMjUwLC43LC40KV0pIH0sXG4gICAgXHRob3Q6IGZ1bmN0aW9uIGhvdCgpIHsgcmV0dXJuIHNjYWxlKFsnIzAwMCcsJyNmMDAnLCcjZmYwJywnI2ZmZiddKS5tb2RlKCdyZ2InKSB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgICBDb2xvckJyZXdlciBjb2xvcnMgZm9yIGNocm9tYS5qc1xuXG4gICAgICAgIENvcHlyaWdodCAoYykgMjAwMiBDeW50aGlhIEJyZXdlciwgTWFyayBIYXJyb3dlciwgYW5kIFRoZVxuICAgICAgICBQZW5uc3lsdmFuaWEgU3RhdGUgVW5pdmVyc2l0eS5cblxuICAgICAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAgICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgICAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkXG4gICAgICAgIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SXG4gICAgICAgIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gICAgICAgIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cblxuICAgIHZhciBjb2xvcmJyZXdlciA9IHtcbiAgICAgICAgLy8gc2VxdWVudGlhbFxuICAgICAgICBPclJkOiBbJyNmZmY3ZWMnLCAnI2ZlZThjOCcsICcjZmRkNDllJywgJyNmZGJiODQnLCAnI2ZjOGQ1OScsICcjZWY2NTQ4JywgJyNkNzMwMWYnLCAnI2IzMDAwMCcsICcjN2YwMDAwJ10sXG4gICAgICAgIFB1QnU6IFsnI2ZmZjdmYicsICcjZWNlN2YyJywgJyNkMGQxZTYnLCAnI2E2YmRkYicsICcjNzRhOWNmJywgJyMzNjkwYzAnLCAnIzA1NzBiMCcsICcjMDQ1YThkJywgJyMwMjM4NTgnXSxcbiAgICAgICAgQnVQdTogWycjZjdmY2ZkJywgJyNlMGVjZjQnLCAnI2JmZDNlNicsICcjOWViY2RhJywgJyM4Yzk2YzYnLCAnIzhjNmJiMScsICcjODg0MTlkJywgJyM4MTBmN2MnLCAnIzRkMDA0YiddLFxuICAgICAgICBPcmFuZ2VzOiBbJyNmZmY1ZWInLCAnI2ZlZTZjZScsICcjZmRkMGEyJywgJyNmZGFlNmInLCAnI2ZkOGQzYycsICcjZjE2OTEzJywgJyNkOTQ4MDEnLCAnI2E2MzYwMycsICcjN2YyNzA0J10sXG4gICAgICAgIEJ1R246IFsnI2Y3ZmNmZCcsICcjZTVmNWY5JywgJyNjY2VjZTYnLCAnIzk5ZDhjOScsICcjNjZjMmE0JywgJyM0MWFlNzYnLCAnIzIzOGI0NScsICcjMDA2ZDJjJywgJyMwMDQ0MWInXSxcbiAgICAgICAgWWxPckJyOiBbJyNmZmZmZTUnLCAnI2ZmZjdiYycsICcjZmVlMzkxJywgJyNmZWM0NGYnLCAnI2ZlOTkyOScsICcjZWM3MDE0JywgJyNjYzRjMDInLCAnIzk5MzQwNCcsICcjNjYyNTA2J10sXG4gICAgICAgIFlsR246IFsnI2ZmZmZlNScsICcjZjdmY2I5JywgJyNkOWYwYTMnLCAnI2FkZGQ4ZScsICcjNzhjNjc5JywgJyM0MWFiNWQnLCAnIzIzODQ0MycsICcjMDA2ODM3JywgJyMwMDQ1MjknXSxcbiAgICAgICAgUmVkczogWycjZmZmNWYwJywgJyNmZWUwZDInLCAnI2ZjYmJhMScsICcjZmM5MjcyJywgJyNmYjZhNGEnLCAnI2VmM2IyYycsICcjY2IxODFkJywgJyNhNTBmMTUnLCAnIzY3MDAwZCddLFxuICAgICAgICBSZFB1OiBbJyNmZmY3ZjMnLCAnI2ZkZTBkZCcsICcjZmNjNWMwJywgJyNmYTlmYjUnLCAnI2Y3NjhhMScsICcjZGQzNDk3JywgJyNhZTAxN2UnLCAnIzdhMDE3NycsICcjNDkwMDZhJ10sXG4gICAgICAgIEdyZWVuczogWycjZjdmY2Y1JywgJyNlNWY1ZTAnLCAnI2M3ZTljMCcsICcjYTFkOTliJywgJyM3NGM0NzYnLCAnIzQxYWI1ZCcsICcjMjM4YjQ1JywgJyMwMDZkMmMnLCAnIzAwNDQxYiddLFxuICAgICAgICBZbEduQnU6IFsnI2ZmZmZkOScsICcjZWRmOGIxJywgJyNjN2U5YjQnLCAnIzdmY2RiYicsICcjNDFiNmM0JywgJyMxZDkxYzAnLCAnIzIyNWVhOCcsICcjMjUzNDk0JywgJyMwODFkNTgnXSxcbiAgICAgICAgUHVycGxlczogWycjZmNmYmZkJywgJyNlZmVkZjUnLCAnI2RhZGFlYicsICcjYmNiZGRjJywgJyM5ZTlhYzgnLCAnIzgwN2RiYScsICcjNmE1MWEzJywgJyM1NDI3OGYnLCAnIzNmMDA3ZCddLFxuICAgICAgICBHbkJ1OiBbJyNmN2ZjZjAnLCAnI2UwZjNkYicsICcjY2NlYmM1JywgJyNhOGRkYjUnLCAnIzdiY2NjNCcsICcjNGViM2QzJywgJyMyYjhjYmUnLCAnIzA4NjhhYycsICcjMDg0MDgxJ10sXG4gICAgICAgIEdyZXlzOiBbJyNmZmZmZmYnLCAnI2YwZjBmMCcsICcjZDlkOWQ5JywgJyNiZGJkYmQnLCAnIzk2OTY5NicsICcjNzM3MzczJywgJyM1MjUyNTInLCAnIzI1MjUyNScsICcjMDAwMDAwJ10sXG4gICAgICAgIFlsT3JSZDogWycjZmZmZmNjJywgJyNmZmVkYTAnLCAnI2ZlZDk3NicsICcjZmViMjRjJywgJyNmZDhkM2MnLCAnI2ZjNGUyYScsICcjZTMxYTFjJywgJyNiZDAwMjYnLCAnIzgwMDAyNiddLFxuICAgICAgICBQdVJkOiBbJyNmN2Y0ZjknLCAnI2U3ZTFlZicsICcjZDRiOWRhJywgJyNjOTk0YzcnLCAnI2RmNjViMCcsICcjZTcyOThhJywgJyNjZTEyNTYnLCAnIzk4MDA0MycsICcjNjcwMDFmJ10sXG4gICAgICAgIEJsdWVzOiBbJyNmN2ZiZmYnLCAnI2RlZWJmNycsICcjYzZkYmVmJywgJyM5ZWNhZTEnLCAnIzZiYWVkNicsICcjNDI5MmM2JywgJyMyMTcxYjUnLCAnIzA4NTE5YycsICcjMDgzMDZiJ10sXG4gICAgICAgIFB1QnVHbjogWycjZmZmN2ZiJywgJyNlY2UyZjAnLCAnI2QwZDFlNicsICcjYTZiZGRiJywgJyM2N2E5Y2YnLCAnIzM2OTBjMCcsICcjMDI4MThhJywgJyMwMTZjNTknLCAnIzAxNDYzNiddLFxuICAgICAgICBWaXJpZGlzOiBbJyM0NDAxNTQnLCAnIzQ4Mjc3NycsICcjM2Y0YThhJywgJyMzMTY3OGUnLCAnIzI2ODM4ZicsICcjMWY5ZDhhJywgJyM2Y2NlNWEnLCAnI2I2ZGUyYicsICcjZmVlODI1J10sXG5cbiAgICAgICAgLy8gZGl2ZXJnaW5nXG5cbiAgICAgICAgU3BlY3RyYWw6IFsnIzllMDE0MicsICcjZDUzZTRmJywgJyNmNDZkNDMnLCAnI2ZkYWU2MScsICcjZmVlMDhiJywgJyNmZmZmYmYnLCAnI2U2ZjU5OCcsICcjYWJkZGE0JywgJyM2NmMyYTUnLCAnIzMyODhiZCcsICcjNWU0ZmEyJ10sXG4gICAgICAgIFJkWWxHbjogWycjYTUwMDI2JywgJyNkNzMwMjcnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOGInLCAnI2ZmZmZiZicsICcjZDllZjhiJywgJyNhNmQ5NmEnLCAnIzY2YmQ2MycsICcjMWE5ODUwJywgJyMwMDY4MzcnXSxcbiAgICAgICAgUmRCdTogWycjNjcwMDFmJywgJyNiMjE4MmInLCAnI2Q2NjA0ZCcsICcjZjRhNTgyJywgJyNmZGRiYzcnLCAnI2Y3ZjdmNycsICcjZDFlNWYwJywgJyM5MmM1ZGUnLCAnIzQzOTNjMycsICcjMjE2NmFjJywgJyMwNTMwNjEnXSxcbiAgICAgICAgUGlZRzogWycjOGUwMTUyJywgJyNjNTFiN2QnLCAnI2RlNzdhZScsICcjZjFiNmRhJywgJyNmZGUwZWYnLCAnI2Y3ZjdmNycsICcjZTZmNWQwJywgJyNiOGUxODYnLCAnIzdmYmM0MScsICcjNGQ5MjIxJywgJyMyNzY0MTknXSxcbiAgICAgICAgUFJHbjogWycjNDAwMDRiJywgJyM3NjJhODMnLCAnIzk5NzBhYicsICcjYzJhNWNmJywgJyNlN2Q0ZTgnLCAnI2Y3ZjdmNycsICcjZDlmMGQzJywgJyNhNmRiYTAnLCAnIzVhYWU2MScsICcjMWI3ODM3JywgJyMwMDQ0MWInXSxcbiAgICAgICAgUmRZbEJ1OiBbJyNhNTAwMjYnLCAnI2Q3MzAyNycsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA5MCcsICcjZmZmZmJmJywgJyNlMGYzZjgnLCAnI2FiZDllOScsICcjNzRhZGQxJywgJyM0NTc1YjQnLCAnIzMxMzY5NSddLFxuICAgICAgICBCckJHOiBbJyM1NDMwMDUnLCAnIzhjNTEwYScsICcjYmY4MTJkJywgJyNkZmMyN2QnLCAnI2Y2ZThjMycsICcjZjVmNWY1JywgJyNjN2VhZTUnLCAnIzgwY2RjMScsICcjMzU5NzhmJywgJyMwMTY2NWUnLCAnIzAwM2MzMCddLFxuICAgICAgICBSZEd5OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZmZmZmZmJywgJyNlMGUwZTAnLCAnI2JhYmFiYScsICcjODc4Nzg3JywgJyM0ZDRkNGQnLCAnIzFhMWExYSddLFxuICAgICAgICBQdU9yOiBbJyM3ZjNiMDgnLCAnI2IzNTgwNicsICcjZTA4MjE0JywgJyNmZGI4NjMnLCAnI2ZlZTBiNicsICcjZjdmN2Y3JywgJyNkOGRhZWInLCAnI2IyYWJkMicsICcjODA3M2FjJywgJyM1NDI3ODgnLCAnIzJkMDA0YiddLFxuXG4gICAgICAgIC8vIHF1YWxpdGF0aXZlXG5cbiAgICAgICAgU2V0MjogWycjNjZjMmE1JywgJyNmYzhkNjInLCAnIzhkYTBjYicsICcjZTc4YWMzJywgJyNhNmQ4NTQnLCAnI2ZmZDkyZicsICcjZTVjNDk0JywgJyNiM2IzYjMnXSxcbiAgICAgICAgQWNjZW50OiBbJyM3ZmM5N2YnLCAnI2JlYWVkNCcsICcjZmRjMDg2JywgJyNmZmZmOTknLCAnIzM4NmNiMCcsICcjZjAwMjdmJywgJyNiZjViMTcnLCAnIzY2NjY2NiddLFxuICAgICAgICBTZXQxOiBbJyNlNDFhMWMnLCAnIzM3N2ViOCcsICcjNGRhZjRhJywgJyM5ODRlYTMnLCAnI2ZmN2YwMCcsICcjZmZmZjMzJywgJyNhNjU2MjgnLCAnI2Y3ODFiZicsICcjOTk5OTk5J10sXG4gICAgICAgIFNldDM6IFsnIzhkZDNjNycsICcjZmZmZmIzJywgJyNiZWJhZGEnLCAnI2ZiODA3MicsICcjODBiMWQzJywgJyNmZGI0NjInLCAnI2IzZGU2OScsICcjZmNjZGU1JywgJyNkOWQ5ZDknLCAnI2JjODBiZCcsICcjY2NlYmM1JywgJyNmZmVkNmYnXSxcbiAgICAgICAgRGFyazI6IFsnIzFiOWU3NycsICcjZDk1ZjAyJywgJyM3NTcwYjMnLCAnI2U3Mjk4YScsICcjNjZhNjFlJywgJyNlNmFiMDInLCAnI2E2NzYxZCcsICcjNjY2NjY2J10sXG4gICAgICAgIFBhaXJlZDogWycjYTZjZWUzJywgJyMxZjc4YjQnLCAnI2IyZGY4YScsICcjMzNhMDJjJywgJyNmYjlhOTknLCAnI2UzMWExYycsICcjZmRiZjZmJywgJyNmZjdmMDAnLCAnI2NhYjJkNicsICcjNmEzZDlhJywgJyNmZmZmOTknLCAnI2IxNTkyOCddLFxuICAgICAgICBQYXN0ZWwyOiBbJyNiM2UyY2QnLCAnI2ZkY2RhYycsICcjY2JkNWU4JywgJyNmNGNhZTQnLCAnI2U2ZjVjOScsICcjZmZmMmFlJywgJyNmMWUyY2MnLCAnI2NjY2NjYyddLFxuICAgICAgICBQYXN0ZWwxOiBbJyNmYmI0YWUnLCAnI2IzY2RlMycsICcjY2NlYmM1JywgJyNkZWNiZTQnLCAnI2ZlZDlhNicsICcjZmZmZmNjJywgJyNlNWQ4YmQnLCAnI2ZkZGFlYycsICcjZjJmMmYyJ10sXG4gICAgfTtcblxuICAgIC8vIGFkZCBsb3dlcmNhc2UgYWxpYXNlcyBmb3IgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyhjb2xvcmJyZXdlcik7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBrZXkgPSBsaXN0W2ldO1xuXG4gICAgICAgIGNvbG9yYnJld2VyW2tleS50b0xvd2VyQ2FzZSgpXSA9IGNvbG9yYnJld2VyW2tleV07XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yYnJld2VyXzEgPSBjb2xvcmJyZXdlcjtcblxuICAgIHZhciBjaHJvbWEgPSBjaHJvbWFfMTtcblxuICAgIC8vIGZlZWwgZnJlZSB0byBjb21tZW50IG91dCBhbnl0aGluZyB0byByb2xsdXBcbiAgICAvLyBhIHNtYWxsZXIgY2hyb21hLmpzIGJ1aWx0XG5cbiAgICAvLyBpbyAtLT4gY29udmVydCBjb2xvcnNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgLy8gb3BlcmF0b3JzIC0tPiBtb2RpZnkgZXhpc3RpbmcgQ29sb3JzXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAvLyBpbnRlcnBvbGF0b3JzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgLy8gZ2VuZXJhdG9ycyAtLSA+IGNyZWF0ZSBuZXcgY29sb3JzXG4gICAgY2hyb21hLmF2ZXJhZ2UgPSBhdmVyYWdlO1xuICAgIGNocm9tYS5iZXppZXIgPSBiZXppZXJfMTtcbiAgICBjaHJvbWEuYmxlbmQgPSBibGVuZF8xO1xuICAgIGNocm9tYS5jdWJlaGVsaXggPSBjdWJlaGVsaXg7XG4gICAgY2hyb21hLm1peCA9IGNocm9tYS5pbnRlcnBvbGF0ZSA9IG1peCQxO1xuICAgIGNocm9tYS5yYW5kb20gPSByYW5kb21fMTtcbiAgICBjaHJvbWEuc2NhbGUgPSBzY2FsZSQyO1xuXG4gICAgLy8gb3RoZXIgdXRpbGl0eSBtZXRob2RzXG4gICAgY2hyb21hLmFuYWx5emUgPSBhbmFseXplXzEuYW5hbHl6ZTtcbiAgICBjaHJvbWEuY29udHJhc3QgPSBjb250cmFzdDtcbiAgICBjaHJvbWEuZGVsdGFFID0gZGVsdGFFO1xuICAgIGNocm9tYS5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIGNocm9tYS5saW1pdHMgPSBhbmFseXplXzEubGltaXRzO1xuICAgIGNocm9tYS52YWxpZCA9IHZhbGlkO1xuXG4gICAgLy8gc2NhbGVcbiAgICBjaHJvbWEuc2NhbGVzID0gc2NhbGVzO1xuXG4gICAgLy8gY29sb3JzXG4gICAgY2hyb21hLmNvbG9ycyA9IHczY3gxMV8xO1xuICAgIGNocm9tYS5icmV3ZXIgPSBjb2xvcmJyZXdlcl8xO1xuXG4gICAgdmFyIGNocm9tYV9qcyA9IGNocm9tYTtcblxuICAgIHJldHVybiBjaHJvbWFfanM7XG5cbn0pKTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmIgPSBkb2N1bWVudC5iYXNlVVJJIHx8IHNlbGYubG9jYXRpb24uaHJlZjtcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3Ncbi8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuLy8gW3Jlc29sdmUsIHJlamVjdCwgUHJvbWlzZV0gPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG52YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuXHQxNzk6IDBcbn07XG5cbi8vIG5vIGNodW5rIG9uIGRlbWFuZCBsb2FkaW5nXG5cbi8vIG5vIHByZWZldGNoaW5nXG5cbi8vIG5vIHByZWxvYWRlZFxuXG4vLyBubyBITVJcblxuLy8gbm8gSE1SIG1hbmlmZXN0XG5cbi8vIG5vIG9uIGNodW5rcyBsb2FkZWRcblxuLy8gbm8ganNvbnAgZnVuY3Rpb24iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5jID0gdW5kZWZpbmVkOyIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0gKHgpID0+IHg7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBTXG4gKiBAcGFyYW0ge1R9IHRhclxuICogQHBhcmFtIHtTfSBzcmNcbiAqIEByZXR1cm5zIHtUICYgU31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuXHQvLyBAdHMtaWdub3JlXG5cdGZvciAoY29uc3QgayBpbiBzcmMpIHRhcltrXSA9IHNyY1trXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VCAmIFN9ICovICh0YXIpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFByb21pc2VMaWtlPGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG5cdHJldHVybiAoXG5cdFx0ISF2YWx1ZSAmJlxuXHRcdCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiZcblx0XHR0eXBlb2YgKC8qKiBAdHlwZSB7YW55fSAqLyAodmFsdWUpLnRoZW4pID09PSAnZnVuY3Rpb24nXG5cdCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG5cdGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcblx0XHRsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cblx0fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bihmbikge1xuXHRyZXR1cm4gZm4oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsYW5rX29iamVjdCgpIHtcblx0cmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbltdfSBmbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcblx0Zm5zLmZvckVhY2gocnVuKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdGhpbmdcbiAqIEByZXR1cm5zIHt0aGluZyBpcyBGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG5cdHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8IChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG59XG5cbmxldCBzcmNfdXJsX2VxdWFsX2FuY2hvcjtcblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuXHRpZiAoIXNyY191cmxfZXF1YWxfYW5jaG9yKSB7XG5cdFx0c3JjX3VybF9lcXVhbF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdH1cblx0c3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZiA9IHVybDtcblx0cmV0dXJuIGVsZW1lbnRfc3JjID09PSBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcblx0cmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGI7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19lbXB0eShvYmopIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcblx0aWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcblx0aWYgKHN0b3JlID09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuXHRcdFx0Y2FsbGJhY2sodW5kZWZpbmVkKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vb3A7XG5cdH1cblx0Y29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcblx0cmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBmcm9tIGEgc3RvcmUgYnkgc3Vic2NyaWJpbmcgYW5kIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJpbmcuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI2dldFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9zdG9yZS9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn0gc3RvcmVcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N0b3JlX3ZhbHVlKHN0b3JlKSB7XG5cdGxldCB2YWx1ZTtcblx0c3Vic2NyaWJlKHN0b3JlLCAoXykgPT4gKHZhbHVlID0gXykpKCk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcblx0Y29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG5cdGlmIChkZWZpbml0aW9uKSB7XG5cdFx0Y29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuXHRcdHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcblx0cmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm4gPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSkgOiAkJHNjb3BlLmN0eDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG5cdGlmIChkZWZpbml0aW9uWzJdICYmIGZuKSB7XG5cdFx0Y29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcblx0XHRpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbGV0cztcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Y29uc3QgbWVyZ2VkID0gW107XG5cdFx0XHRjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuXHRcdFx0XHRtZXJnZWRbaV0gPSAkJHNjb3BlLmRpcnR5W2ldIHwgbGV0c1tpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZXJnZWQ7XG5cdFx0fVxuXHRcdHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcblx0fVxuXHRyZXR1cm4gJCRzY29wZS5kaXJ0eTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zbG90X2Jhc2UoXG5cdHNsb3QsXG5cdHNsb3RfZGVmaW5pdGlvbixcblx0Y3R4LFxuXHQkJHNjb3BlLFxuXHRzbG90X2NoYW5nZXMsXG5cdGdldF9zbG90X2NvbnRleHRfZm5cbikge1xuXHRpZiAoc2xvdF9jaGFuZ2VzKSB7XG5cdFx0Y29uc3Qgc2xvdF9jb250ZXh0ID0gZ2V0X3Nsb3RfY29udGV4dChzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG5cdFx0c2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3Nsb3QoXG5cdHNsb3QsXG5cdHNsb3RfZGVmaW5pdGlvbixcblx0Y3R4LFxuXHQkJHNjb3BlLFxuXHRkaXJ0eSxcblx0Z2V0X3Nsb3RfY2hhbmdlc19mbixcblx0Z2V0X3Nsb3RfY29udGV4dF9mblxuKSB7XG5cdGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG5cdHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG59XG5cbi8qKiBAcmV0dXJucyB7YW55W10gfCAtMX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUoJCRzY29wZSkge1xuXHRpZiAoJCRzY29wZS5jdHgubGVuZ3RoID4gMzIpIHtcblx0XHRjb25zdCBkaXJ0eSA9IFtdO1xuXHRcdGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGRpcnR5W2ldID0gLTE7XG5cdFx0fVxuXHRcdHJldHVybiBkaXJ0eTtcblx0fVxuXHRyZXR1cm4gLTE7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBrIGluIHByb3BzKSBpZiAoa1swXSAhPT0gJyQnKSByZXN1bHRba10gPSBwcm9wc1trXTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcblx0Y29uc3QgcmVzdCA9IHt9O1xuXHRrZXlzID0gbmV3IFNldChrZXlzKTtcblx0Zm9yIChjb25zdCBrIGluIHByb3BzKSBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJykgcmVzdFtrXSA9IHByb3BzW2tdO1xuXHRyZXR1cm4gcmVzdDtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuXHRcdHJlc3VsdFtrZXldID0gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQHJldHVybnMgeyh0aGlzOiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uY2UoZm4pIHtcblx0bGV0IHJhbiA9IGZhbHNlO1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRpZiAocmFuKSByZXR1cm47XG5cdFx0cmFuID0gdHJ1ZTtcblx0XHRmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3RvcmVfdmFsdWUoc3RvcmUsIHJldCwgdmFsdWUpIHtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcblx0cmV0dXJuIGFjdGlvbl9yZXN1bHQgJiYgaXNfZnVuY3Rpb24oYWN0aW9uX3Jlc3VsdC5kZXN0cm95KSA/IGFjdGlvbl9yZXN1bHQuZGVzdHJveSA6IG5vb3A7XG59XG5cbi8qKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBzdHJpbmddfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRfY3NzX3VuaXQodmFsdWUpIHtcblx0Y29uc3Qgc3BsaXQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm1hdGNoKC9eXFxzKigtP1tcXGQuXSspKFteXFxzXSopXFxzKiQvKTtcblx0cmV0dXJuIHNwbGl0ID8gW3BhcnNlRmxvYXQoc3BsaXRbMV0pLCBzcGxpdFsyXSB8fCAncHgnXSA6IFsvKiogQHR5cGUge251bWJlcn0gKi8gKHZhbHVlKSwgJ3B4J107XG59XG5cbmV4cG9ydCBjb25zdCBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcyA9IFsnJywgdHJ1ZSwgMSwgJ3RydWUnLCAnY29udGVudGVkaXRhYmxlJ107XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmV4cG9ydCBjb25zdCBpc19jbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLyoqIEB0eXBlIHsoKSA9PiBudW1iZXJ9ICovXG5leHBvcnQgbGV0IG5vdyA9IGlzX2NsaWVudCA/ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6ICgpID0+IERhdGUubm93KCk7XG5cbmV4cG9ydCBsZXQgcmFmID0gaXNfY2xpZW50ID8gKGNiKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIDogbm9vcDtcblxuLy8gdXNlZCBpbnRlcm5hbGx5IGZvciB0ZXN0aW5nXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X25vdyhmbikge1xuXHRub3cgPSBmbjtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9yYWYoZm4pIHtcblx0cmFmID0gZm47XG59XG4iLCJpbXBvcnQgeyByYWYgfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcblxuY29uc3QgdGFza3MgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG5vd1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHJ1bl90YXNrcyhub3cpIHtcblx0dGFza3MuZm9yRWFjaCgodGFzaykgPT4ge1xuXHRcdGlmICghdGFzay5jKG5vdykpIHtcblx0XHRcdHRhc2tzLmRlbGV0ZSh0YXNrKTtcblx0XHRcdHRhc2suZigpO1xuXHRcdH1cblx0fSk7XG5cdGlmICh0YXNrcy5zaXplICE9PSAwKSByYWYocnVuX3Rhc2tzKTtcbn1cblxuLyoqXG4gKiBGb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5IVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcl9sb29wcygpIHtcblx0dGFza3MuY2xlYXIoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlRhc2tDYWxsYmFja30gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlRhc2t9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb29wKGNhbGxiYWNrKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5UYXNrRW50cnl9ICovXG5cdGxldCB0YXNrO1xuXHRpZiAodGFza3Muc2l6ZSA9PT0gMCkgcmFmKHJ1bl90YXNrcyk7XG5cdHJldHVybiB7XG5cdFx0cHJvbWlzZTogbmV3IFByb21pc2UoKGZ1bGZpbGwpID0+IHtcblx0XHRcdHRhc2tzLmFkZCgodGFzayA9IHsgYzogY2FsbGJhY2ssIGY6IGZ1bGZpbGwgfSkpO1xuXHRcdH0pLFxuXHRcdGFib3J0KCkge1xuXHRcdFx0dGFza3MuZGVsZXRlKHRhc2spO1xuXHRcdH1cblx0fTtcbn1cbiIsIi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXN9ICovXG5leHBvcnQgY29uc3QgZ2xvYmFscyA9XG5cdHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG5cdFx0PyB3aW5kb3dcblx0XHQ6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuXHRcdD8gZ2xvYmFsVGhpc1xuXHRcdDogLy8gQHRzLWlnbm9yZSBOb2RlIHR5cGluZ3MgaGF2ZSB0aGlzXG5cdFx0ICBnbG9iYWw7XG4iLCJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcblxuLyoqXG4gKiBSZXNpemUgb2JzZXJ2ZXIgc2luZ2xldG9uLlxuICogT25lIGxpc3RlbmVyIHBlciBlbGVtZW50IG9ubHkhXG4gKiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2cvYmxpbmstZGV2L2MvejZpZW5PTlViNUEvbS9GNS1WY1VadEJBQUpcbiAqL1xuZXhwb3J0IGNsYXNzIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZWFkb25seVxuXHQgKiBAdHlwZSB7V2Vha01hcDxFbGVtZW50LCBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkxpc3RlbmVyPn1cblx0ICovXG5cdF9saXN0ZW5lcnMgPSAnV2Vha01hcCcgaW4gZ2xvYmFscyA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEB0eXBlIHtSZXNpemVPYnNlcnZlcn1cblx0ICovXG5cdF9vYnNlcnZlciA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1Jlc2l6ZU9ic2VydmVyT3B0aW9uc30gKi9cblx0b3B0aW9ucztcblxuXHQvKiogQHBhcmFtIHtSZXNpemVPYnNlcnZlck9wdGlvbnN9IG9wdGlvbnMgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5MaXN0ZW5lcn0gbGlzdGVuZXJcblx0ICogQHJldHVybnMgeygpID0+IHZvaWR9XG5cdCAqL1xuXHRvYnNlcnZlKGVsZW1lbnQsIGxpc3RlbmVyKSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJzLnNldChlbGVtZW50LCBsaXN0ZW5lcik7XG5cdFx0dGhpcy5fZ2V0T2JzZXJ2ZXIoKS5vYnNlcnZlKGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMuX2xpc3RlbmVycy5kZWxldGUoZWxlbWVudCk7XG5cdFx0XHR0aGlzLl9vYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7IC8vIHRoaXMgbGluZSBjYW4gcHJvYmFibHkgYmUgcmVtb3ZlZFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRPYnNlcnZlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5fb2JzZXJ2ZXIgPz9cblx0XHRcdCh0aGlzLl9vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcblx0XHRcdFx0XHRSZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzLnNldChlbnRyeS50YXJnZXQsIGVudHJ5KTtcblx0XHRcdFx0XHR0aGlzLl9saXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCk/LihlbnRyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKVxuXHRcdCk7XG5cdH1cbn1cblxuLy8gTmVlZHMgdG8gYmUgd3JpdHRlbiBsaWtlIHRoaXMgdG8gcGFzcyB0aGUgdHJlZS1zaGFrZS10ZXN0XG5SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzID0gJ1dlYWtNYXAnIGluIGdsb2JhbHMgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuIiwiaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24gfSBmcm9tICcuL1Jlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmpzJztcbmltcG9ydCB7IGNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLCBoYXNfcHJvcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gVHJhY2sgd2hpY2ggbm9kZXMgYXJlIGNsYWltZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVW5jbGFpbWVkIG5vZGVzIGNhbiB0aGVuIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4vLyBhdCB0aGUgZW5kIG9mIGh5ZHJhdGlvbiB3aXRob3V0IHRvdWNoaW5nIHRoZSByZW1haW5pbmcgbm9kZXMuXG5sZXQgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydF9oeWRyYXRpbmcoKSB7XG5cdGlzX2h5ZHJhdGluZyA9IHRydWU7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRfaHlkcmF0aW5nKCkge1xuXHRpc19oeWRyYXRpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHBhcmFtIHsoaW5kZXg6IG51bWJlcikgPT4gbnVtYmVyfSBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gdXBwZXJfYm91bmQobG93LCBoaWdoLCBrZXksIHZhbHVlKSB7XG5cdC8vIFJldHVybiBmaXJzdCBpbmRleCBvZiB2YWx1ZSBsYXJnZXIgdGhhbiBpbnB1dCB2YWx1ZSBpbiB0aGUgcmFuZ2UgW2xvdywgaGlnaClcblx0d2hpbGUgKGxvdyA8IGhpZ2gpIHtcblx0XHRjb25zdCBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpID4+IDEpO1xuXHRcdGlmIChrZXkobWlkKSA8PSB2YWx1ZSkge1xuXHRcdFx0bG93ID0gbWlkICsgMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlnaCA9IG1pZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxvdztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGVFeH0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gaW5pdF9oeWRyYXRlKHRhcmdldCkge1xuXHRpZiAodGFyZ2V0Lmh5ZHJhdGVfaW5pdCkgcmV0dXJuO1xuXHR0YXJnZXQuaHlkcmF0ZV9pbml0ID0gdHJ1ZTtcblx0Ly8gV2Uga25vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNsYWltX29yZGVyIHZhbHVlcyBzaW5jZSB0aGUgdW5jbGFpbWVkIGhhdmUgYmVlbiBkZXRhY2hlZCBpZiB0YXJnZXQgaXMgbm90IDxoZWFkPlxuXG5cdGxldCBjaGlsZHJlbiA9IC8qKiBAdHlwZSB7QXJyYXlMaWtlPE5vZGVFeDI+fSAqLyAodGFyZ2V0LmNoaWxkTm9kZXMpO1xuXHQvLyBJZiB0YXJnZXQgaXMgPGhlYWQ+LCB0aGVyZSBtYXkgYmUgY2hpbGRyZW4gd2l0aG91dCBjbGFpbV9vcmRlclxuXHRpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnSEVBRCcpIHtcblx0XHRjb25zdCBteUNoaWxkcmVuID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRteUNoaWxkcmVuLnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNoaWxkcmVuID0gbXlDaGlsZHJlbjtcblx0fVxuXHQvKlxuXHQgKiBSZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5LlxuXHQgKiBXZSBjYW4gcmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseSBieSBmaW5kaW5nIHRoZSBsb25nZXN0IHN1YnNlcXVlbmNlIG9mXG5cdCAqIG5vZGVzIHRoYXQgYXJlIGFscmVhZHkgY2xhaW1lZCBpbiBvcmRlciBhbmQgb25seSBtb3ZpbmcgdGhlIHJlc3QuIFRoZSBsb25nZXN0XG5cdCAqIHN1YnNlcXVlbmNlIG9mIG5vZGVzIHRoYXQgYXJlIGNsYWltZWQgaW4gb3JkZXIgY2FuIGJlIGZvdW5kIGJ5XG5cdCAqIGNvbXB1dGluZyB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIC5jbGFpbV9vcmRlciB2YWx1ZXMuXG5cdCAqXG5cdCAqIFRoaXMgYWxnb3JpdGhtIGlzIG9wdGltYWwgaW4gZ2VuZXJhdGluZyB0aGUgbGVhc3QgYW1vdW50IG9mIHJlb3JkZXIgb3BlcmF0aW9uc1xuXHQgKiBwb3NzaWJsZS5cblx0ICpcblx0ICogUHJvb2Y6XG5cdCAqIFdlIGtub3cgdGhhdCwgZ2l2ZW4gYSBzZXQgb2YgcmVvcmRlcmluZyBvcGVyYXRpb25zLCB0aGUgbm9kZXMgdGhhdCBkbyBub3QgbW92ZVxuXHQgKiBhbHdheXMgZm9ybSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLCBzaW5jZSB0aGV5IGRvIG5vdCBtb3ZlIGFtb25nIGVhY2ggb3RoZXJcblx0ICogbWVhbmluZyB0aGF0IHRoZXkgbXVzdCBiZSBhbHJlYWR5IG9yZGVyZWQgYW1vbmcgZWFjaCBvdGhlci4gVGh1cywgdGhlIG1heGltYWxcblx0ICogc2V0IG9mIG5vZGVzIHRoYXQgZG8gbm90IG1vdmUgZm9ybSBhIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZS5cblx0ICovXG5cdC8vIENvbXB1dGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG5cdC8vIG06IHN1YnNlcXVlbmNlIGxlbmd0aCBqID0+IGluZGV4IGsgb2Ygc21hbGxlc3QgdmFsdWUgdGhhdCBlbmRzIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgbGVuZ3RoIGpcblx0Y29uc3QgbSA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCArIDEpO1xuXHQvLyBQcmVkZWNlc3NvciBpbmRpY2VzICsgMVxuXHRjb25zdCBwID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcblx0bVswXSA9IC0xO1xuXHRsZXQgbG9uZ2VzdCA9IDA7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBjdXJyZW50ID0gY2hpbGRyZW5baV0uY2xhaW1fb3JkZXI7XG5cdFx0Ly8gRmluZCB0aGUgbGFyZ2VzdCBzdWJzZXF1ZW5jZSBsZW5ndGggc3VjaCB0aGF0IGl0IGVuZHMgaW4gYSB2YWx1ZSBsZXNzIHRoYW4gb3VyIGN1cnJlbnQgdmFsdWVcblx0XHQvLyB1cHBlcl9ib3VuZCByZXR1cm5zIGZpcnN0IGdyZWF0ZXIgdmFsdWUsIHNvIHdlIHN1YnRyYWN0IG9uZVxuXHRcdC8vIHdpdGggZmFzdCBwYXRoIGZvciB3aGVuIHdlIGFyZSBvbiB0aGUgY3VycmVudCBsb25nZXN0IHN1YnNlcXVlbmNlXG5cdFx0Y29uc3Qgc2VxTGVuID1cblx0XHRcdChsb25nZXN0ID4gMCAmJiBjaGlsZHJlblttW2xvbmdlc3RdXS5jbGFpbV9vcmRlciA8PSBjdXJyZW50XG5cdFx0XHRcdD8gbG9uZ2VzdCArIDFcblx0XHRcdFx0OiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCAoaWR4KSA9PiBjaGlsZHJlblttW2lkeF1dLmNsYWltX29yZGVyLCBjdXJyZW50KSkgLSAxO1xuXHRcdHBbaV0gPSBtW3NlcUxlbl0gKyAxO1xuXHRcdGNvbnN0IG5ld0xlbiA9IHNlcUxlbiArIDE7XG5cdFx0Ly8gV2UgY2FuIGd1YXJhbnRlZSB0aGF0IGN1cnJlbnQgaXMgdGhlIHNtYWxsZXN0IHZhbHVlLiBPdGhlcndpc2UsIHdlIHdvdWxkIGhhdmUgZ2VuZXJhdGVkIGEgbG9uZ2VyIHNlcXVlbmNlLlxuXHRcdG1bbmV3TGVuXSA9IGk7XG5cdFx0bG9uZ2VzdCA9IE1hdGgubWF4KG5ld0xlbiwgbG9uZ2VzdCk7XG5cdH1cblx0Ly8gVGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBub2RlcyAoaW5pdGlhbGx5IHJldmVyc2VkKVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7Tm9kZUV4MltdfVxuXHQgKi9cblx0Y29uc3QgbGlzID0gW107XG5cdC8vIFRoZSByZXN0IG9mIHRoZSBub2Rlcywgbm9kZXMgdGhhdCB3aWxsIGJlIG1vdmVkXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtOb2RlRXgyW119XG5cdCAqL1xuXHRjb25zdCB0b01vdmUgPSBbXTtcblx0bGV0IGxhc3QgPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuXHRmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcblx0XHRsaXMucHVzaChjaGlsZHJlbltjdXIgLSAxXSk7XG5cdFx0Zm9yICg7IGxhc3QgPj0gY3VyOyBsYXN0LS0pIHtcblx0XHRcdHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcblx0XHR9XG5cdFx0bGFzdC0tO1xuXHR9XG5cdGZvciAoOyBsYXN0ID49IDA7IGxhc3QtLSkge1xuXHRcdHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcblx0fVxuXHRsaXMucmV2ZXJzZSgpO1xuXHQvLyBXZSBzb3J0IHRoZSBub2RlcyBiZWluZyBtb3ZlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVpciBpbnNlcnRpb24gb3JkZXIgbWF0Y2hlcyB0aGUgY2xhaW0gb3JkZXJcblx0dG9Nb3ZlLnNvcnQoKGEsIGIpID0+IGEuY2xhaW1fb3JkZXIgLSBiLmNsYWltX29yZGVyKTtcblx0Ly8gRmluYWxseSwgd2UgbW92ZSB0aGUgbm9kZXNcblx0Zm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9Nb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0d2hpbGUgKGogPCBsaXMubGVuZ3RoICYmIHRvTW92ZVtpXS5jbGFpbV9vcmRlciA+PSBsaXNbal0uY2xhaW1fb3JkZXIpIHtcblx0XHRcdGorKztcblx0XHR9XG5cdFx0Y29uc3QgYW5jaG9yID0gaiA8IGxpcy5sZW5ndGggPyBsaXNbal0gOiBudWxsO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodG9Nb3ZlW2ldLCBhbmNob3IpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG5cdHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlX3NoZWV0X2lkXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9zdHlsZXModGFyZ2V0LCBzdHlsZV9zaGVldF9pZCwgc3R5bGVzKSB7XG5cdGNvbnN0IGFwcGVuZF9zdHlsZXNfdG8gPSBnZXRfcm9vdF9mb3Jfc3R5bGUodGFyZ2V0KTtcblx0aWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuXHRcdGNvbnN0IHN0eWxlID0gZWxlbWVudCgnc3R5bGUnKTtcblx0XHRzdHlsZS5pZCA9IHN0eWxlX3NoZWV0X2lkO1xuXHRcdHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuXHRcdGFwcGVuZF9zdHlsZXNoZWV0KGFwcGVuZF9zdHlsZXNfdG8sIHN0eWxlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge1NoYWRvd1Jvb3QgfCBEb2N1bWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9yb290X2Zvcl9zdHlsZShub2RlKSB7XG5cdGlmICghbm9kZSkgcmV0dXJuIGRvY3VtZW50O1xuXHRjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcblx0aWYgKHJvb3QgJiYgLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCkuaG9zdCkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KTtcblx0fVxuXHRyZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge0NTU1N0eWxlU2hlZXR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG5cdGNvbnN0IHN0eWxlX2VsZW1lbnQgPSBlbGVtZW50KCdzdHlsZScpO1xuXHQvLyBGb3IgdHJhbnNpdGlvbnMgdG8gd29yayB3aXRob3V0ICdzdHlsZS1zcmM6IHVuc2FmZS1pbmxpbmUnIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LFxuXHQvLyB0aGVzZSBlbXB0eSB0YWdzIG5lZWQgdG8gYmUgYWxsb3dlZCB3aXRoIGEgaGFzaCBhcyBhIHdvcmthcm91bmQgdW50aWwgd2UgbW92ZSB0byB0aGUgV2ViIEFuaW1hdGlvbnMgQVBJLlxuXHQvLyBVc2luZyB0aGUgaGFzaCBmb3IgdGhlIGVtcHR5IHN0cmluZyAoZm9yIGFuIGVtcHR5IHRhZykgd29ya3MgaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBTYWZhcmkuXG5cdC8vIFNvIGFzIGEgd29ya2Fyb3VuZCBmb3IgdGhlIHdvcmthcm91bmQsIHdoZW4gd2UgYXBwZW5kIGVtcHR5IHN0eWxlIHRhZ3Mgd2Ugc2V0IHRoZWlyIGNvbnRlbnQgdG8gLyogZW1wdHkgKi8uXG5cdC8vIFRoZSBoYXNoICdzaGEyNTYtOU9sTk8wRE5FZWFWekhMNFJad0NMc0JIQThXQlE4dG9CcC80RjVYVjJuYz0nIHdpbGwgdGhlbiB3b3JrIGV2ZW4gaW4gU2FmYXJpLlxuXHRzdHlsZV9lbGVtZW50LnRleHRDb250ZW50ID0gJy8qIGVtcHR5ICovJztcblx0YXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcblx0cmV0dXJuIHN0eWxlX2VsZW1lbnQuc2hlZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTaGFkb3dSb290IHwgRG9jdW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEByZXR1cm5zIHtDU1NTdHlsZVNoZWV0fVxuICovXG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzaGVldChub2RlLCBzdHlsZSkge1xuXHRhcHBlbmQoLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKG5vZGUpLmhlYWQgfHwgbm9kZSwgc3R5bGUpO1xuXHRyZXR1cm4gc3R5bGUuc2hlZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlRXh9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcblx0aWYgKGlzX2h5ZHJhdGluZykge1xuXHRcdGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuXHRcdGlmIChcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCAmJiB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnROb2RlICE9PSB0YXJnZXQpXG5cdFx0KSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5maXJzdENoaWxkO1xuXHRcdH1cblx0XHQvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuXHRcdHdoaWxlICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCAmJiB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5jbGFpbV9vcmRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0XHRpZiAobm9kZSAhPT0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpIHtcblx0XHRcdC8vIFdlIG9ubHkgaW5zZXJ0IGlmIHRoZSBvcmRlcmluZyBvZiB0aGlzIG5vZGUgc2hvdWxkIGJlIG1vZGlmaWVkIG9yIHRoZSBwYXJlbnQgbm9kZSBpcyBub3QgdGFyZ2V0XG5cdFx0XHRpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkIHx8IG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuXHR0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGVFeH0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGVFeH0gbm9kZVxuICogQHBhcmFtIHtOb2RlRXh9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcblx0aWYgKGlzX2h5ZHJhdGluZyAmJiAhYW5jaG9yKSB7XG5cdFx0YXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuXHR9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcblx0aWYgKG5vZGUucGFyZW50Tm9kZSkge1xuXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGl0ZXJhdGlvbnNbaV0pIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9IEtcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHJldHVybnMge0hUTUxFbGVtZW50VGFnTmFtZU1hcFtLXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gS1xuICogQHBhcmFtIHtLfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gaXNcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFRhZ05hbWVNYXBbS119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50X2lzKG5hbWUsIGlzKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgVH0gS1xuICogQHBhcmFtIHtUfSBvYmpcbiAqIEBwYXJhbSB7S1tdfSBleGNsdWRlXG4gKiBAcmV0dXJucyB7UGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMob2JqLCBleGNsdWRlKSB7XG5cdGNvbnN0IHRhcmdldCA9IC8qKiBAdHlwZSB7UGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+Pn0gKi8gKHt9KTtcblx0Zm9yIChjb25zdCBrIGluIG9iaikge1xuXHRcdGlmIChcblx0XHRcdGhhc19wcm9wKG9iaiwgaykgJiZcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTFcblx0XHQpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHRhcmdldFtrXSA9IG9ialtrXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwfSBLXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQoZGF0YSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gc3BhY2UoKSB7XG5cdHJldHVybiB0ZXh0KCcgJyk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoKSB7XG5cdHJldHVybiB0ZXh0KCcnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHJldHVybnMge0NvbW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21tZW50KGNvbnRlbnQpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3R9IGhhbmRsZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcblx0bm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcblx0cmV0dXJuICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IGFueX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKGV2ZW50LmlzVHJ1c3RlZCkgZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cdGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKSBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbi8qKlxuICogTGlzdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBzZXQgdGhyb3VnaCB0aGUgYXR0ciBtZXRob2QsXG4gKiBiZWNhdXNlIHVwZGF0aW5nIHRoZW0gdGhyb3VnaCB0aGUgcHJvcGVydHkgc2V0dGVyIGRvZXNuJ3Qgd29yayByZWxpYWJseS5cbiAqIEluIHRoZSBleGFtcGxlIG9mIGB3aWR0aGAvYGhlaWdodGAsIHRoZSBwcm9ibGVtIGlzIHRoYXQgdGhlIHNldHRlciBvbmx5XG4gKiBhY2NlcHRzIG51bWVyaWMgdmFsdWVzLCBidXQgdGhlIGF0dHJpYnV0ZSBjYW4gYWxzbyBiZSBzZXQgdG8gYSBzdHJpbmcgbGlrZSBgNTAlYC5cbiAqIElmIHRoaXMgbGlzdCBiZWNvbWVzIHRvbyBiaWcsIHJldGhpbmsgdGhpcyBhcHByb2FjaC5cbiAqL1xuY29uc3QgYWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHt7IFt4OiBzdHJpbmddOiBzdHJpbmcgfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG5cdC8vIEB0cy1pZ25vcmVcblx0Y29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG5cdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcblx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcblx0XHRcdG5vZGUuc3R5bGUuY3NzVGV4dCA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ19fdmFsdWUnKSB7XG5cdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKG5vZGUpLnZhbHVlID0gbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRkZXNjcmlwdG9yc1trZXldICYmXG5cdFx0XHRkZXNjcmlwdG9yc1trZXldLnNldCAmJlxuXHRcdFx0YWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUuaW5kZXhPZihrZXkpID09PSAtMVxuXHRcdCkge1xuXHRcdFx0bm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7eyBbeDogc3RyaW5nXTogc3RyaW5nIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gZGF0YV9tYXBcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGFfbWFwKG5vZGUsIGRhdGFfbWFwKSB7XG5cdE9iamVjdC5rZXlzKGRhdGFfbWFwKS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBrZXksIGRhdGFfbWFwW2tleV0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuXHRpZiAocHJvcCBpbiBub2RlKSB7XG5cdFx0bm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdGF0dHIobm9kZSwgcHJvcCwgdmFsdWUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2R5bmFtaWNfZWxlbWVudF9kYXRhKHRhZykge1xuXHRyZXR1cm4gLy0vLnRlc3QodGFnKSA/IHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCA6IHNldF9hdHRyaWJ1dGVzO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24geGxpbmtfYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N2ZWx0ZV9kYXRhc2V0KG5vZGUpIHtcblx0cmV0dXJuIG5vZGUuZGF0YXNldC5zdmVsdGVIO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt1bmtub3duW119ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcblx0Y29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoZ3JvdXBbaV0uY2hlY2tlZCkgdmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuXHR9XG5cdGlmICghY2hlY2tlZCkge1xuXHRcdHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcblx0fVxuXHRyZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50W119IGdyb3VwXG4gKiBAcmV0dXJucyB7eyBwKC4uLmlucHV0czogSFRNTElucHV0RWxlbWVudFtdKTogdm9pZDsgcigpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2lucHV0cztcblx0cmV0dXJuIHtcblx0XHQvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG5cdFx0XHRfaW5wdXRzID0gaW5wdXRzO1xuXHRcdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gZ3JvdXAucHVzaChpbnB1dCkpO1xuXHRcdH0sXG5cdFx0LyogcmVtb3ZlICovIHIoKSB7XG5cdFx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBncm91cC5zcGxpY2UoZ3JvdXAuaW5kZXhPZihpbnB1dCksIDEpKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlc1xuICogQHJldHVybnMge3sgdShuZXdfaW5kZXhlczogbnVtYmVyW10pOiB2b2lkOyBwKC4uLmlucHV0czogSFRNTElucHV0RWxlbWVudFtdKTogdm9pZDsgcjogKCkgPT4gdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cF9keW5hbWljKGdyb3VwLCBpbmRleGVzKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2lucHV0cztcblxuXHRmdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cChncm91cCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Z3JvdXAgPSBncm91cFtpbmRleGVzW2ldXSA9IGdyb3VwW2luZGV4ZXNbaV1dIHx8IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gZ3JvdXA7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIHB1c2goKSB7XG5cdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gX2dyb3VwLnB1c2goaW5wdXQpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IF9ncm91cC5zcGxpY2UoX2dyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG5cdH1cblx0cmV0dXJuIHtcblx0XHQvKiB1cGRhdGUgKi8gdShuZXdfaW5kZXhlcykge1xuXHRcdFx0aW5kZXhlcyA9IG5ld19pbmRleGVzO1xuXHRcdFx0Y29uc3QgbmV3X2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuXHRcdFx0aWYgKG5ld19ncm91cCAhPT0gX2dyb3VwKSB7XG5cdFx0XHRcdHJlbW92ZSgpO1xuXHRcdFx0XHRfZ3JvdXAgPSBuZXdfZ3JvdXA7XG5cdFx0XHRcdHB1c2goKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qIHB1c2ggKi8gcCguLi5pbnB1dHMpIHtcblx0XHRcdF9pbnB1dHMgPSBpbnB1dHM7XG5cdFx0XHRwdXNoKCk7XG5cdFx0fSxcblx0XHQvKiByZW1vdmUgKi8gcjogcmVtb3ZlXG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiArdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMge2FueVtdfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuXHRjb25zdCBhcnJheSA9IFtdO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG5cdH1cblx0cmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0NoaWxkTm9kZVtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuXHRyZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gaW5pdF9jbGFpbV9pbmZvKG5vZGVzKSB7XG5cdGlmIChub2Rlcy5jbGFpbV9pbmZvID09PSB1bmRlZmluZWQpIHtcblx0XHRub2Rlcy5jbGFpbV9pbmZvID0geyBsYXN0X2luZGV4OiAwLCB0b3RhbF9jbGFpbWVkOiAwIH07XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge0NoaWxkTm9kZUV4fSBSXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHsobm9kZTogQ2hpbGROb2RlRXgpID0+IG5vZGUgaXMgUn0gcHJlZGljYXRlXG4gKiBAcGFyYW0geyhub2RlOiBDaGlsZE5vZGVFeCkgPT4gQ2hpbGROb2RlRXggfCB1bmRlZmluZWR9IHByb2Nlc3NOb2RlXG4gKiBAcGFyYW0geygpID0+IFJ9IGNyZWF0ZU5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udFVwZGF0ZUxhc3RJbmRleFxuICogQHJldHVybnMge1J9XG4gKi9cbmZ1bmN0aW9uIGNsYWltX25vZGUobm9kZXMsIHByZWRpY2F0ZSwgcHJvY2Vzc05vZGUsIGNyZWF0ZU5vZGUsIGRvbnRVcGRhdGVMYXN0SW5kZXggPSBmYWxzZSkge1xuXHQvLyBUcnkgdG8gZmluZCBub2RlcyBpbiBhbiBvcmRlciBzdWNoIHRoYXQgd2UgbGVuZ3RoZW4gdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuXHRpbml0X2NsYWltX2luZm8obm9kZXMpO1xuXHRjb25zdCByZXN1bHROb2RlID0gKCgpID0+IHtcblx0XHQvLyBXZSBmaXJzdCB0cnkgdG8gZmluZCBhbiBlbGVtZW50IGFmdGVyIHRoZSBwcmV2aW91cyBvbmVcblx0XHRmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdGlmIChwcmVkaWNhdGUobm9kZSkpIHtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcblx0XHRcdFx0aWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRub2Rlcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZXNbaV0gPSByZXBsYWNlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcblx0XHRcdFx0XHRub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBPdGhlcndpc2UsIHdlIHRyeSB0byBmaW5kIG9uZSBiZWZvcmVcblx0XHQvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugc28gdGhhdCB3ZSBkb24ndCBnbyB0b28gZmFyIGJhY2tcblx0XHRmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdGlmIChwcmVkaWNhdGUobm9kZSkpIHtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcblx0XHRcdFx0aWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRub2Rlcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZXNbaV0gPSByZXBsYWNlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcblx0XHRcdFx0XHRub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBTaW5jZSB3ZSBzcGxpY2VkIGJlZm9yZSB0aGUgbGFzdF9pbmRleCwgd2UgZGVjcmVhc2UgaXRcblx0XHRcdFx0XHRub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gSWYgd2UgY2FuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZSwgd2UgY3JlYXRlIGEgbmV3IG9uZVxuXHRcdHJldHVybiBjcmVhdGVOb2RlKCk7XG5cdH0pKCk7XG5cdHJlc3VsdE5vZGUuY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG5cdG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuXHRyZXR1cm4gcmVzdWx0Tm9kZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBba2V5OiBzdHJpbmddOiBib29sZWFuIH19IGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7KG5hbWU6IHN0cmluZykgPT4gRWxlbWVudCB8IFNWR0VsZW1lbnR9IGNyZWF0ZV9lbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudCB8IFNWR0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgY3JlYXRlX2VsZW1lbnQpIHtcblx0cmV0dXJuIGNsYWltX25vZGUoXG5cdFx0bm9kZXMsXG5cdFx0LyoqIEByZXR1cm5zIHtub2RlIGlzIEVsZW1lbnQgfCBTVkdFbGVtZW50fSAqL1xuXHRcdChub2RlKSA9PiBub2RlLm5vZGVOYW1lID09PSBuYW1lLFxuXHRcdC8qKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgKi9cblx0XHQobm9kZSkgPT4ge1xuXHRcdFx0Y29uc3QgcmVtb3ZlID0gW107XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbal07XG5cdFx0XHRcdGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0pIHtcblx0XHRcdFx0XHRyZW1vdmUucHVzaChhdHRyaWJ1dGUubmFtZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlbW92ZS5mb3JFYWNoKCh2KSA9PiBub2RlLnJlbW92ZUF0dHJpYnV0ZSh2KSk7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH0sXG5cdFx0KCkgPT4gY3JlYXRlX2VsZW1lbnQobmFtZSlcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBba2V5OiBzdHJpbmddOiBib29sZWFuIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgU1ZHRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcblx0cmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgZWxlbWVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudCB8IFNWR0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9zdmdfZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuXHRyZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBzdmdfZWxlbWVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEByZXR1cm5zIHtUZXh0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fdGV4dChub2RlcywgZGF0YSkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgVGV4dH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMyxcblx0XHQvKiogQHBhcmFtIHtUZXh0fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdGNvbnN0IGRhdGFTdHIgPSAnJyArIGRhdGE7XG5cdFx0XHRpZiAobm9kZS5kYXRhLnN0YXJ0c1dpdGgoZGF0YVN0cikpIHtcblx0XHRcdFx0aWYgKG5vZGUuZGF0YS5sZW5ndGggIT09IGRhdGFTdHIubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUuc3BsaXRUZXh0KGRhdGFTdHIubGVuZ3RoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5kYXRhID0gZGF0YVN0cjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdCgpID0+IHRleHQoZGF0YSksXG5cdFx0dHJ1ZSAvLyBUZXh0IG5vZGVzIHNob3VsZCBub3QgdXBkYXRlIGxhc3QgaW5kZXggc2luY2UgaXQgaXMgbGlrZWx5IG5vdCB3b3J0aCBpdCB0byBlbGltaW5hdGUgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBhY3R1YWwgZWxlbWVudHNcblx0KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7VGV4dH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9zcGFjZShub2Rlcykge1xuXHRyZXR1cm4gY2xhaW1fdGV4dChub2RlcywgJyAnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge0NvbW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9jb21tZW50KG5vZGVzLCBkYXRhKSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBDb21tZW50fSAqL1xuXHRcdChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4LFxuXHRcdC8qKiBAcGFyYW0ge0NvbW1lbnR9IG5vZGUgKi9cblx0XHQobm9kZSkgPT4ge1xuXHRcdFx0bm9kZS5kYXRhID0gJycgKyBkYXRhO1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdCgpID0+IGNvbW1lbnQoZGF0YSksXG5cdFx0dHJ1ZVxuXHQpO1xufVxuXG5mdW5jdGlvbiBmaW5kX2NvbW1lbnQobm9kZXMsIHRleHQsIHN0YXJ0KSB7XG5cdGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0Y29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLyAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gdGV4dCkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBub2Rlcy5sZW5ndGg7XG59XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBpc19zdmdcbiAqIEByZXR1cm5zIHtIdG1sVGFnSHlkcmF0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1faHRtbF90YWcobm9kZXMsIGlzX3N2Zykge1xuXHQvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcblx0Y29uc3Qgc3RhcnRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuXHRjb25zdCBlbmRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19FTkQnLCBzdGFydF9pbmRleCk7XG5cdGlmIChzdGFydF9pbmRleCA9PT0gZW5kX2luZGV4KSB7XG5cdFx0cmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKHVuZGVmaW5lZCwgaXNfc3ZnKTtcblx0fVxuXHRpbml0X2NsYWltX2luZm8obm9kZXMpO1xuXHRjb25zdCBodG1sX3RhZ19ub2RlcyA9IG5vZGVzLnNwbGljZShzdGFydF9pbmRleCwgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKTtcblx0ZGV0YWNoKGh0bWxfdGFnX25vZGVzWzBdKTtcblx0ZGV0YWNoKGh0bWxfdGFnX25vZGVzW2h0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDFdKTtcblx0Y29uc3QgY2xhaW1lZF9ub2RlcyA9IGh0bWxfdGFnX25vZGVzLnNsaWNlKDEsIGh0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDEpO1xuXHRmb3IgKGNvbnN0IG4gb2YgY2xhaW1lZF9ub2Rlcykge1xuXHRcdG4uY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG5cdFx0bm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG5cdH1cblx0cmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGNsYWltZWRfbm9kZXMsIGlzX3N2Zyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuXHRkYXRhID0gJycgKyBkYXRhO1xuXHRpZiAodGV4dC5kYXRhID09PSBkYXRhKSByZXR1cm47XG5cdHRleHQuZGF0YSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZGF0YSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGFfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEpIHtcblx0ZGF0YSA9ICcnICsgZGF0YTtcblx0aWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKSByZXR1cm47XG5cdHRleHQuZGF0YSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZGF0YSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyX3ZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhLCBhdHRyX3ZhbHVlKSB7XG5cdGlmICh+Y29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMuaW5kZXhPZihhdHRyX3ZhbHVlKSkge1xuXHRcdHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKTtcblx0fSBlbHNlIHtcblx0XHRzZXRfZGF0YSh0ZXh0LCBkYXRhKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pbnB1dF92YWx1ZShpbnB1dCwgdmFsdWUpIHtcblx0aW5wdXQudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaW5wdXRfdHlwZShpbnB1dCwgdHlwZSkge1xuXHR0cnkge1xuXHRcdGlucHV0LnR5cGUgPSB0eXBlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gZG8gbm90aGluZ1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N0eWxlKG5vZGUsIGtleSwgdmFsdWUsIGltcG9ydGFudCkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcblx0fSBlbHNlIHtcblx0XHRub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIGltcG9ydGFudCA/ICdpbXBvcnRhbnQnIDogJycpO1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZykge1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0Y29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG5cdFx0aWYgKG9wdGlvbi5fX3ZhbHVlID09PSB2YWx1ZSkge1xuXHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblx0aWYgKCFtb3VudGluZyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0c2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0Y29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG5cdFx0b3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2Yob3B0aW9uLl9fdmFsdWUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG5cdGNvbnN0IHNlbGVjdGVkX29wdGlvbiA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yKCc6Y2hlY2tlZCcpO1xuXHRyZXR1cm4gc2VsZWN0ZWRfb3B0aW9uICYmIHNlbGVjdGVkX29wdGlvbi5fX3ZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X211bHRpcGxlX3ZhbHVlKHNlbGVjdCkge1xuXHRyZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIChvcHRpb24pID0+IG9wdGlvbi5fX3ZhbHVlKTtcbn1cbi8vIHVuZm9ydHVuYXRlbHkgdGhpcyBjYW4ndCBiZSBhIGNvbnN0YW50IGFzIHRoYXQgd291bGRuJ3QgYmUgdHJlZS1zaGFrZWFibGVcbi8vIHNvIHdlIGNhY2hlIHRoZSByZXN1bHQgaW5zdGVhZFxuXG4vKipcbiAqIEB0eXBlIHtib29sZWFufSAqL1xubGV0IGNyb3Nzb3JpZ2luO1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuXHRpZiAoY3Jvc3NvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuXHRcdGNyb3Nzb3JpZ2luID0gZmFsc2U7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGFyZW50KSB7XG5cdFx0XHRcdHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y3Jvc3NvcmlnaW4gPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfaWZyYW1lX3Jlc2l6ZV9saXN0ZW5lcihub2RlLCBmbikge1xuXHRjb25zdCBjb21wdXRlZF9zdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGlmIChjb21wdXRlZF9zdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcblx0XHRub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblx0fVxuXHRjb25zdCBpZnJhbWUgPSBlbGVtZW50KCdpZnJhbWUnKTtcblx0aWZyYW1lLnNldEF0dHJpYnV0ZShcblx0XHQnc3R5bGUnLFxuXHRcdCdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7ICcgK1xuXHRcdFx0J292ZXJmbG93OiBoaWRkZW47IGJvcmRlcjogMDsgb3BhY2l0eTogMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHotaW5kZXg6IC0xOydcblx0KTtcblx0aWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXHRpZnJhbWUudGFiSW5kZXggPSAtMTtcblx0Y29uc3QgY3Jvc3NvcmlnaW4gPSBpc19jcm9zc29yaWdpbigpO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7KCkgPT4gdm9pZH1cblx0ICovXG5cdGxldCB1bnN1YnNjcmliZTtcblx0aWYgKGNyb3Nzb3JpZ2luKSB7XG5cdFx0aWZyYW1lLnNyYyA9IFwiZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+XCI7XG5cdFx0dW5zdWJzY3JpYmUgPSBsaXN0ZW4oXG5cdFx0XHR3aW5kb3csXG5cdFx0XHQnbWVzc2FnZScsXG5cdFx0XHQvKiogQHBhcmFtIHtNZXNzYWdlRXZlbnR9IGV2ZW50ICovIChldmVudCkgPT4ge1xuXHRcdFx0XHRpZiAoZXZlbnQuc291cmNlID09PSBpZnJhbWUuY29udGVudFdpbmRvdykgZm4oKTtcblx0XHRcdH1cblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuXHRcdGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0XHR1bnN1YnNjcmliZSA9IGxpc3RlbihpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIGZuKTtcblx0XHRcdC8vIG1ha2Ugc3VyZSBhbiBpbml0aWFsIHJlc2l6ZSBldmVudCBpcyBmaXJlZCBfYWZ0ZXJfIHRoZSBpZnJhbWUgaXMgbG9hZGVkICh3aGljaCBpcyBhc3luY2hyb25vdXMpXG5cdFx0XHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvNDIzM1xuXHRcdFx0Zm4oKTtcblx0XHR9O1xuXHR9XG5cdGFwcGVuZChub2RlLCBpZnJhbWUpO1xuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChjcm9zc29yaWdpbikge1xuXHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHR9IGVsc2UgaWYgKHVuc3Vic2NyaWJlICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG5cdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0XHRkZXRhY2goaWZyYW1lKTtcblx0fTtcbn1cbmV4cG9ydCBjb25zdCByZXNpemVfb2JzZXJ2ZXJfY29udGVudF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHtcblx0Ym94OiAnY29udGVudC1ib3gnXG59KTtcbmV4cG9ydCBjb25zdCByZXNpemVfb2JzZXJ2ZXJfYm9yZGVyX2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oe1xuXHRib3g6ICdib3JkZXItYm94J1xufSk7XG5leHBvcnQgY29uc3QgcmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oXG5cdHsgYm94OiAnZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94JyB9XG4pO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24gfTtcblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVfY2xhc3MoZWxlbWVudCwgbmFtZSwgdG9nZ2xlKSB7XG5cdC8vIFRoZSBgISFgIGlzIHJlcXVpcmVkIGJlY2F1c2UgYW4gYHVuZGVmaW5lZGAgZmxhZyBtZWFucyBmbGlwcGluZyB0aGUgY3VycmVudCBzdGF0ZS5cblx0ZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKG5hbWUsICEhdG9nZ2xlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7VH0gW2RldGFpbF1cbiAqIEBwYXJhbSB7eyBidWJibGVzPzogYm9vbGVhbiwgY2FuY2VsYWJsZT86IGJvb2xlYW4gfX0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7Q3VzdG9tRXZlbnQ8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkge1xuXHRyZXR1cm4gbmV3IEN1c3RvbUV2ZW50KHR5cGUsIHsgZGV0YWlsLCBidWJibGVzLCBjYW5jZWxhYmxlIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJucyB7Q2hpbGROb2RlQXJyYXl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeV9zZWxlY3Rvcl9hbGwoc2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50LmJvZHkpIHtcblx0cmV0dXJuIEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZUlkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBoZWFkXG4gKiBAcmV0dXJucyB7YW55W119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZWFkX3NlbGVjdG9yKG5vZGVJZCwgaGVhZCkge1xuXHRjb25zdCByZXN1bHQgPSBbXTtcblx0bGV0IHN0YXJ0ZWQgPSAwO1xuXHRmb3IgKGNvbnN0IG5vZGUgb2YgaGVhZC5jaGlsZE5vZGVzKSB7XG5cdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovKSB7XG5cdFx0XHRjb25zdCBjb21tZW50ID0gbm9kZS50ZXh0Q29udGVudC50cmltKCk7XG5cdFx0XHRpZiAoY29tbWVudCA9PT0gYEhFQURfJHtub2RlSWR9X0VORGApIHtcblx0XHRcdFx0c3RhcnRlZCAtPSAxO1xuXHRcdFx0XHRyZXN1bHQucHVzaChub2RlKTtcblx0XHRcdH0gZWxzZSBpZiAoY29tbWVudCA9PT0gYEhFQURfJHtub2RlSWR9X1NUQVJUYCkge1xuXHRcdFx0XHRzdGFydGVkICs9IDE7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoc3RhcnRlZCA+IDApIHtcblx0XHRcdHJlc3VsdC5wdXNoKG5vZGUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuLyoqICovXG5leHBvcnQgY2xhc3MgSHRtbFRhZyB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKi9cblx0aXNfc3ZnID0gZmFsc2U7XG5cdC8vIHBhcmVudCBmb3IgY3JlYXRpbmcgbm9kZVxuXHQvKiogKi9cblx0ZSA9IHVuZGVmaW5lZDtcblx0Ly8gaHRtbCB0YWcgbm9kZXNcblx0LyoqICovXG5cdG4gPSB1bmRlZmluZWQ7XG5cdC8vIHRhcmdldFxuXHQvKiogKi9cblx0dCA9IHVuZGVmaW5lZDtcblx0Ly8gYW5jaG9yXG5cdC8qKiAqL1xuXHRhID0gdW5kZWZpbmVkO1xuXHRjb25zdHJ1Y3Rvcihpc19zdmcgPSBmYWxzZSkge1xuXHRcdHRoaXMuaXNfc3ZnID0gaXNfc3ZnO1xuXHRcdHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRjKGh0bWwpIHtcblx0XHR0aGlzLmgoaHRtbCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IHRhcmdldFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gYW5jaG9yXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0bShodG1sLCB0YXJnZXQsIGFuY2hvciA9IG51bGwpIHtcblx0XHRpZiAoIXRoaXMuZSkge1xuXHRcdFx0aWYgKHRoaXMuaXNfc3ZnKVxuXHRcdFx0XHR0aGlzLmUgPSBzdmdfZWxlbWVudCgvKiogQHR5cGUge2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwfSAqLyAodGFyZ2V0Lm5vZGVOYW1lKSk7XG5cdFx0XHQvKiogIzczNjQgIHRhcmdldCBmb3IgPHRlbXBsYXRlPiBtYXkgYmUgcHJvdmlkZWQgYXMgI2RvY3VtZW50LWZyYWdtZW50KDExKSAqLyBlbHNlXG5cdFx0XHRcdHRoaXMuZSA9IGVsZW1lbnQoXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9ICovIChcblx0XHRcdFx0XHRcdHRhcmdldC5ub2RlVHlwZSA9PT0gMTEgPyAnVEVNUExBVEUnIDogdGFyZ2V0Lm5vZGVOYW1lXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXHRcdFx0dGhpcy50ID1cblx0XHRcdFx0dGFyZ2V0LnRhZ05hbWUgIT09ICdURU1QTEFURSdcblx0XHRcdFx0XHQ/IHRhcmdldFxuXHRcdFx0XHRcdDogLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyAodGFyZ2V0KS5jb250ZW50O1xuXHRcdFx0dGhpcy5jKGh0bWwpO1xuXHRcdH1cblx0XHR0aGlzLmkoYW5jaG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGgoaHRtbCkge1xuXHRcdHRoaXMuZS5pbm5lckhUTUwgPSBodG1sO1xuXHRcdHRoaXMubiA9IEFycmF5LmZyb20oXG5cdFx0XHR0aGlzLmUubm9kZU5hbWUgPT09ICdURU1QTEFURScgPyB0aGlzLmUuY29udGVudC5jaGlsZE5vZGVzIDogdGhpcy5lLmNoaWxkTm9kZXNcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRpKGFuY2hvcikge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRpbnNlcnQodGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0cChodG1sKSB7XG5cdFx0dGhpcy5kKCk7XG5cdFx0dGhpcy5oKGh0bWwpO1xuXHRcdHRoaXMuaSh0aGlzLmEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRkKCkge1xuXHRcdHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAZXh0ZW5kcyBIdG1sVGFnICovXG5leHBvcnQgY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuXHQvLyBoeWRyYXRpb24gY2xhaW1lZCBub2Rlc1xuXHQvKiogKi9cblx0bCA9IHVuZGVmaW5lZDtcblx0Y29uc3RydWN0b3IoY2xhaW1lZF9ub2RlcywgaXNfc3ZnID0gZmFsc2UpIHtcblx0XHRzdXBlcihpc19zdmcpO1xuXHRcdHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG5cdFx0dGhpcy5sID0gY2xhaW1lZF9ub2Rlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGMoaHRtbCkge1xuXHRcdGlmICh0aGlzLmwpIHtcblx0XHRcdHRoaXMubiA9IHRoaXMubDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3VwZXIuYyhodG1sKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGkoYW5jaG9yKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGluc2VydF9oeWRyYXRpb24odGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOYW1lZE5vZGVNYXB9IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt7fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHJpYnV0ZV90b19vYmplY3QoYXR0cmlidXRlcykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuXHRcdHJlc3VsdFthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUudmFsdWU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKGVsZW1lbnQpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKFxuXHRcdC8qKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgKi8gKG5vZGUpID0+IHtcblx0XHRcdHJlc3VsdFtub2RlLnNsb3QgfHwgJ2RlZmF1bHQnXSA9IHRydWU7XG5cdFx0fVxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQoY29tcG9uZW50LCBwcm9wcykge1xuXHRyZXR1cm4gbmV3IGNvbXBvbmVudChwcm9wcyk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge05vZGUgJiB7XG4gKiBcdGNsYWltX29yZGVyPzogbnVtYmVyO1xuICogXHRoeWRyYXRlX2luaXQ/OiB0cnVlO1xuICogXHRhY3R1YWxfZW5kX2NoaWxkPzogTm9kZUV4O1xuICogXHRjaGlsZE5vZGVzOiBOb2RlTGlzdE9mPE5vZGVFeD47XG4gKiB9fSBOb2RlRXhcbiAqL1xuXG4vKiogQHR5cGVkZWYge0NoaWxkTm9kZSAmIE5vZGVFeH0gQ2hpbGROb2RlRXggKi9cblxuLyoqIEB0eXBlZGVmIHtOb2RlRXggJiB7IGNsYWltX29yZGVyOiBudW1iZXIgfX0gTm9kZUV4MiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtDaGlsZE5vZGVFeFtdICYge1xuICogXHRjbGFpbV9pbmZvPzoge1xuICogXHRcdGxhc3RfaW5kZXg6IG51bWJlcjtcbiAqIFx0XHR0b3RhbF9jbGFpbWVkOiBudW1iZXI7XG4gKiBcdH07XG4gKiB9fSBDaGlsZE5vZGVBcnJheVxuICovXG4iLCJpbXBvcnQgeyBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldCwgZGV0YWNoLCBnZXRfcm9vdF9mb3Jfc3R5bGUgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyByYWYgfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcblxuLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gZm9yIG11bHRpcGxlIGRvY3VtZW50cyBiZWNhdXNlIGEgU3ZlbHRlIGFwcGxpY2F0aW9uIGNvdWxkIGFsc28gY29udGFpbiBpZnJhbWVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8zNjI0XG4vKiogQHR5cGUge01hcDxEb2N1bWVudCB8IFNoYWRvd1Jvb3QsIGltcG9ydCgnLi9wcml2YXRlLmQudHMnKS5TdHlsZUluZm9ybWF0aW9uPn0gKi9cbmNvbnN0IG1hbmFnZWRfc3R5bGVzID0gbmV3IE1hcCgpO1xuXG5sZXQgYWN0aXZlID0gMDtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2gvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gaGFzaChzdHIpIHtcblx0bGV0IGhhc2ggPSA1MzgxO1xuXHRsZXQgaSA9IHN0ci5sZW5ndGg7XG5cdHdoaWxlIChpLS0pIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuXHRyZXR1cm4gaGFzaCA+Pj4gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50IHwgU2hhZG93Um9vdH0gZG9jXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEByZXR1cm5zIHt7IHN0eWxlc2hlZXQ6IGFueTsgcnVsZXM6IHt9OyB9fVxuICovXG5mdW5jdGlvbiBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKSB7XG5cdGNvbnN0IGluZm8gPSB7IHN0eWxlc2hlZXQ6IGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpLCBydWxlczoge30gfTtcblx0bWFuYWdlZF9zdHlsZXMuc2V0KGRvYywgaW5mbyk7XG5cdHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheVxuICogQHBhcmFtIHsodDogbnVtYmVyKSA9PiBudW1iZXJ9IGVhc2VcbiAqIEBwYXJhbSB7KHQ6IG51bWJlciwgdTogbnVtYmVyKSA9PiBzdHJpbmd9IGZuXG4gKiBAcGFyYW0ge251bWJlcn0gdWlkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3J1bGUobm9kZSwgYSwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNlLCBmbiwgdWlkID0gMCkge1xuXHRjb25zdCBzdGVwID0gMTYuNjY2IC8gZHVyYXRpb247XG5cdGxldCBrZXlmcmFtZXMgPSAne1xcbic7XG5cdGZvciAobGV0IHAgPSAwOyBwIDw9IDE7IHAgKz0gc3RlcCkge1xuXHRcdGNvbnN0IHQgPSBhICsgKGIgLSBhKSAqIGVhc2UocCk7XG5cdFx0a2V5ZnJhbWVzICs9IHAgKiAxMDAgKyBgJXske2ZuKHQsIDEgLSB0KX19XFxuYDtcblx0fVxuXHRjb25zdCBydWxlID0ga2V5ZnJhbWVzICsgYDEwMCUgeyR7Zm4oYiwgMSAtIGIpfX1cXG59YDtcblx0Y29uc3QgbmFtZSA9IGBfX3N2ZWx0ZV8ke2hhc2gocnVsZSl9XyR7dWlkfWA7XG5cdGNvbnN0IGRvYyA9IGdldF9yb290X2Zvcl9zdHlsZShub2RlKTtcblx0Y29uc3QgeyBzdHlsZXNoZWV0LCBydWxlcyB9ID0gbWFuYWdlZF9zdHlsZXMuZ2V0KGRvYykgfHwgY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSk7XG5cdGlmICghcnVsZXNbbmFtZV0pIHtcblx0XHRydWxlc1tuYW1lXSA9IHRydWU7XG5cdFx0c3R5bGVzaGVldC5pbnNlcnRSdWxlKGBAa2V5ZnJhbWVzICR7bmFtZX0gJHtydWxlfWAsIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcblx0fVxuXHRjb25zdCBhbmltYXRpb24gPSBub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJztcblx0bm9kZS5zdHlsZS5hbmltYXRpb24gPSBgJHtcblx0XHRhbmltYXRpb24gPyBgJHthbmltYXRpb259LCBgIDogJydcblx0fSR7bmFtZX0gJHtkdXJhdGlvbn1tcyBsaW5lYXIgJHtkZWxheX1tcyAxIGJvdGhgO1xuXHRhY3RpdmUgKz0gMTtcblx0cmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpIHtcblx0Y29uc3QgcHJldmlvdXMgPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpLnNwbGl0KCcsICcpO1xuXHRjb25zdCBuZXh0ID0gcHJldmlvdXMuZmlsdGVyKFxuXHRcdG5hbWVcblx0XHRcdD8gKGFuaW0pID0+IGFuaW0uaW5kZXhPZihuYW1lKSA8IDAgLy8gcmVtb3ZlIHNwZWNpZmljIGFuaW1hdGlvblxuXHRcdFx0OiAoYW5pbSkgPT4gYW5pbS5pbmRleE9mKCdfX3N2ZWx0ZScpID09PSAtMSAvLyByZW1vdmUgYWxsIFN2ZWx0ZSBhbmltYXRpb25zXG5cdCk7XG5cdGNvbnN0IGRlbGV0ZWQgPSBwcmV2aW91cy5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcblx0aWYgKGRlbGV0ZWQpIHtcblx0XHRub2RlLnN0eWxlLmFuaW1hdGlvbiA9IG5leHQuam9pbignLCAnKTtcblx0XHRhY3RpdmUgLT0gZGVsZXRlZDtcblx0XHRpZiAoIWFjdGl2ZSkgY2xlYXJfcnVsZXMoKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJfcnVsZXMoKSB7XG5cdHJhZigoKSA9PiB7XG5cdFx0aWYgKGFjdGl2ZSkgcmV0dXJuO1xuXHRcdG1hbmFnZWRfc3R5bGVzLmZvckVhY2goKGluZm8pID0+IHtcblx0XHRcdGNvbnN0IHsgb3duZXJOb2RlIH0gPSBpbmZvLnN0eWxlc2hlZXQ7XG5cdFx0XHQvLyB0aGVyZSBpcyBubyBvd25lck5vZGUgaWYgaXQgcnVucyBvbiBqc2RvbS5cblx0XHRcdGlmIChvd25lck5vZGUpIGRldGFjaChvd25lck5vZGUpO1xuXHRcdH0pO1xuXHRcdG1hbmFnZWRfc3R5bGVzLmNsZWFyKCk7XG5cdH0pO1xufVxuIiwiaW1wb3J0IHsgaWRlbnRpdHkgYXMgbGluZWFyLCBub29wIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBub3cgfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcbmltcG9ydCB7IGxvb3AgfSBmcm9tICcuL2xvb3AuanMnO1xuaW1wb3J0IHsgY3JlYXRlX3J1bGUsIGRlbGV0ZV9ydWxlIH0gZnJvbSAnLi9zdHlsZV9tYW5hZ2VyLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Qb3NpdGlvblJlY3R9IGZyb21cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5BbmltYXRpb25Gbn0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuXHRpZiAoIWZyb20pIHJldHVybiBub29wO1xuXHRjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdGlmIChcblx0XHRmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiZcblx0XHRmcm9tLnJpZ2h0ID09PSB0by5yaWdodCAmJlxuXHRcdGZyb20udG9wID09PSB0by50b3AgJiZcblx0XHRmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tXG5cdClcblx0XHRyZXR1cm4gbm9vcDtcblx0Y29uc3Qge1xuXHRcdGRlbGF5ID0gMCxcblx0XHRkdXJhdGlvbiA9IDMwMCxcblx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0Ly8gQHRzLWlnbm9yZSB0b2RvOiBzaG91bGQgdGhpcyBiZSBzZXBhcmF0ZWQgZnJvbSBkZXN0cnVjdHVyaW5nPyBPciBzdGFydC9lbmQgYWRkZWQgdG8gcHVibGljIGFwaSBhbmQgZG9jdW1lbnRhdGlvbj9cblx0XHRzdGFydDogc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXksXG5cdFx0Ly8gQHRzLWlnbm9yZSB0b2RvOlxuXHRcdGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbixcblx0XHR0aWNrID0gbm9vcCxcblx0XHRjc3Ncblx0fSA9IGZuKG5vZGUsIHsgZnJvbSwgdG8gfSwgcGFyYW1zKTtcblx0bGV0IHJ1bm5pbmcgPSB0cnVlO1xuXHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRsZXQgbmFtZTtcblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBzdGFydCgpIHtcblx0XHRpZiAoY3NzKSB7XG5cdFx0XHRuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG5cdFx0fVxuXHRcdGlmICghZGVsYXkpIHtcblx0XHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdH1cblx0fVxuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0aWYgKGNzcykgZGVsZXRlX3J1bGUobm9kZSwgbmFtZSk7XG5cdFx0cnVubmluZyA9IGZhbHNlO1xuXHR9XG5cdGxvb3AoKG5vdykgPT4ge1xuXHRcdGlmICghc3RhcnRlZCAmJiBub3cgPj0gc3RhcnRfdGltZSkge1xuXHRcdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0fVxuXHRcdGlmIChzdGFydGVkICYmIG5vdyA+PSBlbmQpIHtcblx0XHRcdHRpY2soMSwgMCk7XG5cdFx0XHRzdG9wKCk7XG5cdFx0fVxuXHRcdGlmICghcnVubmluZykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoc3RhcnRlZCkge1xuXHRcdFx0Y29uc3QgcCA9IG5vdyAtIHN0YXJ0X3RpbWU7XG5cdFx0XHRjb25zdCB0ID0gMCArIDEgKiBlYXNpbmcocCAvIGR1cmF0aW9uKTtcblx0XHRcdHRpY2sodCwgMSAtIHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSk7XG5cdHN0YXJ0KCk7XG5cdHRpY2soMCwgMSk7XG5cdHJldHVybiBzdG9wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhfcG9zaXRpb24obm9kZSkge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGlmIChzdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG5cdFx0Y29uc3QgYSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0bm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0bm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdG5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGFkZF90cmFuc2Zvcm0obm9kZSwgYSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Qb3NpdGlvblJlY3R9IGFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX3RyYW5zZm9ybShub2RlLCBhKSB7XG5cdGNvbnN0IGIgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG5cdFx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRcdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdFx0bm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG5cdH1cbn1cbiIsImltcG9ydCB7IGN1c3RvbV9ldmVudCB9IGZyb20gJy4vZG9tLmpzJztcblxuZXhwb3J0IGxldCBjdXJyZW50X2NvbXBvbmVudDtcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpIHtcblx0Y3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG5cdGlmICghY3VycmVudF9jb21wb25lbnQpIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbGVkIG91dHNpZGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uJyk7XG5cdHJldHVybiBjdXJyZW50X2NvbXBvbmVudDtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdXBkYXRlZCBhZnRlciBhbnkgc3RhdGUgY2hhbmdlLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYmVmb3JlIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNiZWZvcmV1cGRhdGVcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYmVmb3JlX3VwZGF0ZS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBUaGUgYG9uTW91bnRgIGZ1bmN0aW9uIHNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogSXQgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIHRoZSBjb21wb25lbnQncyBpbml0aWFsaXNhdGlvbiAoYnV0IGRvZXNuJ3QgbmVlZCB0byBsaXZlICppbnNpZGUqIHRoZSBjb21wb25lbnQ7XG4gKiBpdCBjYW4gYmUgY2FsbGVkIGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlKS5cbiAqXG4gKiBJZiBhIGZ1bmN0aW9uIGlzIHJldHVybmVkIF9zeW5jaHJvbm91c2x5XyBmcm9tIGBvbk1vdW50YCwgaXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBgb25Nb3VudGAgZG9lcyBub3QgcnVuIGluc2lkZSBhIFtzZXJ2ZXItc2lkZSBjb21wb25lbnRdKC9kb2NzI3J1bi10aW1lLXNlcnZlci1zaWRlLWNvbXBvbmVudC1hcGkpLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNvbm1vdW50XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLk5vdEZ1bmN0aW9uPFQ+IHwgUHJvbWlzZTxpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLk5vdEZ1bmN0aW9uPFQ+PiB8ICgoKSA9PiBhbnkpfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbk1vdW50KGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIHVwZGF0ZWQuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBhZnRlciB0aGUgaW5pdGlhbCBgb25Nb3VudGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjYWZ0ZXJ1cGRhdGVcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5hZnRlcl91cGRhdGUucHVzaChmbik7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNvbmRlc3Ryb3lcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGRpc3BhdGNoZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwYXRjaCBbY29tcG9uZW50IGV2ZW50c10oL2RvY3MjdGVtcGxhdGUtc3ludGF4LWNvbXBvbmVudC1kaXJlY3RpdmVzLW9uLWV2ZW50bmFtZSkuXG4gKiBFdmVudCBkaXNwYXRjaGVycyBhcmUgZnVuY3Rpb25zIHRoYXQgY2FuIHRha2UgdHdvIGFyZ3VtZW50czogYG5hbWVgIGFuZCBgZGV0YWlsYC5cbiAqXG4gKiBDb21wb25lbnQgZXZlbnRzIGNyZWF0ZWQgd2l0aCBgY3JlYXRlRXZlbnREaXNwYXRjaGVyYCBjcmVhdGUgYVxuICogW0N1c3RvbUV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQpLlxuICogVGhlc2UgZXZlbnRzIGRvIG5vdCBbYnViYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0xlYXJuL0phdmFTY3JpcHQvQnVpbGRpbmdfYmxvY2tzL0V2ZW50cyNFdmVudF9idWJibGluZ19hbmRfY2FwdHVyZSkuXG4gKiBUaGUgYGRldGFpbGAgYXJndW1lbnQgY29ycmVzcG9uZHMgdG8gdGhlIFtDdXN0b21FdmVudC5kZXRhaWxdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9kZXRhaWwpXG4gKiBwcm9wZXJ0eSBhbmQgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgZGF0YS5cbiAqXG4gKiBUaGUgZXZlbnQgZGlzcGF0Y2hlciBjYW4gYmUgdHlwZWQgdG8gbmFycm93IHRoZSBhbGxvd2VkIGV2ZW50IG5hbWVzIGFuZCB0aGUgdHlwZSBvZiB0aGUgYGRldGFpbGAgYXJndW1lbnQ6XG4gKiBgYGB0c1xuICogY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXI8e1xuICogIGxvYWRlZDogbmV2ZXI7IC8vIGRvZXMgbm90IHRha2UgYSBkZXRhaWwgYXJndW1lbnRcbiAqICBjaGFuZ2U6IHN0cmluZzsgLy8gdGFrZXMgYSBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBzdHJpbmcsIHdoaWNoIGlzIHJlcXVpcmVkXG4gKiAgb3B0aW9uYWw6IG51bWJlciB8IG51bGw7IC8vIHRha2VzIGFuIG9wdGlvbmFsIGRldGFpbCBhcmd1bWVudCBvZiB0eXBlIG51bWJlclxuICogfT4oKTtcbiAqIGBgYFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNjcmVhdGVldmVudGRpc3BhdGNoZXJcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50TWFwPWFueV1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuRXZlbnREaXNwYXRjaGVyPEV2ZW50TWFwPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcblx0Y29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG5cdHJldHVybiAodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pID0+IHtcblx0XHRjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuXHRcdGlmIChjYWxsYmFja3MpIHtcblx0XHRcdC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcblx0XHRcdC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cblx0XHRcdGNvbnN0IGV2ZW50ID0gY3VzdG9tX2V2ZW50KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGRldGFpbCwgeyBjYW5jZWxhYmxlIH0pO1xuXHRcdFx0Y2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaCgoZm4pID0+IHtcblx0XHRcdFx0Zm4uY2FsbChjb21wb25lbnQsIGV2ZW50KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNzZXRjb250ZXh0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHBhcmFtIHtUfSBjb250ZXh0XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuc2V0KGtleSwgY29udGV4dCk7XG5cdHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY29udGV4dCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgYGtleWAuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNnZXRjb250ZXh0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuXHRyZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHdob2xlIGNvbnRleHQgbWFwIHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi4gVXNlZnVsLCBmb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGNvbXBvbmVudCBhbmQgd2FudCB0byBwYXNzIHRoZSBleGlzdGluZyBjb250ZXh0IHRvIGl0LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNnZXRhbGxjb250ZXh0c1xuICogQHRlbXBsYXRlIHtNYXA8YW55LCBhbnk+fSBbVD1NYXA8YW55LCBhbnk+XVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcblx0cmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiBga2V5YCBoYXMgYmVlbiBzZXQgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjaGFzY29udGV4dFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuXHRyZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cblxuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydFxuLy8gc2hvcnRoYW5kIGV2ZW50cywgb3IgaWYgd2Ugd2FudCB0byBpbXBsZW1lbnRcbi8vIGEgcmVhbCBidWJibGluZyBtZWNoYW5pc21cbi8qKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICogQHBhcmFtIGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1YmJsZShjb21wb25lbnQsIGV2ZW50KSB7XG5cdGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG5cdGlmIChjYWxsYmFja3MpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0Y2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaCgoZm4pID0+IGZuLmNhbGwodGhpcywgZXZlbnQpKTtcblx0fVxufVxuIiwiaW1wb3J0IHsgcnVuX2FsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQsIHNldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcblxuZXhwb3J0IGNvbnN0IGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbmV4cG9ydCBjb25zdCBpbnRyb3MgPSB7IGVuYWJsZWQ6IGZhbHNlIH07XG5leHBvcnQgY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcblxubGV0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcblxuY29uc3QgZmx1c2hfY2FsbGJhY2tzID0gW107XG5cbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG5cdGlmICghdXBkYXRlX3NjaGVkdWxlZCkge1xuXHRcdHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuXHRcdHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpY2soKSB7XG5cdHNjaGVkdWxlX3VwZGF0ZSgpO1xuXHRyZXR1cm4gcmVzb2x2ZWRfcHJvbWlzZTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcblx0cmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuXHRmbHVzaF9jYWxsYmFja3MucHVzaChmbik7XG59XG5cbi8vIGZsdXNoKCkgY2FsbHMgY2FsbGJhY2tzIGluIHRoaXMgb3JkZXI6XG4vLyAxLiBBbGwgYmVmb3JlVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuXG4vLyAyLiBBbGwgYmluZDp0aGlzIGNhbGxiYWNrcywgaW4gcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyAzLiBBbGwgYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW4uIEVYQ0VQVFxuLy8gICAgZm9yIGFmdGVyVXBkYXRlcyBjYWxsZWQgZHVyaW5nIHRoZSBpbml0aWFsIG9uTW91bnQsIHdoaWNoIGFyZSBjYWxsZWQgaW5cbi8vICAgIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gU2luY2UgY2FsbGJhY2tzIG1pZ2h0IHVwZGF0ZSBjb21wb25lbnQgdmFsdWVzLCB3aGljaCBjb3VsZCB0cmlnZ2VyIGFub3RoZXJcbi8vIGNhbGwgdG8gZmx1c2goKSwgdGhlIGZvbGxvd2luZyBzdGVwcyBndWFyZCBhZ2FpbnN0IHRoaXM6XG4vLyAxLiBEdXJpbmcgYmVmb3JlVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyAgICBkaXJ0eV9jb21wb25lbnRzIGFycmF5IGFuZCB3aWxsIGNhdXNlIGEgcmVlbnRyYW50IGNhbGwgdG8gZmx1c2goKS4gQmVjYXVzZVxuLy8gICAgdGhlIGZsdXNoIGluZGV4IGlzIGtlcHQgb3V0c2lkZSB0aGUgZnVuY3Rpb24sIHRoZSByZWVudHJhbnQgY2FsbCB3aWxsIHBpY2tcbi8vICAgIHVwIHdoZXJlIHRoZSBlYXJsaWVyIGNhbGwgbGVmdCBvZmYgYW5kIGdvIHRocm91Z2ggYWxsIGRpcnR5IGNvbXBvbmVudHMuIFRoZVxuLy8gICAgY3VycmVudF9jb21wb25lbnQgdmFsdWUgaXMgc2F2ZWQgYW5kIHJlc3RvcmVkIHNvIHRoYXQgdGhlIHJlZW50cmFudCBjYWxsIHdpbGxcbi8vICAgIG5vdCBpbnRlcmZlcmUgd2l0aCB0aGUgXCJwYXJlbnRcIiBmbHVzaCgpIGNhbGwuXG4vLyAyLiBiaW5kOnRoaXMgY2FsbGJhY2tzIGNhbm5vdCB0cmlnZ2VyIG5ldyBmbHVzaCgpIGNhbGxzLlxuLy8gMy4gRHVyaW5nIGFmdGVyVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgTk9UIGhhdmUgdGhlaXIgYWZ0ZXJVcGRhdGVcbi8vICAgIGNhbGxiYWNrIGNhbGxlZCBhIHNlY29uZCB0aW1lOyB0aGUgc2Vlbl9jYWxsYmFja3Mgc2V0LCBvdXRzaWRlIHRoZSBmbHVzaCgpXG4vLyAgICBmdW5jdGlvbiwgZ3VhcmFudGVlcyB0aGlzIGJlaGF2aW9yLlxuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5cbmxldCBmbHVzaGlkeCA9IDA7IC8vIERvICpub3QqIG1vdmUgdGhpcyBpbnNpZGUgdGhlIGZsdXNoKCkgZnVuY3Rpb25cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoKCkge1xuXHQvLyBEbyBub3QgcmVlbnRlciBmbHVzaCB3aGlsZSBkaXJ0eSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBhcyB0aGlzIGNhblxuXHQvLyByZXN1bHQgaW4gYW4gaW5maW5pdGUgbG9vcC4gSW5zdGVhZCwgbGV0IHRoZSBpbm5lciBmbHVzaCBoYW5kbGUgaXQuXG5cdC8vIFJlZW50cmFuY3kgaXMgb2sgYWZ0ZXJ3YXJkcyBmb3IgYmluZGluZ3MgZXRjLlxuXHRpZiAoZmx1c2hpZHggIT09IDApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0Y29uc3Qgc2F2ZWRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG5cdGRvIHtcblx0XHQvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG5cdFx0Ly8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG5cdFx0dHJ5IHtcblx0XHRcdHdoaWxlIChmbHVzaGlkeCA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbZmx1c2hpZHhdO1xuXHRcdFx0XHRmbHVzaGlkeCsrO1xuXHRcdFx0XHRzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcblx0XHRcdFx0dXBkYXRlKGNvbXBvbmVudC4kJCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gcmVzZXQgZGlydHkgc3RhdGUgdG8gbm90IGVuZCB1cCBpbiBhIGRlYWRsb2NrZWQgc3RhdGUgYW5kIHRoZW4gcmV0aHJvd1xuXHRcdFx0ZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuXHRcdFx0Zmx1c2hpZHggPSAwO1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuXHRcdGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcblx0XHRmbHVzaGlkeCA9IDA7XG5cdFx0d2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aCkgYmluZGluZ19jYWxsYmFja3MucG9wKCkoKTtcblx0XHQvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcblx0XHQvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG5cdFx0Ly8gc3Vic2VxdWVudCB1cGRhdGVzLi4uXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG5cdFx0XHRpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcblx0XHRcdFx0Ly8gLi4uc28gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBsb29wc1xuXHRcdFx0XHRzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZW5kZXJfY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG5cdH0gd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKTtcblx0d2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcblx0fVxuXHR1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5cdHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChzYXZlZF9jb21wb25lbnQpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5mdW5jdGlvbiB1cGRhdGUoJCQpIHtcblx0aWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG5cdFx0JCQudXBkYXRlKCk7XG5cdFx0cnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcblx0XHRjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuXHRcdCQkLmRpcnR5ID0gWy0xXTtcblx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5wKCQkLmN0eCwgZGlydHkpO1xuXHRcdCQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuXHR9XG59XG5cbi8qKlxuICogVXNlZnVsIGZvciBleGFtcGxlIHRvIGV4ZWN1dGUgcmVtYWluaW5nIGBhZnRlclVwZGF0ZWAgY2FsbGJhY2tzIGJlZm9yZSBleGVjdXRpbmcgYGRlc3Ryb3lgLlxuICogQHBhcmFtIHtGdW5jdGlvbltdfSBmbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hfcmVuZGVyX2NhbGxiYWNrcyhmbnMpIHtcblx0Y29uc3QgZmlsdGVyZWQgPSBbXTtcblx0Y29uc3QgdGFyZ2V0cyA9IFtdO1xuXHRyZW5kZXJfY2FsbGJhY2tzLmZvckVhY2goKGMpID0+IChmbnMuaW5kZXhPZihjKSA9PT0gLTEgPyBmaWx0ZXJlZC5wdXNoKGMpIDogdGFyZ2V0cy5wdXNoKGMpKSk7XG5cdHRhcmdldHMuZm9yRWFjaCgoYykgPT4gYygpKTtcblx0cmVuZGVyX2NhbGxiYWNrcyA9IGZpbHRlcmVkO1xufVxuIiwiaW1wb3J0IHsgaWRlbnRpdHkgYXMgbGluZWFyLCBpc19mdW5jdGlvbiwgbm9vcCwgcnVuX2FsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5pbXBvcnQgeyBsb29wIH0gZnJvbSAnLi9sb29wLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9ydWxlLCBkZWxldGVfcnVsZSB9IGZyb20gJy4vc3R5bGVfbWFuYWdlci5qcyc7XG5pbXBvcnQgeyBjdXN0b21fZXZlbnQgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBhZGRfcmVuZGVyX2NhbGxiYWNrIH0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtQcm9taXNlPHZvaWQ+IHwgbnVsbH1cbiAqL1xubGV0IHByb21pc2U7XG5cbi8qKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmZ1bmN0aW9uIHdhaXQoKSB7XG5cdGlmICghcHJvbWlzZSkge1xuXHRcdHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRwcm9taXNlLnRoZW4oKCkgPT4ge1xuXHRcdFx0cHJvbWlzZSA9IG51bGw7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHByb21pc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0lOVFJPIHwgT1VUUk8gfCBib29sZWFufSBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7J3N0YXJ0JyB8ICdlbmQnfSBraW5kXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG5cdG5vZGUuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQoYCR7ZGlyZWN0aW9uID8gJ2ludHJvJyA6ICdvdXRybyd9JHtraW5kfWApKTtcbn1cblxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHR5cGUge091dHJvfVxuICovXG5sZXQgb3V0cm9zO1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwX291dHJvcygpIHtcblx0b3V0cm9zID0ge1xuXHRcdHI6IDAsXG5cdFx0YzogW10sXG5cdFx0cDogb3V0cm9zIC8vIHBhcmVudCBncm91cFxuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrX291dHJvcygpIHtcblx0aWYgKCFvdXRyb3Mucikge1xuXHRcdHJ1bl9hbGwob3V0cm9zLmMpO1xuXHR9XG5cdG91dHJvcyA9IG91dHJvcy5wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5GcmFnbWVudH0gYmxvY2tcbiAqIEBwYXJhbSB7MCB8IDF9IFtsb2NhbF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcblx0aWYgKGJsb2NrICYmIGJsb2NrLmkpIHtcblx0XHRvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuXHRcdGJsb2NrLmkobG9jYWwpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkZyYWdtZW50fSBibG9ja1xuICogQHBhcmFtIHswIHwgMX0gbG9jYWxcbiAqIEBwYXJhbSB7MCB8IDF9IFtkZXRhY2hdXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja11cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbl9vdXQoYmxvY2ssIGxvY2FsLCBkZXRhY2gsIGNhbGxiYWNrKSB7XG5cdGlmIChibG9jayAmJiBibG9jay5vKSB7XG5cdFx0aWYgKG91dHJvaW5nLmhhcyhibG9jaykpIHJldHVybjtcblx0XHRvdXRyb2luZy5hZGQoYmxvY2spO1xuXHRcdG91dHJvcy5jLnB1c2goKCkgPT4ge1xuXHRcdFx0b3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcblx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRpZiAoZGV0YWNoKSBibG9jay5kKDEpO1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGJsb2NrLm8obG9jYWwpO1xuXHR9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG5cdFx0Y2FsbGJhY2soKTtcblx0fVxufVxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4uL3RyYW5zaXRpb24vcHVibGljLmpzJykuVHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtUcmFuc2l0aW9uRm59IGZuXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7eyBzdGFydCgpOiB2b2lkOyBpbnZhbGlkYXRlKCk6IHZvaWQ7IGVuZCgpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuXHQvKipcblx0ICogQHR5cGUge1RyYW5zaXRpb25PcHRpb25zfSAqL1xuXHRjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdpbicgfTtcblx0bGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG5cdGxldCBydW5uaW5nID0gZmFsc2U7XG5cdGxldCBhbmltYXRpb25fbmFtZTtcblx0bGV0IHRhc2s7XG5cdGxldCB1aWQgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gY2xlYW51cCgpIHtcblx0XHRpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gZ28oKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXHRcdGlmIChjc3MpIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcywgdWlkKyspO1xuXHRcdHRpY2soMCwgMSk7XG5cdFx0Y29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG5cdFx0Y29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG5cdFx0aWYgKHRhc2spIHRhc2suYWJvcnQoKTtcblx0XHRydW5uaW5nID0gdHJ1ZTtcblx0XHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIHRydWUsICdzdGFydCcpKTtcblx0XHR0YXNrID0gbG9vcCgobm93KSA9PiB7XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAobm93ID49IGVuZF90aW1lKSB7XG5cdFx0XHRcdFx0dGljaygxLCAwKTtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCB0cnVlLCAnZW5kJyk7XG5cdFx0XHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0XHRcdHJldHVybiAocnVubmluZyA9IGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0XHR0aWNrKHQsIDEgLSB0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ1bm5pbmc7XG5cdFx0fSk7XG5cdH1cblx0bGV0IHN0YXJ0ZWQgPSBmYWxzZTtcblx0cmV0dXJuIHtcblx0XHRzdGFydCgpIHtcblx0XHRcdGlmIChzdGFydGVkKSByZXR1cm47XG5cdFx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRcdGRlbGV0ZV9ydWxlKG5vZGUpO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcblx0XHRcdFx0Y29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuXHRcdFx0XHR3YWl0KCkudGhlbihnbyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnbygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW52YWxpZGF0ZSgpIHtcblx0XHRcdHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHR9LFxuXHRcdGVuZCgpIHtcblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGNsZWFudXAoKTtcblx0XHRcdFx0cnVubmluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbkZufSBmblxuICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICogQHJldHVybnMge3sgZW5kKHJlc2V0OiBhbnkpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX291dF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uT3B0aW9uc30gKi9cblx0Y29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnb3V0JyB9O1xuXHRsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcblx0bGV0IHJ1bm5pbmcgPSB0cnVlO1xuXHRsZXQgYW5pbWF0aW9uX25hbWU7XG5cdGNvbnN0IGdyb3VwID0gb3V0cm9zO1xuXHRncm91cC5yICs9IDE7XG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0bGV0IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gZ28oKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXG5cdFx0aWYgKGNzcykgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAxLCAwLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcblxuXHRcdGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuXHRcdGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuXHRcdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcblxuXHRcdGlmICgnaW5lcnQnIGluIG5vZGUpIHtcblx0XHRcdG9yaWdpbmFsX2luZXJ0X3ZhbHVlID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpLmluZXJ0O1xuXHRcdFx0bm9kZS5pbmVydCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0bG9vcCgobm93KSA9PiB7XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAobm93ID49IGVuZF90aW1lKSB7XG5cdFx0XHRcdFx0dGljaygwLCAxKTtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCBmYWxzZSwgJ2VuZCcpO1xuXHRcdFx0XHRcdGlmICghLS1ncm91cC5yKSB7XG5cdFx0XHRcdFx0XHQvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuXHRcdFx0XHRcdFx0Ly8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG5cdFx0XHRcdFx0XHRydW5fYWxsKGdyb3VwLmMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG5cdFx0XHRcdFx0dGljaygxIC0gdCwgdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBydW5uaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcblx0XHR3YWl0KCkudGhlbigoKSA9PiB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG5cdFx0XHRnbygpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGdvKCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGVuZChyZXNldCkge1xuXHRcdFx0aWYgKHJlc2V0ICYmICdpbmVydCcgaW4gbm9kZSkge1xuXHRcdFx0XHRub2RlLmluZXJ0ID0gb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcblx0XHRcdFx0Y29uZmlnLnRpY2soMSwgMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcblx0XHRcdFx0cnVubmluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbkZufSBmblxuICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBpbnRyb1xuICogQHJldHVybnMge3sgcnVuKGI6IDAgfCAxKTogdm9pZDsgZW5kKCk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMsIGludHJvKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7VHJhbnNpdGlvbk9wdGlvbnN9ICovXG5cdGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2JvdGgnIH07XG5cdGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHRsZXQgdCA9IGludHJvID8gMCA6IDE7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtQcm9ncmFtIHwgbnVsbH0gKi9cblx0bGV0IHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtQZW5kaW5nUHJvZ3JhbSB8IG51bGx9ICovXG5cdGxldCBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0bGV0IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gY2xlYXJfYW5pbWF0aW9uKCkge1xuXHRcdGlmIChhbmltYXRpb25fbmFtZSkgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UGVuZGluZ1Byb2dyYW19IHByb2dyYW1cblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG5cdCAqIEByZXR1cm5zIHtQcm9ncmFtfVxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdChwcm9ncmFtLCBkdXJhdGlvbikge1xuXHRcdGNvbnN0IGQgPSAvKiogQHR5cGUge1Byb2dyYW1bJ2QnXX0gKi8gKHByb2dyYW0uYiAtIHQpO1xuXHRcdGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRhOiB0LFxuXHRcdFx0YjogcHJvZ3JhbS5iLFxuXHRcdFx0ZCxcblx0XHRcdGR1cmF0aW9uLFxuXHRcdFx0c3RhcnQ6IHByb2dyYW0uc3RhcnQsXG5cdFx0XHRlbmQ6IHByb2dyYW0uc3RhcnQgKyBkdXJhdGlvbixcblx0XHRcdGdyb3VwOiBwcm9ncmFtLmdyb3VwXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lOVFJPIHwgT1VUUk99IGJcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBnbyhiKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1BlbmRpbmdQcm9ncmFtfSAqL1xuXHRcdGNvbnN0IHByb2dyYW0gPSB7XG5cdFx0XHRzdGFydDogbm93KCkgKyBkZWxheSxcblx0XHRcdGJcblx0XHR9O1xuXG5cdFx0aWYgKCFiKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuXHRcdFx0cHJvZ3JhbS5ncm91cCA9IG91dHJvcztcblx0XHRcdG91dHJvcy5yICs9IDE7XG5cdFx0fVxuXG5cdFx0aWYgKCdpbmVydCcgaW4gbm9kZSkge1xuXHRcdFx0aWYgKGIpIHtcblx0XHRcdFx0aWYgKG9yaWdpbmFsX2luZXJ0X3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBhYm9ydGVkL3JldmVyc2VkIG91dHJvIOKAlCByZXN0b3JlIHByZXZpb3VzIGluZXJ0IHZhbHVlXG5cdFx0XHRcdFx0bm9kZS5pbmVydCA9IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcmlnaW5hbF9pbmVydF92YWx1ZSA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChub2RlKS5pbmVydDtcblx0XHRcdFx0bm9kZS5pbmVydCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcblx0XHRcdHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlmIHRoaXMgaXMgYW4gaW50cm8sIGFuZCB0aGVyZSdzIGEgZGVsYXksIHdlIG5lZWQgdG8gZG9cblx0XHRcdC8vIGFuIGluaXRpYWwgdGljayBhbmQvb3IgYXBwbHkgQ1NTIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuXHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdFx0YW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcblx0XHRcdH1cblx0XHRcdGlmIChiKSB0aWNrKDAsIDEpO1xuXHRcdFx0cnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG5cdFx0XHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpKTtcblx0XHRcdGxvb3AoKG5vdykgPT4ge1xuXHRcdFx0XHRpZiAocGVuZGluZ19wcm9ncmFtICYmIG5vdyA+IHBlbmRpbmdfcHJvZ3JhbS5zdGFydCkge1xuXHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocGVuZGluZ19wcm9ncmFtLCBkdXJhdGlvbik7XG5cdFx0XHRcdFx0cGVuZGluZ19wcm9ncmFtID0gbnVsbDtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ3N0YXJ0Jyk7XG5cdFx0XHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRcdFx0XHRhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKFxuXHRcdFx0XHRcdFx0XHRub2RlLFxuXHRcdFx0XHRcdFx0XHR0LFxuXHRcdFx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0uYixcblx0XHRcdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtLmR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRlYXNpbmcsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZy5jc3Ncblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5uaW5nX3Byb2dyYW0pIHtcblx0XHRcdFx0XHRpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5lbmQpIHtcblx0XHRcdFx0XHRcdHRpY2soKHQgPSBydW5uaW5nX3Byb2dyYW0uYiksIDEgLSB0KTtcblx0XHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG5cdFx0XHRcdFx0XHRpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuXHRcdFx0XHRcdFx0XHQvLyB3ZSdyZSBkb25lXG5cdFx0XHRcdFx0XHRcdGlmIChydW5uaW5nX3Byb2dyYW0uYikge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGludHJvIOKAlCB3ZSBjYW4gdGlkeSB1cCBpbW1lZGlhdGVseVxuXHRcdFx0XHRcdFx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIG91dHJvIOKAlCBuZWVkcyB0byBiZSBjb29yZGluYXRlZFxuXHRcdFx0XHRcdFx0XHRcdGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucikgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLnN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuXHRcdFx0XHRcdFx0dCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG5cdFx0XHRcdFx0XHR0aWNrKHQsIDEgLSB0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB7XG5cdFx0cnVuKGIpIHtcblx0XHRcdGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG5cdFx0XHRcdHdhaXQoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBvcHRzID0geyBkaXJlY3Rpb246IGIgPyAnaW4nIDogJ291dCcgfTtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0Y29uZmlnID0gY29uZmlnKG9wdHMpO1xuXHRcdFx0XHRcdGdvKGIpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdvKGIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZW5kKCkge1xuXHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqIEB0eXBlZGVmIHsxfSBJTlRSTyAqL1xuLyoqIEB0eXBlZGVmIHswfSBPVVRSTyAqL1xuLyoqIEB0eXBlZGVmIHt7IGRpcmVjdGlvbjogJ2luJyB8ICdvdXQnIHwgJ2JvdGgnIH19IFRyYW5zaXRpb25PcHRpb25zICovXG4vKiogQHR5cGVkZWYgeyhub2RlOiBFbGVtZW50LCBwYXJhbXM6IGFueSwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMpID0+IGltcG9ydCgnLi4vdHJhbnNpdGlvbi9wdWJsaWMuanMnKS5UcmFuc2l0aW9uQ29uZmlnfSBUcmFuc2l0aW9uRm4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPdXRyb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb25bXX0gY1xuICogQHByb3BlcnR5IHtPYmplY3R9IHBcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBlbmRpbmdQcm9ncmFtXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnRcbiAqIEBwcm9wZXJ0eSB7SU5UUk98T1VUUk99IGJcbiAqIEBwcm9wZXJ0eSB7T3V0cm99IFtncm91cF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2dyYW1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhXG4gKiBAcHJvcGVydHkge0lOVFJPfE9VVFJPfSBiXG4gKiBAcHJvcGVydHkgezF8LTF9IGRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZW5kXG4gKiBAcHJvcGVydHkge091dHJvfSBbZ3JvdXBdXG4gKi9cbiIsImltcG9ydCB7IGlzX3Byb21pc2UgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGNoZWNrX291dHJvcywgZ3JvdXBfb3V0cm9zLCB0cmFuc2l0aW9uX2luLCB0cmFuc2l0aW9uX291dCB9IGZyb20gJy4vdHJhbnNpdGlvbnMuanMnO1xuaW1wb3J0IHsgZmx1c2ggfSBmcm9tICcuL3NjaGVkdWxlci5qcyc7XG5pbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQsIHNldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtQcm9taXNlPFQ+fSBwcm9taXNlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuUHJvbWlzZUluZm88VD59IGluZm9cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlX3Byb21pc2UocHJvbWlzZSwgaW5mbykge1xuXHRjb25zdCB0b2tlbiA9IChpbmZvLnRva2VuID0ge30pO1xuXHQvKipcblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkZyYWdtZW50RmFjdG9yeX0gdHlwZVxuXHQgKiBAcGFyYW0gezAgfCAxIHwgMn0gaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtrZXldXG5cdCAqIEBwYXJhbSB7YW55fSBbdmFsdWVdXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlKHR5cGUsIGluZGV4LCBrZXksIHZhbHVlKSB7XG5cdFx0aWYgKGluZm8udG9rZW4gIT09IHRva2VuKSByZXR1cm47XG5cdFx0aW5mby5yZXNvbHZlZCA9IHZhbHVlO1xuXHRcdGxldCBjaGlsZF9jdHggPSBpbmZvLmN0eDtcblx0XHRpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNoaWxkX2N0eCA9IGNoaWxkX2N0eC5zbGljZSgpO1xuXHRcdFx0Y2hpbGRfY3R4W2tleV0gPSB2YWx1ZTtcblx0XHR9XG5cdFx0Y29uc3QgYmxvY2sgPSB0eXBlICYmIChpbmZvLmN1cnJlbnQgPSB0eXBlKShjaGlsZF9jdHgpO1xuXHRcdGxldCBuZWVkc19mbHVzaCA9IGZhbHNlO1xuXHRcdGlmIChpbmZvLmJsb2NrKSB7XG5cdFx0XHRpZiAoaW5mby5ibG9ja3MpIHtcblx0XHRcdFx0aW5mby5ibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGkpID0+IHtcblx0XHRcdFx0XHRpZiAoaSAhPT0gaW5kZXggJiYgYmxvY2spIHtcblx0XHRcdFx0XHRcdGdyb3VwX291dHJvcygpO1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKGluZm8uYmxvY2tzW2ldID09PSBibG9jaykge1xuXHRcdFx0XHRcdFx0XHRcdGluZm8uYmxvY2tzW2ldID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRjaGVja19vdXRyb3MoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5mby5ibG9jay5kKDEpO1xuXHRcdFx0fVxuXHRcdFx0YmxvY2suYygpO1xuXHRcdFx0dHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG5cdFx0XHRibG9jay5tKGluZm8ubW91bnQoKSwgaW5mby5hbmNob3IpO1xuXHRcdFx0bmVlZHNfZmx1c2ggPSB0cnVlO1xuXHRcdH1cblx0XHRpbmZvLmJsb2NrID0gYmxvY2s7XG5cdFx0aWYgKGluZm8uYmxvY2tzKSBpbmZvLmJsb2Nrc1tpbmRleF0gPSBibG9jaztcblx0XHRpZiAobmVlZHNfZmx1c2gpIHtcblx0XHRcdGZsdXNoKCk7XG5cdFx0fVxuXHR9XG5cdGlmIChpc19wcm9taXNlKHByb21pc2UpKSB7XG5cdFx0Y29uc3QgY3VycmVudF9jb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcblx0XHRwcm9taXNlLnRoZW4oXG5cdFx0XHQodmFsdWUpID0+IHtcblx0XHRcdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcblx0XHRcdFx0dXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgdmFsdWUpO1xuXHRcdFx0XHRzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG5cdFx0XHR9LFxuXHRcdFx0KGVycm9yKSA9PiB7XG5cdFx0XHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG5cdFx0XHRcdHVwZGF0ZShpbmZvLmNhdGNoLCAyLCBpbmZvLmVycm9yLCBlcnJvcik7XG5cdFx0XHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcblx0XHRcdFx0aWYgKCFpbmZvLmhhc0NhdGNoKSB7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHRcdC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGEgdGhlbi9jYXRjaCBibG9jaywgZGVzdHJveSBpdFxuXHRcdGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8ucGVuZGluZykge1xuXHRcdFx0dXBkYXRlKGluZm8ucGVuZGluZywgMCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGluZm8uY3VycmVudCAhPT0gaW5mby50aGVuKSB7XG5cdFx0XHR1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCBwcm9taXNlKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpbmZvLnJlc29sdmVkID0gLyoqIEB0eXBlIHtUfSAqLyAocHJvbWlzZSk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2goaW5mbywgY3R4LCBkaXJ0eSkge1xuXHRjb25zdCBjaGlsZF9jdHggPSBjdHguc2xpY2UoKTtcblx0Y29uc3QgeyByZXNvbHZlZCB9ID0gaW5mbztcblx0aWYgKGluZm8uY3VycmVudCA9PT0gaW5mby50aGVuKSB7XG5cdFx0Y2hpbGRfY3R4W2luZm8udmFsdWVdID0gcmVzb2x2ZWQ7XG5cdH1cblx0aWYgKGluZm8uY3VycmVudCA9PT0gaW5mby5jYXRjaCkge1xuXHRcdGNoaWxkX2N0eFtpbmZvLmVycm9yXSA9IHJlc29sdmVkO1xuXHR9XG5cdGluZm8uYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbn1cbiIsImltcG9ydCB7IHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0IH0gZnJvbSAnLi90cmFuc2l0aW9ucy5qcyc7XG5pbXBvcnQgeyBydW5fYWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8vIGdlbmVyYWwgZWFjaCBmdW5jdGlvbnM6XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVfYXJyYXlfbGlrZShhcnJheV9saWtlX29yX2l0ZXJhdG9yKSB7XG5cdHJldHVybiBhcnJheV9saWtlX29yX2l0ZXJhdG9yPy5sZW5ndGggIT09IHVuZGVmaW5lZFxuXHRcdD8gYXJyYXlfbGlrZV9vcl9pdGVyYXRvclxuXHRcdDogQXJyYXkuZnJvbShhcnJheV9saWtlX29yX2l0ZXJhdG9yKTtcbn1cblxuLy8ga2V5ZWQgZWFjaCBmdW5jdGlvbnM6XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0YmxvY2suZCgxKTtcblx0bG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHR0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuXHRcdGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcblx0fSk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHRibG9jay5mKCk7XG5cdGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0YmxvY2suZigpO1xuXHRvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cblxuLyoqIEByZXR1cm5zIHthbnlbXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfa2V5ZWRfZWFjaChcblx0b2xkX2Jsb2Nrcyxcblx0ZGlydHksXG5cdGdldF9rZXksXG5cdGR5bmFtaWMsXG5cdGN0eCxcblx0bGlzdCxcblx0bG9va3VwLFxuXHRub2RlLFxuXHRkZXN0cm95LFxuXHRjcmVhdGVfZWFjaF9ibG9jayxcblx0bmV4dCxcblx0Z2V0X2NvbnRleHRcbikge1xuXHRsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuXHRsZXQgbiA9IGxpc3QubGVuZ3RoO1xuXHRsZXQgaSA9IG87XG5cdGNvbnN0IG9sZF9pbmRleGVzID0ge307XG5cdHdoaWxlIChpLS0pIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG5cdGNvbnN0IG5ld19ibG9ja3MgPSBbXTtcblx0Y29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcblx0Y29uc3QgZGVsdGFzID0gbmV3IE1hcCgpO1xuXHRjb25zdCB1cGRhdGVzID0gW107XG5cdGkgPSBuO1xuXHR3aGlsZSAoaS0tKSB7XG5cdFx0Y29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcblx0XHRjb25zdCBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG5cdFx0bGV0IGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuXHRcdGlmICghYmxvY2spIHtcblx0XHRcdGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuXHRcdFx0YmxvY2suYygpO1xuXHRcdH0gZWxzZSBpZiAoZHluYW1pYykge1xuXHRcdFx0Ly8gZGVmZXIgdXBkYXRlcyB1bnRpbCBhbGwgdGhlIERPTSBzaHVmZmxpbmcgaXMgZG9uZVxuXHRcdFx0dXBkYXRlcy5wdXNoKCgpID0+IGJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSkpO1xuXHRcdH1cblx0XHRuZXdfbG9va3VwLnNldChrZXksIChuZXdfYmxvY2tzW2ldID0gYmxvY2spKTtcblx0XHRpZiAoa2V5IGluIG9sZF9pbmRleGVzKSBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcblx0fVxuXHRjb25zdCB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG5cdGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuXHRcdHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuXHRcdGJsb2NrLm0obm9kZSwgbmV4dCk7XG5cdFx0bG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcblx0XHRuZXh0ID0gYmxvY2suZmlyc3Q7XG5cdFx0bi0tO1xuXHR9XG5cdHdoaWxlIChvICYmIG4pIHtcblx0XHRjb25zdCBuZXdfYmxvY2sgPSBuZXdfYmxvY2tzW24gLSAxXTtcblx0XHRjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW28gLSAxXTtcblx0XHRjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcblx0XHRjb25zdCBvbGRfa2V5ID0gb2xkX2Jsb2NrLmtleTtcblx0XHRpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcblx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG5cdFx0XHRvLS07XG5cdFx0XHRuLS07XG5cdFx0fSBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcblx0XHRcdC8vIHJlbW92ZSBvbGQgYmxvY2tcblx0XHRcdGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuXHRcdFx0by0tO1xuXHRcdH0gZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuXHRcdFx0aW5zZXJ0KG5ld19ibG9jayk7XG5cdFx0fSBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcblx0XHRcdG8tLTtcblx0XHR9IGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG5cdFx0XHRkaWRfbW92ZS5hZGQobmV3X2tleSk7XG5cdFx0XHRpbnNlcnQobmV3X2Jsb2NrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcblx0XHRcdG8tLTtcblx0XHR9XG5cdH1cblx0d2hpbGUgKG8tLSkge1xuXHRcdGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3Nbb107XG5cdFx0aWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfYmxvY2sua2V5KSkgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG5cdH1cblx0d2hpbGUgKG4pIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG5cdHJ1bl9hbGwodXBkYXRlcyk7XG5cdHJldHVybiBuZXdfYmxvY2tzO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9rZXlzKGN0eCwgbGlzdCwgZ2V0X2NvbnRleHQsIGdldF9rZXkpIHtcblx0Y29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qga2V5ID0gZ2V0X2tleShnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpKTtcblx0XHRpZiAoa2V5cy5oYXMoa2V5KSkge1xuXHRcdFx0bGV0IHZhbHVlID0gJyc7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YWx1ZSA9IGB3aXRoIHZhbHVlICcke1N0cmluZyhrZXkpfScgYDtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gY2FuJ3Qgc3RyaW5naWZ5XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdGBDYW5ub3QgaGF2ZSBkdXBsaWNhdGUga2V5cyBpbiBhIGtleWVkIGVhY2g6IEtleXMgYXQgaW5kZXggJHtrZXlzLmdldChcblx0XHRcdFx0XHRrZXlcblx0XHRcdFx0KX0gYW5kICR7aX0gJHt2YWx1ZX1hcmUgZHVwbGljYXRlc2Bcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGtleXMuc2V0KGtleSwgaSk7XG5cdH1cbn1cbiIsImNvbnN0IF9ib29sZWFuX2F0dHJpYnV0ZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuXHQnYWxsb3dmdWxsc2NyZWVuJyxcblx0J2FsbG93cGF5bWVudHJlcXVlc3QnLFxuXHQnYXN5bmMnLFxuXHQnYXV0b2ZvY3VzJyxcblx0J2F1dG9wbGF5Jyxcblx0J2NoZWNrZWQnLFxuXHQnY29udHJvbHMnLFxuXHQnZGVmYXVsdCcsXG5cdCdkZWZlcicsXG5cdCdkaXNhYmxlZCcsXG5cdCdmb3Jtbm92YWxpZGF0ZScsXG5cdCdoaWRkZW4nLFxuXHQnaW5lcnQnLFxuXHQnaXNtYXAnLFxuXHQnbG9vcCcsXG5cdCdtdWx0aXBsZScsXG5cdCdtdXRlZCcsXG5cdCdub21vZHVsZScsXG5cdCdub3ZhbGlkYXRlJyxcblx0J29wZW4nLFxuXHQncGxheXNpbmxpbmUnLFxuXHQncmVhZG9ubHknLFxuXHQncmVxdWlyZWQnLFxuXHQncmV2ZXJzZWQnLFxuXHQnc2VsZWN0ZWQnXG5dKTtcblxuLyoqXG4gKiBMaXN0IG9mIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzIChlLmcuIGA8aW5wdXQgZGlzYWJsZWQ+YCkuXG4gKiBTb3VyY2U6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbFxuICpcbiAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoWy4uLl9ib29sZWFuX2F0dHJpYnV0ZXNdKTtcblxuLyoqIEB0eXBlZGVmIHt0eXBlb2YgX2Jvb2xlYW5fYXR0cmlidXRlc1tudW1iZXJdfSBCb29sZWFuQXR0cmlidXRlcyAqL1xuIiwiaW1wb3J0IHsgc2V0X2N1cnJlbnRfY29tcG9uZW50LCBjdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IHJ1bl9hbGwsIGJsYW5rX29iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgYm9vbGVhbl9hdHRyaWJ1dGVzIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2Jvb2xlYW5fYXR0cmlidXRlcy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVfYXJyYXlfbGlrZSB9IGZyb20gJy4vZWFjaC5qcyc7XG5leHBvcnQgeyBpc192b2lkIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzL25hbWVzLmpzJztcblxuZXhwb3J0IGNvbnN0IGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyID1cblx0L1tcXHMnXCI+Lz1cXHV7RkREMH0tXFx1e0ZERUZ9XFx1e0ZGRkV9XFx1e0ZGRkZ9XFx1ezFGRkZFfVxcdXsxRkZGRn1cXHV7MkZGRkV9XFx1ezJGRkZGfVxcdXszRkZGRX1cXHV7M0ZGRkZ9XFx1ezRGRkZFfVxcdXs0RkZGRn1cXHV7NUZGRkV9XFx1ezVGRkZGfVxcdXs2RkZGRX1cXHV7NkZGRkZ9XFx1ezdGRkZFfVxcdXs3RkZGRn1cXHV7OEZGRkV9XFx1ezhGRkZGfVxcdXs5RkZGRX1cXHV7OUZGRkZ9XFx1e0FGRkZFfVxcdXtBRkZGRn1cXHV7QkZGRkV9XFx1e0JGRkZGfVxcdXtDRkZGRX1cXHV7Q0ZGRkZ9XFx1e0RGRkZFfVxcdXtERkZGRn1cXHV7RUZGRkV9XFx1e0VGRkZGfVxcdXtGRkZGRX1cXHV7RkZGRkZ9XFx1ezEwRkZGRX1cXHV7MTBGRkZGfV0vdTtcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuXG4vKiogQHJldHVybnMge3N0cmluZ30gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcHJlYWQoYXJncywgYXR0cnNfdG9fYWRkKSB7XG5cdGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcblx0aWYgKGF0dHJzX3RvX2FkZCkge1xuXHRcdGNvbnN0IGNsYXNzZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLmNsYXNzZXM7XG5cdFx0Y29uc3Qgc3R5bGVzX3RvX2FkZCA9IGF0dHJzX3RvX2FkZC5zdHlsZXM7XG5cdFx0aWYgKGNsYXNzZXNfdG9fYWRkKSB7XG5cdFx0XHRpZiAoYXR0cmlidXRlcy5jbGFzcyA9PSBudWxsKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc2VzX3RvX2FkZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMuY2xhc3MgKz0gJyAnICsgY2xhc3Nlc190b19hZGQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzdHlsZXNfdG9fYWRkKSB7XG5cdFx0XHRpZiAoYXR0cmlidXRlcy5zdHlsZSA9PSBudWxsKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMuc3R5bGUgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlc190b19hZGQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoXG5cdFx0XHRcdFx0bWVyZ2Vfc3NyX3N0eWxlcyhhdHRyaWJ1dGVzLnN0eWxlLCBzdHlsZXNfdG9fYWRkKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRsZXQgc3RyID0gJyc7XG5cdE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goKG5hbWUpID0+IHtcblx0XHRpZiAoaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIudGVzdChuYW1lKSkgcmV0dXJuO1xuXHRcdGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IHRydWUpIHN0ciArPSAnICcgKyBuYW1lO1xuXHRcdGVsc2UgaWYgKGJvb2xlYW5fYXR0cmlidXRlcy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuXHRcdFx0aWYgKHZhbHVlKSBzdHIgKz0gJyAnICsgbmFtZTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdHN0ciArPSBgICR7bmFtZX09XCIke3ZhbHVlfVwiYDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gc3RyO1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlX3Nzcl9zdHlsZXMoc3R5bGVfYXR0cmlidXRlLCBzdHlsZV9kaXJlY3RpdmUpIHtcblx0Y29uc3Qgc3R5bGVfb2JqZWN0ID0ge307XG5cdGZvciAoY29uc3QgaW5kaXZpZHVhbF9zdHlsZSBvZiBzdHlsZV9hdHRyaWJ1dGUuc3BsaXQoJzsnKSkge1xuXHRcdGNvbnN0IGNvbG9uX2luZGV4ID0gaW5kaXZpZHVhbF9zdHlsZS5pbmRleE9mKCc6Jyk7XG5cdFx0Y29uc3QgbmFtZSA9IGluZGl2aWR1YWxfc3R5bGUuc2xpY2UoMCwgY29sb25faW5kZXgpLnRyaW0oKTtcblx0XHRjb25zdCB2YWx1ZSA9IGluZGl2aWR1YWxfc3R5bGUuc2xpY2UoY29sb25faW5kZXggKyAxKS50cmltKCk7XG5cdFx0aWYgKCFuYW1lKSBjb250aW51ZTtcblx0XHRzdHlsZV9vYmplY3RbbmFtZV0gPSB2YWx1ZTtcblx0fVxuXHRmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGVfZGlyZWN0aXZlKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBzdHlsZV9kaXJlY3RpdmVbbmFtZV07XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRzdHlsZV9vYmplY3RbbmFtZV0gPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIHN0eWxlX29iamVjdFtuYW1lXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHN0eWxlX29iamVjdDtcbn1cblxuY29uc3QgQVRUUl9SRUdFWCA9IC9bJlwiXS9nO1xuY29uc3QgQ09OVEVOVF9SRUdFWCA9IC9bJjxdL2c7XG5cbi8qKlxuICogTm90ZTogdGhpcyBtZXRob2QgaXMgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlIGFuZCBoYXMgYmVlbiBvcHRpbWl6ZWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC81NzAxXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlKHZhbHVlLCBpc19hdHRyID0gZmFsc2UpIHtcblx0Y29uc3Qgc3RyID0gU3RyaW5nKHZhbHVlKTtcblx0Y29uc3QgcGF0dGVybiA9IGlzX2F0dHIgPyBBVFRSX1JFR0VYIDogQ09OVEVOVF9SRUdFWDtcblx0cGF0dGVybi5sYXN0SW5kZXggPSAwO1xuXHRsZXQgZXNjYXBlZCA9ICcnO1xuXHRsZXQgbGFzdCA9IDA7XG5cdHdoaWxlIChwYXR0ZXJuLnRlc3Qoc3RyKSkge1xuXHRcdGNvbnN0IGkgPSBwYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG5cdFx0Y29uc3QgY2ggPSBzdHJbaV07XG5cdFx0ZXNjYXBlZCArPSBzdHIuc3Vic3RyaW5nKGxhc3QsIGkpICsgKGNoID09PSAnJicgPyAnJmFtcDsnIDogY2ggPT09ICdcIicgPyAnJnF1b3Q7JyA6ICcmbHQ7Jyk7XG5cdFx0bGFzdCA9IGkgKyAxO1xuXHR9XG5cdHJldHVybiBlc2NhcGVkICsgc3RyLnN1YnN0cmluZyhsYXN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUodmFsdWUpIHtcblx0Ly8ga2VlcCBib29sZWFucywgbnVsbCwgYW5kIHVuZGVmaW5lZCBmb3IgdGhlIHNha2Ugb2YgYHNwcmVhZGBcblx0Y29uc3Qgc2hvdWxkX2VzY2FwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpO1xuXHRyZXR1cm4gc2hvdWxkX2VzY2FwZSA/IGVzY2FwZSh2YWx1ZSwgdHJ1ZSkgOiB2YWx1ZTtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVfb2JqZWN0KG9iaikge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG5cdFx0cmVzdWx0W2tleV0gPSBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKG9ialtrZXldKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQHJldHVybnMge3N0cmluZ30gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuXHRpdGVtcyA9IGVuc3VyZV9hcnJheV9saWtlKGl0ZW1zKTtcblx0bGV0IHN0ciA9ICcnO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0c3RyICs9IGZuKGl0ZW1zW2ldLCBpKTtcblx0fVxuXHRyZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgY29uc3QgbWlzc2luZ19jb21wb25lbnQgPSB7XG5cdCQkcmVuZGVyOiAoKSA9PiAnJ1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2NvbXBvbmVudChjb21wb25lbnQsIG5hbWUpIHtcblx0aWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC4kJHJlbmRlcikge1xuXHRcdGlmIChuYW1lID09PSAnc3ZlbHRlOmNvbXBvbmVudCcpIG5hbWUgKz0gJyB0aGlzPXsuLi59Jztcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRgPCR7bmFtZX0+IGlzIG5vdCBhIHZhbGlkIFNTUiBjb21wb25lbnQuIFlvdSBtYXkgbmVlZCB0byByZXZpZXcgeW91ciBidWlsZCBjb25maWcgdG8gZW5zdXJlIHRoYXQgZGVwZW5kZW5jaWVzIGFyZSBjb21waWxlZCwgcmF0aGVyIHRoYW4gaW1wb3J0ZWQgYXMgcHJlLWNvbXBpbGVkIG1vZHVsZXMuIE90aGVyd2lzZSB5b3UgbWF5IG5lZWQgdG8gZml4IGEgPCR7bmFtZX0+LmBcblx0XHQpO1xuXHR9XG5cdHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnKGZpbGUsIGxpbmUsIGNvbHVtbiwgdmFsdWVzKSB7XG5cdGNvbnNvbGUubG9nKGB7QGRlYnVnfSAke2ZpbGUgPyBmaWxlICsgJyAnIDogJyd9KCR7bGluZX06JHtjb2x1bW59KWApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0Y29uc29sZS5sb2codmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdHJldHVybiAnJztcbn1cblxubGV0IG9uX2Rlc3Ryb3k7XG5cbi8qKiBAcmV0dXJucyB7eyByZW5kZXI6IChwcm9wcz86IHt9LCB7ICQkc2xvdHMsIGNvbnRleHQgfT86IHsgJCRzbG90cz86IHt9OyBjb250ZXh0PzogTWFwPGFueSwgYW55PjsgfSkgPT4geyBodG1sOiBhbnk7IGNzczogeyBjb2RlOiBzdHJpbmc7IG1hcDogYW55OyB9OyBoZWFkOiBzdHJpbmc7IH07ICQkcmVuZGVyOiAocmVzdWx0OiBhbnksIHByb3BzOiBhbnksIGJpbmRpbmdzOiBhbnksIHNsb3RzOiBhbnksIGNvbnRleHQ6IGFueSkgPT4gYW55OyB9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9zc3JfY29tcG9uZW50KGZuKSB7XG5cdGZ1bmN0aW9uICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cywgY29udGV4dCkge1xuXHRcdGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcblx0XHRjb25zdCAkJCA9IHtcblx0XHRcdG9uX2Rlc3Ryb3ksXG5cdFx0XHRjb250ZXh0OiBuZXcgTWFwKGNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuXHRcdFx0Ly8gdGhlc2Ugd2lsbCBiZSBpbW1lZGlhdGVseSBkaXNjYXJkZWRcblx0XHRcdG9uX21vdW50OiBbXSxcblx0XHRcdGJlZm9yZV91cGRhdGU6IFtdLFxuXHRcdFx0YWZ0ZXJfdXBkYXRlOiBbXSxcblx0XHRcdGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KClcblx0XHR9O1xuXHRcdHNldF9jdXJyZW50X2NvbXBvbmVudCh7ICQkIH0pO1xuXHRcdGNvbnN0IGh0bWwgPSBmbihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMpO1xuXHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcblx0XHRyZXR1cm4gaHRtbDtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHJlbmRlcjogKHByb3BzID0ge30sIHsgJCRzbG90cyA9IHt9LCBjb250ZXh0ID0gbmV3IE1hcCgpIH0gPSB7fSkgPT4ge1xuXHRcdFx0b25fZGVzdHJveSA9IFtdO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0geyB0aXRsZTogJycsIGhlYWQ6ICcnLCBjc3M6IG5ldyBTZXQoKSB9O1xuXHRcdFx0Y29uc3QgaHRtbCA9ICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIHt9LCAkJHNsb3RzLCBjb250ZXh0KTtcblx0XHRcdHJ1bl9hbGwob25fZGVzdHJveSk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRodG1sLFxuXHRcdFx0XHRjc3M6IHtcblx0XHRcdFx0XHRjb2RlOiBBcnJheS5mcm9tKHJlc3VsdC5jc3MpXG5cdFx0XHRcdFx0XHQubWFwKChjc3MpID0+IGNzcy5jb2RlKVxuXHRcdFx0XHRcdFx0LmpvaW4oJ1xcbicpLFxuXHRcdFx0XHRcdG1hcDogbnVsbCAvLyBUT0RPXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGhlYWQ6IHJlc3VsdC50aXRsZSArIHJlc3VsdC5oZWFkXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0JCRyZW5kZXJcblx0fTtcbn1cblxuLyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2F0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgYm9vbGVhbikge1xuXHRpZiAodmFsdWUgPT0gbnVsbCB8fCAoYm9vbGVhbiAmJiAhdmFsdWUpKSByZXR1cm4gJyc7XG5cdGNvbnN0IGFzc2lnbm1lbnQgPSBib29sZWFuICYmIHZhbHVlID09PSB0cnVlID8gJycgOiBgPVwiJHtlc2NhcGUodmFsdWUsIHRydWUpfVwiYDtcblx0cmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuXG4vKiogQHJldHVybnMge3N0cmluZ30gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfY2xhc3NlcyhjbGFzc2VzKSB7XG5cdHJldHVybiBjbGFzc2VzID8gYCBjbGFzcz1cIiR7Y2xhc3Nlc31cImAgOiAnJztcbn1cblxuLyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXG5mdW5jdGlvbiBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlX29iamVjdCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMoc3R5bGVfb2JqZWN0KVxuXHRcdC5maWx0ZXIoKGtleSkgPT4gc3R5bGVfb2JqZWN0W2tleV0pXG5cdFx0Lm1hcCgoa2V5KSA9PiBgJHtrZXl9OiAke2VzY2FwZV9hdHRyaWJ1dGVfdmFsdWUoc3R5bGVfb2JqZWN0W2tleV0pfTtgKVxuXHRcdC5qb2luKCcgJyk7XG59XG5cbi8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9zdHlsZXMoc3R5bGVfb2JqZWN0KSB7XG5cdGNvbnN0IHN0eWxlcyA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KTtcblx0cmV0dXJuIHN0eWxlcyA/IGAgc3R5bGU9XCIke3N0eWxlc31cImAgOiAnJztcbn1cbiIsImltcG9ydCB7XG5cdGFkZF9yZW5kZXJfY2FsbGJhY2ssXG5cdGZsdXNoLFxuXHRmbHVzaF9yZW5kZXJfY2FsbGJhY2tzLFxuXHRzY2hlZHVsZV91cGRhdGUsXG5cdGRpcnR5X2NvbXBvbmVudHNcbn0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQsIHNldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IGJsYW5rX29iamVjdCwgaXNfZW1wdHksIGlzX2Z1bmN0aW9uLCBydW4sIHJ1bl9hbGwsIG5vb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGNoaWxkcmVuLFxuXHRkZXRhY2gsXG5cdHN0YXJ0X2h5ZHJhdGluZyxcblx0ZW5kX2h5ZHJhdGluZyxcblx0Z2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyxcblx0aW5zZXJ0XG59IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IHRyYW5zaXRpb25faW4gfSBmcm9tICcuL3RyYW5zaXRpb25zLmpzJztcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuXHRjb25zdCBpbmRleCA9IGNvbXBvbmVudC4kJC5wcm9wc1tuYW1lXTtcblx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb21wb25lbnQuJCQuYm91bmRbaW5kZXhdID0gY2FsbGJhY2s7XG5cdFx0Y2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfY29tcG9uZW50KGJsb2NrKSB7XG5cdGJsb2NrICYmIGJsb2NrLmMoKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2NvbXBvbmVudChibG9jaywgcGFyZW50X25vZGVzKSB7XG5cdGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yKSB7XG5cdGNvbnN0IHsgZnJhZ21lbnQsIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuXHRmcmFnbWVudCAmJiBmcmFnbWVudC5tKHRhcmdldCwgYW5jaG9yKTtcblx0Ly8gb25Nb3VudCBoYXBwZW5zIGJlZm9yZSB0aGUgaW5pdGlhbCBhZnRlclVwZGF0ZVxuXHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IHtcblx0XHRjb25zdCBuZXdfb25fZGVzdHJveSA9IGNvbXBvbmVudC4kJC5vbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuXHRcdC8vIGlmIHRoZSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseVxuXHRcdC8vIGl0IHdpbGwgdXBkYXRlIHRoZSBgJCQub25fZGVzdHJveWAgcmVmZXJlbmNlIHRvIGBudWxsYC5cblx0XHQvLyB0aGUgZGVzdHJ1Y3R1cmVkIG9uX2Rlc3Ryb3kgbWF5IHN0aWxsIHJlZmVyZW5jZSB0byB0aGUgb2xkIGFycmF5XG5cdFx0aWYgKGNvbXBvbmVudC4kJC5vbl9kZXN0cm95KSB7XG5cdFx0XHRjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKC4uLm5ld19vbl9kZXN0cm95KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG5cdFx0XHQvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG5cdFx0XHRydW5fYWxsKG5ld19vbl9kZXN0cm95KTtcblx0XHR9XG5cdFx0Y29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG5cdH0pO1xuXHRhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG5cdGNvbnN0ICQkID0gY29tcG9uZW50LiQkO1xuXHRpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcblx0XHRmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKCQkLmFmdGVyX3VwZGF0ZSk7XG5cdFx0cnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcblx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG5cdFx0Ly8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuXHRcdC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcblx0XHQkJC5vbl9kZXN0cm95ID0gJCQuZnJhZ21lbnQgPSBudWxsO1xuXHRcdCQkLmN0eCA9IFtdO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG5cdGlmIChjb21wb25lbnQuJCQuZGlydHlbMF0gPT09IC0xKSB7XG5cdFx0ZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG5cdFx0c2NoZWR1bGVfdXBkYXRlKCk7XG5cdFx0Y29tcG9uZW50LiQkLmRpcnR5LmZpbGwoMCk7XG5cdH1cblx0Y29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gMSA8PCBpICUgMzE7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0KFxuXHRjb21wb25lbnQsXG5cdG9wdGlvbnMsXG5cdGluc3RhbmNlLFxuXHRjcmVhdGVfZnJhZ21lbnQsXG5cdG5vdF9lcXVhbCxcblx0cHJvcHMsXG5cdGFwcGVuZF9zdHlsZXMsXG5cdGRpcnR5ID0gWy0xXVxuKSB7XG5cdGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcblx0c2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5UJCR9ICovXG5cdGNvbnN0ICQkID0gKGNvbXBvbmVudC4kJCA9IHtcblx0XHRmcmFnbWVudDogbnVsbCxcblx0XHRjdHg6IFtdLFxuXHRcdC8vIHN0YXRlXG5cdFx0cHJvcHMsXG5cdFx0dXBkYXRlOiBub29wLFxuXHRcdG5vdF9lcXVhbCxcblx0XHRib3VuZDogYmxhbmtfb2JqZWN0KCksXG5cdFx0Ly8gbGlmZWN5Y2xlXG5cdFx0b25fbW91bnQ6IFtdLFxuXHRcdG9uX2Rlc3Ryb3k6IFtdLFxuXHRcdG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuXHRcdGJlZm9yZV91cGRhdGU6IFtdLFxuXHRcdGFmdGVyX3VwZGF0ZTogW10sXG5cdFx0Y29udGV4dDogbmV3IE1hcChvcHRpb25zLmNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuXHRcdC8vIGV2ZXJ5dGhpbmcgZWxzZVxuXHRcdGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG5cdFx0ZGlydHksXG5cdFx0c2tpcF9ib3VuZDogZmFsc2UsXG5cdFx0cm9vdDogb3B0aW9ucy50YXJnZXQgfHwgcGFyZW50X2NvbXBvbmVudC4kJC5yb290XG5cdH0pO1xuXHRhcHBlbmRfc3R5bGVzICYmIGFwcGVuZF9zdHlsZXMoJCQucm9vdCk7XG5cdGxldCByZWFkeSA9IGZhbHNlO1xuXHQkJC5jdHggPSBpbnN0YW5jZVxuXHRcdD8gaW5zdGFuY2UoY29tcG9uZW50LCBvcHRpb25zLnByb3BzIHx8IHt9LCAoaSwgcmV0LCAuLi5yZXN0KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gcmVzdC5sZW5ndGggPyByZXN0WzBdIDogcmV0O1xuXHRcdFx0XHRpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCgkJC5jdHhbaV0sICgkJC5jdHhbaV0gPSB2YWx1ZSkpKSB7XG5cdFx0XHRcdFx0aWYgKCEkJC5za2lwX2JvdW5kICYmICQkLmJvdW5kW2ldKSAkJC5ib3VuZFtpXSh2YWx1ZSk7XG5cdFx0XHRcdFx0aWYgKHJlYWR5KSBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHQgIH0pXG5cdFx0OiBbXTtcblx0JCQudXBkYXRlKCk7XG5cdHJlYWR5ID0gdHJ1ZTtcblx0cnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcblx0Ly8gYGZhbHNlYCBhcyBhIHNwZWNpYWwgY2FzZSBvZiBubyBET00gY29tcG9uZW50XG5cdCQkLmZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50ID8gY3JlYXRlX2ZyYWdtZW50KCQkLmN0eCkgOiBmYWxzZTtcblx0aWYgKG9wdGlvbnMudGFyZ2V0KSB7XG5cdFx0aWYgKG9wdGlvbnMuaHlkcmF0ZSkge1xuXHRcdFx0c3RhcnRfaHlkcmF0aW5nKCk7XG5cdFx0XHRjb25zdCBub2RlcyA9IGNoaWxkcmVuKG9wdGlvbnMudGFyZ2V0KTtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG5cdFx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5sKG5vZGVzKTtcblx0XHRcdG5vZGVzLmZvckVhY2goZGV0YWNoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cblx0XHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW50cm8pIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcblx0XHRtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IpO1xuXHRcdGVuZF9oeWRyYXRpbmcoKTtcblx0XHRmbHVzaCgpO1xuXHR9XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cblxuZXhwb3J0IGxldCBTdmVsdGVFbGVtZW50O1xuXG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcblx0XHQkJGNvbXBvbmVudEN0b3I7XG5cdFx0JCRzbG90cztcblx0XHQkJGNvbXBvbmVudDtcblx0XHQkJGNvbm5lY3RlZCA9IGZhbHNlO1xuXHRcdCQkZGF0YSA9IHt9O1xuXHRcdCQkcmVmbGVjdGluZyA9IGZhbHNlO1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gKi9cblx0XHQkJHByb3BzX2RlZmluaXRpb24gPSB7fTtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uW10+fSAqL1xuXHRcdCQkbGlzdGVuZXJzID0ge307XG5cdFx0LyoqIEB0eXBlIHtNYXA8RnVuY3Rpb24sIEZ1bmN0aW9uPn0gKi9cblx0XHQkJGxpc3RlbmVyX3Vuc3Vic2NyaWJlX2ZucyA9IG5ldyBNYXAoKTtcblxuXHRcdGNvbnN0cnVjdG9yKCQkY29tcG9uZW50Q3RvciwgJCRzbG90cywgdXNlX3NoYWRvd19kb20pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLiQkY29tcG9uZW50Q3RvciA9ICQkY29tcG9uZW50Q3Rvcjtcblx0XHRcdHRoaXMuJCRzbG90cyA9ICQkc2xvdHM7XG5cdFx0XHRpZiAodXNlX3NoYWRvd19kb20pIHtcblx0XHRcdFx0dGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuXHRcdFx0Ly8gV2UgY2FuJ3QgZGV0ZXJtaW5lIHVwZnJvbnQgaWYgdGhlIGV2ZW50IGlzIGEgY3VzdG9tIGV2ZW50IG9yIG5vdCwgc28gd2UgaGF2ZSB0b1xuXHRcdFx0Ly8gbGlzdGVuIHRvIGJvdGguIElmIHNvbWVvbmUgdXNlcyBhIGN1c3RvbSBldmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgYSByZWd1bGFyXG5cdFx0XHQvLyBicm93c2VyIGV2ZW50LCB0aGlzIGZpcmVzIHR3aWNlIC0gd2UgY2FuJ3QgYXZvaWQgdGhhdC5cblx0XHRcdHRoaXMuJCRsaXN0ZW5lcnNbdHlwZV0gPSB0aGlzLiQkbGlzdGVuZXJzW3R5cGVdIHx8IFtdO1xuXHRcdFx0dGhpcy4kJGxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdGlmICh0aGlzLiQkY29tcG9uZW50KSB7XG5cdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGNvbXBvbmVudC4kb24odHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0XHR0aGlzLiQkbGlzdGVuZXJfdW5zdWJzY3JpYmVfZm5zLnNldChsaXN0ZW5lciwgdW5zdWIpO1xuXHRcdFx0fVxuXHRcdFx0c3VwZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuXHRcdFx0c3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG5cdFx0XHRpZiAodGhpcy4kJGNvbXBvbmVudCkge1xuXHRcdFx0XHRjb25zdCB1bnN1YiA9IHRoaXMuJCRsaXN0ZW5lcl91bnN1YnNjcmliZV9mbnMuZ2V0KGxpc3RlbmVyKTtcblx0XHRcdFx0aWYgKHVuc3ViKSB7XG5cdFx0XHRcdFx0dW5zdWIoKTtcblx0XHRcdFx0XHR0aGlzLiQkbGlzdGVuZXJfdW5zdWJzY3JpYmVfZm5zLmRlbGV0ZShsaXN0ZW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRhc3luYyBjb25uZWN0ZWRDYWxsYmFjaygpIHtcblx0XHRcdHRoaXMuJCRjb25uZWN0ZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCF0aGlzLiQkY29tcG9uZW50KSB7XG5cdFx0XHRcdC8vIFdlIHdhaXQgb25lIHRpY2sgdG8gbGV0IHBvc3NpYmxlIGNoaWxkIHNsb3QgZWxlbWVudHMgYmUgY3JlYXRlZC9tb3VudGVkXG5cdFx0XHRcdGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuJCRjb25uZWN0ZWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gY3JlYXRlX3Nsb3QobmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgbm9kZTtcblx0XHRcdFx0XHRcdGNvbnN0IG9iaiA9IHtcblx0XHRcdFx0XHRcdFx0YzogZnVuY3Rpb24gY3JlYXRlKCkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzbG90Jyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5hbWUgIT09ICdkZWZhdWx0Jykge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBuYW1lKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcblx0XHRcdFx0XHRcdFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2FuY2hvcl1cblx0XHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRcdG06IGZ1bmN0aW9uIG1vdW50KHRhcmdldCwgYW5jaG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZDogZnVuY3Rpb24gZGVzdHJveShkZXRhY2hpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZGV0YWNoaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZXRhY2gobm9kZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0ICQkc2xvdHMgPSB7fTtcblx0XHRcdFx0Y29uc3QgZXhpc3Rpbmdfc2xvdHMgPSBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKHRoaXMpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy4kJHNsb3RzKSB7XG5cdFx0XHRcdFx0aWYgKG5hbWUgaW4gZXhpc3Rpbmdfc2xvdHMpIHtcblx0XHRcdFx0XHRcdCQkc2xvdHNbbmFtZV0gPSBbY3JlYXRlX3Nsb3QobmFtZSldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiB0aGlzLmF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0XHQvLyB0aGlzLiQkZGF0YSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcy5hdHRyaWJ1dGVzXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IHRoaXMuJCRnZXRfcHJvcF9uYW1lKGF0dHJpYnV0ZS5uYW1lKTtcblx0XHRcdFx0XHRpZiAoIShuYW1lIGluIHRoaXMuJCRkYXRhKSkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRhdGFbbmFtZV0gPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUoXG5cdFx0XHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0XHRcdGF0dHJpYnV0ZS52YWx1ZSxcblx0XHRcdFx0XHRcdFx0dGhpcy4kJHByb3BzX2RlZmluaXRpb24sXG5cdFx0XHRcdFx0XHRcdCd0b1Byb3AnXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiQkY29tcG9uZW50ID0gbmV3IHRoaXMuJCRjb21wb25lbnRDdG9yKHtcblx0XHRcdFx0XHR0YXJnZXQ6IHRoaXMuc2hhZG93Um9vdCB8fCB0aGlzLFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHQuLi50aGlzLiQkZGF0YSxcblx0XHRcdFx0XHRcdCQkc2xvdHMsXG5cdFx0XHRcdFx0XHQkJHNjb3BlOiB7XG5cdFx0XHRcdFx0XHRcdGN0eDogW11cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHR5cGUgaW4gdGhpcy4kJGxpc3RlbmVycykge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4kJGxpc3RlbmVyc1t0eXBlXSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkY29tcG9uZW50LiRvbih0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHR0aGlzLiQkbGlzdGVuZXJfdW5zdWJzY3JpYmVfZm5zLnNldChsaXN0ZW5lciwgdW5zdWIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiQkbGlzdGVuZXJzID0ge307XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gV2UgZG9uJ3QgbmVlZCB0aGlzIHdoZW4gd29ya2luZyB3aXRoaW4gU3ZlbHRlIGNvZGUsIGJ1dCBmb3IgY29tcGF0aWJpbGl0eSBvZiBwZW9wbGUgdXNpbmcgdGhpcyBvdXRzaWRlIG9mIFN2ZWx0ZVxuXHRcdC8vIGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMgdGhyb3VnaCBzZXRBdHRyaWJ1dGUgZXRjLCB0aGlzIGlzIGhlbHBmdWxcblx0XHRhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuJCRyZWZsZWN0aW5nKSByZXR1cm47XG5cdFx0XHRhdHRyID0gdGhpcy4kJGdldF9wcm9wX25hbWUoYXR0cik7XG5cdFx0XHR0aGlzLiQkZGF0YVthdHRyXSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShcblx0XHRcdFx0YXR0cixcblx0XHRcdFx0bmV3VmFsdWUsXG5cdFx0XHRcdHRoaXMuJCRwcm9wc19kZWZpbml0aW9uLFxuXHRcdFx0XHQndG9Qcm9wJ1xuXHRcdFx0KTtcblx0XHRcdHRoaXMuJCRjb21wb25lbnQ/LiRzZXQoeyBbYXR0cl06IHRoaXMuJCRkYXRhW2F0dHJdIH0pO1xuXHRcdH1cblxuXHRcdGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuXHRcdFx0dGhpcy4kJGNvbm5lY3RlZCA9IGZhbHNlO1xuXHRcdFx0Ly8gSW4gYSBtaWNyb3Rhc2ssIGJlY2F1c2UgdGhpcyBjb3VsZCBiZSBhIG1vdmUgd2l0aGluIHRoZSBET01cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRpZiAoIXRoaXMuJCRjb25uZWN0ZWQpIHtcblx0XHRcdFx0XHR0aGlzLiQkY29tcG9uZW50LiRkZXN0cm95KCk7XG5cdFx0XHRcdFx0dGhpcy4kJGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0JCRnZXRfcHJvcF9uYW1lKGF0dHJpYnV0ZV9uYW1lKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRPYmplY3Qua2V5cyh0aGlzLiQkcHJvcHNfZGVmaW5pdGlvbikuZmluZChcblx0XHRcdFx0XHQoa2V5KSA9PlxuXHRcdFx0XHRcdFx0dGhpcy4kJHByb3BzX2RlZmluaXRpb25ba2V5XS5hdHRyaWJ1dGUgPT09IGF0dHJpYnV0ZV9uYW1lIHx8XG5cdFx0XHRcdFx0XHQoIXRoaXMuJCRwcm9wc19kZWZpbml0aW9uW2tleV0uYXR0cmlidXRlICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSBhdHRyaWJ1dGVfbmFtZSlcblx0XHRcdFx0KSB8fCBhdHRyaWJ1dGVfbmFtZVxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBwcm9wc19kZWZpbml0aW9uXG4gKiBAcGFyYW0geyd0b0F0dHJpYnV0ZScgfCAndG9Qcm9wJ30gW3RyYW5zZm9ybV1cbiAqL1xuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKHByb3AsIHZhbHVlLCBwcm9wc19kZWZpbml0aW9uLCB0cmFuc2Zvcm0pIHtcblx0Y29uc3QgdHlwZSA9IHByb3BzX2RlZmluaXRpb25bcHJvcF0/LnR5cGU7XG5cdHZhbHVlID0gdHlwZSA9PT0gJ0Jvb2xlYW4nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nID8gdmFsdWUgIT0gbnVsbCA6IHZhbHVlO1xuXHRpZiAoIXRyYW5zZm9ybSB8fCAhcHJvcHNfZGVmaW5pdGlvbltwcm9wXSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSBlbHNlIGlmICh0cmFuc2Zvcm0gPT09ICd0b0F0dHJpYnV0ZScpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyAnJyA6IG51bGw7XG5cdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSlNPTi5wYXJzZSh2YWx1ZSk7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlOyAvLyBjb252ZXJzaW9uIGFscmVhZHkgaGFuZGxlZCBhYm92ZVxuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlICE9IG51bGwgPyArdmFsdWUgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBUdXJuIGEgU3ZlbHRlIGNvbXBvbmVudCBpbnRvIGEgY3VzdG9tIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Db21wb25lbnRUeXBlfSBDb21wb25lbnQgIEEgU3ZlbHRlIGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBwcm9wc19kZWZpbml0aW9uICBUaGUgcHJvcHMgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gc2xvdHMgIFRoZSBzbG90cyB0byBjcmVhdGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFjY2Vzc29ycyAgT3RoZXIgYWNjZXNzb3JzIGJlc2lkZXMgdGhlIG9uZXMgZm9yIHByb3BzIHRoZSBjb21wb25lbnQgaGFzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZV9zaGFkb3dfZG9tICBXaGV0aGVyIHRvIHVzZSBzaGFkb3cgRE9NXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfY3VzdG9tX2VsZW1lbnQoXG5cdENvbXBvbmVudCxcblx0cHJvcHNfZGVmaW5pdGlvbixcblx0c2xvdHMsXG5cdGFjY2Vzc29ycyxcblx0dXNlX3NoYWRvd19kb21cbikge1xuXHRjb25zdCBDbGFzcyA9IGNsYXNzIGV4dGVuZHMgU3ZlbHRlRWxlbWVudCB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcihDb21wb25lbnQsIHNsb3RzLCB1c2Vfc2hhZG93X2RvbSk7XG5cdFx0XHR0aGlzLiQkcHJvcHNfZGVmaW5pdGlvbiA9IHByb3BzX2RlZmluaXRpb247XG5cdFx0fVxuXHRcdHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKHByb3BzX2RlZmluaXRpb24pLm1hcCgoa2V5KSA9PlxuXHRcdFx0XHQocHJvcHNfZGVmaW5pdGlvbltrZXldLmF0dHJpYnV0ZSB8fCBrZXkpLnRvTG93ZXJDYXNlKClcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xuXHRPYmplY3Qua2V5cyhwcm9wc19kZWZpbml0aW9uKS5mb3JFYWNoKChwcm9wKSA9PiB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgcHJvcCwge1xuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGNvbXBvbmVudCAmJiBwcm9wIGluIHRoaXMuJCRjb21wb25lbnRcblx0XHRcdFx0XHQ/IHRoaXMuJCRjb21wb25lbnRbcHJvcF1cblx0XHRcdFx0XHQ6IHRoaXMuJCRkYXRhW3Byb3BdO1xuXHRcdFx0fSxcblx0XHRcdHNldCh2YWx1ZSkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShwcm9wLCB2YWx1ZSwgcHJvcHNfZGVmaW5pdGlvbik7XG5cdFx0XHRcdHRoaXMuJCRkYXRhW3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuJCRjb21wb25lbnQ/LiRzZXQoeyBbcHJvcF06IHZhbHVlIH0pO1xuXHRcdFx0XHRpZiAocHJvcHNfZGVmaW5pdGlvbltwcm9wXS5yZWZsZWN0KSB7XG5cdFx0XHRcdFx0dGhpcy4kJHJlZmxlY3RpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZV92YWx1ZSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShcblx0XHRcdFx0XHRcdHByb3AsXG5cdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRcdHByb3BzX2RlZmluaXRpb24sXG5cdFx0XHRcdFx0XHQndG9BdHRyaWJ1dGUnXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRpZiAoYXR0cmlidXRlX3ZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShwcm9wc19kZWZpbml0aW9uW3Byb3BdLmF0dHJpYnV0ZSB8fCBwcm9wLCBhdHRyaWJ1dGVfdmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLiQkcmVmbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRhY2Nlc3NvcnMuZm9yRWFjaCgoYWNjZXNzb3IpID0+IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBhY2Nlc3Nvciwge1xuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGNvbXBvbmVudD8uW2FjY2Vzc29yXTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdENvbXBvbmVudC5lbGVtZW50ID0gLyoqIEB0eXBlIHthbnl9ICovIChDbGFzcyk7XG5cdHJldHVybiBDbGFzcztcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cy4gVXNlZCB3aGVuIGRldj1mYWxzZS5cbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtQcm9wcz1hbnldXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudHM9YW55XVxuICovXG5leHBvcnQgY2xhc3MgU3ZlbHRlQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqICMjIyBQUklWQVRFIEFQSVxuXHQgKlxuXHQgKiBEbyBub3QgdXNlLCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG5cdCAqXG5cdCAqIEB0eXBlIHthbnl9XG5cdCAqL1xuXHQkJCA9IHVuZGVmaW5lZDtcblx0LyoqXG5cdCAqICMjIyBQUklWQVRFIEFQSVxuXHQgKlxuXHQgKiBEbyBub3QgdXNlLCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG5cdCAqXG5cdCAqIEB0eXBlIHthbnl9XG5cdCAqL1xuXHQkJHNldCA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdCRkZXN0cm95KCkge1xuXHRcdGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuXHRcdHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSB7RXh0cmFjdDxrZXlvZiBFdmVudHMsIHN0cmluZz59IEtcblx0ICogQHBhcmFtIHtLfSB0eXBlXG5cdCAqIEBwYXJhbSB7KChlOiBFdmVudHNbS10pID0+IHZvaWQpIHwgbnVsbCB8IHVuZGVmaW5lZH0gY2FsbGJhY2tcblx0ICogQHJldHVybnMgeygpID0+IHZvaWR9XG5cdCAqL1xuXHQkb24odHlwZSwgY2FsbGJhY2spIHtcblx0XHRpZiAoIWlzX2Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuXHRcdFx0cmV0dXJuIG5vb3A7XG5cdFx0fVxuXHRcdGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKTtcblx0XHRjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1BhcnRpYWw8UHJvcHM+fSBwcm9wc1xuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdCRzZXQocHJvcHMpIHtcblx0XHRpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkocHJvcHMpKSB7XG5cdFx0XHR0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuXHRcdFx0dGhpcy4kJHNldChwcm9wcyk7XG5cdFx0XHR0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmlidXRlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVmbGVjdF1cbiAqIEBwcm9wZXJ0eSB7J1N0cmluZyd8J0Jvb2xlYW4nfCdOdW1iZXInfCdBcnJheSd8J09iamVjdCd9IFt0eXBlXVxuICovXG4iLCIvLyBnZW5lcmF0ZWQgZHVyaW5nIHJlbGVhc2UsIGRvIG5vdCBtb2RpZnlcblxuLyoqXG4gKiBUaGUgY3VycmVudCB2ZXJzaW9uLCBhcyBzZXQgaW4gcGFja2FnZS5qc29uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1jb21waWxlciNzdmVsdGUtdmVyc2lvblxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC4wLjEnO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19WRVJTSU9OID0gJzQnO1xuIiwiaW1wb3J0IHtcblx0Y3VzdG9tX2V2ZW50LFxuXHRhcHBlbmQsXG5cdGFwcGVuZF9oeWRyYXRpb24sXG5cdGluc2VydCxcblx0aW5zZXJ0X2h5ZHJhdGlvbixcblx0ZGV0YWNoLFxuXHRsaXN0ZW4sXG5cdGF0dHJcbn0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgU3ZlbHRlQ29tcG9uZW50IH0gZnJvbSAnLi9Db21wb25lbnQuanMnO1xuaW1wb3J0IHsgaXNfdm9pZCB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy9uYW1lcy5qcyc7XG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3ZlcnNpb24uanMnO1xuaW1wb3J0IHsgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVuc3VyZV9hcnJheV9saWtlIH0gZnJvbSAnLi9lYWNoLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7VH0gW2RldGFpbF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2hfZGV2KHR5cGUsIGRldGFpbCkge1xuXHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudCh0eXBlLCB7IHZlcnNpb246IFZFUlNJT04sIC4uLmRldGFpbCB9LCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX2Rldih0YXJnZXQsIG5vZGUpIHtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcblx0YXBwZW5kKHRhcmdldCwgbm9kZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUpIHtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcblx0YXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gW2FuY2hvcl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0X2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG5cdGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5cbi8qKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcblx0aW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGFjaF9kZXYobm9kZSkge1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZScsIHsgbm9kZSB9KTtcblx0ZGV0YWNoKG5vZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gYmVmb3JlXG4gKiBAcGFyYW0ge05vZGV9IGFmdGVyXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGFjaF9iZXR3ZWVuX2RldihiZWZvcmUsIGFmdGVyKSB7XG5cdHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcgJiYgYmVmb3JlLm5leHRTaWJsaW5nICE9PSBhZnRlcikge1xuXHRcdGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gYWZ0ZXJcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoX2JlZm9yZV9kZXYoYWZ0ZXIpIHtcblx0d2hpbGUgKGFmdGVyLnByZXZpb3VzU2libGluZykge1xuXHRcdGRldGFjaF9kZXYoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gYmVmb3JlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGFjaF9hZnRlcl9kZXYoYmVmb3JlKSB7XG5cdHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcpIHtcblx0XHRkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0fSBoYW5kbGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyB8IEV2ZW50TGlzdGVuZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hhc19wcmV2ZW50X2RlZmF1bHRdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXNfc3RvcF9wcm9wYWdhdGlvbl1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hhc19zdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbl1cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuX2Rldihcblx0bm9kZSxcblx0ZXZlbnQsXG5cdGhhbmRsZXIsXG5cdG9wdGlvbnMsXG5cdGhhc19wcmV2ZW50X2RlZmF1bHQsXG5cdGhhc19zdG9wX3Byb3BhZ2F0aW9uLFxuXHRoYXNfc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb25cbikge1xuXHRjb25zdCBtb2RpZmllcnMgPVxuXHRcdG9wdGlvbnMgPT09IHRydWUgPyBbJ2NhcHR1cmUnXSA6IG9wdGlvbnMgPyBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG9wdGlvbnMpKSA6IFtdO1xuXHRpZiAoaGFzX3ByZXZlbnRfZGVmYXVsdCkgbW9kaWZpZXJzLnB1c2goJ3ByZXZlbnREZWZhdWx0Jyk7XG5cdGlmIChoYXNfc3RvcF9wcm9wYWdhdGlvbikgbW9kaWZpZXJzLnB1c2goJ3N0b3BQcm9wYWdhdGlvbicpO1xuXHRpZiAoaGFzX3N0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uKSBtb2RpZmllcnMucHVzaCgnc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uJyk7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NQWRkRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcblx0Y29uc3QgZGlzcG9zZSA9IGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuXHRcdGRpc3Bvc2UoKTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHJfZGV2KG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0YXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKTtcblx0aWYgKHZhbHVlID09IG51bGwpIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlQXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUgfSk7XG5cdGVsc2UgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7YW55fSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuXHRub2RlW3Byb3BlcnR5XSA9IHZhbHVlO1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldFByb3BlcnR5JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge2FueX0gW3ZhbHVlXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhc2V0X2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcblx0bm9kZS5kYXRhc2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGFzZXQnLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSkge1xuXHRkYXRhID0gJycgKyBkYXRhO1xuXHRpZiAodGV4dC5kYXRhID09PSBkYXRhKSByZXR1cm47XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcblx0dGV4dC5kYXRhID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGVfZGV2KHRleHQsIGRhdGEpIHtcblx0ZGF0YSA9ICcnICsgZGF0YTtcblx0aWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKSByZXR1cm47XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcblx0dGV4dC5kYXRhID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJfdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlX2Rldih0ZXh0LCBkYXRhLCBhdHRyX3ZhbHVlKSB7XG5cdGlmICh+Y29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMuaW5kZXhPZihhdHRyX3ZhbHVlKSkge1xuXHRcdHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZV9kZXYodGV4dCwgZGF0YSk7XG5cdH0gZWxzZSB7XG5cdFx0c2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVfYXJyYXlfbGlrZV9kZXYoYXJnKSB7XG5cdGlmIChcblx0XHR0eXBlb2YgYXJnICE9PSAnc3RyaW5nJyAmJlxuXHRcdCEoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIGFyZykgJiZcblx0XHQhKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgYXJnICYmIFN5bWJvbC5pdGVyYXRvciBpbiBhcmcpXG5cdCkge1xuXHRcdHRocm93IG5ldyBFcnJvcigneyNlYWNofSBvbmx5IHdvcmtzIHdpdGggaXRlcmFibGUgdmFsdWVzLicpO1xuXHR9XG5cdHJldHVybiBlbnN1cmVfYXJyYXlfbGlrZShhcmcpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3Nsb3RzKG5hbWUsIHNsb3QsIGtleXMpIHtcblx0Zm9yIChjb25zdCBzbG90X2tleSBvZiBPYmplY3Qua2V5cyhzbG90KSkge1xuXHRcdGlmICghfmtleXMuaW5kZXhPZihzbG90X2tleSkpIHtcblx0XHRcdGNvbnNvbGUud2FybihgPCR7bmFtZX0+IHJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgc2xvdCBcIiR7c2xvdF9rZXl9XCIuYCk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSB0YWdcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfZHluYW1pY19lbGVtZW50KHRhZykge1xuXHRjb25zdCBpc19zdHJpbmcgPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJztcblx0aWYgKHRhZyAmJiAhaXNfc3RyaW5nKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCc8c3ZlbHRlOmVsZW1lbnQ+IGV4cGVjdHMgXCJ0aGlzXCIgYXR0cmlidXRlIHRvIGJlIGEgc3RyaW5nLicpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmRlZmluZWQgfCBzdHJpbmd9IHRhZ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCh0YWcpIHtcblx0aWYgKHRhZyAmJiBpc192b2lkKHRhZykpIHtcblx0XHRjb25zb2xlLndhcm4oYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJHt0YWd9XCI+IGlzIHNlbGYtY2xvc2luZyBhbmQgY2Fubm90IGhhdmUgY29udGVudC5gKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnRfZGV2KGNvbXBvbmVudCwgcHJvcHMpIHtcblx0Y29uc3QgZXJyb3JfbWVzc2FnZSA9ICd0aGlzPXsuLi59IG9mIDxzdmVsdGU6Y29tcG9uZW50PiBzaG91bGQgc3BlY2lmeSBhIFN2ZWx0ZSBjb21wb25lbnQuJztcblx0dHJ5IHtcblx0XHRjb25zdCBpbnN0YW5jZSA9IG5ldyBjb21wb25lbnQocHJvcHMpO1xuXHRcdGlmICghaW5zdGFuY2UuJCQgfHwgIWluc3RhbmNlLiRzZXQgfHwgIWluc3RhbmNlLiRvbiB8fCAhaW5zdGFuY2UuJGRlc3Ryb3kpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihlcnJvcl9tZXNzYWdlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRjb25zdCB7IG1lc3NhZ2UgfSA9IGVycjtcblx0XHRpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIG1lc3NhZ2UuaW5kZXhPZignaXMgbm90IGEgY29uc3RydWN0b3InKSAhPT0gLTEpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihlcnJvcl9tZXNzYWdlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzIHdpdGggc29tZSBtaW5vciBkZXYtZW5oYW5jZW1lbnRzLiBVc2VkIHdoZW4gZGV2PXRydWUuXG4gKlxuICogQ2FuIGJlIHVzZWQgdG8gY3JlYXRlIHN0cm9uZ2x5IHR5cGVkIFN2ZWx0ZSBjb21wb25lbnRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiBZb3UgaGF2ZSBjb21wb25lbnQgbGlicmFyeSBvbiBucG0gY2FsbGVkIGBjb21wb25lbnQtbGlicmFyeWAsIGZyb20gd2hpY2hcbiAqIHlvdSBleHBvcnQgYSBjb21wb25lbnQgY2FsbGVkIGBNeUNvbXBvbmVudGAuIEZvciBTdmVsdGUrVHlwZVNjcmlwdCB1c2VycyxcbiAqIHlvdSB3YW50IHRvIHByb3ZpZGUgdHlwaW5ncy4gVGhlcmVmb3JlIHlvdSBjcmVhdGUgYSBgaW5kZXguZC50c2A6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU3ZlbHRlQ29tcG9uZW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50PHtmb286IHN0cmluZ30+IHt9XG4gKiBgYGBcbiAqIFR5cGluZyB0aGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciBJREVzIGxpa2UgVlMgQ29kZSB3aXRoIHRoZSBTdmVsdGUgZXh0ZW5zaW9uXG4gKiB0byBwcm92aWRlIGludGVsbGlzZW5zZSBhbmQgdG8gdXNlIHRoZSBjb21wb25lbnQgbGlrZSB0aGlzIGluIGEgU3ZlbHRlIGZpbGVcbiAqIHdpdGggVHlwZVNjcmlwdDpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAqIFx0aW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tIFwiY29tcG9uZW50LWxpYnJhcnlcIjtcbiAqIDwvc2NyaXB0PlxuICogPE15Q29tcG9uZW50IGZvbz17J2Jhcid9IC8+XG4gKiBgYGBcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW1Byb3BzPWFueV1cbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50cz1hbnldXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtTbG90cz1hbnldXG4gKiBAZXh0ZW5kcyB7U3ZlbHRlQ29tcG9uZW50PFByb3BzLCBFdmVudHM+fVxuICovXG5leHBvcnQgY2xhc3MgU3ZlbHRlQ29tcG9uZW50RGV2IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIEZvciB0eXBlIGNoZWNraW5nIGNhcGFiaWxpdGllcyBvbmx5LlxuXHQgKiBEb2VzIG5vdCBleGlzdCBhdCBydW50aW1lLlxuXHQgKiAjIyMgRE8gTk9UIFVTRSFcblx0ICpcblx0ICogQHR5cGUge1Byb3BzfVxuXHQgKi9cblx0JCRwcm9wX2RlZjtcblx0LyoqXG5cdCAqIEZvciB0eXBlIGNoZWNraW5nIGNhcGFiaWxpdGllcyBvbmx5LlxuXHQgKiBEb2VzIG5vdCBleGlzdCBhdCBydW50aW1lLlxuXHQgKiAjIyMgRE8gTk9UIFVTRSFcblx0ICpcblx0ICogQHR5cGUge0V2ZW50c31cblx0ICovXG5cdCQkZXZlbnRzX2RlZjtcblx0LyoqXG5cdCAqIEZvciB0eXBlIGNoZWNraW5nIGNhcGFiaWxpdGllcyBvbmx5LlxuXHQgKiBEb2VzIG5vdCBleGlzdCBhdCBydW50aW1lLlxuXHQgKiAjIyMgRE8gTk9UIFVTRSFcblx0ICpcblx0ICogQHR5cGUge1Nsb3RzfVxuXHQgKi9cblx0JCRzbG90X2RlZjtcblxuXHQvKiogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuQ29tcG9uZW50Q29uc3RydWN0b3JPcHRpb25zPFByb3BzPn0gb3B0aW9ucyAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCIndGFyZ2V0JyBpcyBhIHJlcXVpcmVkIG9wdGlvblwiKTtcblx0XHR9XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0JGRlc3Ryb3koKSB7XG5cdFx0c3VwZXIuJGRlc3Ryb3koKTtcblx0XHR0aGlzLiRkZXN0cm95ID0gKCkgPT4ge1xuXHRcdFx0Y29uc29sZS53YXJuKCdDb21wb25lbnQgd2FzIGFscmVhZHkgZGVzdHJveWVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXHRcdH07XG5cdH1cblxuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdCRjYXB0dXJlX3N0YXRlKCkge31cblxuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdCRpbmplY3Rfc3RhdGUoKSB7fVxufVxuLyoqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtQcm9wcz1hbnldXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudHM9YW55XVxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbU2xvdHM9YW55XVxuICogQGRlcHJlY2F0ZWQgVXNlIGBTdmVsdGVDb21wb25lbnRgIGluc3RlYWQuIFNlZSBQUiBmb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzg1MTJcbiAqIEBleHRlbmRzIHtTdmVsdGVDb21wb25lbnREZXY8UHJvcHMsIEV2ZW50cywgU2xvdHM+fVxuICovXG5leHBvcnQgY2xhc3MgU3ZlbHRlQ29tcG9uZW50VHlwZWQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnREZXYge31cblxuLyoqIEByZXR1cm5zIHsoKSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvb3BfZ3VhcmQodGltZW91dCkge1xuXHRjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKERhdGUubm93KCkgLSBzdGFydCA+IHRpbWVvdXQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBkZXRlY3RlZCcpO1xuXHRcdH1cblx0fTtcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vYW5pbWF0aW9ucy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2F3YWl0X2Jsb2NrLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZG9tLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZW52aXJvbm1lbnQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9nbG9iYWxzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZWFjaC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpZmVjeWNsZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xvb3AuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zcHJlYWQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zc3IuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFuc2l0aW9ucy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vQ29tcG9uZW50LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZGV2LmpzJztcbiIsImltcG9ydCB7IFBVQkxJQ19WRVJTSU9OIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3ZlcnNpb24uanMnO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpXG5cdC8vIEB0cy1pZ25vcmVcblx0KHdpbmRvdy5fX3N2ZWx0ZSB8fCAod2luZG93Ll9fc3ZlbHRlID0geyB2OiBuZXcgU2V0KCkgfSkpLnYuYWRkKFBVQkxJQ19WRVJTSU9OKTtcbiIsImV4cG9ydCB7XG5cdFN2ZWx0ZUNvbXBvbmVudERldiBhcyBTdmVsdGVDb21wb25lbnQsXG5cdG9uTW91bnQsXG5cdG9uRGVzdHJveSxcblx0YmVmb3JlVXBkYXRlLFxuXHRhZnRlclVwZGF0ZSxcblx0c2V0Q29udGV4dCxcblx0Z2V0Q29udGV4dCxcblx0Z2V0QWxsQ29udGV4dHMsXG5cdGhhc0NvbnRleHQsXG5cdHRpY2ssXG5cdGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcixcblx0U3ZlbHRlQ29tcG9uZW50VHlwZWRcbn0gZnJvbSAnLi9pbnRlcm5hbC9pbmRleC5qcyc7XG4iLCJpbXBvcnQge1xuXHRydW5fYWxsLFxuXHRzdWJzY3JpYmUsXG5cdG5vb3AsXG5cdHNhZmVfbm90X2VxdWFsLFxuXHRpc19mdW5jdGlvbixcblx0Z2V0X3N0b3JlX3ZhbHVlXG59IGZyb20gJy4uL2ludGVybmFsL2luZGV4LmpzJztcblxuY29uc3Qgc3Vic2NyaWJlcl9xdWV1ZSA9IFtdO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgUmVhZGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNyZWFkYWJsZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5TdGFydFN0b3BOb3RpZmllcjxUPn0gW3N0YXJ0XVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRhYmxlKHZhbHVlLCBzdGFydCkge1xuXHRyZXR1cm4ge1xuXHRcdHN1YnNjcmliZTogd3JpdGFibGUodmFsdWUsIHN0YXJ0KS5zdWJzY3JpYmVcblx0fTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgV3JpdGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIGJvdGggdXBkYXRpbmcgYW5kIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSN3cml0YWJsZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5TdGFydFN0b3BOb3RpZmllcjxUPn0gW3N0YXJ0XVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Xcml0YWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRhYmxlKHZhbHVlLCBzdGFydCA9IG5vb3ApIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vcHVibGljLmpzJykuVW5zdWJzY3JpYmVyfSAqL1xuXHRsZXQgc3RvcDtcblx0LyoqIEB0eXBlIHtTZXQ8aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGU8VD4+fSAqL1xuXHRjb25zdCBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcblx0LyoqIEBwYXJhbSB7VH0gbmV3X3ZhbHVlXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0KG5ld192YWx1ZSkge1xuXHRcdGlmIChzYWZlX25vdF9lcXVhbCh2YWx1ZSwgbmV3X3ZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSBuZXdfdmFsdWU7XG5cdFx0XHRpZiAoc3RvcCkge1xuXHRcdFx0XHQvLyBzdG9yZSBpcyByZWFkeVxuXHRcdFx0XHRjb25zdCBydW5fcXVldWUgPSAhc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3Vic2NyaWJlciBvZiBzdWJzY3JpYmVycykge1xuXHRcdFx0XHRcdHN1YnNjcmliZXJbMV0oKTtcblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLnB1c2goc3Vic2NyaWJlciwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5fcXVldWUpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJfcXVldWUubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWVbaV1bMF0oc3Vic2NyaWJlcl9xdWV1ZVtpICsgMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuVXBkYXRlcjxUPn0gZm5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGUoZm4pIHtcblx0XHRzZXQoZm4odmFsdWUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5TdWJzY3JpYmVyPFQ+fSBydW5cblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkludmFsaWRhdG9yPFQ+fSBbaW52YWxpZGF0ZV1cblx0ICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5VbnN1YnNjcmliZXJ9XG5cdCAqL1xuXHRmdW5jdGlvbiBzdWJzY3JpYmUocnVuLCBpbnZhbGlkYXRlID0gbm9vcCkge1xuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGU8VD59ICovXG5cdFx0Y29uc3Qgc3Vic2NyaWJlciA9IFtydW4sIGludmFsaWRhdGVdO1xuXHRcdHN1YnNjcmliZXJzLmFkZChzdWJzY3JpYmVyKTtcblx0XHRpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMSkge1xuXHRcdFx0c3RvcCA9IHN0YXJ0KHNldCwgdXBkYXRlKSB8fCBub29wO1xuXHRcdH1cblx0XHRydW4odmFsdWUpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRzdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG5cdFx0XHRpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCAmJiBzdG9wKSB7XG5cdFx0XHRcdHN0b3AoKTtcblx0XHRcdFx0c3RvcCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4geyBzZXQsIHVwZGF0ZSwgc3Vic2NyaWJlIH07XG59XG5cbi8qKlxuICogRGVyaXZlZCB2YWx1ZSBzdG9yZSBieSBzeW5jaHJvbml6aW5nIG9uZSBvciBtb3JlIHJlYWRhYmxlIHN0b3JlcyBhbmRcbiAqIGFwcGx5aW5nIGFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIG92ZXIgaXRzIGlucHV0IHZhbHVlcy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjZGVyaXZlZFxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtTfSBzdG9yZXMgLSBpbnB1dCBzdG9yZXNcbiAqIEBwYXJhbSB7KHZhbHVlczogaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXNWYWx1ZXM8Uz4sIHNldDogKHZhbHVlOiBUKSA9PiB2b2lkLCB1cGRhdGU6IChmbjogaW1wb3J0KCcuL3B1YmxpYy5qcycpLlVwZGF0ZXI8VD4pID0+IHZvaWQpID0+IGltcG9ydCgnLi9wdWJsaWMuanMnKS5VbnN1YnNjcmliZXIgfCB2b2lkfSBmbiAtIGZ1bmN0aW9uIGNhbGxiYWNrIHRoYXQgYWdncmVnYXRlcyB0aGUgdmFsdWVzXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXSAtIGluaXRpYWwgdmFsdWVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59XG4gKi9cblxuLyoqXG4gKiBEZXJpdmVkIHZhbHVlIHN0b3JlIGJ5IHN5bmNocm9uaXppbmcgb25lIG9yIG1vcmUgcmVhZGFibGUgc3RvcmVzIGFuZFxuICogYXBwbHlpbmcgYW4gYWdncmVnYXRpb24gZnVuY3Rpb24gb3ZlciBpdHMgaW5wdXQgdmFsdWVzLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNkZXJpdmVkXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuU3RvcmVzfSBTXG4gKiBAdGVtcGxhdGUgVFxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1N9IHN0b3JlcyAtIGlucHV0IHN0b3Jlc1xuICogQHBhcmFtIHsodmFsdWVzOiBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN0b3Jlc1ZhbHVlczxTPikgPT4gVH0gZm4gLSBmdW5jdGlvbiBjYWxsYmFjayB0aGF0IGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlc1xuICogQHBhcmFtIHtUfSBbaW5pdGlhbF92YWx1ZV0gLSBpbml0aWFsIHZhbHVlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U30gc3RvcmVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtUfSBbaW5pdGlhbF92YWx1ZV1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkKHN0b3JlcywgZm4sIGluaXRpYWxfdmFsdWUpIHtcblx0Y29uc3Qgc2luZ2xlID0gIUFycmF5LmlzQXJyYXkoc3RvcmVzKTtcblx0LyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8YW55Pj59ICovXG5cdGNvbnN0IHN0b3Jlc19hcnJheSA9IHNpbmdsZSA/IFtzdG9yZXNdIDogc3RvcmVzO1xuXHRpZiAoIXN0b3Jlc19hcnJheS5ldmVyeShCb29sZWFuKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZGVyaXZlZCgpIGV4cGVjdHMgc3RvcmVzIGFzIGlucHV0LCBnb3QgYSBmYWxzeSB2YWx1ZScpO1xuXHR9XG5cdGNvbnN0IGF1dG8gPSBmbi5sZW5ndGggPCAyO1xuXHRyZXR1cm4gcmVhZGFibGUoaW5pdGlhbF92YWx1ZSwgKHNldCwgdXBkYXRlKSA9PiB7XG5cdFx0bGV0IHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblx0XHRsZXQgcGVuZGluZyA9IDA7XG5cdFx0bGV0IGNsZWFudXAgPSBub29wO1xuXHRcdGNvbnN0IHN5bmMgPSAoKSA9PiB7XG5cdFx0XHRpZiAocGVuZGluZykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBmbihzaW5nbGUgPyB2YWx1ZXNbMF0gOiB2YWx1ZXMsIHNldCwgdXBkYXRlKTtcblx0XHRcdGlmIChhdXRvKSB7XG5cdFx0XHRcdHNldChyZXN1bHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xlYW51cCA9IGlzX2Z1bmN0aW9uKHJlc3VsdCkgPyByZXN1bHQgOiBub29wO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y29uc3QgdW5zdWJzY3JpYmVycyA9IHN0b3Jlc19hcnJheS5tYXAoKHN0b3JlLCBpKSA9PlxuXHRcdFx0c3Vic2NyaWJlKFxuXHRcdFx0XHRzdG9yZSxcblx0XHRcdFx0KHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dmFsdWVzW2ldID0gdmFsdWU7XG5cdFx0XHRcdFx0cGVuZGluZyAmPSB+KDEgPDwgaSk7XG5cdFx0XHRcdFx0aWYgKHN0YXJ0ZWQpIHtcblx0XHRcdFx0XHRcdHN5bmMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdCgpID0+IHtcblx0XHRcdFx0XHRwZW5kaW5nIHw9IDEgPDwgaTtcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdCk7XG5cdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0c3luYygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBzdG9wKCkge1xuXHRcdFx0cnVuX2FsbCh1bnN1YnNjcmliZXJzKTtcblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdC8vIFdlIG5lZWQgdG8gc2V0IHRoaXMgdG8gZmFsc2UgYmVjYXVzZSBjYWxsYmFja3MgY2FuIHN0aWxsIGhhcHBlbiBkZXNwaXRlIGhhdmluZyB1bnN1YnNjcmliZWQ6XG5cdFx0XHQvLyBDYWxsYmFja3MgbWlnaHQgYWxyZWFkeSBiZSBwbGFjZWQgaW4gdGhlIHF1ZXVlIHdoaWNoIGRvZXNuJ3Qga25vdyBpdCBzaG91bGQgbm8gbG9uZ2VyXG5cdFx0XHQvLyBpbnZva2UgdGhpcyBkZXJpdmVkIHN0b3JlLlxuXHRcdFx0c3RhcnRlZCA9IGZhbHNlO1xuXHRcdH07XG5cdH0pO1xufVxuXG4vKipcbiAqIFRha2VzIGEgc3RvcmUgYW5kIHJldHVybnMgYSBuZXcgb25lIGRlcml2ZWQgZnJvbSB0aGUgb2xkIG9uZSB0aGF0IGlzIHJlYWRhYmxlLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNyZWFkb25seVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fSBzdG9yZSAgLSBzdG9yZSB0byBtYWtlIHJlYWRvbmx5XG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZG9ubHkoc3RvcmUpIHtcblx0cmV0dXJuIHtcblx0XHRzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZS5iaW5kKHN0b3JlKVxuXHR9O1xufVxuXG5leHBvcnQgeyBnZXRfc3RvcmVfdmFsdWUgYXMgZ2V0IH07XG4iLCJpbXBvcnQge3R5cGUgV3JpdGFibGUsIHdyaXRhYmxlfSBmcm9tICdzdmVsdGUvc3RvcmUnXG5cbmV4cG9ydCBsZXQgZ2FsbGVyeV9vcGVuOiBXcml0YWJsZTxib29sZWFuPiA9IHdyaXRhYmxlKGZhbHNlKVxuZXhwb3J0IGxldCBmbG9hdGluZ19tb2RhbF9tZXNzYWdlOiBXcml0YWJsZTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0gd3JpdGFibGUodW5kZWZpbmVkKVxuIiwiLy8geW9pbmtlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNDQ1MDAvZWZmaWNpZW50LXdheS10by1pbnNlcnQtYS1udW1iZXItaW50by1hLXNvcnRlZC1hcnJheS1vZi1udW1iZXJzXG5cbi8qKlxuICogTG9vayBmb3IgYW4gaW5kZXggZnJvbSBhIHNvcnRlZCBsaXN0IHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gKlxuICogSWYgeW91IGRvbid0IHByb3ZpZGUgYSBjb21wYXJlIGZ1bmN0aW9uLCBpdCB3aWxsIGxvb2sgZm9yICoqdGhlIGZpcnN0IHNhbWUgdmFsdWUqKiBpdCBjYW4gZmluZC5cbiAqIElmIGl0IGNhbm5vdCBmaW5kIGFuIGV4YWN0bHkgbWF0Y2hpbmcgdmFsdWUsIGl0IGNhbiByZXR1cm4gTiB3aGVyZSB0aGUgbGVuZ3RoIG9mIGdpdmVuIGFycmF5IGlzIE4uXG4gKlxuICogQHBhcmFtIGFycmF5IEEgc29ydGVkIGFycmF5XG4gKiBAcGFyYW0gY29tcGFyZSBNYWtlIHRoaXMgZnVuY3Rpb24gcmV0dXJuIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gcG9pbnQgcmlnaHQgc2lkZSBvZiBnaXZlbiBlbGVtZW50LCBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcG9pbnQgbGVmdCBzaWRlIG9mIGdpdmVuIGVsZW1lbnQuXG4gKiBAcmV0dXJucyBBbiBpbmRleCBmb3VuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoPFQ+KCBhcnJheTogQXJyYXlMaWtlPFQ+LCBlbGVtZW50OiBUICk6IG51bWJlcjtcbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2g8VD4oIGFycmF5OiBBcnJheUxpa2U8VD4sIGNvbXBhcmU6ICggZWxlbWVudDogVCApID0+IGJvb2xlYW4gKTogbnVtYmVyO1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaDxUPihcbiAgYXJyYXk6IEFycmF5TGlrZTxUPixcbiAgZWxlbWVudE9yQ29tcGFyZTogVCB8ICggKCBlbGVtZW50OiBUICkgPT4gYm9vbGVhbiApLFxuKTogbnVtYmVyIHtcbiAgaWYgKCB0eXBlb2YgZWxlbWVudE9yQ29tcGFyZSAhPT0gJ2Z1bmN0aW9uJyApIHtcbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoKCBhcnJheSwgKCBlbGVtZW50ICkgPT4gKCBlbGVtZW50IDwgZWxlbWVudE9yQ29tcGFyZSApICk7XG4gIH1cbiAgY29uc3QgY29tcGFyZSA9IGVsZW1lbnRPckNvbXBhcmUgYXMgKCBlbGVtZW50OiBUICkgPT4gYm9vbGVhbjtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICggc3RhcnQgPCBlbmQgKSB7XG4gICAgY29uc3QgY2VudGVyID0gKCBzdGFydCArIGVuZCApID4+IDE7XG4gICAgY29uc3QgY2VudGVyRWxlbWVudCA9IGFycmF5WyBjZW50ZXIgXTtcblxuICAgIGNvbnN0IGNvbXBhcmVSZXN1bHQgPSBjb21wYXJlKCBjZW50ZXJFbGVtZW50ICk7XG5cbiAgICBpZiAoIGNvbXBhcmVSZXN1bHQgKSB7XG4gICAgICBzdGFydCA9IGNlbnRlciArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IGNlbnRlcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhcnQ7XG59XG4iLCIvKipcbiAqIEdlbmVyaWMgdHJhdmVyc2UgZnVuY3Rpb24uXG4gKlxuICogSXQgcGVyZm9ybXMgRGVwdGgtRmlyc3QgU2VhcmNoLlxuICpcbiAqIFRoZSBgdHJhdmVyc2VyYCBmdW5jdGlvbiB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGRlc2NlbmRhbnRzLlxuICogWW91IG5lZWQgdG8gcmV0dXJuIHRoZWlyIFwiY2hpbGRyZW5cIiBpbiBhbiBhcnJheS5cbiAqIElmIHlvdSB3YW50IHRvIHN0b3AgdGhlIHRyYXZlcnNhbCwgcmV0dXJuIGBmYWxzZWAgaW5zdGVhZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIC8vIHJlcGxpY2F0ZSBUaHJlZS5qcyB0cmF2ZXJzZSBmb3Igbm8gcmVhc29uXG4gKiBjb25zdCBtZXNoZXMgPSBbXTtcbiAqIHRyYXZlcnNlKCBvYmplY3QzRFJvb3QsICggb2JqZWN0ICkgPT4ge1xuICogICBpZiAoIG9iamVjdC5pc01lc2ggKSB7XG4gKiAgICAgbWVzaGVzLnB1c2goIG9iamVjdCApO1xuICogICB9XG4gKiAgIHJldHVybiBvYmplY3QzRFJvb3QuY2hpbGRyZW47XG4gKiB9ICk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcm9vdCBUaGUgXCJyb290XCIgbm9kZVxuICogQHBhcmFtIHRyYXZlcnNlciBUaGUgdHJhdmVyc2UgZnVuY3Rpb24uIElmIHRoZSBub2RlIGhhcyBcImNoaWxkcmVuXCIgcmV0dXJuIHRoZW0gaW4gYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZTxUTm9kZT4oXG4gIHJvb3Q6IFROb2RlLFxuICB0cmF2ZXJzZXI6ICggbm9kZTogVE5vZGUgKSA9PiBUTm9kZVtdIHwgZmFsc2UsXG4pOiB2b2lkIHtcbiAgY29uc3Qgbm9kZXNOZWVkUHJvY2VzczogVE5vZGVbXSA9IFsgcm9vdCBdO1xuICBjb25zdCBub2Rlc1NlZW4gPSBuZXcgU2V0PFROb2RlPiggbm9kZXNOZWVkUHJvY2VzcyApO1xuXG4gIHdoaWxlICggbm9kZXNOZWVkUHJvY2Vzcy5sZW5ndGggPiAwICkge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gbm9kZXNOZWVkUHJvY2Vzcy5zaGlmdCgpITtcblxuICAgIGNvbnN0IGNoaWxkcmVuID0gdHJhdmVyc2VyKCBjdXJyZW50Tm9kZSApO1xuXG4gICAgaWYgKCAhY2hpbGRyZW4gKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCBub2Rlc0ZvdW5kID0gY2hpbGRyZW4uZmlsdGVyKCAoIG5vZGUgKSA9PiAhbm9kZXNTZWVuLmhhcyggbm9kZSApICk7XG4gICAgbm9kZXNOZWVkUHJvY2Vzcy51bnNoaWZ0KCAuLi5ub2Rlc0ZvdW5kICk7XG4gICAgbm9kZXNGb3VuZC5tYXAoICggbm9kZSApID0+IG5vZGVzU2Vlbi5hZGQoIG5vZGUgKSApO1xuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYXJyYXlSYW5nZSggc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHN0ZXA/OiBudW1iZXIgKTogbnVtYmVyW10ge1xuICBsZXQgY3VycmVudCA9IHN0YXJ0O1xuICBjb25zdCByZXQ6IG51bWJlcltdID0gW107XG5cbiAgaWYgKCBzdGFydCA8IGVuZCApIHtcbiAgICBzdGVwID0gc3RlcCA/PyAxO1xuICAgIHdoaWxlICggY3VycmVudCA8IGVuZCApIHtcbiAgICAgIHJldC5wdXNoKCBjdXJyZW50ICk7XG4gICAgICBjdXJyZW50ICs9IHN0ZXA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0ZXAgPSBzdGVwID8/IC0xO1xuICAgIHdoaWxlICggY3VycmVudCA+IGVuZCApIHtcbiAgICAgIHJldC5wdXNoKCBjdXJyZW50ICk7XG4gICAgICBjdXJyZW50ICs9IHN0ZXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuIiwiZXhwb3J0IGNvbnN0IGFycmF5U2VyaWFsID0gKCBjb3VudDogbnVtYmVyICk6IG51bWJlcltdID0+IChcbiAgWyAuLi5BcnJheSggY291bnQgKSBdLm1hcCggKCBfLCBpICkgPT4gaSApXG4pO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGFycmF5U2V0RGVsZXRlPFQ+KCBhcnJheTogQXJyYXk8VD4sIHZhbHVlOiBUICk6IGJvb2xlYW4ge1xuICBjb25zdCBpbmRleCA9IGFycmF5LmluZGV4T2YoIHZhbHVlICk7XG4gIGlmICggaW5kZXggPT09IC0xICkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBhcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlTZXRIYXM8VD4oIGFycmF5OiBBcnJheTxUPiwgdmFsdWU6IFQgKTogYm9vbGVhbiB7XG4gIHJldHVybiBhcnJheS5pbmRleE9mKCB2YWx1ZSApICE9PSAtMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5U2V0QWRkPFQ+KCBhcnJheTogQXJyYXk8VD4sIHZhbHVlOiBUICk6IGJvb2xlYW4ge1xuICBjb25zdCBpbmRleCA9IGFycmF5LmluZGV4T2YoIHZhbHVlICk7XG4gIGlmICggaW5kZXggIT09IC0xICkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBhcnJheS5wdXNoKCB2YWx1ZSApO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5U2V0VW5pb248VD4oIGE6IEFycmF5PFQ+LCBiOiBBcnJheTxUPiApOiBBcnJheTxUPiB7XG4gIGNvbnN0IG91dCA9IFsgLi4uYSBdO1xuICBiLmZvckVhY2goICggdiApID0+IHtcbiAgICBpZiAoICFhcnJheVNldEhhcyggb3V0LCB2ICkgKSB7XG4gICAgICBvdXQucHVzaCggdiApO1xuICAgIH1cbiAgfSApO1xuICByZXR1cm4gb3V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlTZXREaWZmPFQ+KCBmcm9tOiBBcnJheTxUPiwgZGlmZjogQXJyYXk8VD4gKTogQXJyYXk8VD4ge1xuICBjb25zdCBvdXQgPSBbIC4uLmZyb20gXTtcbiAgZGlmZi5mb3JFYWNoKCAoIHYgKSA9PiB7XG4gICAgYXJyYXlTZXREZWxldGUoIG91dCwgdiApO1xuICB9ICk7XG4gIHJldHVybiBvdXQ7XG59XG4iLCIvKipcbiAqIGBbIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxIF1gXG4gKi9cbmV4cG9ydCBjb25zdCBUUklBTkdMRV9TVFJJUF9RVUFEID0gWyAtMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgMSBdO1xuXG4vKipcbiAqIGBbIC0xLCAtMSwgMCwgMSwgLTEsIDAsIC0xLCAxLCAwLCAxLCAxLCAwIF1gXG4gKi9cbmV4cG9ydCBjb25zdCBUUklBTkdMRV9TVFJJUF9RVUFEXzNEID0gWyAtMSwgLTEsIDAsIDEsIC0xLCAwLCAtMSwgMSwgMCwgMSwgMSwgMCBdO1xuXG4vKipcbiAqIGBbIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEgXWBcbiAqL1xuZXhwb3J0IGNvbnN0IFRSSUFOR0xFX1NUUklQX1FVQURfTk9STUFMID0gWyAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxIF07XG5cbi8qKlxuICogYFsgMCwgMCwgMSwgMCwgMCwgMSwgMSwgMSBdYFxuICovXG5leHBvcnQgY29uc3QgVFJJQU5HTEVfU1RSSVBfUVVBRF9VViA9IFsgMCwgMCwgMSwgMCwgMCwgMSwgMSwgMSBdO1xuIiwiLyoqXG4gKiBTaHVmZmxlIGdpdmVuIGBhcnJheWAgdXNpbmcgZ2l2ZW4gYGRpY2VgIFJORy4gKipEZXN0cnVjdGl2ZSoqLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2h1ZmZsZUFycmF5PFQ+KCBhcnJheTogVFtdLCBkaWNlPzogKCkgPT4gbnVtYmVyICk6IFRbXSB7XG4gIGNvbnN0IGYgPSBkaWNlID8gZGljZSA6ICgpID0+IE1hdGgucmFuZG9tKCk7XG4gIGZvciAoIGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aCAtIDE7IGkgKysgKSB7XG4gICAgY29uc3QgaXIgPSBpICsgTWF0aC5mbG9vciggZigpICogKCBhcnJheS5sZW5ndGggLSBpICkgKTtcbiAgICBjb25zdCB0ZW1wID0gYXJyYXlbIGlyIF07XG4gICAgYXJyYXlbIGlyIF0gPSBhcnJheVsgaSBdO1xuICAgIGFycmF5WyBpIF0gPSB0ZW1wO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBJIGxpa2Ugd2lyZWZyYW1lXG4gKlxuICogYHRyaUluZGV4VG9MaW5lSW5kZXgoIFsgMCwgMSwgMiwgNSwgNiwgNyBdIClgIC0+IGBbIDAsIDEsIDEsIDIsIDIsIDAsIDUsIDYsIDYsIDcsIDcsIDUgXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaUluZGV4VG9MaW5lSW5kZXg8VD4oIGFycmF5OiBUW10gKTogVFtdIHtcbiAgY29uc3QgcmV0OiBUW10gPSBbXTtcbiAgZm9yICggbGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoIC8gMzsgaSArKyApIHtcbiAgICBjb25zdCBoZWFkID0gaSAqIDM7XG4gICAgcmV0LnB1c2goXG4gICAgICBhcnJheVsgaGVhZCAgICAgXSwgYXJyYXlbIGhlYWQgKyAxIF0sXG4gICAgICBhcnJheVsgaGVhZCArIDEgXSwgYXJyYXlbIGhlYWQgKyAyIF0sXG4gICAgICBhcnJheVsgaGVhZCArIDIgXSwgYXJyYXlbIGhlYWQgICAgIF1cbiAgICApO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogYG1hdHJpeDJkKCAzLCAyIClgIC0+IGBbIDAsIDAsIDAsIDEsIDAsIDIsIDEsIDAsIDEsIDEsIDEsIDIgXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdHJpeDJkKCB3OiBudW1iZXIsIGg6IG51bWJlciApOiBudW1iZXJbXSB7XG4gIGNvbnN0IGFycjogbnVtYmVyW10gPSBbXTtcbiAgZm9yICggbGV0IGl5ID0gMDsgaXkgPCBoOyBpeSArKyApIHtcbiAgICBmb3IgKCBsZXQgaXggPSAwOyBpeCA8IHc7IGl4ICsrICkge1xuICAgICAgYXJyLnB1c2goIGl4LCBpeSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIFNlZSBhbHNvOiB7QGxpbmsgbWF0cml4MmR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRyaXgzZCggdzogbnVtYmVyLCBoOiBudW1iZXIsIGQ6IG51bWJlciApOiBudW1iZXJbXSB7XG4gIGNvbnN0IGFycjogbnVtYmVyW10gPSBbXTtcbiAgZm9yICggbGV0IGl6ID0gMDsgaXogPCBkOyBpeiArKyApIHtcbiAgICBmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGg7IGl5ICsrICkge1xuICAgICAgZm9yICggbGV0IGl4ID0gMDsgaXggPCB3OyBpeCArKyApIHtcbiAgICAgICAgYXJyLnB1c2goIGl4LCBpeSwgaXogKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cbiIsIi8qKlxuICogQ3JpdGljYWxseSBEYW1wZWQgU3ByaW5nXG4gKlxuICogU2hvdXRvdXRzIHRvIEtlaWppcm8gVGFrYWhhc2hpXG4gKi9cbmV4cG9ydCBjbGFzcyBDRFMge1xuICBwdWJsaWMgZmFjdG9yID0gMTAwLjA7XG4gIHB1YmxpYyByYXRpbyA9IDEuMDtcbiAgcHVibGljIHZlbG9jaXR5ID0gMC4wO1xuICBwdWJsaWMgdmFsdWUgPSAwLjA7XG4gIHB1YmxpYyB0YXJnZXQgPSAwLjA7XG5cbiAgcHVibGljIHVwZGF0ZSggZGVsdGFUaW1lOiBudW1iZXIgKTogbnVtYmVyIHtcbiAgICB0aGlzLnZlbG9jaXR5ICs9IChcbiAgICAgIC10aGlzLmZhY3RvciAqICggdGhpcy52YWx1ZSAtIHRoaXMudGFyZ2V0IClcbiAgICAgIC0gMi4wICogdGhpcy52ZWxvY2l0eSAqIE1hdGguc3FydCggdGhpcy5mYWN0b3IgKSAqIHRoaXMucmF0aW9cbiAgICApICogZGVsdGFUaW1lO1xuICAgIHRoaXMudmFsdWUgKz0gdGhpcy52ZWxvY2l0eSAqIGRlbHRhVGltZTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDbGFzcyB0aGF0IGRlYWxzIHdpdGggdGltZS5cbiAqIEluIHRoaXMgYmFzZSBjbGFzcywgeW91IG5lZWQgdG8gc2V0IHRpbWUgbWFudWFsbHkgZnJvbSBgQXV0b21hdG9uLnVwZGF0ZSgpYC5cbiAqIEJlc3QgZm9yIHN5bmMgd2l0aCBleHRlcm5hbCBjbG9jayBzdHVmZi5cbiAqL1xuZXhwb3J0IGNsYXNzIENsb2NrIHtcbiAgLyoqXG4gICAqIEl0cyBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBwcm90ZWN0ZWQgX190aW1lID0gMC4wO1xuXG4gIC8qKlxuICAgKiBJdHMgZGVsdGFUaW1lIG9mIGxhc3QgdXBkYXRlLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9fZGVsdGFUaW1lID0gMC4wO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGl0cyBjdXJyZW50bHkgcGxheWluZyBvciBub3QuXG4gICAqL1xuICBwcm90ZWN0ZWQgX19pc1BsYXlpbmcgPSBmYWxzZTtcblxuICAvKipcbiAgICogSXRzIGN1cnJlbnQgdGltZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgdGltZSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fX3RpbWU7IH1cblxuICAvKipcbiAgICogSXRzIGRlbHRhVGltZSBvZiBsYXN0IHVwZGF0ZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgZGVsdGFUaW1lKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9fZGVsdGFUaW1lOyB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgaXRzIGN1cnJlbnRseSBwbGF5aW5nIG9yIG5vdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNQbGF5aW5nKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fX2lzUGxheWluZzsgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNsb2NrLlxuICAgKiBAcGFyYW0gdGltZSBUaW1lLiBZb3UgbmVlZCB0byBzZXQgbWFudWFsbHkgd2hlbiB5b3UgYXJlIHVzaW5nIG1hbnVhbCBDbG9ja1xuICAgKi9cbiAgcHVibGljIHVwZGF0ZSggdGltZT86IG51bWJlciApOiB2b2lkIHtcbiAgICBjb25zdCBwcmV2VGltZSA9IHRoaXMuX190aW1lO1xuICAgIHRoaXMuX190aW1lID0gdGltZSB8fCAwLjA7XG4gICAgdGhpcy5fX2RlbHRhVGltZSA9IHRoaXMuX190aW1lIC0gcHJldlRpbWU7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIGNsb2NrLlxuICAgKi9cbiAgcHVibGljIHBsYXkoKTogdm9pZCB7XG4gICAgdGhpcy5fX2lzUGxheWluZyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgY2xvY2suXG4gICAqL1xuICBwdWJsaWMgcGF1c2UoKTogdm9pZCB7XG4gICAgdGhpcy5fX2lzUGxheWluZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGltZSBtYW51YWxseS5cbiAgICogQHBhcmFtIHRpbWUgVGltZVxuICAgKi9cbiAgcHVibGljIHNldFRpbWUoIHRpbWU6IG51bWJlciApOiB2b2lkIHtcbiAgICB0aGlzLl9fdGltZSA9IHRpbWU7XG4gIH1cbn1cbiIsImltcG9ydCB7IENsb2NrIH0gZnJvbSAnLi9DbG9jayc7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCBkZWFscyB3aXRoIHRpbWUuXG4gKiBUaGlzIGlzIFwiZnJhbWVcIiB0eXBlIGNsb2NrLCB0aGUgZnJhbWUgaW5jcmVhc2VzIGV2ZXJ5IHtAbGluayBDbG9ja0ZyYW1lI3VwZGF0ZX0gY2FsbC5cbiAqIEBwYXJhbSBmcHMgRnJhbWVzIHBlciBzZWNvbmRcbiAqL1xuZXhwb3J0IGNsYXNzIENsb2NrRnJhbWUgZXh0ZW5kcyBDbG9jayB7XG4gIC8qKlxuICAgKiBJdHMgY3VycmVudCBmcmFtZS5cbiAgICovXG4gIHByaXZhdGUgX19mcmFtZSA9IDA7XG5cbiAgLyoqXG4gICAqIEl0cyBmcHMuXG4gICAqL1xuICBwcml2YXRlIF9fZnBzOiBudW1iZXI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBmcHMgPSA2MCApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19mcHMgPSBmcHM7XG4gIH1cblxuICAvKipcbiAgICogSXRzIGN1cnJlbnQgZnJhbWUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGZyYW1lKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9fZnJhbWU7IH1cblxuICAvKipcbiAgICogSXRzIGZwcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgZnBzKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9fZnBzOyB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY2xvY2suIEl0IHdpbGwgaW5jcmVhc2UgdGhlIGZyYW1lIGJ5IDEuXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKCk6IHZvaWQge1xuICAgIGlmICggdGhpcy5fX2lzUGxheWluZyApIHtcbiAgICAgIHRoaXMuX190aW1lID0gdGhpcy5fX2ZyYW1lIC8gdGhpcy5fX2ZwcztcbiAgICAgIHRoaXMuX19kZWx0YVRpbWUgPSAxLjAgLyB0aGlzLl9fZnBzO1xuICAgICAgdGhpcy5fX2ZyYW1lICsrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fZGVsdGFUaW1lID0gMC4wO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRpbWUgbWFudWFsbHkuXG4gICAqIFRoZSBzZXQgdGltZSB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIGludGVybmFsIGZyYW1lIGNvdW50LCBzbyB0aGUgdGltZSB3aWxsIG5vdCBiZSBleGFjdGx5IHNhbWUgYXMgc2V0IG9uZS5cbiAgICogQHBhcmFtIHRpbWUgVGltZVxuICAgKi9cbiAgcHVibGljIHNldFRpbWUoIHRpbWU6IG51bWJlciApOiB2b2lkIHtcbiAgICB0aGlzLl9fZnJhbWUgPSBNYXRoLmZsb29yKCB0aGlzLl9fZnBzICogdGltZSApO1xuICAgIHRoaXMuX190aW1lID0gdGhpcy5fX2ZyYW1lIC8gdGhpcy5fX2ZwcztcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2xvY2sgfSBmcm9tICcuL0Nsb2NrJztcblxuLyoqXG4gKiBDbGFzcyB0aGF0IGRlYWxzIHdpdGggdGltZS5cbiAqIFRoaXMgaXMgXCJyZWFsdGltZVwiIHR5cGUgY2xvY2ssIHRoZSB0aW1lIGdvZXMgb24gYXMgcmVhbCB3b3JsZC5cbiAqL1xuZXhwb3J0IGNsYXNzIENsb2NrUmVhbHRpbWUgZXh0ZW5kcyBDbG9jayB7XG4gIC8qKlxuICAgKiBcIllvdSBzZXQgdGhlIHRpbWUgbWFudWFsbHkgdG8gYF9fcnRUaW1lYCB3aGVuIGl0J3MgYF9fcnREYXRlYC5cIlxuICAgKi9cbiAgcHJpdmF0ZSBfX3J0VGltZSA9IDAuMDtcblxuICAvKipcbiAgICogXCJZb3Ugc2V0IHRoZSB0aW1lIG1hbnVhbGx5IHRvIGBfX3J0VGltZWAgd2hlbiBpdCdzIGBfX3J0RGF0ZWAuXCJcbiAgICovXG4gIHByaXZhdGUgX19ydERhdGU6IG51bWJlciA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gIC8qKlxuICAgKiBUaGUgY2xvY2sgaXMgcmVhbHRpbWUuIHllYWguXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzUmVhbHRpbWUoKTogYm9vbGVhbiB7IHJldHVybiB0cnVlOyB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY2xvY2suIFRpbWUgaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aW1lIGluIHJlYWwgd29ybGQuXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgaWYgKCB0aGlzLl9faXNQbGF5aW5nICkge1xuICAgICAgY29uc3QgcHJldlRpbWUgPSB0aGlzLl9fdGltZTtcbiAgICAgIGNvbnN0IGRlbHRhRGF0ZSA9ICggbm93IC0gdGhpcy5fX3J0RGF0ZSApO1xuICAgICAgdGhpcy5fX3RpbWUgPSB0aGlzLl9fcnRUaW1lICsgZGVsdGFEYXRlIC8gMTAwMC4wO1xuICAgICAgdGhpcy5fX2RlbHRhVGltZSA9IHRoaXMudGltZSAtIHByZXZUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fcnRUaW1lID0gdGhpcy50aW1lO1xuICAgICAgdGhpcy5fX3J0RGF0ZSA9IG5vdztcbiAgICAgIHRoaXMuX19kZWx0YVRpbWUgPSAwLjA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGltZSBtYW51YWxseS5cbiAgICogQHBhcmFtIHRpbWUgVGltZVxuICAgKi9cbiAgcHVibGljIHNldFRpbWUoIHRpbWU6IG51bWJlciApOiB2b2lkIHtcbiAgICB0aGlzLl9fdGltZSA9IHRpbWU7XG4gICAgdGhpcy5fX3J0VGltZSA9IHRoaXMudGltZTtcbiAgICB0aGlzLl9fcnREYXRlID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3UkdCIH0gZnJvbSAnLi9SYXdSR0InO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBpbnB1dCBjb2xvciBpbiBBdGFyaS1TVCBjb2xvciBwYWxldHRlIGZvcm1hdCB0byBhIHtAbGluayBSYXdSR0J9LlxuICpcbiAqIEBwYXJhbSBzdENvbG9yIEEgY29sb3IgaW4gQXRhcmktU1QgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2xvckZyb21BdGFyaVNUKCBzdENvbG9yOiBudW1iZXIgKTogUmF3UkdCIHtcbiAgcmV0dXJuIFtcbiAgICAoIHN0Q29sb3IgPj4gOCAmIDcgKSAvIDcuMCxcbiAgICAoIHN0Q29sb3IgPj4gNCAmIDcgKSAvIDcuMCxcbiAgICAoIHN0Q29sb3IgJiA3ICkgLyA3LjAsXG4gIF07XG59XG4iLCIvKipcbiAqIGBsZXJwYCwgb3IgYG1peGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAoIGE6IG51bWJlciwgYjogbnVtYmVyLCB4OiBudW1iZXIgKTogbnVtYmVyIHtcbiAgcmV0dXJuIGEgKyAoIGIgLSBhICkgKiB4O1xufVxuXG4vKipcbiAqIGBjbGFtcGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKCB4OiBudW1iZXIsIGw6IG51bWJlciwgaDogbnVtYmVyICk6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLm1pbiggTWF0aC5tYXgoIHgsIGwgKSwgaCApO1xufVxuXG4vKipcbiAqIGBjbGFtcCggeCwgMC4wLCAxLjAgKWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhdHVyYXRlKCB4OiBudW1iZXIgKTogbnVtYmVyIHtcbiAgcmV0dXJuIGNsYW1wKCB4LCAwLjAsIDEuMCApO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHZhbHVlIGZyb20gaW5wdXQgcmFuZ2UgdG8gb3V0cHV0IHJhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2UoIHg6IG51bWJlciwgeDA6IG51bWJlciwgeDE6IG51bWJlciwgeTA6IG51bWJlciwgeTE6IG51bWJlciApOiBudW1iZXIge1xuICByZXR1cm4gKCAoIHggLSB4MCApICogKCB5MSAtIHkwICkgLyAoIHgxIC0geDAgKSArIHkwICk7XG59XG5cbi8qKlxuICogYHNtb290aHN0ZXBgIGJ1dCBub3Qgc21vb3RoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJzdGVwKCBhOiBudW1iZXIsIGI6IG51bWJlciwgeDogbnVtYmVyICk6IG51bWJlciB7XG4gIHJldHVybiBzYXR1cmF0ZSggKCB4IC0gYSApIC8gKCBiIC0gYSApICk7XG59XG5cbi8qKlxuICogd29ybGQgZmFtb3VzIGBzbW9vdGhzdGVwYCBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc21vb3Roc3RlcCggYTogbnVtYmVyLCBiOiBudW1iZXIsIHg6IG51bWJlciApOiBudW1iZXIge1xuICBjb25zdCB0ID0gbGluZWFyc3RlcCggYSwgYiwgeCApO1xuICByZXR1cm4gdCAqIHQgKiAoIDMuMCAtIDIuMCAqIHQgKTtcbn1cblxuLyoqXG4gKiBgc21vb3Roc3RlcGAgYnV0IG1vcmUgc21vb3RoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbW9vdGhlcnN0ZXAoIGE6IG51bWJlciwgYjogbnVtYmVyLCB4OiBudW1iZXIgKTogbnVtYmVyIHtcbiAgY29uc3QgdCA9IGxpbmVhcnN0ZXAoIGEsIGIsIHggKTtcbiAgcmV0dXJuIHQgKiB0ICogdCAqICggdCAqICggdCAqIDYuMCAtIDE1LjAgKSArIDEwLjAgKTtcbn1cblxuLyoqXG4gKiBgc21vb3Roc3RlcGAgYnV0IFdBWSBtb3JlIHNtb290aFxuICovXG5leHBvcnQgZnVuY3Rpb24gc21vb3RoZXN0c3RlcCggYTogbnVtYmVyLCBiOiBudW1iZXIsIHg6IG51bWJlciApOiBudW1iZXIge1xuICBjb25zdCB0ID0gbGluZWFyc3RlcCggYSwgYiwgeCApO1xuICByZXR1cm4gdCAqIHQgKiB0ICogdCAqICggdCAqICggdCAqICggLTIwLjAgKiB0ICsgNzAuMCApIC0gODQuMCApICsgMzUuMCApO1xufVxuIiwiaW1wb3J0IHsgUmF3UkdCIH0gZnJvbSAnLi9SYXdSR0InO1xuaW1wb3J0IHsgbGVycCB9IGZyb20gJy4uL21hdGgvdXRpbHMnO1xuXG4vKipcbiAqIENvbnZlcnQgYSBjb2xvciBmcm9tIEhTViB0byBSR0IuXG4gKiBFYWNoIGNvbXBvbmVudCBvZiB0aGUgSFNWIG11c3QgYmUgZ2l2ZW4gaW4gWzAgLSAxXSByYW5nZS5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTVl9jb2xvcl9zcGFjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29sb3JIU1YyUkdCKCBbIGgsIHMsIHYgXTogWyBudW1iZXIsIG51bWJlciwgbnVtYmVyIF0gKTogUmF3UkdCIHtcbiAgY29uc3QgaHQgPSBoICUgMS4wICogNi4wO1xuXG4gIHJldHVybiBbIDAuMCwgNC4wLCAyLjAgXS5tYXAoICggcCApID0+IHtcbiAgICBjb25zdCBjb2xIID0gTWF0aC5taW4oIE1hdGgubWF4KCAoXG4gICAgICBNYXRoLmFicyggKCBodCArIHAgKSAlIDYuMCAtIDMuMCApIC0gMS4wXG4gICAgKSwgMC4wICksIDEuMCApO1xuICAgIGNvbnN0IGNvbFMgPSBsZXJwKCAxLjAsIGNvbEgsIHMgKTtcbiAgICByZXR1cm4gdiAqIGNvbFM7XG4gIH0gKSBhcyBSYXdSR0I7XG59XG4iLCJpbXBvcnQgeyBzYXR1cmF0ZSB9IGZyb20gJy4uL21hdGgvdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBSYXdSR0IgfSBmcm9tICcuL1Jhd1JHQic7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGlucHV0IGNvbG9yIHRvIGhleCByZXByZXNlbnRhdGlvbiAoZS5nLiAjN2Y3ZjdmKVxuICogQHBhcmFtIGNvbG9yIGNvbG9yIGluIHtAbGluayBSYXdSR0J9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2xvclRvSGV4KCBjb2xvcjogUmF3UkdCICk6IHN0cmluZyB7XG4gIHJldHVybiAnIycgKyBjb2xvci5tYXAoICggdiApID0+IChcbiAgICAoICcwJyArICggTWF0aC5yb3VuZCggc2F0dXJhdGUoIHYgKSAqIDI1NS4wICkgKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtMiApXG4gICkgKS5qb2luKCAnJyApO1xufVxuIiwiLyoqXG4gKiBSZXR1cm4gYSBkb3QgcHJvZHVjdCBvZiBnaXZlbiB0d28gdmVjdG9ycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlY0RvdDxUIGV4dGVuZHMgbnVtYmVyW10+KCB2ZWNBOiBULCB2ZWNCOiBUICk6IG51bWJlciB7XG4gIHJldHVybiB2ZWNBLnJlZHVjZSggKCBzdW0sIHYsIGkgKSA9PiBzdW0gKyB2ICogdmVjQlsgaSBdLCAwLjAgKTtcbn1cbiIsIi8qIVxuICogVHVyYm8gY29sb3JtYXBcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiAoQXBhY2hlLTIuMClcbiAqXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9taWtoYWlsb3Ytd29yay8wZDE3NzQ2NWE4MTUxZWI2ZWRlMTc2OGQ1MWQ0NzZjN1xuICovXG5cbmltcG9ydCB7IFJhd1JHQiB9IGZyb20gJy4vUmF3UkdCJztcbmltcG9ydCB7IHNhdHVyYXRlIH0gZnJvbSAnLi4vbWF0aC91dGlscyc7XG5pbXBvcnQgeyB2ZWNEb3QgfSBmcm9tICcuLi9tYXRoL3ZlYy92ZWNEb3QnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgdHVyYm8gZ3JhZGllbnQuXG4gKlxuICogUmVmOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9taWtoYWlsb3Ytd29yay8wZDE3NzQ2NWE4MTUxZWI2ZWRlMTc2OGQ1MWQ0NzZjN1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29sb3JUdXJibyggeDogbnVtYmVyICk6IFJhd1JHQiB7XG4gIGNvbnN0IGtyID0gW1xuICAgIDAuMTM1NzIxMzgsIDQuNjE1MzkyNjAsIC00Mi42NjAzMjI1OCxcbiAgICAxMzIuMTMxMDgyMzQsIC0xNTIuOTQyMzkzOTYsIDU5LjI4NjM3OTQzLFxuICBdO1xuICBjb25zdCBrZyA9IFtcbiAgICAwLjA5MTQwMjYxLCAyLjE5NDE4ODM5LCA0Ljg0Mjk2NjU4LFxuICAgIC0xNC4xODUwMzMzMywgNC4yNzcyOTg1NywgMi44Mjk1NjYwNCxcbiAgXTtcbiAgY29uc3Qga2IgPSBbXG4gICAgMC4xMDY2NzMzMCwgMTIuNjQxOTQ2MDgsIC02MC41ODIwNDgzNixcbiAgICAxMTAuMzYyNzY3NzEsIC04OS45MDMxMDkxMiwgMjcuMzQ4MjQ5NzMsXG4gIF07XG5cbiAgY29uc3QgeHQgPSBzYXR1cmF0ZSggeCApO1xuICBjb25zdCB4diA9IFtcbiAgICAxLjAsXG4gICAgeHQsXG4gICAgeHQgKiB4dCxcbiAgICB4dCAqIHh0ICogeHQsXG4gICAgeHQgKiB4dCAqIHh0ICogeHQsXG4gICAgeHQgKiB4dCAqIHh0ICogeHQgKiB4dCxcbiAgXTtcblxuICBjb25zdCBjb2wgPSBbXG4gICAgc2F0dXJhdGUoIHZlY0RvdCgga3IsIHh2ICkgKSxcbiAgICBzYXR1cmF0ZSggdmVjRG90KCBrZywgeHYgKSApLFxuICAgIHNhdHVyYXRlKCB2ZWNEb3QoIGtiLCB4diApICksXG4gIF07XG5cbiAgcmV0dXJuIGNvbCBhcyBSYXdSR0I7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd1JHQiB9IGZyb20gJy4vUmF3UkdCJztcblxuLyoqXG4gKiBFT1RGIG9mIFJlYy43MDkgYS5rLmEuIHNSR0ItdG8tTGluZWFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlb3RmUmVjNzA5KCB2YWx1ZTogUmF3UkdCICk6IFJhd1JHQiB7XG4gIHJldHVybiB2YWx1ZS5tYXAoICggdiApID0+IChcbiAgICB2IDwgMC4wODFcbiAgICAgID8gdiAvIDQuNVxuICAgICAgOiBNYXRoLnBvdyggKCB2ICsgMC4wOTkgKSAvIDEuMDk5LCAxLjAgLyAwLjQ1IClcbiAgKSApIGFzIFJhd1JHQjtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3UkdCIH0gZnJvbSAnLi9SYXdSR0InO1xuXG4vKipcbiAqIE9FVEYgb2YgUmVjLjcwOSBhLmsuYS4gTGluZWFyLXRvLXNSR0JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ldGZSZWM3MDkoIGx1bWluYW5jZTogUmF3UkdCICk6IFJhd1JHQiB7XG4gIHJldHVybiBsdW1pbmFuY2UubWFwKCAoIGwgKSA9PiAoXG4gICAgbCA8IDAuMDE4XG4gICAgICA/IDQuNSAqIGxcbiAgICAgIDogMS4wOTkgKiBNYXRoLnBvdyggbCwgMC40NSApIC0gMC4wOTlcbiAgKSApIGFzIFJhd1JHQjtcbn1cbiIsImltcG9ydCB7IFJhd0RhZ0VkZ2UgfSBmcm9tICcuL1Jhd0RhZ0VkZ2UnO1xuXG4vKipcbiAqIFJldHVybiBhbGwgcGFyZW50IHNvdXJjZXMgdGhlIHNwZWNpZmllZCBkZXN0aW5hdGlvbiBoYXMuXG4gKiBAcGFyYW0gZWRnZXMgQW4gYXJyYXkgb2YgZGFnIGVkZ2VcbiAqIEBwYXJhbSBkZXN0aW5hdGlvbiBUaGUgdGFyZ2V0IGRlc3RpbmF0aW9uXG4gKlxuICogU2VlIGFsc286IHtAbGluayBkYWdFZGdlc0NoaWxkcmVufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGFnRWRnZXNQYXJlbnRzPFQ+KCBlZGdlczogUmF3RGFnRWRnZTxUPltdLCBkZXN0aW5hdGlvbjogVCApOiBUW10ge1xuICByZXR1cm4gZWRnZXNcbiAgICAuZmlsdGVyKCAoIGVkZ2UgKSA9PiBlZGdlWyAxIF0gPT09IGRlc3RpbmF0aW9uIClcbiAgICAubWFwKCAoIGVkZ2UgKSA9PiBlZGdlWyAwIF0gKTtcbn1cbiIsImltcG9ydCB7IGRhZ0VkZ2VzUGFyZW50cyB9IGZyb20gJy4vZGFnRWRnZXNQYXJlbnRzJztcbmltcG9ydCB7IHRyYXZlcnNlIH0gZnJvbSAnLi4vYWxnb3JpdGhtL3RyYXZlcnNlJztcbmltcG9ydCB0eXBlIHsgUmF3RGFnRWRnZSB9IGZyb20gJy4vUmF3RGFnRWRnZSc7XG5cbi8qKlxuICogUmV0dXJuIGFsbCBhbmNlc3RvciBzb3VyY2VzIHRoZSBzcGVjaWZpZWQgZGVzdGluYXRpb24gaGFzLlxuICogQHBhcmFtIGVkZ2VzIEFuIGFycmF5IG9mIGRhZyBlZGdlXG4gKiBAcGFyYW0gZGVzdGluYXRpb24gVGhlIHRhcmdldCBkZXN0aW5hdGlvblxuICpcbiAqIFNlZSBhbHNvOiB7QGxpbmsgZGFnRWRnZXNDaGlsZHJlbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhZ0VkZ2VzQW5jZXN0b3JzPFQ+KCBlZGdlczogUmF3RGFnRWRnZTxUPltdLCBkZXN0aW5hdGlvbjogVCApOiBUW10ge1xuICBjb25zdCBhbmNlc3RvcnMgPSBuZXcgU2V0PFQ+KCk7XG5cbiAgdHJhdmVyc2UoIGRlc3RpbmF0aW9uLCAoIG5vZGUgKSA9PiB7XG4gICAgY29uc3QgcGFyZW50cyA9IGRhZ0VkZ2VzUGFyZW50cyggZWRnZXMsIG5vZGUgKTtcbiAgICBwYXJlbnRzLm1hcCggKCBwYXJlbnQgKSA9PiBhbmNlc3RvcnMuYWRkKCBwYXJlbnQgKSApO1xuICAgIHJldHVybiBwYXJlbnRzO1xuICB9ICk7XG5cbiAgcmV0dXJuIEFycmF5LmZyb20oIGFuY2VzdG9ycyApO1xufVxuIiwiaW1wb3J0IHsgUmF3RGFnRWRnZSB9IGZyb20gJy4vUmF3RGFnRWRnZSc7XG5cbi8qKlxuICogUmV0dXJuIGFsbCBjaGlsZHJlbiBkZXN0aW5hdGlvbnMgdGhlIHNwZWNpZmllZCBzb3VyY2UgaGFzLlxuICogQHBhcmFtIGVkZ2VzIEFuIGFycmF5IG9mIGRhZyBlZGdlXG4gKiBAcGFyYW0gc291cmNlIFRoZSB0YXJnZXQgc291cmNlXG4gKlxuICogU2VlIGFsc286IHtAbGluayBkYWdFZGdlc0Rlc2NlbmRhbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYWdFZGdlc0NoaWxkcmVuPFQ+KCBlZGdlczogUmF3RGFnRWRnZTxUPltdLCBzb3VyY2U6IFQgKTogVFtdIHtcbiAgcmV0dXJuIGVkZ2VzXG4gICAgLmZpbHRlciggKCBlZGdlICkgPT4gZWRnZVsgMCBdID09PSBzb3VyY2UgKVxuICAgIC5tYXAoICggZWRnZSApID0+IGVkZ2VbIDEgXSApO1xufVxuIiwiaW1wb3J0IHsgZGFnRWRnZXNDaGlsZHJlbiB9IGZyb20gJy4vZGFnRWRnZXNDaGlsZHJlbic7XG5pbXBvcnQgeyB0cmF2ZXJzZSB9IGZyb20gJy4uL2FsZ29yaXRobS90cmF2ZXJzZSc7XG5pbXBvcnQgdHlwZSB7IFJhd0RhZ0VkZ2UgfSBmcm9tICcuL1Jhd0RhZ0VkZ2UnO1xuXG4vKipcbiAqIFJldHVybiBhbGwgZGVzY2VuZGFudCBkZXN0aW5hdGlvbnMgdGhlIHNwZWNpZmllZCBzb3VyY2UgaGFzLlxuICogQHBhcmFtIGVkZ2VzIEFuIGFycmF5IG9mIGRhZyBlZGdlXG4gKiBAcGFyYW0gc291cmNlIFRoZSB0YXJnZXQgc291cmNlXG4gKlxuICogU2VlIGFsc286IHtAbGluayBkYWdFZGdlc0NoaWxkcmVufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGFnRWRnZXNEZXNjZW5kYW50czxUPiggZWRnZXM6IFJhd0RhZ0VkZ2U8VD5bXSwgc291cmNlOiBUICk6IFRbXSB7XG4gIGNvbnN0IGRlc2NlbmRhbnRzID0gbmV3IFNldDxUPigpO1xuXG4gIHRyYXZlcnNlKCBzb3VyY2UsICggbm9kZSApID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGRhZ0VkZ2VzQ2hpbGRyZW4oIGVkZ2VzLCBub2RlICk7XG4gICAgY2hpbGRyZW4ubWFwKCAoIGNoaWxkICkgPT4gZGVzY2VuZGFudHMuYWRkKCBjaGlsZCApICk7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9ICk7XG5cbiAgcmV0dXJuIEFycmF5LmZyb20oIGRlc2NlbmRhbnRzICk7XG59XG4iLCJpbXBvcnQgeyBSYXdEYWdFZGdlIH0gZnJvbSAnLi9SYXdEYWdFZGdlJztcblxuLyoqXG4gKiBSZXR1cm4gZmlyc3QgcGFyZW50IHNvdXJjZSB0aGUgc3BlY2lmaWVkIGRlc3RpbmF0aW9uIGhhcy5cbiAqIElmIGl0IGNhbid0IGZpbmQgYSBwYXJlbnQsIGl0IHdpbGwgcmV0dXJuIGBudWxsYCBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSBlZGdlcyBBbiBhcnJheSBvZiBkYWcgZWRnZVxuICogQHBhcmFtIGRlc3RpbmF0aW9uIFRoZSB0YXJnZXQgZGVzdGluYXRpb25cbiAqXG4gKiBTZWUgYWxzbzoge0BsaW5rIGRhZ0VkZ2VzUGFyZW50c31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhZ0VkZ2VzUGFyZW50PFQ+KCBlZGdlczogUmF3RGFnRWRnZTxUPltdLCBkZXN0aW5hdGlvbjogVCApOiBUIHwgbnVsbCB7XG4gIHJldHVybiBlZGdlcy5maW5kKCAoIGVkZ2UgKSA9PiBlZGdlWyAxIF0gPT09IGRlc3RpbmF0aW9uICk/LlsgMCBdID8/IG51bGw7XG59XG4iLCJpbXBvcnQgeyBSYXdEYWdFZGdlIH0gZnJvbSAnLi9SYXdEYWdFZGdlJztcbmltcG9ydCB7IGRhZ0VkZ2VzUGFyZW50IH0gZnJvbSAnLi9kYWdFZGdlc1BhcmVudCc7XG5cbi8qKlxuICogUmVzb2x2ZSBkYWcgZGVwZW5kZW5jeSByZWxhdGlvbnNoaXAgYW5kIGdpdmUgeW91IGEgY29ycmVjdCBvcmRlci5cbiAqXG4gKiBAcGFyYW0gZWRnZXMgQW4gYXJyYXkgb2YgZGFnIGVkZ2VzXG4gKiBAcGFyYW0gbm9kZXMgQW4gYXJyYXkgb2YgZGFnIG5vZGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYWdFZGdlc1Jlc29sdmU8VD4oIGVkZ2VzOiBSYXdEYWdFZGdlPFQ+W10sIG5vZGVzOiBUW10gKTogVFtdIHtcbiAgY29uc3Qgb3JkZXI6IFRbXSA9IFtdO1xuXG4gIGNvbnN0IG5vZGVTZXQgPSBuZXcgU2V0KCBub2RlcyApO1xuICBsZXQgdGVtcEVkZ2VzID0gZWRnZXMuY29uY2F0KCk7XG5cbiAgd2hpbGUgKCB0ZW1wRWRnZXMubGVuZ3RoID4gMCApIHtcbiAgICBub2RlU2V0LmZvckVhY2goICggbm9kZSApID0+IHtcbiAgICAgIC8vIGlzIHRoaXMgYW4gZW50cnlwb2ludD9cbiAgICAgIGNvbnN0IGhhc1BhcmVudHMgPSBkYWdFZGdlc1BhcmVudCggdGVtcEVkZ2VzLCBub2RlICkgIT0gbnVsbDtcblxuICAgICAgaWYgKCAhaGFzUGFyZW50cyApIHtcbiAgICAgICAgbm9kZVNldC5kZWxldGUoIG5vZGUgKTtcbiAgICAgICAgb3JkZXIucHVzaCggbm9kZSApO1xuXG4gICAgICAgIC8vIGRlbGV0ZSB0aGUgc3RydWN0dXJlIG9mIHRlbXBFZGdlcyBmcm9tIGVudHJ5cG9pbnQgc2lkZVxuICAgICAgICB0ZW1wRWRnZXMgPSB0ZW1wRWRnZXMuZmlsdGVyKCAoIFsgc3JjIF0gKSA9PiAoIHNyYyAhPT0gbm9kZSApICk7XG4gICAgICB9XG4gICAgfSApO1xuICB9XG5cbiAgcmV0dXJuIG9yZGVyLmNvbmNhdCggQXJyYXkuZnJvbSggbm9kZVNldCApICk7XG4gIC8vICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXiB0ZXJtaW5hdG9yIG5vZGVzXG59XG4iLCIvLyB5b2lua2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC90aW55LXNkZiAoQlNEIDItQ2xhdXNlKVxuLy8gaW1wbGVtZW50cyBodHRwOi8vcGVvcGxlLmNzLnVjaGljYWdvLmVkdS9+cGZmL3BhcGVycy9kdC5wZGZcblxuLyoqXG4gKiBDb21wdXRlIGEgb25lIGRpbWVuc2lvbmFsIGVkdCBmcm9tIHRoZSBzb3VyY2UgZGF0YS5cbiAqIFJldHVybmluZyBkaXN0YW5jZSB3aWxsIGJlIHNxdWFyZWQuXG4gKiBJbnRlbmRlZCB0byBiZSB1c2VkIGludGVybmFsbHkgaW4ge0BsaW5rIGVkdDJkfS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBEYXRhIG9mIHRoZSBzb3VyY2VcbiAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IG9mIHRoZSBzb3VyY2UgZnJvbSBiZWdpbm5pbmdcbiAqIEBwYXJhbSBzdHJpZGUgU3RyaWRlIG9mIHRoZSBzb3VyY2VcbiAqIEBwYXJhbSBsZW5ndGggTGVuZ3RoIG9mIHRoZSBzb3VyY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkdDFkKFxuICBkYXRhOiBGbG9hdDMyQXJyYXksXG4gIG9mZnNldDogbnVtYmVyLFxuICBzdHJpZGU6IG51bWJlcixcbiAgbGVuZ3RoOiBudW1iZXJcbik6IHZvaWQge1xuICAvLyBpbmRleCBvZiByaWdodG1vc3QgcGFyYWJvbGEgaW4gbG93ZXIgZW52ZWxvcGVcbiAgbGV0IGsgPSAwO1xuXG4gIC8vIGxvY2F0aW9ucyBvZiBwYXJhYm9sYXMgaW4gbG93ZXIgZW52ZWxvcGVcbiAgY29uc3QgdiA9IG5ldyBGbG9hdDMyQXJyYXkoIGxlbmd0aCApO1xuICB2WyAwIF0gPSAwLjA7XG5cbiAgLy8gbG9jYXRpb25zIG9mIGJvdW5kYXJpZXMgYmV0d2VlbiBwYXJhYm9sYXNcbiAgY29uc3QgeiA9IG5ldyBGbG9hdDMyQXJyYXkoIGxlbmd0aCArIDEgKTtcbiAgelsgMCBdID0gLUluZmluaXR5O1xuICB6WyAxIF0gPSBJbmZpbml0eTtcblxuICAvLyBjcmVhdGUgYSBzdHJhaWdodCBhcnJheSBvZiBpbnB1dCBkYXRhXG4gIGNvbnN0IGYgPSBuZXcgRmxvYXQzMkFycmF5KCBsZW5ndGggKTtcbiAgZm9yICggbGV0IHEgPSAwOyBxIDwgbGVuZ3RoOyBxICsrICkge1xuICAgIGZbIHEgXSA9IGRhdGFbIG9mZnNldCArIHEgKiBzdHJpZGUgXTtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgbG93ZXIgZW52ZWxvcGVcbiAgZm9yICggbGV0IHEgPSAxOyBxIDwgbGVuZ3RoOyBxICsrICkge1xuICAgIGxldCBzID0gMC4wO1xuXG4gICAgd2hpbGUgKCAwIDw9IGsgKSB7XG4gICAgICBzID0gKCBmWyBxIF0gKyBxICogcSAtIGZbIHZbIGsgXSBdIC0gdlsgayBdICogdlsgayBdICkgLyAoIDIuMCAqIHEgLSAyLjAgKiB2WyBrIF0gKTtcbiAgICAgIGlmICggcyA8PSB6WyBrIF0gKSB7XG4gICAgICAgIGsgLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBrICsrO1xuICAgIHZbIGsgXSA9IHE7XG4gICAgelsgayBdID0gcztcbiAgICB6WyBrICsgMSBdID0gSW5maW5pdHk7XG4gIH1cblxuICBrID0gMDtcblxuICAvLyBmaWxsIGluIHZhbHVlcyBvZiBkaXN0YW5jZSB0cmFuc2Zvcm1cbiAgZm9yICggbGV0IHEgPSAwOyBxIDwgbGVuZ3RoOyBxICsrICkge1xuICAgIHdoaWxlICggelsgayArIDEgXSA8IHEgKSB7IGsgKys7IH1cbiAgICBjb25zdCBxU3ViVksgPSBxIC0gdlsgayBdO1xuICAgIGRhdGFbIG9mZnNldCArIHEgKiBzdHJpZGUgXSA9IGZbIHZbIGsgXSBdICsgcVN1YlZLICogcVN1YlZLO1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZSBhIHR3byBkaW1lbnNpb25hbCBlZHQgZnJvbSB0aGUgc291cmNlIGRhdGEuXG4gKiBSZXR1cm5pbmcgZGlzdGFuY2Ugd2lsbCBiZSBzcXVhcmVkLlxuICpcbiAqIEBwYXJhbSBkYXRhIERhdGEgb2YgdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB3aWR0aCBXaWR0aCBvZiB0aGUgc291cmNlLlxuICogQHBhcmFtIGhlaWdodCBIZWlnaHQgb2YgdGhlIHNvdXJjZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkdDJkKFxuICBkYXRhOiBGbG9hdDMyQXJyYXksXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyXG4pOiB2b2lkIHtcbiAgZm9yICggbGV0IHggPSAwOyB4IDwgd2lkdGg7IHggKysgKSB7XG4gICAgZWR0MWQoIGRhdGEsIHgsIHdpZHRoLCBoZWlnaHQgKTtcbiAgfVxuXG4gIGZvciAoIGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSArKyApIHtcbiAgICBlZHQxZCggZGF0YSwgeSAqIHdpZHRoLCAxLCB3aWR0aCApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBsZXJwIH0gZnJvbSAnLi4vbWF0aC91dGlscyc7XG5cbi8qKlxuICogRG8gZXhwIHNtb290aGluZ1xuICovXG5leHBvcnQgY2xhc3MgRXhwU21vb3RoIHtcbiAgcHVibGljIGZhY3RvciA9IDEwLjA7XG4gIHB1YmxpYyB0YXJnZXQgPSAwLjA7XG4gIHB1YmxpYyB2YWx1ZSA9IDAuMDtcblxuICBwdWJsaWMgdXBkYXRlKCBkZWx0YVRpbWU6IG51bWJlciApOiBudW1iZXIge1xuICAgIHRoaXMudmFsdWUgPSBsZXJwKCB0aGlzLnRhcmdldCwgdGhpcy52YWx1ZSwgTWF0aC5leHAoIC10aGlzLmZhY3RvciAqIGRlbHRhVGltZSApICk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn1cbiIsImV4cG9ydCBjbGFzcyBQb29sPFQ+IHtcbiAgcHVibGljIGFycmF5OiBUW107XG5cbiAgcHVibGljIGluZGV4ID0gMDtcblxuICBwdWJsaWMgZ2V0IGN1cnJlbnQoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbIHRoaXMuaW5kZXggXTtcbiAgfVxuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggYXJyYXk6IFRbXSApIHtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBwdWJsaWMgbmV4dCgpOiBUIHtcbiAgICB0aGlzLmluZGV4ID0gKCB0aGlzLmluZGV4ICsgMSApICUgdGhpcy5hcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgUG9vbCB9IGZyb20gJy4uL1Bvb2wvUG9vbCc7XG5cbmV4cG9ydCBjbGFzcyBHUFVUaW1lciB7XG4gIHB1YmxpYyBxdWVyaWVzOiBQb29sPFdlYkdMUXVlcnk+O1xuICBwdWJsaWMgc3RhY2s6IFByb21pc2U8bnVtYmVyPltdO1xuICBwdWJsaWMgZXh0OiBhbnk7XG4gIHB1YmxpYyByZWFkb25seSBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcblxuICBwcml2YXRlIF9fbG9vcFRhc2tzOiBTZXQ8KCkgPT4gdm9pZD47XG5cbiAgcHVibGljIHN0YXRpYyBpc1N1cHBvcnRlZCggZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5ldyBTZXQoIGdsLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKSApLmhhcyggJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInICk7XG4gIH1cblxuICBwdWJsaWMgY29uc3RydWN0b3IoIGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICkge1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIGNvbnN0IHF1ZXJpZXMgPSBuZXcgQXJyYXkoIDEwMjQgKS5maWxsKCAxICkubWFwKCAoKSA9PiBnbC5jcmVhdGVRdWVyeSgpISApO1xuICAgIHRoaXMucXVlcmllcyA9IG5ldyBQb29sKCBxdWVyaWVzICk7XG5cbiAgICB0aGlzLnN0YWNrID0gW107XG5cbiAgICB0aGlzLmV4dCA9IGdsLmdldEV4dGVuc2lvbiggJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInICk7XG5cbiAgICB0aGlzLl9fbG9vcFRhc2tzID0gbmV3IFNldCgpO1xuXG4gICAgLy8gbG9vcFxuICAgIGNvbnN0IHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xuICAgIH07XG4gICAgdXBkYXRlKCk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKCk6IHZvaWQge1xuICAgIEFycmF5LmZyb20oIHRoaXMuX19sb29wVGFza3MgKS5mb3JFYWNoKCAoIHRhc2sgKSA9PiB0YXNrKCkgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBtZWFzdXJlKCBmdW5jOiAoKSA9PiB2b2lkICk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcblxuICAgIGlmICggdGhpcy5zdGFjay5sZW5ndGggIT09IDAgKSB7XG4gICAgICBnbC5lbmRRdWVyeSggdGhpcy5leHQuVElNRV9FTEFQU0VEX0VYVCApO1xuICAgICAgY29uc3QgcHJvbWlzZUZpbmlzaGluZ1ByZXYgPSB0aGlzLmNoZWNrKCB0aGlzLnF1ZXJpZXMuY3VycmVudCApO1xuXG4gICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5tYXAoIGFzeW5jICggcHJvbWlzZUFjY3VtICkgPT4ge1xuICAgICAgICByZXR1cm4gKCBhd2FpdCBwcm9taXNlQWNjdW0gKSArICggYXdhaXQgcHJvbWlzZUZpbmlzaGluZ1ByZXYgKTtcbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2goIFByb21pc2UucmVzb2x2ZSggMC4wICkgKTtcblxuICAgIGdsLmJlZ2luUXVlcnkoIHRoaXMuZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHRoaXMucXVlcmllcy5uZXh0KCkgKTtcblxuICAgIGZ1bmMoKTtcblxuICAgIGdsLmVuZFF1ZXJ5KCB0aGlzLmV4dC5USU1FX0VMQVBTRURfRVhUICk7XG5cbiAgICBjb25zdCBwcm9taXNlQWNjdW0gPSB0aGlzLnN0YWNrLnBvcCgpITtcbiAgICBjb25zdCBwcm9taXNlVGhpcyA9IHRoaXMuY2hlY2soIHRoaXMucXVlcmllcy5jdXJyZW50ICk7XG5cbiAgICBpZiAoIHRoaXMuc3RhY2subGVuZ3RoICE9PSAwICkge1xuICAgICAgdGhpcy5zdGFjayA9IHRoaXMuc3RhY2subWFwKCBhc3luYyAoIHByb21pc2VBY2N1bSApID0+IHtcbiAgICAgICAgcmV0dXJuICggYXdhaXQgcHJvbWlzZUFjY3VtICkgKyAoIGF3YWl0IHByb21pc2VUaGlzICk7XG4gICAgICB9ICk7XG5cbiAgICAgIGdsLmJlZ2luUXVlcnkoIHRoaXMuZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHRoaXMucXVlcmllcy5uZXh0KCkgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCBhd2FpdCBwcm9taXNlQWNjdW0gKSArICggYXdhaXQgcHJvbWlzZVRoaXMgKTtcbiAgfVxuXG4gIHB1YmxpYyBjaGVjayggcXVlcnk6IFdlYkdMUXVlcnkgKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCAoIHJlc29sdmUgKSA9PiB7XG4gICAgICBjb25zdCB0YXNrID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBpc0F2YWlsYWJsZSA9IGdsLmdldFF1ZXJ5UGFyYW1ldGVyKCBxdWVyeSwgZ2wuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSApO1xuXG4gICAgICAgIGlmICggaXNBdmFpbGFibGUgKSB7XG4gICAgICAgICAgdGhpcy5fX2xvb3BUYXNrcy5kZWxldGUoIHRhc2sgKTtcbiAgICAgICAgICByZXNvbHZlKCBnbC5nZXRRdWVyeVBhcmFtZXRlciggcXVlcnksIGdsLlFVRVJZX1JFU1VMVCApICogMC4wMDEgKiAwLjAwMSApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9fbG9vcFRhc2tzLmFkZCggdGFzayApO1xuICAgIH0gKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBVc2VmdWwgZm9yIHRhcCB0ZW1wb1xuICogU2VlIGFsc286IHtAbGluayBIaXN0b3J5TWVhbkNhbGN1bGF0b3J9XG4gKi9cbmV4cG9ydCBjbGFzcyBIaXN0b3J5TWVhbkNhbGN1bGF0b3Ige1xuICBwcml2YXRlIF9fcmVjYWxjRm9yRWFjaCA9IDA7XG4gIHByaXZhdGUgX19jb3VudFVudGlsUmVjYWxjID0gMDtcbiAgcHJpdmF0ZSBfX2hpc3Rvcnk6IG51bWJlcltdID0gW107XG4gIHByaXZhdGUgX19pbmRleCA9IDA7XG4gIHByaXZhdGUgX19sZW5ndGg6IG51bWJlcjtcbiAgcHJpdmF0ZSBfX2NvdW50ID0gMDtcbiAgcHJpdmF0ZSBfX2NhY2hlID0gMDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoIGxlbmd0aDogbnVtYmVyICkge1xuICAgIHRoaXMuX19sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5fX3JlY2FsY0ZvckVhY2ggPSBsZW5ndGg7XG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuICAgICAgdGhpcy5fX2hpc3RvcnlbIGkgXSA9IDA7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBtZWFuKCk6IG51bWJlciB7XG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1pbiggdGhpcy5fX2NvdW50LCB0aGlzLl9fbGVuZ3RoICk7XG4gICAgcmV0dXJuIGNvdW50ID09PSAwID8gMC4wIDogdGhpcy5fX2NhY2hlIC8gY291bnQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHJlY2FsY0ZvckVhY2goKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fX3JlY2FsY0ZvckVhY2g7XG4gIH1cblxuICBwdWJsaWMgc2V0IHJlY2FsY0ZvckVhY2goIHZhbHVlOiBudW1iZXIgKSB7XG4gICAgY29uc3QgZGVsdGEgPSB2YWx1ZSAtIHRoaXMuX19yZWNhbGNGb3JFYWNoO1xuICAgIHRoaXMuX19yZWNhbGNGb3JFYWNoID0gdmFsdWU7XG4gICAgdGhpcy5fX2NvdW50VW50aWxSZWNhbGMgPSBNYXRoLm1heCggMCwgdGhpcy5fX2NvdW50VW50aWxSZWNhbGMgKyBkZWx0YSApO1xuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuX19pbmRleCA9IDA7XG4gICAgdGhpcy5fX2NvdW50ID0gMDtcbiAgICB0aGlzLl9fY2FjaGUgPSAwO1xuICAgIHRoaXMuX19jb3VudFVudGlsUmVjYWxjID0gMDtcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLl9fbGVuZ3RoOyBpICsrICkge1xuICAgICAgdGhpcy5fX2hpc3RvcnlbIGkgXSA9IDA7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHB1c2goIHZhbHVlOiBudW1iZXIgKTogdm9pZCB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMuX19oaXN0b3J5WyB0aGlzLl9faW5kZXggXTtcbiAgICB0aGlzLl9faGlzdG9yeVsgdGhpcy5fX2luZGV4IF0gPSB2YWx1ZTtcbiAgICB0aGlzLl9fY291bnQgKys7XG4gICAgdGhpcy5fX2luZGV4ID0gKCB0aGlzLl9faW5kZXggKyAxICkgJSB0aGlzLl9fbGVuZ3RoO1xuXG4gICAgaWYgKCB0aGlzLl9fY291bnRVbnRpbFJlY2FsYyA9PT0gMCApIHtcbiAgICAgIHRoaXMucmVjYWxjKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX19jb3VudFVudGlsUmVjYWxjIC0tO1xuICAgICAgdGhpcy5fX2NhY2hlIC09IHByZXY7XG4gICAgICB0aGlzLl9fY2FjaGUgKz0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlY2FsYygpOiB2b2lkIHtcbiAgICB0aGlzLl9fY291bnRVbnRpbFJlY2FsYyA9IHRoaXMuX19yZWNhbGNGb3JFYWNoO1xuICAgIGNvbnN0IHN1bSA9IHRoaXMuX19oaXN0b3J5XG4gICAgICAuc2xpY2UoIDAsIE1hdGgubWluKCB0aGlzLl9fY291bnQsIHRoaXMuX19sZW5ndGggKSApXG4gICAgICAucmVkdWNlKCAoIHN1bSwgdiApID0+IHN1bSArIHYsIDAgKTtcbiAgICB0aGlzLl9fY2FjaGUgPSBzdW07XG4gIH1cbn1cbiIsImltcG9ydCB7IGJpbmFyeVNlYXJjaCB9IGZyb20gJy4uL2FsZ29yaXRobS9iaW5hcnlTZWFyY2gnO1xuXG4vKipcbiAqIFVzZWZ1bCBmb3IgZnBzIGNhbGNcbiAqIFNlZSBhbHNvOiB7QGxpbmsgSGlzdG9yeU1lYW5DYWxjdWxhdG9yfVxuICovXG5leHBvcnQgY2xhc3MgSGlzdG9yeVBlcmNlbnRpbGVDYWxjdWxhdG9yIHtcbiAgcHJpdmF0ZSBfX2hpc3Rvcnk6IG51bWJlcltdID0gW107XG4gIHByaXZhdGUgX19zb3J0ZWQ6IG51bWJlcltdID0gW107XG4gIHByaXZhdGUgX19pbmRleCA9IDA7XG4gIHByaXZhdGUgcmVhZG9ubHkgX19sZW5ndGg6IG51bWJlcjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoIGxlbmd0aDogbnVtYmVyICkge1xuICAgIHRoaXMuX19sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG1lZGlhbigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBlcmNlbnRpbGUoIDUwLjAgKTtcbiAgfVxuXG4gIHB1YmxpYyBwZXJjZW50aWxlKCBwZXJjZW50aWxlOiBudW1iZXIgKTogbnVtYmVyIHtcbiAgICBpZiAoIHRoaXMuX19oaXN0b3J5Lmxlbmd0aCA9PT0gMCApIHsgcmV0dXJuIDAuMDsgfVxuICAgIHJldHVybiB0aGlzLl9fc29ydGVkWyBNYXRoLnJvdW5kKCBwZXJjZW50aWxlICogMC4wMSAqICggdGhpcy5fX2hpc3RvcnkubGVuZ3RoIC0gMSApICkgXTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLl9faW5kZXggPSAwO1xuICAgIHRoaXMuX19oaXN0b3J5ID0gW107XG4gICAgdGhpcy5fX3NvcnRlZCA9IFtdO1xuICB9XG5cbiAgcHVibGljIHB1c2goIHZhbHVlOiBudW1iZXIgKTogdm9pZCB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMuX19oaXN0b3J5WyB0aGlzLl9faW5kZXggXTtcbiAgICB0aGlzLl9faGlzdG9yeVsgdGhpcy5fX2luZGV4IF0gPSB2YWx1ZTtcbiAgICB0aGlzLl9faW5kZXggPSAoIHRoaXMuX19pbmRleCArIDEgKSAlIHRoaXMuX19sZW5ndGg7XG5cbiAgICAvLyByZW1vdmUgdGhlIHByZXYgZnJvbSBzb3J0ZWQgYXJyYXlcbiAgICBpZiAoIHRoaXMuX19zb3J0ZWQubGVuZ3RoID09PSB0aGlzLl9fbGVuZ3RoICkge1xuICAgICAgY29uc3QgcHJldkluZGV4ID0gYmluYXJ5U2VhcmNoKCB0aGlzLl9fc29ydGVkLCBwcmV2ICk7XG4gICAgICB0aGlzLl9fc29ydGVkLnNwbGljZSggcHJldkluZGV4LCAxICk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSBiaW5hcnlTZWFyY2goIHRoaXMuX19zb3J0ZWQsIHZhbHVlICk7XG4gICAgdGhpcy5fX3NvcnRlZC5zcGxpY2UoIGluZGV4LCAwLCB2YWx1ZSApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBIaXN0b3J5UGVyY2VudGlsZUNhbGN1bGF0b3IgfSBmcm9tICcuL0hpc3RvcnlQZXJjZW50aWxlQ2FsY3VsYXRvcic7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgSXQncyBhY3R1YWxseSBqdXN0IGEgc3BlY2lhbCBjYXNlIG9mIHtAbGluayBIaXN0b3J5UGVyY2VudGlsZUNhbGN1bGF0b3J9XG4gKi9cbmV4cG9ydCBjbGFzcyBIaXN0b3J5TWVkaWFuQ2FsY3VsYXRvciBleHRlbmRzIEhpc3RvcnlQZXJjZW50aWxlQ2FsY3VsYXRvciB7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggbGVuZ3RoOiBudW1iZXIgKSB7XG4gICAgc3VwZXIoIGxlbmd0aCApO1xuICAgIGNvbnNvbGUud2FybiggJ0hpc3RvcnlNZWRpYW5DYWxjdWxhdG9yOiBEZXByZWNhdGVkLiBVc2UgSGlzdG9yeVBlcmNlbnRpbGVDYWxjdWxhdG9yIGluc3RlYWQnICk7XG4gIH1cbn1cbiIsImV4cG9ydCBjbGFzcyBNYXBPZlNldDxLLCBWPiB7XG4gIHB1YmxpYyByZWFkb25seSBtYXA6IE1hcDxLLCBTZXQ8Vj4+O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQoIGtleTogSyApOiBTZXQ8Vj4ge1xuICAgIHJldHVybiB0aGlzLm1hcC5nZXQoIGtleSApID8/IG5ldyBTZXQoKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGQoIGtleTogSywgdmFsdWU6IFYgKTogdm9pZCB7XG4gICAgbGV0IHNldCA9IHRoaXMubWFwLmdldCgga2V5ICk7XG4gICAgaWYgKCBzZXQgPT0gbnVsbCApIHtcbiAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMubWFwLnNldCgga2V5LCBzZXQgKTtcbiAgICB9XG4gICAgc2V0LmFkZCggdmFsdWUgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBSZXR1cm4gYSB2ZWN0b3Igd2l0aCB0aGUgYWJzb2x1dGUgb2YgZWFjaCBjb21wb25lbnQgb2YgdGhlIGdpdmVuIHZlY3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlY0FiczxUIGV4dGVuZHMgbnVtYmVyW10+KCB2ZWM6IFQgKTogVCB7XG4gIHJldHVybiB2ZWMubWFwKCAoIHYgKSA9PiBNYXRoLmFicyggdiApICkgYXMgVDtcbn1cbiIsIi8qKlxuICogUmV0dXJuIGEgc3VtIG9mIHZlY3RvcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWNBZGQ8VCBleHRlbmRzIG51bWJlcltdPiggLi4udmVjczogVFtdICk6IFQge1xuICBpZiAoIHZlY3MubGVuZ3RoIDwgMiApIHtcbiAgICByZXR1cm4gdmVjc1sgMCBdO1xuICB9XG5cbiAgY29uc3QgYSA9IHZlY3Muc2hpZnQoKSE7XG4gIGNvbnN0IGIgPSB2ZWNBZGQoIC4uLnZlY3MgKTtcblxuICByZXR1cm4gYS5tYXAoICggdiwgaSApID0+IHYgKyBiWyBpIF0gKSBhcyBUO1xufVxuIiwiLyoqXG4gKiBEaXZpZGUgYSB2ZWN0b3IgYnkgYSB2ZWN0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWNEaXZpZGU8VCBleHRlbmRzIG51bWJlcltdPiggdmVjQTogVCwgdmVjQjogVCApOiBUIHtcbiAgcmV0dXJuIHZlY0EubWFwKCAoIHYsIGkgKSA9PiB2IC8gdmVjQlsgaSBdICkgYXMgVDtcbn1cbiIsIi8qKlxuICogUmV0dXJuIGFuIGV1Y2xpZGVhbiBsZW5ndGggb2YgZ2l2ZW4gdmVjdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVjTGVuZ3RoPFQgZXh0ZW5kcyBudW1iZXJbXT4oIHZlYzogVCApOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5zcXJ0KCB2ZWMucmVkdWNlKCAoIHN1bSwgdiApID0+IHN1bSArIHYgKiB2LCAwLjAgKSApO1xufVxuIiwiLyoqXG4gKiBSZXR1cm4gYW4gc3F1YXJlZCBldWNsaWRlYW4gbGVuZ3RoIG9mIGdpdmVuIHZlY3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlY0xlbmd0aFNxPFQgZXh0ZW5kcyBudW1iZXJbXT4oIHZlYzogVCApOiBudW1iZXIge1xuICByZXR1cm4gdmVjLnJlZHVjZSggKCBzdW0sIHYgKSA9PiBzdW0gKyB2ICogdiwgMC4wICk7XG59XG4iLCIvKipcbiAqIFJldHVybiBhIG1hbmhhdHRhbiBsZW5ndGggb2YgZ2l2ZW4gdmVjdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVjTWFuaGF0dGFuTGVuZ3RoPFQgZXh0ZW5kcyBudW1iZXJbXT4oIHZlYzogVCApOiBudW1iZXIge1xuICByZXR1cm4gdmVjLnJlZHVjZSggKCBzdW0sIHYgKSA9PiBzdW0gKyBNYXRoLmFicyggdiApLCAwLjAgKTtcbn1cbiIsIi8qKlxuICogUmV0dXJuIGEgcHJvZHVjdCBvZiB2ZWN0b3JzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVjTXVsdGlwbHk8VCBleHRlbmRzIG51bWJlcltdPiggLi4udmVjczogVFtdICk6IFQge1xuICBpZiAoIHZlY3MubGVuZ3RoIDwgMiApIHtcbiAgICByZXR1cm4gdmVjc1sgMCBdO1xuICB9XG5cbiAgY29uc3QgYSA9IHZlY3Muc2hpZnQoKSE7XG4gIGNvbnN0IGIgPSB2ZWNNdWx0aXBseSggLi4udmVjcyApO1xuXG4gIHJldHVybiBhLm1hcCggKCB2LCBpICkgPT4gdiAqIGJbIGkgXSApIGFzIFQ7XG59XG4iLCIvKipcbiAqIE5lZ2F0ZSBhIHZlY3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlY05lZzxUIGV4dGVuZHMgbnVtYmVyW10+KCB2ZWM6IFQgKTogVCB7XG4gIHJldHVybiB2ZWMubWFwKCAoIHYgKSA9PiAtdiApIGFzIFQ7XG59XG4iLCIvKipcbiAqIFNjYWxlIHRoZSBnaXZlbiB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWNTY2FsZTxUIGV4dGVuZHMgbnVtYmVyW10+KCB2ZWM6IFQsIHNjYWxhcjogbnVtYmVyICk6IFQge1xuICByZXR1cm4gdmVjLm1hcCggKCB2ICkgPT4gdiAqIHNjYWxhciApIGFzIFQ7XG59XG4iLCJpbXBvcnQgeyB2ZWNMZW5ndGggfSBmcm9tICcuL3ZlY0xlbmd0aCc7XG5pbXBvcnQgeyB2ZWNTY2FsZSB9IGZyb20gJy4vdmVjU2NhbGUnO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBnaXZlbiB2ZWN0b3IuXG4gKiBJZiB0aGUgbGVuZ3RoIG9mIGdpdmVuIHZlY3RvciBpcyAwLjAsIGl0IHdpbGwgcmV0dXJuIGEgemVybyB2ZWN0b3IgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlY05vcm1hbGl6ZTxUIGV4dGVuZHMgbnVtYmVyW10+KCB2ZWM6IFQgKTogVCB7XG4gIGNvbnN0IGxlbiA9IHZlY0xlbmd0aCggdmVjICk7XG4gIGNvbnN0IGludkxlbiA9IGxlbiA9PT0gMC4wID8gMC4wIDogMS4wIC8gbGVuO1xuICByZXR1cm4gdmVjU2NhbGUoIHZlYywgaW52TGVuICk7XG59XG4iLCIvKipcbiAqIFN1YnRyYWN0IGEgdmVjdG9yIGZyb20gYSB2ZWN0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWNTdWI8VCBleHRlbmRzIG51bWJlcltdPiggdmVjQTogVCwgdmVjQjogVCApOiBUIHtcbiAgcmV0dXJuIHZlY0EubWFwKCAoIHYsIGkgKSA9PiB2IC0gdmVjQlsgaSBdICkgYXMgVDtcbn1cbiIsImltcG9ydCB7IHZlY0FicyB9IGZyb20gJy4vdmVjQWJzJztcbmltcG9ydCB7IHZlY0FkZCB9IGZyb20gJy4vdmVjQWRkJztcbmltcG9ydCB7IHZlY0RpdmlkZSB9IGZyb20gJy4vdmVjRGl2aWRlJztcbmltcG9ydCB7IHZlY0RvdCB9IGZyb20gJy4vdmVjRG90JztcbmltcG9ydCB7IHZlY0xlbmd0aCB9IGZyb20gJy4vdmVjTGVuZ3RoJztcbmltcG9ydCB7IHZlY0xlbmd0aFNxIH0gZnJvbSAnLi92ZWNMZW5ndGhTcSc7XG5pbXBvcnQgeyB2ZWNNYW5oYXR0YW5MZW5ndGggfSBmcm9tICcuL3ZlY01hbmhhdHRhbkxlbmd0aCc7XG5pbXBvcnQgeyB2ZWNNdWx0aXBseSB9IGZyb20gJy4vdmVjTXVsdGlwbHknO1xuaW1wb3J0IHsgdmVjTmVnIH0gZnJvbSAnLi92ZWNOZWcnO1xuaW1wb3J0IHsgdmVjTm9ybWFsaXplIH0gZnJvbSAnLi92ZWNOb3JtYWxpemUnO1xuaW1wb3J0IHsgdmVjU2NhbGUgfSBmcm9tICcuL3ZlY1NjYWxlJztcbmltcG9ydCB7IHZlY1N1YiB9IGZyb20gJy4vdmVjU3ViJztcblxuLyoqXG4gKiBBIFZlY3Rvci5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFZlY3RvcjxUIGV4dGVuZHMgVmVjdG9yPFQ+PiB7XG4gIHB1YmxpYyBhYnN0cmFjdCBlbGVtZW50czogbnVtYmVyW107XG5cbiAgLyoqXG4gICAqIFRoZSBsZW5ndGggb2YgdGhpcy5cbiAgICogYS5rLmEuIGBtYWduaXR1ZGVgXG4gICAqL1xuICBwdWJsaWMgZ2V0IGxlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB2ZWNMZW5ndGgoIHRoaXMuZWxlbWVudHMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3F1YXJlZCBsZW5ndGggb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgbGVuZ3RoU3EoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdmVjTGVuZ3RoU3EoIHRoaXMuZWxlbWVudHMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWFuaGF0dGFuIGxlbmd0aCBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCBtYW5oYXR0YW5MZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdmVjTWFuaGF0dGFuTGVuZ3RoKCB0aGlzLmVsZW1lbnRzICk7XG4gIH1cblxuICAvKipcbiAgICogQSBub3JtYWxpemVkIFZlY3RvcjMgb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgbm9ybWFsaXplZCgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fX25ldyggdmVjTm9ybWFsaXplKCB0aGlzLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGJ1dCBuZWdhdGVkLlxuICAgKi9cbiAgcHVibGljIGdldCBuZWdhdGVkKCk6IFQge1xuICAgIHJldHVybiB0aGlzLl9fbmV3KCB2ZWNOZWcoIHRoaXMuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgYnV0IGVhY2ggY29tcG9uZW50IGlzIHRoZSBhYnNvbHV0ZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgYWJzKCk6IFQge1xuICAgIHJldHVybiB0aGlzLl9fbmV3KCB2ZWNBYnMoIHRoaXMuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgY2xvbmUoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuX19uZXcoIHRoaXMuZWxlbWVudHMuY29uY2F0KCkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb25lIG9yIG1vcmUgVmVjdG9yIGludG8gdGhpcy5cbiAgICogQHBhcmFtIHZlY3RvcnMgT3RoZXIgVmVjdG9yc1xuICAgKi9cbiAgcHVibGljIGFkZCggLi4udmVjdG9yczogVFtdICk6IFQge1xuICAgIHJldHVybiB0aGlzLl9fbmV3KCB2ZWNBZGQoIHRoaXMuZWxlbWVudHMsIC4uLnZlY3RvcnMubWFwKCAoIHYgKSA9PiB2LmVsZW1lbnRzICkgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnN0cmFjdCB0aGlzIGZyb20gYW5vdGhlciBWZWN0b3IuXG4gICAqIEBwYXJhbSB2IEFub3RoZXIgdmVjdG9yXG4gICAqL1xuICBwdWJsaWMgc3ViKCB2ZWN0b3I6IFQgKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuX19uZXcoIHZlY1N1YiggdGhpcy5lbGVtZW50cywgdmVjdG9yLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSBvbmUgb3IgbW9yZSBWZWN0b3Igd2l0aCB0aGlzLlxuICAgKiBAcGFyYW0gdmVjdG9ycyBPdGhlciBWZWN0b3JzXG4gICAqL1xuICBwdWJsaWMgbXVsdGlwbHkoIC4uLnZlY3RvcnM6IFRbXSApOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fX25ldyggdmVjTXVsdGlwbHkoIHRoaXMuZWxlbWVudHMsIC4uLnZlY3RvcnMubWFwKCAoIHYgKSA9PiB2LmVsZW1lbnRzICkgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIERpdmlkZSB0aGlzIGZyb20gYW5vdGhlciBWZWN0b3IuXG4gICAqIEBwYXJhbSB2ZWN0b3IgQW5vdGhlciBWZWN0b3JcbiAgICovXG4gIHB1YmxpYyBkaXZpZGUoIHZlY3RvcjogVCApOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fX25ldyggdmVjRGl2aWRlKCB0aGlzLmVsZW1lbnRzLCB2ZWN0b3IuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxlIHRoaXMgYnkgc2NhbGFyLlxuICAgKiBhLmsuYS4gYG11bHRpcGx5U2NhbGFyYFxuICAgKiBAcGFyYW0gc2NhbGFyIEEgc2NhbGFyXG4gICAqL1xuICBwdWJsaWMgc2NhbGUoIHNjYWxhcjogbnVtYmVyICk6IFQge1xuICAgIHJldHVybiB0aGlzLl9fbmV3KCB2ZWNTY2FsZSggdGhpcy5lbGVtZW50cywgc2NhbGFyICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEb3QgdHdvIFZlY3RvcnMuXG4gICAqIEBwYXJhbSB2ZWN0b3IgQW5vdGhlciB2ZWN0b3JcbiAgICovXG4gIHB1YmxpYyBkb3QoIHZlY3RvcjogVCApOiBudW1iZXIge1xuICAgIHJldHVybiB2ZWNEb3QoIHRoaXMuZWxlbWVudHMsIHZlY3Rvci5lbGVtZW50cyApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF9fbmV3KCB2OiBudW1iZXJbXSApOiBUO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NCc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjQgfSBmcm9tICcuL1Jhd1ZlY3RvcjQnO1xuXG4vKipcbiAqIE11bHRpcGx5IGEgdmVjNCBieSBhIG1hdDQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWM0QXBwbHlNYXRyaXg0KCB2OiBSYXdWZWN0b3I0LCBtOiBSYXdNYXRyaXg0ICk6IFJhd1ZlY3RvcjQge1xuICByZXR1cm4gW1xuICAgIG1bIDAgXSAqIHZbIDAgXSArIG1bIDQgXSAqIHZbIDEgXSArIG1bIDggXSAqIHZbIDIgXSArIG1bIDEyIF0gKiB2WyAzIF0sXG4gICAgbVsgMSBdICogdlsgMCBdICsgbVsgNSBdICogdlsgMSBdICsgbVsgOSBdICogdlsgMiBdICsgbVsgMTMgXSAqIHZbIDMgXSxcbiAgICBtWyAyIF0gKiB2WyAwIF0gKyBtWyA2IF0gKiB2WyAxIF0gKyBtWyAxMCBdICogdlsgMiBdICsgbVsgMTQgXSAqIHZbIDMgXSxcbiAgICBtWyAzIF0gKiB2WyAwIF0gKyBtWyA3IF0gKiB2WyAxIF0gKyBtWyAxMSBdICogdlsgMiBdICsgbVsgMTUgXSAqIHZbIDMgXSxcbiAgXTtcbn1cbiIsImltcG9ydCB7IHZlYzRBcHBseU1hdHJpeDQgfSBmcm9tICcuLi92ZWM0L3ZlYzRBcHBseU1hdHJpeDQnO1xuaW1wb3J0IHsgdmVjU2NhbGUgfSBmcm9tICcuLi92ZWMvdmVjU2NhbGUnO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NC9SYXdNYXRyaXg0JztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4vUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogQXBwbHkgYSB2ZWMzICh3aXRoIGFuIGltcGxpY2l0IDEgaW4gdGhlIDR0aCBkaW1lbnNpb24pIGEgbWF0NC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlYzNBcHBseU1hdHJpeDQoIHY6IFJhd1ZlY3RvcjMsIG06IFJhd01hdHJpeDQgKTogUmF3VmVjdG9yMyB7XG4gIGNvbnN0IHZlYzQgPSB2ZWM0QXBwbHlNYXRyaXg0KCBbIC4uLnYsIDEgXSwgbSApO1xuICBjb25zdCB4eXo6IFJhd1ZlY3RvcjMgPSBbIHZlYzRbIDAgXSwgdmVjNFsgMSBdLCB2ZWM0WyAyIF0gXTtcbiAgY29uc3QgdyA9IHZlYzRbIDMgXTtcbiAgcmV0dXJuIHZlY1NjYWxlKCB4eXosIDEuMCAvIHcgKTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4vUmF3UXVhdGVybmlvbic7XG5cbi8qKlxuICogUmV0dXJuIGFuIGludmVyc2Ugb2YgYSBxdWF0ZXJuaW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhdEludmVyc2UoIHF1YXQ6IFJhd1F1YXRlcm5pb24gKTogUmF3UXVhdGVybmlvbiB7XG4gIHJldHVybiBbIC1xdWF0WyAwIF0sIC1xdWF0WyAxIF0sIC1xdWF0WyAyIF0sIHF1YXRbIDMgXSBdO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi9SYXdRdWF0ZXJuaW9uJztcblxuLyoqXG4gKiBSZXR1cm4gYSBtdWx0aXBsaWNhdGlvbiByZXN1bHQgb2YgcXVhdGVybmlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWF0TXVsdGlwbHkoIC4uLnF1YXRzOiBSYXdRdWF0ZXJuaW9uW10gKTogUmF3UXVhdGVybmlvbiB7XG4gIGlmICggcXVhdHMubGVuZ3RoIDwgMiApIHtcbiAgICByZXR1cm4gcXVhdHNbIDAgXTtcbiAgfVxuXG4gIGNvbnN0IGEgPSBxdWF0cy5zaGlmdCgpITtcbiAgY29uc3QgYiA9IHF1YXRNdWx0aXBseSggLi4ucXVhdHMgKTtcblxuICByZXR1cm4gW1xuICAgIGFbIDMgXSAqIGJbIDAgXSArIGFbIDAgXSAqIGJbIDMgXSArIGFbIDEgXSAqIGJbIDIgXSAtIGFbIDIgXSAqIGJbIDEgXSxcbiAgICBhWyAzIF0gKiBiWyAxIF0gLSBhWyAwIF0gKiBiWyAyIF0gKyBhWyAxIF0gKiBiWyAzIF0gKyBhWyAyIF0gKiBiWyAwIF0sXG4gICAgYVsgMyBdICogYlsgMiBdICsgYVsgMCBdICogYlsgMSBdIC0gYVsgMSBdICogYlsgMCBdICsgYVsgMiBdICogYlsgMyBdLFxuICAgIGFbIDMgXSAqIGJbIDMgXSAtIGFbIDAgXSAqIGJbIDAgXSAtIGFbIDEgXSAqIGJbIDEgXSAtIGFbIDIgXSAqIGJbIDIgXSxcbiAgXTtcbn1cbiIsImltcG9ydCB7IHF1YXRJbnZlcnNlIH0gZnJvbSAnLi4vcXVhdC9xdWF0SW52ZXJzZSc7XG5pbXBvcnQgeyBxdWF0TXVsdGlwbHkgfSBmcm9tICcuLi9xdWF0L3F1YXRNdWx0aXBseSc7XG5pbXBvcnQgdHlwZSB7IFJhd1F1YXRlcm5pb24gfSBmcm9tICcuLi9xdWF0L1Jhd1F1YXRlcm5pb24nO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBBcHBseSBhIHZlYzMgKHdpdGggYW4gaW1wbGljaXQgMSBpbiB0aGUgNHRoIGRpbWVuc2lvbikgYSBxdWF0ZXJuaW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVjM0FwcGx5UXVhdGVybmlvbiggdmVjOiBSYXdWZWN0b3IzLCBxdWF0OiBSYXdRdWF0ZXJuaW9uICk6IFJhd1ZlY3RvcjMge1xuICBjb25zdCBwOiBSYXdRdWF0ZXJuaW9uID0gWyAuLi52ZWMsIDAuMCBdO1xuICBjb25zdCByID0gcXVhdEludmVyc2UoIHF1YXQgKTtcbiAgY29uc3QgcmVzID0gcXVhdE11bHRpcGx5KCBxdWF0LCBwLCByICk7XG4gIHJlcy5wb3AoKTtcbiAgcmV0dXJuIHJlcyBhcyB1bmtub3duIGFzIFJhd1ZlY3RvcjM7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFJldHVybiBhIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVjM0Nyb3NzKCB2ZWNBOiBSYXdWZWN0b3IzLCB2ZWNCOiBSYXdWZWN0b3IzICk6IFJhd1ZlY3RvcjMge1xuICByZXR1cm4gW1xuICAgIHZlY0FbIDEgXSAqIHZlY0JbIDIgXSAtIHZlY0FbIDIgXSAqIHZlY0JbIDEgXSxcbiAgICB2ZWNBWyAyIF0gKiB2ZWNCWyAwIF0gLSB2ZWNBWyAwIF0gKiB2ZWNCWyAyIF0sXG4gICAgdmVjQVsgMCBdICogdmVjQlsgMSBdIC0gdmVjQVsgMSBdICogdmVjQlsgMCBdLFxuICBdO1xufVxuIiwiaW1wb3J0IHsgdmVjM0Nyb3NzIH0gZnJvbSAnLi92ZWMzQ3Jvc3MnO1xuaW1wb3J0IHsgdmVjRG90IH0gZnJvbSAnLi4vdmVjL3ZlY0RvdCc7XG5pbXBvcnQgeyB2ZWNOZWcgfSBmcm9tICcuLi92ZWMvdmVjTmVnJztcbmltcG9ydCB7IHZlY05vcm1hbGl6ZSB9IGZyb20gJy4uL3ZlYy92ZWNOb3JtYWxpemUnO1xuaW1wb3J0IHsgdmVjU2NhbGUgfSBmcm9tICcuLi92ZWMvdmVjU2NhbGUnO1xuaW1wb3J0IHsgdmVjU3ViIH0gZnJvbSAnLi4vdmVjL3ZlY1N1Yic7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFJldHVybiBhIHRhbmdlbnQgd2hpY2ggaXMgb3J0aG9nb25hbCB0byBub3JtYWwuXG4gKiBJZiBiaW5vcm1hbCBpcyBzcGVjaWZpZWQsIGl0IGlzIGFsc28gcmV0dXJuZWQgYW5kIGl0J3Mgb3J0aG9nb25hbCB0byBib3RoIG5vcm1hbCBhbmQgdGFuZ2VudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlYzNPcnRob05vcm1hbGl6ZShcbiAgbm9ybWFsOiBSYXdWZWN0b3IzLFxuICB0YW5nZW50OiBSYXdWZWN0b3IzID0gWyAwLjAsIDEuMCwgMC4wIF0sXG4gIGJpbm9ybWFsPzogUmF3VmVjdG9yMyxcbik6IHtcbiAgICBub3JtYWw6IFJhd1ZlY3RvcjMsXG4gICAgdGFuZ2VudDogUmF3VmVjdG9yMyxcbiAgICBiaW5vcm1hbDogUmF3VmVjdG9yMyxcbiAgfSB7XG4gIGNvbnN0IG4gPSB2ZWNOb3JtYWxpemUoIG5vcm1hbCApO1xuICBsZXQgdCA9IHZlY05vcm1hbGl6ZSggdGFuZ2VudCApO1xuXG4gIGxldCBkb3ROVCA9IHZlY0RvdCggbiwgdCApO1xuXG4gIGlmICggZG90TlQgPT09IDEuMCApIHtcbiAgICBpZiAoIE1hdGguYWJzKCBuWyAxIF0gKSA+IE1hdGguYWJzKCBuWyAyIF0gKSApIHtcbiAgICAgIHQgPSBbIDAuMCwgMC4wLCAxLjAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdCA9IFsgMC4wLCAxLjAsIDAuMCBdO1xuICAgIH1cbiAgICBkb3ROVCA9IHZlY0RvdCggbiwgdCApO1xuICB9XG5cbiAgdCA9IHZlY05vcm1hbGl6ZSggdmVjU3ViKCB0LCB2ZWNTY2FsZSggbiwgZG90TlQgKSApICk7XG5cbiAgbGV0IGIgPSB2ZWMzQ3Jvc3MoIHQsIG4gKTtcbiAgaWYgKCBiaW5vcm1hbCAmJiB2ZWNEb3QoIGIsIGJpbm9ybWFsICkgPCAwLjAgKSB7XG4gICAgYiA9IHZlY05lZyggYiApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub3JtYWw6IG4sXG4gICAgdGFuZ2VudDogdCxcbiAgICBiaW5vcm1hbDogYixcbiAgfTtcbn1cbiIsImltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L01hdHJpeDQnO1xuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4uL3F1YXQvUXVhdGVybmlvbic7XG5pbXBvcnQgeyBWZWN0b3IgfSBmcm9tICcuLi92ZWMvVmVjdG9yJztcbmltcG9ydCB7IHZlYzNBcHBseU1hdHJpeDQgfSBmcm9tICcuL3ZlYzNBcHBseU1hdHJpeDQnO1xuaW1wb3J0IHsgdmVjM0FwcGx5UXVhdGVybmlvbiB9IGZyb20gJy4vdmVjM0FwcGx5UXVhdGVybmlvbic7XG5pbXBvcnQgeyB2ZWMzQ3Jvc3MgfSBmcm9tICcuL3ZlYzNDcm9zcyc7XG5pbXBvcnQgeyB2ZWMzT3J0aG9Ob3JtYWxpemUgfSBmcm9tICcuL3ZlYzNPcnRob05vcm1hbGl6ZSc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIEEgVmVjdG9yMy5cbiAqL1xuZXhwb3J0IGNsYXNzIFZlY3RvcjMgZXh0ZW5kcyBWZWN0b3I8VmVjdG9yMz4ge1xuICBwdWJsaWMgZWxlbWVudHM6IFJhd1ZlY3RvcjM7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCB2OiBSYXdWZWN0b3IzID0gWyAwLjAsIDAuMCwgMC4wIF0gKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gdjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiB4IGNvbXBvbmVudCBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCB4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbIDAgXTtcbiAgfVxuXG4gIHB1YmxpYyBzZXQgeCggeDogbnVtYmVyICkge1xuICAgIHRoaXMuZWxlbWVudHNbIDAgXSA9IHg7XG4gIH1cblxuICAvKipcbiAgICogQW4geSBjb21wb25lbnQgb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgeSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzWyAxIF07XG4gIH1cblxuICBwdWJsaWMgc2V0IHkoIHk6IG51bWJlciApIHtcbiAgICB0aGlzLmVsZW1lbnRzWyAxIF0gPSB5O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIHogY29tcG9uZW50IG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHooKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c1sgMiBdO1xuICB9XG5cbiAgcHVibGljIHNldCB6KCB6OiBudW1iZXIgKSB7XG4gICAgdGhpcy5lbGVtZW50c1sgMiBdID0gejtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgVmVjdG9yMyggJHsgdGhpcy54LnRvRml4ZWQoIDMgKSB9LCAkeyB0aGlzLnkudG9GaXhlZCggMyApIH0sICR7IHRoaXMuei50b0ZpeGVkKCAzICkgfSApYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjcm9zcyBvZiB0aGlzIGFuZCBhbm90aGVyIFZlY3RvcjMuXG4gICAqIEBwYXJhbSB2ZWN0b3IgQW5vdGhlciB2ZWN0b3JcbiAgICovXG4gIHB1YmxpYyBjcm9zcyggdmVjdG9yOiBWZWN0b3IzICk6IFZlY3RvcjMge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyggdmVjM0Nyb3NzKCB0aGlzLmVsZW1lbnRzLCB2ZWN0b3IuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGlzIHZlY3RvciB1c2luZyBhIFF1YXRlcm5pb24uXG4gICAqIEBwYXJhbSBxdWF0ZXJuaW9uIEEgcXVhdGVybmlvblxuICAgKi9cbiAgcHVibGljIGFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbjogUXVhdGVybmlvbiApOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoIHZlYzNBcHBseVF1YXRlcm5pb24oIHRoaXMuZWxlbWVudHMsIHF1YXRlcm5pb24uZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoaXMgdmVjdG9yICh3aXRoIGFuIGltcGxpY2l0IDEgaW4gdGhlIDR0aCBkaW1lbnNpb24pIGJ5IG0uXG4gICAqL1xuICBwdWJsaWMgYXBwbHlNYXRyaXg0KCBtYXRyaXg6IE1hdHJpeDQgKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCB2ZWMzQXBwbHlNYXRyaXg0KCB0aGlzLmVsZW1lbnRzLCBtYXRyaXguZWxlbWVudHMgKSApO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9fbmV3KCB2OiBSYXdWZWN0b3IzICk6IFZlY3RvcjMge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyggdiApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlY3RvcjMoIDAuMCwgMC4wLCAwLjAgKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgemVybygpOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoIFsgMC4wLCAwLjAsIDAuMCBdICk7XG4gIH1cblxuICAvKipcbiAgICogVmVjdG9yMyggMS4wLCAwLjAsIDAuMCApXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCBweCgpOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoIFsgMS4wLCAwLjAsIDAuMCBdICk7XG4gIH1cblxuICAvKipcbiAgICogVmVjdG9yMyggLTEuMCwgMC4wLCAwLjAgKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgbngoKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCBbIC0xLjAsIDAuMCwgMC4wIF0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZWN0b3IzKCAwLjAsIDEuMCwgMC4wIClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IHB5KCk6IFZlY3RvcjMge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyggWyAwLjAsIDEuMCwgMC4wIF0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZWN0b3IzKCAwLjAsIC0xLjAsIDAuMCApXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCBueSgpOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoIFsgMC4wLCAtMS4wLCAwLjAgXSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlY3RvcjMoIDAuMCwgMC4wLCAxLjAgKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgcHooKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCBbIDAuMCwgMC4wLCAxLjAgXSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlY3RvcjMoIDAuMCwgMC4wLCAtMS4wIClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IG56KCk6IFZlY3RvcjMge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyggWyAwLjAsIDAuMCwgLTEuMCBdICk7XG4gIH1cblxuICAvKipcbiAgICogVmVjdG9yMyggMS4wLCAxLjAsIDEuMCApXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCBvbmUoKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCBbIDEuMCwgMS4wLCAxLjAgXSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHRhbmdlbnQgd2hpY2ggaXMgb3J0aG9nb25hbCB0byBub3JtYWwuXG4gICAqIElmIGJpbm9ybWFsIGlzIHNwZWNpZmllZCwgaXQgaXMgYWxzbyByZXR1cm5lZCBhbmQgaXQncyBvcnRob2dvbmFsIHRvIGJvdGggbm9ybWFsIGFuZCB0YW5nZW50LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBvcnRob05vcm1hbGl6ZSggbm9ybWFsOiBWZWN0b3IzLCB0YW5nZW50OiBWZWN0b3IzLCBiaW5vcm1hbDogVmVjdG9yMyApOiB7XG4gICAgbm9ybWFsOiBWZWN0b3IzLFxuICAgIHRhbmdlbnQ6IFZlY3RvcjMsXG4gICAgYmlub3JtYWw6IFZlY3RvcjMsXG4gIH0ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZlYzNPcnRob05vcm1hbGl6ZSggbm9ybWFsLmVsZW1lbnRzLCB0YW5nZW50LmVsZW1lbnRzLCBiaW5vcm1hbC5lbGVtZW50cyApO1xuICAgIHJldHVybiB7XG4gICAgICBub3JtYWw6IG5ldyBWZWN0b3IzKCByZXN1bHQubm9ybWFsICksXG4gICAgICB0YW5nZW50OiBuZXcgVmVjdG9yMyggcmVzdWx0LnRhbmdlbnQgKSxcbiAgICAgIGJpbm9ybWFsOiBuZXcgVmVjdG9yMyggcmVzdWx0LmJpbm9ybWFsICksXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdCb3gzIH0gZnJvbSAnLi9SYXdCb3gzJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogVGVzdCBpZiBnaXZlbiBwb2ludCBpcyBjb250YWluZWQgaW4gZ2l2ZW4gYm94IG9yIG5vdC5cbiAqIEBwYXJhbSBib3ggQSBib3hcbiAqIEBwYXJhbSBwb2ludCBBIHBvaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3gzQ29udGFpbnNQb2ludCggYm94OiBSYXdCb3gzLCBwb2ludDogUmF3VmVjdG9yMyApOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBib3hbIDAgXVsgMCBdIDw9IHBvaW50WyAwIF0gJiZcbiAgICBib3hbIDEgXVsgMCBdID49IHBvaW50WyAwIF0gJiZcbiAgICBib3hbIDAgXVsgMSBdIDw9IHBvaW50WyAxIF0gJiZcbiAgICBib3hbIDEgXVsgMSBdID49IHBvaW50WyAxIF0gJiZcbiAgICBib3hbIDAgXVsgMiBdIDw9IHBvaW50WyAyIF0gJiZcbiAgICBib3hbIDEgXVsgMiBdID49IHBvaW50WyAyIF1cbiAgKTtcbn1cbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1ZlY3RvcjMnO1xuaW1wb3J0IHsgYm94M0NvbnRhaW5zUG9pbnQgfSBmcm9tICcuL2JveDNDb250YWluc1BvaW50JztcbmltcG9ydCB0eXBlIHsgUmF3Qm94MyB9IGZyb20gJy4vUmF3Qm94Myc7XG5cbi8qKlxuICogQSAzRCBib3guXG4gKi9cbmV4cG9ydCBjbGFzcyBCb3gzIHtcbiAgcHVibGljIG1pbjogVmVjdG9yMztcbiAgcHVibGljIG1heDogVmVjdG9yMztcblxuICBwdWJsaWMgY29uc3RydWN0b3IoIG1pbjogVmVjdG9yMyA9IFZlY3RvcjMuemVybywgbWF4OiBWZWN0b3IzID0gVmVjdG9yMy56ZXJvICkge1xuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0c2VsZiBidXQge0BsaW5rIFJhd0JveDN9IGZvcm0uXG4gICAqL1xuICBwdWJsaWMgZ2V0IHJhdygpOiBSYXdCb3gzIHtcbiAgICByZXR1cm4gWyB0aGlzLm1pbi5lbGVtZW50cywgdGhpcy5tYXguZWxlbWVudHMgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIGdpdmVuIHBvaW50IGlzIGNvbnRhaW5lZCBpbiB0aGUgYm94IG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHBvaW50IEEgcG9pbnRcbiAgICovXG4gIHB1YmxpYyBjb250YWluc1BvaW50KCBwb2ludDogVmVjdG9yMyApOiBib29sZWFuIHtcbiAgICByZXR1cm4gYm94M0NvbnRhaW5zUG9pbnQoIHRoaXMucmF3LCBwb2ludC5lbGVtZW50cyApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQge0BsaW5rIFJhd0JveDN9IHRvIGNsYXNzIGZvcm0uXG4gICAqIEBwYXJhbSBib3ggQSB7QGxpbmsgUmF3Qm94M31cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVJhdyggYm94OiBSYXdCb3gzICk6IEJveDMge1xuICAgIHJldHVybiBuZXcgQm94MyggbmV3IFZlY3RvcjMoIGJveFsgMCBdICksIG5ldyBWZWN0b3IzKCBib3hbIDEgXSApICk7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4vUmF3TWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L1Jhd01hdHJpeDQnO1xuXG4vKipcbiAqIFdobyBuZWVkcyB0aGlzP1xuICpcbiAqIEludGVuZGVkIHRvIGJlIHVzZWQgYnkge0BsaW5rIG1hdDNDcmVhdGVOb3JtYWxNYXRyaXh9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0M0Zyb21NYXQ0VHJhbnNwb3NlKFxuICBzb3VyY2U6IFJhd01hdHJpeDQsXG4pOiBSYXdNYXRyaXgzIHtcbiAgcmV0dXJuIFtcbiAgICBzb3VyY2VbIDAgXSwgc291cmNlWyA0IF0sIHNvdXJjZVsgOCBdLFxuICAgIHNvdXJjZVsgMSBdLCBzb3VyY2VbIDUgXSwgc291cmNlWyA5IF0sXG4gICAgc291cmNlWyAyIF0sIHNvdXJjZVsgNiBdLCBzb3VyY2VbIDEwIF0sXG4gIF07XG59XG4iLCJpbXBvcnQgeyB2ZWNTY2FsZSB9IGZyb20gJy4uL3ZlYy92ZWNTY2FsZSc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDMgfSBmcm9tICcuL1Jhd01hdHJpeDMnO1xuXG4vKipcbiAqIFJldHVybiBhbiBpbnZlcnNlIG9mIGdpdmVuIG1hdDMuXG4gKlxuICogWW9pbmtlZCBmcm9tIFRocmVlLmpzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQzSW52ZXJzZSggbTogUmF3TWF0cml4MyApOiBSYXdNYXRyaXgzIHtcbiAgY29uc3RcbiAgICBuMTEgPSBtWyAwIF0sIG4yMSA9IG1bIDEgXSwgbjMxID0gbVsgMiBdLFxuICAgIG4xMiA9IG1bIDMgXSwgbjIyID0gbVsgNCBdLCBuMzIgPSBtWyA1IF0sXG4gICAgbjEzID0gbVsgNiBdLCBuMjMgPSBtWyA3IF0sIG4zMyA9IG1bIDggXSxcbiAgICB0MTEgPSBuMzMgKiBuMjIgLSBuMzIgKiBuMjMsXG4gICAgdDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxuICAgIHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcbiAgICBkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTM7XG5cbiAgaWYgKCBkZXQgPT09IDAuMCApIHsgcmV0dXJuIHZlY1NjYWxlKCBtLCAwLjAgKTsgfVxuXG4gIHJldHVybiB2ZWNTY2FsZSggW1xuICAgIHQxMSxcbiAgICBuMzEgKiBuMjMgLSBuMzMgKiBuMjEsXG4gICAgbjMyICogbjIxIC0gbjMxICogbjIyLFxuICAgIHQxMixcbiAgICBuMzMgKiBuMTEgLSBuMzEgKiBuMTMsXG4gICAgbjMxICogbjEyIC0gbjMyICogbjExLFxuICAgIHQxMyxcbiAgICBuMjEgKiBuMTMgLSBuMjMgKiBuMTEsXG4gICAgbjIyICogbjExIC0gbjIxICogbjEyLFxuICBdLCAxLjAgLyBkZXQgKTtcbn1cbiIsImltcG9ydCB7IG1hdDNGcm9tTWF0NFRyYW5zcG9zZSB9IGZyb20gJy4vbWF0M0Zyb21NYXQ0VHJhbnNwb3NlJztcbmltcG9ydCB7IG1hdDNJbnZlcnNlIH0gZnJvbSAnLi9tYXQzSW52ZXJzZSc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDMgfSBmcm9tICcuL1Jhd01hdHJpeDMnO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NC9SYXdNYXRyaXg0JztcblxuLyoqXG4gKiBDcmVhdGUgYSBub3JtYWwgbWF0cml4IG91dCBvZiBhIG1hdHJpeDQuXG4gKlxuICogQHBhcmFtIG1hdHJpeCBBIG1hdHJpeDRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDNDcmVhdGVOb3JtYWxNYXRyaXgoIG06IFJhd01hdHJpeDQgKTogUmF3TWF0cml4MyB7XG4gIHJldHVybiBtYXQzSW52ZXJzZSggbWF0M0Zyb21NYXQ0VHJhbnNwb3NlKCBtICkgKTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4vUmF3TWF0cml4Myc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXQzRGV0ZXJtaW5hbnQoIG06IFJhd01hdHJpeDMgKTogbnVtYmVyIHtcbiAgY29uc3RcbiAgICBuMTEgPSBtWyAwIF0sIG4yMSA9IG1bIDEgXSwgbjMxID0gbVsgMiBdLFxuICAgIG4xMiA9IG1bIDMgXSwgbjIyID0gbVsgNCBdLCBuMzIgPSBtWyA1IF0sXG4gICAgbjEzID0gbVsgNiBdLCBuMjMgPSBtWyA3IF0sIG4zMyA9IG1bIDggXSxcbiAgICB0MTEgPSBuMzMgKiBuMjIgLSBuMzIgKiBuMjMsXG4gICAgdDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxuICAgIHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMztcblxuICByZXR1cm4gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXgzIH0gZnJvbSAnLi9SYXdNYXRyaXgzJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4uL21hdDQvUmF3TWF0cml4NCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgbWF0cml4MyBmcm9tIG1hdHJpeDQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQzRnJvbU1hdDQoXG4gIHNvdXJjZTogUmF3TWF0cml4NCxcbik6IFJhd01hdHJpeDMge1xuICByZXR1cm4gW1xuICAgIHNvdXJjZVsgMCBdLCBzb3VyY2VbIDEgXSwgc291cmNlWyAyIF0sXG4gICAgc291cmNlWyA0IF0sIHNvdXJjZVsgNSBdLCBzb3VyY2VbIDYgXSxcbiAgICBzb3VyY2VbIDggXSwgc291cmNlWyA5IF0sIHNvdXJjZVsgMTAgXSxcbiAgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4vUmF3TWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd1F1YXRlcm5pb24gfSBmcm9tICcuLi9xdWF0L1Jhd1F1YXRlcm5pb24nO1xuXG4vKipcbiAqIENvbnZlcnQgYSBxdWF0ZXJuaW9uIGludG8gYSBtYXRyaXgzLlxuICpcbiAqIFlvaW5rZWQgZnJvbSBUaHJlZS5qcy5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL21hdGgvTWF0cml4NC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0M0Zyb21RdWF0ZXJuaW9uKCBxdWF0OiBSYXdRdWF0ZXJuaW9uICk6IFJhd01hdHJpeDMge1xuICBjb25zdCB4ID0gcXVhdFsgMCBdO1xuICBjb25zdCB5ID0gcXVhdFsgMSBdO1xuICBjb25zdCB6ID0gcXVhdFsgMiBdO1xuICBjb25zdCB3ID0gcXVhdFsgMyBdO1xuXG4gIHJldHVybiBbXG4gICAgMS4wIC0gMi4wICogeSAqIHkgLSAyLjAgKiB6ICogeiwgMi4wICogeCAqIHkgKyAyLjAgKiB6ICogdywgMi4wICogeCAqIHogLSAyLjAgKiB5ICogdyxcbiAgICAyLjAgKiB4ICogeSAtIDIuMCAqIHogKiB3LCAxLjAgLSAyLjAgKiB4ICogeCAtIDIuMCAqIHogKiB6LCAyLjAgKiB5ICogeiArIDIuMCAqIHggKiB3LFxuICAgIDIuMCAqIHggKiB6ICsgMi4wICogeSAqIHcsIDIuMCAqIHkgKiB6IC0gMi4wICogeCAqIHcsIDEuMCAtIDIuMCAqIHggKiB4IC0gMi4wICogeSAqIHksXG4gIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDMgfSBmcm9tICcuL1Jhd01hdHJpeDMnO1xuXG4vKipcbiAqIFJldHVybiBhIG11bHRpcGxpY2F0aW9uIHJlc3VsdCBvZiBtYXRyaWNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDNNdWx0aXBseSggLi4ubWF0czogUmF3TWF0cml4M1tdICk6IFJhd01hdHJpeDMge1xuICBpZiAoIG1hdHMubGVuZ3RoIDwgMiApIHtcbiAgICByZXR1cm4gbWF0c1sgMCBdO1xuICB9XG5cbiAgY29uc3QgYSA9IG1hdHMuc2hpZnQoKSE7XG4gIGNvbnN0IGIgPSBtYXQzTXVsdGlwbHkoIC4uLm1hdHMgKTtcbiAgY29uc3RcbiAgICBhMDAgPSBhWyAwIF0sIGEwMSA9IGFbIDEgXSwgYTAyID0gYVsgMiBdLFxuICAgIGExMCA9IGFbIDMgXSwgYTExID0gYVsgNCBdLCBhMTIgPSBhWyA1IF0sXG4gICAgYTIwID0gYVsgNiBdLCBhMjEgPSBhWyA3IF0sIGEyMiA9IGFbIDggXSxcbiAgICBiMDAgPSBiWyAwIF0sIGIwMSA9IGJbIDEgXSwgYjAyID0gYlsgMiBdLFxuICAgIGIxMCA9IGJbIDMgXSwgYjExID0gYlsgNCBdLCBiMTIgPSBiWyA1IF0sXG4gICAgYjIwID0gYlsgNiBdLCBiMjEgPSBiWyA3IF0sIGIyMiA9IGJbIDggXTtcblxuICByZXR1cm4gW1xuICAgIGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMixcbiAgICBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDIsXG4gICAgYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyLFxuXG4gICAgYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyLFxuICAgIGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMixcbiAgICBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTIsXG5cbiAgICBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjIsXG4gICAgYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyLFxuICAgIGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMixcbiAgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4vUmF3TWF0cml4Myc7XG5cbi8qKlxuICogVHJhbnNwb3NlIGEgbWF0My5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDNUcmFuc3Bvc2UoXG4gIHNvdXJjZTogUmF3TWF0cml4Myxcbik6IFJhd01hdHJpeDMge1xuICByZXR1cm4gW1xuICAgIHNvdXJjZVsgMCBdLCBzb3VyY2VbIDMgXSwgc291cmNlWyA2IF0sXG4gICAgc291cmNlWyAxIF0sIHNvdXJjZVsgNCBdLCBzb3VyY2VbIDcgXSxcbiAgICBzb3VyY2VbIDIgXSwgc291cmNlWyA1IF0sIHNvdXJjZVsgOCBdLFxuICBdO1xufVxuIiwiaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdDQvTWF0cml4NCc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vcXVhdC9RdWF0ZXJuaW9uJztcbmltcG9ydCB7IG1hdDNDcmVhdGVOb3JtYWxNYXRyaXggfSBmcm9tICcuL21hdDNDcmVhdGVOb3JtYWxNYXRyaXgnO1xuaW1wb3J0IHsgbWF0M0RldGVybWluYW50IH0gZnJvbSAnLi9tYXQzRGV0ZXJtaW5hbnQnO1xuaW1wb3J0IHsgbWF0M0Zyb21NYXQ0IH0gZnJvbSAnLi9tYXQzRnJvbU1hdDQnO1xuaW1wb3J0IHsgbWF0M0Zyb21RdWF0ZXJuaW9uIH0gZnJvbSAnLi9tYXQzRnJvbVF1YXRlcm5pb24nO1xuaW1wb3J0IHsgbWF0M0ludmVyc2UgfSBmcm9tICcuL21hdDNJbnZlcnNlJztcbmltcG9ydCB7IG1hdDNNdWx0aXBseSB9IGZyb20gJy4vbWF0M011bHRpcGx5JztcbmltcG9ydCB7IG1hdDNUcmFuc3Bvc2UgfSBmcm9tICcuL21hdDNUcmFuc3Bvc2UnO1xuaW1wb3J0IHsgdmVjU2NhbGUgfSBmcm9tICcuLi92ZWMvdmVjU2NhbGUnO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXgzIH0gZnJvbSAnLi9SYXdNYXRyaXgzJztcblxuY29uc3QgcmF3SWRlbnRpdHlNYXRyaXgzOiBSYXdNYXRyaXgzID0gW1xuICAxLjAsIDAuMCwgMC4wLFxuICAwLjAsIDEuMCwgMC4wLFxuICAwLjAsIDAuMCwgMS4wLFxuXTtcblxuLyoqXG4gKiBBIE1hdHJpeDMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRyaXgzIHtcbiAgcHVibGljIGVsZW1lbnRzOiBSYXdNYXRyaXgzO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdjogUmF3TWF0cml4MyA9IHJhd0lkZW50aXR5TWF0cml4MyApIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gdjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IHRyYW5zcG9zZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRyYW5zcG9zZSgpOiBNYXRyaXgzIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDMoIG1hdDNUcmFuc3Bvc2UoIHRoaXMuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0cyBkZXRlcm1pbmFudC5cbiAgICovXG4gIHB1YmxpYyBnZXQgZGV0ZXJtaW5hbnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gbWF0M0RldGVybWluYW50KCB0aGlzLmVsZW1lbnRzICk7XG4gIH1cblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCBpbnZlcnRlZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaW52ZXJzZSgpOiBNYXRyaXgzIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDMoIG1hdDNJbnZlcnNlKCB0aGlzLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IG1hdHJpeDQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IG1hdHJpeDQoKTogTWF0cml4NCB7XG4gICAgcmV0dXJuIE1hdHJpeDQuZnJvbU1hdHJpeDMoIHRoaXMgKTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzLm1hcCggKCB2ICkgPT4gdi50b0ZpeGVkKCAzICkgKTtcbiAgICByZXR1cm4gYE1hdHJpeDMoICR7IG1bIDAgXSB9LCAkeyBtWyAzIF0gfSwgJHsgbVsgNiBdIH07ICR7IG1bIDEgXSB9LCAkeyBtWyA0IF0gfSwgJHsgbVsgNyBdIH07ICR7IG1bIDIgXSB9LCAkeyBtWyA1IF0gfSwgJHsgbVsgOCBdIH0gKWA7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBjbG9uZSgpOiBNYXRyaXgzIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDMoIHRoaXMuZWxlbWVudHMuY29uY2F0KCkgYXMgUmF3TWF0cml4MyApO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoaXMgTWF0cml4MyBieSBvbmUgb3IgbW9yZSBNYXRyaXgzcy5cbiAgICovXG4gIHB1YmxpYyBtdWx0aXBseSggLi4ubWF0cmljZXM6IE1hdHJpeDNbXSApOiBNYXRyaXgzIHtcbiAgICByZXR1cm4gTWF0cml4My5tdWx0aXBseSggdGhpcywgLi4ubWF0cmljZXMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGlzIE1hdHJpeDMgYnkgYSBzY2FsYXIuXG4gICAqL1xuICBwdWJsaWMgc2NhbGVTY2FsYXIoIHNjYWxhcjogbnVtYmVyICk6IE1hdHJpeDMge1xuICAgIHJldHVybiBuZXcgTWF0cml4MyggdmVjU2NhbGUoIHRoaXMuZWxlbWVudHMsIHNjYWxhciApICk7XG4gIH1cblxuICAvKipcbiAgICogQW4gaWRlbnRpdHkgTWF0cml4NC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IGlkZW50aXR5KCk6IE1hdHJpeDMge1xuICAgIHJldHVybiBuZXcgTWF0cml4MyggcmF3SWRlbnRpdHlNYXRyaXgzICk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgdHdvIG9yIG1vcmUgbWF0cmljZXMuXG4gICAqIEBwYXJhbSBtYXRyaWNlcyBNYXRyaWNlc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtdWx0aXBseSggLi4ubWF0cmljZXM6IE1hdHJpeDNbXSApOiBNYXRyaXgzIHtcbiAgICBpZiAoIG1hdHJpY2VzLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgIHJldHVybiBNYXRyaXgzLmlkZW50aXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeDMoIG1hdDNNdWx0aXBseSggLi4ubWF0cmljZXMubWFwKCAoIG0gKSA9PiBtLmVsZW1lbnRzICkgKSApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBub3JtYWwgbWF0cml4IG91dCBvZiBtYXRyaXg0LlxuICAgKiBAcGFyYW0gbWF0cml4NCBBIG1hdHJpeDRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlTm9ybWFsTWF0cml4KCBtYXRyaXg0OiBNYXRyaXg0ICk6IE1hdHJpeDMge1xuICAgIHJldHVybiBuZXcgTWF0cml4MyggbWF0M0NyZWF0ZU5vcm1hbE1hdHJpeCggbWF0cml4NC5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogQ2FzdCBhIHtAbGluayBNYXRyaXg0fSBpbnRvIGEgTWF0cml4My5cbiAgICogQHBhcmFtIG1hdHJpeDQgQSBtYXRyaXg0XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21NYXRyaXg0KCBtYXRyaXg0OiBNYXRyaXg0ICk6IE1hdHJpeDMge1xuICAgIHJldHVybiBuZXcgTWF0cml4MyggbWF0M0Zyb21NYXQ0KCBtYXRyaXg0LmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtYXRyaXggb3V0IG9mIGEge0BsaW5rIFF1YXRlcm5pb259LlxuICAgKiBAcGFyYW0gcXVhdGVybmlvbiBBIHF1YXRlcm5pb25cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb246IFF1YXRlcm5pb24gKTogTWF0cml4MyB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgzKCBtYXQzRnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24uZWxlbWVudHMgKSApO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuJztcbmltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4uL3F1YXQvUmF3UXVhdGVybmlvbic7XG5cbi8qKlxuICogQ29udmVydCBhIHF1YXRlcm5pb24gaW50byBhIG1hdHJpeDQuXG4gKlxuICogWW9pbmtlZCBmcm9tIFRocmVlLmpzLlxuICpcbiAqIFNlZTogaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZW4vbWF0aC9NYXRyaXg0Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQ0RnJvbVF1YXRlcm5pb24oIHF1YXQ6IFJhd1F1YXRlcm5pb24gKTogUmF3TWF0cml4NCB7XG4gIGNvbnN0IHggPSBxdWF0WyAwIF07XG4gIGNvbnN0IHkgPSBxdWF0WyAxIF07XG4gIGNvbnN0IHogPSBxdWF0WyAyIF07XG4gIGNvbnN0IHcgPSBxdWF0WyAzIF07XG5cbiAgcmV0dXJuIFtcbiAgICAxLjAgLSAyLjAgKiB5ICogeSAtIDIuMCAqIHogKiB6LCAyLjAgKiB4ICogeSArIDIuMCAqIHogKiB3LCAyLjAgKiB4ICogeiAtIDIuMCAqIHkgKiB3LCAwLjAsXG4gICAgMi4wICogeCAqIHkgLSAyLjAgKiB6ICogdywgMS4wIC0gMi4wICogeCAqIHggLSAyLjAgKiB6ICogeiwgMi4wICogeSAqIHogKyAyLjAgKiB4ICogdywgMC4wLFxuICAgIDIuMCAqIHggKiB6ICsgMi4wICogeSAqIHcsIDIuMCAqIHkgKiB6IC0gMi4wICogeCAqIHcsIDEuMCAtIDIuMCAqIHggKiB4IC0gMi4wICogeSAqIHksIDAuMCxcbiAgICAwLjAsIDAuMCwgMC4wLCAxLjAsXG4gIF07XG59XG4iLCJpbXBvcnQgeyBtYXQ0RnJvbVF1YXRlcm5pb24gfSBmcm9tICcuL21hdDRGcm9tUXVhdGVybmlvbic7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vcXVhdC9SYXdRdWF0ZXJuaW9uJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogQ29tcG9zZSBhIG1hdHJpeCBvdXQgb2YgcG9zaXRpb24sIHNjYWxlLCBhbmQgcm90YXRpb24uXG4gKiBZb2lua2VkIGZyb20gVGhyZWUuanMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQ0Q29tcG9zZShcbiAgcG9zaXRpb246IFJhd1ZlY3RvcjMsXG4gIHJvdGF0aW9uOiBSYXdRdWF0ZXJuaW9uLFxuICBzY2FsZTogUmF3VmVjdG9yMyxcbik6IFJhd01hdHJpeDQge1xuICBjb25zdCBtYXRSb3QgPSBtYXQ0RnJvbVF1YXRlcm5pb24oIHJvdGF0aW9uICk7XG5cbiAgY29uc3Qgc3ggPSBzY2FsZVsgMCBdLCBzeSA9IHNjYWxlWyAxIF0sIHN6ID0gc2NhbGVbIDIgXTtcblxuICByZXR1cm4gW1xuICAgIG1hdFJvdFsgMCBdICogc3gsXG4gICAgbWF0Um90WyAxIF0gKiBzeCxcbiAgICBtYXRSb3RbIDIgXSAqIHN4LFxuICAgIDAuMCxcblxuICAgIG1hdFJvdFsgNCBdICogc3ksXG4gICAgbWF0Um90WyA1IF0gKiBzeSxcbiAgICBtYXRSb3RbIDYgXSAqIHN5LFxuICAgIDAuMCxcblxuICAgIG1hdFJvdFsgOCBdICogc3osXG4gICAgbWF0Um90WyA5IF0gKiBzeixcbiAgICBtYXRSb3RbIDEwIF0gKiBzeixcbiAgICAwLjAsXG5cbiAgICBwb3NpdGlvblsgMCBdLFxuICAgIHBvc2l0aW9uWyAxIF0sXG4gICAgcG9zaXRpb25bIDIgXSxcbiAgICAxLjBcbiAgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5cbi8qKlxuICogUmV0dXJuIGEgZGV0ZXJtaW5hbnQgb2YgZ2l2ZW4gbWF0NC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDREZXRlcm1pbmFudCggbTogUmF3TWF0cml4NCApOiBudW1iZXIge1xuICBjb25zdFxuICAgIGEwMCA9IG1bICAwIF0sIGEwMSA9IG1bICAxIF0sIGEwMiA9IG1bICAyIF0sIGEwMyA9IG1bICAzIF0sXG4gICAgYTEwID0gbVsgIDQgXSwgYTExID0gbVsgIDUgXSwgYTEyID0gbVsgIDYgXSwgYTEzID0gbVsgIDcgXSxcbiAgICBhMjAgPSBtWyAgOCBdLCBhMjEgPSBtWyAgOSBdLCBhMjIgPSBtWyAxMCBdLCBhMjMgPSBtWyAxMSBdLFxuICAgIGEzMCA9IG1bIDEyIF0sIGEzMSA9IG1bIDEzIF0sIGEzMiA9IG1bIDE0IF0sIGEzMyA9IG1bIDE1IF0sXG4gICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLCAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCwgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLCAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCwgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4uL21hdDMvUmF3TWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd1F1YXRlcm5pb24gfSBmcm9tICcuL1Jhd1F1YXRlcm5pb24nO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgUXVhdGVybmlvbiBvdXQgb2YgYSByb3RhdGlvbiBtYXRyaXguXG4gKiBZb2lua2VkIGZyb20gVGhyZWUuanMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWF0RnJvbU1hdHJpeDMoIG06IFJhd01hdHJpeDMgKTogUmF3UXVhdGVybmlvbiB7XG4gIGNvbnN0IG0xMSA9IG1bIDAgXSwgbTEyID0gbVsgMyBdLCBtMTMgPSBtWyA2IF0sXG4gICAgbTIxID0gbVsgMSBdLCBtMjIgPSBtWyA0IF0sIG0yMyA9IG1bIDcgXSxcbiAgICBtMzEgPSBtWyAyIF0sIG0zMiA9IG1bIDUgXSwgbTMzID0gbVsgOCBdLFxuICAgIHRyYWNlID0gbTExICsgbTIyICsgbTMzO1xuXG4gIGlmICggdHJhY2UgPiAwICkge1xuICAgIGNvbnN0IHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG4gICAgcmV0dXJuIFtcbiAgICAgICggbTMyIC0gbTIzICkgKiBzLFxuICAgICAgKCBtMTMgLSBtMzEgKSAqIHMsXG4gICAgICAoIG0yMSAtIG0xMiApICogcyxcbiAgICAgIDAuMjUgLyBzXG4gICAgXTtcbiAgfSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcbiAgICBjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcbiAgICByZXR1cm4gW1xuICAgICAgMC4yNSAqIHMsXG4gICAgICAoIG0xMiArIG0yMSApIC8gcyxcbiAgICAgICggbTEzICsgbTMxICkgLyBzLFxuICAgICAgKCBtMzIgLSBtMjMgKSAvIHNcbiAgICBdO1xuICB9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG4gICAgY29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XG4gICAgcmV0dXJuIFtcbiAgICAgICggbTEyICsgbTIxICkgLyBzLFxuICAgICAgMC4yNSAqIHMsXG4gICAgICAoIG0yMyArIG0zMiApIC8gcyxcbiAgICAgICggbTEzIC0gbTMxICkgLyBzXG4gICAgXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcbiAgICByZXR1cm4gW1xuICAgICAgKCBtMTMgKyBtMzEgKSAvIHMsXG4gICAgICAoIG0yMyArIG0zMiApIC8gcyxcbiAgICAgIDAuMjUgKiBzLFxuICAgICAgKCBtMjEgLSBtMTIgKSAvIHNcbiAgICBdO1xuICB9XG59XG4iLCJpbXBvcnQgeyBtYXQzRnJvbU1hdDQgfSBmcm9tICcuLi9tYXQzL21hdDNGcm9tTWF0NCc7XG5pbXBvcnQgeyBxdWF0RnJvbU1hdHJpeDMgfSBmcm9tICcuL3F1YXRGcm9tTWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L1Jhd01hdHJpeDQnO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi9SYXdRdWF0ZXJuaW9uJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIFF1YXRlcm5pb24gb3V0IG9mIGEgcm90YXRpb24gbWF0cml4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhdEZyb21NYXRyaXg0KCBtOiBSYXdNYXRyaXg0ICk6IFJhd1F1YXRlcm5pb24ge1xuICByZXR1cm4gcXVhdEZyb21NYXRyaXgzKCBtYXQzRnJvbU1hdDQoIG0gKSApO1xufVxuIiwiaW1wb3J0IHsgbWF0NERldGVybWluYW50IH0gZnJvbSAnLi9tYXQ0RGV0ZXJtaW5hbnQnO1xuaW1wb3J0IHsgcXVhdEZyb21NYXRyaXg0IH0gZnJvbSAnLi4vcXVhdC9xdWF0RnJvbU1hdHJpeDQnO1xuaW1wb3J0IHsgdmVjTGVuZ3RoIH0gZnJvbSAnLi4vdmVjL3ZlY0xlbmd0aCc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vcXVhdC9SYXdRdWF0ZXJuaW9uJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogRGVjb21wb3NlIGEgbWF0cml4IGludG8gYSBwb3NpdGlvbiwgYSBzY2FsZSwgYW5kIGEgcm90YXRpb24uXG4gKiBZb2lua2VkIGZyb20gVGhyZWUuanMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQ0RGVjb21wb3NlKCBtOiBSYXdNYXRyaXg0ICk6IHtcbiAgcG9zaXRpb246IFJhd1ZlY3RvcjM7XG4gIHNjYWxlOiBSYXdWZWN0b3IzO1xuICByb3RhdGlvbjogUmF3UXVhdGVybmlvbjtcbn0ge1xuICBsZXQgc3ggPSB2ZWNMZW5ndGgoIFsgbVsgMCBdLCBtWyAxIF0sIG1bIDIgXSBdICk7XG4gIGNvbnN0IHN5ID0gdmVjTGVuZ3RoKCBbIG1bIDQgXSwgbVsgNSBdLCBtWyA2IF0gXSApO1xuICBjb25zdCBzeiA9IHZlY0xlbmd0aCggWyBtWyA4IF0sIG1bIDkgXSwgbVsgMTAgXSBdICk7XG5cbiAgLy8gaWYgZGV0ZXJtaW5hbnQgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuICBjb25zdCBkZXQgPSBtYXQ0RGV0ZXJtaW5hbnQoIG0gKTtcbiAgaWYgKCBkZXQgPCAwICkgeyBzeCA9IC1zeDsgfVxuXG4gIGNvbnN0IGludlN4ID0gMS4wIC8gc3g7XG4gIGNvbnN0IGludlN5ID0gMS4wIC8gc3k7XG4gIGNvbnN0IGludlN6ID0gMS4wIC8gc3o7XG5cbiAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBtLmNvbmNhdCgpIGFzIFJhd01hdHJpeDQ7XG5cbiAgcm90YXRpb25NYXRyaXhbIDAgXSAqPSBpbnZTeDtcbiAgcm90YXRpb25NYXRyaXhbIDEgXSAqPSBpbnZTeDtcbiAgcm90YXRpb25NYXRyaXhbIDIgXSAqPSBpbnZTeDtcblxuICByb3RhdGlvbk1hdHJpeFsgNCBdICo9IGludlN5O1xuICByb3RhdGlvbk1hdHJpeFsgNSBdICo9IGludlN5O1xuICByb3RhdGlvbk1hdHJpeFsgNiBdICo9IGludlN5O1xuXG4gIHJvdGF0aW9uTWF0cml4WyA4IF0gKj0gaW52U3o7XG4gIHJvdGF0aW9uTWF0cml4WyA5IF0gKj0gaW52U3o7XG4gIHJvdGF0aW9uTWF0cml4WyAxMCBdICo9IGludlN6O1xuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IFsgbVsgMTIgXSwgbVsgMTMgXSwgbVsgMTQgXSBdLFxuICAgIHNjYWxlOiBbIHN4LCBzeSwgc3ogXSxcbiAgICByb3RhdGlvbjogcXVhdEZyb21NYXRyaXg0KCByb3RhdGlvbk1hdHJpeCApLFxuICB9O1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXgzIH0gZnJvbSAnLi4vbWF0My9SYXdNYXRyaXgzJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgbWF0cml4NCBmcm9tIG1hdHJpeDMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQ0RnJvbU1hdDMoXG4gIHNvdXJjZTogUmF3TWF0cml4Myxcbik6IFJhd01hdHJpeDQge1xuICByZXR1cm4gW1xuICAgIHNvdXJjZVsgMCBdLCBzb3VyY2VbIDEgXSwgc291cmNlWyAyIF0sIDAuMCxcbiAgICBzb3VyY2VbIDMgXSwgc291cmNlWyA0IF0sIHNvdXJjZVsgNSBdLCAwLjAsXG4gICAgc291cmNlWyA2IF0sIHNvdXJjZVsgNyBdLCBzb3VyY2VbIDggXSwgMC4wLFxuICAgIDAuMCwgMC4wLCAwLjAsIDEuMCxcbiAgXTtcbn1cbiIsImltcG9ydCB7IHZlY1NjYWxlIH0gZnJvbSAnLi4vdmVjL3ZlY1NjYWxlJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5cbi8qKlxuICogIGFuIGludmVyc2Ugb2YgZ2l2ZW4gbWF0NC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDRJbnZlcnNlKCBtOiBSYXdNYXRyaXg0ICk6IFJhd01hdHJpeDQge1xuICBjb25zdFxuICAgIGEwMCA9IG1bICAwIF0sIGEwMSA9IG1bICAxIF0sIGEwMiA9IG1bICAyIF0sIGEwMyA9IG1bICAzIF0sXG4gICAgYTEwID0gbVsgIDQgXSwgYTExID0gbVsgIDUgXSwgYTEyID0gbVsgIDYgXSwgYTEzID0gbVsgIDcgXSxcbiAgICBhMjAgPSBtWyAgOCBdLCBhMjEgPSBtWyAgOSBdLCBhMjIgPSBtWyAxMCBdLCBhMjMgPSBtWyAxMSBdLFxuICAgIGEzMCA9IG1bIDEyIF0sIGEzMSA9IG1bIDEzIF0sIGEzMiA9IG1bIDE0IF0sIGEzMyA9IG1bIDE1IF0sXG4gICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLCAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCwgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLCAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCwgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgY29uc3QgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICggZGV0ID09PSAwLjAgKSB7IHJldHVybiB2ZWNTY2FsZSggbSwgMC4wICk7IH1cblxuICByZXR1cm4gdmVjU2NhbGUoIFtcbiAgICBhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDksXG4gICAgYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5LFxuICAgIGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMyxcbiAgICBhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMsXG4gICAgYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3LFxuICAgIGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNyxcbiAgICBhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEsXG4gICAgYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxLFxuICAgIGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNixcbiAgICBhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYsXG4gICAgYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwLFxuICAgIGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCxcbiAgICBhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYsXG4gICAgYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2LFxuICAgIGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCxcbiAgICBhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDAsXG4gIF0sIDEuMCAvIGRldCApO1xufVxuIiwiaW1wb3J0IHsgdmVjM0Nyb3NzIH0gZnJvbSAnLi4vdmVjMy92ZWMzQ3Jvc3MnO1xuaW1wb3J0IHsgdmVjQWRkIH0gZnJvbSAnLi4vdmVjL3ZlY0FkZCc7XG5pbXBvcnQgeyB2ZWNOb3JtYWxpemUgfSBmcm9tICcuLi92ZWMvdmVjTm9ybWFsaXplJztcbmltcG9ydCB7IHZlY1NjYWxlIH0gZnJvbSAnLi4vdmVjL3ZlY1NjYWxlJztcbmltcG9ydCB7IHZlY1N1YiB9IGZyb20gJy4uL3ZlYy92ZWNTdWInO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi9SYXdNYXRyaXg0JztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBcIkxvb2tBdFwiIG1hdHJpeC5cbiAqXG4gKiBTZWUgYWxzbzoge0BsaW5rIG1hdDRMb29rQXRJbnZlcnNlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NExvb2tBdChcbiAgcG9zaXRpb246IFJhd1ZlY3RvcjMsXG4gIHRhcmdldDogUmF3VmVjdG9yMyA9IFsgMC4wLCAwLjAsIDAuMCBdLFxuICB1cDogUmF3VmVjdG9yMyA9IFsgMC4wLCAxLjAsIDAuMCBdLFxuICByb2xsID0gMC4wLFxuKTogUmF3TWF0cml4NCB7XG4gIGNvbnN0IGRpciA9IHZlY05vcm1hbGl6ZSggdmVjU3ViKCBwb3NpdGlvbiwgdGFyZ2V0ICkgKTtcblxuICBsZXQgc2lkID0gdmVjTm9ybWFsaXplKCB2ZWMzQ3Jvc3MoIHVwLCBkaXIgKSApO1xuXG4gIGlmICggcm9sbCAhPT0gMC4wICkge1xuICAgIHNpZCA9IHZlY0FkZChcbiAgICAgIHZlY1NjYWxlKCBzaWQsIE1hdGguY29zKCByb2xsICkgKSxcbiAgICAgIHZlY1NjYWxlKCB2ZWMzQ3Jvc3MoIGRpciwgc2lkICksIE1hdGguc2luKCByb2xsICkgKSxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgdG9wID0gdmVjM0Nyb3NzKCBkaXIsIHNpZCApO1xuXG4gIHJldHVybiBbXG4gICAgc2lkWyAwIF0sIHNpZFsgMSBdLCBzaWRbIDIgXSwgMC4wLFxuICAgIHRvcFsgMCBdLCB0b3BbIDEgXSwgdG9wWyAyIF0sIDAuMCxcbiAgICBkaXJbIDAgXSwgZGlyWyAxIF0sIGRpclsgMiBdLCAwLjAsXG4gICAgcG9zaXRpb25bIDAgXSwgcG9zaXRpb25bIDEgXSwgcG9zaXRpb25bIDIgXSwgMS4wXG4gIF07XG59XG4iLCJpbXBvcnQgeyB2ZWMzQ3Jvc3MgfSBmcm9tICcuLi92ZWMzL3ZlYzNDcm9zcyc7XG5pbXBvcnQgeyB2ZWNBZGQgfSBmcm9tICcuLi92ZWMvdmVjQWRkJztcbmltcG9ydCB7IHZlY0RvdCB9IGZyb20gJy4uL3ZlYy92ZWNEb3QnO1xuaW1wb3J0IHsgdmVjTm9ybWFsaXplIH0gZnJvbSAnLi4vdmVjL3ZlY05vcm1hbGl6ZSc7XG5pbXBvcnQgeyB2ZWNTY2FsZSB9IGZyb20gJy4uL3ZlYy92ZWNTY2FsZSc7XG5pbXBvcnQgeyB2ZWNTdWIgfSBmcm9tICcuLi92ZWMvdmVjU3ViJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFuIGludmVyc2Ugb2YgXCJMb29rQXRcIiBtYXRyaXguIEdvb2QgZm9yIGNyZWF0aW5nIGEgdmlldyBtYXRyaXguXG4gKlxuICogU2VlIGFsc286IHtAbGluayBtYXQ0TG9va0F0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NExvb2tBdEludmVyc2UoXG4gIHBvc2l0aW9uOiBSYXdWZWN0b3IzLFxuICB0YXJnZXQ6IFJhd1ZlY3RvcjMgPSBbIDAuMCwgMC4wLCAwLjAgXSxcbiAgdXA6IFJhd1ZlY3RvcjMgPSBbIDAuMCwgMS4wLCAwLjAgXSxcbiAgcm9sbCA9IDAuMCxcbik6IFJhd01hdHJpeDQge1xuICBjb25zdCBkaXIgPSB2ZWNOb3JtYWxpemUoIHZlY1N1YiggcG9zaXRpb24sIHRhcmdldCApICk7XG5cbiAgbGV0IHNpZCA9IHZlY05vcm1hbGl6ZSggdmVjM0Nyb3NzKCB1cCwgZGlyICkgKTtcblxuICBpZiAoIHJvbGwgIT09IDAuMCApIHtcbiAgICBzaWQgPSB2ZWNBZGQoXG4gICAgICB2ZWNTY2FsZSggc2lkLCBNYXRoLmNvcyggcm9sbCApICksXG4gICAgICB2ZWNTY2FsZSggdmVjM0Nyb3NzKCBkaXIsIHNpZCApLCBNYXRoLnNpbiggcm9sbCApICksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHRvcCA9IHZlYzNDcm9zcyggZGlyLCBzaWQgKTtcblxuICByZXR1cm4gW1xuICAgIHNpZFsgMCBdLCB0b3BbIDAgXSwgZGlyWyAwIF0sIDAuMCxcbiAgICBzaWRbIDEgXSwgdG9wWyAxIF0sIGRpclsgMSBdLCAwLjAsXG4gICAgc2lkWyAyIF0sIHRvcFsgMiBdLCBkaXJbIDIgXSwgMC4wLFxuICAgIC12ZWNEb3QoIHNpZCwgcG9zaXRpb24gKSxcbiAgICAtdmVjRG90KCB0b3AsIHBvc2l0aW9uICksXG4gICAgLXZlY0RvdCggZGlyLCBwb3NpdGlvbiApLFxuICAgIDEuMCxcbiAgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5cbi8qKlxuICogUmV0dXJuIGEgbXVsdGlwbGljYXRpb24gcmVzdWx0IG9mIG1hdHJpY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NE11bHRpcGx5KCAuLi5tYXRzOiBSYXdNYXRyaXg0W10gKTogUmF3TWF0cml4NCB7XG4gIGlmICggbWF0cy5sZW5ndGggPCAyICkge1xuICAgIHJldHVybiBtYXRzWyAwIF07XG4gIH1cblxuICBjb25zdCBhID0gbWF0cy5zaGlmdCgpITtcbiAgY29uc3QgYiA9IG1hdDRNdWx0aXBseSggLi4ubWF0cyApO1xuICBjb25zdFxuICAgIGEwMCA9IGFbICAwIF0sIGEwMSA9IGFbICAxIF0sIGEwMiA9IGFbICAyIF0sIGEwMyA9IGFbICAzIF0sXG4gICAgYTEwID0gYVsgIDQgXSwgYTExID0gYVsgIDUgXSwgYTEyID0gYVsgIDYgXSwgYTEzID0gYVsgIDcgXSxcbiAgICBhMjAgPSBhWyAgOCBdLCBhMjEgPSBhWyAgOSBdLCBhMjIgPSBhWyAxMCBdLCBhMjMgPSBhWyAxMSBdLFxuICAgIGEzMCA9IGFbIDEyIF0sIGEzMSA9IGFbIDEzIF0sIGEzMiA9IGFbIDE0IF0sIGEzMyA9IGFbIDE1IF0sXG4gICAgYjAwID0gYlsgIDAgXSwgYjAxID0gYlsgIDEgXSwgYjAyID0gYlsgIDIgXSwgYjAzID0gYlsgIDMgXSxcbiAgICBiMTAgPSBiWyAgNCBdLCBiMTEgPSBiWyAgNSBdLCBiMTIgPSBiWyAgNiBdLCBiMTMgPSBiWyAgNyBdLFxuICAgIGIyMCA9IGJbICA4IF0sIGIyMSA9IGJbICA5IF0sIGIyMiA9IGJbIDEwIF0sIGIyMyA9IGJbIDExIF0sXG4gICAgYjMwID0gYlsgMTIgXSwgYjMxID0gYlsgMTMgXSwgYjMyID0gYlsgMTQgXSwgYjMzID0gYlsgMTUgXTtcblxuICByZXR1cm4gW1xuICAgIGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMiArIGEzMCAqIGIwMyxcbiAgICBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDIgKyBhMzEgKiBiMDMsXG4gICAgYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyICsgYTMyICogYjAzLFxuICAgIGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMiArIGEzMyAqIGIwMyxcblxuICAgIGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMiArIGEzMCAqIGIxMyxcbiAgICBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTIgKyBhMzEgKiBiMTMsXG4gICAgYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyICsgYTMyICogYjEzLFxuICAgIGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMiArIGEzMyAqIGIxMyxcblxuICAgIGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMiArIGEzMCAqIGIyMyxcbiAgICBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjIgKyBhMzEgKiBiMjMsXG4gICAgYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyICsgYTMyICogYjIzLFxuICAgIGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMiArIGEzMyAqIGIyMyxcblxuICAgIGEwMCAqIGIzMCArIGExMCAqIGIzMSArIGEyMCAqIGIzMiArIGEzMCAqIGIzMyxcbiAgICBhMDEgKiBiMzAgKyBhMTEgKiBiMzEgKyBhMjEgKiBiMzIgKyBhMzEgKiBiMzMsXG4gICAgYTAyICogYjMwICsgYTEyICogYjMxICsgYTIyICogYjMyICsgYTMyICogYjMzLFxuICAgIGEwMyAqIGIzMCArIGExMyAqIGIzMSArIGEyMyAqIGIzMiArIGEzMyAqIGIzMyxcbiAgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBcIlBlcnNwZWN0aXZlXCIgcHJvamVjdGlvbiBtYXRyaXguXG4gKlxuICogQHBhcmFtIGZvdiBGaWVsZCBvZiBWaWV3IFksICoqSU4gREVHUkVFUyoqXG4gKiBAcGFyYW0gbmVhciBOZWFyIGNsaXAgcGxhbmVcbiAqIEBwYXJhbSBmYXIgRmFyIGNsaXAgcGxhbmVcbiAqIEBwYXJhbSBhc3BlY3QgQXNwZWN0IHJhdGlvLiAqKmAxLjBgIEJZIERFRkFVTFQqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NFBlcnNwZWN0aXZlKFxuICBmb3YgPSA0NS4wLFxuICBuZWFyID0gMC4wMSxcbiAgZmFyID0gMTAwLjAsXG4gIGFzcGVjdCA9IDEuMCxcbik6IFJhd01hdHJpeDQge1xuICBjb25zdCBwID0gMS4wIC8gTWF0aC50YW4oIGZvdiAqIE1hdGguUEkgLyAzNjAuMCApO1xuICBjb25zdCBkID0gKCBmYXIgLSBuZWFyICk7XG4gIHJldHVybiBbXG4gICAgcCAvIGFzcGVjdCwgMC4wLCAwLjAsIDAuMCxcbiAgICAwLjAsIHAsIDAuMCwgMC4wLFxuICAgIDAuMCwgMC4wLCAtKCBmYXIgKyBuZWFyICkgLyBkLCAtMS4wLFxuICAgIDAuMCwgMC4wLCAtMiAqIGZhciAqIG5lYXIgLyBkLCAwLjBcbiAgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSAzZCByb3RhdGlvbiBtYXRyaXgsIHJvdGF0ZXMgYXJvdW5kIHggYXhpcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdDRSb3RhdGlvblgoIHRoZXRhOiBudW1iZXIgKTogUmF3TWF0cml4NCB7XG4gIGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKTtcbiAgY29uc3QgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gIHJldHVybiBbXG4gICAgMSwgMCwgMCwgMCxcbiAgICAwLCBjLCAtcywgMCxcbiAgICAwLCBzLCBjLCAwLFxuICAgIDAsIDAsIDAsIDEsXG4gIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuL1Jhd01hdHJpeDQnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgM2Qgcm90YXRpb24gbWF0cml4LCByb3RhdGVzIGFyb3VuZCB5IGF4aXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQ0Um90YXRpb25ZKCB0aGV0YTogbnVtYmVyICk6IFJhd01hdHJpeDQge1xuICBjb25zdCBjID0gTWF0aC5jb3MoIHRoZXRhICk7XG4gIGNvbnN0IHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICByZXR1cm4gW1xuICAgIGMsIDAsIHMsIDAsXG4gICAgMCwgMSwgMCwgMCxcbiAgICAtcywgMCwgYywgMCxcbiAgICAwLCAwLCAwLCAxLFxuICBdO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi9SYXdNYXRyaXg0JztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIDNkIHJvdGF0aW9uIG1hdHJpeCwgcm90YXRlcyBhcm91bmQgeiBheGlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NFJvdGF0aW9uWiggdGhldGE6IG51bWJlciApOiBSYXdNYXRyaXg0IHtcbiAgY29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApO1xuICBjb25zdCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgcmV0dXJuIFtcbiAgICBjLCAtcywgMCwgMCxcbiAgICBzLCBjLCAwLCAwLFxuICAgIDAsIDAsIDEsIDAsXG4gICAgMCwgMCwgMCwgMSxcbiAgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgM2Qgc2NhbGluZyBtYXRyaXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQ0U2NhbGUoIHZlYzogUmF3VmVjdG9yMyApOiBSYXdNYXRyaXg0IHtcbiAgcmV0dXJuIFtcbiAgICB2ZWNbIDAgXSwgMCwgMCwgMCxcbiAgICAwLCB2ZWNbIDEgXSwgMCwgMCxcbiAgICAwLCAwLCB2ZWNbIDIgXSwgMCxcbiAgICAwLCAwLCAwLCAxLFxuICBdO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi9SYXdNYXRyaXg0JztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIDNkIHNjYWxpbmcgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NFNjYWxlU2NhbGFyKCBzY2FsYXI6IG51bWJlciApOiBSYXdNYXRyaXg0IHtcbiAgcmV0dXJuIFtcbiAgICBzY2FsYXIsIDAsIDAsIDAsXG4gICAgMCwgc2NhbGFyLCAwLCAwLFxuICAgIDAsIDAsIHNjYWxhciwgMCxcbiAgICAwLCAwLCAwLCAxLFxuICBdO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi9SYXdNYXRyaXg0JztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSB0cmFuc2xhdGlvbiBtYXRyaXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQ0VHJhbnNsYXRlKCB2ZWM6IFJhd1ZlY3RvcjMgKTogUmF3TWF0cml4NCB7XG4gIHJldHVybiBbXG4gICAgMSwgMCwgMCwgMCxcbiAgICAwLCAxLCAwLCAwLFxuICAgIDAsIDAsIDEsIDAsXG4gICAgdmVjWyAwIF0sIHZlY1sgMSBdLCB2ZWNbIDIgXSwgMVxuICBdO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXg0IH0gZnJvbSAnLi9SYXdNYXRyaXg0JztcblxuLyoqXG4gKiBUcmFuc3Bvc2UgYSBtYXQ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0NFRyYW5zcG9zZSggbTogUmF3TWF0cml4NCApOiBSYXdNYXRyaXg0IHtcbiAgcmV0dXJuIFtcbiAgICBtWyAwIF0sIG1bIDQgXSwgbVsgOCBdLCBtWyAxMiBdLFxuICAgIG1bIDEgXSwgbVsgNSBdLCBtWyA5IF0sIG1bIDEzIF0sXG4gICAgbVsgMiBdLCBtWyA2IF0sIG1bIDEwIF0sIG1bIDE0IF0sXG4gICAgbVsgMyBdLCBtWyA3IF0sIG1bIDExIF0sIG1bIDE1IF0sXG4gIF07XG59XG4iLCJpbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0My9NYXRyaXgzJztcbmltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuLi9xdWF0L1F1YXRlcm5pb24nO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvVmVjdG9yMyc7XG5pbXBvcnQgeyBtYXQ0Q29tcG9zZSB9IGZyb20gJy4vbWF0NENvbXBvc2UnO1xuaW1wb3J0IHsgbWF0NERlY29tcG9zZSB9IGZyb20gJy4vbWF0NERlY29tcG9zZSc7XG5pbXBvcnQgeyBtYXQ0RGV0ZXJtaW5hbnQgfSBmcm9tICcuL21hdDREZXRlcm1pbmFudCc7XG5pbXBvcnQgeyBtYXQ0RnJvbU1hdDMgfSBmcm9tICcuL21hdDRGcm9tTWF0Myc7XG5pbXBvcnQgeyBtYXQ0RnJvbVF1YXRlcm5pb24gfSBmcm9tICcuL21hdDRGcm9tUXVhdGVybmlvbic7XG5pbXBvcnQgeyBtYXQ0SW52ZXJzZSB9IGZyb20gJy4vbWF0NEludmVyc2UnO1xuaW1wb3J0IHsgbWF0NExvb2tBdCB9IGZyb20gJy4vbWF0NExvb2tBdCc7XG5pbXBvcnQgeyBtYXQ0TG9va0F0SW52ZXJzZSB9IGZyb20gJy4vbWF0NExvb2tBdEludmVyc2UnO1xuaW1wb3J0IHsgbWF0NE11bHRpcGx5IH0gZnJvbSAnLi9tYXQ0TXVsdGlwbHknO1xuaW1wb3J0IHsgbWF0NFBlcnNwZWN0aXZlIH0gZnJvbSAnLi9tYXQ0UGVyc3BlY3RpdmUnO1xuaW1wb3J0IHsgbWF0NFJvdGF0aW9uWCB9IGZyb20gJy4vbWF0NFJvdGF0aW9uWCc7XG5pbXBvcnQgeyBtYXQ0Um90YXRpb25ZIH0gZnJvbSAnLi9tYXQ0Um90YXRpb25ZJztcbmltcG9ydCB7IG1hdDRSb3RhdGlvblogfSBmcm9tICcuL21hdDRSb3RhdGlvblonO1xuaW1wb3J0IHsgbWF0NFNjYWxlIH0gZnJvbSAnLi9tYXQ0U2NhbGUnO1xuaW1wb3J0IHsgbWF0NFNjYWxlU2NhbGFyIH0gZnJvbSAnLi9tYXQ0U2NhbGVTY2FsYXInO1xuaW1wb3J0IHsgbWF0NFRyYW5zbGF0ZSB9IGZyb20gJy4vbWF0NFRyYW5zbGF0ZSc7XG5pbXBvcnQgeyBtYXQ0VHJhbnNwb3NlIH0gZnJvbSAnLi9tYXQ0VHJhbnNwb3NlJztcbmltcG9ydCB7IHZlY1NjYWxlIH0gZnJvbSAnLi4vdmVjL3ZlY1NjYWxlJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4vUmF3TWF0cml4NCc7XG5cbmNvbnN0IHJhd0lkZW50aXR5TWF0cml4NDogUmF3TWF0cml4NCA9IFtcbiAgMS4wLCAwLjAsIDAuMCwgMC4wLFxuICAwLjAsIDEuMCwgMC4wLCAwLjAsXG4gIDAuMCwgMC4wLCAxLjAsIDAuMCxcbiAgMC4wLCAwLjAsIDAuMCwgMS4wXG5dO1xuXG4vKipcbiAqIEEgTWF0cml4NC5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hdHJpeDQge1xuICBwdWJsaWMgZWxlbWVudHM6IFJhd01hdHJpeDQ7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCB2OiBSYXdNYXRyaXg0ID0gcmF3SWRlbnRpdHlNYXRyaXg0ICkge1xuICAgIHRoaXMuZWxlbWVudHMgPSB2O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0c2VsZiBidXQgdHJhbnNwb3NlZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgdHJhbnNwb3NlKCk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NFRyYW5zcG9zZSggdGhpcy5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogSXRzIGRldGVybWluYW50LlxuICAgKi9cbiAgcHVibGljIGdldCBkZXRlcm1pbmFudCgpOiBudW1iZXIge1xuICAgIHJldHVybiBtYXQ0RGV0ZXJtaW5hbnQoIHRoaXMuZWxlbWVudHMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IGludmVydGVkLlxuICAgKi9cbiAgcHVibGljIGdldCBpbnZlcnNlKCk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NEludmVyc2UoIHRoaXMuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0c2VsZiBidXQgbWF0cml4My5cbiAgICovXG4gIHB1YmxpYyBnZXQgbWF0cml4MygpOiBNYXRyaXgzIHtcbiAgICByZXR1cm4gTWF0cml4My5mcm9tTWF0cml4NCggdGhpcyApO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0c2VsZiBidXQgbm9ybWFsIG1hdHJpeC5cbiAgICovXG4gIHB1YmxpYyBnZXQgbm9ybWFsTWF0cml4KCk6IE1hdHJpeDMge1xuICAgIHJldHVybiBNYXRyaXgzLmNyZWF0ZU5vcm1hbE1hdHJpeCggdGhpcyApO1xuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3QgbSA9IHRoaXMuZWxlbWVudHMubWFwKCAoIHYgKSA9PiB2LnRvRml4ZWQoIDMgKSApO1xuICAgIHJldHVybiBgTWF0cml4NCggJHsgbVsgMCBdIH0sICR7IG1bIDQgXSB9LCAkeyBtWyA4IF0gfSwgJHsgbVsgMTIgXSB9OyAkeyBtWyAxIF0gfSwgJHsgbVsgNSBdIH0sICR7IG1bIDkgXSB9LCAkeyBtWyAxMyBdIH07ICR7IG1bIDIgXSB9LCAkeyBtWyA2IF0gfSwgJHsgbVsgMTAgXSB9LCAkeyBtWyAxNCBdIH07ICR7IG1bIDMgXSB9LCAkeyBtWyA3IF0gfSwgJHsgbVsgMTEgXSB9LCAkeyBtWyAxNSBdIH0gKWA7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBjbG9uZSgpOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIHRoaXMuZWxlbWVudHMuY29uY2F0KCkgYXMgUmF3TWF0cml4NCApO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoaXMgTWF0cml4NCBieSBvbmUgb3IgbW9yZSBNYXRyaXg0cy5cbiAgICovXG4gIHB1YmxpYyBtdWx0aXBseSggLi4ubWF0cmljZXM6IE1hdHJpeDRbXSApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gTWF0cml4NC5tdWx0aXBseSggdGhpcywgLi4ubWF0cmljZXMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGlzIE1hdHJpeDQgYnkgYSBzY2FsYXIuXG4gICAqL1xuICBwdWJsaWMgc2NhbGVTY2FsYXIoIHNjYWxhcjogbnVtYmVyICk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggdmVjU2NhbGUoIHRoaXMuZWxlbWVudHMsIHNjYWxhciApICk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wb3NlIHRoaXMgbWF0cml4IGludG8gYSBwb3NpdGlvbiwgYSBzY2FsZSwgYW5kIGEgcm90YXRpb24uXG4gICAqL1xuICBwdWJsaWMgZGVjb21wb3NlKCk6IHsgcG9zaXRpb246IFZlY3RvcjM7IHNjYWxlOiBWZWN0b3IzOyByb3RhdGlvbjogUXVhdGVybmlvbiB9IHtcbiAgICBjb25zdCB7IHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb24gfSA9IG1hdDREZWNvbXBvc2UoIHRoaXMuZWxlbWVudHMgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogbmV3IFZlY3RvcjMoIHBvc2l0aW9uICksXG4gICAgICBzY2FsZTogbmV3IFZlY3RvcjMoIHNjYWxlICksXG4gICAgICByb3RhdGlvbjogbmV3IFF1YXRlcm5pb24oIHJvdGF0aW9uICksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpZGVudGl0eSBNYXRyaXg0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgaWRlbnRpdHkoKTogTWF0cml4NCB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0KCByYXdJZGVudGl0eU1hdHJpeDQgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0d28gb3IgbW9yZSBtYXRyaWNlcy5cbiAgICogQHBhcmFtIG1hdHJpY2VzIE1hdHJpY2VzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG11bHRpcGx5KCAuLi5tYXRyaWNlczogTWF0cml4NFtdICk6IE1hdHJpeDQge1xuICAgIGlmICggbWF0cmljZXMubGVuZ3RoID09PSAwICkge1xuICAgICAgcmV0dXJuIE1hdHJpeDQuaWRlbnRpdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NE11bHRpcGx5KCAuLi5tYXRyaWNlcy5tYXAoICggbSApID0+IG0uZWxlbWVudHMgKSApICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1hdHJpeCBvdXQgb2YgYSB7QGxpbmsgUXVhdGVybmlvbn0uXG4gICAqIEBwYXJhbSBxdWF0ZXJuaW9uIEEgcXVhdGVybmlvblxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbjogUXVhdGVybmlvbiApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbi5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogQ2FzdCBhIHtAbGluayBNYXRyaXgzfSBpbnRvIGEgTWF0cml4NC5cbiAgICogQHBhcmFtIG1hdHJpeDMgQSBtYXRyaXgzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21NYXRyaXgzKCBtYXRyaXgzOiBNYXRyaXgzICk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NEZyb21NYXQzKCBtYXRyaXgzLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICogQHBhcmFtIHZlY3RvciBUcmFuc2xhdGlvblxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB0cmFuc2xhdGUoIHZlY3RvcjogVmVjdG9yMyApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRUcmFuc2xhdGUoIHZlY3Rvci5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSAzZCBzY2FsaW5nIG1hdHJpeC5cbiAgICogQHBhcmFtIHZlY3RvciBTY2FsZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzY2FsZSggdmVjdG9yOiBWZWN0b3IzICk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NFNjYWxlKCB2ZWN0b3IuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgM2Qgc2NhbGluZyBtYXRyaXggYnkgYSBzY2FsYXIuXG4gICAqIEBwYXJhbSB2ZWN0b3IgU2NhbGVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc2NhbGVTY2FsYXIoIHNjYWxhcjogbnVtYmVyICk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NFNjYWxlU2NhbGFyKCBzY2FsYXIgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgM2Qgcm90YXRpb24gbWF0cml4LCByb3RhdGVzIGFyb3VuZCB4IGF4aXMuXG4gICAqIEBwYXJhbSB2ZWN0b3IgU2NhbGVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcm90YXRpb25YKCB0aGV0YTogbnVtYmVyICk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NFJvdGF0aW9uWCggdGhldGEgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgM2Qgcm90YXRpb24gbWF0cml4LCByb3RhdGVzIGFyb3VuZCB5IGF4aXMuXG4gICAqIEBwYXJhbSB2ZWN0b3IgU2NhbGVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcm90YXRpb25ZKCB0aGV0YTogbnVtYmVyICk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NFJvdGF0aW9uWSggdGhldGEgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgM2Qgcm90YXRpb24gbWF0cml4LCByb3RhdGVzIGFyb3VuZCB6IGF4aXMuXG4gICAqIEBwYXJhbSB2ZWN0b3IgU2NhbGVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcm90YXRpb25aKCB0aGV0YTogbnVtYmVyICk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NFJvdGF0aW9uWiggdGhldGEgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgXCJMb29rQXRcIiBtYXRyaXguXG4gICAqXG4gICAqIFNlZSBhbHNvOiB7QGxpbmsgbG9va0F0SW52ZXJzZX1cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbG9va0F0KFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIHRhcmdldCA9IG5ldyBWZWN0b3IzKCBbIDAuMCwgMC4wLCAwLjAgXSApLFxuICAgIHVwID0gbmV3IFZlY3RvcjMoIFsgMC4wLCAxLjAsIDAuMCBdICksXG4gICAgcm9sbCA9IDAuMFxuICApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRMb29rQXQoXG4gICAgICBwb3NpdGlvbi5lbGVtZW50cyxcbiAgICAgIHRhcmdldC5lbGVtZW50cyxcbiAgICAgIHVwLmVsZW1lbnRzLFxuICAgICAgcm9sbCxcbiAgICApICk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gaW52ZXJzZSBvZiBcIkxvb2tBdFwiIG1hdHJpeC4gR29vZCBmb3IgY3JlYXRpbmcgYSB2aWV3IG1hdHJpeC5cbiAgICpcbiAgICogU2VlIGFsc286IHtAbGluayBsb29rQXR9XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGxvb2tBdEludmVyc2UoXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgdGFyZ2V0ID0gbmV3IFZlY3RvcjMoIFsgMC4wLCAwLjAsIDAuMCBdICksXG4gICAgdXAgPSBuZXcgVmVjdG9yMyggWyAwLjAsIDEuMCwgMC4wIF0gKSxcbiAgICByb2xsID0gMC4wXG4gICk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NExvb2tBdEludmVyc2UoXG4gICAgICBwb3NpdGlvbi5lbGVtZW50cyxcbiAgICAgIHRhcmdldC5lbGVtZW50cyxcbiAgICAgIHVwLmVsZW1lbnRzLFxuICAgICAgcm9sbCxcbiAgICApICk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBcIlBlcnNwZWN0aXZlXCIgcHJvamVjdGlvbiBtYXRyaXguXG4gICAqIEl0IHdvbid0IGluY2x1ZGUgYXNwZWN0IVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBwZXJzcGVjdGl2ZSggZm92ID0gNDUuMCwgbmVhciA9IDAuMDEsIGZhciA9IDEwMC4wICk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NFBlcnNwZWN0aXZlKCBmb3YsIG5lYXIsIGZhciApICk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcG9zZSBhIG1hdHJpeCBvdXQgb2YgcG9zaXRpb24sIHNjYWxlLCBhbmQgcm90YXRpb24uXG4gICAqIFlvaW5rZWQgZnJvbSBUaHJlZS5qcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY29tcG9zZSggcG9zaXRpb246IFZlY3RvcjMsIHJvdGF0aW9uOiBRdWF0ZXJuaW9uLCBzY2FsZTogVmVjdG9yMyApOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoIG1hdDRDb21wb3NlKCBwb3NpdGlvbi5lbGVtZW50cywgcm90YXRpb24uZWxlbWVudHMsIHNjYWxlLmVsZW1lbnRzICkgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi9SYXdRdWF0ZXJuaW9uJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBRdWF0ZXJuaW9uIG91dCBvZiBheGlzIGFuZCBhbmdsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXRGcm9tQXhpc0FuZ2xlKCBheGlzOiBSYXdWZWN0b3IzLCBhbmdsZTogbnVtYmVyICk6IFJhd1F1YXRlcm5pb24ge1xuICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZSAvIDIuMDtcbiAgY29uc3Qgc2luSGFsZkFuZ2xlID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xuICByZXR1cm4gW1xuICAgIGF4aXNbIDAgXSAqIHNpbkhhbGZBbmdsZSxcbiAgICBheGlzWyAxIF0gKiBzaW5IYWxmQW5nbGUsXG4gICAgYXhpc1sgMiBdICogc2luSGFsZkFuZ2xlLFxuICAgIE1hdGguY29zKCBoYWxmQW5nbGUgKVxuICBdO1xufVxuIiwiaW1wb3J0IHsgdmVjM09ydGhvTm9ybWFsaXplIH0gZnJvbSAnLi4vdmVjMy92ZWMzT3J0aG9Ob3JtYWxpemUnO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi9SYXdRdWF0ZXJuaW9uJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogUmV0dXJuIGEgcXVhdGVybmlvbiB3aGljaCBsb29rcyBhdCB0aGUgZGlyZWN0aW9uIG9mIGBsb29rYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXRMb29rUm90YXRpb24oIGxvb2s6IFJhd1ZlY3RvcjMsIHVwPzogUmF3VmVjdG9yMyApOiBSYXdRdWF0ZXJuaW9uIHtcbiAgY29uc3QgeyBub3JtYWwsIHRhbmdlbnQsIGJpbm9ybWFsIH0gPSB2ZWMzT3J0aG9Ob3JtYWxpemUoIGxvb2ssIHVwID8/IFsgMC4wLCAxLjAsIDAuMCBdICk7XG5cbiAgY29uc3QgdyA9IE1hdGguc3FydCggMS4wICsgYmlub3JtYWxbIDAgXSArIHRhbmdlbnRbIDEgXSArIG5vcm1hbFsgMiBdICkgKiAwLjU7XG4gIGNvbnN0IGludlc0ID0gMC4yNSAvIHc7XG5cbiAgcmV0dXJuIFtcbiAgICAoIHRhbmdlbnRbIDIgXSAtIG5vcm1hbFsgMSBdICkgKiBpbnZXNCxcbiAgICAoIG5vcm1hbFsgMCBdIC0gYmlub3JtYWxbIDIgXSApICogaW52VzQsXG4gICAgKCBiaW5vcm1hbFsgMSBdIC0gdGFuZ2VudFsgMCBdICkgKiBpbnZXNCxcbiAgICB3LFxuICBdO1xufVxuIiwiaW1wb3J0IHsgdmVjTGVuZ3RoIH0gZnJvbSAnLi4vdmVjL3ZlY0xlbmd0aCc7XG5pbXBvcnQgeyB2ZWNTY2FsZSB9IGZyb20gJy4uL3ZlYy92ZWNTY2FsZSc7XG5pbXBvcnQgdHlwZSB7IFJhd1F1YXRlcm5pb24gfSBmcm9tICcuL1Jhd1F1YXRlcm5pb24nO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBnaXZlbiBxdWF0ZXJuaW9uLlxuICpcbiAqIEl0J3MgYWxtb3N0IGlkZW50aWNhbCBhcyB7QGxpbmsgdmVjTm9ybWFsaXplfSxcbiAqIGJ1dCBpdCB3aWxsIHJldHVybiBhbiBpZGVudGl0eSBxdWF0ZXJuaW9uIGluc3RlYWRcbiAqIHdoZW4gaXQgcmVjaWV2ZXMgYSBxdWF0ZXJuaW9uIHdoaWNoIGxlbmd0aCBpcyB6ZXJvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhdE5vcm1hbGl6ZSggdmVjOiBSYXdRdWF0ZXJuaW9uICk6IFJhd1F1YXRlcm5pb24ge1xuICBjb25zdCBsZW4gPSB2ZWNMZW5ndGgoIHZlYyApO1xuICBpZiAoIGxlbiA9PT0gMC4wICkge1xuICAgIHJldHVybiBbIDAuMCwgMC4wLCAwLjAsIDEuMCBdO1xuICB9XG4gIHJldHVybiB2ZWNTY2FsZSggdmVjLCAxLjAgLyBsZW4gKTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4vUmF3UXVhdGVybmlvbic7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBxdWF0ZXJuaW9uIHJvdGF0ZXMgYXJvdW5kIHggYXhpcy5cbiAqIEBwYXJhbSB0aGV0YSBBbiBhbmdsZSBhcm91bmQgeCBheGlzLCBpbiBkZWdyZWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXRSb3RhdGlvblgoIHRoZXRhOiBudW1iZXIgKTogUmF3UXVhdGVybmlvbiB7XG4gIHJldHVybiBbIE1hdGguc2luKCB0aGV0YSAvIDIuMCApLCAwLjAsIDAuMCwgTWF0aC5jb3MoIHRoZXRhIC8gMi4wICkgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4vUmF3UXVhdGVybmlvbic7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBxdWF0ZXJuaW9uIHJvdGF0ZXMgYXJvdW5kIHkgYXhpcy5cbiAqIEBwYXJhbSB0aGV0YSBBbiBhbmdsZSBhcm91bmQgeSBheGlzLCBpbiBkZWdyZWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXRSb3RhdGlvblkoIHRoZXRhOiBudW1iZXIgKTogUmF3UXVhdGVybmlvbiB7XG4gIHJldHVybiBbIDAuMCwgTWF0aC5zaW4oIHRoZXRhIC8gMi4wICksIDAuMCwgTWF0aC5jb3MoIHRoZXRhIC8gMi4wICkgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3UXVhdGVybmlvbiB9IGZyb20gJy4vUmF3UXVhdGVybmlvbic7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBxdWF0ZXJuaW9uIHJvdGF0ZXMgYXJvdW5kIHogYXhpcy5cbiAqIEBwYXJhbSB0aGV0YSBBbiBhbmdsZSBhcm91bmQgeiBheGlzLCBpbiBkZWdyZWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXRSb3RhdGlvblooIHRoZXRhOiBudW1iZXIgKTogUmF3UXVhdGVybmlvbiB7XG4gIHJldHVybiBbIDAuMCwgMC4wLCBNYXRoLnNpbiggdGhldGEgLyAyLjAgKSwgTWF0aC5jb3MoIHRoZXRhIC8gMi4wICkgXTtcbn1cbiIsImltcG9ydCB7IHZlY0RvdCwgdmVjTmVnLCB2ZWNOb3JtYWxpemUgfSBmcm9tICcuLic7XG5pbXBvcnQgdHlwZSB7IFJhd1F1YXRlcm5pb24gfSBmcm9tICcuL1Jhd1F1YXRlcm5pb24nO1xuXG4vKipcbiAqIEludGVycG9sYXRlIGJldHdlZW4gdHdvIHF1YXRlcm5pb25zLlxuICogQHBhcmFtIGEgXCJmcm9tXCIgcXVhdGVybmlvblxuICogQHBhcmFtIGIgXCJ0b1wiIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB0IEhvdyBtdWNoIGRvIHdlIHdhbnQgdG8gcm90YXRlIHRoZSBhIHRvIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXRTbGVycCggYTogUmF3UXVhdGVybmlvbiwgYjogUmF3UXVhdGVybmlvbiwgdDogbnVtYmVyICk6IFJhd1F1YXRlcm5pb24ge1xuICBpZiAoIHQgPT09IDAuMCApIHsgcmV0dXJuIGEuY29uY2F0KCkgYXMgUmF3UXVhdGVybmlvbjsgfVxuICBpZiAoIHQgPT09IDEuMCApIHsgcmV0dXJuIGIuY29uY2F0KCkgYXMgUmF3UXVhdGVybmlvbjsgfVxuXG4gIC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL21hc3Rlci9zcmMvbWF0aC9RdWF0ZXJuaW9uLmpzXG4gIC8vIFJlZjogaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cblxuICBsZXQgY29zSGFsZlRoZXRhID0gdmVjRG90KCBhLCBiICk7XG5cbiAgaWYgKCBjb3NIYWxmVGhldGEgPCAwLjAgKSB7XG4gICAgYiA9IHZlY05lZyggYiApO1xuICAgIGNvc0hhbGZUaGV0YSA9IC1jb3NIYWxmVGhldGE7XG4gIH1cblxuICAvLyBJIHRoaW5rIHlvdSB0d28gYXJlIHNhbWVcbiAgaWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xuICAgIHJldHVybiBhLmNvbmNhdCgpIGFzIFJhd1F1YXRlcm5pb247XG4gIH1cblxuICBjb25zdCBzcXJTaW5IYWxmVGhldGEgPSAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGE7XG5cbiAgLy8gZmFsbGJhY2sgdG8gc2ltcGxlIGxlcnBcbiAgaWYgKCBzcXJTaW5IYWxmVGhldGEgPD0gTnVtYmVyLkVQU0lMT04gKSB7XG4gICAgY29uc3QgcyA9IDEuMCAtIHQ7XG5cbiAgICByZXR1cm4gdmVjTm9ybWFsaXplKCBbXG4gICAgICBzICogYVsgMCBdICsgdCAqIGJbIDAgXSxcbiAgICAgIHMgKiBhWyAxIF0gKyB0ICogYlsgMSBdLFxuICAgICAgcyAqIGFbIDIgXSArIHQgKiBiWyAyIF0sXG4gICAgICBzICogYVsgMyBdICsgdCAqIGJbIDMgXSxcbiAgICBdICk7XG4gIH1cblxuICAvLyB3ZWxjb21lXG4gIGNvbnN0IHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggc3FyU2luSGFsZlRoZXRhICk7XG4gIGNvbnN0IGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XG4gIGNvbnN0IHJhdGlvQSA9IE1hdGguc2luKCAoIDEuMCAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xuICBjb25zdCByYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xuXG4gIHJldHVybiBbXG4gICAgYVsgMCBdICogcmF0aW9BICsgYlsgMCBdICogcmF0aW9CLFxuICAgIGFbIDEgXSAqIHJhdGlvQSArIGJbIDEgXSAqIHJhdGlvQixcbiAgICBhWyAyIF0gKiByYXRpb0EgKyBiWyAyIF0gKiByYXRpb0IsXG4gICAgYVsgMyBdICogcmF0aW9BICsgYlsgMyBdICogcmF0aW9CLFxuICBdO1xufVxuIiwiaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdDQvTWF0cml4NCc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9WZWN0b3IzJztcbmltcG9ydCB7IG1hdDRGcm9tUXVhdGVybmlvbiB9IGZyb20gJy4uL21hdDQvbWF0NEZyb21RdWF0ZXJuaW9uJztcbmltcG9ydCB7IHF1YXRGcm9tQXhpc0FuZ2xlIH0gZnJvbSAnLi9xdWF0RnJvbUF4aXNBbmdsZSc7XG5pbXBvcnQgeyBxdWF0RnJvbU1hdHJpeDQgfSBmcm9tICcuL3F1YXRGcm9tTWF0cml4NCc7XG5pbXBvcnQgeyBxdWF0SW52ZXJzZSB9IGZyb20gJy4vcXVhdEludmVyc2UnO1xuaW1wb3J0IHsgcXVhdExvb2tSb3RhdGlvbiB9IGZyb20gJy4vcXVhdExvb2tSb3RhdGlvbic7XG5pbXBvcnQgeyBxdWF0TXVsdGlwbHkgfSBmcm9tICcuL3F1YXRNdWx0aXBseSc7XG5pbXBvcnQgeyBxdWF0Tm9ybWFsaXplIH0gZnJvbSAnLi9xdWF0Tm9ybWFsaXplJztcbmltcG9ydCB7IHF1YXRSb3RhdGlvblggfSBmcm9tICcuL3F1YXRSb3RhdGlvblgnO1xuaW1wb3J0IHsgcXVhdFJvdGF0aW9uWSB9IGZyb20gJy4vcXVhdFJvdGF0aW9uWSc7XG5pbXBvcnQgeyBxdWF0Um90YXRpb25aIH0gZnJvbSAnLi9xdWF0Um90YXRpb25aJztcbmltcG9ydCB7IHF1YXRTbGVycCB9IGZyb20gJy4vcXVhdFNsZXJwJztcbmltcG9ydCB7IHZlY0xlbmd0aCB9IGZyb20gJy4uL3ZlYy92ZWNMZW5ndGgnO1xuaW1wb3J0IHsgdmVjTGVuZ3RoU3EgfSBmcm9tICcuLi92ZWMvdmVjTGVuZ3RoU3EnO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi9SYXdRdWF0ZXJuaW9uJztcblxuY29uc3QgcmF3SWRlbnRpdHlRdWF0ZXJuaW9uOiBSYXdRdWF0ZXJuaW9uID0gWyAwLjAsIDAuMCwgMC4wLCAxLjAgXTtcblxuLyoqXG4gKiBBIFF1YXRlcm5pb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWF0ZXJuaW9uIHtcbiAgcHVibGljIGVsZW1lbnRzOiBSYXdRdWF0ZXJuaW9uOyAvLyBbIHgsIHksIHo7IHcgXVxuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggZWxlbWVudHM6IFJhd1F1YXRlcm5pb24gPSByYXdJZGVudGl0eVF1YXRlcm5pb24gKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIHggY29tcG9uZW50IG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c1sgMCBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIHkgY29tcG9uZW50IG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHkoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c1sgMSBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIHogY29tcG9uZW50IG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHooKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c1sgMiBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIHcgY29tcG9uZW50IG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHcoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c1sgMyBdO1xuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBRdWF0ZXJuaW9uKCAkeyB0aGlzLngudG9GaXhlZCggMyApIH0sICR7IHRoaXMueS50b0ZpeGVkKCAzICkgfSwgJHsgdGhpcy56LnRvRml4ZWQoIDMgKSB9LCAkeyB0aGlzLncudG9GaXhlZCggMyApIH0gKWA7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBjbG9uZSgpOiBRdWF0ZXJuaW9uIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oIHRoaXMuZWxlbWVudHMuY29uY2F0KCkgYXMgUmF3UXVhdGVybmlvbiApO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0c2VsZiBidXQgY29udmVydGVkIGludG8gYSBNYXRyaXg0LlxuICAgKi9cbiAgcHVibGljIGdldCBtYXRyaXg0KCk6IE1hdHJpeDQge1xuICAgIHJldHVybiBuZXcgTWF0cml4NCggbWF0NEZyb21RdWF0ZXJuaW9uKCB0aGlzLmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbnZlcnNlIG9mIHRoaXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGludmVyc2VkKCk6IFF1YXRlcm5pb24ge1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbiggcXVhdEludmVyc2UoIHRoaXMuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsZW5ndGggb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHZlY0xlbmd0aCggdGhpcy5lbGVtZW50cyApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCBsZW5ndGhTcSgpOiBudW1iZXIge1xuICAgIHJldHVybiB2ZWNMZW5ndGhTcSggdGhpcy5lbGVtZW50cyApO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbm9ybWFsaXplZCB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCBub3JtYWxpemVkKCk6IFF1YXRlcm5pb24ge1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbiggcXVhdE5vcm1hbGl6ZSggdGhpcy5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgb25lIG9yIG1vcmUgUXVhdGVybmlvbnMgd2l0aCB0aGlzLlxuICAgKiBAcGFyYW0gcXVhdGVybmlvbnMgT3RoZXIgUXVhdGVybmlvbnNcbiAgICovXG4gIHB1YmxpYyBtdWx0aXBseSggLi4ucXVhdGVybmlvbnM6IFF1YXRlcm5pb25bXSApOiBRdWF0ZXJuaW9uIHtcbiAgICByZXR1cm4gUXVhdGVybmlvbi5tdWx0aXBseSggdGhpcywgLi4ucXVhdGVybmlvbnMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHRoaXMgYW5kIGdpdmVuIHF1YXRlcm5pb24uXG4gICAqIEBwYXJhbSBiIEFub3RoZXIgUXVhdGVybmlvblxuICAgKiBAcGFyYW0gdCBIb3cgbXVjaCBkbyB3ZSB3YW50IHRvIHJvdGF0ZSB0aGlzIHRvIGJcbiAgICovXG4gIHB1YmxpYyBzbGVycCggYjogUXVhdGVybmlvbiwgdDogbnVtYmVyICk6IFF1YXRlcm5pb24ge1xuICAgIHJldHVybiBRdWF0ZXJuaW9uLnNsZXJwKCB0aGlzLCBiLCB0ICk7XG4gIH1cblxuICAvKipcbiAgICogQW4gaWRlbnRpdHkgUXVhdGVybmlvbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IGlkZW50aXR5KCk6IFF1YXRlcm5pb24ge1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbiggcmF3SWRlbnRpdHlRdWF0ZXJuaW9uICk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgdHdvIG9yIG1vcmUgbWF0cmljZXMuXG4gICAqIEBwYXJhbSBxdWF0ZXJuaW9uIFF1YXRlcm5pb25zXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG11bHRpcGx5KCAuLi5xdWF0ZXJuaW9uczogUXVhdGVybmlvbltdICk6IFF1YXRlcm5pb24ge1xuICAgIGlmICggcXVhdGVybmlvbnMubGVuZ3RoID09PSAwICkge1xuICAgICAgcmV0dXJuIFF1YXRlcm5pb24uaWRlbnRpdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbiggcXVhdE11bHRpcGx5KCAuLi5xdWF0ZXJuaW9ucy5tYXAoICggcSApID0+IHEuZWxlbWVudHMgKSApICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVycG9sYXRlIGJldHdlZW4gdHdvIHF1YXRlcm5pb25zLlxuICAgKiBAcGFyYW0gYSBcImZyb21cIiBxdWF0ZXJuaW9uXG4gICAqIEBwYXJhbSBiIFwidG9cIiBxdWF0ZXJuaW9uXG4gICAqIEBwYXJhbSB0IEhvdyBtdWNoIGRvIHdlIHdhbnQgdG8gcm90YXRlIHRoZSBhIHRvIGJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc2xlcnAoIGE6IFF1YXRlcm5pb24sIGI6IFF1YXRlcm5pb24sIHQ6IG51bWJlciApOiBRdWF0ZXJuaW9uIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oIHF1YXRTbGVycCggYS5lbGVtZW50cywgYi5lbGVtZW50cywgdCApICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgcXVhdGVybmlvbiB3aGljaCByb3RhdGVzIGFyb3VuZCB4IGF4aXMuXG4gICAqIEBwYXJhbSB0aGV0YSBBbiBhbmdsZSBhcm91bmQgeCBheGlzLCBpbiBkZWdyZWVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcm90YXRpb25YKCB0aGV0YTogbnVtYmVyICk6IFF1YXRlcm5pb24ge1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbiggcXVhdFJvdGF0aW9uWCggdGhldGEgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHF1YXRlcm5pb24gd2hpY2ggcm90YXRlcyBhcm91bmQgeSBheGlzLlxuICAgKiBAcGFyYW0gdGhldGEgQW4gYW5nbGUgYXJvdW5kIHkgYXhpcywgaW4gZGVncmVlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJvdGF0aW9uWSggdGhldGE6IG51bWJlciApOiBRdWF0ZXJuaW9uIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oIHF1YXRSb3RhdGlvblkoIHRoZXRhICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBxdWF0ZXJuaW9uIHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHogYXhpcy5cbiAgICogQHBhcmFtIHRoZXRhIEFuIGFuZ2xlIGFyb3VuZCB6IGF4aXMsIGluIGRlZ3JlZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByb3RhdGlvblooIHRoZXRhOiBudW1iZXIgKTogUXVhdGVybmlvbiB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKCBxdWF0Um90YXRpb25aKCB0aGV0YSApICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgcXVhdGVybmlvbiB3aGljaCBsb29rcyBhdCB0aGUgZGlyZWN0aW9uIG9mIGBsb29rYC5cbiAgICogQHBhcmFtIGxvb2sgUG9zaXRpb24gd2hlcmUgdGhlIHF1YXRlcm5pb24gd2lsbCBsb29rIGF0XG4gICAqIEBwYXJhbSB1cCBUaGUgXCJ1cCB2ZWN0b3JcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBsb29rUm90YXRpb24oIGxvb2s6IFZlY3RvcjMsIHVwOiBWZWN0b3IzICk6IFF1YXRlcm5pb24ge1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbiggcXVhdExvb2tSb3RhdGlvbiggbG9vay5lbGVtZW50cywgdXAuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgUXVhdGVybmlvbiBvdXQgb2YgYW5nbGUgYW5kIGF4aXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21BeGlzQW5nbGUoIGF4aXM6IFZlY3RvcjMsIGFuZ2xlOiBudW1iZXIgKTogUXVhdGVybmlvbiB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKCBxdWF0RnJvbUF4aXNBbmdsZSggYXhpcy5lbGVtZW50cywgYW5nbGUgKSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgUXVhdGVybmlvbiBvdXQgb2YgYSByb3RhdGlvbiBtYXRyaXguXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21NYXRyaXg0KCBtYXRyaXg6IE1hdHJpeDQgKTogUXVhdGVybmlvbiB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKCBxdWF0RnJvbU1hdHJpeDQoIG1hdHJpeC5lbGVtZW50cyApICk7XG4gIH1cbn1cbiIsIi8qKlxuICogR0xTTCBTdHlsZSBgbW9kYCBmdW5jdGlvbi5cbiAqIFwiY29tcHV0ZSB2YWx1ZSBvZiBvbmUgcGFyYW1ldGVyIG1vZHVsbyBhbm90aGVyXCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vZCggdmFsdWU6IG51bWJlciwgZGl2aXNvcjogbnVtYmVyICk6IG51bWJlciB7XG4gIHJldHVybiB2YWx1ZSAtIE1hdGguZmxvb3IoIHZhbHVlIC8gZGl2aXNvciApICogZGl2aXNvcjtcbn1cbiIsImltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kJztcblxuLyoqXG4gKiBFbmNsb3NlIGFyYml0cmFyeSBhbmdsZSAoaW4gcmFkaWFuKSBpbnRvIFstz4AsIM+AKVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVBbmdsZSggYW5nbGU6IG51bWJlciApOiBudW1iZXIge1xuICByZXR1cm4gbW9kKCBhbmdsZSArIE1hdGguUEksIDIuMCAqIE1hdGguUEkgKSAtIE1hdGguUEk7XG59XG4iLCJpbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHNhbml0aXplQW5nbGUgfSBmcm9tICcuLi9zYW5pdGl6ZUFuZ2xlJztcbmltcG9ydCB7IHZlY01hbmhhdHRhbkxlbmd0aCB9IGZyb20gJy4uL3ZlYy92ZWNNYW5oYXR0YW5MZW5ndGgnO1xuaW1wb3J0IHR5cGUgeyBFdWxlck9yZGVyIH0gZnJvbSAnLi9FdWxlck9yZGVyJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4uL21hdDMvUmF3TWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFJldHVybiBhIGV1bGVyIGFuZ2xlcyBvdXQgb2YgYSBtYXRyaXgzLlxuICogTWFrZSBzdXJlIHRoZSBpbnB1dCBtYXRyaXggaXMgbm9ybWFsaXplZC5cbiAqXG4gKiBAcGFyYW0gbSBBbiBpbnB1dCByb3RhdGlvbiBtYXRyaXhcbiAqIEBwYXJhbSBvcmRlciBBbiBvcmRlciBvZiBvdXRwdXQgZXVsZXIgYW5nbGVzLiBBc3N1bWUgYXMgYFhZWmAgaWYgbm90IHNwZWNpZmllZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXVsZXJGcm9tTWF0MyggbTogUmF3TWF0cml4Mywgb3JkZXI/OiBFdWxlck9yZGVyICk6IFJhd1ZlY3RvcjMge1xuICBjb25zdCBbIGksIGosIGssIHNpZ24gXSA9XG4gICAgIW9yZGVyIHx8IG9yZGVyID09PSAnWFlaJyA/IFsgMCwgMSwgMiwgMSBdIDpcbiAgICBvcmRlciA9PT0gJ1haWScgPyBbIDAsIDIsIDEsIC0xIF0gOlxuICAgIG9yZGVyID09PSAnWVhaJyA/IFsgMSwgMCwgMiwgLTEgXSA6XG4gICAgb3JkZXIgPT09ICdZWlgnID8gWyAxLCAyLCAwLCAxIF0gOlxuICAgIG9yZGVyID09PSAnWlhZJyA/IFsgMiwgMCwgMSwgMSBdIDpcbiAgICBbIDIsIDEsIDAsIC0xIF07XG5cbiAgY29uc3QgcmVzdWx0OiBSYXdWZWN0b3IzID0gWyAwLjAsIDAuMCwgMC4wIF07XG5cbiAgY29uc3QgYyA9IG1bIGsgKyBpICogMyBdO1xuICByZXN1bHRbIGogXSA9IC1zaWduICogTWF0aC5hc2luKCBjbGFtcCggYywgLTEuMCwgMS4wICkgKTtcblxuICBpZiAoIE1hdGguYWJzKCBjICkgPCAwLjk5OTk5OSApIHtcbiAgICByZXN1bHRbIGkgXSA9IHNpZ24gKiBNYXRoLmF0YW4yKCBtWyBrICsgaiAqIDMgXSwgbVsgayAqIDQgXSApO1xuICAgIHJlc3VsdFsgayBdID0gc2lnbiAqIE1hdGguYXRhbjIoIG1bIGogKyBpICogMyBdLCBtWyBpICogNCBdICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gXCJ5IGlzIDkwZGVnXCIgY2FzZXNcbiAgICByZXN1bHRbIGkgXSA9IHNpZ24gKiBNYXRoLmF0YW4yKCAtbVsgaiArIGsgKiAzIF0sIG1bIGogKiA0IF0gKTtcbiAgfVxuXG4gIGlmICggdmVjTWFuaGF0dGFuTGVuZ3RoKCByZXN1bHQgKSA+IDEuNSAqIE1hdGguUEkgKSB7XG4gICAgLy8gXCJ0d28gYmlnIHJldm9sdXRpb25zXCIgY2FzZXNcbiAgICByZXN1bHRbIGkgXSA9IHNhbml0aXplQW5nbGUoIHJlc3VsdFsgaSBdICsgTWF0aC5QSSApO1xuICAgIHJlc3VsdFsgaiBdID0gc2FuaXRpemVBbmdsZSggTWF0aC5QSSAtIHJlc3VsdFsgaiBdICk7XG4gICAgcmVzdWx0WyBrIF0gPSBzYW5pdGl6ZUFuZ2xlKCByZXN1bHRbIGsgXSArIE1hdGguUEkgKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgeyBldWxlckZyb21NYXQzIH0gZnJvbSAnLi9ldWxlckZyb21NYXQzJztcbmltcG9ydCB7IG1hdDNGcm9tTWF0NCB9IGZyb20gJy4uL21hdDMvbWF0M0Zyb21NYXQ0JztcbmltcG9ydCB0eXBlIHsgRXVsZXJPcmRlciB9IGZyb20gJy4vRXVsZXJPcmRlcic7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L1Jhd01hdHJpeDQnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBSZXR1cm4gYSBldWxlciBhbmdsZXMgb3V0IG9mIGEgbWF0cml4NC5cbiAqIE1ha2Ugc3VyZSB0aGUgaW5wdXQgbWF0cml4IGlzIG5vcm1hbGl6ZWQuXG4gKlxuICogQHBhcmFtIG0gQW4gaW5wdXQgcm90YXRpb24gbWF0cml4XG4gKiBAcGFyYW0gb3JkZXIgQW4gb3JkZXIgb2Ygb3V0cHV0IGV1bGVyIGFuZ2xlcy4gQXNzdW1lIGFzIGBYWVpgIGlmIG5vdCBzcGVjaWZpZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV1bGVyRnJvbU1hdDQoIG06IFJhd01hdHJpeDQsIG9yZGVyPzogRXVsZXJPcmRlciApOiBSYXdWZWN0b3IzIHtcbiAgcmV0dXJuIGV1bGVyRnJvbU1hdDMoIG1hdDNGcm9tTWF0NCggbSApLCBvcmRlciApO1xufVxuIiwiaW1wb3J0IHsgZXVsZXJGcm9tTWF0MyB9IGZyb20gJy4vZXVsZXJGcm9tTWF0Myc7XG5pbXBvcnQgeyBtYXQzRnJvbVF1YXRlcm5pb24gfSBmcm9tICcuLi9tYXQzL21hdDNGcm9tUXVhdGVybmlvbic7XG5pbXBvcnQgdHlwZSB7IEV1bGVyT3JkZXIgfSBmcm9tICcuL0V1bGVyT3JkZXInO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vcXVhdC9SYXdRdWF0ZXJuaW9uJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogUmV0dXJuIGEgZXVsZXIgYW5nbGVzIG91dCBvZiBhIHF1YXRlcm5pb24uXG4gKlxuICogQHBhcmFtIG0gQW4gaW5wdXQgcXVhdGVybmlvblxuICogQHBhcmFtIG9yZGVyIEFuIG9yZGVyIG9mIG91dHB1dCBldWxlciBhbmdsZXMuIEFzc3VtZSBhcyBgWFlaYCBpZiBub3Qgc3BlY2lmaWVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldWxlckZyb21RdWF0ZXJuaW9uKCBtOiBSYXdRdWF0ZXJuaW9uLCBvcmRlcj86IEV1bGVyT3JkZXIgKTogUmF3VmVjdG9yMyB7XG4gIHJldHVybiBldWxlckZyb21NYXQzKCBtYXQzRnJvbVF1YXRlcm5pb24oIG0gKSwgb3JkZXIgKTtcbn1cbiIsImltcG9ydCB0eXBlIHsgRXVsZXJPcmRlciB9IGZyb20gJy4uL2V1bGVyL0V1bGVyT3JkZXInO1xuaW1wb3J0IHR5cGUgeyBSYXdRdWF0ZXJuaW9uIH0gZnJvbSAnLi9SYXdRdWF0ZXJuaW9uJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBRdWF0ZXJuaW9uIG91dCBvZiBldWxlciBhbmdsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWF0RnJvbUV1bGVyKCBldWxlcjogUmF3VmVjdG9yMywgb3JkZXI/OiBFdWxlck9yZGVyICk6IFJhd1F1YXRlcm5pb24ge1xuICBjb25zdCBbIGksIGosIGssIHNpZ24gXSA9XG4gICAgIW9yZGVyIHx8IG9yZGVyID09PSAnWFlaJyA/IFsgMCwgMSwgMiwgMSBdIDpcbiAgICBvcmRlciA9PT0gJ1haWScgPyBbIDAsIDIsIDEsIC0xIF0gOlxuICAgIG9yZGVyID09PSAnWVhaJyA/IFsgMSwgMCwgMiwgLTEgXSA6XG4gICAgb3JkZXIgPT09ICdZWlgnID8gWyAxLCAyLCAwLCAxIF0gOlxuICAgIG9yZGVyID09PSAnWlhZJyA/IFsgMiwgMCwgMSwgMSBdIDpcbiAgICBbIDIsIDEsIDAsIC0xIF07XG5cbiAgY29uc3QgdGkgPSAwLjUgKiBldWxlclsgaSBdO1xuICBjb25zdCB0aiA9IDAuNSAqIHNpZ24gKiBldWxlclsgaiBdO1xuICBjb25zdCB0ayA9IDAuNSAqIGV1bGVyWyBrIF07XG5cbiAgY29uc3QgY2kgPSBNYXRoLmNvcyggdGkgKTtcbiAgY29uc3QgY2ogPSBNYXRoLmNvcyggdGogKTtcbiAgY29uc3QgY2sgPSBNYXRoLmNvcyggdGsgKTtcbiAgY29uc3Qgc2kgPSBNYXRoLnNpbiggdGkgKTtcbiAgY29uc3Qgc2ogPSBNYXRoLnNpbiggdGogKTtcbiAgY29uc3Qgc2sgPSBNYXRoLnNpbiggdGsgKTtcblxuICBjb25zdCByZXN1bHQ6IFJhd1F1YXRlcm5pb24gPSBbXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAwLjAsXG4gICAgY2sgKiBjaiAqIGNpICsgc2sgKiBzaiAqIHNpLFxuICBdO1xuICByZXN1bHRbIGkgXSA9IGNrICogY2ogKiBzaSAtIHNrICogc2ogKiBjaTtcbiAgcmVzdWx0WyBqIF0gPSBzaWduICogKCBjayAqIHNqICogY2kgKyBzayAqIGNqICogc2kgKTtcbiAgcmVzdWx0WyBrIF0gPSBzayAqIGNqICogY2kgLSBjayAqIHNqICogc2k7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXQzL01hdHJpeDMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdDQvTWF0cml4NCc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vcXVhdC9RdWF0ZXJuaW9uJztcbmltcG9ydCB7IGV1bGVyRnJvbU1hdDMgfSBmcm9tICcuL2V1bGVyRnJvbU1hdDMnO1xuaW1wb3J0IHsgZXVsZXJGcm9tTWF0NCB9IGZyb20gJy4vZXVsZXJGcm9tTWF0NCc7XG5pbXBvcnQgeyBldWxlckZyb21RdWF0ZXJuaW9uIH0gZnJvbSAnLi9ldWxlckZyb21RdWF0ZXJuaW9uJztcbmltcG9ydCB7IHF1YXRGcm9tRXVsZXIgfSBmcm9tICcuLi9xdWF0L3F1YXRGcm9tRXVsZXInO1xuaW1wb3J0IHR5cGUgeyBFdWxlck9yZGVyIH0gZnJvbSAnLi9FdWxlck9yZGVyJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogQW4gRXVsZXIgcm90YXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgRXVsZXIge1xuICBwdWJsaWMgZWxlbWVudHM6IFJhd1ZlY3RvcjM7IC8vIFsgeCwgeSwgeiBdXG5cbiAgLyoqXG4gICAqIEFuIG9yZGVyIG9mIHRoaXMgZXVsZXIuXG4gICAqICdYWVonIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGlzICoqZXh0cmluc2ljKiogcm90YXRpb25zICh3aGljaCBpcyBzYW1lIGFzIEJsZW5kZXIsIE1heWEsIGFuZCBVbml0eSkuXG4gICAqIFRocmVlLmpzIHVzZXMgaW50cmluc2ljIHJvdGF0aW9ucyBzbyB5b3UgaGF2ZSB0byByZXZlcnNlIHRoZSBvcmRlciBpZiB5b3Ugd2FudCB0byBtYXRjaCB0aGUgYmVoYXZpb3Igd2l0aCBUaHJlZS5qcy5cbiAgICovXG4gIHB1YmxpYyBvcmRlcjogRXVsZXJPcmRlcjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoIGVsZW1lbnRzOiBSYXdWZWN0b3IzID0gWyAwLjAsIDAuMCwgMC4wIF0sIG9yZGVyOiBFdWxlck9yZGVyID0gJ1hZWicgKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIHRoaXMub3JkZXIgPSBvcmRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiB4IGNvbXBvbmVudCBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCB4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbIDAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiB5IGNvbXBvbmVudCBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCB5KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbIDEgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiB6IGNvbXBvbmVudCBvZiB0aGlzLlxuICAgKi9cbiAgcHVibGljIGdldCB6KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbIDIgXTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgRXVsZXIoICR7IHRoaXMueC50b0ZpeGVkKCAzICkgfSwgJHsgdGhpcy55LnRvRml4ZWQoIDMgKSB9LCAkeyB0aGlzLnoudG9GaXhlZCggMyApIH0gKCR7IHRoaXMub3JkZXIgfSkgKWA7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBjbG9uZSgpOiBFdWxlciB7XG4gICAgcmV0dXJuIG5ldyBFdWxlciggdGhpcy5lbGVtZW50cy5jb25jYXQoKSBhcyBSYXdWZWN0b3IzLCB0aGlzLm9yZGVyICk7XG4gIH1cblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCBjb252ZXJ0ZWQgaW50byBhIFF1YXRlcm5pb24uXG4gICAqL1xuICBwdWJsaWMgZ2V0IHF1YXRlcm5pb24oKTogUXVhdGVybmlvbiB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKCBxdWF0RnJvbUV1bGVyKCB0aGlzLmVsZW1lbnRzLCB0aGlzLm9yZGVyICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IGNvbnZlcnRlZCBpbnRvIGEgTWF0cml4NC5cbiAgICovXG4gIHB1YmxpYyBnZXQgbWF0cml4NCgpOiBNYXRyaXg0IHtcbiAgICByZXR1cm4gdGhpcy5xdWF0ZXJuaW9uLm1hdHJpeDQ7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gRXVsZXIgb3V0IG9mIGEgbWF0cml4My5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbU1hdHJpeDMoIG1hdHJpeDogTWF0cml4Mywgb3JkZXI6IEV1bGVyT3JkZXIgKTogRXVsZXIge1xuICAgIHJldHVybiBuZXcgRXVsZXIoIGV1bGVyRnJvbU1hdDMoIG1hdHJpeC5lbGVtZW50cywgb3JkZXIgKSwgb3JkZXIgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBFdWxlciBvdXQgb2YgYSBtYXRyaXg0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tTWF0cml4NCggbWF0cml4OiBNYXRyaXg0LCBvcmRlcjogRXVsZXJPcmRlciApOiBFdWxlciB7XG4gICAgcmV0dXJuIG5ldyBFdWxlciggZXVsZXJGcm9tTWF0NCggbWF0cml4LmVsZW1lbnRzLCBvcmRlciApLCBvcmRlciApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIEV1bGVyIG91dCBvZiBhIHF1YXRlcm5pb24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uOiBRdWF0ZXJuaW9uLCBvcmRlcjogRXVsZXJPcmRlciApOiBFdWxlciB7XG4gICAgcmV0dXJuIG5ldyBFdWxlciggZXVsZXJGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbi5lbGVtZW50cywgb3JkZXIgKSwgb3JkZXIgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdmVjRG90IH0gZnJvbSAnLi4vdmVjL3ZlY0RvdCc7XG5pbXBvcnQgeyB2ZWNTdWIgfSBmcm9tICcuLi92ZWMvdmVjU3ViJztcbmltcG9ydCB0eXBlIHsgUmF3UmF5MyB9IGZyb20gJy4vUmF3UmF5Myc7XG5pbXBvcnQgdHlwZSB7IFJhd1NwaGVyZTMgfSBmcm9tICcuLi9zcGhlcmUzL1Jhd1NwaGVyZTMnO1xuXG4vKipcbiAqIFJldHVybiBkaXN0YW5jZXMgZnJvbSBnaXZlbiByYXkgdG8gc3BoZXJlLlxuICpcbiAqIFRoZSByZXR1cm5pbmcgZGlzdGFuY2UgY2FuIGJlIG5lZ2F0aXZlLlxuICpcbiAqIFRoZSBmaXJzdCByZXR1cm5pbmcgdmFsdWUgd2lsbCBiZSB0aGUgZGlzdGFuY2Ugb2YgdGhlIGluY2lkZW50IHBvaW50LlxuICogSWYgdGhlIHJheSBkb2VzIG5vdCBpbnRlcnNlY3Qgd2l0aCBzcGhlcmUsIGl0IHdpbGwgcmV0dXJuIGBudWxsYC5cbiAqXG4gKiBAcGFyYW0gcmF5IEEgcmF5XG4gKiBAcGFyYW0gc3BoZXJlIEEgdGFyZ2V0IHNwaGVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmF5M0Rpc3RhbmNlVG9TcGhlcmUoXG4gIFsgcm8sIHJkIF06IFJhd1JheTMsXG4gIHNwaGVyZTogUmF3U3BoZXJlMyxcbik6IFsgbnVtYmVyLCBudW1iZXIgXSB8IG51bGwge1xuICBjb25zdCB2ID0gdmVjU3ViKCBybywgc3BoZXJlWyAwIF0gKTtcbiAgY29uc3QgYiA9IHZlY0RvdCggdiwgcmQgKTtcbiAgY29uc3QgYyA9IHZlY0RvdCggdiwgdiApIC0gc3BoZXJlWyAxIF07XG4gIGNvbnN0IGQgPSBiICogYiAtIGM7XG5cbiAgaWYgKCBkIDwgMC4wICkgeyByZXR1cm4gbnVsbDsgfVxuXG4gIGNvbnN0IHNxcnREID0gTWF0aC5zcXJ0KCBkICk7XG5cbiAgcmV0dXJuIFsgLWIgLSBzcXJ0RCwgLWIgKyBzcXJ0RCBdO1xufVxuIiwiaW1wb3J0IHsgdmVjU3ViIH0gZnJvbSAnLi4vdmVjL3ZlY1N1Yic7XG5pbXBvcnQgdHlwZSB7IFJhd0xpbmUzIH0gZnJvbSAnLi9SYXdMaW5lMyc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFJldHVybiBhIHZlY3RvciB0aGF0IHJlcHJlc2VudHMgZGVsdGEgb2YgZ2l2ZW4gbGluZS5cbiAqXG4gKiBAcGFyYW0gbGluZSBBIGxpbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmUzRGVsdGEoIGxpbmU6IFJhd0xpbmUzICk6IFJhd1ZlY3RvcjMge1xuICByZXR1cm4gdmVjU3ViKCBsaW5lWyAxIF0sIGxpbmVbIDAgXSApO1xufVxuIiwiaW1wb3J0IHsgbGluZTNEZWx0YSB9IGZyb20gJy4uL2xpbmUzL2xpbmUzRGVsdGEnO1xuaW1wb3J0IHsgdmVjTm9ybWFsaXplIH0gZnJvbSAnLi4vdmVjL3ZlY05vcm1hbGl6ZSc7XG5pbXBvcnQgdHlwZSB7IFJhd0xpbmUzIH0gZnJvbSAnLi4vbGluZTMvUmF3TGluZTMnO1xuaW1wb3J0IHR5cGUgeyBSYXdSYXkzIH0gZnJvbSAnLi9SYXdSYXkzJztcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBsaW5lIHRvIGEgcmF5LlxuICpcbiAqIEBwYXJhbSBsaW5lIEEgbGluZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmF5M0Zyb21MaW5lMyggbGluZTogUmF3TGluZTMgKTogUmF3UmF5MyB7XG4gIHJldHVybiBbXG4gICAgbGluZVsgMCBdLFxuICAgIHZlY05vcm1hbGl6ZSggbGluZTNEZWx0YSggbGluZSApICksXG4gIF07XG59XG4iLCJpbXBvcnQgeyBMaW5lMyB9IGZyb20gJy4uL2xpbmUzL0xpbmUzJztcbmltcG9ydCB7IFNwaGVyZTMgfSBmcm9tICcuLi9zcGhlcmUzL1NwaGVyZTMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvVmVjdG9yMyc7XG5pbXBvcnQgeyByYXkzRGlzdGFuY2VUb1NwaGVyZSB9IGZyb20gJy4vcmF5M0Rpc3RhbmNlVG9TcGhlcmUnO1xuaW1wb3J0IHsgcmF5M0Zyb21MaW5lMyB9IGZyb20gJy4vcmF5M0Zyb21MaW5lMyc7XG5pbXBvcnQgdHlwZSB7IFJhd1JheTMgfSBmcm9tICcuL1Jhd1JheTMnO1xuXG4vKipcbiAqIEEgM0QgcmF5LlxuICovXG5leHBvcnQgY2xhc3MgUmF5MyB7XG4gIC8qKlxuICAgKiBUaGUgb3JpZ2luIG9mIHRoZSByYXkuXG4gICAqL1xuICBwdWJsaWMgb3JpZ2luOiBWZWN0b3IzO1xuXG4gIC8qKlxuICAgKiBUaGUgZGlyZWN0aW9uIG9mIHRoZSByYXkuXG4gICAqIE1ha2Ugc3VyZSB0aGUgZGlyZWN0aW9uIGlzIG5vcm1hbGl6ZWQuXG4gICAqL1xuICBwdWJsaWMgZGlyZWN0aW9uOiBWZWN0b3IzO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvciggc3RhcnQ6IFZlY3RvcjMgPSBWZWN0b3IzLnplcm8sIGVuZDogVmVjdG9yMyA9IFZlY3RvcjMucHogKSB7XG4gICAgdGhpcy5vcmlnaW4gPSBzdGFydDtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IGVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IHtAbGluayBSYXdSYXkzfSBmb3JtLlxuICAgKi9cbiAgcHVibGljIGdldCByYXcoKTogUmF3UmF5MyB7XG4gICAgcmV0dXJuIFsgdGhpcy5vcmlnaW4uZWxlbWVudHMsIHRoaXMuZGlyZWN0aW9uLmVsZW1lbnRzIF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGRpc3RhbmNlcyBmcm9tIGdpdmVuIHJheSB0byBzcGhlcmUuXG4gICAqXG4gICAqIFRoZSByZXR1cm5pbmcgZGlzdGFuY2UgY2FuIGJlIG5lZ2F0aXZlLlxuICAgKlxuICAgKiBUaGUgZmlyc3QgcmV0dXJuaW5nIHZhbHVlIHdpbGwgYmUgdGhlIGRpc3RhbmNlIG9mIHRoZSBpbmNpZGVudCBwb2ludC5cbiAgICogSWYgdGhlIHJheSBkb2VzIG5vdCBpbnRlcnNlY3Qgd2l0aCBzcGhlcmUsIGl0IHdpbGwgcmV0dXJuIGBudWxsYC5cbiAgICpcbiAgICogQHBhcmFtIHNwaGVyZSBBIHRhcmdldCBzcGhlcmVcbiAgICovXG4gIHB1YmxpYyBkaXN0YW5jZVRvU3BoZXJlKCBzcGhlcmU6IFNwaGVyZTMgKTogWyBudW1iZXIsIG51bWJlciBdIHwgbnVsbCB7XG4gICAgcmV0dXJuIHJheTNEaXN0YW5jZVRvU3BoZXJlKCB0aGlzLnJhdywgc3BoZXJlLnJhdyApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQge0BsaW5rIFJhd1JheTN9IHRvIGNsYXNzIGZvcm0uXG4gICAqIEBwYXJhbSByYXkgQSB7QGxpbmsgUmF3UmF5M31cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVJhdyggcmF5OiBSYXdSYXkzICk6IFJheTMge1xuICAgIHJldHVybiBuZXcgUmF5MyggbmV3IFZlY3RvcjMoIHJheVsgMCBdICksIG5ldyBWZWN0b3IzKCByYXlbIDEgXSApICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmF5IG91dCBvZiBhIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSBsaW5lIEEge0BsaW5rIExpbmUzfVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tTGluZTMoIGxpbmU6IExpbmUzICk6IFJheTMge1xuICAgIHJldHVybiBSYXkzLmZyb21SYXcoIHJheTNGcm9tTGluZTMoIGxpbmUucmF3ICkgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdmVjM0FwcGx5TWF0cml4NCB9IGZyb20gJy4uL3ZlYzMvdmVjM0FwcGx5TWF0cml4NCc7XG5pbXBvcnQgdHlwZSB7IFJhd0xpbmUzIH0gZnJvbSAnLi9SYXdMaW5lMyc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L1Jhd01hdHJpeDQnO1xuXG4vKipcbiAqIEFwcGx5IGdpdmVuIG1hdHJpeDQgdG8gZ2l2ZW4gbGluZS5cbiAqXG4gKiBAcGFyYW0gbGluZSBBIGxpbmVcbiAqIEBwYXJhbSBtYXRyaXggQSBtYXRyaXg0IHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgbGluZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZTNBcHBseU1hdHJpeDQoXG4gIFsgc3RhcnQsIGVuZCBdOiBSYXdMaW5lMyxcbiAgbWF0cml4OiBSYXdNYXRyaXg0LFxuKTogUmF3TGluZTMge1xuICByZXR1cm4gW1xuICAgIHZlYzNBcHBseU1hdHJpeDQoIHN0YXJ0LCBtYXRyaXggKSxcbiAgICB2ZWMzQXBwbHlNYXRyaXg0KCBlbmQsIG1hdHJpeCApLFxuICBdO1xufVxuIiwiaW1wb3J0IHsgdmVjQWRkIH0gZnJvbSAnLi4vdmVjL3ZlY0FkZCc7XG5pbXBvcnQgeyB2ZWNTY2FsZSB9IGZyb20gJy4uL3ZlYy92ZWNTY2FsZSc7XG5pbXBvcnQgdHlwZSB7IFJhd0xpbmUzIH0gZnJvbSAnLi9SYXdMaW5lMyc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFJldHVybiBhIHZlY3RvciB0aGF0IHJlcHJlc2VudHMgYSBjZXJ0YWluIHBvaW50IG9mIGdpdmVuIGxpbmUuXG4gKiBTYW1lIGFzIHN0YXJ0IGF0IHQgPSAwLCBzYW1lIGFzIGVuZCBhdCB0ID0gMS5cbiAqXG4gKiBAcGFyYW0gbGluZSBBIGxpbmVcbiAqIEBwYXJhbSB0IEEgcGFyYW1ldGVyIHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmUzQXQoIGxpbmU6IFJhd0xpbmUzLCB0OiBudW1iZXIgKTogUmF3VmVjdG9yMyB7XG4gIHJldHVybiB2ZWNBZGQoXG4gICAgdmVjU2NhbGUoIGxpbmVbIDAgXSwgMS4wIC0gdCApLFxuICAgIHZlY1NjYWxlKCBsaW5lWyAxIF0sIHQgKSxcbiAgKTtcbn1cbiIsImltcG9ydCB7IGxpbmUzQXQgfSBmcm9tICcuL2xpbmUzQXQnO1xuaW1wb3J0IHsgc2F0dXJhdGUgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyB2ZWNEb3QgfSBmcm9tICcuLi92ZWMvdmVjRG90JztcbmltcG9ydCB7IHZlY1N1YiB9IGZyb20gJy4uL3ZlYy92ZWNTdWInO1xuaW1wb3J0IHR5cGUgeyBSYXdMaW5lMyB9IGZyb20gJy4vUmF3TGluZTMnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBSZXR1cm4gYSBwb2ludCB0aGF0IGlzIG9uIHRoZSBnaXZlbiBsaW5lIHdoaWNoIGlzIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIHBvaW50LlxuICpcbiAqIElmIGBzZWdtZW50YCBpcyB0cnVlLCBpdCB3aWxsIHRyZWF0IHRoZSBsaW5lIGFzIGEgc2VnbWVudCB3aGljaCBoYXMgc3RhcnQgYW5kIGVuZC5cbiAqIE90aGVyd2lzZSBpdCB3aWxsIHRyZWF0IHRoZSBsaW5lIGlzIGluZmluaXRlLlxuICpcbiAqIEBwYXJhbSBsaW5lIEEgbGluZVxuICogQHBhcmFtIHBvaW50IEEgcG9pbnRcbiAqIEBwYXJhbSBzZWdtZW50IElzIHRoZSBsaW5lIGEgc2VnbWVudD9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmUzQ2xvc2VzdFBvaW50VG9Qb2ludChcbiAgbGluZTogUmF3TGluZTMsXG4gIHBvaW50OiBSYXdWZWN0b3IzLFxuICBzZWdtZW50PzogYm9vbGVhbixcbik6IFJhd1ZlY3RvcjMge1xuICBjb25zdCBhcCA9IHZlY1N1YiggcG9pbnQsIGxpbmVbIDAgXSApO1xuICBjb25zdCBhYiA9IHZlY1N1YiggbGluZVsgMSBdLCBsaW5lWyAwIF0gKTtcblxuICBsZXQgdCA9IHZlY0RvdCggYXAsIGFiICkgLyB2ZWNEb3QoIGFiLCBhYiApO1xuICBzZWdtZW50ICYmICggdCA9IHNhdHVyYXRlKCB0ICkgKTtcblxuICByZXR1cm4gbGluZTNBdCggbGluZSwgdCApO1xufVxuIiwiaW1wb3J0IHsgbGluZTNDbG9zZXN0UG9pbnRUb1BvaW50IH0gZnJvbSAnLi9saW5lM0Nsb3Nlc3RQb2ludFRvUG9pbnQnO1xuaW1wb3J0IHsgdmVjTGVuZ3RoIH0gZnJvbSAnLi4vdmVjL3ZlY0xlbmd0aCc7XG5pbXBvcnQgeyB2ZWNTdWIgfSBmcm9tICcuLi92ZWMvdmVjU3ViJztcbmltcG9ydCB0eXBlIHsgUmF3TGluZTMgfSBmcm9tICcuL1Jhd0xpbmUzJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogUmV0dXJuIGEgZGlzdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gbGluZSB0byB0aGUgZ2l2ZW4gcG9pbnQuXG4gKlxuICogSWYgYHNlZ21lbnRgIGlzIHRydWUsIGl0IHdpbGwgdHJlYXQgdGhlIGxpbmUgYXMgYSBzZWdtZW50IHdoaWNoIGhhcyBzdGFydCBhbmQgZW5kLlxuICogT3RoZXJ3aXNlIGl0IHdpbGwgdHJlYXQgdGhlIGxpbmUgaXMgaW5maW5pdGUuXG4gKlxuICogQHBhcmFtIGxpbmUgQSBsaW5lXG4gKiBAcGFyYW0gcG9pbnQgQSBwb2ludFxuICogQHBhcmFtIHNlZ21lbnQgSXMgdGhlIGxpbmUgYSBzZWdtZW50P1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZTNEaXN0YW5jZVRvUG9pbnQoXG4gIGxpbmU6IFJhd0xpbmUzLFxuICBwb2ludDogUmF3VmVjdG9yMyxcbiAgc2VnbWVudD86IGJvb2xlYW4sXG4pOiBudW1iZXIge1xuICByZXR1cm4gdmVjTGVuZ3RoKCB2ZWNTdWIoXG4gICAgbGluZTNDbG9zZXN0UG9pbnRUb1BvaW50KCBsaW5lLCBwb2ludCwgc2VnbWVudCApLFxuICAgIHBvaW50LFxuICApICk7XG59XG4iLCJpbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0NC9NYXRyaXg0JztcbmltcG9ydCB7IFJheTMgfSBmcm9tICcuLi9yYXkzL1JheTMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvVmVjdG9yMyc7XG5pbXBvcnQgeyBsaW5lM0FwcGx5TWF0cml4NCB9IGZyb20gJy4vbGluZTNBcHBseU1hdHJpeDQnO1xuaW1wb3J0IHsgbGluZTNBdCB9IGZyb20gJy4vbGluZTNBdCc7XG5pbXBvcnQgeyBsaW5lM0Nsb3Nlc3RQb2ludFRvUG9pbnQgfSBmcm9tICcuL2xpbmUzQ2xvc2VzdFBvaW50VG9Qb2ludCc7XG5pbXBvcnQgeyBsaW5lM0RlbHRhIH0gZnJvbSAnLi9saW5lM0RlbHRhJztcbmltcG9ydCB7IGxpbmUzRGlzdGFuY2VUb1BvaW50IH0gZnJvbSAnLi9saW5lM0Rpc3RhbmNlVG9Qb2ludCc7XG5pbXBvcnQgdHlwZSB7IFJhd0xpbmUzIH0gZnJvbSAnLi9SYXdMaW5lMyc7XG5cbi8qKlxuICogQSAzRCBsaW5lLlxuICovXG5leHBvcnQgY2xhc3MgTGluZTMge1xuICBwdWJsaWMgc3RhcnQ6IFZlY3RvcjM7XG4gIHB1YmxpYyBlbmQ6IFZlY3RvcjM7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBzdGFydDogVmVjdG9yMyA9IFZlY3RvcjMuemVybywgZW5kOiBWZWN0b3IzID0gVmVjdG9yMy56ZXJvICkge1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IHtAbGluayBSYXdMaW5lM30gZm9ybS5cbiAgICovXG4gIHB1YmxpYyBnZXQgcmF3KCk6IFJhd0xpbmUzIHtcbiAgICByZXR1cm4gWyB0aGlzLnN0YXJ0LmVsZW1lbnRzLCB0aGlzLmVuZC5lbGVtZW50cyBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0c2VsZiBidXQgYSByYXkuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHJheSgpOiBSYXkzIHtcbiAgICByZXR1cm4gUmF5My5mcm9tTGluZTMoIHRoaXMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHZlY3RvciB0aGF0IHJlcHJlc2VudHMgZGVsdGEgb2YgdGhlIGxpbmUuXG4gICAqL1xuICBwdWJsaWMgZGVsdGEoKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCBsaW5lM0RlbHRhKCB0aGlzLnJhdyApICk7XG4gIH1cblxuICAvKipcbiAgICogSXRzIGxlbmd0aC5cbiAgICovXG4gIHB1YmxpYyBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5kZWx0YS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgdmVjdG9yIHRoYXQgcmVwcmVzZW50cyBhIGNlcnRhaW4gcG9pbnQgb2YgdGhlIGxpbmUuXG4gICAqIFNhbWUgYXMgc3RhcnQgYXQgdCA9IDAsIHNhbWUgYXMgZW5kIGF0IHQgPSAxLlxuICAgKlxuICAgKiBAcGFyYW0gdCBBIHBhcmFtZXRlciB0XG4gICAqL1xuICBwdWJsaWMgYXQoIHQ6IG51bWJlciApOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoIGxpbmUzQXQoIHRoaXMucmF3LCB0ICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBnaXZlbiBtYXRyaXg0IHRvIHRoZSBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0gbWF0cml4IEEgbWF0cml4NCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGxpbmVcbiAgICovXG4gIHB1YmxpYyBhcHBseU1hdHJpeDQoIG1hdHJpeDogTWF0cml4NCApOiBMaW5lMyB7XG4gICAgcmV0dXJuIExpbmUzLmZyb21SYXcoXG4gICAgICBsaW5lM0FwcGx5TWF0cml4NChcbiAgICAgICAgdGhpcy5yYXcsXG4gICAgICAgIG1hdHJpeC5lbGVtZW50cyxcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHBvaW50IHRoYXQgaXMgb24gdGhlIGxpbmUgd2hpY2ggaXMgY2xvc2VzdCB0byB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAqXG4gICAqIElmIGBzZWdtZW50YCBpcyB0cnVlLCBpdCB3aWxsIHRyZWF0IHRoZSBsaW5lIGFzIGEgc2VnbWVudCB3aGljaCBoYXMgc3RhcnQgYW5kIGVuZC5cbiAgICogT3RoZXJ3aXNlIGl0IHdpbGwgdHJlYXQgdGhlIGxpbmUgaXMgaW5maW5pdGUuXG4gICAqXG4gICAqIEBwYXJhbSBwb2ludCBBIHBvaW50XG4gICAqIEBwYXJhbSBzZWdtZW50IElzIHRoZSBsaW5lIGEgc2VnbWVudD9cbiAgICovXG4gIHB1YmxpYyBjbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludDogVmVjdG9yMywgc2VnbWVudDogYm9vbGVhbiApOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoIGxpbmUzQ2xvc2VzdFBvaW50VG9Qb2ludCggdGhpcy5yYXcsIHBvaW50LmVsZW1lbnRzLCBzZWdtZW50ICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBkaXN0YW5jZSBmcm9tIHRoZSBsaW5lIHRvIHRoZSBnaXZlbiBwb2ludC5cbiAgICpcbiAgICogSWYgYHNlZ21lbnRgIGlzIHRydWUsIGl0IHdpbGwgdHJlYXQgdGhlIGxpbmUgYXMgYSBzZWdtZW50IHdoaWNoIGhhcyBzdGFydCBhbmQgZW5kLlxuICAgKiBPdGhlcndpc2UgaXQgd2lsbCB0cmVhdCB0aGUgbGluZSBpcyBpbmZpbml0ZS5cbiAgICpcbiAgICogQHBhcmFtIHBvaW50IEEgcG9pbnRcbiAgICogQHBhcmFtIHNlZ21lbnQgSXMgdGhlIGxpbmUgYSBzZWdtZW50P1xuICAgKi9cbiAgcHVibGljIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQ6IFZlY3RvcjMsIHNlZ21lbnQ6IGJvb2xlYW4gKTogbnVtYmVyIHtcbiAgICByZXR1cm4gbGluZTNEaXN0YW5jZVRvUG9pbnQoIHRoaXMucmF3LCBwb2ludC5lbGVtZW50cywgc2VnbWVudCApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQge0BsaW5rIFJhd0xpbmUzfSB0byBjbGFzcyBmb3JtLlxuICAgKiBAcGFyYW0gbGluZSBBIHtAbGluayBSYXdMaW5lM31cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVJhdyggbGluZTogUmF3TGluZTMgKTogTGluZTMge1xuICAgIHJldHVybiBuZXcgTGluZTMoIG5ldyBWZWN0b3IzKCBsaW5lWyAwIF0gKSwgbmV3IFZlY3RvcjMoIGxpbmVbIDEgXSApICk7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4MiB9IGZyb20gJy4vUmF3TWF0cml4Mic7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXQyRGV0ZXJtaW5hbnQoIG06IFJhd01hdHJpeDIgKTogbnVtYmVyIHtcbiAgcmV0dXJuIG1bIDAgXSAqIG1bIDMgXSAtIG1bIDIgXSAqIG1bIDEgXTtcbn1cbiIsImltcG9ydCB7IHZlY1NjYWxlIH0gZnJvbSAnLi4vdmVjL3ZlY1NjYWxlJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4MiB9IGZyb20gJy4vUmF3TWF0cml4Mic7XG5cbi8qKlxuICogUmV0dXJuIGFuIGludmVyc2Ugb2YgZ2l2ZW4gbWF0cml4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0MkludmVyc2UoIG06IFJhd01hdHJpeDIgKTogUmF3TWF0cml4MiB7XG4gIGNvbnN0XG4gICAgbjExID0gbVsgMCBdLCBuMjEgPSBtWyAxIF0sXG4gICAgbjEyID0gbVsgMiBdLCBuMjIgPSBtWyAzIF0sXG4gICAgZGV0ID0gbjExICogbjIyIC0gbjEyICogbjIxO1xuXG4gIGlmICggZGV0ID09PSAwLjAgKSB7IHJldHVybiB2ZWNTY2FsZSggbSwgMC4wICk7IH1cblxuICByZXR1cm4gdmVjU2NhbGUoIFtcbiAgICBuMjIsIC1uMjEsXG4gICAgLW4xMiwgbjExLFxuICBdLCAxLjAgLyBkZXQgKTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3TWF0cml4MiB9IGZyb20gJy4vUmF3TWF0cml4Mic7XG5cbi8qKlxuICogUmV0dXJuIGEgbXVsdGlwbGljYXRpb24gcmVzdWx0IG9mIG1hdHJpY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Mk11bHRpcGx5KCAuLi5tYXRzOiBSYXdNYXRyaXgyW10gKTogUmF3TWF0cml4MiB7XG4gIGlmICggbWF0cy5sZW5ndGggPCAyICkge1xuICAgIHJldHVybiBtYXRzWyAwIF07XG4gIH1cblxuICBjb25zdCBhID0gbWF0cy5zaGlmdCgpITtcbiAgY29uc3QgYiA9IG1hdDJNdWx0aXBseSggLi4ubWF0cyApO1xuICBjb25zdFxuICAgIGEwMCA9IGFbIDAgXSwgYTAxID0gYVsgMSBdLFxuICAgIGExMCA9IGFbIDIgXSwgYTExID0gYVsgMyBdLFxuICAgIGIwMCA9IGJbIDAgXSwgYjAxID0gYlsgMSBdLFxuICAgIGIxMCA9IGJbIDIgXSwgYjExID0gYlsgMyBdO1xuXG4gIHJldHVybiBbXG4gICAgYTAwICogYjAwICsgYTEwICogYjAxLFxuICAgIGEwMSAqIGIwMCArIGExMSAqIGIwMSxcblxuICAgIGEwMCAqIGIxMCArIGExMCAqIGIxMSxcbiAgICBhMDEgKiBiMTAgKyBhMTEgKiBiMTEsXG4gIF07XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhd01hdHJpeDIgfSBmcm9tICcuL1Jhd01hdHJpeDInO1xuXG4vKipcbiAqIFRyYW5zcG9zZSBhIG1hdDIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXQyVHJhbnNwb3NlKFxuICBzb3VyY2U6IFJhd01hdHJpeDIsXG4pOiBSYXdNYXRyaXgyIHtcbiAgcmV0dXJuIFtcbiAgICBzb3VyY2VbIDAgXSwgc291cmNlWyAyIF0sXG4gICAgc291cmNlWyAxIF0sIHNvdXJjZVsgMyBdLFxuICBdO1xufVxuIiwiaW1wb3J0IHsgbWF0MkRldGVybWluYW50IH0gZnJvbSAnLi9tYXQyRGV0ZXJtaW5hbnQnO1xuaW1wb3J0IHsgbWF0MkludmVyc2UgfSBmcm9tICcuL21hdDJJbnZlcnNlJztcbmltcG9ydCB7IG1hdDJNdWx0aXBseSB9IGZyb20gJy4vbWF0Mk11bHRpcGx5JztcbmltcG9ydCB7IG1hdDJUcmFuc3Bvc2UgfSBmcm9tICcuL21hdDJUcmFuc3Bvc2UnO1xuaW1wb3J0IHsgdmVjU2NhbGUgfSBmcm9tICcuLi92ZWMvdmVjU2NhbGUnO1xuaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXgyIH0gZnJvbSAnLi9SYXdNYXRyaXgyJztcblxuY29uc3QgcmF3SWRlbnRpdHlNYXRyaXgyOiBSYXdNYXRyaXgyID0gW1xuICAxLjAsIDAuMCxcbiAgMC4wLCAxLjAsXG5dO1xuXG4vKipcbiAqIEEgTWF0cml4Mi5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hdHJpeDIge1xuICBwdWJsaWMgZWxlbWVudHM6IFJhd01hdHJpeDI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCB2OiBSYXdNYXRyaXgyID0gcmF3SWRlbnRpdHlNYXRyaXgyICkge1xuICAgIHRoaXMuZWxlbWVudHMgPSB2O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0c2VsZiBidXQgdHJhbnNwb3NlZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgdHJhbnNwb3NlKCk6IE1hdHJpeDIge1xuICAgIHJldHVybiBuZXcgTWF0cml4MiggbWF0MlRyYW5zcG9zZSggdGhpcy5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogSXRzIGRldGVybWluYW50LlxuICAgKi9cbiAgcHVibGljIGdldCBkZXRlcm1pbmFudCgpOiBudW1iZXIge1xuICAgIHJldHVybiBtYXQyRGV0ZXJtaW5hbnQoIHRoaXMuZWxlbWVudHMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IGludmVydGVkLlxuICAgKi9cbiAgcHVibGljIGdldCBpbnZlcnNlKCk6IE1hdHJpeDIge1xuICAgIHJldHVybiBuZXcgTWF0cml4MiggbWF0MkludmVyc2UoIHRoaXMuZWxlbWVudHMgKSApO1xuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3QgbSA9IHRoaXMuZWxlbWVudHMubWFwKCAoIHYgKSA9PiB2LnRvRml4ZWQoIDMgKSApO1xuICAgIHJldHVybiBgTWF0cml4MiggJHsgbVsgMCBdIH0sICR7IG1bIDIgXSB9OyAkeyBtWyAxIF0gfSwgJHsgbVsgMyBdIH0gKWA7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBjbG9uZSgpOiBNYXRyaXgyIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDIoIHRoaXMuZWxlbWVudHMuY29uY2F0KCkgYXMgUmF3TWF0cml4MiApO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoaXMgTWF0cml4MiBieSBvbmUgb3IgbW9yZSBNYXRyaXgycy5cbiAgICovXG4gIHB1YmxpYyBtdWx0aXBseSggLi4ubWF0cmljZXM6IE1hdHJpeDJbXSApOiBNYXRyaXgyIHtcbiAgICByZXR1cm4gTWF0cml4Mi5tdWx0aXBseSggdGhpcywgLi4ubWF0cmljZXMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGlzIE1hdHJpeDMgYnkgYSBzY2FsYXIuXG4gICAqL1xuICBwdWJsaWMgc2NhbGVTY2FsYXIoIHNjYWxhcjogbnVtYmVyICk6IE1hdHJpeDIge1xuICAgIHJldHVybiBuZXcgTWF0cml4MiggdmVjU2NhbGUoIHRoaXMuZWxlbWVudHMsIHNjYWxhciApICk7XG4gIH1cblxuICAvKipcbiAgICogQW4gaWRlbnRpdHkgTWF0cml4NC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IGlkZW50aXR5KCk6IE1hdHJpeDIge1xuICAgIHJldHVybiBuZXcgTWF0cml4MiggcmF3SWRlbnRpdHlNYXRyaXgyICk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgdHdvIG9yIG1vcmUgbWF0cmljZXMuXG4gICAqIEBwYXJhbSBtYXRyaWNlcyBNYXRyaWNlc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtdWx0aXBseSggLi4ubWF0cmljZXM6IE1hdHJpeDJbXSApOiBNYXRyaXgyIHtcbiAgICBpZiAoIG1hdHJpY2VzLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgIHJldHVybiBNYXRyaXgyLmlkZW50aXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeDIoIG1hdDJNdWx0aXBseSggLi4ubWF0cmljZXMubWFwKCAoIG0gKSA9PiBtLmVsZW1lbnRzICkgKSApO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdNYXRyaXgzIH0gZnJvbSAnLi4vbWF0My9SYXdNYXRyaXgzJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4vUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogQXBwbHkgYSB2ZWMzIGEgbWF0My5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlYzNBcHBseU1hdHJpeDMoIHY6IFJhd1ZlY3RvcjMsIG06IFJhd01hdHJpeDMgKTogUmF3VmVjdG9yMyB7XG4gIHJldHVybiBbXG4gICAgbVsgMCBdICogdlsgMCBdICsgbVsgMyBdICogdlsgMSBdICsgbVsgNiBdICogdlsgMiBdLFxuICAgIG1bIDEgXSAqIHZbIDAgXSArIG1bIDQgXSAqIHZbIDEgXSArIG1bIDcgXSAqIHZbIDIgXSxcbiAgICBtWyAyIF0gKiB2WyAwIF0gKyBtWyA1IF0gKiB2WyAxIF0gKyBtWyA4IF0gKiB2WyAyIF0sXG4gIF07XG59XG4iLCJpbXBvcnQgeyB2ZWMzQXBwbHlNYXRyaXgzIH0gZnJvbSAnLi4vdmVjMy92ZWMzQXBwbHlNYXRyaXgzJztcbmltcG9ydCB7IHZlYzNBcHBseU1hdHJpeDQgfSBmcm9tICcuLi92ZWMzL3ZlYzNBcHBseU1hdHJpeDQnO1xuaW1wb3J0IHsgdmVjRG90IH0gZnJvbSAnLi4vdmVjL3ZlY0RvdCc7XG5pbXBvcnQgeyB2ZWNOb3JtYWxpemUgfSBmcm9tICcuLi92ZWMvdmVjTm9ybWFsaXplJztcbmltcG9ydCB7IHZlY1NjYWxlIH0gZnJvbSAnLi4vdmVjL3ZlY1NjYWxlJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4uL21hdDMvUmF3TWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd01hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L1Jhd01hdHJpeDQnO1xuaW1wb3J0IHR5cGUgeyBSYXdQbGFuZTMgfSBmcm9tICcuL1Jhd1BsYW5lMyc7XG5cbi8qKlxuICogQXBwbHkgZ2l2ZW4gbWF0cml4NCB0byBnaXZlbiBwbGFuZS5cbiAqXG4gKiBAcGFyYW0gcGxhbmUgQSBwbGFuZVxuICogQHBhcmFtIG1hdHJpeCBBIG1hdHJpeDQgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwbGFuZVxuICogQHBhcmFtIG5vcm1hbE1hdHJpeCBBIG5vcm1hbE1hdHJpeCBtYWRlIG91dCBvZiB7QGxpbmsgbWF0cml4fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGxhbmUzQXBwbHlNYXRyaXg0KFxuICBbIG5vcm1hbCwgZGlzdGFuY2UgXTogUmF3UGxhbmUzLFxuICBtYXRyaXg6IFJhd01hdHJpeDQsXG4gIG5vcm1hbE1hdHJpeDogUmF3TWF0cml4Myxcbik6IFJhd1BsYW5lMyB7XG4gIC8vIG5vcm1hbOOBquOCk+OBoOOBi+OCiW5vcm1hbE1hdHJpeOW9k+OBpuOCjOOBsOODqOOCt++8gVxuICBjb25zdCBuZXdOb3JtYWwgPSB2ZWNOb3JtYWxpemUoIHZlYzNBcHBseU1hdHJpeDMoIG5vcm1hbCwgbm9ybWFsTWF0cml4ICkgKTtcblxuICAvLyDjgajjgorjgYLjgYjjgZrkuIDngrnoprPmuKzjgZfjgabjgYLjgajjgadkb3Tlj5bjgornm7TjgZfjgaHjgoPjgYrjgYbjgZzvvIFcbiAgY29uc3QgY29wbGFuYXIgPSB2ZWNTY2FsZSggbm9ybWFsLCAtZGlzdGFuY2UgKTtcbiAgY29uc3QgcmVmUG9pbnQgPSB2ZWMzQXBwbHlNYXRyaXg0KCBjb3BsYW5hciwgbWF0cml4ICk7XG4gIGNvbnN0IG5ld0Rpc3RhbmNlID0gLXZlY0RvdCggcmVmUG9pbnQsIG5vcm1hbCApO1xuXG4gIHJldHVybiBbIG5ld05vcm1hbCwgbmV3RGlzdGFuY2UgXTtcbn1cbiIsImltcG9ydCB7IHZlY0RvdCB9IGZyb20gJy4uL3ZlYy92ZWNEb3QnO1xuaW1wb3J0IHR5cGUgeyBSYXdQbGFuZTMgfSBmcm9tICcuL1Jhd1BsYW5lMyc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFJldHVybiBhIHNpZ25lZCBkaXN0YW5jZSBmcm9tIGdpdmVuIHBsYW5lIHRvIHRoZSBnaXZlbiBwb2ludC5cbiAqIE1ha2Ugc3VyZSB0aGUgYG5vcm1hbGAgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsYW5lM0Rpc3RhbmNlVG9Qb2ludChcbiAgWyBub3JtYWwsIGRpc3RhbmNlIF06IFJhd1BsYW5lMyxcbiAgcG9pbnQ6IFJhd1ZlY3RvcjMsXG4pOiBudW1iZXIge1xuICByZXR1cm4gdmVjRG90KCBub3JtYWwsIHBvaW50ICkgKyBkaXN0YW5jZTtcbn1cbiIsImltcG9ydCB7IHZlY0xlbmd0aCB9IGZyb20gJy4uL3ZlYy92ZWNMZW5ndGgnO1xuaW1wb3J0IHsgdmVjU2NhbGUgfSBmcm9tICcuLi92ZWMvdmVjU2NhbGUnO1xuaW1wb3J0IHR5cGUgeyBSYXdQbGFuZTMgfSBmcm9tICcuL1Jhd1BsYW5lMyc7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgZ2l2ZW4gcGxhbmU/XG4gKiBUaGlzIG5vcm1hbGl6ZXMgdGhlIG5vcm1hbCBhbmQgYWxzbyBkaXZpZGUgZGlzdGFuY2UgYnkgaXRzIG9yaWdpbmFsIG5vcm1hbCBsZW5ndGguXG4gKlxuICogSSBkb24ndCBjb21lIHVwIHdpdGggYW55IHVzZSBjYXNlcyBvdGhlciB0aGFuIHtAbGluayBwbGFuZXNGcm9tUHJvamVjdGlvbk1hdHJpeH0uXG4gKlxuICogQHBhcmFtIHBsYW5lIFRoZSBwbGFuZSB5b3Ugd2FudCB0byBub3JtYWxpemVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsYW5lM05vcm1hbGl6ZSggWyBub3JtYWwsIGRpc3RhbmNlIF06IFJhd1BsYW5lMyApOiBSYXdQbGFuZTMge1xuICBjb25zdCBpbnZMID0gMS4wIC8gdmVjTGVuZ3RoKCBub3JtYWwgKTtcbiAgcmV0dXJuIFsgdmVjU2NhbGUoIG5vcm1hbCwgaW52TCApLCBkaXN0YW5jZSAqIGludkwgXTtcbn1cbiIsImltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXQzL01hdHJpeDMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdDQvTWF0cml4NCc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9WZWN0b3IzJztcbmltcG9ydCB7IHBsYW5lM0FwcGx5TWF0cml4NCB9IGZyb20gJy4vcGxhbmUzQXBwbHlNYXRyaXg0JztcbmltcG9ydCB7IHBsYW5lM0Rpc3RhbmNlVG9Qb2ludCB9IGZyb20gJy4vcGxhbmUzRGlzdGFuY2VUb1BvaW50JztcbmltcG9ydCB7IHBsYW5lM05vcm1hbGl6ZSB9IGZyb20gJy4vcGxhbmUzTm9ybWFsaXplJztcbmltcG9ydCB0eXBlIHsgUmF3UGxhbmUzIH0gZnJvbSAnLi9SYXdQbGFuZTMnO1xuXG4vKipcbiAqIEEgM0QgcGxhbmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBQbGFuZTMge1xuICBwdWJsaWMgbm9ybWFsOiBWZWN0b3IzO1xuICBwdWJsaWMgZGlzdGFuY2U6IG51bWJlcjtcblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCB7QGxpbmsgUmF3UGxhbmUzfSBmb3JtLlxuICAgKi9cbiAgcHVibGljIGdldCByYXcoKTogUmF3UGxhbmUzIHtcbiAgICByZXR1cm4gWyB0aGlzLm5vcm1hbC5lbGVtZW50cywgdGhpcy5kaXN0YW5jZSBdO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZWQgcGxhbmU/XG4gICAqIFRoaXMgbm9ybWFsaXplcyB0aGUgbm9ybWFsIGFuZCBhbHNvIGRpdmlkZSBkaXN0YW5jZSBieSBpdHMgb3JpZ2luYWwgbm9ybWFsIGxlbmd0aC5cbiAgICovXG4gIHB1YmxpYyBnZXQgbm9ybWFsaXplZCgpOiBQbGFuZTMge1xuICAgIHJldHVybiBQbGFuZTMuZnJvbVJhdyggcGxhbmUzTm9ybWFsaXplKCB0aGlzLnJhdyApICk7XG4gIH1cblxuICBwdWJsaWMgY29uc3RydWN0b3IoIG5vcm1hbDogVmVjdG9yMyA9IFZlY3RvcjMucHosIGRpc3RhbmNlID0gMC4wICkge1xuICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xuICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBnaXZlbiBtYXRyaXg0IHRvIHRoZSBwbGFuZS5cbiAgICpcbiAgICogQHBhcmFtIG1hdHJpeCBBIG1hdHJpeDQgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwbGFuZVxuICAgKiBAcGFyYW0gbm9ybWFsTWF0cml4IEEgbm9ybWFsTWF0cml4IG1hZGUgb3V0IG9mIHtAbGluayBtYXRyaXh9LiBPcHRpb25hbFxuICAgKi9cbiAgcHVibGljIGFwcGx5TWF0cml4NCggbWF0cml4OiBNYXRyaXg0LCBub3JtYWxNYXRyaXg/OiBNYXRyaXgzICk6IFBsYW5lMyB7XG4gICAgcmV0dXJuIFBsYW5lMy5mcm9tUmF3KFxuICAgICAgcGxhbmUzQXBwbHlNYXRyaXg0KFxuICAgICAgICB0aGlzLnJhdyxcbiAgICAgICAgbWF0cml4LmVsZW1lbnRzLFxuICAgICAgICBub3JtYWxNYXRyaXg/LmVsZW1lbnRzID8/IG1hdHJpeC5ub3JtYWxNYXRyaXguZWxlbWVudHMsXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzaWduZWQgZGlzdGFuY2UgZnJvbSBnaXZlbiBwbGFuZSB0byB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwb2ludCBBIHBvaW50XG4gICAqL1xuICBwdWJsaWMgZGlzdGFuY2VUb1BvaW50KCBwb2ludDogVmVjdG9yMyApOiBudW1iZXIge1xuICAgIHJldHVybiBwbGFuZTNEaXN0YW5jZVRvUG9pbnQoIHRoaXMucmF3LCBwb2ludC5lbGVtZW50cyApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQge0BsaW5rIFJhd1BsYW5lM30gdG8gY2xhc3MgZm9ybS5cbiAgICogQHBhcmFtIHBsYW5lIEEge0BsaW5rIFJhd1BsYW5lM31cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVJhdyggcGxhbmU6IFJhd1BsYW5lMyApOiBQbGFuZTMge1xuICAgIHJldHVybiBuZXcgUGxhbmUzKCBuZXcgVmVjdG9yMyggcGxhbmVbIDAgXSApLCBwbGFuZVsgMSBdICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHBsYW5lM0Rpc3RhbmNlVG9Qb2ludCB9IGZyb20gJy4vcGxhbmUzRGlzdGFuY2VUb1BvaW50JztcbmltcG9ydCB0eXBlIHsgUmF3UGxhbmUzIH0gZnJvbSAnLi9SYXdQbGFuZTMnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9SYXdWZWN0b3IzJztcblxuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIHBvaW50IGlzIGNvbnRhaW5lZCBpbiBnaXZlbiBwbGFuZXMgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBwbGFuZXMgQSBsaXN0IG9mIHBsYW5lc1xuICogQHBhcmFtIHBvaW50IEEgcG9pbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsYW5lczNDb250YWluUG9pbnQoIHBsYW5lczogUmF3UGxhbmUzW10sIHBvaW50OiBSYXdWZWN0b3IzICk6IGJvb2xlYW4ge1xuICByZXR1cm4gcGxhbmVzLmV2ZXJ5KCAoIHBsYW5lICkgPT4gcGxhbmUzRGlzdGFuY2VUb1BvaW50KCBwbGFuZSwgcG9pbnQgKSA+PSAwLjAgKTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUmF3Qm94MyB9IGZyb20gJy4uL2JveDMvUmF3Qm94Myc7XG5pbXBvcnQgdHlwZSB7IFJhd1BsYW5lMyB9IGZyb20gJy4vUmF3UGxhbmUzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBwbGFuZTMgb3V0IG9mIGEge0BsaW5rIFJhd0JveDN9LlxuICpcbiAqIEBwYXJhbSBib3ggQSBib3hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsYW5lczNGcm9tQm94MyggYm94OiBSYXdCb3gzICk6IFJhd1BsYW5lM1tdIHtcbiAgcmV0dXJuIFtcbiAgICBbIFsgMS4wLCAwLjAsIDAuMCBdLCAtYm94WyAwIF1bIDAgXSBdLCAvLyB4blxuICAgIFsgWyAtMS4wLCAwLjAsIDAuMCBdLCBib3hbIDEgXVsgMCBdIF0sIC8vIHhwXG4gICAgWyBbIDAuMCwgMS4wLCAwLjAgXSwgLWJveFsgMCBdWyAxIF0gXSwgLy8geW5cbiAgICBbIFsgMC4wLCAtMS4wLCAwLjAgXSwgYm94WyAxIF1bIDEgXSBdLCAvLyB5cFxuICAgIFsgWyAwLjAsIDAuMCwgMS4wIF0sIC1ib3hbIDAgXVsgMiBdIF0sIC8vIHluXG4gICAgWyBbIDAuMCwgMC4wLCAtMS4wIF0sIGJveFsgMSBdWyAyIF0gXSwgLy8geXBcbiAgXTtcbn1cbiIsImltcG9ydCB7IHBsYW5lM05vcm1hbGl6ZSB9IGZyb20gJy4vcGxhbmUzTm9ybWFsaXplJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4NCB9IGZyb20gJy4uL21hdDQvUmF3TWF0cml4NCc7XG5pbXBvcnQgdHlwZSB7IFJhd1BsYW5lMyB9IGZyb20gJy4vUmF3UGxhbmUzJztcblxuLyoqXG4gKiBDcmVhdGUgZnJ1c3R1bSBwbGFuZXMgb3V0IG9mIGdpdmVuIHByb2plY3Rpb24gbWF0cml4LlxuICpcbiAqIEBwYXJhbSBtIEEgcHJvamVjdGlvbiBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsYW5lczNGcm9tUHJvamVjdGlvbk1hdHJpeCggbTogUmF3TWF0cml4NCApOiBSYXdQbGFuZTNbXSB7XG4gIGNvbnN0XG4gICAgbTExID0gbVsgMCBdLCBtMTIgPSBtWyA0IF0sIG0xMyA9IG1bIDggXSwgbTE0ID0gbVsgMTIgXSxcbiAgICBtMjEgPSBtWyAxIF0sIG0yMiA9IG1bIDUgXSwgbTIzID0gbVsgOSBdLCBtMjQgPSBtWyAxMyBdLFxuICAgIG0zMSA9IG1bIDIgXSwgbTMyID0gbVsgNiBdLCBtMzMgPSBtWyAxMCBdLCBtMzQgPSBtWyAxNCBdLFxuICAgIG00MSA9IG1bIDMgXSwgbTQyID0gbVsgNyBdLCBtNDMgPSBtWyAxMSBdLCBtNDQgPSBtWyAxNSBdO1xuXG4gIHJldHVybiBbXG4gICAgcGxhbmUzTm9ybWFsaXplKCBbIFsgbTQxIC0gbTExLCBtNDIgLSBtMTIsIG00MyAtIG0xMyBdLCBtNDQgLSBtMTQgXSApLCAvLyB4cFxuICAgIHBsYW5lM05vcm1hbGl6ZSggWyBbIG00MSArIG0xMSwgbTQyICsgbTEyLCBtNDMgKyBtMTMgXSwgbTQ0ICsgbTE0IF0gKSwgLy8geG5cbiAgICBwbGFuZTNOb3JtYWxpemUoIFsgWyBtNDEgLSBtMjEsIG00MiAtIG0yMiwgbTQzIC0gbTIzIF0sIG00NCAtIG0yNCBdICksIC8vIHlwXG4gICAgcGxhbmUzTm9ybWFsaXplKCBbIFsgbTQxICsgbTIxLCBtNDIgKyBtMjIsIG00MyArIG0yMyBdLCBtNDQgKyBtMjQgXSApLCAvLyB5blxuICAgIHBsYW5lM05vcm1hbGl6ZSggWyBbIG00MSAtIG0zMSwgbTQyIC0gbTMyLCBtNDMgLSBtMzMgXSwgbTQ0IC0gbTM0IF0gKSwgLy8gem5cbiAgICBwbGFuZTNOb3JtYWxpemUoIFsgWyBtNDEgKyBtMzEsIG00MiArIG0zMiwgbTQzICsgbTMzIF0sIG00NCArIG0zNCBdICksIC8vIHpwXG4gIF07XG59XG4iLCJpbXBvcnQgeyBwbGFuZTNEaXN0YW5jZVRvUG9pbnQgfSBmcm9tICcuL3BsYW5lM0Rpc3RhbmNlVG9Qb2ludCc7XG5pbXBvcnQgdHlwZSB7IFJhd0JveDMgfSBmcm9tICcuLi9ib3gzL1Jhd0JveDMnO1xuaW1wb3J0IHR5cGUgeyBSYXdQbGFuZTMgfSBmcm9tICcuL1Jhd1BsYW5lMyc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuXG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gYm94IGludGVyc2VjdHMgd2l0aCBwbGFuZXMgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBwbGFuZXMgQSBsaXN0IG9mIHBsYW5lc1xuICogQHBhcmFtIGJveCBBIGJveDNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsYW5lczNJbnRlcnNlY3RCb3gzKCBwbGFuZXM6IFJhd1BsYW5lM1tdLCBib3g6IFJhd0JveDMgKTogYm9vbGVhbiB7XG4gIHJldHVybiBwbGFuZXMuZXZlcnkoICggcGxhbmUgKSA9PiB7XG4gICAgY29uc3QgdiA9IHBsYW5lWyAwIF0ubWFwKCAoIG5jLCBpICkgPT4gYm94WyBuYyA+IDAuMCA/IDEgOiAwIF1bIGkgXSApIGFzIFJhd1ZlY3RvcjM7XG4gICAgcmV0dXJuIHBsYW5lM0Rpc3RhbmNlVG9Qb2ludCggcGxhbmUsIHYgKSA+PSAwLjA7XG4gIH0gKTtcbn1cbiIsImltcG9ydCB7IFJhd1NwaGVyZTMgfSBmcm9tICcuLi9zcGhlcmUzL1Jhd1NwaGVyZTMnO1xuaW1wb3J0IHsgcGxhbmUzRGlzdGFuY2VUb1BvaW50IH0gZnJvbSAnLi9wbGFuZTNEaXN0YW5jZVRvUG9pbnQnO1xuaW1wb3J0IHR5cGUgeyBSYXdQbGFuZTMgfSBmcm9tICcuL1Jhd1BsYW5lMyc7XG5cbi8qKlxuICogVGVzdCBpZiBnaXZlbiBzcGhlcmUgaW50ZXJzZWN0cyB3aXRoIHBsYW5lcyBvciBub3QuXG4gKlxuICogSXQgZG9lcyBub3QgZG8gc3RyaWN0IGludGVyc2VjdGlvbiB0ZXN0IGJ1dCBzdGlsbCBzaG91bGQgd29yayB3ZWxsIHdpdGggZnJ1c3R1bSBjdWxsIHVzZSBjYXNlcy5cbiAqIFNlZSB0aGUgdGVzdCBjYXNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIHBsYW5lcyBBIGxpc3Qgb2YgcGxhbmVzXG4gKiBAcGFyYW0gc3BoZXJlIEEgc3BoZXJlM1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGxhbmVzM0ludGVyc2VjdFNwaGVyZTMoIHBsYW5lczogUmF3UGxhbmUzW10sIHNwaGVyZTogUmF3U3BoZXJlMyApOiBib29sZWFuIHtcbiAgcmV0dXJuIHBsYW5lcy5ldmVyeSggKCBwbGFuZSApID0+IChcbiAgICBwbGFuZTNEaXN0YW5jZVRvUG9pbnQoIHBsYW5lLCBzcGhlcmVbIDAgXSApID49IC1zcGhlcmVbIDEgXVxuICApICk7XG59XG4iLCJpbXBvcnQgeyBCb3gzIH0gZnJvbSAnLi4vYm94My9Cb3gzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L01hdHJpeDQnO1xuaW1wb3J0IHsgUGxhbmUzIH0gZnJvbSAnLi9QbGFuZTMnO1xuaW1wb3J0IHsgU3BoZXJlMyB9IGZyb20gJy4uL3NwaGVyZTMvU3BoZXJlMyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vdmVjMy9WZWN0b3IzJztcbmltcG9ydCB7IHBsYW5lczNDb250YWluUG9pbnQgfSBmcm9tICcuL3BsYW5lczNDb250YWluUG9pbnQnO1xuaW1wb3J0IHsgcGxhbmVzM0Zyb21Cb3gzIH0gZnJvbSAnLi9wbGFuZXMzRnJvbUJveDMnO1xuaW1wb3J0IHsgcGxhbmVzM0Zyb21Qcm9qZWN0aW9uTWF0cml4IH0gZnJvbSAnLi9wbGFuZXMzRnJvbVByb2plY3Rpb25NYXRyaXgnO1xuaW1wb3J0IHsgcGxhbmVzM0ludGVyc2VjdEJveDMgfSBmcm9tICcuL3BsYW5lczNJbnRlcnNlY3RCb3gzJztcbmltcG9ydCB7IHBsYW5lczNJbnRlcnNlY3RTcGhlcmUzIH0gZnJvbSAnLi9wbGFuZXMzSW50ZXJzZWN0U3BoZXJlMyc7XG5pbXBvcnQgdHlwZSB7IFJhd1BsYW5lMyB9IGZyb20gJy4vUmF3UGxhbmUzJztcblxuLyoqXG4gKiBBIHNldCBvZiB7QGxpbmsgUGxhbmUzfS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBsYW5lczMge1xuICBwdWJsaWMgcGxhbmVzOiBQbGFuZTNbXTtcblxuICAvKipcbiAgICogSXRzZWxmIGJ1dCB7QGxpbmsgUmF3UGxhbmUzfVtdIGZvcm0uXG4gICAqL1xuICBwdWJsaWMgZ2V0IHJhdygpOiBSYXdQbGFuZTNbXSB7XG4gICAgcmV0dXJuIHRoaXMucGxhbmVzLm1hcCggKCBwbGFuZSApID0+IHBsYW5lLnJhdyApO1xuICB9XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBwbGFuZXM6IFBsYW5lM1tdICkge1xuICAgIHRoaXMucGxhbmVzID0gcGxhbmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgZ2l2ZW4gcG9pbnQgaXMgY29udGFpbmVkIGluIHRoZSBwbGFuZXMgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0gcG9pbnQgQSBwb2ludFxuICAgKi9cbiAgcHVibGljIGNvbnRhaW5Qb2ludCggcG9pbnQ6IFZlY3RvcjMgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHBsYW5lczNDb250YWluUG9pbnQoIHRoaXMucmF3LCBwb2ludC5lbGVtZW50cyApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgZ2l2ZW4gYm94IGludGVyc2VjdHMgd2l0aCB0aGUgcGxhbmVzIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIGJveCBBIGJveDNcbiAgICovXG4gIHB1YmxpYyBpbnRlcnNlY3RCb3gzKCBib3g6IEJveDMgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHBsYW5lczNJbnRlcnNlY3RCb3gzKCB0aGlzLnJhdywgYm94LnJhdyApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgZ2l2ZW4gc3BoZXJlIGludGVyc2VjdHMgd2l0aCB0aGUgcGxhbmVzIG9yIG5vdC5cbiAgICpcbiAgICogSXQgZG9lcyBub3QgZG8gc3RyaWN0IGludGVyc2VjdGlvbiB0ZXN0IGJ1dCBzdGlsbCBzaG91bGQgd29yayB3ZWxsIHdpdGggZnJ1c3R1bSBjdWxsIHVzZSBjYXNlcy5cbiAgICogU2VlIHRoZSB0ZXN0IGNhc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQHBhcmFtIHNwaGVyZSBBIHNwaGVyZTNcbiAgICovXG4gIHB1YmxpYyBpbnRlcnNlY3RTcGhlcmUzKCBzcGhlcmU6IFNwaGVyZTMgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHBsYW5lczNJbnRlcnNlY3RTcGhlcmUzKCB0aGlzLnJhdywgc3BoZXJlLnJhdyApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQge0BsaW5rIFJhd1BsYW5lM31bXSB0byBjbGFzcyBmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0gcGxhbmVzIEEge0BsaW5rIFJhd1BsYW5lM31bXVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tUmF3KCBwbGFuZXM6IFJhd1BsYW5lM1tdICk6IFBsYW5lczMge1xuICAgIHJldHVybiBuZXcgUGxhbmVzMyggcGxhbmVzLm1hcCggKCBwbGFuZSApID0+IFBsYW5lMy5mcm9tUmF3KCBwbGFuZSApICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHNldCBvZiBwbGFuZTMgb3V0IG9mIGEge0BsaW5rIFJhd0JveDN9LlxuICAgKlxuICAgKiBAcGFyYW0gYm94IEEgYm94XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21Cb3gzKCBib3g6IEJveDMgKTogUGxhbmVzMyB7XG4gICAgcmV0dXJuIFBsYW5lczMuZnJvbVJhdyggcGxhbmVzM0Zyb21Cb3gzKCBib3gucmF3ICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgZnJ1c3R1bSBwbGFuZXMgb3V0IG9mIGdpdmVuIHByb2plY3Rpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gbWF0cml4IEEgcHJvamVjdGlvbiBtYXRyaXhcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVByb2plY3Rpb25NYXRyaXgoIG1hdHJpeDogTWF0cml4NCApOiBQbGFuZXMzIHtcbiAgICByZXR1cm4gUGxhbmVzMy5mcm9tUmF3KCBwbGFuZXMzRnJvbVByb2plY3Rpb25NYXRyaXgoIG1hdHJpeC5lbGVtZW50cyApICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHZlY0xlbmd0aFNxIH0gZnJvbSAnLi4vdmVjL3ZlY0xlbmd0aFNxJztcbmltcG9ydCB7IHZlY1N1YiB9IGZyb20gJy4uL3ZlYy92ZWNTdWInO1xuaW1wb3J0IHR5cGUgeyBSYXdTcGhlcmUzIH0gZnJvbSAnLi9SYXdTcGhlcmUzJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yMyB9IGZyb20gJy4uL3ZlYzMvUmF3VmVjdG9yMyc7XG5cbi8qKlxuICogVGVzdCBpZiBnaXZlbiBwb2ludCBpcyBjb250YWluZWQgaW4gZ2l2ZW4gc3BoZXJlIG9yIG5vdC5cbiAqIEBwYXJhbSBzcGhlcmUgQSBzcGhlcmVcbiAqIEBwYXJhbSBwb2ludCBBIHBvaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGhlcmUzQ29udGFpbnNQb2ludCggc3BoZXJlOiBSYXdTcGhlcmUzLCBwb2ludDogUmF3VmVjdG9yMyApOiBib29sZWFuIHtcbiAgcmV0dXJuIHZlY0xlbmd0aFNxKCB2ZWNTdWIoIHNwaGVyZVsgMCBdLCBwb2ludCApICkgPD0gc3BoZXJlWyAxIF0gKiBzcGhlcmVbIDEgXTtcbn1cbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1ZlY3RvcjMnO1xuaW1wb3J0IHsgc3BoZXJlM0NvbnRhaW5zUG9pbnQgfSBmcm9tICcuL3NwaGVyZTNDb250YWluc1BvaW50JztcbmltcG9ydCB0eXBlIHsgUmF3U3BoZXJlMyB9IGZyb20gJy4vUmF3U3BoZXJlMyc7XG5cbi8qKlxuICogQSAzRCBzcGhlcmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGhlcmUzIHtcbiAgcHVibGljIG9yaWdpbjogVmVjdG9yMztcbiAgcHVibGljIHJhZGl1czogbnVtYmVyO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvciggb3JpZ2luOiBWZWN0b3IzID0gVmVjdG9yMy56ZXJvLCByYWRpdXM6IG51bWJlciA9IDAuMCApIHtcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgfVxuXG4gIC8qKlxuICAgKiBJdHNlbGYgYnV0IHtAbGluayBSYXdTcGhlcmUzfSBmb3JtLlxuICAgKi9cbiAgcHVibGljIGdldCByYXcoKTogUmF3U3BoZXJlMyB7XG4gICAgcmV0dXJuIFsgdGhpcy5vcmlnaW4uZWxlbWVudHMsIHRoaXMucmFkaXVzIF07XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiBnaXZlbiBwb2ludCBpcyBjb250YWluZWQgaW4gdGhlIHNwaGVyZSBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSBwb2ludCBBIHBvaW50XG4gICAqL1xuICBwdWJsaWMgY29udGFpbnNQb2ludCggcG9pbnQ6IFZlY3RvcjMgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNwaGVyZTNDb250YWluc1BvaW50KCB0aGlzLnJhdywgcG9pbnQuZWxlbWVudHMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHtAbGluayBSYXdTcGhlcmUzfSB0byBjbGFzcyBmb3JtLlxuICAgKiBAcGFyYW0gc3BoZXJlIEEge0BsaW5rIFJhd1NwaGVyZTN9XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21SYXcoIHNwaGVyZTogUmF3U3BoZXJlMyApOiBTcGhlcmUzIHtcbiAgICByZXR1cm4gbmV3IFNwaGVyZTMoIG5ldyBWZWN0b3IzKCBzcGhlcmVbIDAgXSApLCBzcGhlcmVbIDEgXSApO1xuICB9XG59XG4iLCJpbXBvcnQgeyB2ZWMzQXBwbHlNYXRyaXgzIH0gZnJvbSAnLi4vdmVjMy92ZWMzQXBwbHlNYXRyaXgzJztcbmltcG9ydCB0eXBlIHsgUmF3TWF0cml4MyB9IGZyb20gJy4uL21hdDMvUmF3TWF0cml4Myc7XG5pbXBvcnQgdHlwZSB7IFJhd1ZlY3RvcjMgfSBmcm9tICcuLi92ZWMzL1Jhd1ZlY3RvcjMnO1xuaW1wb3J0IHR5cGUgeyBSYXdWZWN0b3I0IH0gZnJvbSAnLi9SYXdWZWN0b3I0JztcblxuLyoqXG4gKiBBcHBseSBhIHZlYzQgYSBtYXQzICh3aXRoIGFuIGltcGxpY2l0IDEgb24gbTQ0KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlYzRBcHBseU1hdHJpeDMoIHY6IFJhd1ZlY3RvcjQsIG06IFJhd01hdHJpeDMgKTogUmF3VmVjdG9yNCB7XG4gIGNvbnN0IHYzOiBSYXdWZWN0b3IzID0gWyB2WyAwIF0sIHZbIDEgXSwgdlsgMiBdIF07XG4gIGNvbnN0IHh5eiA9IHZlYzNBcHBseU1hdHJpeDMoIHYzLCBtICk7XG4gIGNvbnN0IHcgPSB2WyAzIF07XG4gIHJldHVybiBbIHh5elsgMCBdLCB4eXpbIDEgXSwgeHl6WyAyIF0sIHcgXTtcbn1cbiIsImltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXQ0L01hdHJpeDQnO1xuaW1wb3J0IHsgVmVjdG9yIH0gZnJvbSAnLi4vdmVjL1ZlY3Rvcic7XG5pbXBvcnQgeyB2ZWM0QXBwbHlNYXRyaXgzIH0gZnJvbSAnLi92ZWM0QXBwbHlNYXRyaXgzJztcbmltcG9ydCB7IHZlYzRBcHBseU1hdHJpeDQgfSBmcm9tICcuL3ZlYzRBcHBseU1hdHJpeDQnO1xuaW1wb3J0IHR5cGUgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0My9NYXRyaXgzJztcbmltcG9ydCB0eXBlIHsgUmF3VmVjdG9yNCB9IGZyb20gJy4vUmF3VmVjdG9yNCc7XG5cbi8qKlxuICogQSBWZWN0b3IzLlxuICovXG5leHBvcnQgY2xhc3MgVmVjdG9yNCBleHRlbmRzIFZlY3RvcjxWZWN0b3I0PiB7XG4gIHB1YmxpYyBlbGVtZW50czogUmF3VmVjdG9yNDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoIHY6IFJhd1ZlY3RvcjQgPSBbIDAuMCwgMC4wLCAwLjAsIDAuMCBdICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IHY7XG4gIH1cblxuICAvKipcbiAgICogQW4geCBjb21wb25lbnQgb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgeCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzWyAwIF07XG4gIH1cblxuICBwdWJsaWMgc2V0IHgoIHg6IG51bWJlciApIHtcbiAgICB0aGlzLmVsZW1lbnRzWyAwIF0gPSB4O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgeSBjb21wb25lbnQgb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgeSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzWyAxIF07XG4gIH1cblxuICBwdWJsaWMgc2V0IHkoIHk6IG51bWJlciApIHtcbiAgICB0aGlzLmVsZW1lbnRzWyAxIF0gPSB5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgeiBjb21wb25lbnQgb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgeigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzWyAyIF07XG4gIH1cblxuICBwdWJsaWMgc2V0IHooIHo6IG51bWJlciApIHtcbiAgICB0aGlzLmVsZW1lbnRzWyAyIF0gPSB6O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdyBjb21wb25lbnQgb2YgdGhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgdygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzWyAzIF07XG4gIH1cblxuICBwdWJsaWMgc2V0IHcoIHo6IG51bWJlciApIHtcbiAgICB0aGlzLmVsZW1lbnRzWyAzIF0gPSB6O1xuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBWZWN0b3I0KCAkeyB0aGlzLngudG9GaXhlZCggMyApIH0sICR7IHRoaXMueS50b0ZpeGVkKCAzICkgfSwgJHsgdGhpcy56LnRvRml4ZWQoIDMgKSB9LCAkeyB0aGlzLncudG9GaXhlZCggMyApIH0gKWA7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgdGhpcyB2ZWN0b3IgYSBtYXQzICh3aXRoIGFuIGltcGxpY2l0IDEgb24gbTQ0KS5cbiAgICovXG4gIHB1YmxpYyBhcHBseU1hdHJpeDMoIG1hdHJpeDogTWF0cml4MyApOiBWZWN0b3I0IHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjQoIHZlYzRBcHBseU1hdHJpeDMoIHRoaXMuZWxlbWVudHMsIG1hdHJpeC5lbGVtZW50cyApICk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgdGhpcyB2ZWN0b3IgYnkgYSBtYXQ0LlxuICAgKi9cbiAgcHVibGljIGFwcGx5TWF0cml4NCggbWF0cml4OiBNYXRyaXg0ICk6IFZlY3RvcjQge1xuICAgIHJldHVybiBuZXcgVmVjdG9yNCggdmVjNEFwcGx5TWF0cml4NCggdGhpcy5lbGVtZW50cywgbWF0cml4LmVsZW1lbnRzICkgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfX25ldyggdjogUmF3VmVjdG9yNCApOiBWZWN0b3I0IHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjQoIHYgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZWN0b3I0KCAwLjAsIDAuMCwgMC4wLCAwLjAgKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgemVybygpOiBWZWN0b3I0IHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjQoIFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZWN0b3I0KCAxLjAsIDEuMCwgMS4wLCAxLjAgKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgb25lKCk6IFZlY3RvcjQge1xuICAgIHJldHVybiBuZXcgVmVjdG9yNCggWyAxLjAsIDEuMCwgMS4wLCAxLjAgXSApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBNaWRpUGFyc2VSZXN1bHQsIE1pZGlQYXJzZVJlc3VsdEhlYWRlciwgTWlkaVBhcnNlUmVzdWx0VHJhY2sgfSBmcm9tICcuL01pZGlQYXJzZVJlc3VsdCc7XG5pbXBvcnQgeyBhcnJheVNlcmlhbCB9IGZyb20gJy4uL2FycmF5L2FycmF5U2VyaWFsJztcblxuZnVuY3Rpb24gcmVhZFU4KCBhcnJheTogVWludDhBcnJheSwgaGVhZEJveDogWyBudW1iZXIgXSApOiBudW1iZXIge1xuICByZXR1cm4gYXJyYXlbIGhlYWRCb3hbIDAgXSArKyBdO1xufVxuXG4vKipcbiAqIEJpZyBlbmRpYW5cbiAqL1xuZnVuY3Rpb24gcmVhZFUxNiggYXJyYXk6IFVpbnQ4QXJyYXksIGhlYWRCb3g6IFsgbnVtYmVyIF0gKTogbnVtYmVyIHtcbiAgcmV0dXJuIHJlYWRVOCggYXJyYXksIGhlYWRCb3ggKSAqIDI1NiArIHJlYWRVOCggYXJyYXksIGhlYWRCb3ggKTtcbn1cblxuLyoqXG4gKiBCaWcgZW5kaWFuXG4gKi9cbmZ1bmN0aW9uIHJlYWRVMzIoIGFycmF5OiBVaW50OEFycmF5LCBoZWFkQm94OiBbIG51bWJlciBdICk6IG51bWJlciB7XG4gIHJldHVybiByZWFkVTE2KCBhcnJheSwgaGVhZEJveCApICogNjU1MzYgKyByZWFkVTE2KCBhcnJheSwgaGVhZEJveCApO1xufVxuXG5mdW5jdGlvbiByZWFkVVZhciggYXJyYXk6IFVpbnQ4QXJyYXksIGhlYWRCb3g6IFsgbnVtYmVyIF0gKTogbnVtYmVyIHtcbiAgbGV0IHYgPSAwO1xuICBmb3IgKCA7OyApIHtcbiAgICBjb25zdCB2diA9IHJlYWRVOCggYXJyYXksIGhlYWRCb3ggKTtcbiAgICB2ID0gdiAqIDEyOCArICggdnYgJiAxMjcgKTtcblxuICAgIGlmICggdnYgPCAxMjggKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoIGFycmF5OiBVaW50OEFycmF5LCBoZWFkQm94OiBbIG51bWJlciBdICk6IE1pZGlQYXJzZVJlc3VsdEhlYWRlciB7XG4gIC8vIHNraXAgdHlwZSBhbmQgbGVuZ3RoICg0KzQpXG4gIC8vIGxlbmd0aCBoYXMgdG8gYmUgNiwgdGhlcmUncyBubyBuZWVkIHRvIHBhcnNlXG4gIGhlYWRCb3hbIDAgXSArPSA4O1xuXG4gIHJldHVybiBbXG4gICAgcmVhZFUxNiggYXJyYXksIGhlYWRCb3ggKSxcbiAgICByZWFkVTE2KCBhcnJheSwgaGVhZEJveCApLFxuICAgIHJlYWRVMTYoIGFycmF5LCBoZWFkQm94ICksXG4gIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJhY2soIGFycmF5OiBVaW50OEFycmF5LCBoZWFkQm94OiBbIG51bWJlciBdICk6IE1pZGlQYXJzZVJlc3VsdFRyYWNrIHtcbiAgLy8gc2tpcCB0eXBlICg0KVxuICBoZWFkQm94WyAwIF0gKz0gNDtcblxuICBjb25zdCBlbmRPZlRyYWNrID0gaGVhZEJveFsgMCBdICsgcmVhZFUzMiggYXJyYXksIGhlYWRCb3ggKSArIDQ7XG5cbiAgY29uc3QgdHJhY2s6IE1pZGlQYXJzZVJlc3VsdFRyYWNrID0gW107XG4gIGxldCB0eXBlID0gMDtcblxuICB3aGlsZSAoIGhlYWRCb3hbIDAgXSA8IGVuZE9mVHJhY2sgKSB7XG4gICAgY29uc3QgZGVsdGEgPSByZWFkVVZhciggYXJyYXksIGhlYWRCb3ggKTtcbiAgICBjb25zdCBzdGF0dXMgPSByZWFkVTgoIGFycmF5LCBoZWFkQm94ICk7XG4gICAgdHlwZSA9IHN0YXR1cyA8IDEyOCA/IHR5cGUgOiBzdGF0dXM7XG4gICAgY29uc3QgZGF0YTAgPSBzdGF0dXMgPCAxMjggPyBzdGF0dXMgOiByZWFkVTgoIGFycmF5LCBoZWFkQm94ICk7XG5cbiAgICBpZiAoIHR5cGUgPCAweGMwICkge1xuICAgICAgLy8gbm90ZSBvbiAoOXgpLCBub3RlIG9mZiAoOHgpLCBwb2x5cGhvbmljIGtleSBwcmVzc3VyZSAoQXgpLCBjb250cm9sIGNoYW5nZSAoQngpXG5cbiAgICAgIHRyYWNrLnB1c2goIFtcbiAgICAgICAgZGVsdGEsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRhdGEwLCAvLyBub3RlIG9yIGNjIG51bWJlclxuICAgICAgICByZWFkVTgoIGFycmF5LCBoZWFkQm94ICksIC8vIHZlbG9jaXR5LCBwcmVzc3VyZSwgb3IgZGF0YVxuICAgICAgXSApO1xuICAgIH0gZWxzZSBpZiAoIHR5cGUgPT09IDB4ZmYgKSB7XG4gICAgICAvLyBtZXRhIGV2ZW50c1xuXG4gICAgICBjb25zdCBldmVudExlbmd0aCA9IHJlYWRVOCggYXJyYXksIGhlYWRCb3ggKTtcblxuICAgICAgdHJhY2sucHVzaCggW1xuICAgICAgICBkZWx0YSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZGF0YTAsXG4gICAgICAgIGFycmF5U2VyaWFsKCBldmVudExlbmd0aCApLm1hcCggKCkgPT4gcmVhZFU4KCBhcnJheSwgaGVhZEJveCApICksXG4gICAgICBdICk7XG5cbiAgICAgIGlmICggZGF0YTAgPT09IDB4MmYgKSB7IC8vIGVuZCBvZiB0cmFja1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCBgJHsgdHlwZSB9YCApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cmFjaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1pZGlQYXJzZSggYnVmZmVyOiBBcnJheUJ1ZmZlciApOiBNaWRpUGFyc2VSZXN1bHQge1xuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KCBidWZmZXIgKTtcbiAgY29uc3QgaGVhZEJveDogWyBudW1iZXIgXSA9IFsgMCBdO1xuXG4gIGNvbnN0IGhlYWRlciA9IHBhcnNlSGVhZGVyKCBhcnJheSwgaGVhZEJveCApO1xuICBjb25zdCB0cmFja3M6IE1pZGlQYXJzZVJlc3VsdFRyYWNrW10gPSBbXTtcblxuICB3aGlsZSAoIGhlYWRCb3hbIDAgXSA8IGFycmF5Lmxlbmd0aCApIHtcbiAgICB0cmFja3MucHVzaCggcGFyc2VUcmFjayggYXJyYXksIGhlYWRCb3ggKSApO1xuICB9XG5cbiAgcmV0dXJuIFsgaGVhZGVyLCB0cmFja3MgXTtcbn1cbiIsImltcG9ydCB0eXBlIHsgUG9rZXJSYW5rIH0gZnJvbSAnLi9Qb2tlclJhbmsnO1xuXG5leHBvcnQgY29uc3QgcG9rZXJSYW5rc0J5U3RyZW5ndGg6IFBva2VyUmFua1tdID0gW1xuICAnMicsXG4gICczJyxcbiAgJzQnLFxuICAnNScsXG4gICc2JyxcbiAgJzcnLFxuICAnOCcsXG4gICc5JyxcbiAgJ1QnLFxuICAnSicsXG4gICdRJyxcbiAgJ0snLFxuICAnQScsXG5dO1xuIiwiaW1wb3J0IHR5cGUgeyBQb2tlclN1aXQgfSBmcm9tICcuL1Bva2VyU3VpdCc7XG5cbmV4cG9ydCBjb25zdCBwb2tlclN1aXRzQnlJbmRleDogUG9rZXJTdWl0W10gPSBbXG4gICdjJyxcbiAgJ2QnLFxuICAnaCcsXG4gICdzJyxcbl07XG4iLCJpbXBvcnQgeyBwb2tlclJhbmtzQnlTdHJlbmd0aCB9IGZyb20gJy4vcG9rZXJSYW5rc0J5U3RyZW5ndGgnO1xuaW1wb3J0IHsgcG9rZXJTdWl0c0J5SW5kZXggfSBmcm9tICcuL3Bva2VyU3VpdHNCeUluZGV4JztcbmltcG9ydCB0eXBlIHsgUG9rZXJDYXJkIH0gZnJvbSAnLi9Qb2tlckNhcmQnO1xuXG4vKipcbiAqIENyZWF0ZSBhIDUyLWNhcmQgZGVjay5cbiAqIFlvdSBtaWdodCB3YW50IHRvIHVzZSB7QGxpbmsgc2h1ZmZsZUFycmF5fSB0byBzaHVmZmxlIHRoZSBkZWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUG9rZXJEZWNrKCk6IFBva2VyQ2FyZFtdIHtcbiAgY29uc3QgYXJyYXk6IFBva2VyQ2FyZFtdID0gW107XG5cbiAgcG9rZXJTdWl0c0J5SW5kZXgubWFwKCAoIHN1aXQgKSA9PiAoXG4gICAgcG9rZXJSYW5rc0J5U3RyZW5ndGgubWFwKCAoIHJhbmsgKSA9PiAoXG4gICAgICBhcnJheS5wdXNoKCByYW5rICsgc3VpdCBhcyBQb2tlckNhcmQgKVxuICAgICkgKVxuICApICk7XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuIiwiaW1wb3J0IHsgUG9rZXJIYW5kIH0gZnJvbSAnLi9Qb2tlckhhbmQnO1xuXG5leHBvcnQgY29uc3QgcG9rZXJIYW5kU3RyZW5ndGhNYXA6IHsgWyBoYW5kIGluIFBva2VySGFuZCBdOiBudW1iZXIgfSA9IHtcbiAgJ0hpZ2hDYXJkJzogMCxcbiAgJ09uZVBhaXInOiAxLFxuICAnVHdvUGFpcic6IDIsXG4gICdUaHJlZU9mQUtpbmQnOiAzLFxuICAnU3RyYWlnaHQnOiA0LFxuICAnRmx1c2gnOiA1LFxuICAnRnVsbEhvdXNlJzogNixcbiAgJ0ZvdXJPZkFLaW5kJzogNyxcbiAgJ1N0cmFpZ2h0Rmx1c2gnOiA4LFxufTtcbiIsImltcG9ydCB0eXBlIHsgUG9rZXJSYW5rIH0gZnJvbSAnLi9Qb2tlclJhbmsnO1xuXG5leHBvcnQgY29uc3QgcG9rZXJSYW5rU3RyZW5ndGhNYXA6IHsgWyByYW5rIGluIFBva2VyUmFuayBdOiBudW1iZXIgfSA9IHtcbiAgJzInOiAwLFxuICAnMyc6IDEsXG4gICc0JzogMixcbiAgJzUnOiAzLFxuICAnNic6IDQsXG4gICc3JzogNSxcbiAgJzgnOiA2LFxuICAnOSc6IDcsXG4gICdUJzogOCxcbiAgJ0onOiA5LFxuICAnUSc6IDEwLFxuICAnSyc6IDExLFxuICAnQSc6IDEyXG59O1xuIiwiaW1wb3J0IHR5cGUgeyBQb2tlclN1aXQgfSBmcm9tICcuL1Bva2VyU3VpdCc7XG5cbmV4cG9ydCBjb25zdCBwb2tlclN1aXRJbmRleE1hcDogeyBbIHN1aXQgaW4gUG9rZXJTdWl0IF06IG51bWJlciB9ID0ge1xuICAnYyc6IDAsXG4gICdkJzogMSxcbiAgJ2gnOiAyLFxuICAncyc6IDMsXG59O1xuIiwiaW1wb3J0IHsgcG9rZXJSYW5rU3RyZW5ndGhNYXAgfSBmcm9tICcuL3Bva2VyUmFua1N0cmVuZ3RoTWFwJztcbmltcG9ydCB7IHBva2VyU3VpdEluZGV4TWFwIH0gZnJvbSAnLi9wb2tlclN1aXRJbmRleE1hcCc7XG5pbXBvcnQgdHlwZSB7IFBva2VyQ2FyZCB9IGZyb20gJy4vUG9rZXJDYXJkJztcbmltcG9ydCB0eXBlIHsgUG9rZXJSYW5rIH0gZnJvbSAnLi9Qb2tlclJhbmsnO1xuaW1wb3J0IHR5cGUgeyBQb2tlclN1aXQgfSBmcm9tICcuL1Bva2VyU3VpdCc7XG5cbi8qKlxuICogU29ydCBnaXZlbiBhcnJheSBvZiBjYXJkcyBpbiBwbGFjZSBieSByYW5rIChhbmQgc3VpdCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0UG9rZXJDYXJkc0J5UmFuayggY2FyZHM6IFBva2VyQ2FyZFtdICk6IFBva2VyQ2FyZFtdIHtcbiAgcmV0dXJuIGNhcmRzXG4gICAgLnNvcnQoICggYSwgYiApID0+IChcbiAgICAgIHBva2VyU3VpdEluZGV4TWFwWyBhWyAxIF0gYXMgUG9rZXJTdWl0IF0gLSBwb2tlclN1aXRJbmRleE1hcFsgYlsgMSBdIGFzIFBva2VyU3VpdCBdXG4gICAgKSApXG4gICAgLnNvcnQoICggYSwgYiApID0+IChcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBhWyAwIF0gYXMgUG9rZXJSYW5rIF0gLSBwb2tlclJhbmtTdHJlbmd0aE1hcFsgYlsgMCBdIGFzIFBva2VyUmFuayBdXG4gICAgKSApO1xufVxuIiwiaW1wb3J0IHsgTWFwT2ZTZXQgfSBmcm9tICcuLi9NYXBPZlNldC9NYXBPZlNldCc7XG5pbXBvcnQgeyBwb2tlckhhbmRTdHJlbmd0aE1hcCB9IGZyb20gJy4vcG9rZXJIYW5kU3RyZW5ndGhNYXAnO1xuaW1wb3J0IHsgcG9rZXJSYW5rU3RyZW5ndGhNYXAgfSBmcm9tICcuL3Bva2VyUmFua1N0cmVuZ3RoTWFwJztcbmltcG9ydCB7IHBva2VyUmFua3NCeVN0cmVuZ3RoIH0gZnJvbSAnLi9wb2tlclJhbmtzQnlTdHJlbmd0aCc7XG5pbXBvcnQgeyBzb3J0UG9rZXJDYXJkc0J5UmFuayB9IGZyb20gJy4vc29ydFBva2VyQ2FyZHNCeVJhbmsnO1xuaW1wb3J0IHR5cGUgeyBQb2tlckNhcmQgfSBmcm9tICcuL1Bva2VyQ2FyZCc7XG5pbXBvcnQgdHlwZSB7IFBva2VySGFuZCB9IGZyb20gJy4vUG9rZXJIYW5kJztcbmltcG9ydCB0eXBlIHsgUG9rZXJSYW5rIH0gZnJvbSAnLi9Qb2tlclJhbmsnO1xuaW1wb3J0IHR5cGUgeyBQb2tlclN1aXQgfSBmcm9tICcuL1Bva2VyU3VpdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZhbHVhdGVQb2tlckhhbmRSZXN1bHQge1xuICBoYW5kOiBQb2tlckhhbmQ7XG4gIHN0cmVuZ3RoOiBudW1iZXJbXTtcbiAgY2FyZHM6IFsgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlUG9rZXJIYW5kKCBjYXJkczogUG9rZXJDYXJkW10gKTogRXZhbHVhdGVQb2tlckhhbmRSZXN1bHQge1xuICAvLyBjYXJkcyBtdXRhYmxlIGVkaXRpb25cbiAgY29uc3QgY2FyZHNfID0gY2FyZHMuY29uY2F0KCk7XG5cbiAgY29uc3QgY2FyZHNCeVJhbmsgPSBuZXcgTWFwT2ZTZXQ8UG9rZXJSYW5rLCBQb2tlckNhcmQ+KCk7XG4gIGNvbnN0IGNhcmRzQnlTdWl0ID0gbmV3IE1hcE9mU2V0PFBva2VyU3VpdCwgUG9rZXJDYXJkPigpO1xuXG4gIGNhcmRzXy5tYXAoICggY2FyZCApID0+IHtcbiAgICBjb25zdCByYW5rID0gY2FyZFsgMCBdIGFzIFBva2VyUmFuaztcbiAgICBjb25zdCBzdWl0ID0gY2FyZFsgMSBdIGFzIFBva2VyU3VpdDtcbiAgICBjYXJkc0J5UmFuay5hZGQoIHJhbmssIGNhcmQgKTtcbiAgICBjYXJkc0J5U3VpdC5hZGQoIHN1aXQsIGNhcmQgKTtcbiAgfSApO1xuXG4gIC8vIHBhaXJzXG4gIGNvbnN0IGZvdXJzOiBQb2tlclJhbmtbXSA9IFtdO1xuICBjb25zdCB0aHJlZXM6IFBva2VyUmFua1tdID0gW107XG4gIGNvbnN0IHR3b3M6IFBva2VyUmFua1tdID0gW107XG5cbiAgcG9rZXJSYW5rc0J5U3RyZW5ndGgubWFwKCAoIHJhbmsgKSA9PiB7XG4gICAgY29uc3QgY2FyZHMgPSBjYXJkc0J5UmFuay5nZXQoIHJhbmsgKTtcbiAgICBpZiAoIGNhcmRzLnNpemUgPiAzICkge1xuICAgICAgZm91cnMucHVzaCggcmFuayApO1xuICAgIH0gZWxzZSBpZiAoIGNhcmRzLnNpemUgPiAyICkge1xuICAgICAgdGhyZWVzLnB1c2goIHJhbmsgKTtcbiAgICB9IGVsc2UgaWYgKCBjYXJkcy5zaXplID4gMSApIHtcbiAgICAgIHR3b3MucHVzaCggcmFuayApO1xuICAgIH1cbiAgfSApO1xuXG4gIC8vIHN0cmFpZ2h0XG4gIGxldCBzdHJhaWdodENhcmRzOiBQb2tlckNhcmRbXSB8IHVuZGVmaW5lZDtcbiAge1xuICAgIGxldCBjdXJyZW50OiBQb2tlckNhcmRbXSA9IFtdO1xuXG4gICAgLy8gaGFuZGxlIHN0ZWVsIHdoZWVsXG4gICAgY29uc3QgYSA9IEFycmF5LmZyb20oIGNhcmRzQnlSYW5rLmdldCggJ0EnICkgKVsgMCBdO1xuICAgIGlmICggYSApIHtcbiAgICAgIGN1cnJlbnQucHVzaCggYSApO1xuICAgIH1cblxuICAgIHBva2VyUmFua3NCeVN0cmVuZ3RoLm1hcCggKCByYW5rICkgPT4ge1xuICAgICAgY29uc3QgY2FyZCA9IEFycmF5LmZyb20oIGNhcmRzQnlSYW5rLmdldCggcmFuayApIClbIDAgXTtcbiAgICAgIGlmICggY2FyZCApIHtcbiAgICAgICAgY3VycmVudC5wdXNoKCBjYXJkICk7XG5cbiAgICAgICAgaWYgKCBjdXJyZW50Lmxlbmd0aCA+IDQgKSB7XG4gICAgICAgICAgc3RyYWlnaHRDYXJkcyA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgPSBbXTtcbiAgICAgIH1cbiAgICB9ICk7XG4gIH1cblxuICAvLyBzdHJhaWdodCBmbHVzaFxuICBpZiAoIHN0cmFpZ2h0Q2FyZHMgKSB7XG4gICAgZm9yICggY29uc3QgWyBzdWl0LCBjYXJkc1NldCBdIG9mIGNhcmRzQnlTdWl0Lm1hcCApIHtcbiAgICAgIGlmICggY2FyZHNTZXQuc2l6ZSA+IDAgKSB7XG4gICAgICAgIGxldCBzdHJhaWdodEZsdXNoQ2FyZHM6IFBva2VyQ2FyZFtdIHwgdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY3VycmVudDogUG9rZXJDYXJkW10gPSBbXTtcblxuICAgICAgICAvLyBoYW5kbGUgc3RlZWwgd2hlZWxcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gJ0EnICsgc3VpdCBhcyBQb2tlckNhcmQ7XG4gICAgICAgIGNvbnN0IGEgPSBjYXJkc1NldC5oYXMoIHRhcmdldCApO1xuICAgICAgICBpZiAoIGEgKSB7XG4gICAgICAgICAgY3VycmVudC5wdXNoKCB0YXJnZXQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBva2VyUmFua3NCeVN0cmVuZ3RoLm1hcCggKCByYW5rICkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHJhbmsgKyBzdWl0IGFzIFBva2VyQ2FyZDtcbiAgICAgICAgICBpZiAoIGNhcmRzU2V0LmhhcyggdGFyZ2V0ICkgKSB7XG4gICAgICAgICAgICBjdXJyZW50LnB1c2goIHRhcmdldCApO1xuXG4gICAgICAgICAgICBpZiAoIGN1cnJlbnQubGVuZ3RoID4gNCApIHtcbiAgICAgICAgICAgICAgc3RyYWlnaHRGbHVzaENhcmRzID0gY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIGlmICggc3RyYWlnaHRGbHVzaENhcmRzICkge1xuICAgICAgICAgIHN0cmFpZ2h0Rmx1c2hDYXJkcy5zcGxpY2UoIDAsIHN0cmFpZ2h0Rmx1c2hDYXJkcy5sZW5ndGggLSA1ICk7XG5cbiAgICAgICAgICBjb25zdCBoYW5kID0gJ1N0cmFpZ2h0Rmx1c2gnO1xuICAgICAgICAgIGNvbnN0IHN0cmVuZ3RoID0gW1xuICAgICAgICAgICAgcG9rZXJIYW5kU3RyZW5ndGhNYXBbIGhhbmQgXSxcbiAgICAgICAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBzdHJhaWdodEZsdXNoQ2FyZHNbIDQgXVsgMCBdIGFzIFBva2VyUmFuayBdLFxuICAgICAgICAgIF07XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFuZCxcbiAgICAgICAgICAgIGNhcmRzOiBzdHJhaWdodEZsdXNoQ2FyZHMgYXMgWyBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCBdLFxuICAgICAgICAgICAgc3RyZW5ndGgsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGZvdXIgb2YgYSBraW5kXG4gIGlmICggZm91cnMubGVuZ3RoID4gMCApIHtcbiAgICBmb3Vycy5zb3J0KCAoIGEsIGIgKSA9PiBwb2tlclJhbmtTdHJlbmd0aE1hcFsgYSBdIC0gcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGIgXSApO1xuICAgIGZvdXJzLnNwbGljZSggMCwgZm91cnMubGVuZ3RoIC0gMSApO1xuXG4gICAgLy8gNXMsIDVjLCBLZCwgNmQsIDljLCA1ZCwgNWhcblxuICAgIGNvbnN0IHNhbWVDYXJkcyA9IEFycmF5LmZyb20oIGNhcmRzQnlSYW5rLmdldCggZm91cnNbIDAgXSApICk7XG4gICAgc2FtZUNhcmRzLm1hcCggKCBjYXJkICkgPT4gKFxuICAgICAgY2FyZHNfLnNwbGljZSggY2FyZHNfLmluZGV4T2YoIGNhcmQgKSwgMSApXG4gICAgKSApO1xuICAgIC8vIEtkLCA2ZCwgOWNcblxuICAgIHNvcnRQb2tlckNhcmRzQnlSYW5rKCBjYXJkc18gKS5zcGxpY2UoIDAsIGNhcmRzXy5sZW5ndGggLSAxICk7XG4gICAgLy8gS2RcblxuICAgIGNvbnN0IGhhbmQgPSAnRm91ck9mQUtpbmQnO1xuICAgIGNvbnN0IHN0cmVuZ3RoID0gW1xuICAgICAgcG9rZXJIYW5kU3RyZW5ndGhNYXBbIGhhbmQgXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBmb3Vyc1sgMCBdIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgY2FyZHNfWyAwIF1bIDAgXSBhcyBQb2tlclJhbmsgXSxcbiAgICBdO1xuXG4gICAgY2FyZHNfLnB1c2goIC4uLnNhbWVDYXJkcyApO1xuICAgIHNvcnRQb2tlckNhcmRzQnlSYW5rKCBjYXJkc18gKTtcbiAgICAvLyA1YywgNWQsIDVoLCA1cywgS2RcblxuICAgIHJldHVybiB7XG4gICAgICBoYW5kLFxuICAgICAgY2FyZHM6IGNhcmRzXyBhcyBbIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkIF0sXG4gICAgICBzdHJlbmd0aCxcbiAgICB9O1xuICB9XG5cbiAgLy8gZnVsbCBob3VzZVxuICBpZiAoIHRocmVlcy5sZW5ndGggPiAwICYmIHRocmVlcy5sZW5ndGggKyB0d29zLmxlbmd0aCA+IDEgKSB7XG4gICAgdGhyZWVzLnNvcnQoICggYSwgYiApID0+IHBva2VyUmFua1N0cmVuZ3RoTWFwWyBhIF0gLSBwb2tlclJhbmtTdHJlbmd0aE1hcFsgYiBdICk7XG5cbiAgICAvLyB0cmlja3kgcGFydDogaXQgaXMgcG9zc2libGUgdG8gaGF2ZSB0d28gb3IgbW9yZSB0aHJlZXMgYXQgb25jZVxuICAgIC8vIGp1c3QgdHJhbnNmZXIgdGhyZWVzIHdoaWNoIGlzIG5vdCBoaWdoZXN0XG4gICAgLy8gYW5kIHdpc2ggd2UnbGwgZG8gdGhpcyByaWdodCBpbiB0aGUgcmVzdCBvZiB0aGUgY29kZVxuICAgIHR3b3MucHVzaCggLi4udGhyZWVzLnNwbGljZSggMCwgdGhyZWVzLmxlbmd0aCAtIDEgKSApO1xuXG4gICAgdHdvcy5zb3J0KCAoIGEsIGIgKSA9PiBwb2tlclJhbmtTdHJlbmd0aE1hcFsgYSBdIC0gcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGIgXSApO1xuICAgIHR3b3Muc3BsaWNlKCAwLCB0d29zLmxlbmd0aCAtIDEgKTtcblxuICAgIC8vIDdkLCA3cywgVGMsIFRkLCA3aCwgOWQsIFRoXG5cbiAgICBjb25zdCBzYW1lQ2FyZHMgPSBBcnJheS5mcm9tKCBjYXJkc0J5UmFuay5nZXQoIHRocmVlc1sgMCBdICkgKTtcbiAgICBzYW1lQ2FyZHMucHVzaCggLi4uQXJyYXkuZnJvbSggY2FyZHNCeVJhbmsuZ2V0KCB0d29zWyAwIF0gKSApICk7XG4gICAgLy8gc2FtZUNhcmRzOiBUYywgVGQsIFRoLCA3ZCwgN3MsIDdoXG5cbiAgICBzb3J0UG9rZXJDYXJkc0J5UmFuayggc2FtZUNhcmRzICkuc3BsaWNlKCAwLCBzYW1lQ2FyZHMubGVuZ3RoIC0gNSApO1xuICAgIC8vIHNhbWVDYXJkczogN2gsIDdzLCBUYywgVGQsIFRoXG5cbiAgICBjb25zdCBoYW5kID0gJ0Z1bGxIb3VzZSc7XG4gICAgY29uc3Qgc3RyZW5ndGggPSBbXG4gICAgICBwb2tlckhhbmRTdHJlbmd0aE1hcFsgaGFuZCBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIHRocmVlc1sgMCBdIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgdHdvc1sgMCBdIF0sXG4gICAgXTtcblxuICAgIHJldHVybiB7XG4gICAgICBoYW5kLFxuICAgICAgY2FyZHM6IHNhbWVDYXJkcyBhcyBbIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkIF0sXG4gICAgICBzdHJlbmd0aCxcbiAgICB9O1xuICB9XG5cbiAgLy8gZmx1c2hcbiAgZm9yICggY29uc3QgWyBfc3VpdCwgY2FyZHNTZXQgXSBvZiBjYXJkc0J5U3VpdC5tYXAgKSB7XG4gICAgaWYgKCBjYXJkc1NldC5zaXplID4gNCApIHtcbiAgICAgIGNvbnN0IGNhcmRzID0gc29ydFBva2VyQ2FyZHNCeVJhbmsoIEFycmF5LmZyb20oIGNhcmRzU2V0ICkgKTtcbiAgICAgIGNhcmRzLnNwbGljZSggMCwgY2FyZHMubGVuZ3RoIC0gNSApO1xuXG4gICAgICBjb25zdCBoYW5kID0gJ0ZsdXNoJztcbiAgICAgIGNvbnN0IHN0cmVuZ3RoID0gW1xuICAgICAgICBwb2tlckhhbmRTdHJlbmd0aE1hcFsgaGFuZCBdLFxuICAgICAgICAuLi5jYXJkc1xuICAgICAgICAgIC5jb25jYXQoKVxuICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAubWFwKCAoIGNhcmQgKSA9PiAoXG4gICAgICAgICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgY2FyZFsgMCBdIGFzIFBva2VyUmFuayBdXG4gICAgICAgICAgKSApLFxuICAgICAgXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFuZCxcbiAgICAgICAgY2FyZHM6IGNhcmRzIGFzIFsgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQgXSxcbiAgICAgICAgc3RyZW5ndGgsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIHN0cmFpZ2h0XG4gIGlmICggc3RyYWlnaHRDYXJkcyApIHtcbiAgICBzdHJhaWdodENhcmRzLnNwbGljZSggMCwgc3RyYWlnaHRDYXJkcy5sZW5ndGggLSA1ICk7XG5cbiAgICBjb25zdCBoYW5kID0gJ1N0cmFpZ2h0JztcbiAgICBjb25zdCBzdHJlbmd0aCA9IFtcbiAgICAgIHBva2VySGFuZFN0cmVuZ3RoTWFwWyBoYW5kIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgc3RyYWlnaHRDYXJkc1sgNCBdWyAwIF0gYXMgUG9rZXJSYW5rIF0sXG4gICAgXTtcblxuICAgIHJldHVybiB7XG4gICAgICBoYW5kLFxuICAgICAgY2FyZHM6IHN0cmFpZ2h0Q2FyZHMgYXMgWyBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCBdLFxuICAgICAgc3RyZW5ndGgsXG4gICAgfTtcbiAgfVxuXG4gIC8vIHRocmVlIG9mIGEga2luZFxuICBpZiAoIHRocmVlcy5sZW5ndGggPiAwICkge1xuICAgIHRocmVlcy5zb3J0KCAoIGEsIGIgKSA9PiBwb2tlclJhbmtTdHJlbmd0aE1hcFsgYSBdIC0gcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGIgXSApO1xuICAgIHRocmVlcy5zcGxpY2UoIDAsIHRocmVlcy5sZW5ndGggLSAxICk7XG5cbiAgICAvLyBBaCwgQWQsIEtjLCA3cywgNHMsIFFjLCBBc1xuXG4gICAgY29uc3Qgc2FtZUNhcmRzID0gQXJyYXkuZnJvbSggY2FyZHNCeVJhbmsuZ2V0KCB0aHJlZXNbIDAgXSApICk7XG4gICAgc2FtZUNhcmRzLm1hcCggKCBjYXJkICkgPT4gKFxuICAgICAgY2FyZHNfLnNwbGljZSggY2FyZHNfLmluZGV4T2YoIGNhcmQgKSwgMSApXG4gICAgKSApO1xuICAgIC8vIEtjLCA3cywgNHMsIFFjXG5cbiAgICBzb3J0UG9rZXJDYXJkc0J5UmFuayggY2FyZHNfICkuc3BsaWNlKCAwLCBjYXJkc18ubGVuZ3RoIC0gMiApO1xuICAgIC8vIFFjLCBLY1xuXG4gICAgY29uc3QgaGFuZCA9ICdUaHJlZU9mQUtpbmQnO1xuICAgIGNvbnN0IHN0cmVuZ3RoID0gW1xuICAgICAgcG9rZXJIYW5kU3RyZW5ndGhNYXBbIGhhbmQgXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyB0aHJlZXNbIDAgXSBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGNhcmRzX1sgMSBdWyAwIF0gYXMgUG9rZXJSYW5rIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgY2FyZHNfWyAwIF1bIDAgXSBhcyBQb2tlclJhbmsgXSxcbiAgICBdO1xuXG4gICAgY2FyZHNfLnB1c2goIC4uLnNhbWVDYXJkcyApO1xuICAgIHNvcnRQb2tlckNhcmRzQnlSYW5rKCBjYXJkc18gKTtcbiAgICAvLyBRYywgS2MsIEFkLCBBaCwgQXNcblxuICAgIHJldHVybiB7XG4gICAgICBoYW5kLFxuICAgICAgY2FyZHM6IGNhcmRzXyBhcyBbIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkIF0sXG4gICAgICBzdHJlbmd0aCxcbiAgICB9O1xuICB9XG5cbiAgLy8gdHdvIHBhaXJcbiAgaWYgKCB0d29zLmxlbmd0aCA+IDEgKSB7XG4gICAgdHdvcy5zb3J0KCAoIGEsIGIgKSA9PiBwb2tlclJhbmtTdHJlbmd0aE1hcFsgYSBdIC0gcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGIgXSApO1xuICAgIHR3b3Muc3BsaWNlKCAwLCB0d29zLmxlbmd0aCAtIDIgKTtcblxuICAgIC8vIDRjLCA4ZCwgN2gsIDRoLCA4aCwgSmMsIDJzXG5cbiAgICBjb25zdCBwYWlycyA9IEFycmF5LmZyb20oIGNhcmRzQnlSYW5rLmdldCggdHdvc1sgMCBdICkgKTtcbiAgICBwYWlycy5wdXNoKCAuLi5BcnJheS5mcm9tKCBjYXJkc0J5UmFuay5nZXQoIHR3b3NbIDEgXSApICkgKTtcbiAgICBwYWlycy5tYXAoICggY2FyZCApID0+IChcbiAgICAgIGNhcmRzXy5zcGxpY2UoIGNhcmRzXy5pbmRleE9mKCBjYXJkICksIDEgKVxuICAgICkgKTtcbiAgICAvLyA3aCwgSmMsIDJzXG5cbiAgICBzb3J0UG9rZXJDYXJkc0J5UmFuayggY2FyZHNfICkuc3BsaWNlKCAwLCBjYXJkc18ubGVuZ3RoIC0gMSApO1xuICAgIC8vIEpjXG5cbiAgICBjb25zdCBoYW5kID0gJ1R3b1BhaXInO1xuICAgIGNvbnN0IHN0cmVuZ3RoID0gW1xuICAgICAgcG9rZXJIYW5kU3RyZW5ndGhNYXBbIGhhbmQgXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyB0d29zWyAxIF0gXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyB0d29zWyAwIF0gXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBjYXJkc19bIDAgXVsgMCBdIGFzIFBva2VyUmFuayBdLFxuICAgIF07XG5cbiAgICBjYXJkc18ucHVzaCggLi4ucGFpcnMgKTtcbiAgICBzb3J0UG9rZXJDYXJkc0J5UmFuayggY2FyZHNfICk7XG4gICAgLy8gNGMsIDRoLCA4ZCwgOGgsIEpjXG5cbiAgICByZXR1cm4ge1xuICAgICAgaGFuZCxcbiAgICAgIGNhcmRzOiBjYXJkc18gYXMgWyBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCBdLFxuICAgICAgc3RyZW5ndGgsXG4gICAgfTtcbiAgfVxuXG4gIC8vIG9uZSBwYWlyXG4gIGlmICggdHdvcy5sZW5ndGggPiAwICkge1xuICAgIC8vIDNjLCA1ZCwgOGMsIDhzLCBBYywgUWQsIDdoXG5cbiAgICBjb25zdCBwYWlyID0gQXJyYXkuZnJvbSggY2FyZHNCeVJhbmsuZ2V0KCB0d29zWyAwIF0gKSApO1xuICAgIHBhaXIubWFwKCAoIGNhcmQgKSA9PiAoXG4gICAgICBjYXJkc18uc3BsaWNlKCBjYXJkc18uaW5kZXhPZiggY2FyZCApLCAxIClcbiAgICApICk7XG4gICAgLy8gM2MsIDVkLCBBYywgUWQsIDdoXG5cbiAgICBzb3J0UG9rZXJDYXJkc0J5UmFuayggY2FyZHNfICkuc3BsaWNlKCAwLCBjYXJkc18ubGVuZ3RoIC0gMyApO1xuICAgIC8vIDdoLCBRZCwgQWNcblxuICAgIGNvbnN0IGhhbmQgPSAnT25lUGFpcic7XG4gICAgY29uc3Qgc3RyZW5ndGggPSBbXG4gICAgICBwb2tlckhhbmRTdHJlbmd0aE1hcFsgaGFuZCBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIHR3b3NbIDAgXSBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGNhcmRzX1sgMiBdWyAwIF0gYXMgUG9rZXJSYW5rIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgY2FyZHNfWyAxIF1bIDAgXSBhcyBQb2tlclJhbmsgXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBjYXJkc19bIDAgXVsgMCBdIGFzIFBva2VyUmFuayBdLFxuICAgIF07XG5cbiAgICBjYXJkc18ucHVzaCggLi4ucGFpciApO1xuICAgIHNvcnRQb2tlckNhcmRzQnlSYW5rKCBjYXJkc18gKTtcbiAgICAvLyA3aCwgOGMsIDhzLCBRZCwgQWNcblxuICAgIHJldHVybiB7XG4gICAgICBoYW5kLFxuICAgICAgY2FyZHM6IGNhcmRzXyBhcyBbIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkIF0sXG4gICAgICBzdHJlbmd0aCxcbiAgICB9O1xuICB9XG5cbiAgLy8gaGlnaCBjYXJkXG4gIHtcbiAgICBjb25zdCBoYW5kID0gJ0hpZ2hDYXJkJztcblxuICAgIC8vIDJoLCA1YywgNmMsIDdzLCBUZCwgQWQsIEtkXG5cbiAgICBzb3J0UG9rZXJDYXJkc0J5UmFuayggY2FyZHNfICk7XG4gICAgLy8gMmgsIDVjLCA2YywgN3MsIFRkLCBLZCwgQWRcblxuICAgIGNhcmRzXy5zcGxpY2UoIDAsIGNhcmRzXy5sZW5ndGggLSA1ICk7XG4gICAgLy8gNmMsIDdzLCBUZCwgS2QsIEFkXG5cbiAgICBjb25zdCBzdHJlbmd0aCA9IFtcbiAgICAgIHBva2VySGFuZFN0cmVuZ3RoTWFwWyBoYW5kIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgY2FyZHNfWyA0IF1bIDAgXSBhcyBQb2tlclJhbmsgXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBjYXJkc19bIDMgXVsgMCBdIGFzIFBva2VyUmFuayBdLFxuICAgICAgcG9rZXJSYW5rU3RyZW5ndGhNYXBbIGNhcmRzX1sgMiBdWyAwIF0gYXMgUG9rZXJSYW5rIF0sXG4gICAgICBwb2tlclJhbmtTdHJlbmd0aE1hcFsgY2FyZHNfWyAxIF1bIDAgXSBhcyBQb2tlclJhbmsgXSxcbiAgICAgIHBva2VyUmFua1N0cmVuZ3RoTWFwWyBjYXJkc19bIDAgXVsgMCBdIGFzIFBva2VyUmFuayBdLFxuICAgIF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgaGFuZCxcbiAgICAgIGNhcmRzOiBjYXJkc18gYXMgWyBQb2tlckNhcmQsIFBva2VyQ2FyZCwgUG9rZXJDYXJkLCBQb2tlckNhcmQsIFBva2VyQ2FyZCBdLFxuICAgICAgc3RyZW5ndGgsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBQb2tlckhhbmQgfSBmcm9tICcuL1Bva2VySGFuZCc7XG5cbmV4cG9ydCBjb25zdCBwb2tlckhhbmRzQnlTdHJlbmd0aDogUG9rZXJIYW5kW10gPSBbXG4gICdIaWdoQ2FyZCcsXG4gICdPbmVQYWlyJyxcbiAgJ1R3b1BhaXInLFxuICAnVGhyZWVPZkFLaW5kJyxcbiAgJ1N0cmFpZ2h0JyxcbiAgJ0ZsdXNoJyxcbiAgJ0Z1bGxIb3VzZScsXG4gICdGb3VyT2ZBS2luZCcsXG4gICdTdHJhaWdodEZsdXNoJyxcbl07XG4iLCIvKipcbiAqIFJldHJ5IGdpdmVuIGZ1bmN0aW9uIGZvciBuIHRpbWVzLlxuICpcbiAqIFNlZSBhbHNvOiB7QGxpbmsgcmV0cnl9XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY1JldHJ5PFQ+KCBmdW5jOiAoKSA9PiBQcm9taXNlPFQ+LCBuOiBudW1iZXIgKTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBhd2FpdCBmdW5jKCkuY2F0Y2goICggZXJyb3IgKSA9PiB7XG4gICAgaWYgKCBuIDw9IDEgKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXN5bmNSZXRyeSggZnVuYywgbiAtIDEgKTtcbiAgfSApO1xufVxuIiwiLyoqXG4gKiBSZXRyeSBnaXZlbiBmdW5jdGlvbiBmb3IgbiB0aW1lcy5cbiAqXG4gKiBTZWUgYWxzbzoge0BsaW5rIGFzeW5jUmV0cnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRyeTxUPiggZnVuYzogKCkgPT4gVCwgbjogbnVtYmVyICk6IFQge1xuICB0cnkge1xuICAgIHJldHVybiBmdW5jKCk7XG4gIH0gY2F0Y2ggKCBlcnJvciApIHtcbiAgICBpZiAoIG4gPD0gMSApIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiByZXRyeSggZnVuYywgbiAtIDEgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgU1ROSUNDQ0ZyYW1lIH0gZnJvbSAnLi9TVE5JQ0NDRnJhbWUnO1xuXG4vKipcbiAqIFJlZjogaHR0cDovL2Fyc2FudGljYS1vbmxpbmUuY29tL3N0LW5pY2NjLWNvbXBldGl0aW9uL1xuICpcbiAqIEBwYXJhbSBidWZmZXIgVGhlIGlucHV0IFNULU5JQ0NDIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU1ROSUNDQyggYnVmZmVyOiBBcnJheUJ1ZmZlciApOiBTVE5JQ0NDRnJhbWVbXSB7XG4gIGNvbnN0IGZyYW1lczogU1ROSUNDQ0ZyYW1lW10gPSBbXTtcblxuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KCBidWZmZXIgKTtcblxuICBjb25zdCBwYWxldHRlID0gbmV3IFVpbnQxNkFycmF5KCAxNiApO1xuXG4gIGxldCBoZWFkID0gMDtcblxuICAvLyB3aGVuIHBvbHktZGVzY3JpcHRvciBzYXlzIDB4ZmVcbiAgbGV0IHNob3VsZFNraXAgPSBmYWxzZTtcblxuICAvLyB3aGVuIHBvbHktZGVzY3JpcHRvciBzYXlzIDB4ZmRcbiAgbGV0IHNob3VsZEVuZCA9IGZhbHNlO1xuXG4gIC8vID4gRXZlcnkgZnJhbWUgc3RvcmVzIHRoZSBmb2xsb3dpbmcgZGF0YTpcbiAgZm9yICggOzsgKSB7XG4gICAgLy8gPiAxIGJ5dGUgRmxhZ3MgQml0IDA6IEZyYW1lIG5lZWRzIHRvIGNsZWFyIHRoZSBzY3JlZW4uXG4gICAgLy8gPiBCaXQgMTogRnJhbWUgY29udGFpbnMgcGFsZXR0ZSBkYXRhLlxuICAgIC8vID4gQml0IDI6IEZyYW1lIGlzIHN0b3JlZCBpbiBpbmRleGVkIG1vZGUuXG4gICAgY29uc3QgZmxhZ3MgPSBhcnJheVsgaGVhZCArKyBdO1xuICAgIGNvbnN0IG5lZWRzQ2xlYXIgPSAoIGZsYWdzICYgMSApID09PSAxO1xuICAgIGNvbnN0IGhhc1BhbGV0dGUgPSAoIGZsYWdzID4+IDEgJiAxICkgPT09IDE7XG4gICAgY29uc3QgaW5kZXhlZE1vZGUgPSAoIGZsYWdzID4+IDIgJiAxICkgPT09IDE7XG5cbiAgICAvLyA+IElmIGZyYW1lIGNvbnRhaW5zIHBhbGV0dGUgZGF0YVxuICAgIGlmICggaGFzUGFsZXR0ZSApIHtcbiAgICAgIC8vID4gMSB3b3JkIEJpdG1hc2tcbiAgICAgIGNvbnN0IGJpdG1hc2sgPSBhcnJheVsgaGVhZCArKyBdIDw8IDggfCBhcnJheVsgaGVhZCArKyBdO1xuXG4gICAgICAvLyA+IEZvciBldmVyeSBzZXQgYml0IGluIHRoZSBCaXRtYXNrICgwLTE1KVxuICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG4gICAgICAgIGlmICggYml0bWFzayA+PiAoIDE1IC0gaSApICYgMSApIHtcbiAgICAgICAgICAvLyA+IDEgd29yZCBDb2xvciBUaGUgY29sb3IgaGFzIHRvIGJlIGNvcGllZCBpbnRvIHRoZSBwYWxldHRlIGF0IHRoZSByZXZlcnNlIGluZGV4IG9mIHRoZSBhY3R1YWwgYml0LFxuICAgICAgICAgIC8vID4gYmVjYXVzZSB0aGUgYml0bWFzayBpcyBzdG9yZWQgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgICAgICAvLyA+IEluIG90aGVyIHdvcmRzOiBJZiBiaXQgMTUgb2YgbWFzayBpcyBzZXQgLT4gdXBkYXRlIGNvbG9yIDAgb2YgcGFsZXR0ZSxcbiAgICAgICAgICAvLyA+IOKAplxuICAgICAgICAgIC8vID4gaWYgYml0IDAgb2YgbWFzayBpcyBzZXQgLT4gdXBkYXRlIGNvbG9yIDE1IG9mIHBhbGV0dGUuXG5cbiAgICAgICAgICBwYWxldHRlWyBpIF0gPSBhcnJheVsgaGVhZCArKyBdIDw8IDggfCBhcnJheVsgaGVhZCArKyBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gPiBJZiBmcmFtZSBpcyBzdG9yZWQgaW4gaW5kZXhlZCBtb2RlXG4gICAgaWYgKCBpbmRleGVkTW9kZSApIHtcbiAgICAgIC8vID4gMSBieXRlIE51bWJlciBvZiB2ZXJ0aWNlcyAoMC0yNTUpXG4gICAgICBjb25zdCBuVmVydGljZXMgPSBhcnJheVsgaGVhZCArKyBdO1xuXG4gICAgICAvLyA+IEZvciBldmVyeSBWZXJ0ZXhcbiAgICAgIC8vID4ge1xuICAgICAgLy8gPiAxIGJ5dGUgWC1wb3NpdGlvblxuICAgICAgLy8gPiAxIGJ5dGUgWS1wb3NpdGlvblxuICAgICAgLy8gPiB9XG4gICAgICBjb25zdCB2ZXJ0aWNlcyA9IGFycmF5LnN1YmFycmF5KCBoZWFkLCBoZWFkICsgMiAqIG5WZXJ0aWNlcyApO1xuICAgICAgaGVhZCArPSAyICogblZlcnRpY2VzO1xuXG4gICAgICBjb25zdCBwb2x5Z29uczogeyBjb2xvckluZGV4OiBudW1iZXI7IGluZGljZXM6IG51bWJlcltdIH1bXSA9IFtdO1xuXG4gICAgICAvLyA+IFdoaWxlICjigKYpXG4gICAgICBmb3IgKCA7OyApIHtcbiAgICAgICAgLy8gPiAxIGJ5dGUgUG9seS1kZXNjcmlwdG9yIENvbnRhaW5zOiBoaS1uaWJibGUgLSA0IGJpdHMgY29sb3ItaW5kZXhcbiAgICAgICAgLy8gPiBsby1uaWJibGUgLSA0IGJpdHMgbnVtYmVyIG9mIHBvbHlnb24gdmVydGljZXNcbiAgICAgICAgLy8gPlxuICAgICAgICAvLyA+IFNvbWUgc3BlY2lhbCBjYXNlcyBhcmUgZW5jb2RlZCBpbiB0aGUgZGVzY3JpcHRvciBieXRlOlxuICAgICAgICAvLyA+ICRmZiA9IEVuZCBvZiBmcmFtZVxuICAgICAgICAvLyA+ICRmZSA9IEVuZCBvZiBmcmFtZSBhbmQgdGhlIHN0cmVhbSBza2lwcyB0byB0aGUgbmV4dCA2NEtCIGJsb2NrXG4gICAgICAgIC8vID4gJGZkID0gRW5kIG9mIHN0cmVhbSAod2UgYXJlIGRvbmUgXFxvLylcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGFycmF5WyBoZWFkICsrIF07XG5cbiAgICAgICAgaWYgKCBkZXNjcmlwdG9yID09PSAweGZmICkgeyAvLyBlbmQgb2YgZnJhbWVcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9IGVsc2UgaWYgKCBkZXNjcmlwdG9yID09PSAweGZlICkgeyAvLyBlbmQgb2YgZnJhbWUgKyBza2lwIHRvIHRoZSBuZXh0IDY0S0JcbiAgICAgICAgICBzaG91bGRTa2lwID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9IGVsc2UgaWYgKCBkZXNjcmlwdG9yID09PSAweGZkICkgeyAvLyBlbmQgb2Ygc3RyZWFtXG4gICAgICAgICAgc2hvdWxkRW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29sb3JJbmRleCA9IGRlc2NyaXB0b3IgPj4gNCAmIDE1O1xuICAgICAgICBjb25zdCBuSW5kaWNlcyA9IGRlc2NyaXB0b3IgJiAxNTtcblxuICAgICAgICAvLyA+IEZvciBldmVyeSB2ZXJ0ZXggb2YgdGhlIHBvbHlnb25cbiAgICAgICAgLy8gPiB7XG4gICAgICAgIC8vID4gMSBieXRlIFZlcnRleC1pZCAoMC0yNTUpXG4gICAgICAgIC8vID4gfVxuICAgICAgICBjb25zdCBpbmRpY2VzID0gYXJyYXkuc3ViYXJyYXkoIGhlYWQsIGhlYWQgKyBuSW5kaWNlcyApO1xuICAgICAgICBoZWFkICs9IG5JbmRpY2VzO1xuXG4gICAgICAgIHBvbHlnb25zLnB1c2goIHtcbiAgICAgICAgICBjb2xvckluZGV4LFxuICAgICAgICAgIGluZGljZXM6IEFycmF5LmZyb20oIGluZGljZXMgKSxcbiAgICAgICAgfSApO1xuICAgICAgfVxuXG4gICAgICBmcmFtZXMucHVzaCgge1xuICAgICAgICBuZWVkc0NsZWFyLFxuICAgICAgICBpbmRleGVkTW9kZSxcbiAgICAgICAgcGFsZXR0ZTogQXJyYXkuZnJvbSggcGFsZXR0ZSApLFxuICAgICAgICB2ZXJ0aWNlczogQXJyYXkuZnJvbSggdmVydGljZXMgKSxcbiAgICAgICAgcG9seWdvbnMsXG4gICAgICB9ICk7XG5cbiAgICAvLyA+IEVsc2UgaWYgZnJhbWUgaXMgc3RvcmVkIGluIG5vbi1pbmRleGVkIG1vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcG9seWdvbnM6IHsgY29sb3JJbmRleDogbnVtYmVyOyB2ZXJ0aWNlczogbnVtYmVyW10gfVtdID0gW107XG5cbiAgICAgIC8vID4gV2hpbGUgKOKApilcbiAgICAgIGZvciAoIDs7ICkge1xuICAgICAgICAvLyA+IDEgYnl0ZSBQb2x5LWRlc2NyaXB0b3IgKFNlZSBpbmRleGVkIG1vZGUpXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBhcnJheVsgaGVhZCArKyBdO1xuXG4gICAgICAgIGlmICggZGVzY3JpcHRvciA9PT0gMHhmZiApIHsgLy8gZW5kIG9mIGZyYW1lXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfSBlbHNlIGlmICggZGVzY3JpcHRvciA9PT0gMHhmZSApIHsgLy8gZW5kIG9mIGZyYW1lICsgc2tpcCB0byB0aGUgbmV4dCA2NEtCXG4gICAgICAgICAgc2hvdWxkU2tpcCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfSBlbHNlIGlmICggZGVzY3JpcHRvciA9PT0gMHhmZCApIHsgLy8gZW5kIG9mIHN0cmVhbVxuICAgICAgICAgIHNob3VsZEVuZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbG9ySW5kZXggPSBkZXNjcmlwdG9yID4+IDQgJiAxNTtcbiAgICAgICAgY29uc3QgblZlcnRpY2VzID0gZGVzY3JpcHRvciAmIDE1O1xuXG4gICAgICAgIC8vID4gRm9yIGV2ZXJ5IHZlcnRleCBvZiB0aGUgcG9seWdvblxuICAgICAgICAvLyA+IHtcbiAgICAgICAgLy8gPiAxIGJ5dGUgVmVydGV4LWlkICgwLTI1NSlcbiAgICAgICAgLy8gPiB9XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gYXJyYXkuc3ViYXJyYXkoIGhlYWQsIGhlYWQgKyAyICogblZlcnRpY2VzICk7XG4gICAgICAgIGhlYWQgKz0gMiAqIG5WZXJ0aWNlcztcblxuICAgICAgICBwb2x5Z29ucy5wdXNoKCB7XG4gICAgICAgICAgY29sb3JJbmRleCxcbiAgICAgICAgICB2ZXJ0aWNlczogQXJyYXkuZnJvbSggdmVydGljZXMgKSxcbiAgICAgICAgfSApO1xuICAgICAgfVxuXG4gICAgICBmcmFtZXMucHVzaCgge1xuICAgICAgICBuZWVkc0NsZWFyLFxuICAgICAgICBpbmRleGVkTW9kZSxcbiAgICAgICAgcGFsZXR0ZTogQXJyYXkuZnJvbSggcGFsZXR0ZSApLFxuICAgICAgICBwb2x5Z29ucyxcbiAgICAgIH0gKTtcbiAgICB9XG5cbiAgICBpZiAoIHNob3VsZFNraXAgKSB7XG4gICAgICBoZWFkID0gKCBNYXRoLmZsb29yKCBoZWFkIC8gMHgxMDAwMCApICsgMSApICogMHgxMDAwMDtcbiAgICAgIHNob3VsZFNraXAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIHNob3VsZEVuZCApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmcmFtZXM7XG59XG4iLCJpbXBvcnQgeyBTVE5JQ0NDRnJhbWUgfSBmcm9tICcuL1NUTklDQ0NGcmFtZSc7XG5pbXBvcnQgeyBjb2xvckZyb21BdGFyaVNUIH0gZnJvbSAnLi4vY29sb3IvY29sb3JGcm9tQXRhcmlTVCc7XG5pbXBvcnQgeyBjb2xvclRvSGV4IH0gZnJvbSAnLi4vY29sb3IvY29sb3JUb0hleCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdG5pY2NjVG9TVkcoIGZyYW1lczogU1ROSUNDQ0ZyYW1lW10sIG9wdGlvbnM6IHtcbiAgZnBzPzogbnVtYmVyO1xufSA9IHt9ICk6IHN0cmluZyB7XG4gIGNvbnN0IGRlbHRhID0gMS4wIC8gKCBvcHRpb25zPy5mcHMgPz8gMzAuMCApO1xuXG4gIGxldCBzdmcgPSAnPHN2ZyB3aWR0aD1cIjI1NlwiIGhlaWdodD1cIjIwMFwiIHZpZXdCb3g9XCIwIDAgMjU2IDIwMFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4nO1xuXG4gIGxldCBzdHlsZSA9IGBne3Zpc2liaWxpdHk6aGlkZGVuO2FuaW1hdGlvbi1kdXJhdGlvbjokeyAoIGRlbHRhICogZnJhbWVzLmxlbmd0aCApLnRvRml4ZWQoIDMgKSB9czthbmltYXRpb24taXRlcmF0aW9uLWNvdW50OmluZmluaXRlO2FuaW1hdGlvbi1uYW1lOmZyYW1lfUBrZXlmcmFtZXMgZnJhbWV7MCV7dmlzaWJpbGl0eTp2aXNpYmxlfSR7IDIwMC4wIC8gZnJhbWVzLmxlbmd0aCB9JXt2aXNpYmlsaXR5OmhpZGRlbn19YDtcblxuICBmcmFtZXMubWFwKCAoIGZyYW1lLCBpRnJhbWUgKSA9PiB7XG4gICAgY29uc3QgeyBpbmRleGVkTW9kZSwgcGFsZXR0ZSwgcG9seWdvbnMgfSA9IGZyYW1lO1xuXG4gICAgc3R5bGUgKz0gYCNmJHsgaUZyYW1lIH17YW5pbWF0aW9uLWRlbGF5OiR7ICggZGVsdGEgKiBpRnJhbWUgKS50b0ZpeGVkKCAzICkgfXN9YDtcblxuICAgIGNvbnN0IHBhbGV0dGVJbkhleCA9IHBhbGV0dGUubWFwKCAoIHN0Q29sb3IgKSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGNvbG9yRnJvbUF0YXJpU1QoIHN0Q29sb3IgKTtcbiAgICAgIHJldHVybiBjb2xvclRvSGV4KCBjb2xvciApO1xuICAgIH0gKTtcblxuICAgIGxldCBjaGlsZHJlblN0ciA9ICc8cmVjdCB3aWR0aD1cIjI1NlwiIGhlaWdodD1cIjIwMFwiIGZpbGw9XCIjMDAwXCIgLz4nO1xuXG4gICAgbGV0IGN1cnJlbnRDb2xvckluZGV4ID0gLTE7XG4gICAgbGV0IGQgPSAnJztcblxuICAgIGlmICggaW5kZXhlZE1vZGUgKSB7XG4gICAgICBjb25zdCB7IHZlcnRpY2VzIH0gPSBmcmFtZTtcblxuICAgICAgcG9seWdvbnMubWFwKCAoIHsgY29sb3JJbmRleCwgaW5kaWNlcyB9ICkgPT4ge1xuICAgICAgICBpZiAoIGN1cnJlbnRDb2xvckluZGV4ICE9PSBjb2xvckluZGV4ICkge1xuICAgICAgICAgIGlmICggY3VycmVudENvbG9ySW5kZXggIT09IC0xICkge1xuICAgICAgICAgICAgY29uc3QgY29sb3JIZXggPSBwYWxldHRlSW5IZXhbIGN1cnJlbnRDb2xvckluZGV4IF07XG4gICAgICAgICAgICBjaGlsZHJlblN0ciArPSBgPHBhdGggZD1cIiR7IGQgfVwiIGZpbGw9XCIkeyBjb2xvckhleCB9XCIgLz5gO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRDb2xvckluZGV4ID0gY29sb3JJbmRleDtcbiAgICAgICAgICBkID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArKyApIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IGluZGljZXNbIGkgXTtcbiAgICAgICAgICBjb25zdCB4ID0gdmVydGljZXNbIDIgKiBpbmRleCBdO1xuICAgICAgICAgIGNvbnN0IHkgPSB2ZXJ0aWNlc1sgMiAqIGluZGV4ICsgMSBdO1xuXG4gICAgICAgICAgZCArPSBpID09PSAwXG4gICAgICAgICAgICA/IGBNJHsgeCB9LCR7IHkgfWBcbiAgICAgICAgICAgIDogYEwkeyB4IH0sJHsgeSB9YDtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2x5Z29ucy5tYXAoICggeyBjb2xvckluZGV4LCB2ZXJ0aWNlcyB9ICkgPT4ge1xuICAgICAgICBpZiAoIGN1cnJlbnRDb2xvckluZGV4ICE9PSBjb2xvckluZGV4ICkge1xuICAgICAgICAgIGlmICggY3VycmVudENvbG9ySW5kZXggIT09IC0xICkge1xuICAgICAgICAgICAgY29uc3QgY29sb3JIZXggPSBwYWxldHRlSW5IZXhbIGN1cnJlbnRDb2xvckluZGV4IF07XG4gICAgICAgICAgICBjaGlsZHJlblN0ciArPSBgPHBhdGggZD1cIiR7IGQgfVwiIGZpbGw9XCIkeyBjb2xvckhleCB9XCIgLz5gO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRDb2xvckluZGV4ID0gY29sb3JJbmRleDtcbiAgICAgICAgICBkID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMiApIHtcbiAgICAgICAgICBjb25zdCB4ID0gdmVydGljZXNbIGkgXTtcbiAgICAgICAgICBjb25zdCB5ID0gdmVydGljZXNbIGkgKyAxIF07XG5cbiAgICAgICAgICBkICs9IGkgPT09IDBcbiAgICAgICAgICAgID8gYE0keyB4IH0sJHsgeSB9YFxuICAgICAgICAgICAgOiBgTCR7IHggfSwkeyB5IH1gO1xuICAgICAgICB9XG4gICAgICB9ICk7XG4gICAgfVxuXG4gICAgY29uc3QgY29sb3JIZXggPSBwYWxldHRlSW5IZXhbIGN1cnJlbnRDb2xvckluZGV4IF07XG4gICAgY2hpbGRyZW5TdHIgKz0gYDxwYXRoIGQ9XCIkeyBkIH1cIiBmaWxsPVwiJHsgY29sb3JIZXggfVwiIC8+YDtcblxuICAgIHN2ZyArPSBgPGcgaWQ9XCJmJHsgaUZyYW1lIH1cIj4keyBjaGlsZHJlblN0ciB9PC9nPmA7XG4gIH0gKTtcblxuICBzdmcgKz0gYDxzdHlsZT4ke3N0eWxlfTwvc3R5bGU+PC9zdmc+YDtcblxuICByZXR1cm4gc3ZnO1xufVxuIiwiLyoqXG4gKiBUaGUgbmFpdmUgaW1wbGVtZW50YXRpb24gb2Ygc28tY2FsbGVkIFNtb290aERhbXAuXG4gKiBQcmV0dHkgbXVjaCB0aGUgc2FtZSBhcyB7QGxpbmsgQ0RTfSwgYnV0IGl0IGhhcyBhIHdheSBlYXNpZXIgcGFyYW1ldGVyIHRvIHR3ZWFrLCB7QGxpbmsgc21vb3RoVGltZX0uXG4gKlxuICogUmVmOiBHYW1lIFByb2dyYW1taW5nIEdlbXMgNCwgQ2hhcHRlciAxLjEwXG4gKlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vVW5pdHktVGVjaG5vbG9naWVzL1VuaXR5Q3NSZWZlcmVuY2UvYmxvYi9hMmJkZmU5YjNjNGNkNDQ3NmY0NGJmNTJmODQ4MDYzYmZhZjdiNmI5L1J1bnRpbWUvRXhwb3J0L01hdGgvTWF0aGYuY3MjTDMwOFxuICovXG5leHBvcnQgY2xhc3MgU21vb3RoRGFtcCB7XG4gIHB1YmxpYyBzbW9vdGhUaW1lID0gMS4wO1xuICBwdWJsaWMgdmVsb2NpdHkgPSAwLjA7XG4gIHB1YmxpYyB2YWx1ZSA9IDAuMDtcbiAgcHVibGljIHRhcmdldCA9IDAuMDtcblxuICBwdWJsaWMgdXBkYXRlKCBkZWx0YVRpbWU6IG51bWJlciApOiBudW1iZXIge1xuICAgIGNvbnN0IG9tZWdhID0gMi4wIC8gdGhpcy5zbW9vdGhUaW1lO1xuICAgIGNvbnN0IHggPSBvbWVnYSAqIGRlbHRhVGltZTtcbiAgICBjb25zdCBleHAgPSAxLjAgLyAoIDEuMCArIHggKyAwLjQ4ICogeCAqIHggKyAwLjIzNSAqIHggKiB4ICogeCApO1xuICAgIGNvbnN0IGRlbHRhID0gdGhpcy52YWx1ZSAtIHRoaXMudGFyZ2V0O1xuICAgIGNvbnN0IHRlbXAgPSAoIHRoaXMudmVsb2NpdHkgKyBvbWVnYSAqIGRlbHRhICkgKiBkZWx0YVRpbWU7XG4gICAgdGhpcy52ZWxvY2l0eSA9ICggdGhpcy52ZWxvY2l0eSAtIG9tZWdhICogdGVtcCApICogZXhwO1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLnRhcmdldCArICggZGVsdGEgKyB0ZW1wICkgKiBleHA7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn1cbiIsIi8qKlxuICogVXNlZnVsIGZvciBzd2FwIGJ1ZmZlclxuICovXG5leHBvcnQgY2xhc3MgU3dhcDxUPiB7XG4gIHB1YmxpYyBpOiBUO1xuICBwdWJsaWMgbzogVDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoIGE6IFQsIGI6IFQgKSB7XG4gICAgdGhpcy5pID0gYTtcbiAgICB0aGlzLm8gPSBiO1xuICB9XG5cbiAgcHVibGljIHN3YXAoKTogdm9pZCB7XG4gICAgY29uc3QgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSB0aGlzLm87XG4gICAgdGhpcy5vID0gaTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSGlzdG9yeU1lYW5DYWxjdWxhdG9yIH0gZnJvbSAnLi4vSGlzdG9yeU1lYW5DYWxjdWxhdG9yL0hpc3RvcnlNZWFuQ2FsY3VsYXRvcic7XG5cbmV4cG9ydCBjbGFzcyBUYXBUZW1wbyB7XG4gIHByaXZhdGUgX19icG0gPSAwLjA7XG4gIHByaXZhdGUgX19sYXN0VGFwID0gMC4wO1xuICBwcml2YXRlIF9fbGFzdEJlYXQgPSAwLjA7XG4gIHByaXZhdGUgX19sYXN0VGltZSA9IDAuMDtcbiAgcHJpdmF0ZSBfX2NhbGM6IEhpc3RvcnlNZWFuQ2FsY3VsYXRvciA9IG5ldyBIaXN0b3J5TWVhbkNhbGN1bGF0b3IoIDE2ICk7XG5cbiAgcHVibGljIGdldCBiZWF0RHVyYXRpb24oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gNjAuMCAvIHRoaXMuX19icG07XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJwbSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9fYnBtO1xuICB9XG5cbiAgcHVibGljIHNldCBicG0oIGJwbTogbnVtYmVyICkge1xuICAgIHRoaXMuX19sYXN0QmVhdCA9IHRoaXMuYmVhdDtcbiAgICB0aGlzLl9fbGFzdFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLl9fYnBtID0gYnBtO1xuICB9XG5cbiAgcHVibGljIGdldCBiZWF0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX19sYXN0QmVhdCArICggcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLl9fbGFzdFRpbWUgKSAqIDAuMDAxIC8gdGhpcy5iZWF0RHVyYXRpb247XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5fX2NhbGMucmVzZXQoKTtcbiAgfVxuXG4gIHB1YmxpYyBudWRnZSggYW1vdW50OiBudW1iZXIgKTogdm9pZCB7XG4gICAgdGhpcy5fX2xhc3RCZWF0ID0gdGhpcy5iZWF0ICsgYW1vdW50O1xuICAgIHRoaXMuX19sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICB9XG5cbiAgcHVibGljIHRhcCgpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBkZWx0YSA9ICggbm93IC0gdGhpcy5fX2xhc3RUYXAgKSAqIDAuMDAxO1xuXG4gICAgaWYgKCAyLjAgPCBkZWx0YSApIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fX2NhbGMucHVzaCggZGVsdGEgKTtcbiAgICAgIHRoaXMuX19icG0gPSA2MC4wIC8gKCB0aGlzLl9fY2FsYy5tZWFuICk7XG4gICAgfVxuXG4gICAgdGhpcy5fX2xhc3RUYXAgPSBub3c7XG4gICAgdGhpcy5fX2xhc3RUaW1lID0gbm93O1xuICAgIHRoaXMuX19sYXN0QmVhdCA9IDAuMDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgYXJyYXlTZXJpYWwgfSBmcm9tICcuLi9hcnJheSc7XG5cbi8qKlxuICogUGFyc2UgYSBwb2x5cGhvbmljIHRpbnlzZXEgYnVmZmVyLlxuICpcbiAqIFJldHVybnMgWyB0aW1lLCBvZmZUaW1lLCBub3RlLCByZXNlcnZlZCwgdGltZSwgb2ZmVGltZSwgbm90ZSwgcmVzZXJ2ZWQsIC4uLiBdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUaW55c2VxUG9seVJlYWRlcihcbiAgYnVmZmVyOiBVaW50OEFycmF5LFxuICBvcHRpb25zOiB7XG4gICAgcG9seT86IG51bWJlcixcbiAgICBibG9ja1NpemU/OiBudW1iZXIsXG4gICAgc2FtcGxlUmF0ZT86IG51bWJlcixcbiAgICBzdGVwc1BlclNlY29uZD86IG51bWJlcixcbiAgfSA9IHt9LFxuKTogKCkgPT4gRmxvYXQzMkFycmF5W10ge1xuICBjb25zdCBwb2x5ID0gb3B0aW9ucy5wb2x5ID8/IDg7XG4gIGNvbnN0IGJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplID8/IDEyODtcbiAgY29uc3Qgc2FtcGxlUmF0ZSA9IG9wdGlvbnMuc2FtcGxlUmF0ZSA/PyA0ODAwMDtcbiAgY29uc3Qgc3RlcHNQZXJTZWNvbmQgPSBvcHRpb25zLnN0ZXBzUGVyU2Vjb25kID8/IDEuMDtcblxuICBsZXQgc2FtcGxlcyA9IDA7XG4gIGxldCBwb3MgPSAwO1xuICBsZXQgbm90ZTogbnVtYmVyO1xuICBjb25zdCBub3RlcyA9IGFycmF5U2VyaWFsKCBwb2x5ICkuZmlsbCggLTEgKTtcbiAgY29uc3Qgbm90ZXNUaW1lID0gYXJyYXlTZXJpYWwoIHBvbHkgKS5maWxsKCAtSW5maW5pdHkgKTtcbiAgY29uc3Qgbm90ZXNPZmZUaW1lID0gYXJyYXlTZXJpYWwoIHBvbHkgKS5maWxsKCAtSW5maW5pdHkgKTtcbiAgbGV0IG5leHRTdGVwID0gMDtcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IHJldCA9IGFycmF5U2VyaWFsKCBwb2x5ICkubWFwKCAoKSA9PiBuZXcgRmxvYXQzMkFycmF5KCA0ICogYmxvY2tTaXplICkgKTtcblxuICAgIGFycmF5U2VyaWFsKCBibG9ja1NpemUgKS5tYXAoICggaVNhbXBsZSApID0+IHtcbiAgICAgIGNvbnN0IHQgPSBzYW1wbGVzIC8gc2FtcGxlUmF0ZTtcbiAgICAgIGNvbnN0IHMgPSB0ICogc3RlcHNQZXJTZWNvbmQ7XG5cbiAgICAgIGlmICggcyA+PSBuZXh0U3RlcCApIHtcbiAgICAgICAgY29uc3QgZXZlbnROb3RlID0gYnVmZmVyWyBwb3MgXTtcbiAgICAgICAgY29uc3QgZXZlbnREZWx0YVN0ZXAgPSBidWZmZXJbIHBvcyArIDEgXTtcblxuICAgICAgICBub3RlID0gKCAoIHBvcyA9PT0gMCA/IDYwIDogbm90ZSApICsgZXZlbnROb3RlICkgJiAxMjc7XG5cbiAgICAgICAgLy8gZmluZCBzYW1lIG5vdGVcbiAgICAgICAgbGV0IGlQb2x5ID0gbm90ZXMuaW5kZXhPZiggbm90ZSApO1xuXG4gICAgICAgIC8vIGZpbmQgZWFybGllc3Qgbm90ZSBvZmZcbiAgICAgICAgbGV0IHRFYXJsaWVzdCA9IEluZmluaXR5O1xuXG4gICAgICAgIGlmICggaVBvbHkgPT09IC0xICkge1xuICAgICAgICAgIG5vdGVzVGltZS5tYXAoICggdE9uLCBqUG9seSApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRPZmYgPSBub3Rlc09mZlRpbWVbIGpQb2x5IF07XG4gICAgICAgICAgICBpZiAoIHRPbiA8PSB0T2ZmICkge1xuICAgICAgICAgICAgICBpZiAoIHRPZmYgPCB0RWFybGllc3QgKSB7XG4gICAgICAgICAgICAgICAgaVBvbHkgPSBqUG9seTtcbiAgICAgICAgICAgICAgICB0RWFybGllc3QgPSB0T2ZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBlYXJsaWVzdCBub3RlIG9uXG4gICAgICAgIGlmICggaVBvbHkgPT09IC0xICkge1xuICAgICAgICAgIG5vdGVzVGltZS5tYXAoICggdE9uLCBqUG9seSApID0+IHtcbiAgICAgICAgICAgIGlmICggdE9uIDwgdEVhcmxpZXN0ICkge1xuICAgICAgICAgICAgICBpUG9seSA9IGpQb2x5O1xuICAgICAgICAgICAgICB0RWFybGllc3QgPSB0T247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgbm90ZXNbIGlQb2x5IF0gPSBub3RlO1xuXG4gICAgICAgIGlmICggZXZlbnROb3RlICYgMTI4ICkge1xuICAgICAgICAgIGlmICggbm90ZXNPZmZUaW1lWyBpUG9seSBdIDwgbm90ZXNUaW1lWyBpUG9seSBdICkge1xuICAgICAgICAgICAgbm90ZXNPZmZUaW1lWyBpUG9seSBdID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCBub3Rlc09mZlRpbWVbIGlQb2x5IF0gPj0gbm90ZXNUaW1lWyBpUG9seSBdICkge1xuICAgICAgICAgICAgbm90ZXNUaW1lWyBpUG9seSBdID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0U3RlcCArPSBldmVudERlbHRhU3RlcDtcblxuICAgICAgICBwb3MgPSAoIHBvcyArIDIgKSAlIGJ1ZmZlci5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHNhbXBsZXMgKys7XG5cbiAgICAgIGFycmF5U2VyaWFsKCBwb2x5ICkubWFwKCAoIGlQb2x5ICkgPT4ge1xuICAgICAgICBjb25zdCBub3RlVGltZSA9IG5vdGVzVGltZVsgaVBvbHkgXTtcbiAgICAgICAgY29uc3Qgbm90ZU9mZlRpbWUgPSBub3Rlc09mZlRpbWVbIGlQb2x5IF07XG5cbiAgICAgICAgcmV0WyBpUG9seSBdWyA0ICogaVNhbXBsZSArIDAgXSA9IHQgLSBub3RlVGltZTsgLy8gdGltZVxuICAgICAgICByZXRbIGlQb2x5IF1bIDQgKiBpU2FtcGxlICsgMSBdID0gbm90ZU9mZlRpbWUgPCBub3RlVGltZSA/IDAuMCA6IHQgLSBub3RlT2ZmVGltZTsgLy8gb2ZmVGltZVxuICAgICAgICByZXRbIGlQb2x5IF1bIDQgKiBpU2FtcGxlICsgMiBdID0gbm90ZXNbIGlQb2x5IF07IC8vIG5vdGVcbiAgICAgICAgcmV0WyBpUG9seSBdWyA0ICogaVNhbXBsZSArIDMgXSA9IDAuMDsgLy8gcmVzZXJ2ZWRcbiAgICAgIH0gKTtcbiAgICB9ICk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuIiwiaW1wb3J0IHsgYXJyYXlTZXJpYWwgfSBmcm9tICcuLi9hcnJheSc7XG5cbi8qKlxuICogUGFyc2UgYSB0aW55c2VxIGJ1ZmZlci5cbiAqXG4gKiBSZXR1cm5zIFsgdGltZSwgb2ZmVGltZSwgbm90ZSwgcmVzZXJ2ZWQsIHRpbWUsIG9mZlRpbWUsIG5vdGUsIHJlc2VydmVkLCAuLi4gXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGlueXNlcVJlYWRlcihcbiAgYnVmZmVyOiBVaW50OEFycmF5LFxuICBvcHRpb25zOiB7XG4gICAgYmxvY2tTaXplPzogbnVtYmVyLFxuICAgIHNhbXBsZVJhdGU/OiBudW1iZXIsXG4gICAgc3RlcHNQZXJTZWNvbmQ/OiBudW1iZXIsXG4gIH0gPSB7fSxcbik6ICgpID0+IEZsb2F0MzJBcnJheSB7XG4gIGNvbnN0IGJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplID8/IDEyODtcbiAgY29uc3Qgc2FtcGxlUmF0ZSA9IG9wdGlvbnMuc2FtcGxlUmF0ZSA/PyA0ODAwMDtcbiAgY29uc3Qgc3RlcHNQZXJTZWNvbmQgPSBvcHRpb25zLnN0ZXBzUGVyU2Vjb25kID8/IDk2MC4wO1xuXG4gIGxldCBzYW1wbGVzID0gMDtcbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBub3RlOiBudW1iZXI7XG4gIGxldCBub3RlVGltZSA9IC1JbmZpbml0eTtcbiAgbGV0IG5vdGVPZmZUaW1lID0gLUluZmluaXR5O1xuICBsZXQgbmV4dFN0ZXAgPSAwO1xuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5U2VyaWFsKCBibG9ja1NpemUgKS5tYXAoICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBzYW1wbGVzIC8gc2FtcGxlUmF0ZTtcbiAgICAgIGNvbnN0IHMgPSB0ICogc3RlcHNQZXJTZWNvbmQ7XG5cbiAgICAgIGlmICggcyA+PSBuZXh0U3RlcCApIHtcbiAgICAgICAgY29uc3QgZXZlbnROb3RlID0gYnVmZmVyWyBwb3MgXTtcbiAgICAgICAgY29uc3QgZXZlbnREZWx0YVN0ZXAgPSBidWZmZXJbIHBvcyArIDEgXTtcblxuICAgICAgICBub3RlID0gKCAoIHBvcyA9PT0gMCA/IDYwIDogbm90ZSApICsgZXZlbnROb3RlICkgJiAxMjc7XG4gICAgICAgIGlmICggZXZlbnROb3RlICYgMTI4ICkge1xuICAgICAgICAgIGlmICggbm90ZU9mZlRpbWUgPCBub3RlVGltZSApIHtcbiAgICAgICAgICAgIG5vdGVPZmZUaW1lID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCBub3RlT2ZmVGltZSA+PSBub3RlVGltZSApIHtcbiAgICAgICAgICAgIG5vdGVUaW1lID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0U3RlcCArPSBldmVudERlbHRhU3RlcDtcblxuICAgICAgICBwb3MgPSAoIHBvcyArIDIgKSAlIGJ1ZmZlci5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHNhbXBsZXMgKys7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHQgLSBub3RlVGltZSwgLy8gdGltZVxuICAgICAgICBub3RlT2ZmVGltZSA8IG5vdGVUaW1lID8gMC4wIDogdCAtIG5vdGVPZmZUaW1lLCAvLyBvZmZUaW1lXG4gICAgICAgIG5vdGUsIC8vIG5vdGVcbiAgICAgICAgMC4wLCAvLyByZXNlcnZlZFxuICAgICAgXTtcbiAgICB9ICkuZmxhdCgpICk7XG4gIH07XG59XG4iLCJpbXBvcnQgeyBNaWRpUGFyc2VSZXN1bHQgfSBmcm9tICcuLi9taWRpJztcbmltcG9ydCB7IGFycmF5U2VyaWFsIH0gZnJvbSAnLi4vYXJyYXknO1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHBhcnNlZCBtaWRpIHJlc3VsdCB0byBhIHRpbnlzZXEgYmluYXJ5LlxuICpcbiAqIFNlZToge0BsaW5rIG1pZGlQYXJzZX1cbiAqXG4gKiBAcGFyYW0gbWlkaSBUaGUgcGFyc2VkIG1pZGkgcmVzdWx0XG4gKiBAcGFyYW0gdHJhY2sgVGhlIGluZGV4IG9mIHRoZSBtaWRpIHRyYWNrIHlvdSB3YW50IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB0aWNrTXVsdGlwbGllciBNdWx0aXBseSB0aGlzIHZhbHVlIHRvIHRpY2tcbiAqIEByZXR1cm5zIEEgdGlueXNlcSBiaW5hcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbnlzZXFGcm9tTWlkaVBhcnNlUmVzdWx0KFxuICBtaWRpOiBNaWRpUGFyc2VSZXN1bHQsXG4gIHsgdHJhY2ssIHRpY2tNdWx0aXBsaWVyIH06IHtcbiAgICB0cmFjaz86IG51bWJlcixcbiAgICB0aWNrTXVsdGlwbGllcj86IG51bWJlcixcbiAgfSA9IHt9LFxuKTogVWludDhBcnJheSB7XG4gIGNvbnN0IGRhdGE6IG51bWJlcltdID0gW107XG4gIGxldCBsYXN0Tm90ZSA9IDYwO1xuICBsZXQgZGVsdGEgPSAwO1xuXG4gIGNvbnN0IHRyYWNrRXZlbnRzID0gbWlkaVsgMSBdWyB0cmFjayA/PyAwLjAgXTtcblxuICAvLyBbIGRlbHRhLCBtaWRpIGV2ZW50LCBub3RlLCB2ZWwgXVtdIC0+IFsgb25vZmYgKDAgb3IgMTI4KSArIGRlbHRhTm90ZSwgZGVsdGEsIC4uLiBdXG4gIC8vIFsgWyA0LCAxNDQsIDYwLCAxMDAgXSwgWyA0LCAxMjgsIDYwLCAxMDAgXSBdIC0+IFsgMTI4LCA0LCAwLCA0LCAxMjgsIDAgXVxuXG4gIGFycmF5U2VyaWFsKCB0cmFja0V2ZW50cy5sZW5ndGggKyAxICkubWFwKCAoIGkgKSA9PiB7XG4gICAgZGVsdGEgKz0gKCB0cmFja0V2ZW50c1sgaSBdPy5bIDAgXSA/PyAwICkgKiAoIHRpY2tNdWx0aXBsaWVyID8/IDEuMCApO1xuXG4gICAgaWYgKCBkZWx0YSA9PT0gMCAmJiBpID09PSAwICkgeyByZXR1cm47IH0gLy8gaWdub3JlIGlmIGl0J3MgdGhlIGZpcnN0IGV2ZW50IGFuZCBkZWx0YSBpcyAwXG5cbiAgICBjb25zdCBldk1zZyA9IHRyYWNrRXZlbnRzWyBpIC0gMSBdPy5bIDEgXSA/PyAxMjg7XG4gICAgY29uc3QgZXZOb3RlID0gdHJhY2tFdmVudHNbIGkgLSAxIF0/LlsgMiBdID8/IDYwO1xuXG4gICAgaWYgKCBldk1zZyA+PSAxNjAgKSB7IHJldHVybjsgfSAvLyBpZ25vcmUgaWYgdGhlIG1zZyBpcyBub3QgYSBub3RlIGV2ZW50XG5cbiAgICBjb25zdCBub3RlRGVsdGEgPSAoIGV2Tm90ZSAtIGxhc3ROb3RlICsgMTI4ICkgJiAxMjc7XG4gICAgbGFzdE5vdGUgPSBldk5vdGU7XG4gICAgY29uc3Qgb25vZmYgPSBldk1zZyA8IDE0NCA/IDEyOCA6IDA7IC8vIDAgaWYgb24gKDE0NCAtIDE1OSksIDEyOCBpZiBvZmYgKDEyOCAtIDE0MylcblxuICAgIC8vIHByb2JhYmx5IDI0MCBpcyBtb3JlIGVmZmljaWVudCB0aGFuIDI1NiBzaW5jZSB0aGUgZGl2aXNpb24gaW4gbW9zdCBvZiBtaWRpIGZpbGVzIGFyZSA0ODAgb3IgOTYwXG4gICAgbGV0IGRlbHRhQ29uc3VtZSA9IE1hdGguZmxvb3IoIE1hdGgubWluKCBkZWx0YSwgMjQwICkgKTtcbiAgICBkYXRhLnB1c2goIG5vdGVEZWx0YSArIG9ub2ZmLCBkZWx0YUNvbnN1bWUgKTtcbiAgICBkZWx0YSAtPSBkZWx0YUNvbnN1bWU7XG5cbiAgICB3aGlsZSAoIGRlbHRhID49IDEgKSB7XG4gICAgICBkZWx0YUNvbnN1bWUgPSBNYXRoLmZsb29yKCBNYXRoLm1pbiggZGVsdGEsIDI0MCApICk7XG4gICAgICBkYXRhLnB1c2goIG9ub2ZmLCBkZWx0YUNvbnN1bWUgKTtcbiAgICAgIGRlbHRhIC09IGRlbHRhQ29uc3VtZTtcbiAgICB9XG4gIH0gKTtcblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoIGRhdGEgKTtcbn1cbiIsImV4cG9ydCBjbGFzcyBYb3JzaGlmdCB7XG4gIHB1YmxpYyBzZWVkOiBudW1iZXI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBzZWVkPzogbnVtYmVyICkge1xuICAgIHRoaXMuc2VlZCA9IHNlZWQgfHwgMTtcbiAgfVxuXG4gIHB1YmxpYyBnZW4oIHNlZWQ/OiBudW1iZXIgKTogbnVtYmVyIHtcbiAgICBpZiAoIHNlZWQgKSB7XG4gICAgICB0aGlzLnNlZWQgPSBzZWVkO1xuICAgIH1cblxuICAgIHRoaXMuc2VlZCA9IHRoaXMuc2VlZCBeICggdGhpcy5zZWVkIDw8IDEzICk7XG4gICAgdGhpcy5zZWVkID0gdGhpcy5zZWVkIF4gKCB0aGlzLnNlZWQgPj4+IDE3ICk7XG4gICAgdGhpcy5zZWVkID0gdGhpcy5zZWVkIF4gKCB0aGlzLnNlZWQgPDwgNSApO1xuICAgIHJldHVybiB0aGlzLnNlZWQgLyBNYXRoLnBvdyggMiwgMzIgKSArIDAuNTtcbiAgfVxuXG4gIHB1YmxpYyBzZXQoIHNlZWQ/OiBudW1iZXIgKTogdm9pZCB7XG4gICAgdGhpcy5zZWVkID0gc2VlZCB8fCB0aGlzLnNlZWQgfHwgMTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBYb3JzaGlmdDtcbiIsImltcG9ydCB7IGxpbmVhcnN0ZXAgfSBmcm9tICcuLi9tYXRoL3V0aWxzJztcblxuLyoqXG4gKiBodHRwczovL3R3aXR0ZXIuY29tL3l1Z29wXG4gKlxuICogQHBhcmFtIHRleHQgVGhlIGlucHV0IHRleHRcbiAqIEBwYXJhbSBwaGFzZSBUaGUgdmFsdWUgYmV0d2VlbiAwLjAgYW5kIDEuMFxuICogQHBhcmFtIHJhbmRvbVJhdGlvIFRoZSBuZXJkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRZdWdvcFRleHQoIHRleHQ6IHN0cmluZywgcGhhc2U6IG51bWJlciwgcmFuZG9tUmF0aW8gPSAwLjUgKTogc3RyaW5nIHtcbiAgaWYgKCBwaGFzZSA+PSAxLjAgKSB7IHJldHVybiB0ZXh0OyB9XG4gIGlmICggcGhhc2UgPCAwLjAgKSB7IHJldHVybiAnJzsgfVxuXG4gIC8qXG4gICAqIC0tLS0tLT09PT09XG4gICAqIC4tLS0tLS09PT09XG4gICAqIC4uLS0tLS0tPT09XG4gICAqIC4uLi0tLS0tLT09XG4gICAqIC4uLi4tLS0tLS09XG4gICAqIF4gICAgIF4gICBeXG4gICAqIHwgICAgIHwgICB8XG4gICAqIHwgICAgIHwgICBwaGFzZSBpcyAxLjBcbiAgICogfCAgICAgcGhhc2UgaXMgcmFuZG9tUmF0aW9cbiAgICogcGhhc2UgaXMgMC4wXG4gICAqL1xuXG4gIGNvbnN0IGRpc3BsYXlUd2VlbiA9IGxpbmVhcnN0ZXAoIDAuMCwgMS4wIC0gcmFuZG9tUmF0aW8sIHBoYXNlICk7XG4gIGNvbnN0IGZpeFR3ZWVuID0gbGluZWFyc3RlcCggcmFuZG9tUmF0aW8sIDEuMCwgcGhhc2UgKTtcblxuICBjb25zdCBkaXNwbGF5TGVuZ3RoID0gMS4wICsgTWF0aC5mbG9vciggZGlzcGxheVR3ZWVuICogKCB0ZXh0Lmxlbmd0aCAtIDEgKSApO1xuICBjb25zdCBmaXhMZW5ndGggPSBwaGFzZSA8IHJhbmRvbVJhdGlvID8gMCA6IDEuMCArIE1hdGguZmxvb3IoIGZpeFR3ZWVuICogKCB0ZXh0Lmxlbmd0aCAtIDEgKSApO1xuICBjb25zdCByYW5kb21MZW5ndGggPSBkaXNwbGF5TGVuZ3RoIC0gZml4TGVuZ3RoO1xuXG4gIGNvbnN0IHJhbmRvbVN0ciA9IFsgLi4uQXJyYXkoIHJhbmRvbUxlbmd0aCApIF1cbiAgICAubWFwKCAoKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKCAzMyArIE1hdGguZmxvb3IoIDkzICogTWF0aC5yYW5kb20oKSApICkgKVxuICAgIC5qb2luKCAnJyApO1xuXG4gIHJldHVybiB0ZXh0LnN1YnN0cmluZyggMCwgZml4TGVuZ3RoICkgKyByYW5kb21TdHI7XG59XG4iLCJleHBvcnQgY2xhc3MgQmluYXJ5SGVhcDxUPiB7XG4gIHB1YmxpYyByZWFkb25seSBhcnJheTogVFtdO1xuICBwdWJsaWMgcmVhZG9ubHkgZWxlbWVudEluZGV4TWFwOiBNYXA8VCwgbnVtYmVyPjtcbiAgcHVibGljIGNvbXBhcmF0b3I6ICggYTogVCwgYjogVCApID0+IG51bWJlcjtcblxuICBwdWJsaWMgc3RhdGljIGRlZmF1bHRDb21wYXJhdG9yKCBhOiBhbnksIGI6IGFueSApOiBudW1iZXIge1xuICAgIGNvbnN0IGFTdHIgPSBgJHsgYSB9YDtcbiAgICBjb25zdCBiU3RyID0gYCR7IGIgfWA7XG5cbiAgICBpZiAoIGFTdHIgPiBiU3RyICkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICggYVN0ciA8IGJTdHIgKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgcm9vdCgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheVsgMCBdO1xuICB9XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCBpbml0PzogVFtdLCBjb21wYXJhdG9yPzogKCBhOiBULCBiOiBUICkgPT4gbnVtYmVyICkge1xuICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICB0aGlzLmVsZW1lbnRJbmRleE1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yID8/IEJpbmFyeUhlYXAuZGVmYXVsdENvbXBhcmF0b3I7XG5cbiAgICBpZiAoIGluaXQgIT0gbnVsbCApIHtcbiAgICAgIGZvciAoIGNvbnN0IGVsIG9mIGluaXQgKSB7XG4gICAgICAgIHRoaXMucHVzaCggZWwgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcHVzaCggLi4uZWxlbWVudHM6IFRbXSApOiB2b2lkIHtcbiAgICBlbGVtZW50cy5tYXAoICggZWwgKSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5sZW5ndGg7XG4gICAgICB0aGlzLmFycmF5LnB1c2goIGVsICk7XG4gICAgICB0aGlzLmVsZW1lbnRJbmRleE1hcC5zZXQoIGVsLCBpICk7XG4gICAgICB0aGlzLl9fdXAoIGksIGVsICk7XG4gICAgfSApO1xuICB9XG5cbiAgcHVibGljIHBvcCgpOiBUIHwgbnVsbCB7XG4gICAgaWYgKCB0aGlzLmlzRW1wdHkgKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBlbCA9IHRoaXMuYXJyYXlbIDAgXTtcbiAgICB0aGlzLmVsZW1lbnRJbmRleE1hcC5kZWxldGUoIGVsICk7XG5cbiAgICBpZiAoIHRoaXMubGVuZ3RoID09PSAxICkge1xuICAgICAgdGhpcy5hcnJheS5zcGxpY2UoIDAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVwID0gdGhpcy5hcnJheS5wb3AoKTtcbiAgICAgIHRoaXMuX19kb3duKCAwLCByZXAhICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgcHVibGljIGRlbGV0ZSggaTogbnVtYmVyICk6IGJvb2xlYW4ge1xuICAgIHRoaXMuZWxlbWVudEluZGV4TWFwLmRlbGV0ZSggdGhpcy5hcnJheVsgaSBdICk7XG5cbiAgICBjb25zdCByZXAgPSB0aGlzLmFycmF5LnBvcCgpO1xuICAgIGlmICggcmVwICE9IG51bGwgKSB7XG4gICAgICBpID0gdGhpcy5fX3VwKCBpLCByZXAgKTtcbiAgICAgIGkgPSB0aGlzLl9fZG93biggaSwgcmVwICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgcmVwbGFjZSggaTogbnVtYmVyLCByZXA6IFQgKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKCBpICE9IG51bGwgKSB7XG4gICAgICB0aGlzLmVsZW1lbnRJbmRleE1hcC5kZWxldGUoIHRoaXMuYXJyYXlbIGkgXSApO1xuXG4gICAgICBpID0gdGhpcy5fX3VwKCBpLCByZXAgKTtcbiAgICAgIGkgPSB0aGlzLl9fZG93biggaSwgcmVwICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGkgPz8gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgX191cCggaTogbnVtYmVyLCBlbDogVCApOiBudW1iZXIge1xuICAgIGxldCBpYyA9IGk7XG5cbiAgICB3aGlsZSAoIGljICE9PSAwICkge1xuICAgICAgY29uc3QgaXAgPSAoIGljIC0gMSApID4+IDE7XG5cbiAgICAgIGNvbnN0IHAgPSB0aGlzLmFycmF5WyBpcCBdO1xuICAgICAgaWYgKCB0aGlzLmNvbXBhcmF0b3IoIGVsLCBwICkgPCAwICkge1xuICAgICAgICB0aGlzLmFycmF5WyBpYyBdID0gcDtcbiAgICAgICAgdGhpcy5lbGVtZW50SW5kZXhNYXAuc2V0KCBwLCBpYyApO1xuICAgICAgICBpYyA9IGlwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hcnJheVsgaWMgXSA9IGVsO1xuICAgIHRoaXMuZWxlbWVudEluZGV4TWFwLnNldCggZWwsIGljICk7XG4gICAgcmV0dXJuIGljO1xuICB9XG5cbiAgcHJpdmF0ZSBfX2Rvd24oIGk6IG51bWJlciwgZWw6IFQgKTogbnVtYmVyIHtcbiAgICBsZXQgaXAgPSBpO1xuXG4gICAgd2hpbGUgKCAoIGlwIDw8IDEgKSArIDEgPCB0aGlzLmxlbmd0aCApIHtcbiAgICAgIGNvbnN0IGljMSA9ICggaXAgPDwgMSApICsgMTtcbiAgICAgIGNvbnN0IGljMiA9ICggaXAgPDwgMSApICsgMjtcblxuICAgICAgaWYgKCBpYzIgPCB0aGlzLmxlbmd0aCApIHtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLmFycmF5WyBpYzEgXTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLmFycmF5WyBpYzIgXTtcblxuICAgICAgICBjb25zdCBwaWNrTGVmdCA9IHRoaXMuY29tcGFyYXRvciggYzEsIGMyICkgPCAwO1xuICAgICAgICBjb25zdCBjID0gcGlja0xlZnQgPyBjMSA6IGMyO1xuICAgICAgICBjb25zdCBpYyA9IHBpY2tMZWZ0ID8gaWMxIDogaWMyO1xuXG4gICAgICAgIGlmICggdGhpcy5jb21wYXJhdG9yKCBjLCBlbCApIDwgMCApIHtcbiAgICAgICAgICB0aGlzLmFycmF5WyBpcCBdID0gYztcbiAgICAgICAgICB0aGlzLmVsZW1lbnRJbmRleE1hcC5zZXQoIGMsIGlwICk7XG4gICAgICAgICAgaXAgPSBpYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICggdGhpcy5jb21wYXJhdG9yKCB0aGlzLmFycmF5WyBpYzEgXSwgZWwgKSA8IDAgKSB7XG4gICAgICAgIHRoaXMuYXJyYXlbIGlwIF0gPSB0aGlzLmFycmF5WyBpYzEgXTtcbiAgICAgICAgdGhpcy5lbGVtZW50SW5kZXhNYXAuc2V0KCB0aGlzLmFycmF5WyBpcCBdLCBpcCApO1xuICAgICAgICBpcCA9IGljMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYXJyYXlbIGlwIF0gPSBlbDtcbiAgICB0aGlzLmVsZW1lbnRJbmRleE1hcC5zZXQoIGVsLCBpcCApO1xuICAgIHJldHVybiBpcDtcbiAgfVxufVxuIiwiLyoqXG4gKiBBIGJhcmUgZnVuY3Rpb24gdG8gbm90aWZ5IG9ic2VydmVycy5cbiAqIFRoZSBpbmNyZWRpYmx5IGNoZWFwIGltcGxlbWVudGF0aW9uIG9mIHRoZSBvYnNlcnZlciBwYXR0ZXJuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IFNldDwoIHRleHQ6IHN0cmluZyApID0+IHZvaWQ+KCk7XG4gKlxuICogb2JzZXJ2ZXJzLmFkZCggKCB0ZXh0ICkgPT4gY29uc29sZS5sb2coIHRleHQgKSApO1xuICogb2JzZXJ2ZXJzLmFkZCggKCB0ZXh0ICkgPT4gYWxlcnQoIHRleHQgKSApO1xuICpcbiAqIG5vdGlmeU9ic2VydmVycyggb2JzZXJ2ZXJzLCAnd2VuaXMnICk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb2JzZXJ2ZXJzIFRoZSBpdGVyYXRvciBvZiBvYnNlcnZlcnNcbiAqIEBwYXJhbSBwYXJhbSBUaGUgcGFyYW0geW91IHdhbnQgdG8gZ2l2ZSB0byBvYnNlcnZlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdGlmeU9ic2VydmVycyggb2JzZXJ2ZXJzOiBJdGVyYWJsZTwoKSA9PiB2b2lkPiApOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIG5vdGlmeU9ic2VydmVyczxUPiggb2JzZXJ2ZXJzOiBJdGVyYWJsZTwoIGFyZzogVCApID0+IHZvaWQ+LCBwYXJhbTogVCApOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIG5vdGlmeU9ic2VydmVycyggb2JzZXJ2ZXJzOiBJdGVyYWJsZTwoIGFyZzogYW55ICkgPT4gdm9pZD4sIHBhcmFtPzogYW55ICk6IHZvaWQge1xuICBmb3IgKCBjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlcnMgKSB7XG4gICAgb2JzZXJ2ZXIoIHBhcmFtICk7XG4gIH1cbn1cbiIsIi8vIEB0cy1ub2NoZWNrXG5cbmltcG9ydCB7bW9kfSBmcm9tICdAMGI1dnIvZXhwZXJpbWVudGFsJ1xuLy8gaW1wb3J0IHtub2l9IGZyb20gXCJAMGI1dnIvZXhwZXJpbWVudGFsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGZyYWN0KGE6IG51bWJlcikge1xuXHRyZXR1cm4gbW9kKGEsIDEpXG59XG5cbmV4cG9ydCBjb25zdCB0YXU6IG51bWJlciA9IE1hdGguUEkgKiAyLjBcbmV4cG9ydCBjb25zdCBwaTogbnVtYmVyID0gTWF0aC5QSVxuZXhwb3J0IGNvbnN0IGhhbGZQaTogbnVtYmVyID0gTWF0aC5QSSAvIDJcblxuZXhwb3J0IGZ1bmN0aW9uIG1heChhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XG5cdHJldHVybiBNYXRoLm1heChhLCBiKVxufVxuZXhwb3J0IGZ1bmN0aW9uIG1pbihhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XG5cdHJldHVybiBNYXRoLm1pbihhLCBiKVxufVxuZXhwb3J0IGZ1bmN0aW9uIG1peChhOiBudW1iZXIsIGI6IG51bWJlciwgZjogbnVtYmVyKTogbnVtYmVyIHtcblx0cmV0dXJuIGEgKiAoMS4wIC0gZikgKyBiICogZlxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nKGE6IG51bWJlcik6IG51bWJlciB7XG5cdHJldHVybiBNYXRoLmxvZyhhKVxufVxuZXhwb3J0IGZ1bmN0aW9uIGxvZzIoYTogbnVtYmVyKTogbnVtYmVyIHtcblx0cmV0dXJuIE1hdGgubG9nMihhKVxufVxuXG5leHBvcnQgY2xhc3MgSGFzaCB7XG5cdHNlZWQgPSAwXG5cdGNvbnN0cnVjdG9yKHNlZWQgPSAxMjUxMjU0KSB7XG5cdFx0SGFzaC5zZWVkID0gc2VlZFxuXHR9XG5cdHN0YXRpYyBoMTEocDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRwID0gZnJhY3QocCAqIDAuMTAzMSlcblx0XHRwICo9IHAgKyAzMy4zM1xuXHRcdHAgKj0gcCArIHBcblx0XHRyZXR1cm4gZnJhY3QocClcblx0fVxuXHRoMTEocDogbnVtYmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VlZGVkKDEyNTEyNCArIHAgKiAxMjUwKVxuXHR9XG5cdHNlZWRlZChhKSB7XG5cdFx0dmFyIHQgPSAoYSArPSAweDZkMmI3OWY1KVxuXHRcdHQgPSBNYXRoLmltdWwodCBeICh0ID4+PiAxNSksIHQgfCAxKVxuXHRcdHQgXj0gdCArIE1hdGguaW11bCh0IF4gKHQgPj4+IDcpLCB0IHwgNjEpXG5cdFx0cmV0dXJuICgodCBeICh0ID4+PiAxNCkpID4+PiAwKSAvIDQyOTQ5NjcyOTZcblx0fVxuXG5cdHZhbHVlTm9pc2UoYTogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRjb25zdCBmbGEgPSBmbG9vcihhKVxuXHRcdGNvbnN0IGNlaWxhID0gZmxhICsgMVxuXHRcdGNvbnN0IHJjdXJyID0gSGFzaC5oMTEoZmxhKVxuXHRcdGNvbnN0IHJuZXh0ID0gSGFzaC5oMTEoY2VpbGEpXG5cdFx0bGV0IGZyID0gZnJhY3QoYSlcblx0XHRmciA9IHNtb290aHN0ZXAoMCwgMSwgZnIpXG5cdFx0cmV0dXJuIGxlcnAocmN1cnIsIHJuZXh0LCBmcilcblx0fVxuXG5cdHZhbHVlTm9pc2VTbW9vdGgoYTogbnVtYmVyLCBzbW9vdGhuZXNzOiBudW1iZXIpOiBudW1iZXIge1xuXHRcdGNvbnN0IGZsYSA9IGZsb29yKGEpXG5cdFx0Y29uc3QgY2VpbGEgPSBmbGEgKyAxXG5cdFx0Y29uc3QgcmN1cnIgPSB0aGlzLmgxMShmbGEpXG5cdFx0Y29uc3Qgcm5leHQgPSB0aGlzLmgxMShjZWlsYSlcblx0XHRsZXQgZnIgPSBmcmFjdChhKVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc21vb3RobmVzczsgaSsrKSB7XG5cdFx0XHRpZiAoZmxvb3IoaSkgPT09IGZsb29yKHNtb290aG5lc3MpKSB7XG5cdFx0XHRcdGZyID0gbGVycChmciwgc21vb3Roc3RlcCgwLCAxLCBmciksIHNtb290aG5lc3MgLSBpKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZnIgPSBzbW9vdGhzdGVwKDAsIDEsIGZyKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbGVycChyY3Vyciwgcm5leHQsIGZyKVxuXHR9XG59XG5cbi8vIGV4cG9ydCBjb25zdCBua2luZ1NpbiA9ICh4OiBudW1iZXIpID0+IHtcbi8vICAgY29uc3Qgc3EgPSAoeDogbnVtYmVyKSA9PiB4ICogeDtcbi8vICAgY29uc3Qgc3RlcCA9IChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4ge1xuLy8gICAgIGlmIChhIDwgYikgcmV0dXJuIDA7XG4vLyAgICAgZWxzZSByZXR1cm4gMTtcbi8vICAgfTtcbi8vICAgIHZhbCAtIE1hdGguZmxvb3IodmFsKVxuLy8gICByZXR1cm4gKHNxKCgoeCAlIHBpKSAqIDIpIC8gcGkgLSAxKSAtIDEpICogKDEgLSAyICogc3RlcCh4ICUgKDIgKiBwaSksIHBpKSk7XG4vLyB9O1xuXG5jb25zdCByMnBpID0gMC42MzY2MTk3NzIzNlxuXG5leHBvcnQgY29uc3QgbmtpbmdTaW4gPSAoeDogbnVtYmVyKSA9PiB7XG5cdGNvbnN0IHh0YXUgPSB4ICogdGF1XG5cdGlmICh4dGF1IC0gTWF0aC5mbG9vcih4dGF1KSA+IHBpKSB7XG5cdFx0Y29uc3QgbW9kID0gKHggLSBwaSkgKiByMnBpIC0gMVxuXHRcdHJldHVybiBtb2QgKiBtb2QgLSAxXG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgbW9kID0geCAqIHIycGkgLSAxXG5cdFx0cmV0dXJuIDEgLSBtb2QgKiBtb2Rcblx0fVxufVxuXG5jb25zdCBzbW9vdGhzaW4gPSAoeDogbnVtYmVyKSA9PiB7XG5cdGNvbnN0IGIgPSB4ICogeCAqICgzLjAgLSAyLjAgKiB4KVxuXHRjb25zdCBhID0geCAqICgzIC0gMS4wICogeClcblx0cmV0dXJuIGEgKyAoYiAtIGEpICogYlxufVxuY29uc3Qgb25lT3ZlckhhbGZQaSA9IDEgLyAocGkgLyAyKVxuZXhwb3J0IGNvbnN0IGZhc3RTaW4gPSAoeDogbnVtYmVyKSA9PiB7XG5cdHggKj0gb25lT3ZlckhhbGZQaVxuXG5cdGNvbnN0IGlkID0gTWF0aC5mbG9vcih4KVxuXHR4ID0geCAlIDFcblxuXHRsZXQgc2lkZSA9IDFcblx0aWYgKChpZCAtIDIpICUgNCA8IDIpIHtcblx0XHRzaWRlID0gLTFcblx0fVxuXHRpZiAoaWQgJSAyID09PSAxKSB7XG5cdFx0eCA9IDEgLSB4XG5cdH1cblx0bGV0IGFwcHJveCA9IHNtb290aHNpbih4KVxuXHRhcHByb3ggKj0gc2lkZVxuXHRyZXR1cm4gYXBwcm94XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGl6ZShhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XG5cdHJldHVybiBNYXRoLmZsb29yKGEgLyBiKSAqIGJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRtb2QoYTogbnVtYmVyLCBiOiBudW1iZXIsIGM6IG51bWJlcj8gPSAyKSB7XG5cdHJldHVybiBtYXgobW9kKGEsIGIpIC0gYiArIDIsIDApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhYnMoYTogbnVtYmVyKTogbnVtYmVyIHtcblx0cmV0dXJuIE1hdGguYWJzKGEpXG59XG5leHBvcnQgZnVuY3Rpb24gc2lnbihhOiBudW1iZXIpOiBudW1iZXIge1xuXHRyZXR1cm4gYSA8IDAgPyAtMSA6IDFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyaShhOiBudW1iZXIpOiBudW1iZXIge1xuXHRjb25zdCBmciA9IGEgLSBNYXRoLmZsb29yKGEpXG5cdHJldHVybiBhYnMoZnIgLSAwLjUpICogMiAtIDFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbihhOiBudW1iZXIpOiBudW1iZXIge1xuXHQvLyByZXR1cm4gZmFzdFNpbihhKVxuXHQvLyAgcmV0dXJuIG5raW5nU2luKGEpXG5cdHJldHVybiBNYXRoLnNpbihhKVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvcyhhOiBudW1iZXIpOiBudW1iZXIge1xuXHQvLyByZXR1cm4gbmtpbmdTaW4oYSArIGhhbGZQaSlcblx0cmV0dXJuIE1hdGguY29zKGEpXG59XG5leHBvcnQgZnVuY3Rpb24gZmxvb3IoYTogbnVtYmVyKTogbnVtYmVyIHtcblx0cmV0dXJuIE1hdGguZmxvb3IoYSlcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3coYTogbnVtYmVyLCBiOiBudW1iZXIpIHtcblx0cmV0dXJuIE1hdGgucG93KGEsIGIpXG59XG5leHBvcnQgZnVuY3Rpb24gc3FydChhOiBudW1iZXIpIHtcblx0cmV0dXJuIE1hdGguc3FydChhKVxufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXAoYTogbnVtYmVyLCBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpIHtcblx0Y29uc3QgcmFuZ2UgPSB0byAtIGZyb21cblx0YSAtPSBmcm9tXG5cdGEgPSBtb2QoYSwgcmFuZ2UpXG5cdHJldHVybiBmcm9tICsgYVxufVxuXG5leHBvcnQgY29uc3QgbGVycCA9IChhLCBiLCB4KSA9PiBhICsgKGIgLSBhKSAqIHhcbmV4cG9ydCBjb25zdCBjbGFtcCA9ICh4OiBudW1iZXIsIGw6IG51bWJlciwgaDogbnVtYmVyKSA9PiBNYXRoLm1pbihNYXRoLm1heCh4LCBsKSwgaClcbmV4cG9ydCBjb25zdCBzYXR1cmF0ZSA9ICh4OiBudW1iZXIpID0+IE1hdGgubWluKE1hdGgubWF4KHgsIDAuMCksIDEuMClcbmV4cG9ydCBjb25zdCBsaW5lYXJzdGVwID0gKGEsIGIsIHgpID0+IHNhdHVyYXRlKCh4IC0gYSkgLyAoYiAtIGEpKVxuZXhwb3J0IGNvbnN0IHNtb290aHN0ZXAgPSAoYSwgYiwgeCkgPT4ge1xuXHRjb25zdCB0ID0gbGluZWFyc3RlcChhLCBiLCB4KVxuXHRyZXR1cm4gdCAqIHQgKiAoMy4wIC0gMi4wICogdClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmQoKSB7XG5cdHJldHVybiBNYXRoLnJhbmRvbSgpXG59XG5cbi8vIFNvbWUgZWFzaW5nIGZ1bmN0aW9uc1xuY2xhc3MgRWFzZSB7XG5cdC8vIG5vIGVhc2luZywgbm8gYWNjZWxlcmF0aW9uXG5cdHN0YXRpYyBsaW5lYXIodDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHQ7KHQpID0+IHRcblx0fVxuXHQvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG5cdHN0YXRpYyBlYXNlSW5RdWFkKHQ6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHQgKiB0XG5cdH1cblx0Ly8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcblx0c3RhdGljIGVhc2VPdXRRdWFkKHQ6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHQgKiAoMiAtIHQpXG5cdH1cblx0Ly8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG5cdHN0YXRpYyBlYXNlSW5PdXRRdWFkKHQ6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHQgPCAwLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdFxuXHR9XG5cdC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcblx0c3RhdGljIGVhc2VJbkN1YmljKHQ6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHQgKiB0ICogdFxuXHR9XG5cdC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG5cdHN0YXRpYyBlYXNlT3V0Q3ViaWModDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gLS10ICogdCAqIHQgKyAxXG5cdH1cblx0Ly8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG5cdHN0YXRpYyBlYXNlSW5PdXRDdWJpYyh0OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0IDwgMC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMVxuXHR9XG5cdC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcblx0c3RhdGljIGVhc2VJblF1YXJ0KHQ6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHRcblx0fVxuXHQvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuXHRzdGF0aWMgZWFzZU91dFF1YXJ0KHQ6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIDEgLSAtLXQgKiB0ICogdCAqIHRcblx0fVxuXHQvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cblx0c3RhdGljIGVhc2VJbk91dFF1YXJ0KHQ6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHQgPCAwLjUgPyA4ICogdCAqIHQgKiB0ICogdCA6IDEgLSA4ICogLS10ICogdCAqIHQgKiB0XG5cdH1cblx0Ly8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuXHRzdGF0aWMgZWFzZUluUXVpbnQodDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdCAqIHRcblx0fVxuXHQvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuXHRzdGF0aWMgZWFzZU91dFF1aW50KHQ6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIDEgKyAtLXQgKiB0ICogdCAqIHQgKiB0XG5cdH1cblx0Ly8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG5cdHN0YXRpYyBlYXNlSW5PdXRRdWludCh0OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0IDwgMC41ID8gMTYgKiB0ICogdCAqIHQgKiB0ICogdCA6IDEgKyAxNiAqIC0tdCAqIHQgKiB0ICogdCAqIHRcblx0fVxuXHRzdGF0aWMgZWFzZUluRWxhc3RpYyh0OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdGNvbnN0IGM0ID0gKDIgKiBNYXRoLlBJKSAvIDNcblxuXHRcdHJldHVybiB0ID09PSAwID8gMCA6IHQgPT09IDEgPyAxIDogLU1hdGgucG93KDIsIDEwICogdCAtIDEwKSAqIE1hdGguc2luKCh0ICogMTAgLSAxMC43NSkgKiBjNClcblx0fVxuXHRzdGF0aWMgZWFzZU91dEVsYXN0aWModDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRjb25zdCBjNCA9ICgyICogTWF0aC5QSSkgLyAzXG5cdFx0cmV0dXJuIHQgPT09IDAgPyAwIDogdCA9PT0gMSA/IDEgOiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogMTAgLSAwLjc1KSAqIGM0KSArIDFcblx0fVxuXHQvLyBlYXNlSW5PdXRFbGFzdGljOiB0ID0+IHtcblx0Ly8gICB2YXIgcyA9IDIgKiB0IC0gMSAvLyByZW1hcDogWzAsMC41XSAtPiBbLTEsMF1cblx0Ly8gICB2YXIgayA9ICgoODAgKiBzIC0gOSkgKiBNYXRoLlBJKSAvIDE4IC8vIGFuZCAgICBbMC41LDFdIC0+IFswLCsxXVxuXHQvLyAgIGlmIChzIDwgMCkgcmV0dXJuIC0wLjUgKiBNYXRoLnBvdygyLCAxMCAqIHMpICogTWF0aC5zaW4oaylcblx0Ly8gICBlbHNlIHJldHVybiAxICsgMC41ICogTWF0aC5wb3coMiwgLTEwICogcykgKiBNYXRoLnNpbihrKVxuXHQvLyB9LFxufVxuXG5leHBvcnQgY2xhc3MgV01hdGgge1xuXHRzdGF0aWMgbWFjb3MoeDogbnVtYmVyKSB7XG5cdFx0cmV0dXJuIE1hdGguYWNvcyh4KVxuXHR9XG5cdHN0YXRpYyBtYXNpbih4OiBudW1iZXIpIHtcblx0XHRyZXR1cm4gTWF0aC5hc2luKHgpXG5cdH1cblx0c3RhdGljIG1hdGFuKHksIHgpIHtcblx0XHRyZXR1cm4gTWF0aC5hdGFuMih5LCB4KVxuXHR9XG5cdHN0YXRpYyBtY29zKHgpIHtcblx0XHRyZXR1cm4gTWF0aC5jb3MoeClcblx0fVxuXHRzdGF0aWMgbXNpbih4KSB7XG5cdFx0cmV0dXJuIE1hdGguc2luKHgpXG5cdH1cblx0c3RhdGljIGNvczIoeCkge1xuXHRcdHJldHVybiBbTWF0aC5jb3MoeFswXSksIE1hdGguY29zKHhbMV0pXVxuXHR9XG5cdHN0YXRpYyBjb3MzKHgpIHtcblx0XHRyZXR1cm4gW01hdGguY29zKHhbMF0pLCBNYXRoLmNvcyh4WzFdKSwgTWF0aC5jb3MoeFsyXSldXG5cdH1cblx0c3RhdGljIHNpbjIoeCkge1xuXHRcdHJldHVybiBbTWF0aC5zaW4oeFswXSksIE1hdGguc2luKHhbMV0pXVxuXHR9XG5cdHN0YXRpYyBzaW4zKHgpIHtcblx0XHRyZXR1cm4gW01hdGguc2luKHhbMF0pLCBNYXRoLnNpbih4WzFdKSwgTWF0aC5zaW4oeFsyXSldXG5cdH1cblx0c3RhdGljIHNpbjQoeCkge1xuXHRcdHJldHVybiBbTWF0aC5zaW4oeFswXSksIE1hdGguc2luKHhbMV0pLCBNYXRoLnNpbih4WzJdKSwgTWF0aC5zaW4oeFszXSldXG5cdH1cblx0c3RhdGljIFNDKHgpIHtcblx0XHRyZXR1cm4gW01hdGguc2luKHgpLCBNYXRoLmNvcyh4KV1cblx0fVxuXHRzdGF0aWMgYWRkMihhLCBiKSB7XG5cdFx0cmV0dXJuIFthWzBdICsgYlswXSwgYVsxXSArIGJbMV1dXG5cdH1cblx0c3RhdGljIGFkZDMoYSwgYikge1xuXHRcdHJldHVybiBbYVswXSArIGJbMF0sIGFbMV0gKyBiWzFdLCBhWzJdICsgYlsyXV1cblx0fVxuXHRzdGF0aWMgYWRkMzEoYSwgYikge1xuXHRcdHJldHVybiBbYVswXSArIGIsIGFbMV0gKyBiLCBhWzJdICsgYl1cblx0fVxuXHRzdGF0aWMgYWRkNChhLCBiKSB7XG5cdFx0cmV0dXJuIFthWzBdICsgYlswXSwgYVsxXSArIGJbMV0sIGFbMl0gKyBiWzJdLCBhWzNdICsgYlszXV1cblx0fVxuXHRzdGF0aWMgc3ViMyhhLCBiKSB7XG5cdFx0cmV0dXJuIFthWzBdIC0gYlswXSwgYVsxXSAtIGJbMV0sIGFbMl0gLSBiWzJdXVxuXHR9XG5cdHN0YXRpYyBzdWIyKGEsIGIpIHtcblx0XHRyZXR1cm4gW2FbMF0gLSBiWzBdLCBhWzFdIC0gYlsxXV1cblx0fVxuXHRzdGF0aWMgZG90MyhhLCBiKSB7XG5cdFx0cmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXVxuXHR9XG5cdHN0YXRpYyBhYnMzKGEpIHtcblx0XHRyZXR1cm4gW2FbMF0gPiAwID8gYVswXSA6IC1hWzBdLCBhWzFdID4gMCA/IGFbMV0gOiAtYVsxXSwgYVsyXSA+IDAgPyBhWzJdIDogLWFbMl1dXG5cdH1cblx0c3RhdGljIHNjYWxlMihhLCBiKSB7XG5cdFx0cmV0dXJuIFthWzBdICogYiwgYVsxXSAqIGJdXG5cdH1cblx0c3RhdGljIHNjYWxlMyhhLCBiKSB7XG5cdFx0cmV0dXJuIFthWzBdICogYiwgYVsxXSAqIGIsIGFbMl0gKiBiXVxuXHR9XG5cdHN0YXRpYyBzY2FsZTQoYSwgYikge1xuXHRcdHJldHVybiBbYVswXSAqIGIsIGFbMV0gKiBiLCBhWzJdICogYiwgYVszXSAqIGJdXG5cdH1cblx0c3RhdGljIG11bDMoYSwgYikge1xuXHRcdHJldHVybiBbYVswXSAqIGJbMF0sIGFbMV0gKiBiWzFdLCBhWzJdICogYlsyXV1cblx0fVxuXHRzdGF0aWMgbXVsNChhLCBiKSB7XG5cdFx0cmV0dXJuIFthWzBdICogYlswXSwgYVsxXSAqIGJbMV0sIGFbMl0gKiBiWzJdLCBhWzNdICogYlszXV1cblx0fVxuXHRzdGF0aWMgbXltaXgoYSwgYiwgZikge1xuXHRcdHJldHVybiBhICogKDEuMCAtIGYpICsgYiAqIGZcblx0fVxuXHRzdGF0aWMgbXltaXgyMihhLCBiLCBmKSB7XG5cdFx0cmV0dXJuIFthWzBdICogKDEuMCAtIGZbMF0pICsgYlswXSAqIGZbMF0sIGFbMV0gKiAoMS4wIC0gZlsxXSkgKyBiWzFdICogZlsxXV1cblx0fVxuXHRzdGF0aWMgbWl4MShhLCBiLCBmKSB7XG5cdFx0cmV0dXJuIGEgKiAoMS4wIC0gZikgKyBiICogZlxuXHR9XG5cdHN0YXRpYyBtaXgzKGEsIGIsIGYpIHtcblx0XHRyZXR1cm4gYWRkMyhzY2FsZTMoYSwgMS4wIC0gZiksIHNjYWxlMyhiLCBmKSlcblx0fVxuXHRzdGF0aWMgbGVuZ3RoMihhKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydChhWzBdICogYVswXSArIGFbMV0gKiBhWzFdKVxuXHR9XG5cdHN0YXRpYyBsZW5ndGgzKGEpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGFbMF0gKiBhWzBdICsgYVsxXSAqIGFbMV0gKyBhWzJdICogYVsyXSlcblx0fVxuXHRzdGF0aWMgbGVuZ3RoNChhKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydChhWzBdICogYVswXSArIGFbMV0gKiBhWzFdICsgYVsyXSAqIGFbMl0gKyBhWzNdICogYVszXSlcblx0fVxuXHRzdGF0aWMgbm9ybWFsaXplMyhhKSB7XG5cdFx0cmV0dXJuIHNjYWxlMyhhLCAxLjAgLyBsZW5ndGgzKGEpKVxuXHR9XG5cdHN0YXRpYyBub3JtYWxpemU0KGEpIHtcblx0XHRyZXR1cm4gc2NhbGU0KGEsIDEuMCAvIGxlbmd0aDQoYSkpXG5cdH1cblx0c3RhdGljIGNyb3NzKGEsIGIpIHtcblx0XHRyZXR1cm4gW2FbMV0gKiBiWzJdIC0gYlsxXSAqIGFbMl0sIGFbMl0gKiBiWzBdIC0gYlsyXSAqIGFbMF0sIGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV1dXG5cdH1cblx0RyA9IDAuNSArIE1hdGguc3FydCg1IC8gNClcblx0c3RhdGljIGZyYWN0MShhKSB7XG5cdFx0cmV0dXJuIGEgLSBNYXRoLmZsb29yKGEpXG5cdH1cblx0c3RhdGljIGZsb29yMihhKSB7XG5cdFx0cmV0dXJuIFtNYXRoLmZsb29yKGFbMF0pLCBNYXRoLmZsb29yKGFbMV0pXVxuXHR9XG5cdHN0YXRpYyBmcmFjdDIoYSkge1xuXHRcdHJldHVybiBbZnJhY3QxKGFbMF0pLCBmcmFjdDEoYVsxXSldXG5cdH1cblx0c3RhdGljIGZyYWN0MyhhKSB7XG5cdFx0cmV0dXJuIFtmcmFjdDEoYVswXSksIGZyYWN0MShhWzFdKSwgZnJhY3QxKGFbMl0pXVxuXHR9XG5cdHN0YXRpYyBmcmFjdDQoYSkge1xuXHRcdHJldHVybiBbZnJhY3QxKGFbMF0pLCBmcmFjdDEoYVsxXSksIGZyYWN0MShhWzJdKSwgZnJhY3QxKGFbM10pXVxuXHR9XG5cdHN0YXRpYyBjbGFtcDEoYSwgYTEsIGEyKSB7XG5cdFx0cmV0dXJuIGEgPCBhMSA/IGExIDogYSA+IGEyID8gYTIgOiBhXG5cdH1cblx0c3RhdGljIGNsYW1wMzEoYSwgYTEsIGEyKSB7XG5cdFx0cmV0dXJuIFtjbGFtcDEoYVswXSwgYTEsIGEyKSwgY2xhbXAxKGFbMV0sIGExLCBhMiksIGNsYW1wMShhWzJdLCBhMSwgYTIpXVxuXHR9XG5cdHN0YXRpYyByb3RYKHBoLCB2KSB7XG5cdFx0cmV0dXJuIFt2WzBdLCB2WzFdICogbWNvcyhwaCkgKyB2WzJdICogbXNpbihwaCksIHZbMl0gKiBtY29zKHBoKSAtIHZbMV0gKiBtc2luKHBoKV1cblx0fVxuXHRzdGF0aWMgcm90WShwaCwgdikge1xuXHRcdHJldHVybiBbdlswXSAqIG1jb3MocGgpICsgdlsyXSAqIG1zaW4ocGgpLCB2WzFdLCB2WzJdICogbWNvcyhwaCkgLSB2WzBdICogbXNpbihwaCldXG5cdH1cblx0c3RhdGljIHJvdFoocGgsIHYpIHtcblx0XHRyZXR1cm4gW3ZbMF0gKiBtY29zKHBoKSArIHZbMV0gKiBtc2luKHBoKSwgdlsxXSAqIG1jb3MocGgpIC0gdlswXSAqIG1zaW4ocGgpLCB2WzJdXVxuXHR9XG5cdHN0YXRpYyBoc3YycmdiKGMpIHtcblx0XHR2YXIgSyA9IFsxLjAsIDIuMCAvIDMuMCwgMS4wIC8gMy4wLCAzLjBdXG5cdFx0dmFyIHAgPSBhYnMzKHN1YjMoc2NhbGUzKGZyYWN0MyhhZGQzKFtjWzBdLCBjWzBdLCBjWzBdXSwgSykpLCA2LjApLCBbMywgMywgM10pKVxuXHRcdHJldHVybiBzY2FsZTMobWl4MyhbMSwgMSwgMV0sIGNsYW1wMzEoc3ViMyhwLCBbMSwgMSwgMV0pLCAwLjAsIDEuMCksIGNbMV0pLCBjWzJdKVxuXHR9XG59XG4iLCJpbXBvcnQge3BhdXNlX29uX2dsX2Vycm9yfSBmcm9tICdnbF91dGlscydcbmltcG9ydCB7bG9nMiwgbWluLCBwb3d9IGZyb20gJ3dtYXRoJ1xuaW1wb3J0IHtGcmFtZWJ1ZmZlcn0gZnJvbSAnLi9GcmFtZWJ1ZmZlcidcblxuZXhwb3J0IGNsYXNzIFRleHR1cmUge1xuXHQvLyBAdHMtaWdub3JlXG5cdHRleDogV2ViR0xUZXh0dXJlXG5cdGludGVybmFsX2Zvcm1hdDogbnVtYmVyXG5cdGZvcm1hdDogbnVtYmVyXG5cdHR5cGU6IG51bWJlclxuXHRyZXM6IEFycmF5PG51bWJlcj5cblxuXHRwcml2YXRlIGlzX2Zsb2F0OiBib29sZWFuXG5cdG1pcG1hcHBlZDogYm9vbGVhblxuXHRwcml2YXRlIG1pcF9sZXZlbHM6IG51bWJlclxuXG5cdGNvbnN0cnVjdG9yKHJlczogbnVtYmVyW10sIGludGVybmFsX2Zvcm1hdDogbnVtYmVyID0gZ2wuUkdCQSwgbWlwbWFwcGVkID0gZmFsc2UsIG1pcF9sZXZlbHM6IG51bWJlciA9IDApIHtcblx0XHRjb25zdCBlcV9hbnkgPSAoYTogYW55LCBiOiBhbnlbXSk6IGJvb2xlYW4gPT4ge1xuXHRcdFx0bGV0IGVxID0gZmFsc2Vcblx0XHRcdGIuZm9yRWFjaCgoYikgPT4ge1xuXHRcdFx0XHRpZiAoYiA9PT0gYSkge1xuXHRcdFx0XHRcdGVxID0gdHJ1ZVxuXHRcdFx0XHRcdC8vIHJldHVybiBlcVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0cmV0dXJuIGVxXG5cdFx0fVxuXHRcdHRoaXMucmVzID0gWy4uLnJlc11cblx0XHR0aGlzLmludGVybmFsX2Zvcm1hdCA9IGludGVybmFsX2Zvcm1hdFxuXG5cdFx0dGhpcy5taXBtYXBwZWQgPSBtaXBtYXBwZWRcblx0XHR0aGlzLm1pcF9sZXZlbHMgPSBtaXBfbGV2ZWxzXG5cblx0XHR0aGlzLmlzX2Zsb2F0ID0gZXFfYW55KGludGVybmFsX2Zvcm1hdCwgW2dsLlJHQkEzMkYsIGdsLlJHQkExNkYsIGdsLlJHQjE2RiwgZ2wuUkdCMzJGXSlcblxuXHRcdGxldCBjb21wX2NudCA9IDRcblx0XHRpZiAoZXFfYW55KGludGVybmFsX2Zvcm1hdCwgW2dsLlJHQkEzMkYsIGdsLlJHQkExNkYsIGdsLlJHQkEsIGdsLlJHQkExNkksIGdsLlJHQkExNlVJLCBnbC5SR0JBMzJJLCBnbC5SR0JBOEksIGdsLlJHQkE4VUldKSkge1xuXHRcdFx0Y29tcF9jbnQgPSA0XG5cdFx0fVxuXHRcdGlmIChlcV9hbnkoaW50ZXJuYWxfZm9ybWF0LCBbZ2wuUkdCMzJGLCBnbC5SR0IxNkYsIGdsLlJHQiwgZ2wuUkdCMTZJLCBnbC5SR0IxNlVJLCBnbC5SR0IzMkksIGdsLlJHQjhJLCBnbC5SR0I4VUldKSkge1xuXHRcdFx0Y29tcF9jbnQgPSAzXG5cdFx0fVxuXG5cdFx0dGhpcy5mb3JtYXQgPSBjb21wX2NudCA9PT0gNCA/IGdsLlJHQkEgOiBnbC5SR0Jcblx0XHR0aGlzLnR5cGUgPSB0aGlzLmlzX2Zsb2F0ID8gZ2wuRkxPQVQgOiBnbC5VTlNJR05FRF9CWVRFXG5cblx0XHRpZiAoZXFfYW55KGludGVybmFsX2Zvcm1hdCwgW2dsLlJHQkE4VUksIGdsLlJHQkExNlVJLCBnbC5SR0JBMzJVSSwgZ2wuUkdCOFVJLCBnbC5SR0IxNlVJLCBnbC5SR0IzMlVJXSkpIHtcblx0XHRcdHRoaXMudHlwZSA9IGdsLlVOU0lHTkVEX0lOVFxuXHRcdH1cblx0XHRpZiAoZXFfYW55KGludGVybmFsX2Zvcm1hdCwgW2dsLlJHQkE4SSwgZ2wuUkdCQTE2SSwgZ2wuUkdCQTMySSwgZ2wuUkdCOEksIGdsLlJHQjE2SSwgZ2wuUkdCMzJJXSkpIHtcblx0XHRcdHRoaXMudHlwZSA9IGdsLklOVFxuXHRcdH1cblx0XHR0aGlzLnJlY3JlYXRlKClcblx0fVxuXHRyZWNyZWF0ZSgpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0dGhpcy50ZXggPSBnbC5jcmVhdGVUZXh0dXJlKClcblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4KVxuXG5cdFx0aWYgKHRoaXMuaXNfZmxvYXQpIHtcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKVxuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKVxuXHRcdH1cblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpXG5cblx0XHRpZiAodGhpcy5taXBtYXBwZWQpIHtcblx0XHRcdGlmICh0aGlzLm1pcF9sZXZlbHMgPT09IDApIHtcblx0XHRcdFx0aWYgKHRoaXMucmVzWzBdID4gNCAmJiB0aGlzLnJlc1sxXSA+IDQpIHtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSX01JUE1BUF9MSU5FQVIpXG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUilcblx0XHRcdFx0XHRnbC50ZXhTdG9yYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbG9nMihtaW4odGhpcy5yZXNbMF0sIHRoaXMucmVzWzFdKSksIHRoaXMuaW50ZXJuYWxfZm9ybWF0LCB0aGlzLnJlc1swXSwgdGhpcy5yZXNbMV0pXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmludGVybmFsX2Zvcm1hdCwgdGhpcy5yZXNbMF0sIHRoaXMucmVzWzFdLCAwLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBudWxsKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwYXVzZV9vbl9nbF9lcnJvcigpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5pbnRlcm5hbF9mb3JtYXQsIHRoaXMucmVzWzBdLCB0aGlzLnJlc1sxXSwgMCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgbnVsbClcblx0XHR9XG5cdFx0Ly8gY29uc29sZS5sb2coZ2wuaXNUZXh0dXJlKHRoaXMudGV4KSlcblxuXHRcdGlmICghZ2wuaXNUZXh0dXJlKHRoaXMudGV4KSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEVYVFVSRSBJTkNPTVBMRVRFJylcblx0XHR9XG5cdH1cblxuXHRyZXNpemUobmV3X3JlczogbnVtYmVyW10pIHtcblx0XHR0aGlzLnJlcyA9IFsuLi5uZXdfcmVzXVxuXHRcdGlmICh0aGlzLm1pcG1hcHBlZCkge1xuXHRcdFx0Z2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleClcblx0XHRcdHRoaXMucmVjcmVhdGUoKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxNSlcblx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4KVxuXHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmludGVybmFsX2Zvcm1hdCwgdGhpcy5yZXNbMF0sIHRoaXMucmVzWzFdLCAwLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBudWxsKVxuXHRcdH1cblx0fVxuXHRzdGF0aWMgYXN5bmMgZnJvbV9pbWFnZV9wYXRoKGltZ19wYXRoOiBzdHJpbmcpOiBQcm9taXNlPFRleHR1cmU+IHtcblx0XHRmdW5jdGlvbiBsb2FkSW1hZ2UodXJsOiBzdHJpbmcpOiBQcm9taXNlPEhUTUxJbWFnZUVsZW1lbnQ+IHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdFx0XHRjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpXG5cdFx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0cmVzb2x2ZShpbWFnZSlcblx0XHRcdFx0fSlcblx0XHRcdFx0aW1hZ2Uuc3JjID0gdXJsXG5cdFx0XHR9KVxuXHRcdH1cblxuXHRcdGNvbnN0IGltZyA9IGF3YWl0IGxvYWRJbWFnZShpbWdfcGF0aClcblx0XHRjb25zdCB0ZXggPSBuZXcgVGV4dHVyZShbaW1nLm5hdHVyYWxXaWR0aCwgaW1nLm5hdHVyYWxIZWlnaHRdLCBnbC5SR0JBOCwgdHJ1ZSwgMClcblx0XHQvLyB0ZXgudXBsb2FkX2Zyb21fY3B1KGltZylcblx0XHQvLyBnbC5nZXRUZXhQYXJhbWV0ZXIoZ2wuVEVYVFVSRV8yRCwgZ2wuVFlQRSlcblx0XHRnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHRleC5yZXNbMF0sIHRleC5yZXNbMV0sIHRleC5mb3JtYXQsIHRleC50eXBlLCBpbWcpXG5cdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRClcblx0XHRwYXVzZV9vbl9nbF9lcnJvcigpXG5cdFx0Ly8gTm90IG5lZWRlZD9cblx0XHRnbC5maW5pc2goKVxuXHRcdGltZy5yZW1vdmUoKVxuXHRcdHJldHVybiB0ZXhcblx0fVxuXG5cdHVwbG9hZF9mcm9tX2NwdShpbWFnZTogSFRNTEltYWdlRWxlbWVudCB8IG51bWJlcltdIHwgRmxvYXQzMkFycmF5KSB7XG5cdFx0aWYgKGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuXHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmludGVybmFsX2Zvcm1hdCwgdGhpcy5yZXNbMF0sIHRoaXMucmVzWzFdLCAwLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBpbWFnZSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVidWdnZXJcblx0XHR9XG5cdH1cblxuXHRjbG9uZSgpOiBUZXh0dXJlIHtcblx0XHRyZXR1cm4gbmV3IFRleHR1cmUodGhpcy5yZXMsIHRoaXMuaW50ZXJuYWxfZm9ybWF0LCB0aGlzLm1pcG1hcHBlZCwgdGhpcy5taXBfbGV2ZWxzKVxuXHR9XG5cdGJpbmRfdG9fdW5pdCh1bml0OiBudW1iZXIpIHtcblx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdW5pdClcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleClcblx0fVxuXG5cdHJlYWRfYmFja19hcnJheShvZmZzOiBudW1iZXJbXSA9IFswLCAwXSwgcmVhZF9iYWNrX3JlczogbnVtYmVyW10gPSBbLi4udGhpcy5yZXNdKTogVWludDhBcnJheSB8IEZsb2F0MzJBcnJheSB7XG5cdFx0bGV0IHRlbXBfZmIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpIGFzIFdlYkdMRnJhbWVidWZmZXJcblx0XHRsZXQgcHJldl9ib3VuZF9mYiA9IEZyYW1lYnVmZmVyLmN1cnJlbnRseV9ib3VuZFxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGVtcF9mYilcblx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4LCAwKVxuXG5cdFx0Ly8gY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMucmVzWzBdICogdGhpcy5yZXNbMV0gKiA0KVxuXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuaXNfZmxvYXRcblx0XHRcdD8gbmV3IEZsb2F0MzJBcnJheShyZWFkX2JhY2tfcmVzWzBdICogcmVhZF9iYWNrX3Jlc1sxXSAqIDQpXG5cdFx0XHQ6IG5ldyBVaW50OEFycmF5KHJlYWRfYmFja19yZXNbMF0gKiByZWFkX2JhY2tfcmVzWzFdICogNClcblx0XHRnbC5yZWFkUGl4ZWxzKG9mZnNbMF0sIG9mZnNbMV0sIHJlYWRfYmFja19yZXNbMF0sIHJlYWRfYmFja19yZXNbMV0sIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIGRhdGEpXG5cdFx0Ly8gY29uc29sZS5sb2coZGF0YSlcblx0XHRnbC5kZWxldGVGcmFtZWJ1ZmZlcih0ZW1wX2ZiKVxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgcHJldl9ib3VuZF9mYi5mYilcblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHJlYWRfYmFja19waXhlbChvZmZzOiBudW1iZXJbXSk6IEFycmF5PG51bWJlcj4ge1xuXHRcdGxldCBkYXRhID0gdGhpcy5yZWFkX2JhY2tfYXJyYXkob2ZmcywgWzEsIDFdKVxuXHRcdGlmICh0aGlzLmlzX2Zsb2F0KSB7XG5cdFx0XHRkYXRhLmZvckVhY2goKGUsIGksIGEpID0+IHtcblx0XHRcdFx0YVtpXSAqPSAyNTVcblx0XHRcdH0pXG5cdFx0fVxuXHRcdGRhdGFbM10gPSAyNTVcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIEFycmF5LmZyb20oZGF0YSlcblx0fVxuXHRhc3luYyByZWFkX2JhY2tfaW1hZ2UoXG5cdFx0Z2FtbWFfY29ycmVjdDogYm9vbGVhbiA9IGZhbHNlLFxuXHRcdG9mZnM6IG51bWJlcltdID0gWzAsIDBdLFxuXHRcdHJlYWRfYmFja19yZXM6IG51bWJlcltdID0gWy4uLnRoaXMucmVzXSxcblx0KTogUHJvbWlzZTxbSFRNTEltYWdlRWxlbWVudCwgQmxvYl0+IHtcblx0XHRsZXQgZGF0YSA9IHRoaXMucmVhZF9iYWNrX2FycmF5KG9mZnMsIHJlYWRfYmFja19yZXMpXG5cblx0XHRsZXQgaSA9IDBcblx0XHRsZXQgaWR4ID0gMFxuXHRcdGZvciAobGV0IHBpeGVsIG9mIGRhdGEpIHtcblx0XHRcdGlmIChpID09PSAzKSB7XG5cdFx0XHRcdGlmICh0aGlzLmlzX2Zsb2F0KSB7XG5cdFx0XHRcdFx0ZGF0YVtpZHhdID0gMjU1XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVtpZHhdID0gMjU1XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IC0xXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoZ2FtbWFfY29ycmVjdCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLmlzX2Zsb2F0KSB7XG5cdFx0XHRcdFx0XHRkYXRhW2lkeF0gPSAyNTUgKiBwb3coZGF0YVtpZHhdLCAwLjQ1NDU0NTQ1NDUpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRhdGFbaWR4XSA9IDI1NSAqIHBvdyhkYXRhW2lkeF0gLyAyNTUsIDAuNDU0NTQ1NDU0NSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZGF0YVtpZHhdICo9IDI0MFxuXHRcdFx0fVxuXHRcdFx0aWR4Kytcblx0XHRcdGkrK1xuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBhIDJEIGNhbnZhcyB0byBzdG9yZSB0aGUgcmVzdWx0XG5cdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcblx0XHRjYW52YXMud2lkdGggPSB0aGlzLnJlc1swXVxuXHRcdGNhbnZhcy5oZWlnaHQgPSB0aGlzLnJlc1sxXVxuXHRcdGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhcyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcblxuXHRcdGxldCBibG9iOiBCbG9iXG5cblx0XHRjb25zdCBnZXRDYW52YXNCbG9iID0gKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiBQcm9taXNlPEJsb2I+ID0+IHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdGNhbnZhcy50b0Jsb2IoZnVuY3Rpb24gKGJsb2IpIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0cmVzb2x2ZShibG9iKVxuXHRcdFx0XHR9LCAnaW1hZ2UvcG5nJylcblx0XHRcdH0pXG5cdFx0fVxuXG5cdFx0YmxvYiA9IGF3YWl0IGdldENhbnZhc0Jsb2IoY2FudmFzKVxuXHRcdGNvbnNvbGUubG9nKCdCTE9SR1VCUycpXG5cdFx0Y29uc29sZS5sb2coYmxvYilcblxuXHRcdC8vIGNhbnZhcy50b0Jsb2IoKGIpID0+IHtcblx0XHQvLyBcdGJsb2IgPSBiIGFzIEJsb2Jcblx0XHQvLyBcdGNvbnNvbGUubG9nKCdCTE9CIEEnKVxuXHRcdC8vIFx0Y29uc29sZS5sb2coYmxvYilcblx0XHQvLyB9LCAnaW1hZ2UvcG5nJylcblxuXHRcdC8vIGNvbnNvbGUubG9nKCdCTE9CIEInKVxuXHRcdC8vIGNvbnNvbGUubG9nKGJsb2IpXG5cblx0XHRjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cdFx0aW1hZ2VEYXRhLmRhdGEuc2V0KGRhdGEpXG5cdFx0Y29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuXHRcdGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpXG5cdFx0aW1nLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoKVxuXG5cdFx0Y2FudmFzLnJlbW92ZSgpXG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBbaW1nLCBibG9iXVxuXHR9XG59XG4iLCJpbXBvcnQge1RleHR1cmV9IGZyb20gJy4vVGV4dHVyZSdcblxuZXhwb3J0IGNsYXNzIEZyYW1lYnVmZmVyIHtcblx0c3RhdGljIGN1cnJlbnRseV9ib3VuZDogRnJhbWVidWZmZXJcblx0c3RhdGljIGZyYW1lYnVmZmVyczogRnJhbWVidWZmZXJbXSA9IFtdXG5cdF90ZXh0dXJlczogQXJyYXk8VGV4dHVyZT5cblx0X2JhY2tfdGV4dHVyZXM6IEFycmF5PFRleHR1cmU+XG5cdHByaXZhdGUgX2ZiOiBXZWJHTEZyYW1lYnVmZmVyXG5cdC8vIEB0cy1pZ25vcmVcblx0cHJpdmF0ZSBfZmJfYmFjazogV2ViR0xGcmFtZWJ1ZmZlciA9IHVuZGVmaW5lZFxuXHRkZWZhdWx0OiBib29sZWFuID0gZmFsc2Vcblx0cG9uZ2FibGU6IGJvb2xlYW4gPSBmYWxzZVxuXHRuZWVkc19wb25nOiBib29sZWFuID0gZmFsc2Vcblx0cG9uZ19pZHg6IG51bWJlciA9IDBcblxuXHRwdWJsaWMgZ2V0IHRleHR1cmVzKCk6IEFycmF5PFRleHR1cmU+IHtcblx0XHRpZiAodGhpcy5wb25nX2lkeCA9PT0gMCkgcmV0dXJuIHRoaXMuX3RleHR1cmVzXG5cdFx0ZWxzZSByZXR1cm4gdGhpcy5fYmFja190ZXh0dXJlc1xuXHR9XG5cdHB1YmxpYyBnZXQgYmFja190ZXh0dXJlcygpOiBBcnJheTxUZXh0dXJlPiB7XG5cdFx0aWYgKHRoaXMucG9uZ19pZHggPT09IDApIHJldHVybiB0aGlzLl9iYWNrX3RleHR1cmVzXG5cdFx0ZWxzZSByZXR1cm4gdGhpcy5fdGV4dHVyZXNcblx0fVxuXG5cdHB1YmxpYyBnZXQgZmIoKTogV2ViR0xGcmFtZWJ1ZmZlciB7XG5cdFx0aWYgKHRoaXMucG9uZ19pZHggPT09IDApIHJldHVybiB0aGlzLl9mYlxuXHRcdGVsc2UgcmV0dXJuIHRoaXMuX2ZiX2JhY2tcblx0fVxuXHRwdWJsaWMgZ2V0IGZiX2JhY2soKTogV2ViR0xGcmFtZWJ1ZmZlciB7XG5cdFx0aWYgKHRoaXMucG9uZ19pZHggPT09IDApIHJldHVybiB0aGlzLl9mYl9iYWNrXG5cdFx0ZWxzZSByZXR1cm4gdGhpcy5fZmJcblx0fVxuXG5cdHB1YmxpYyBwb25nKCkge1xuXHRcdHRoaXMucG9uZ19pZHggPSAxIC0gdGhpcy5wb25nX2lkeFxuXHRcdHRoaXMubmVlZHNfcG9uZyA9IGZhbHNlXG5cdH1cblxuXHRwdWJsaWMgcmVjcmVhdGUoKSB7XG5cdFx0aWYgKHRoaXMucG9uZ2FibGUpIHtcblx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5fZmJfYmFjaylcblxuXHRcdFx0bGV0IGkgPSAwXG5cdFx0XHRmb3IgKGxldCB0ZXggb2YgdGhpcy5fYmFja190ZXh0dXJlcykge1xuXHRcdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcblx0XHRcdFx0XHRnbC5GUkFNRUJVRkZFUixcblx0XHRcdFx0XHRnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksXG5cdFx0XHRcdFx0Z2wuVEVYVFVSRV8yRCxcblx0XHRcdFx0XHR0ZXgudGV4LFxuXHRcdFx0XHRcdDAsIC8vIGxldmVsLCB0aGlzIGlzIHRoZSBtaXBtYXAgbGV2ZWxcblx0XHRcdFx0KVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZSQU1FQlVGRkVSIElOQ09NUExFVEUnKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5fZmIpXG5cblx0XHRsZXQgaSA9IDBcblx0XHRmb3IgKGxldCB0ZXggb2YgdGhpcy5fdGV4dHVyZXMpIHtcblx0XHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuXHRcdFx0XHRnbC5GUkFNRUJVRkZFUixcblx0XHRcdFx0Z2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLFxuXHRcdFx0XHRnbC5URVhUVVJFXzJELFxuXHRcdFx0XHR0ZXgudGV4LFxuXHRcdFx0XHQwLCAvLyBsZXZlbCwgdGhpcyBpcyB0aGUgbWlwbWFwIGxldmVsXG5cdFx0XHQpXG5cdFx0XHRpKytcblx0XHR9XG5cblx0XHRpZiAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGUkFNRUJVRkZFUiBJTkNPTVBMRVRFJylcblx0XHR9XG5cdH1cblx0Y29uc3RydWN0b3IodGV4dHVyZXM6IEFycmF5PFRleHR1cmU+LCBwb25nYWJsZTogYm9vbGVhbiA9IGZhbHNlKSB7XG5cdFx0dGhpcy5fZmIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpIGFzIFdlYkdMRnJhbWVidWZmZXJcblx0XHR0aGlzLl90ZXh0dXJlcyA9IFsuLi50ZXh0dXJlc11cblx0XHR0aGlzLnBvbmdhYmxlID0gcG9uZ2FibGVcblx0XHR0aGlzLl9iYWNrX3RleHR1cmVzID0gW11cblxuXHRcdGlmICh0aGlzLnBvbmdhYmxlKSB7XG5cdFx0XHR0aGlzLl9mYl9iYWNrID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKSBhcyBXZWJHTEZyYW1lYnVmZmVyXG5cdFx0XHRmb3IgKGxldCB0ZXggb2YgdGhpcy50ZXh0dXJlcykge1xuXHRcdFx0XHR0aGlzLl9iYWNrX3RleHR1cmVzLnB1c2godGV4LmNsb25lKCkpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5yZWNyZWF0ZSgpXG5cblx0XHQvLyBpZiAodGhpcyAhPT0gRnJhbWVidWZmZXIuY3VycmVudGx5X2JvdW5kKSBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIEZyYW1lYnVmZmVyLmN1cnJlbnRseV9ib3VuZC5fZmIpXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBGcmFtZWJ1ZmZlci5jdXJyZW50bHlfYm91bmQuX2ZiKVxuXHRcdEZyYW1lYnVmZmVyLmZyYW1lYnVmZmVycy5wdXNoKHRoaXMpXG5cdH1cblx0YmluZCgpIHtcblx0XHRpZiAodGhpcy5wb25nYWJsZSkgdGhpcy5uZWVkc19wb25nID0gdHJ1ZVxuXHRcdGxldCBkcmF3X2J1ZmZzOiBudW1iZXJbXSA9IFtdXG5cblx0XHRpZiAodGhpcy5kZWZhdWx0KSB7XG5cdFx0XHRkcmF3X2J1ZmZzID0gW2dsLkJBQ0tdXG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBpID0gMFxuXHRcdFx0Zm9yIChsZXQgdGV4IG9mIHRoaXMudGV4dHVyZXMpIHtcblx0XHRcdFx0ZHJhd19idWZmcy5wdXNoKGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSlcblx0XHRcdFx0aSsrXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z2wudmlld3BvcnQoMCwgMCwgdGhpcy50ZXh0dXJlc1swXS5yZXNbMF0sIHRoaXMudGV4dHVyZXNbMF0ucmVzWzFdKVxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mYilcblx0XHRGcmFtZWJ1ZmZlci5jdXJyZW50bHlfYm91bmQgPSB0aGlzXG5cdFx0Ly8gZ2wuZHJhd0J1ZmZlcnMoZHJhd19idWZmcylcblx0fVxuXHRjbGVhcihjb2xvdXI6IG51bWJlcltdID0gWzAsIDAsIDAsIDBdKSB7XG5cdFx0Ly8gaWYgKHRoaXMuZmIgIT09IEZyYW1lYnVmZmVyLmN1cnJlbnRseV9ib3VuZC5mYikgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZiKVxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mYilcblx0XHRnbC5jbGVhckNvbG9yKGNvbG91clswXSwgY29sb3VyWzFdLCBjb2xvdXJbMl0sIGNvbG91clszXSlcblx0XHRnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKVxuXHRcdC8vIGlmICh0aGlzLmZiICE9PSBGcmFtZWJ1ZmZlci5jdXJyZW50bHlfYm91bmQuZmIpIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgRnJhbWVidWZmZXIuY3VycmVudGx5X2JvdW5kLmZiKVxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgRnJhbWVidWZmZXIuY3VycmVudGx5X2JvdW5kLmZiKVxuXHR9XG59XG4iLCJpbXBvcnQge0ZyYW1lYnVmZmVyfSBmcm9tICdnbC9GcmFtZWJ1ZmZlcidcbmltcG9ydCB7VGV4dHVyZX0gZnJvbSAnZ2wvVGV4dHVyZSdcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRfZ2xfZXJyb3JfaGFuZGxpbmcoKSB7XG5cdGlmICghZ2wuZGVidWdFbmFibGVkKSByZXR1cm5cblx0Z2wuZ2xFbnVtcyA9IHt9XG5cdGdsLmVudW1TdHJpbmdUb1ZhbHVlID0ge31cblx0Zm9yIChsZXQgcHJvcGVydHlOYW1lIGluIGdsKSB7XG5cdFx0aWYgKHR5cGVvZiBnbFtwcm9wZXJ0eU5hbWVdID09PSAnbnVtYmVyJykge1xuXHRcdFx0Z2wuZ2xFbnVtc1tnbFtwcm9wZXJ0eU5hbWVdXSA9IHByb3BlcnR5TmFtZVxuXHRcdFx0Z2wuZW51bVN0cmluZ1RvVmFsdWVbcHJvcGVydHlOYW1lXSA9IGdsW3Byb3BlcnR5TmFtZV1cblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdsX2VudW1fdG9fc3RyaW5nKHZhbHVlKTogc3RyaW5nIHtcblx0Ly8gY2hlY2tJbml0KCk7XG5cdGNvbnN0IG5hbWUgPSB3aW5kb3cuZ2wuZ2xFbnVtc1t2YWx1ZV1cblx0cmV0dXJuIG5hbWUgIT09IHVuZGVmaW5lZCA/ICdnbC4nICsgbmFtZSA6ICcvKlVOS05PV04gV2ViR0wgRU5VTSovIDB4JyArIHZhbHVlLnRvU3RyaW5nKDE2KSArICcnXG59XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRfb25fZ2xfZXJyb3IoKSB7XG5cdGlmICghZ2wuZGVidWdFbmFibGVkKSByZXR1cm5cblx0bGV0IGVyciA9IHdpbmRvdy5nbC5nZXRFcnJvcigpXG5cdGlmIChlcnIgIT09IDApIHtcblx0XHRjb25zb2xlLmVycm9yKGVycilcblx0XHRjb25zb2xlLmVycm9yKGdsX2VudW1fdG9fc3RyaW5nKGVycikpXG5cdH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXVzZV9vbl9nbF9lcnJvcigpIHtcblx0aWYgKCFnbC5kZWJ1Z0VuYWJsZWQpIHJldHVyblxuXHRsZXQgZXJyID0gd2luZG93LmdsLmdldEVycm9yKClcblx0aWYgKGVyciAhPT0gMCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoZXJyKVxuXHRcdGNvbnNvbGUuZXJyb3IoZ2xfZW51bV90b19zdHJpbmcoZXJyKSlcblx0XHRkZWJ1Z2dlclxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5X2ZiX3RvX3RleHR1cmUoaW5fZnJhbWVidWZmZXI6IFdlYkdMRnJhbWVidWZmZXIsIG91dF90ZXh0dXJlOiBUZXh0dXJlKSB7XG5cdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgaW5fZnJhbWVidWZmZXIpXG5cdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG91dF90ZXh0dXJlLnRleClcblx0Z2wuY29weVRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgb3V0X3RleHR1cmUuaW50ZXJuYWxfZm9ybWF0LCAwLCAwLCBvdXRfdGV4dHVyZS5yZXNbMF0sIG91dF90ZXh0dXJlLnJlc1sxXSwgMClcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb3B5X2ZiX3RvX2ZiKGluX2ZyYW1lYnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyLCBvdXRfZnJhbWVidWZmZXI6IFdlYkdMRnJhbWVidWZmZXIsIHJlczogbnVtYmVyW10pIHtcblx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIGluX2ZyYW1lYnVmZmVyKVxuXHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRFJBV19GUkFNRUJVRkZFUiwgb3V0X2ZyYW1lYnVmZmVyKVxuXHRnbC5ibGl0RnJhbWVidWZmZXIoMCwgMCwgcmVzWzBdLCByZXNbMV0sIDAsIDAsIHJlc1swXSwgcmVzWzFdLCBnbC5DT0xPUl9CVUZGRVJfQklULCBnbC5ORUFSRVNUKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzaXplSWZOZWVkZWQoXG5cdGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG5cdGRlZmF1bHRfZnJhbWVidWZmZXI6IEZyYW1lYnVmZmVyLFxuXHRjbGllbnRfcmVzOiBudW1iZXJbXSxcblx0c2V0X3JlZHJhd19uZWVkZWQ6ICh2OiBib29sZWFuKSA9PiB2b2lkLFxuXHRzZXRfc2hhcmVkX3VuaWZvcm1zOiBGdW5jdGlvbixcbikge1xuXHRjb25zdCBkaXNwbGF5V2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGhcblx0Y29uc3QgZGlzcGxheUhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHRcblxuXHRjb25zdCBuZWVkUmVzaXplID0gY2FudmFzLndpZHRoICE9PSBkaXNwbGF5V2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gZGlzcGxheUhlaWdodFxuXG5cdGlmIChuZWVkUmVzaXplKSB7XG5cdFx0Y2xpZW50X3Jlc1swXSA9IGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aFxuXHRcdGNsaWVudF9yZXNbMV0gPSBjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodFxuXHRcdHNldF9yZWRyYXdfbmVlZGVkKHRydWUpXG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGRlZmF1bHRfZnJhbWVidWZmZXIuX3RleHR1cmVzWzBdLnJlcyA9IFsuLi5jbGllbnRfcmVzXVxuXHRcdHNldF9zaGFyZWRfdW5pZm9ybXMoKVxuXHR9XG5cblx0cmV0dXJuIG5lZWRSZXNpemVcbn1cbiIsIi8qXG5BZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsXG5EaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvZWFzZXMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuKi9cbmV4cG9ydCB7IGlkZW50aXR5IGFzIGxpbmVhciB9IGZyb20gJy4uL2ludGVybmFsL2luZGV4LmpzJztcblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG5cdGNvbnN0IHMgPSAxLjcwMTU4ICogMS41MjU7XG5cdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSk7XG5cdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tJbih0KSB7XG5cdGNvbnN0IHMgPSAxLjcwMTU4O1xuXHRyZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tPdXQodCkge1xuXHRjb25zdCBzID0gMS43MDE1ODtcblx0cmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VPdXQodCkge1xuXHRjb25zdCBhID0gNC4wIC8gMTEuMDtcblx0Y29uc3QgYiA9IDguMCAvIDExLjA7XG5cdGNvbnN0IGMgPSA5LjAgLyAxMC4wO1xuXHRjb25zdCBjYSA9IDQzNTYuMCAvIDM2MS4wO1xuXHRjb25zdCBjYiA9IDM1NDQyLjAgLyAxODA1LjA7XG5cdGNvbnN0IGNjID0gMTYwNjEuMCAvIDE4MDUuMDtcblx0Y29uc3QgdDIgPSB0ICogdDtcblx0cmV0dXJuIHQgPCBhXG5cdFx0PyA3LjU2MjUgKiB0MlxuXHRcdDogdCA8IGJcblx0XHQ/IDkuMDc1ICogdDIgLSA5LjkgKiB0ICsgMy40XG5cdFx0OiB0IDwgY1xuXHRcdD8gY2EgKiB0MiAtIGNiICogdCArIGNjXG5cdFx0OiAxMC44ICogdCAqIHQgLSAyMC41MiAqIHQgKyAxMC43Mjtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluT3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjUgPyAwLjUgKiAoMS4wIC0gYm91bmNlT3V0KDEuMCAtIHQgKiAyLjApKSA6IDAuNSAqIGJvdW5jZU91dCh0ICogMi4wIC0gMS4wKSArIDAuNTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcblx0cmV0dXJuIDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0KTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmNJbk91dCh0KSB7XG5cdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XG5cdHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjSW4odCkge1xuXHRyZXR1cm4gMS4wIC0gTWF0aC5zcXJ0KDEuMCAtIHQgKiB0KTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmNPdXQodCkge1xuXHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNSA/IDQuMCAqIHQgKiB0ICogdCA6IDAuNSAqIE1hdGgucG93KDIuMCAqIHQgLSAyLjAsIDMuMCkgKyAxLjA7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcblx0cmV0dXJuIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcblx0Y29uc3QgZiA9IHQgLSAxLjA7XG5cdHJldHVybiBmICogZiAqIGYgKyAxLjA7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGFzdGljSW5PdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNVxuXHRcdD8gMC41ICogTWF0aC5zaW4oKCgrMTMuMCAqIE1hdGguUEkpIC8gMikgKiAyLjAgKiB0KSAqIE1hdGgucG93KDIuMCwgMTAuMCAqICgyLjAgKiB0IC0gMS4wKSlcblx0XHQ6IDAuNSAqXG5cdFx0XHRcdE1hdGguc2luKCgoLTEzLjAgKiBNYXRoLlBJKSAvIDIpICogKDIuMCAqIHQgLSAxLjAgKyAxLjApKSAqXG5cdFx0XHRcdE1hdGgucG93KDIuMCwgLTEwLjAgKiAoMi4wICogdCAtIDEuMCkpICtcblx0XHRcdFx0MS4wO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcblx0cmV0dXJuIE1hdGguc2luKCgxMy4wICogdCAqIE1hdGguUEkpIC8gMikgKiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG5cdHJldHVybiBNYXRoLnNpbigoLTEzLjAgKiAodCArIDEuMCkgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpICsgMS4wO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb0luT3V0KHQpIHtcblx0cmV0dXJuIHQgPT09IDAuMCB8fCB0ID09PSAxLjBcblx0XHQ/IHRcblx0XHQ6IHQgPCAwLjVcblx0XHQ/ICswLjUgKiBNYXRoLnBvdygyLjAsIDIwLjAgKiB0IC0gMTAuMClcblx0XHQ6IC0wLjUgKiBNYXRoLnBvdygyLjAsIDEwLjAgLSB0ICogMjAuMCkgKyAxLjA7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBvSW4odCkge1xuXHRyZXR1cm4gdCA9PT0gMC4wID8gdCA6IE1hdGgucG93KDIuMCwgMTAuMCAqICh0IC0gMS4wKSk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBvT3V0KHQpIHtcblx0cmV0dXJuIHQgPT09IDEuMCA/IHQgOiAxLjAgLSBNYXRoLnBvdygyLjAsIC0xMC4wICogdCk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkSW5PdXQodCkge1xuXHR0IC89IDAuNTtcblx0aWYgKHQgPCAxKSByZXR1cm4gMC41ICogdCAqIHQ7XG5cdHQtLTtcblx0cmV0dXJuIC0wLjUgKiAodCAqICh0IC0gMikgLSAxKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YWRJbih0KSB7XG5cdHJldHVybiB0ICogdDtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YWRPdXQodCkge1xuXHRyZXR1cm4gLXQgKiAodCAtIDIuMCk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFydEluT3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjUgPyArOC4wICogTWF0aC5wb3codCwgNC4wKSA6IC04LjAgKiBNYXRoLnBvdyh0IC0gMS4wLCA0LjApICsgMS4wO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhcnRJbih0KSB7XG5cdHJldHVybiBNYXRoLnBvdyh0LCA0LjApO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhcnRPdXQodCkge1xuXHRyZXR1cm4gTWF0aC5wb3codCAtIDEuMCwgMy4wKSAqICgxLjAgLSB0KSArIDEuMDtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1aW50SW5PdXQodCkge1xuXHRpZiAoKHQgKj0gMikgPCAxKSByZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdCAqIHQ7XG5cdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWludEluKHQpIHtcblx0cmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVpbnRPdXQodCkge1xuXHRyZXR1cm4gLS10ICogdCAqIHQgKiB0ICogdCArIDE7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5lSW5PdXQodCkge1xuXHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbmVJbih0KSB7XG5cdGNvbnN0IHYgPSBNYXRoLmNvcyh0ICogTWF0aC5QSSAqIDAuNSk7XG5cdGlmIChNYXRoLmFicyh2KSA8IDFlLTE0KSByZXR1cm4gMTtcblx0ZWxzZSByZXR1cm4gMSAtIHY7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5lT3V0KHQpIHtcblx0cmV0dXJuIE1hdGguc2luKCh0ICogTWF0aC5QSSkgLyAyKTtcbn1cbiIsImltcG9ydCB7IGN1YmljT3V0LCBjdWJpY0luT3V0LCBsaW5lYXIgfSBmcm9tICcuLi9lYXNpbmcvaW5kZXguanMnO1xuaW1wb3J0IHsgYXNzaWduLCBzcGxpdF9jc3NfdW5pdCwgaXNfZnVuY3Rpb24gfSBmcm9tICcuLi9pbnRlcm5hbC9pbmRleC5qcyc7XG5cbi8qKlxuICogQW5pbWF0ZXMgYSBgYmx1cmAgZmlsdGVyIGFsb25nc2lkZSBhbiBlbGVtZW50J3Mgb3BhY2l0eS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtdHJhbnNpdGlvbiNibHVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYycpLkJsdXJQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBibHVyKFxuXHRub2RlLFxuXHR7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljSW5PdXQsIGFtb3VudCA9IDUsIG9wYWNpdHkgPSAwIH0gPSB7fVxuKSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0Y29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgZiA9IHN0eWxlLmZpbHRlciA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS5maWx0ZXI7XG5cdGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuXHRjb25zdCBbdmFsdWUsIHVuaXRdID0gc3BsaXRfY3NzX3VuaXQoYW1vdW50KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAoX3QsIHUpID0+IGBvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gb2QgKiB1fTsgZmlsdGVyOiAke2Z9IGJsdXIoJHt1ICogdmFsdWV9JHt1bml0fSk7YFxuXHR9O1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgZnJvbSAwIHRvIHRoZSBjdXJyZW50IG9wYWNpdHkgZm9yIGBpbmAgdHJhbnNpdGlvbnMgYW5kIGZyb20gdGhlIGN1cnJlbnQgb3BhY2l0eSB0byAwIGZvciBgb3V0YCB0cmFuc2l0aW9ucy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtdHJhbnNpdGlvbiNmYWRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYycpLkZhZGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gbGluZWFyIH0gPSB7fSkge1xuXHRjb25zdCBvID0gK2dldENvbXB1dGVkU3R5bGUobm9kZSkub3BhY2l0eTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAodCkgPT4gYG9wYWNpdHk6ICR7dCAqIG99YFxuXHR9O1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIHRoZSB4IGFuZCB5IHBvc2l0aW9ucyBhbmQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudC4gYGluYCB0cmFuc2l0aW9ucyBhbmltYXRlIGZyb20gdGhlIHByb3ZpZGVkIHZhbHVlcywgcGFzc2VkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIGVsZW1lbnQncyBkZWZhdWx0IHZhbHVlcy4gYG91dGAgdHJhbnNpdGlvbnMgYW5pbWF0ZSBmcm9tIHRoZSBlbGVtZW50J3MgZGVmYXVsdCB2YWx1ZXMgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtdHJhbnNpdGlvbiNmbHlcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljJykuRmx5UGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMnKS5UcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx5KFxuXHRub2RlLFxuXHR7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCB4ID0gMCwgeSA9IDAsIG9wYWNpdHkgPSAwIH0gPSB7fVxuKSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0Y29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcblx0Y29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG5cdGNvbnN0IFt4VmFsdWUsIHhVbml0XSA9IHNwbGl0X2Nzc191bml0KHgpO1xuXHRjb25zdCBbeVZhbHVlLCB5VW5pdF0gPSBzcGxpdF9jc3NfdW5pdCh5KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7KDEgLSB0KSAqIHhWYWx1ZX0ke3hVbml0fSwgJHsoMSAtIHQpICogeVZhbHVlfSR7eVVuaXR9KTtcblx0XHRcdG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSBvZCAqIHV9YFxuXHR9O1xufVxuXG4vKipcbiAqIFNsaWRlcyBhbiBlbGVtZW50IGluIGFuZCBvdXQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXRyYW5zaXRpb24jc2xpZGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljJykuU2xpZGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGlkZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCBheGlzID0gJ3knIH0gPSB7fSkge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgcHJpbWFyeV9wcm9wZXJ0eSA9IGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblx0Y29uc3QgcHJpbWFyeV9wcm9wZXJ0eV92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbcHJpbWFyeV9wcm9wZXJ0eV0pO1xuXHRjb25zdCBzZWNvbmRhcnlfcHJvcGVydGllcyA9IGF4aXMgPT09ICd5JyA/IFsndG9wJywgJ2JvdHRvbSddIDogWydsZWZ0JywgJ3JpZ2h0J107XG5cdGNvbnN0IGNhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzID0gc2Vjb25kYXJ5X3Byb3BlcnRpZXMubWFwKFxuXHRcdChlKSA9PiBgJHtlWzBdLnRvVXBwZXJDYXNlKCl9JHtlLnNsaWNlKDEpfWBcblx0KTtcblx0Y29uc3QgcGFkZGluZ19zdGFydF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYHBhZGRpbmcke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfWBdKTtcblx0Y29uc3QgcGFkZGluZ19lbmRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BwYWRkaW5nJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1sxXX1gXSk7XG5cdGNvbnN0IG1hcmdpbl9zdGFydF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYG1hcmdpbiR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19YF0pO1xuXHRjb25zdCBtYXJnaW5fZW5kX3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgbWFyZ2luJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1sxXX1gXSk7XG5cdGNvbnN0IGJvcmRlcl93aWR0aF9zdGFydF92YWx1ZSA9IHBhcnNlRmxvYXQoXG5cdFx0c3R5bGVbYGJvcmRlciR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19V2lkdGhgXVxuXHQpO1xuXHRjb25zdCBib3JkZXJfd2lkdGhfZW5kX3ZhbHVlID0gcGFyc2VGbG9hdChcblx0XHRzdHlsZVtgYm9yZGVyJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1sxXX1XaWR0aGBdXG5cdCk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKHQpID0+XG5cdFx0XHQnb3ZlcmZsb3c6IGhpZGRlbjsnICtcblx0XHRcdGBvcGFjaXR5OiAke01hdGgubWluKHQgKiAyMCwgMSkgKiBvcGFjaXR5fTtgICtcblx0XHRcdGAke3ByaW1hcnlfcHJvcGVydHl9OiAke3QgKiBwcmltYXJ5X3Byb3BlcnR5X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YHBhZGRpbmctJHtzZWNvbmRhcnlfcHJvcGVydGllc1swXX06ICR7dCAqIHBhZGRpbmdfc3RhcnRfdmFsdWV9cHg7YCArXG5cdFx0XHRgcGFkZGluZy0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfTogJHt0ICogcGFkZGluZ19lbmRfdmFsdWV9cHg7YCArXG5cdFx0XHRgbWFyZ2luLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19OiAke3QgKiBtYXJnaW5fc3RhcnRfdmFsdWV9cHg7YCArXG5cdFx0XHRgbWFyZ2luLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19OiAke3QgKiBtYXJnaW5fZW5kX3ZhbHVlfXB4O2AgK1xuXHRcdFx0YGJvcmRlci0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfS13aWR0aDogJHt0ICogYm9yZGVyX3dpZHRoX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YGJvcmRlci0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfS13aWR0aDogJHt0ICogYm9yZGVyX3dpZHRoX2VuZF92YWx1ZX1weDtgXG5cdH07XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgdGhlIG9wYWNpdHkgYW5kIHNjYWxlIG9mIGFuIGVsZW1lbnQuIGBpbmAgdHJhbnNpdGlvbnMgYW5pbWF0ZSBmcm9tIGFuIGVsZW1lbnQncyBjdXJyZW50IChkZWZhdWx0KSB2YWx1ZXMgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcywgcGFzc2VkIGFzIHBhcmFtZXRlcnMuIGBvdXRgIHRyYW5zaXRpb25zIGFuaW1hdGUgZnJvbSB0aGUgcHJvdmlkZWQgdmFsdWVzIHRvIGFuIGVsZW1lbnQncyBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtdHJhbnNpdGlvbiNzY2FsZVxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMnKS5TY2FsZVBhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljJykuVHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKFxuXHRub2RlLFxuXHR7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCBzdGFydCA9IDAsIG9wYWNpdHkgPSAwIH0gPSB7fVxuKSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0Y29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcblx0Y29uc3Qgc2QgPSAxIC0gc3RhcnQ7XG5cdGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6IChfdCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gc2NhbGUoJHsxIC0gc2QgKiB1fSk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gb2QgKiB1fVxuXHRcdGBcblx0fTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyB0aGUgc3Ryb2tlIG9mIGFuIFNWRyBlbGVtZW50LCBsaWtlIGEgc25ha2UgaW4gYSB0dWJlLiBgaW5gIHRyYW5zaXRpb25zIGJlZ2luIHdpdGggdGhlIHBhdGggaW52aXNpYmxlIGFuZCBkcmF3IHRoZSBwYXRoIHRvIHRoZSBzY3JlZW4gb3ZlciB0aW1lLiBgb3V0YCB0cmFuc2l0aW9ucyBzdGFydCBpbiBhIHZpc2libGUgc3RhdGUgYW5kIGdyYWR1YWxseSBlcmFzZSB0aGUgcGF0aC4gYGRyYXdgIG9ubHkgd29ya3Mgd2l0aCBlbGVtZW50cyB0aGF0IGhhdmUgYSBgZ2V0VG90YWxMZW5ndGhgIG1ldGhvZCwgbGlrZSBgPHBhdGg+YCBhbmQgYDxwb2x5bGluZT5gLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS10cmFuc2l0aW9uI2RyYXdcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudCAmIHsgZ2V0VG90YWxMZW5ndGgoKTogbnVtYmVyIH19IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYycpLkRyYXdQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmF3KG5vZGUsIHsgZGVsYXkgPSAwLCBzcGVlZCwgZHVyYXRpb24sIGVhc2luZyA9IGN1YmljSW5PdXQgfSA9IHt9KSB7XG5cdGxldCBsZW4gPSBub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0aWYgKHN0eWxlLnN0cm9rZUxpbmVjYXAgIT09ICdidXR0Jykge1xuXHRcdGxlbiArPSBwYXJzZUludChzdHlsZS5zdHJva2VXaWR0aCk7XG5cdH1cblx0aWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZHVyYXRpb24gPSA4MDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGR1cmF0aW9uID0gbGVuIC8gc3BlZWQ7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGR1cmF0aW9uID0gZHVyYXRpb24obGVuKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6IChfLCB1KSA9PiBgXG5cdFx0XHRzdHJva2UtZGFzaGFycmF5OiAke2xlbn07XG5cdFx0XHRzdHJva2UtZGFzaG9mZnNldDogJHt1ICogbGVufTtcblx0XHRgXG5cdH07XG59XG5cbi8qKlxuICogVGhlIGBjcm9zc2ZhZGVgIGZ1bmN0aW9uIGNyZWF0ZXMgYSBwYWlyIG9mIFt0cmFuc2l0aW9uc10oL2RvY3MjdGVtcGxhdGUtc3ludGF4LWVsZW1lbnQtZGlyZWN0aXZlcy10cmFuc2l0aW9uLWZuKSBjYWxsZWQgYHNlbmRgIGFuZCBgcmVjZWl2ZWAuIFdoZW4gYW4gZWxlbWVudCBpcyAnc2VudCcsIGl0IGxvb2tzIGZvciBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBiZWluZyAncmVjZWl2ZWQnLCBhbmQgZ2VuZXJhdGVzIGEgdHJhbnNpdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIGVsZW1lbnQgdG8gaXRzIGNvdW50ZXJwYXJ0J3MgcG9zaXRpb24gYW5kIGZhZGVzIGl0IG91dC4gV2hlbiBhbiBlbGVtZW50IGlzICdyZWNlaXZlZCcsIHRoZSByZXZlcnNlIGhhcHBlbnMuIElmIHRoZXJlIGlzIG5vIGNvdW50ZXJwYXJ0LCB0aGUgYGZhbGxiYWNrYCB0cmFuc2l0aW9uIGlzIHVzZWQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXRyYW5zaXRpb24jY3Jvc3NmYWRlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMnKS5Dcm9zc2ZhZGVQYXJhbXMgJiB7XG4gKiBcdGZhbGxiYWNrPzogKG5vZGU6IEVsZW1lbnQsIHBhcmFtczogaW1wb3J0KCcuL3B1YmxpYycpLkNyb3NzZmFkZVBhcmFtcywgaW50cm86IGJvb2xlYW4pID0+IGltcG9ydCgnLi9wdWJsaWMnKS5UcmFuc2l0aW9uQ29uZmlnO1xuICogfX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7Wyhub2RlOiBhbnksIHBhcmFtczogaW1wb3J0KCcuL3B1YmxpYycpLkNyb3NzZmFkZVBhcmFtcyAmIHsga2V5OiBhbnk7IH0pID0+ICgpID0+IGltcG9ydCgnLi9wdWJsaWMnKS5UcmFuc2l0aW9uQ29uZmlnLCAobm9kZTogYW55LCBwYXJhbXM6IGltcG9ydCgnLi9wdWJsaWMnKS5Dcm9zc2ZhZGVQYXJhbXMgJiB7IGtleTogYW55OyB9KSA9PiAoKSA9PiBpbXBvcnQoJy4vcHVibGljJykuVHJhbnNpdGlvbkNvbmZpZ119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcm9zc2ZhZGUoeyBmYWxsYmFjaywgLi4uZGVmYXVsdHMgfSkge1xuXHQvKiogQHR5cGUge01hcDxhbnksIEVsZW1lbnQ+fSAqL1xuXHRjb25zdCB0b19yZWNlaXZlID0gbmV3IE1hcCgpO1xuXHQvKiogQHR5cGUge01hcDxhbnksIEVsZW1lbnQ+fSAqL1xuXHRjb25zdCB0b19zZW5kID0gbmV3IE1hcCgpO1xuXHQvKipcblx0ICogQHBhcmFtIHtFbGVtZW50fSBmcm9tX25vZGVcblx0ICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYycpLkNyb3NzZmFkZVBhcmFtc30gcGFyYW1zXG5cdCAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljJykuVHJhbnNpdGlvbkNvbmZpZ31cblx0ICovXG5cdGZ1bmN0aW9uIGNyb3NzZmFkZShmcm9tX25vZGUsIG5vZGUsIHBhcmFtcykge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gKGQpID0+IE1hdGguc3FydChkKSAqIDMwLFxuXHRcdFx0ZWFzaW5nID0gY3ViaWNPdXRcblx0XHR9ID0gYXNzaWduKGFzc2lnbih7fSwgZGVmYXVsdHMpLCBwYXJhbXMpO1xuXHRcdGNvbnN0IGZyb20gPSBmcm9tX25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0Y29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IGR4ID0gZnJvbS5sZWZ0IC0gdG8ubGVmdDtcblx0XHRjb25zdCBkeSA9IGZyb20udG9wIC0gdG8udG9wO1xuXHRcdGNvbnN0IGR3ID0gZnJvbS53aWR0aCAvIHRvLndpZHRoO1xuXHRcdGNvbnN0IGRoID0gZnJvbS5oZWlnaHQgLyB0by5oZWlnaHQ7XG5cdFx0Y29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRcdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdFx0Y29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRcdHJldHVybiB7XG5cdFx0XHRkZWxheSxcblx0XHRcdGR1cmF0aW9uOiBpc19mdW5jdGlvbihkdXJhdGlvbikgPyBkdXJhdGlvbihkKSA6IGR1cmF0aW9uLFxuXHRcdFx0ZWFzaW5nLFxuXHRcdFx0Y3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0XHRvcGFjaXR5OiAke3QgKiBvcGFjaXR5fTtcblx0XHRcdFx0dHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7XG5cdFx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke3UgKiBkeH1weCwke3UgKiBkeX1weCkgc2NhbGUoJHt0ICsgKDEgLSB0KSAqIGR3fSwgJHtcblx0XHRcdFx0dCArICgxIC0gdCkgKiBkaFxuXHRcdFx0fSk7XG5cdFx0XHRgXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge01hcDxhbnksIEVsZW1lbnQ+fSBpdGVtc1xuXHQgKiBAcGFyYW0ge01hcDxhbnksIEVsZW1lbnQ+fSBjb3VudGVycGFydHNcblx0ICogQHBhcmFtIHtib29sZWFufSBpbnRyb1xuXHQgKiBAcmV0dXJucyB7KG5vZGU6IGFueSwgcGFyYW1zOiBpbXBvcnQoJy4vcHVibGljJykuQ3Jvc3NmYWRlUGFyYW1zICYgeyBrZXk6IGFueTsgfSkgPT4gKCkgPT4gaW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG5cdCAqL1xuXHRmdW5jdGlvbiB0cmFuc2l0aW9uKGl0ZW1zLCBjb3VudGVycGFydHMsIGludHJvKSB7XG5cdFx0cmV0dXJuIChub2RlLCBwYXJhbXMpID0+IHtcblx0XHRcdGl0ZW1zLnNldChwYXJhbXMua2V5LCBub2RlKTtcblx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdGlmIChjb3VudGVycGFydHMuaGFzKHBhcmFtcy5rZXkpKSB7XG5cdFx0XHRcdFx0Y29uc3Qgb3RoZXJfbm9kZSA9IGNvdW50ZXJwYXJ0cy5nZXQocGFyYW1zLmtleSk7XG5cdFx0XHRcdFx0Y291bnRlcnBhcnRzLmRlbGV0ZShwYXJhbXMua2V5KTtcblx0XHRcdFx0XHRyZXR1cm4gY3Jvc3NmYWRlKG90aGVyX25vZGUsIG5vZGUsIHBhcmFtcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIG5vZGUgaXMgZGlzYXBwZWFyaW5nIGFsdG9nZXRoZXJcblx0XHRcdFx0Ly8gKGkuZS4gd2Fzbid0IGNsYWltZWQgYnkgdGhlIG90aGVyIGxpc3QpXG5cdFx0XHRcdC8vIHRoZW4gd2UgbmVlZCB0byBzdXBwbHkgYW4gb3V0cm9cblx0XHRcdFx0aXRlbXMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuXHRcdFx0XHRyZXR1cm4gZmFsbGJhY2sgJiYgZmFsbGJhY2sobm9kZSwgcGFyYW1zLCBpbnRybyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFt0cmFuc2l0aW9uKHRvX3NlbmQsIHRvX3JlY2VpdmUsIGZhbHNlKSwgdHJhbnNpdGlvbih0b19yZWNlaXZlLCB0b19zZW5kLCB0cnVlKV07XG59XG4iLCI8c3ZlbHRlOm9wdGlvbnMgYWNjZXNzb3JzIC8+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCBLbm9iIGZyb20gXCIuL0tub2Iuc3ZlbHRlXCJcblx0aW1wb3J0IHsgZmFkZSwgc2xpZGUgfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XG5cdGltcG9ydCB7Z2FsbGVyeV9vcGVufSBmcm9tICdzdG9yZSdcblxuXHQvLyBleHBvcnQgbGV0IGNoaWxkXG4gIGV4cG9ydCBsZXQgaGlkZGVuOiBib29sZWFuID0gdHJ1ZVxuICBleHBvcnQgbGV0IGtub2I6IEtub2Jcbjwvc2NyaXB0PlxuXG5cbnsjaWYgIWhpZGRlbn1cbjxkaXYgaWQ9J2JhcicgdHJhbnNpdGlvbjpzbGlkZT17e2R1cmF0aW9uOiAyMDB9fSBzdHlsZT17JGdhbGxlcnlfb3BlbiA/IFwiZGlzcGxheTogbm9uZTtcIiA6IFwiXCJ9PlxuICA8c2xvdD48L3Nsb3Q+XG48L2Rpdj5cbnsvaWZ9XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAjYmFyIHtcblx0XHR6LWluZGV4OiAwICFpbXBvcnRhbnQ7XG4gICAgYmFja2dyb3VuZDogYmxhY2s7XG4gICAgLy8gcG9zaXRpb246IGFic29sdXRlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogNnJlbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBhZGRpbmc6IDByZW0gMXJlbTtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGJhY2tncm91bmQ6IGJsYWNrO1xuICAgIC8vIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICAvLyBoZWlnaHQ6IDZyZW07XG4gICAgZGlzcGxheTogZmxleDtcbiAgICAvLyBwYWRkaW5nOiAwcmVtIDFyZW07XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICA+Omdsb2JhbChkaXYpIHtcbiAgICAgIG1heC1oZWlnaHQ6IDRyZW07XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAmOm5vdCg6Zmlyc3Qtb2YtdHlwZSl7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAwLjI1cmVtO1xuICAgICAgfVxuXG4gICAgICBtYXJnaW4tcmlnaHQ6IDAuMjVyZW07XG4gICAgICAvLyBtYXgtaGVpZ2h0OiAyLjVyZW07XHRcbiAgICAgIHotaW5kZXg6IDE7XG4gICAgICAmOmxhc3Qtb2YtdHlwZSB7XG4gICAgICAgIG1hcmdpbi1yaWdodDogNHJlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbjwvc3R5bGU+IiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBtaW4gfSBmcm9tICd3bWF0aCdcblx0aW1wb3J0IFNlbWlNb2RhbCBmcm9tICcuL1NlbWlNb2RhbC5zdmVsdGUnXG5cdGltcG9ydCB7b25Nb3VudH0gZnJvbSAnc3ZlbHRlJ1xuXHRpbXBvcnQgeyBzYXR1cmF0ZSB9IGZyb20gJ0AwYjV2ci9leHBlcmltZW50YWwnXG5cblx0ZXhwb3J0IGxldCB2YWx1ZVxuICBcbiAgZXhwb3J0IGxldCB0cmlnZ2VyTW9kYWw6IHVuZGVmaW5lZCB8ICgobW9kYWw6IFNlbWlNb2RhbCk9PnZvaWQpID0gdW5kZWZpbmVkXG4gIGV4cG9ydCBsZXQgbW9kYWw6IFNlbWlNb2RhbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICBcbiAgZXhwb3J0IGxldCBtb2RhbEhpZGRlbiA9IHRydWVcbiAgZXhwb3J0IGxldCB0aXRsZSA9IFwiXCJcblxuICBsZXQgdGl0bGVFbGVtZW50OiBIVE1MRGl2RWxlbWVudFxuXG5cdGNvbnN0IHJvdFJhbmdlID0gMiAqIE1hdGguUEkgKiAwLjgzO1xuXG5cdGxldCBzdGFydFkgPSAwXG4gIGxldCBzdGFydFggPSAwO1xuICBsZXQgc3RhcnRWYWx1ZSA9IDBcblx0JDogcm90YXRpb24gPSAtTWF0aC5QSSAqIDAuODMgKyAodmFsdWUpICogcm90UmFuZ2U7XG4gIFxuXHRjb25zdCBwb2ludGVyTW92ZSA9ICh7IGNsaWVudFgsIGNsaWVudFkgfSkgPT4ge1xuXHRcdGxldCBzY2FsZSA9IDMuL21pbihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIFxuXG5cdFx0bGV0IHZhbHVlRGlmZiA9IChzdGFydFkgLSBjbGllbnRZKSAqIHNjYWxlO1xuXHRcdHZhbHVlRGlmZiAtPSAoc3RhcnRYIC0gY2xpZW50WCkgKnNjYWxlO1xuXHRcdHZhbHVlID0gc2F0dXJhdGUoc3RhcnRWYWx1ZSArIHZhbHVlRGlmZilcblx0fVxuXHRcblx0Y29uc3QgcG9pbnRlckRvd24gPSAoZTogUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgbGV0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZVxuXHRcdHN0YXJ0WSA9IGNsaWVudFk7XG5cdFx0c3RhcnRYID0gY2xpZW50WDtcblx0XHRzdGFydFZhbHVlID0gdmFsdWU7XG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBwb2ludGVyTW92ZSk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHBvaW50ZXJVcCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKSBcblx0fVxuXHRcblx0ZnVuY3Rpb24gcG9pbnRlclVwKCkge1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHBvaW50ZXJNb3ZlKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcG9pbnRlclVwKTtcblx0fVxuICBcblxuICBvbk1vdW50KCgpPT57XG4gICAgbGV0IHBvaW50ZXJEb3duXG4gICAgbGV0IHBvaW50ZXJVcCA9ICgpPT57XG4gICAgICBpZihtb2RhbCl7XG4gICAgICAgIHRyaWdnZXJNb2RhbD8uKG1vZGFsKVxuICAgICAgICBtb2RhbEhpZGRlbiA9IG1vZGFsLmhpZGRlbiBhcyBib29sZWFuXG4gICAgICB9XG4gICAgICB0aXRsZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJwb2ludGVyZG93blwiLCBwb2ludGVyRG93bilcbiAgICB9XG4gICAgcG9pbnRlckRvd24gPSAoKT0+e1xuICAgICAgdGl0bGVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwKVxuICAgICAgdGl0bGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwKVxuICAgIH1cbiAgICB0aXRsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHBvaW50ZXJEb3duKVxuICB9KVxuXG48L3NjcmlwdD5cblxuXG48ZGl2IGRyYWdnYWJsZT1cImZhbHNlXCIgY2xhc3M9J2tub2ItY29udGFpbmVyLWNvbnRhaW5lcic+XG4gIDxkaXYgY2xhc3M9J2tub2ItY29udGFpbmVyJz5cbiAgICA8ZGl2IGNsYXNzPVwia25vYlwiIHN0eWxlPVwidHJhbnNmb3JtOnJvdGF0ZShjYWxjKHtyb3RhdGlvbn0gKiAxcmFkKSlcIiBvbjpwb2ludGVyZG93bj17cG9pbnRlckRvd259ID5cbiAgICAgIDxzdmcgd2lkdGg9JzEwMCUnIGhlaWdodD0nMTAwJScgdmlld0JveD1cIjAgMCAxMDAgMTAwXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgPHBhdGggc3Ryb2tlLXdpZHRoPVwiMTBcIiBkPVwiTTUwIDQwIGwwIC01MFwiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgPGRpdiBcbiAgICBjbGFzcz1cInRpdGxlIHt0cmlnZ2VyTW9kYWwgPyBcIm1lbnUtdG9nZ2xlXCIgOiBcIlwifVwiIFxuICAgIGJpbmQ6dGhpcz17dGl0bGVFbGVtZW50fVxuICAgIHN0eWxlPSd7IW1vZGFsSGlkZGVuICYmIFwib3V0bGluZTogMXB4IHNvbGlkIHdoaXRlOyBvdXRsaW5lLW9mZnNldDogMC4xcmVtO1wifSB7bW9kYWwgJiYgXCJjdXJzb3I6IHBvaW50ZXI7XCJ9J1xuICAgID57dGl0bGV9PC9kaXY+XG48L2Rpdj5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4gIC5rbm9iLWNvbnRhaW5lci1jb250YWluZXJ7XG4gICAgYXNwZWN0LXJhdGlvOiAxLzE7XG4gICAgLy8gbWF4LWhlaWdodDogNTAlO1xuICAgIG1hcmdpbi10b3A6IDAuNXJlbTtcbiAgICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgID4udGl0bGUubWVudS10b2dnbGV7XG4gICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICAgIGNvbG9yOiBibGFjaztcbiAgICB9XG4gICAgPi50aXRsZSB7XG4gICAgICBcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgIC8qIHBvc2l0aW9uOiBhYnNvbHV0ZTsgKi9cbiAgICAgIGZvbnQtc2l6ZTogMC44cmVtICFpbXBvcnRhbnQ7XG4gICAgICAvKiBwb3NpdGlvbjogYWJzb2x1dGU7ICovXG4gICAgICBtYXJnaW4tdG9wOiAwLjVyZW07XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XG4gICAgICB0b3A6IDUuNXJlbTtcbiAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIH1cbiAgICA+Lmtub2ItY29udGFpbmVye1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICY6aG92ZXJ7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgIH1cbiAgICAgIGFzcGVjdC1yYXRpbzogMS8xO1xuICAgICAgLyogd2lkdGg6IDQwcHg7XG4gICAgICBoZWlnaHQ6IDQwcHg7ICovXG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJhY2tncm91bmQtaW1hZ2U6IGNvbmljLWdyYWRpZW50KGZyb20gNDVkZWcsXG4gICAgICAgIHZhcigtLXNlY29uZGFyeS1jb2xvcikgMGRlZyAxNWRlZyxcbiAgICAgICAgdmFyKC0tdGVydGlhcnktY29sb3IpIDYwZGVnIDYwZGVnLFxuICAgICAgICB2YXIoLS1kYXJrZW4tY29sb3IpIDEyMGRlZyAyNDBkZWcsXG4gICAgICAgIHZhcigtLXRlcnRpYXJ5LWNvbG9yKSAzMDBkZWcgMzAwZGVnLFxuICAgICAgICB2YXIoLS1zZWNvbmRhcnktY29sb3IpIDM0NWRlZyAzNjBkZWdcbiAgICAgICk7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICBib3JkZXI6IDAuMnJlbSBzb2xpZCB3aGl0ZTtcbiAgICB9XG4gICAgPi5rbm9iIHtcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgYXNwZWN0LXJhdGlvOiAxLzE7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAvKiBoZWlnaHQ6IDgwJTsgKi9cbiAgICAgIHBhZGRpbmc6IDA7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICBjb2xvcjogdmFyKC0tdGV4dC1jb2xvcik7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10ZXJ0aWFyeS1jb2xvcik7XG4gICAgICBib3gtc2hhZG93OiAwIDAgLjNlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMykgaW5zZXQ7XG4gICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xuICAgIH1cblxuICAgID4ua25vYiBzdmd7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG4gIH1cblxuPC9zdHlsZT4iLCI8c3ZlbHRlOm9wdGlvbnMgYWNjZXNzb3JzIC8+XG5cbjxkaXYgY2xhc3M9XCJrbm9iLWNvbnRhaW5lci1jb250YWluZXJcIiBjbGFzczprbm9iLXNlbGVjdGVkPXtkcmFnZ2luZ30gb246cG9pbnRlcmRvd249e3BvaW50ZXJEb3dufT5cblx0PGRpdiBjbGFzcz1cImtub2ItY29udGFpbmVyXCI+XG5cdFx0PGRpdiBjbGFzcz1cImtub2JcIj5cblx0XHRcdHtAaHRtbCBicnVzaFNpemVJY29ufVxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cbjwvZGl2PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBjbGFtcCwgbWluIH0gZnJvbSAnd21hdGgnXG5cdC8vIEB0cy1pZ25vcmVcblx0aW1wb3J0IGJydXNoU2l6ZUljb24gZnJvbSAnLy4uL3B1YmxpYy9jb3B5LnN2ZydcblxuXHRleHBvcnQgbGV0IGJydXNoX3N6OiBudW1iZXJbXSA9IFswLjIsIDAuMl1cblxuXHRleHBvcnQgbGV0IGRyYWdnaW5nOiBib29sZWFuID0gZmFsc2Vcblx0ZXhwb3J0IGxldCBzdG9wcGVkX2RyYWdnaW5nOiBib29sZWFuID0gZmFsc2VcblxuXHRsZXQgc3RhcnRZID0gMFxuXHRsZXQgc3RhcnRWYWx1ZSA9IFswLCAwXVxuXHRsZXQgc3RhcnRYID0gMFxuXG5cdGNvbnN0IHBvaW50ZXJNb3ZlID0gKHtjbGllbnRYLCBjbGllbnRZfSkgPT4ge1xuXHRcdGNvbnN0IHNjYWxlID0gMTAuL21pbihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIFxuXG5cdFx0Y29uc3QgdmFsdWVEaWZmWSA9IChzdGFydFkgLSBjbGllbnRZKSAqIHNjYWxlXG5cdFx0Y29uc3QgdmFsdWVEaWZmWCA9IChzdGFydFggLSBjbGllbnRYKSAqIHNjYWxlXG5cblx0XHRicnVzaF9zelswXSA9IGNsYW1wKHN0YXJ0VmFsdWVbMF0gLSB2YWx1ZURpZmZYLDAsNSlcblx0XHRicnVzaF9zelsxXSA9IGNsYW1wKHN0YXJ0VmFsdWVbMV0gKyB2YWx1ZURpZmZZLDAsNSlcblx0fVxuXG5cdGNvbnN0IHBvaW50ZXJEb3duID0gKGU6IFBvaW50ZXJFdmVudCkgPT4ge1xuXHRcdGRyYWdnaW5nID0gdHJ1ZVxuXHRcdGNvbnN0IHtjbGllbnRYLCBjbGllbnRZfSA9IGVcblx0XHRzdGFydFkgPSBjbGllbnRZXG5cdFx0c3RhcnRYID0gY2xpZW50WFxuXHRcdHN0YXJ0VmFsdWUgPSBbLi4uYnJ1c2hfc3pdXG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBwb2ludGVyTW92ZSlcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcG9pbnRlclVwKVxuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKClcblx0fVxuXG5cdGZ1bmN0aW9uIHBvaW50ZXJVcCgpIHtcblx0XHRkcmFnZ2luZyA9IGZhbHNlXG5cdFx0c3RvcHBlZF9kcmFnZ2luZyA9IHRydWVcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBwb2ludGVyTW92ZSlcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcG9pbnRlclVwKVxuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4gIEBpbXBvcnQgXCIvLi4vc3R5bGVzL2ljb24uc2Nzc1wiIHNjb3BlZDsgXG5cdC5rbm9iLWNvbnRhaW5lci1jb250YWluZXIge1xuXHRcdGFzcGVjdC1yYXRpbzogMS8xO1xuXG5cdFx0JjphY3RpdmV7XG5cdFx0XHRmaWx0ZXI6IGludmVydCgxKTtcblx0XHR9XG5cblx0XHQua25vYntcblx0XHRcdCY6YWN0aXZle1xuXHRcdFx0XHRmaWx0ZXI6IGludmVydCgwKTtcblx0XHRcdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuICAgIC8vIG1heC1oZWlnaHQ6IHVuc2V0ICFpbXBvcnRhbnQ7XG4gICAgLy8gZGlzcGxheTogZmxleDtcbiAgICAvLyBhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdCY6aG92ZXIge1xuXHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdH1cblx0XHQvLyBoZWlnaHQ6IDEwMCU7XG5cdFx0Lmtub2ItY29udGFpbmVye1xuXHRcdFx0bWFyZ2luLWxlZnQ6IDA7XG5cdFx0XHRtYXJnaW4tcmlnaHQ6IDA7XG5cdFx0XHQvLyBwYWRkaW5nOiAwLjNyZW07XG5cdFx0fVxuXHR9XG5cbjwvc3R5bGU+XG4iLCJpbXBvcnQge0JydXNoU3Ryb2tlfSBmcm9tICdicnVzaF9zdHJva2UnXG5pbXBvcnQge1RleHR1cmV9IGZyb20gJ2dsL1RleHR1cmUnXG5pbXBvcnQge3Bvd30gZnJvbSAnd21hdGgnXG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodjogYm9vbGVhbikge1xuXHRpZiAoIXYpIGRlYnVnZ2VyXG59XG5cbmV4cG9ydCBjbGFzcyBCcnVzaFRleHR1cmUge1xuXHQvLyBAdHMtaWdub3JlXG5cdGdwdV90ZXg6IFRleHR1cmUgPSB1bmRlZmluZWRcblx0Ly8gQHRzLWlnbm9yZVxuXHRwYXRoOiBzdHJpbmcgPSB1bmRlZmluZWRcblx0Ly8gQHRzLWlnbm9yZVxuXHRpZHg6IG51bWJlclxuXG5cdHN0YXRpYyBhc3luYyBjcmVhdGUocGF0aCwgaWR4OiBudW1iZXIpOiBQcm9taXNlPEJydXNoVGV4dHVyZT4ge1xuXHRcdGNvbnN0IGdwdV90ZXggPSBhd2FpdCBUZXh0dXJlLmZyb21faW1hZ2VfcGF0aChwYXRoKVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdwdV90ZXgsXG5cdFx0XHRwYXRoLFxuXHRcdFx0aWR4LFxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgY2xhc3MgUHJvamVjdCB7XG5cdGlkOiBudW1iZXIgPSBEYXRlLm5vdygpXG5cdHNhdmVkOiBib29sZWFuID0gZmFsc2Vcblx0YnJ1c2hfc3Ryb2tlczogQnJ1c2hTdHJva2VbXSA9IFtdXG5cdGNhbnZhc1JlczogbnVtYmVyW10gPSBbMTAyNCwgMjA0OF1cblx0Ly8gY2FudmFzUmVzOiBudW1iZXJbXSA9IFsyMDQ4LCAxMDI0XVxuXHRjb25zdHJ1Y3RvcigpIHt9XG5cdHB1c2hfc3Ryb2tlKHN0cm9rZTogQnJ1c2hTdHJva2UpIHtcblx0XHR0aGlzLmJydXNoX3N0cm9rZXMucHVzaChzdHJva2UpXG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIFV0aWxzIHtcblx0c3RhdGljIGlzT25Nb2JpbGUgPSAoKTogYm9vbGVhbiA9PiB7XG5cdFx0bGV0IGNoZWNrID0gZmFsc2Vcblx0XHQ7KGZ1bmN0aW9uIChhKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm98YW5kcm9pZHxpcGFkfHBsYXlib29rfHNpbGsvaS50ZXN0KFxuXHRcdFx0XHRcdGEsXG5cdFx0XHRcdCkgfHxcblx0XHRcdFx0LzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdChcblx0XHRcdFx0XHRhLnN1YnN0cigwLCA0KSxcblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdFx0XHRjaGVjayA9IHRydWVcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHR9KShuYXZpZ2F0b3IudXNlckFnZW50IHx8IG5hdmlnYXRvci52ZW5kb3IgfHwgd2luZG93Lm9wZXJhKVxuXHRcdHJldHVybiBjaGVja1xuXHR9XG5cdHN0YXRpYyBnYW1tYV9jb3JyZWN0KHU6IG51bWJlcltdLCBpbnZlcnNlOiBib29sZWFuID0gZmFsc2UsIG1vZGlmeTogYm9vbGVhbiA9IGZhbHNlKSB7XG5cdFx0Y29uc3QgZXhwb25lbnQgPSBpbnZlcnNlID8gMSAvIDAuNDU0NTQ1NDU0NTQ1NDUgOiAwLjQ1NDU0NTQ1NDU0NTQ1XG5cdFx0aWYgKCFtb2RpZnkpIHUgPSBbLi4udV1cblx0XHR1LmZvckVhY2goKHYsIGksIGEpID0+IHtcblx0XHRcdGFbaV0gPSBwb3codiwgZXhwb25lbnQpXG5cdFx0fSlcblx0XHRyZXR1cm4gdVxuXHR9XG5cdHN0YXRpYyBjc3NfY29udGFpbih1OiBudW1iZXJbXSwgaW5wdXRfcmVzOiBudW1iZXJbXSwgdGV4X3JlczogbnVtYmVyW10pOiBudW1iZXJbXSB7XG5cdFx0Y29uc3QgdXNlcl9yZXMgPSBpbnB1dF9yZXNcblx0XHRjb25zdCBjYW52YXNfcmVzID0gdGV4X3Jlc1xuXG5cdFx0Y29uc3QgaW5wdXRfcmF0aW8gPSB1c2VyX3Jlc1swXSAvIHVzZXJfcmVzWzFdXG5cdFx0Y29uc3QgdGV4X3JhdGlvID0gY2FudmFzX3Jlc1swXSAvIGNhbnZhc19yZXNbMV1cblx0XHRjb25zdCByYXRpbyA9IGlucHV0X3JhdGlvIC8gdGV4X3JhdGlvXG5cblx0XHRpZiAocmF0aW8gPiAxKSB7XG5cdFx0XHRyZXR1cm4gW3VbMF0gKiByYXRpbywgdVsxXV1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFt1WzBdLCB1WzFdIC8gcmF0aW9dXG5cdFx0fVxuXHR9XG5cdHN0YXRpYyBzY3JlZW5fTkRDX3RvX2NhbnZhc19OREMoXG5cdFx0dTogbnVtYmVyW10sXG5cdFx0dXNlcl90ZXg6IFRleHR1cmUsXG5cdFx0Y2FudmFzX3RleDogVGV4dHVyZSxcblx0XHR6b29tOiBudW1iZXIsXG5cdFx0cGFuOiBudW1iZXJbXSB8IEZsb2F0MzJBcnJheSxcblx0KTogbnVtYmVyW10ge1xuXHRcdGNvbnN0IHVzZXJfcmVzID0gdXNlcl90ZXgucmVzXG5cdFx0Y29uc3QgY2FudmFzX3JlcyA9IGNhbnZhc190ZXgucmVzXG5cblx0XHR1ID0gWy4uLnVdXG5cblx0XHRjb25zdCBpbnB1dF9yYXRpbyA9IHVzZXJfcmVzWzBdIC8gdXNlcl9yZXNbMV1cblx0XHRjb25zdCB0ZXhfcmF0aW8gPSBjYW52YXNfcmVzWzBdIC8gY2FudmFzX3Jlc1sxXVxuXHRcdGNvbnN0IHJhdGlvID0gaW5wdXRfcmF0aW8gLyB0ZXhfcmF0aW9cblxuXHRcdGlmIChyYXRpbyA+IDEpIHtcblx0XHRcdHVbMF0gKj0gcmF0aW8gLyB6b29tXG5cdFx0XHR1WzFdIC89IHpvb21cblxuXHRcdFx0Y29uc3QgY29udCA9IFV0aWxzLmNzc19jb250YWluKFsxLCAxXSwgdXNlcl9yZXMsIGNhbnZhc19yZXMpXG5cblx0XHRcdHVbMF0gLT0gcGFuWzBdICogY29udFswXVxuXHRcdFx0dVsxXSAtPSBwYW5bMV0gKiBjb250WzFdXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHVbMV0gLT0gKDEgLSByYXRpbykgKiAwLjVcblx0XHRcdHVbMF0gLz0gem9vbVxuXHRcdFx0dVsxXSAvPSByYXRpbyAqIHpvb21cblxuXHRcdFx0Y29uc3QgY29udCA9IFV0aWxzLmNzc19jb250YWluKFsxLCAxXSwgdXNlcl9yZXMsIGNhbnZhc19yZXMpXG5cblx0XHRcdHVbMF0gLT0gcGFuWzBdICogY29udFswXVxuXHRcdFx0dVsxXSAtPSBwYW5bMV0gKiBjb250WzFdXG5cdFx0fVxuXHRcdHJldHVybiB1XG5cdH1cblx0c3RhdGljIHRleHR1cmVfTkRDX3RvX3RleHR1cmVfcGl4ZWxfY29vcmRzKHU6IG51bWJlcltdIHwgRmxvYXQzMkFycmF5LCB0ZXg6IFRleHR1cmUpOiBudW1iZXJbXSB7XG5cdFx0cmV0dXJuIFsodVswXSAqIDAuNSArIDAuNSkgKiB0ZXgucmVzWzBdLCAodVsxXSAqIDAuNSArIDAuNSkgKiB0ZXgucmVzWzFdXVxuXHR9XG59XG4iLCJpbXBvcnQge0JydXNoVGV4dHVyZX0gZnJvbSAnc3R1ZmYnXG5cbmV4cG9ydCBlbnVtIEJsZW5kaW5nQ29sb3VyU3BhY2Uge1xuXHRSR0IsXG5cdE9rTENILFxuXHRQaWdtZW50cyxcbn1cblxuZXhwb3J0IGNsYXNzIERyYXdQYXJhbXMge1xuXHR0ZXhfZHluYW1pY3M6IG51bWJlciA9IDAuM1xuXHR0ZXhfbGNoX2R5bmFtaWNzOiBudW1iZXJbXSA9IFswLCAwLCAwLjJdXG5cdG5vaXNlX3N0cmV0Y2g6IG51bWJlcltdID0gWzEsIDAuMl1cblx0dGV4X3N0cmV0Y2g6IG51bWJlcltdID0gWzEsIDAuMl1cblxuXHRibGVuZGluZ19jb2xvdXJfc3BhY2UgPSBCbGVuZGluZ0NvbG91clNwYWNlLlBpZ21lbnRzXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHRleF9keW5hbWljczogbnVtYmVyLFxuXHRcdHRleF9sY2hfZHluYW1pY3M6IG51bWJlcltdLFxuXHRcdG5vaXNlX3N0cmV0Y2g6IG51bWJlcltdLFxuXHRcdHRleF9zdHJldGNoOiBudW1iZXJbXSxcblx0XHRibGVuZGluZ19jb2xvdXJfc3BhY2U6IEJsZW5kaW5nQ29sb3VyU3BhY2UsXG5cdCkge1xuXHRcdHRoaXMudGV4X2R5bmFtaWNzID0gdGV4X2R5bmFtaWNzXG5cdFx0dGhpcy50ZXhfbGNoX2R5bmFtaWNzID0gWy4uLnRleF9sY2hfZHluYW1pY3NdXG5cdFx0dGhpcy5ub2lzZV9zdHJldGNoID0gWy4uLm5vaXNlX3N0cmV0Y2hdXG5cdFx0dGhpcy50ZXhfc3RyZXRjaCA9IFsuLi50ZXhfc3RyZXRjaF1cblx0XHR0aGlzLmJsZW5kaW5nX2NvbG91cl9zcGFjZSA9IGJsZW5kaW5nX2NvbG91cl9zcGFjZVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBCcnVzaFByZXNldCB7XG5cdHNlbGVjdGVkX2JydXNoX3R5cGU6IEJydXNoVHlwZSA9IEJydXNoVHlwZS5CbG9ic1xuXG5cdGNoYW9zX2xjaDogQXJyYXk8bnVtYmVyPiA9IFswLCAwLCAxXVxuXHRjaGFvc19zcGVlZDogbnVtYmVyID0gMC4zXG5cdGNoYW9zOiBudW1iZXIgPSAwLjdcblxuXHRkeW5hbWljczogbnVtYmVyID0gMC4zXG5cdHN0cm9rZV9vcGFjaXR5X2R5bmFtaWNzOiBudW1iZXJbXSA9IFswLCAxXVxuXHRzdHJva2Vfc2l6ZV9keW5hbWljczogbnVtYmVyW10gPSBbMC43LCAxXVxuXHRyb3Rfaml0dGVyOiBudW1iZXIgPSAwXG5cdHBvc19qaXR0ZXI6IG51bWJlciA9IDBcblxuXHQvLyBAdHMtaWdub3JlXG5cdHNlbGVjdGVkX2JydXNoX3RleHR1cmU6IEJydXNoVGV4dHVyZSA9IHVuZGVmaW5lZFxuXG5cdHRleF9keW5hbWljczogbnVtYmVyID0gMC4zXG5cdHRleF9sY2hfZHluYW1pY3M6IG51bWJlcltdID0gWzAsIDAsIDAuMDJdXG5cdG5vaXNlX3N0cmV0Y2g6IG51bWJlcltdID0gWzEsIDAuMl1cblx0dGV4X3N0cmV0Y2g6IG51bWJlcltdID0gWzEsIDAuMl1cblxuXHRjb25zdHJ1Y3RvcigpIHt9XG59XG5cbmV4cG9ydCBlbnVtIEJydXNoVHlwZSB7XG5cdEJsb2JzLFxuXHRMb25nLFxuXHRUcmksXG59XG5leHBvcnQgY2xhc3MgQnJ1c2hTdHJva2Uge1xuXHRicnVzaF90eXBlOiBCcnVzaFR5cGVcblx0YnJ1c2hfdGV4dHVyZTogQnJ1c2hUZXh0dXJlXG5cdGRyYXdfcGFyYW1zOiBEcmF3UGFyYW1zXG5cdHBvc2l0aW9uczogbnVtYmVyW10gPSBbXVxuXHRyb3RhdGlvbnM6IG51bWJlcltdID0gW11cblx0c2l6ZXM6IG51bWJlcltdID0gW11cblx0b3BhY2l0aWVzOiBudW1iZXJbXSA9IFtdXG5cdGNvbG91cnM6IG51bWJlcltdID0gW11cblxuXHRpZHg6IG51bWJlciA9IDBcblx0Y29uc3RydWN0b3IoYnJ1c2hfdHlwZTogQnJ1c2hUeXBlLCBkcmF3X3BhcmFtczogRHJhd1BhcmFtcywgYnJ1c2hfdGV4dHVyZTogQnJ1c2hUZXh0dXJlKSB7XG5cdFx0dGhpcy5kcmF3X3BhcmFtcyA9IGRyYXdfcGFyYW1zXG5cdFx0dGhpcy5icnVzaF90eXBlID0gYnJ1c2hfdHlwZVxuXHRcdHRoaXMuYnJ1c2hfdGV4dHVyZSA9IGJydXNoX3RleHR1cmVcblx0fVxuXHRwdXNoX3N0cm9rZShwb3NpdGlvbjogbnVtYmVyW10sIHJvdGF0aW9uOiBudW1iZXJbXSwgc2l6ZTogbnVtYmVyW10sIG9wYWNpdHk6IG51bWJlciwgY29sb3VyOiBudW1iZXJbXSkge1xuXHRcdC8vIGFzc2VydChwb3NpdGlvbi5sZW5ndGggPT09IDIpXG5cdFx0Ly8gYXNzZXJ0KHJvdGF0aW9uLmxlbmd0aCA9PT0gMilcblx0XHQvLyBhc3NlcnQoY29sb3VyLmxlbmd0aCA9PT0gMylcblx0XHRjb25zdCBjdXJyX2lkeCA9IHRoaXMuaWR4XG5cdFx0dGhpcy5wb3NpdGlvbnMubGVuZ3RoICs9IDJcblx0XHR0aGlzLnJvdGF0aW9ucy5sZW5ndGggKz0gMlxuXHRcdHRoaXMuc2l6ZXMubGVuZ3RoICs9IDJcblx0XHR0aGlzLm9wYWNpdGllcy5sZW5ndGggKz0gMVxuXHRcdHRoaXMuY29sb3Vycy5sZW5ndGggKz0gM1xuXHRcdHRoaXMucG9zaXRpb25zW2N1cnJfaWR4ICogMl0gPSBwb3NpdGlvblswXVxuXHRcdHRoaXMucG9zaXRpb25zW2N1cnJfaWR4ICogMiArIDFdID0gcG9zaXRpb25bMV1cblx0XHR0aGlzLnNpemVzW2N1cnJfaWR4ICogMl0gPSBzaXplWzBdXG5cdFx0dGhpcy5zaXplc1tjdXJyX2lkeCAqIDIgKyAxXSA9IHNpemVbMV1cblx0XHR0aGlzLnJvdGF0aW9uc1tjdXJyX2lkeCAqIDJdID0gcm90YXRpb25bMF1cblx0XHR0aGlzLnJvdGF0aW9uc1tjdXJyX2lkeCAqIDIgKyAxXSA9IHJvdGF0aW9uWzFdXG5cdFx0dGhpcy5vcGFjaXRpZXNbY3Vycl9pZHhdID0gb3BhY2l0eVxuXHRcdHRoaXMuY29sb3Vyc1tjdXJyX2lkeCAqIDNdID0gY29sb3VyWzBdXG5cdFx0dGhpcy5jb2xvdXJzW2N1cnJfaWR4ICogMyArIDFdID0gY29sb3VyWzFdXG5cdFx0dGhpcy5jb2xvdXJzW2N1cnJfaWR4ICogMyArIDJdID0gY29sb3VyWzJdXG5cdFx0dGhpcy5pZHgrK1xuXHR9XG59XG4iLCI8c3ZlbHRlOm9wdGlvbnMgYWNjZXNzb3JzIC8+XG5cbjxkaXYgY2xhc3M9XCJrbm9iLWNvbnRhaW5lci1jb250YWluZXJcIj5cblx0eyNlYWNoIGJydXNoX3R5cGVzIGFzIGJydXNoX3R5cGUsIGl9XG5cdFx0PGRpdlxuXHRcdFx0Y2xhc3M9XCJ0aXRsZSBtZW51LXRvZ2dsZVwiXG5cdFx0XHRiaW5kOnRoaXM9e2VsZW1lbnRzW2ldfVxuXHRcdFx0cm9sZT1cImJ1dHRvblwiXG5cdFx0XHR0YWJpbmRleD1cIjBcIlxuXHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0Y3Vycl9icnVzaC5zZWxlY3RlZF9icnVzaF90eXBlID0gQnJ1c2hUeXBlW2JydXNoX3R5cGVdXG5cdFx0XHRcdGxldCBrID0gMFxuXHRcdFx0XHRmb3IgKGxldCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG5cdFx0XHRcdFx0aWYgKGsgPT09IGkpIHtcblx0XHRcdFx0XHRcdGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICcxcHggc29saWQgd2hpdGUnXG5cdFx0XHRcdFx0XHRlbGVtZW50LnN0eWxlLm91dGxpbmVPZmZzZXQgPSAnMHJlbSdcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJzBweCBzb2xpZCB3aGl0ZSdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aysrXG5cdFx0XHRcdH1cblx0XHRcdH19XG5cdFx0XHRzdHlsZT1cImN1cnNvcjogcG9pbnRlcjtcIj5cblx0XHRcdHtAaHRtbCBpID09PSAwID8gYnJ1c2hfYmxvYnNfaWNvbiA6IGkgPT09IDEgPyBicnVzaF9sb25nX2ljb24gOiBicnVzaF90cmlhbmdsZXNfaWNvbn1cblx0XHQ8L2Rpdj5cblx0ey9lYWNofVxuPC9kaXY+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7QnJ1c2hQcmVzZXQsIEJydXNoVHlwZX0gZnJvbSAnYnJ1c2hfc3Ryb2tlJ1xuXHRpbXBvcnQge29uTW91bnR9IGZyb20gJ3N2ZWx0ZSdcblxuXHQvLyBAdHMtaWdub3JlXG5cdGltcG9ydCBicnVzaF9ibG9ic19pY29uIGZyb20gJy8uLi9wdWJsaWMvYnJ1c2gtYmxvYnMuc3ZnJ1xuXHQvLyBAdHMtaWdub3JlXG5cdGltcG9ydCBicnVzaF9sb25nX2ljb24gZnJvbSAnLy4uL3B1YmxpYy9icnVzaC1sb25nLnN2Zydcblx0Ly8gQHRzLWlnbm9yZVxuXHRpbXBvcnQgYnJ1c2hfdHJpYW5nbGVzX2ljb24gZnJvbSAnLy4uL3B1YmxpYy9icnVzaC10cmlhbmdsZXMuc3ZnJ1xuXG5cdGV4cG9ydCBsZXQgY3Vycl9icnVzaDogQnJ1c2hQcmVzZXRcblx0bGV0IHNlbGVjdGVkX2JydXNoX3R5cGU6IEJydXNoVHlwZVxuXG5cdGxldCBlbGVtZW50czogSFRNTERpdkVsZW1lbnRbXSA9IFtdXG5cdGxldCBicnVzaF90eXBlczogc3RyaW5nW10gPSBbXVxuXHRmb3IgKGxldCB0eXBlIG9mIE9iamVjdC5rZXlzKEJydXNoVHlwZSkuZmlsdGVyKCh2KSA9PiBpc05hTihOdW1iZXIodikpKSkge1xuXHRcdGJydXNoX3R5cGVzLnB1c2godHlwZSlcblx0XHRlbGVtZW50cy5sZW5ndGgrK1xuXHR9XG5cblx0Y29uc3QgdXBkYXRlX3N0eWxlcyA9ICgpID0+IHtcblx0XHRsZXQgayA9IDBcblx0XHR0cnkge1xuXHRcdFx0Zm9yIChsZXQgZWxlbWVudCBvZiBlbGVtZW50cykge1xuXHRcdFx0XHRsZXQgYnJ1c2hfdHlwZV9pbnQgPSBCcnVzaFR5cGVbYnJ1c2hfdHlwZXNba11dXG5cdFx0XHRcdGlmIChicnVzaF90eXBlX2ludCA9PT0gc2VsZWN0ZWRfYnJ1c2hfdHlwZSkge1xuXHRcdFx0XHRcdGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICcxcHggc29saWQgd2hpdGUnXG5cdFx0XHRcdFx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lT2Zmc2V0ID0gJzAuMXJlbSdcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnMHB4IHNvbGlkIHdoaXRlJ1xuXHRcdFx0XHR9XG5cdFx0XHRcdGsrK1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKF8pIHt9XG5cdH1cblxuXHQkOiB7XG5cdFx0c2VsZWN0ZWRfYnJ1c2hfdHlwZSA9IGN1cnJfYnJ1c2guc2VsZWN0ZWRfYnJ1c2hfdHlwZVxuXHRcdHVwZGF0ZV9zdHlsZXMoKVxuXHR9XG5cblx0b25Nb3VudCgoKSA9PiB7XG5cdFx0dXBkYXRlX3N0eWxlcygpXG5cdH0pXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5cdC5rbm9iLWNvbnRhaW5lci1jb250YWluZXIge1xuICAgIGFzcGVjdC1yYXRpbzogdW5zZXQ7XG4gICAgZGlzcGxheTogZ3JpZDtcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxZnI7XG5cdFx0Z3JpZC1jb2x1bW4tZ2FwOiAwLjRyZW07XG5cdFx0Z3JpZC1yb3ctZ2FwOiAwLjRyZW07XG5cbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB3aWR0aDogNHJlbTtcbiAgICBtYXgtd2lkdGg6IHVuc2V0O1xuXHRcdHBhZGRpbmc6IDAuMnJlbTtcbiAgICA+LnRpdGxlLm1lbnUtdG9nZ2xlIHtcbiAgICAgIDpnbG9iYWwoc3ZnKSB7XG4gICAgICAgIGZpbGw6IHdoaXRlO1xuICAgICAgICAmOmFjdGl2ZSB7XG4gICAgICAgICAgZmlsdGVyOiBpbnZlcnQoMSk7XG4gICAgICAgICAgYmFja2dyb3VuZDogYmxhY2s7XG4gICAgICAgIH1cblx0XHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0XHR3aWR0aDogMTAwJTtcbiAgICAgIH1cbiAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuXHR9XG48L3N0eWxlPlxuIiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBCcnVzaFByZXNldH0gZnJvbSAnYnJ1c2hfc3Ryb2tlJ1xuXHRpbXBvcnQge29uTW91bnR9IGZyb20gJ3N2ZWx0ZSdcblxuICBleHBvcnQgbGV0IGJydXNoX3ByZXNldHM6IEJydXNoUHJlc2V0W11cbiAgZXhwb3J0IGxldCBzZWxlY3RlZF9icnVzaF9wcmVzZXQ6IEJydXNoUHJlc2V0XG5cbiAgbGV0IGVsZW1lbnRzOiBIVE1MRGl2RWxlbWVudFtdID0gW11cbiAgZm9yKGxldCBwcmVzZXQgb2YgYnJ1c2hfcHJlc2V0cyl7XG4gICAgZWxlbWVudHMubGVuZ3RoKytcbiAgfVxuXG4gIG9uTW91bnQoKCk9PntcbiAgICBsZXQgayA9IDAgXG4gICAgZm9yKGxldCBlbGVtZW50IG9mIGVsZW1lbnRzKXtcbiAgICAgIGlmKHNlbGVjdGVkX2JydXNoX3ByZXNldCA9PT0gYnJ1c2hfcHJlc2V0c1trXSl7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICcxcHggc29saWQgd2hpdGUnXG4gICAgICAgIGVsZW1lbnQuc3R5bGUub3V0bGluZU9mZnNldCA9ICcwLjFyZW0nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnMHB4IHNvbGlkIHdoaXRlJ1xuICAgICAgfVxuICAgICAgaysrXG4gICAgfVxuICB9KVxuPC9zY3JpcHQ+XG5cblxuPGRpdiBjbGFzcz0na25vYi1jb250YWluZXItY29udGFpbmVyJz5cbiAgeyNlYWNoIGJydXNoX3ByZXNldHMgYXMgcHJlc2V0LCBpfVxuICAgIDxkaXYgXG4gICAgICBjbGFzcz1cInRpdGxlIG1lbnUtdG9nZ2xlXCIgXG4gICAgICBiaW5kOnRoaXM9e2VsZW1lbnRzW2ldfVxuICAgICAgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIFxuICAgICAgb246Y2xpY2s9eygpPT57XG4gICAgICAgIHNlbGVjdGVkX2JydXNoX3ByZXNldCA9IHByZXNldFxuICAgICAgICBsZXQgayA9IDBcbiAgICAgICAgZm9yKGxldCBlbGVtZW50IG9mIGVsZW1lbnRzKXtcbiAgICAgICAgICBpZihrID09PSBpKXtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICcxcHggc29saWQgd2hpdGUnXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLm91dGxpbmVPZmZzZXQgPSAnMC4xcmVtJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnMHB4IHNvbGlkIHdoaXRlJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBrKytcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAgIHN0eWxlPSdjdXJzb3I6IHBvaW50ZXI7J1xuICAgICAgPntpLnRvU3RyaW5nKCl9PC9kaXY+XG4gIHsvZWFjaH1cbjwvZGl2PlxuICBcbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAua25vYi1jb250YWluZXItY29udGFpbmVye1xuICAgIGFzcGVjdC1yYXRpbzogdW5zZXQ7XG4gICAgZGlzcGxheTogZ3JpZDtcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAvLyB3aWR0aDogZml0LWNvbnRlbnQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMWZyIDFmcjtcbiAgICBcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB3aWR0aDogNHJlbTtcbiAgICAvLyBtYXgtaGVpZ2h0OiB1bnNldCAhaW1wb3J0YW50O1xuICAgIG1hcmdpbjogMDtcbiAgICBtYXJnaW4tdG9wOiBhdXRvO1xuICAgIG1hcmdpbi1ib3R0b206IGF1dG87XG4gICAgbWF4LXdpZHRoOiB1bnNldDtcbiAgICAvLyB3aWR0aDogZml0LWNvbnRlbnQ7XG4gICAgbWFyZ2luLXJpZ2h0OiAxcmVtO1xuICAgID4udGl0bGUubWVudS10b2dnbGV7XG4gICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICAgIGNvbG9yOiBibGFjaztcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbiAgICA+LnRpdGxlIHtcbiAgICAgIHBhZGRpbmc6IDAuMHJlbTtcbiAgICAgIGZvbnQtc2l6ZTogMC44cmVtICFpbXBvcnRhbnQ7XG4gICAgICBtYXJnaW46IDAuMHJlbTtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XG4gICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICB9XG4gIH1cbjwvc3R5bGU+IiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAvLyBAdHMtaWdub3JlXG4gIGltcG9ydCB1bmRvSWNvbiBmcm9tIFwiLy4uL3B1YmxpYy91bmRvLnN2Z1wiXG4gIC8vIEB0cy1pZ25vcmVcbiAgaW1wb3J0IHJlZG9JY29uIGZyb20gXCIvLi4vcHVibGljL3JlZG8uc3ZnXCIgXG4gIFxuICBcbiAgZXhwb3J0IGxldCByZWRvOiAoKT0+dm9pZFxuICBleHBvcnQgbGV0IHVuZG86ICgpPT52b2lkXG4gIFxuPC9zY3JpcHQ+XG5cbjwhLS0gPHN2ZWx0ZTpmcmFnbWVudD4gLS0+XG4gIDxkaXYgY2xhc3M9J2tub2ItY29udGFpbmVyJz5cbiAgICA8ZGl2IGNsYXNzPVwia25vYlwiIG9uOmNsaWNrPXsoKT0+dW5kbygpfT5cbiAgICAgIHtAaHRtbCB1bmRvSWNvbn1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9J2tub2ItY29udGFpbmVyJz5cbiAgICA8ZGl2IGNsYXNzPVwia25vYlwiIG9uOmNsaWNrPXsoKT0+cmVkbygpfT5cbiAgICAgIHtAaHRtbCByZWRvSWNvbn1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48IS0tIDwvc3ZlbHRlOmZyYWdtZW50PiAtLT5cblxuXG48IS0tIDxzdHlsZSBzcmM9Jy8uLi9zdHlsZXMvaWNvbi5zY3NzJz4gPC9zdHlsZT4gLS0+XG48c3R5bGUgbGFuZz1cInNjc3NcIj5cblxuICBAaW1wb3J0IFwiLy4uL3N0eWxlcy9pY29uLnNjc3NcIiBzY29wZWQ7IFxuICBcbiAgLmtub2ItY29udGFpbmVye1xuICAgIC8vIGFzcGVjdC1yYXRpbzogdW5zZXQ7IFxuICB9XG5cbjwvc3R5bGU+IiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZpcmViYXNlIGNvbnN0YW50cy4gIFNvbWUgb2YgdGhlc2UgKEBkZWZpbmVzKSBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBjb21waWxlLXRpbWUuXG4gKi9cblxuZXhwb3J0IGNvbnN0IENPTlNUQU5UUyA9IHtcbiAgLyoqXG4gICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgY2xpZW50IE5vZGUuanMgU0RLLlxuICAgKi9cbiAgTk9ERV9DTElFTlQ6IGZhbHNlLFxuICAvKipcbiAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBBZG1pbiBOb2RlLmpzIFNESy5cbiAgICovXG4gIE5PREVfQURNSU46IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxuICAgKi9cbiAgU0RLX1ZFUlNJT046ICcke0pTQ09SRV9WRVJTSU9OfSdcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCBhc3NlcnRpb24gaXMgZmFsc3lcbiAqL1xuZXhwb3J0IGNvbnN0IGFzc2VydCA9IGZ1bmN0aW9uIChhc3NlcnRpb246IHVua25vd24sIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIHRocm93IGFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gRXJyb3Igb2JqZWN0IHN1aXRhYmxlIGZvciB0aHJvd2luZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2U6IHN0cmluZyk6IEVycm9yIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAnRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xuICAgICAgQ09OU1RBTlRTLlNES19WRVJTSU9OICtcbiAgICAgICcpIElOVEVSTkFMIEFTU0VSVCBGQUlMRUQ6ICcgK1xuICAgICAgbWVzc2FnZVxuICApO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHN0cjogc3RyaW5nKTogbnVtYmVyW10ge1xuICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxuICBjb25zdCBvdXQ6IG51bWJlcltdID0gW107XG4gIGxldCBwID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICBvdXRbcCsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgb3V0W3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcbiAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXG4gICAgICBpICsgMSA8IHN0ci5sZW5ndGggJiZcbiAgICAgIChzdHIuY2hhckNvZGVBdChpICsgMSkgJiAweGZjMDApID09PSAweGRjMDBcbiAgICApIHtcbiAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXG4gICAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDAzZmYpO1xuICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG4gICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG4gICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xuICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBudW1iZXJzIGludG8gdGhlIHN0cmluZyBnaXZlbiBieSB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcbiAqIGNoYXJhY3RlcnMgdG8gd2hpY2ggdGhlIG51bWJlcnMgY29ycmVzcG9uZC5cbiAqIEBwYXJhbSBieXRlcyBBcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBjaGFyYWN0ZXJzLlxuICogQHJldHVybiBTdHJpbmdpZmljYXRpb24gb2YgdGhlIGFycmF5LlxuICovXG5jb25zdCBieXRlQXJyYXlUb1N0cmluZyA9IGZ1bmN0aW9uIChieXRlczogbnVtYmVyW10pOiBzdHJpbmcge1xuICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxuICBjb25zdCBvdXQ6IHN0cmluZ1tdID0gW107XG4gIGxldCBwb3MgPSAwLFxuICAgIGMgPSAwO1xuICB3aGlsZSAocG9zIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgYzEgPSBieXRlc1twb3MrK107XG4gICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYzEpO1xuICAgIH0gZWxzZSBpZiAoYzEgPiAxOTEgJiYgYzEgPCAyMjQpIHtcbiAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzEgJiAzMSkgPDwgNikgfCAoYzIgJiA2MykpO1xuICAgIH0gZWxzZSBpZiAoYzEgPiAyMzkgJiYgYzEgPCAzNjUpIHtcbiAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXG4gICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xuICAgICAgY29uc3QgYzQgPSBieXRlc1twb3MrK107XG4gICAgICBjb25zdCB1ID1cbiAgICAgICAgKCgoYzEgJiA3KSA8PCAxOCkgfCAoKGMyICYgNjMpIDw8IDEyKSB8ICgoYzMgJiA2MykgPDwgNikgfCAoYzQgJiA2MykpIC1cbiAgICAgICAgMHgxMDAwMDtcbiAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgKyAodSA+PiAxMCkpO1xuICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZGMwMCArICh1ICYgMTAyMykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xuICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAoKGMxICYgMTUpIDw8IDEyKSB8ICgoYzIgJiA2MykgPDwgNikgfCAoYzMgJiA2MylcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQuam9pbignJyk7XG59O1xuXG5pbnRlcmZhY2UgQmFzZTY0IHtcbiAgYnl0ZVRvQ2hhck1hcF86IHsgW2tleTogbnVtYmVyXTogc3RyaW5nIH0gfCBudWxsO1xuICBjaGFyVG9CeXRlTWFwXzogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSB8IG51bGw7XG4gIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogeyBba2V5OiBudW1iZXJdOiBzdHJpbmcgfSB8IG51bGw7XG4gIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSB8IG51bGw7XG4gIEVOQ09ERURfVkFMU19CQVNFOiBzdHJpbmc7XG4gIHJlYWRvbmx5IEVOQ09ERURfVkFMUzogc3RyaW5nO1xuICByZWFkb25seSBFTkNPREVEX1ZBTFNfV0VCU0FGRTogc3RyaW5nO1xuICBIQVNfTkFUSVZFX1NVUFBPUlQ6IGJvb2xlYW47XG4gIGVuY29kZUJ5dGVBcnJheShpbnB1dDogbnVtYmVyW10gfCBVaW50OEFycmF5LCB3ZWJTYWZlPzogYm9vbGVhbik6IHN0cmluZztcbiAgZW5jb2RlU3RyaW5nKGlucHV0OiBzdHJpbmcsIHdlYlNhZmU/OiBib29sZWFuKTogc3RyaW5nO1xuICBkZWNvZGVTdHJpbmcoaW5wdXQ6IHN0cmluZywgd2ViU2FmZTogYm9vbGVhbik6IHN0cmluZztcbiAgZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQ6IHN0cmluZywgd2ViU2FmZTogYm9vbGVhbik6IG51bWJlcltdO1xuICBpbml0XygpOiB2b2lkO1xufVxuXG4vLyBXZSBkZWZpbmUgaXQgYXMgYW4gb2JqZWN0IGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNsYXNzIGJlY2F1c2UgYSBjbGFzcyBjb21waWxlZCBkb3duIHRvIGVzNSBjYW4ndFxuLy8gYmUgdHJlZXNoYWtlZC4gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE2OTFcbi8vIFN0YXRpYyBsb29rdXAgbWFwcywgbGF6aWx5IHBvcHVsYXRlZCBieSBpbml0XygpXG5leHBvcnQgY29uc3QgYmFzZTY0OiBCYXNlNjQgPSB7XG4gIC8qKlxuICAgKiBNYXBzIGJ5dGVzIHRvIGNoYXJhY3RlcnMuXG4gICAqL1xuICBieXRlVG9DaGFyTWFwXzogbnVsbCxcblxuICAvKipcbiAgICogTWFwcyBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxuICAgKi9cbiAgY2hhclRvQnl0ZU1hcF86IG51bGwsXG5cbiAgLyoqXG4gICAqIE1hcHMgYnl0ZXMgdG8gd2Vic2FmZSBjaGFyYWN0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYnl0ZVRvQ2hhck1hcFdlYlNhZmVfOiBudWxsLFxuXG4gIC8qKlxuICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcblxuICAvKipcbiAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQsIHNoYXJlZCBiZXR3ZWVuXG4gICAqIEVOQ09ERURfVkFMUyBhbmQgRU5DT0RFRF9WQUxTX1dFQlNBRkVcbiAgICovXG4gIEVOQ09ERURfVkFMU19CQVNFOlxuICAgICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgKyAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICsgJzAxMjM0NTY3ODknLFxuXG4gIC8qKlxuICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldC4gVmFsdWUgNjQgKD0pIGlzIHNwZWNpYWw7IGl0IG1lYW5zIFwibm90aGluZy5cIlxuICAgKi9cbiAgZ2V0IEVOQ09ERURfVkFMUygpIHtcbiAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICcrLz0nO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPdXIgd2Vic2FmZSBhbHBoYWJldC5cbiAgICovXG4gIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcbiAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICctXy4nO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgYnJvd3NlciBzdXBwb3J0cyB0aGUgYXRvYiBhbmQgYnRvYSBmdW5jdGlvbnMuIFRoaXMgZXh0ZW5zaW9uXG4gICAqIHN0YXJ0ZWQgYXQgTW96aWxsYSBidXQgaXMgbm93IGltcGxlbWVudGVkIGJ5IG1hbnkgYnJvd3NlcnMuIFdlIHVzZSB0aGVcbiAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XG4gICAqIGJ1dCBzdGlsbCBhbGxvd2luZyB0aGUgc3RhbmRhcmQgcGVyLWJyb3dzZXIgY29tcGlsYXRpb25zLlxuICAgKlxuICAgKi9cbiAgSEFTX05BVElWRV9TVVBQT1JUOiB0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJyxcblxuICAvKipcbiAgICogQmFzZTY0LWVuY29kZSBhbiBhcnJheSBvZiBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IEFuIGFycmF5IG9mIGJ5dGVzIChudW1iZXJzIHdpdGhcbiAgICogICAgIHZhbHVlIGluIFswLCAyNTVdKSB0byBlbmNvZGUuXG4gICAqIEBwYXJhbSB3ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxuICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAqIEByZXR1cm4gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAgICovXG4gIGVuY29kZUJ5dGVBcnJheShpbnB1dDogbnVtYmVyW10gfCBVaW50OEFycmF5LCB3ZWJTYWZlPzogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2VuY29kZUJ5dGVBcnJheSB0YWtlcyBhbiBhcnJheSBhcyBhIHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdF8oKTtcblxuICAgIGNvbnN0IGJ5dGVUb0NoYXJNYXAgPSB3ZWJTYWZlXG4gICAgICA/IHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfIVxuICAgICAgOiB0aGlzLmJ5dGVUb0NoYXJNYXBfITtcblxuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgY29uc3QgYnl0ZTEgPSBpbnB1dFtpXTtcbiAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgKyAxIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBpbnB1dFtpICsgMV0gOiAwO1xuICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSArIDIgPCBpbnB1dC5sZW5ndGg7XG4gICAgICBjb25zdCBieXRlMyA9IGhhdmVCeXRlMyA/IGlucHV0W2kgKyAyXSA6IDA7XG5cbiAgICAgIGNvbnN0IG91dEJ5dGUxID0gYnl0ZTEgPj4gMjtcbiAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgbGV0IG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xuICAgICAgbGV0IG91dEJ5dGU0ID0gYnl0ZTMgJiAweDNmO1xuXG4gICAgICBpZiAoIWhhdmVCeXRlMykge1xuICAgICAgICBvdXRCeXRlNCA9IDY0O1xuXG4gICAgICAgIGlmICghaGF2ZUJ5dGUyKSB7XG4gICAgICAgICAgb3V0Qnl0ZTMgPSA2NDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvdXRwdXQucHVzaChcbiAgICAgICAgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMV0sXG4gICAgICAgIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLFxuICAgICAgICBieXRlVG9DaGFyTWFwW291dEJ5dGUzXSxcbiAgICAgICAgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlNF1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQmFzZTY0LWVuY29kZSBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cbiAgICogQHBhcmFtIHdlYlNhZmUgSWYgdHJ1ZSwgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAqL1xuICBlbmNvZGVTdHJpbmcoaW5wdXQ6IHN0cmluZywgd2ViU2FmZT86IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XG4gICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxuICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xuICAgICAgcmV0dXJuIGJ0b2EoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbmNvZGVCeXRlQXJyYXkoc3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQpLCB3ZWJTYWZlKTtcbiAgfSxcblxuICAvKipcbiAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IHRvIGRlY29kZS5cbiAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZVxuICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAgICovXG4gIGRlY29kZVN0cmluZyhpbnB1dDogc3RyaW5nLCB3ZWJTYWZlOiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxuICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIXdlYlNhZmUpIHtcbiAgICAgIHJldHVybiBhdG9iKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVBcnJheVRvU3RyaW5nKHRoaXMuZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpKTtcbiAgfSxcblxuICAvKipcbiAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cbiAgICpcbiAgICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcbiAgICogYnl0ZXMuICBJZiB0aGUgZW5jb2RlciBkaWQgbm90IGFwcGx5IHBhZGRpbmcsIHRoZSBpbnB1dCBsZW5ndGggbWF5IG5vdFxuICAgKiBiZSBhIG11bHRpcGxlIG9mIDQuXG4gICAqXG4gICAqIEluIHRoaXMgY2FzZSwgdGhlIGxhc3QgZ3JvdXAgd2lsbCBoYXZlIGZld2VyIHRoYW4gNCBjaGFyYWN0ZXJzLCBhbmRcbiAgICogcGFkZGluZyB3aWxsIGJlIGluZmVycmVkLiAgSWYgdGhlIGdyb3VwIGhhcyBvbmUgb3IgdHdvIGNoYXJhY3RlcnMsIGl0IGRlY29kZXNcbiAgICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXQgSW5wdXQgdG8gZGVjb2RlLlxuICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxuICAgKiBAcmV0dXJuIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAgICovXG4gIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0OiBzdHJpbmcsIHdlYlNhZmU6IGJvb2xlYW4pOiBudW1iZXJbXSB7XG4gICAgdGhpcy5pbml0XygpO1xuXG4gICAgY29uc3QgY2hhclRvQnl0ZU1hcCA9IHdlYlNhZmVcbiAgICAgID8gdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8hXG4gICAgICA6IHRoaXMuY2hhclRvQnl0ZU1hcF8hO1xuXG4gICAgY29uc3Qgb3V0cHV0OiBudW1iZXJbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICkge1xuICAgICAgY29uc3QgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcblxuICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogMDtcbiAgICAgICsraTtcblxuICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XG4gICAgICArK2k7XG5cbiAgICAgIGNvbnN0IGhhdmVCeXRlNCA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICBjb25zdCBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICAgKytpO1xuXG4gICAgICBpZiAoYnl0ZTEgPT0gbnVsbCB8fCBieXRlMiA9PSBudWxsIHx8IGJ5dGUzID09IG51bGwgfHwgYnl0ZTQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSAoYnl0ZTEgPDwgMikgfCAoYnl0ZTIgPj4gNCk7XG4gICAgICBvdXRwdXQucHVzaChvdXRCeXRlMSk7XG5cbiAgICAgIGlmIChieXRlMyAhPT0gNjQpIHtcbiAgICAgICAgY29uc3Qgb3V0Qnl0ZTIgPSAoKGJ5dGUyIDw8IDQpICYgMHhmMCkgfCAoYnl0ZTMgPj4gMik7XG4gICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUyKTtcblxuICAgICAgICBpZiAoYnl0ZTQgIT09IDY0KSB7XG4gICAgICAgICAgY29uc3Qgb3V0Qnl0ZTMgPSAoKGJ5dGUzIDw8IDYpICYgMHhjMCkgfCBieXRlNDtcbiAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMYXp5IHN0YXRpYyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbi4gQ2FsbGVkIGJlZm9yZVxuICAgKiBhY2Nlc3NpbmcgYW55IG9mIHRoZSBzdGF0aWMgbWFwIHZhcmlhYmxlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRfKCkge1xuICAgIGlmICghdGhpcy5ieXRlVG9DaGFyTWFwXykge1xuICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwXyA9IHt9O1xuICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwXyA9IHt9O1xuICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV8gPSB7fTtcbiAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfID0ge307XG5cbiAgICAgIC8vIFdlIHdhbnQgcXVpY2sgbWFwcGluZ3MgYmFjayBhbmQgZm9ydGgsIHNvIHdlIHByZWNvbXB1dGUgdHdvIG1hcHMuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRU5DT0RFRF9WQUxTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF9baV0gPSB0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSk7XG4gICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5ieXRlVG9DaGFyTWFwX1tpXV0gPSBpO1xuICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpO1xuICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXV0gPSBpO1xuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZyB3aGVuIGRlY29kaW5nIGFuZCBjb3JyZWN0bHkgZGVjb2RlIGJvdGggZW5jb2RpbmdzLlxuICAgICAgICBpZiAoaSA+PSB0aGlzLkVOQ09ERURfVkFMU19CQVNFLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBbiBlcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBkZWNvZGluZyBiYXNlNjQgc3RyaW5nLlxuICovXG5leHBvcnQgY2xhc3MgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHJlYWRvbmx5IG5hbWUgPSAnRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3InO1xufVxuXG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZ1xuICovXG5leHBvcnQgY29uc3QgYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24gKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkoc3RyKTtcbiAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkodXRmOEJ5dGVzLCB0cnVlKTtcbn07XG5cbi8qKlxuICogVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nICh3aXRob3V0IFwiLlwiIHBhZGRpbmcgaW4gdGhlIGVuZCkuXG4gKiBlLmcuIFVzZWQgaW4gSlNPTiBXZWIgVG9rZW4gKEpXVCkgcGFydHMuXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyA9IGZ1bmN0aW9uIChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIFVzZSBiYXNlNjR1cmwgZW5jb2RpbmcgYW5kIHJlbW92ZSBwYWRkaW5nIGluIHRoZSBlbmQgKGRvdCBjaGFyYWN0ZXJzKS5cbiAgcmV0dXJuIGJhc2U2NEVuY29kZShzdHIpLnJlcGxhY2UoL1xcLi9nLCAnJyk7XG59O1xuXG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBkZWNvZGluZ1xuICpcbiAqIE5PVEU6IERPIE5PVCB1c2UgdGhlIGdsb2JhbCBhdG9iKCkgZnVuY3Rpb24gLSBpdCBkb2VzIE5PVCBzdXBwb3J0IHRoZVxuICogYmFzZTY0VXJsIHZhcmlhbnQgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHN0ciBUbyBiZSBkZWNvZGVkXG4gKiBAcmV0dXJuIERlY29kZWQgcmVzdWx0LCBpZiBwb3NzaWJsZVxuICovXG5leHBvcnQgY29uc3QgYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKHN0cjogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGJhc2U2NC5kZWNvZGVTdHJpbmcoc3RyLCB0cnVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2Jhc2U2NERlY29kZSBmYWlsZWQ6ICcsIGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogRG8gYSBkZWVwLWNvcHkgb2YgYmFzaWMgSmF2YVNjcmlwdCBPYmplY3RzIG9yIEFycmF5cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5PFQ+KHZhbHVlOiBUKTogVCB7XG4gIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpIGFzIFQ7XG59XG5cbi8qKlxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRhcmdldCAocmVjdXJzaXZlbHkgYWxsb3dzIGV4dGVuc2lvblxuICogb2YgT2JqZWN0cyBhbmQgQXJyYXlzKS4gIFNjYWxhciB2YWx1ZXMgaW4gdGhlIHRhcmdldCBhcmUgb3Zlci13cml0dGVuLlxuICogSWYgdGFyZ2V0IGlzIHVuZGVmaW5lZCwgYW4gb2JqZWN0IG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlIHdpbGwgYmUgY3JlYXRlZFxuICogKGFuZCByZXR1cm5lZCkuXG4gKlxuICogV2UgcmVjdXJzaXZlbHkgY29weSBhbGwgY2hpbGQgcHJvcGVydGllcyBvZiBwbGFpbiBPYmplY3RzIGluIHRoZSBzb3VyY2UtIHNvXG4gKiB0aGF0IG5hbWVzcGFjZS0gbGlrZSBkaWN0aW9uYXJpZXMgYXJlIG1lcmdlZC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHRhcmdldCBjYW4gYmUgYSBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSB0aGUgcHJvcGVydGllcyBpblxuICogdGhlIHNvdXJjZSBPYmplY3QgYXJlIGNvcGllZCBvbnRvIGl0IGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbi5cbiAqXG4gKiBOb3RlOiB3ZSBkb24ndCBtZXJnZSBfX3Byb3RvX18gdG8gcHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwRXh0ZW5kKHRhcmdldDogdW5rbm93biwgc291cmNlOiB1bmtub3duKTogdW5rbm93biB7XG4gIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgc3dpdGNoIChzb3VyY2UuY29uc3RydWN0b3IpIHtcbiAgICBjYXNlIERhdGU6XG4gICAgICAvLyBUcmVhdCBEYXRlcyBsaWtlIHNjYWxhcnM7IGlmIHRoZSB0YXJnZXQgZGF0ZSBvYmplY3QgaGFkIGFueSBjaGlsZFxuICAgICAgLy8gcHJvcGVydGllcyAtIHRoZXkgd2lsbCBiZSBsb3N0IVxuICAgICAgY29uc3QgZGF0ZVZhbHVlID0gc291cmNlIGFzIERhdGU7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZVZhbHVlLmdldFRpbWUoKSk7XG5cbiAgICBjYXNlIE9iamVjdDpcbiAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQXJyYXk6XG4gICAgICAvLyBBbHdheXMgY29weSB0aGUgYXJyYXkgc291cmNlIGFuZCBvdmVyd3JpdGUgdGhlIHRhcmdldC5cbiAgICAgIHRhcmdldCA9IFtdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gTm90IGEgcGxhaW4gT2JqZWN0IC0gdHJlYXQgaXQgYXMgYSBzY2FsYXIuXG4gICAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xuICAgIC8vIHVzZSBpc1ZhbGlkS2V5IHRvIGd1YXJkIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbi4gU2VlIGh0dHBzOi8vc255ay5pby92dWxuL1NOWUstSlMtTE9EQVNILTQ1MDIwMlxuICAgIGlmICghc291cmNlLmhhc093blByb3BlcnR5KHByb3ApIHx8ICFpc1ZhbGlkS2V5KHByb3ApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgKHRhcmdldCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbcHJvcF0gPSBkZWVwRXh0ZW5kKFxuICAgICAgKHRhcmdldCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbcHJvcF0sXG4gICAgICAoc291cmNlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtwcm9wXVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgYGdsb2JhbFRoaXNgIG9iamVjdC5cbiAqIEByZXR1cm5zIHRoZSBgZ2xvYmFsVGhpc2Agb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHbG9iYWwoKTogdHlwZW9mIGdsb2JhbFRoaXMge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0LicpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYmFzZTY0RGVjb2RlIH0gZnJvbSAnLi9jcnlwdCc7XG5pbXBvcnQgeyBnZXRHbG9iYWwgfSBmcm9tICcuL2dsb2JhbCc7XG5cbi8qKlxuICogS2V5cyBmb3IgZXhwZXJpbWVudGFsIHByb3BlcnRpZXMgb24gdGhlIGBGaXJlYmFzZURlZmF1bHRzYCBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEV4cGVyaW1lbnRhbEtleSA9ICdhdXRoVG9rZW5TeW5jVVJMJyB8ICdhdXRoSWRUb2tlbk1heEFnZSc7XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIGJlIGluamVjdGVkIGludG8gdGhlIGVudmlyb25tZW50IGFzIF9fRklSRUJBU0VfREVGQVVMVFNfXyxcbiAqIGVpdGhlciBhcyBhIHByb3BlcnR5IG9mIGdsb2JhbFRoaXMsIGEgc2hlbGwgZW52aXJvbm1lbnQgdmFyaWFibGUsIG9yIGFcbiAqIGNvb2tpZS5cbiAqXG4gKiBUaGlzIG9iamVjdCBjYW4gYmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbmZpZ3VyZSBhbmQgaW5pdGlhbGl6ZVxuICogYSBGaXJlYmFzZSBhcHAgYXMgd2VsbCBhcyBhbnkgZW11bGF0b3JzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaXJlYmFzZURlZmF1bHRzIHtcbiAgY29uZmlnPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgZW11bGF0b3JIb3N0cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIF9hdXRoVG9rZW5TeW5jVVJMPzogc3RyaW5nO1xuICBfYXV0aElkVG9rZW5NYXhBZ2U/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBPdmVycmlkZSBGaXJlYmFzZSdzIHJ1bnRpbWUgZW52aXJvbm1lbnQgZGV0ZWN0aW9uIGFuZFxuICAgKiBmb3JjZSB0aGUgU0RLIHRvIGFjdCBhcyBpZiBpdCB3ZXJlIGluIHRoZSBzcGVjaWZpZWQgZW52aXJvbm1lbnQuXG4gICAqL1xuICBmb3JjZUVudmlyb25tZW50PzogJ2Jyb3dzZXInIHwgJ25vZGUnO1xuICBba2V5OiBzdHJpbmddOiB1bmtub3duO1xufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIE5lZWQgYHZhcmAgZm9yIHRoaXMgdG8gd29yay5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICB2YXIgX19GSVJFQkFTRV9ERUZBVUxUU19fOiBGaXJlYmFzZURlZmF1bHRzIHwgdW5kZWZpbmVkO1xufVxuXG5jb25zdCBnZXREZWZhdWx0c0Zyb21HbG9iYWwgPSAoKTogRmlyZWJhc2VEZWZhdWx0cyB8IHVuZGVmaW5lZCA9PlxuICBnZXRHbG9iYWwoKS5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XG5cbi8qKlxuICogQXR0ZW1wdCB0byByZWFkIGRlZmF1bHRzIGZyb20gYSBKU09OIHN0cmluZyBwcm92aWRlZCB0b1xuICogcHJvY2VzcyguKWVudiguKV9fRklSRUJBU0VfREVGQVVMVFNfXyBvciBhIEpTT04gZmlsZSB3aG9zZSBwYXRoIGlzIGluXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19QQVRIX19cbiAqIFRoZSBkb3RzIGFyZSBpbiBwYXJlbnMgYmVjYXVzZSBjZXJ0YWluIGNvbXBpbGVycyAoVml0ZT8pIGNhbm5vdFxuICogaGFuZGxlIHNlZWluZyB0aGF0IHZhcmlhYmxlIGluIGNvbW1lbnRzLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzY4MzhcbiAqL1xuY29uc3QgZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUgPSAoKTogRmlyZWJhc2VEZWZhdWx0cyB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHByb2Nlc3MuZW52ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZWZhdWx0c0pzb25TdHJpbmcgPSBwcm9jZXNzLmVudi5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XG4gIGlmIChkZWZhdWx0c0pzb25TdHJpbmcpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWZhdWx0c0pzb25TdHJpbmcpO1xuICB9XG59O1xuXG5jb25zdCBnZXREZWZhdWx0c0Zyb21Db29raWUgPSAoKTogRmlyZWJhc2VEZWZhdWx0cyB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBtYXRjaDtcbiAgdHJ5IHtcbiAgICBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaCgvX19GSVJFQkFTRV9ERUZBVUxUU19fPShbXjtdKykvKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQW5ndWxhciBVbml2ZXJzYWwgU1NSIGhhdmUgYVxuICAgIC8vIGBkb2N1bWVudGAgb2JqZWN0IGJ1dCBlcnJvciBvbiBhY2Nlc3NpbmcgYGRvY3VtZW50LmNvb2tpZWAuXG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRlY29kZWQgPSBtYXRjaCAmJiBiYXNlNjREZWNvZGUobWF0Y2hbMV0pO1xuICByZXR1cm4gZGVjb2RlZCAmJiBKU09OLnBhcnNlKGRlY29kZWQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuIEl0IGNoZWNrcyBpbiBvcmRlcjpcbiAqICgxKSBpZiBzdWNoIGFuIG9iamVjdCBleGlzdHMgYXMgYSBwcm9wZXJ0eSBvZiBgZ2xvYmFsVGhpc2BcbiAqICgyKSBpZiBzdWNoIGFuIG9iamVjdCB3YXMgcHJvdmlkZWQgb24gYSBzaGVsbCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogKDMpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBpbiBhIGNvb2tpZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdHMgPSAoKTogRmlyZWJhc2VEZWZhdWx0cyB8IHVuZGVmaW5lZCA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGdldERlZmF1bHRzRnJvbUdsb2JhbCgpIHx8XG4gICAgICBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSgpIHx8XG4gICAgICBnZXREZWZhdWx0c0Zyb21Db29raWUoKVxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKipcbiAgICAgKiBDYXRjaC1hbGwgZm9yIGJlaW5nIHVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZVxuICAgICAqIHRvIGFueSBlbnZpcm9ubWVudCBjYXNlIHdlIGhhdmUgbm90IGFjY291bnRlZCBmb3IuIExvZyB0b1xuICAgICAqIGluZm8gaW5zdGVhZCBvZiBzd2FsbG93aW5nIHNvIHdlIGNhbiBmaW5kIHRoZXNlIHVua25vd24gY2FzZXNcbiAgICAgKiBhbmQgYWRkIHBhdGhzIGZvciB0aGVtIGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBjb25zb2xlLmluZm8oYFVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZSB0bzogJHtlfWApO1xuICAgIHJldHVybjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3Qgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXG4gKiBAcmV0dXJucyBhIFVSTCBob3N0IGZvcm1hdHRlZCBsaWtlIGAxMjcuMC4wLjE6OTk5OWAgb3IgYFs6OjFdOjQwMDBgIGlmIGF2YWlsYWJsZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCA9IChcbiAgcHJvZHVjdE5hbWU6IHN0cmluZ1xuKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IGdldERlZmF1bHRzKCk/LmVtdWxhdG9ySG9zdHM/Lltwcm9kdWN0TmFtZV07XG5cbi8qKlxuICogUmV0dXJucyBlbXVsYXRvciBob3N0bmFtZSBhbmQgcG9ydCBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3RcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cbiAqIEByZXR1cm5zIGEgcGFpciBvZiBob3N0bmFtZSBhbmQgcG9ydCBsaWtlIGBbXCI6OjFcIiwgNDAwMF1gIGlmIGF2YWlsYWJsZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0ID0gKFxuICBwcm9kdWN0TmFtZTogc3RyaW5nXG4pOiBbaG9zdG5hbWU6IHN0cmluZywgcG9ydDogbnVtYmVyXSB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGhvc3QgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0KHByb2R1Y3ROYW1lKTtcbiAgaWYgKCFob3N0KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBzZXBhcmF0b3JJbmRleCA9IGhvc3QubGFzdEluZGV4T2YoJzonKTsgLy8gRmluZGluZyB0aGUgbGFzdCBzaW5jZSBJUHY2IGFkZHIgYWxzbyBoYXMgY29sb25zLlxuICBpZiAoc2VwYXJhdG9ySW5kZXggPD0gMCB8fCBzZXBhcmF0b3JJbmRleCArIDEgPT09IGhvc3QubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhvc3QgJHtob3N0fSB3aXRoIG5vIHNlcGFyYXRlIGhvc3RuYW1lIGFuZCBwb3J0IWApO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgY29uc3QgcG9ydCA9IHBhcnNlSW50KGhvc3Quc3Vic3RyaW5nKHNlcGFyYXRvckluZGV4ICsgMSksIDEwKTtcbiAgaWYgKGhvc3RbMF0gPT09ICdbJykge1xuICAgIC8vIEJyYWNrZXQtcXVvdGVkIGBbaXB2NmFkZHJdOnBvcnRgID0+IHJldHVybiBcImlwdjZhZGRyXCIgKHdpdGhvdXQgYnJhY2tldHMpLlxuICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMSwgc2VwYXJhdG9ySW5kZXggLSAxKSwgcG9ydF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtob3N0LnN1YnN0cmluZygwLCBzZXBhcmF0b3JJbmRleCksIHBvcnRdO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgRmlyZWJhc2UgYXBwIGNvbmZpZyBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBnZXREZWZhdWx0QXBwQ29uZmlnID0gKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWQgPT5cbiAgZ2V0RGVmYXVsdHMoKT8uY29uZmlnO1xuXG4vKipcbiAqIFJldHVybnMgYW4gZXhwZXJpbWVudGFsIHNldHRpbmcgb24gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QgKHByb3BlcnRpZXNcbiAqIHByZWZpeGVkIGJ5IFwiX1wiKVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgZ2V0RXhwZXJpbWVudGFsU2V0dGluZyA9IDxUIGV4dGVuZHMgRXhwZXJpbWVudGFsS2V5PihcbiAgbmFtZTogVFxuKTogRmlyZWJhc2VEZWZhdWx0c1tgXyR7VH1gXSA9PlxuICBnZXREZWZhdWx0cygpPy5bYF8ke25hbWV9YF0gYXMgRmlyZWJhc2VEZWZhdWx0c1tgXyR7VH1gXTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjbGFzcyBEZWZlcnJlZDxSPiB7XG4gIHByb21pc2U6IFByb21pc2U8Uj47XG4gIHJlamVjdDogKHZhbHVlPzogdW5rbm93bikgPT4gdm9pZCA9ICgpID0+IHt9O1xuICByZXNvbHZlOiAodmFsdWU/OiB1bmtub3duKSA9PiB2b2lkID0gKCkgPT4ge307XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmUgYXMgKHZhbHVlPzogdW5rbm93bikgPT4gdm9pZDtcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0IGFzICh2YWx1ZT86IHVua25vd24pID0+IHZvaWQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT3VyIEFQSSBpbnRlcm5hbHMgYXJlIG5vdCBwcm9taXNlaWZpZWQgYW5kIGNhbm5vdCBiZWNhdXNlIG91ciBjYWxsYmFjayBBUElzIGhhdmUgc3VidGxlIGV4cGVjdGF0aW9ucyBhcm91bmRcbiAgICogaW52b2tpbmcgcHJvbWlzZXMgaW5saW5lLCB3aGljaCBQcm9taXNlcyBhcmUgZm9yYmlkZGVuIHRvIGRvLiBUaGlzIG1ldGhvZCBhY2NlcHRzIGFuIG9wdGlvbmFsIG5vZGUtc3R5bGUgY2FsbGJhY2tcbiAgICogYW5kIHJldHVybnMgYSBub2RlLXN0eWxlIGNhbGxiYWNrIHdoaWNoIHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIERlZmVycmVkJ3MgcHJvbWlzZS5cbiAgICovXG4gIHdyYXBDYWxsYmFjayhcbiAgICBjYWxsYmFjaz86IChlcnJvcj86IHVua25vd24sIHZhbHVlPzogdW5rbm93bikgPT4gdm9pZFxuICApOiAoZXJyb3I6IHVua25vd24sIHZhbHVlPzogdW5rbm93bikgPT4gdm9pZCB7XG4gICAgcmV0dXJuIChlcnJvciwgdmFsdWU/KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5yZWplY3QoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQXR0YWNoaW5nIG5vb3AgaGFuZGxlciBqdXN0IGluIGNhc2UgZGV2ZWxvcGVyIHdhc24ndCBleHBlY3RpbmdcbiAgICAgICAgLy8gcHJvbWlzZXNcbiAgICAgICAgdGhpcy5wcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcblxuICAgICAgICAvLyBTb21lIG9mIG91ciBjYWxsYmFja3MgZG9uJ3QgZXhwZWN0IGEgdmFsdWUgYW5kIG91ciBvd24gdGVzdHNcbiAgICAgICAgLy8gYXNzZXJ0IHRoYXQgdGhlIHBhcmFtZXRlciBsZW5ndGggaXMgMVxuICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyB9IGZyb20gJy4vY3J5cHQnO1xuXG4vLyBGaXJlYmFzZSBBdXRoIHRva2VucyBjb250YWluIHNuYWtlX2Nhc2UgY2xhaW1zIGZvbGxvd2luZyB0aGUgSldUIHN0YW5kYXJkIC8gY29udmVudGlvbi5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuXG5leHBvcnQgdHlwZSBGaXJlYmFzZVNpZ25JblByb3ZpZGVyID1cbiAgfCAnY3VzdG9tJ1xuICB8ICdlbWFpbCdcbiAgfCAncGFzc3dvcmQnXG4gIHwgJ3Bob25lJ1xuICB8ICdhbm9ueW1vdXMnXG4gIHwgJ2dvb2dsZS5jb20nXG4gIHwgJ2ZhY2Vib29rLmNvbSdcbiAgfCAnZ2l0aHViLmNvbSdcbiAgfCAndHdpdHRlci5jb20nXG4gIHwgJ21pY3Jvc29mdC5jb20nXG4gIHwgJ2FwcGxlLmNvbSc7XG5cbmludGVyZmFjZSBGaXJlYmFzZUlkVG9rZW4ge1xuICAvLyBBbHdheXMgc2V0IHRvIGh0dHBzOi8vc2VjdXJldG9rZW4uZ29vZ2xlLmNvbS9QUk9KRUNUX0lEXG4gIGlzczogc3RyaW5nO1xuXG4gIC8vIEFsd2F5cyBzZXQgdG8gUFJPSkVDVF9JRFxuICBhdWQ6IHN0cmluZztcblxuICAvLyBUaGUgdXNlcidzIHVuaXF1ZSBJRFxuICBzdWI6IHN0cmluZztcblxuICAvLyBUaGUgdG9rZW4gaXNzdWUgdGltZSwgaW4gc2Vjb25kcyBzaW5jZSBlcG9jaFxuICBpYXQ6IG51bWJlcjtcblxuICAvLyBUaGUgdG9rZW4gZXhwaXJ5IHRpbWUsIG5vcm1hbGx5ICdpYXQnICsgMzYwMFxuICBleHA6IG51bWJlcjtcblxuICAvLyBUaGUgdXNlcidzIHVuaXF1ZSBJRC4gTXVzdCBiZSBlcXVhbCB0byAnc3ViJ1xuICB1c2VyX2lkOiBzdHJpbmc7XG5cbiAgLy8gVGhlIHRpbWUgdGhlIHVzZXIgYXV0aGVudGljYXRlZCwgbm9ybWFsbHkgJ2lhdCdcbiAgYXV0aF90aW1lOiBudW1iZXI7XG5cbiAgLy8gVGhlIHNpZ24gaW4gcHJvdmlkZXIsIG9ubHkgc2V0IHdoZW4gdGhlIHByb3ZpZGVyIGlzICdhbm9ueW1vdXMnXG4gIHByb3ZpZGVyX2lkPzogJ2Fub255bW91cyc7XG5cbiAgLy8gVGhlIHVzZXIncyBwcmltYXJ5IGVtYWlsXG4gIGVtYWlsPzogc3RyaW5nO1xuXG4gIC8vIFRoZSB1c2VyJ3MgZW1haWwgdmVyaWZpY2F0aW9uIHN0YXR1c1xuICBlbWFpbF92ZXJpZmllZD86IGJvb2xlYW47XG5cbiAgLy8gVGhlIHVzZXIncyBwcmltYXJ5IHBob25lIG51bWJlclxuICBwaG9uZV9udW1iZXI/OiBzdHJpbmc7XG5cbiAgLy8gVGhlIHVzZXIncyBkaXNwbGF5IG5hbWVcbiAgbmFtZT86IHN0cmluZztcblxuICAvLyBUaGUgdXNlcidzIHByb2ZpbGUgcGhvdG8gVVJMXG4gIHBpY3R1cmU/OiBzdHJpbmc7XG5cbiAgLy8gSW5mb3JtYXRpb24gb24gYWxsIGlkZW50aXRpZXMgbGlua2VkIHRvIHRoaXMgdXNlclxuICBmaXJlYmFzZToge1xuICAgIC8vIFRoZSBwcmltYXJ5IHNpZ24taW4gcHJvdmlkZXJcbiAgICBzaWduX2luX3Byb3ZpZGVyOiBGaXJlYmFzZVNpZ25JblByb3ZpZGVyO1xuXG4gICAgLy8gQSBtYXAgb2YgcHJvdmlkZXJzIHRvIHRoZSB1c2VyJ3MgbGlzdCBvZiB1bmlxdWUgaWRlbnRpZmllcnMgZnJvbVxuICAgIC8vIGVhY2ggcHJvdmlkZXJcbiAgICBpZGVudGl0aWVzPzogeyBbcHJvdmlkZXIgaW4gRmlyZWJhc2VTaWduSW5Qcm92aWRlcl0/OiBzdHJpbmdbXSB9O1xuICB9O1xuXG4gIC8vIEN1c3RvbSBjbGFpbXMgc2V0IGJ5IHRoZSBkZXZlbG9wZXJcbiAgW2NsYWltOiBzdHJpbmddOiB1bmtub3duO1xuXG4gIHVpZD86IG5ldmVyOyAvLyBUcnkgdG8gY2F0Y2ggYSBjb21tb24gbWlzdGFrZSBvZiBcInVpZFwiIChzaG91bGQgYmUgXCJzdWJcIiBpbnN0ZWFkKS5cbn1cblxuZXhwb3J0IHR5cGUgRW11bGF0b3JNb2NrVG9rZW5PcHRpb25zID0gKHsgdXNlcl9pZDogc3RyaW5nIH0gfCB7IHN1Yjogc3RyaW5nIH0pICZcbiAgUGFydGlhbDxGaXJlYmFzZUlkVG9rZW4+O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW9ja1VzZXJUb2tlbihcbiAgdG9rZW46IEVtdWxhdG9yTW9ja1Rva2VuT3B0aW9ucyxcbiAgcHJvamVjdElkPzogc3RyaW5nXG4pOiBzdHJpbmcge1xuICBpZiAodG9rZW4udWlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1RoZSBcInVpZFwiIGZpZWxkIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYnkgbW9ja1VzZXJUb2tlbi4gUGxlYXNlIHVzZSBcInN1YlwiIGluc3RlYWQgZm9yIEZpcmViYXNlIEF1dGggVXNlciBJRC4nXG4gICAgKTtcbiAgfVxuICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgXCJub25lXCIgYXMgdGhlIGFsZ29yaXRobS5cbiAgY29uc3QgaGVhZGVyID0ge1xuICAgIGFsZzogJ25vbmUnLFxuICAgIHR5cGU6ICdKV1QnXG4gIH07XG5cbiAgY29uc3QgcHJvamVjdCA9IHByb2plY3RJZCB8fCAnZGVtby1wcm9qZWN0JztcbiAgY29uc3QgaWF0ID0gdG9rZW4uaWF0IHx8IDA7XG4gIGNvbnN0IHN1YiA9IHRva2VuLnN1YiB8fCB0b2tlbi51c2VyX2lkO1xuICBpZiAoIXN1Yikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1vY2tVc2VyVG9rZW4gbXVzdCBjb250YWluICdzdWInIG9yICd1c2VyX2lkJyBmaWVsZCFcIik7XG4gIH1cblxuICBjb25zdCBwYXlsb2FkOiBGaXJlYmFzZUlkVG9rZW4gPSB7XG4gICAgLy8gU2V0IGFsbCByZXF1aXJlZCBmaWVsZHMgdG8gZGVjZW50IGRlZmF1bHRzXG4gICAgaXNzOiBgaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGUuY29tLyR7cHJvamVjdH1gLFxuICAgIGF1ZDogcHJvamVjdCxcbiAgICBpYXQsXG4gICAgZXhwOiBpYXQgKyAzNjAwLFxuICAgIGF1dGhfdGltZTogaWF0LFxuICAgIHN1YixcbiAgICB1c2VyX2lkOiBzdWIsXG4gICAgZmlyZWJhc2U6IHtcbiAgICAgIHNpZ25faW5fcHJvdmlkZXI6ICdjdXN0b20nLFxuICAgICAgaWRlbnRpdGllczoge31cbiAgICB9LFxuXG4gICAgLy8gT3ZlcnJpZGUgd2l0aCB1c2VyIG9wdGlvbnNcbiAgICAuLi50b2tlblxuICB9O1xuXG4gIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSB0aGUgZW1wdHkgc3RyaW5nIGFzIGEgc2lnbmF0dXJlLlxuICBjb25zdCBzaWduYXR1cmUgPSAnJztcbiAgcmV0dXJuIFtcbiAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShoZWFkZXIpKSxcbiAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSksXG4gICAgc2lnbmF0dXJlXG4gIF0uam9pbignLicpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzJztcblxuLyoqXG4gKiBSZXR1cm5zIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nIG9yICcnIGlmIGl0J3Mgbm90IGRlZmluZWQuXG4gKiBAcmV0dXJuIHVzZXIgYWdlbnQgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVQSgpOiBzdHJpbmcge1xuICBpZiAoXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgbmF2aWdhdG9yWyd1c2VyQWdlbnQnXSA9PT0gJ3N0cmluZydcbiAgKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvclsndXNlckFnZW50J107XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZWN0IENvcmRvdmEgLyBQaG9uZUdhcCAvIElvbmljIGZyYW1ld29ya3Mgb24gYSBtb2JpbGUgZGV2aWNlLlxuICpcbiAqIERlbGliZXJhdGVseSBkb2VzIG5vdCByZWx5IG9uIGNoZWNraW5nIGBmaWxlOi8vYCBVUkxzIChhcyB0aGlzIGZhaWxzIFBob25lR2FwXG4gKiBpbiB0aGUgUmlwcGxlIGVtdWxhdG9yKSBub3IgQ29yZG92YSBgb25EZXZpY2VSZWFkeWAsIHdoaWNoIHdvdWxkIG5vcm1hbGx5XG4gKiB3YWl0IGZvciBhIGNhbGxiYWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNNb2JpbGVDb3Jkb3ZhKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gQHRzLWlnbm9yZSBTZXR0aW5nIHVwIGFuIGJyb2FkbHkgYXBwbGljYWJsZSBpbmRleCBzaWduYXR1cmUgZm9yIFdpbmRvd1xuICAgIC8vIGp1c3QgdG8gZGVhbCB3aXRoIHRoaXMgY2FzZSB3b3VsZCBwcm9iYWJseSBiZSBhIGJhZCBpZGVhLlxuICAgICEhKHdpbmRvd1snY29yZG92YSddIHx8IHdpbmRvd1sncGhvbmVnYXAnXSB8fCB3aW5kb3dbJ1Bob25lR2FwJ10pICYmXG4gICAgL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWR8YmxhY2tiZXJyeXxpZW1vYmlsZS9pLnRlc3QoZ2V0VUEoKSlcbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgTm9kZS5qcy5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgTm9kZS5qcyBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZCBvciBzcGVjaWZpZWQuXG4gKi9cbi8vIE5vZGUgZGV0ZWN0aW9uIGxvZ2ljIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9pbGlha2FuL2RldGVjdC1ub2RlL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZSgpOiBib29sZWFuIHtcbiAgY29uc3QgZm9yY2VFbnZpcm9ubWVudCA9IGdldERlZmF1bHRzKCk/LmZvcmNlRW52aXJvbm1lbnQ7XG4gIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnbm9kZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnYnJvd3NlcicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiAoXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSdcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZWN0IEJyb3dzZXIgRW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnJvd3NlcigpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGY7XG59XG5cbi8qKlxuICogRGV0ZWN0IGJyb3dzZXIgZXh0ZW5zaW9ucyAoQ2hyb21lIGFuZCBGaXJlZm94IGF0IGxlYXN0KS5cbiAqL1xuaW50ZXJmYWNlIEJyb3dzZXJSdW50aW1lIHtcbiAgaWQ/OiB1bmtub3duO1xufVxuZGVjbGFyZSBjb25zdCBjaHJvbWU6IHsgcnVudGltZT86IEJyb3dzZXJSdW50aW1lIH07XG5kZWNsYXJlIGNvbnN0IGJyb3dzZXI6IHsgcnVudGltZT86IEJyb3dzZXJSdW50aW1lIH07XG5leHBvcnQgZnVuY3Rpb24gaXNCcm93c2VyRXh0ZW5zaW9uKCk6IGJvb2xlYW4ge1xuICBjb25zdCBydW50aW1lID1cbiAgICB0eXBlb2YgY2hyb21lID09PSAnb2JqZWN0J1xuICAgICAgPyBjaHJvbWUucnVudGltZVxuICAgICAgOiB0eXBlb2YgYnJvd3NlciA9PT0gJ29iamVjdCdcbiAgICAgID8gYnJvd3Nlci5ydW50aW1lXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHR5cGVvZiBydW50aW1lID09PSAnb2JqZWN0JyAmJiBydW50aW1lLmlkICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRGV0ZWN0IFJlYWN0IE5hdGl2ZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvclsncHJvZHVjdCddID09PSAnUmVhY3ROYXRpdmUnXG4gICk7XG59XG5cbi8qKiBEZXRlY3RzIEVsZWN0cm9uIGFwcHMuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVjdHJvbigpOiBib29sZWFuIHtcbiAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignRWxlY3Ryb24vJykgPj0gMDtcbn1cblxuLyoqIERldGVjdHMgSW50ZXJuZXQgRXhwbG9yZXIuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJRSgpOiBib29sZWFuIHtcbiAgY29uc3QgdWEgPSBnZXRVQSgpO1xuICByZXR1cm4gdWEuaW5kZXhPZignTVNJRSAnKSA+PSAwIHx8IHVhLmluZGV4T2YoJ1RyaWRlbnQvJykgPj0gMDtcbn1cblxuLyoqIERldGVjdHMgVW5pdmVyc2FsIFdpbmRvd3MgUGxhdGZvcm0gYXBwcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VXUCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignTVNBcHBIb3N0LycpID49IDA7XG59XG5cbi8qKlxuICogRGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgU0RLIGJ1aWxkIGlzIHRoZSBOb2RlIHZlcnNpb24uXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGl0J3MgdGhlIE5vZGUgU0RLIGJ1aWxkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlU2RrKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gQ09OU1RBTlRTLk5PREVfQ0xJRU5UID09PSB0cnVlIHx8IENPTlNUQU5UUy5OT0RFX0FETUlOID09PSB0cnVlO1xufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIHdlIGFyZSBydW5uaW5nIGluIFNhZmFyaS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmFyaSgpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICAhaXNOb2RlKCkgJiZcbiAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdTYWZhcmknKSAmJlxuICAgICFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdDaHJvbWUnKVxuICApO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XG4gKiBAcmV0dXJuIHRydWUgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbmRleGVkREJBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbmRleGVkREIgPT09ICdvYmplY3QnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdmFsaWRhdGVzIGJyb3dzZXIvc3cgY29udGV4dCBmb3IgaW5kZXhlZERCIGJ5IG9wZW5pbmcgYSBkdW1teSBpbmRleGVkREIgZGF0YWJhc2UgYW5kIHJlamVjdFxuICogaWYgZXJyb3JzIG9jY3VyIGR1cmluZyB0aGUgZGF0YWJhc2Ugb3BlbiBvcGVyYXRpb24uXG4gKlxuICogQHRocm93cyBleGNlcHRpb24gaWYgY3VycmVudCBicm93c2VyL3N3IGNvbnRleHQgY2FuJ3QgcnVuIGlkYi5vcGVuIChleDogU2FmYXJpIGlmcmFtZSwgRmlyZWZveFxuICogcHJpdmF0ZSBicm93c2luZylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBwcmVFeGlzdDogYm9vbGVhbiA9IHRydWU7XG4gICAgICBjb25zdCBEQl9DSEVDS19OQU1FID1cbiAgICAgICAgJ3ZhbGlkYXRlLWJyb3dzZXItY29udGV4dC1mb3ItaW5kZXhlZGRiLWFuYWx5dGljcy1tb2R1bGUnO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHNlbGYuaW5kZXhlZERCLm9wZW4oREJfQ0hFQ0tfTkFNRSk7XG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgcmVxdWVzdC5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgLy8gZGVsZXRlIGRhdGFiYXNlIG9ubHkgd2hlbiBpdCBkb2Vzbid0IHByZS1leGlzdFxuICAgICAgICBpZiAoIXByZUV4aXN0KSB7XG4gICAgICAgICAgc2VsZi5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoREJfQ0hFQ0tfTkFNRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH07XG4gICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcbiAgICAgICAgcHJlRXhpc3QgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3I/Lm1lc3NhZ2UgfHwgJycpO1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXG4gKiBAcmV0dXJuIHRydWUgaWYgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJlQ29va2llc0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFN0YW5kYXJkaXplZCBGaXJlYmFzZSBFcnJvci5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgIC8vIFR5cGVzY3JpcHQgc3RyaW5nIGxpdGVyYWxzIGZvciB0eXBlLXNhZmUgY29kZXNcbiAqICAgdHlwZSBFcnIgPVxuICogICAgICd1bmtub3duJyB8XG4gKiAgICAgJ29iamVjdC1ub3QtZm91bmQnXG4gKiAgICAgO1xuICpcbiAqICAgLy8gQ2xvc3VyZSBlbnVtIGZvciB0eXBlLXNhZmUgZXJyb3IgY29kZXNcbiAqICAgLy8gYXQtZW51bSB7c3RyaW5nfVxuICogICB2YXIgRXJyID0ge1xuICogICAgIFVOS05PV046ICd1bmtub3duJyxcbiAqICAgICBPQkpFQ1RfTk9UX0ZPVU5EOiAnb2JqZWN0LW5vdC1mb3VuZCcsXG4gKiAgIH1cbiAqXG4gKiAgIGxldCBlcnJvcnM6IE1hcDxFcnIsIHN0cmluZz4gPSB7XG4gKiAgICAgJ2dlbmVyaWMtZXJyb3InOiBcIlVua25vd24gZXJyb3JcIixcbiAqICAgICAnZmlsZS1ub3QtZm91bmQnOiBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IHskZmlsZX1cIixcbiAqICAgfTtcbiAqXG4gKiAgIC8vIFR5cGUtc2FmZSBmdW5jdGlvbiAtIG11c3QgcGFzcyBhIHZhbGlkIGVycm9yIGNvZGUgYXMgcGFyYW0uXG4gKiAgIGxldCBlcnJvciA9IG5ldyBFcnJvckZhY3Rvcnk8RXJyPignc2VydmljZScsICdTZXJ2aWNlJywgZXJyb3JzKTtcbiAqXG4gKiAgIC4uLlxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkdFTkVSSUMpO1xuICogICAuLi5cbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5GSUxFX05PVF9GT1VORCwgeydmaWxlJzogZmlsZU5hbWV9KTtcbiAqICAgLi4uXG4gKiAgIC8vIFNlcnZpY2U6IENvdWxkIG5vdCBmaWxlIGZpbGU6IGZvby50eHQgKHNlcnZpY2UvZmlsZS1ub3QtZm91bmQpLlxuICpcbiAqICAgY2F0Y2ggKGUpIHtcbiAqICAgICBhc3NlcnQoZS5tZXNzYWdlID09PSBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IGZvby50eHQuXCIpO1xuICogICAgIGlmICgoZSBhcyBGaXJlYmFzZUVycm9yKT8uY29kZSA9PT0gJ3NlcnZpY2UvZmlsZS1ub3QtZm91bmQnKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhcIkNvdWxkIG5vdCByZWFkIGZpbGU6IFwiICsgZVsnZmlsZSddKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqL1xuXG5leHBvcnQgdHlwZSBFcnJvck1hcDxFcnJvckNvZGUgZXh0ZW5kcyBzdHJpbmc+ID0ge1xuICByZWFkb25seSBbSyBpbiBFcnJvckNvZGVdOiBzdHJpbmc7XG59O1xuXG5jb25zdCBFUlJPUl9OQU1FID0gJ0ZpcmViYXNlRXJyb3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmluZ0xpa2Uge1xuICB0b1N0cmluZygpOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JEYXRhIHtcbiAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuLy8gQmFzZWQgb24gY29kZSBmcm9tOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjQ3VzdG9tX0Vycm9yX1R5cGVzXG5leHBvcnQgY2xhc3MgRmlyZWJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqIFRoZSBjdXN0b20gbmFtZSBmb3IgYWxsIEZpcmViYXNlRXJyb3JzLiAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmcgPSBFUlJPUl9OQU1FO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgZXJyb3IgY29kZSBmb3IgdGhpcyBlcnJvci4gKi9cbiAgICByZWFkb25seSBjb2RlOiBzdHJpbmcsXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIC8qKiBDdXN0b20gZGF0YSBmb3IgdGhpcyBlcnJvci4gKi9cbiAgICBwdWJsaWMgY3VzdG9tRGF0YT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuXG4gICAgLy8gRml4IEZvciBFUzVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBGaXJlYmFzZUVycm9yLnByb3RvdHlwZSk7XG5cbiAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93bi5cbiAgICAvLyBPbmx5IGF2YWlsYWJsZSBvbiBWOC5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVycm9yRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEVycm9yRmFjdG9yeTxcbiAgRXJyb3JDb2RlIGV4dGVuZHMgc3RyaW5nLFxuICBFcnJvclBhcmFtcyBleHRlbmRzIHsgcmVhZG9ubHkgW0sgaW4gRXJyb3JDb2RlXT86IEVycm9yRGF0YSB9ID0ge31cbj4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNlcnZpY2U6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNlcnZpY2VOYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBlcnJvcnM6IEVycm9yTWFwPEVycm9yQ29kZT5cbiAgKSB7fVxuXG4gIGNyZWF0ZTxLIGV4dGVuZHMgRXJyb3JDb2RlPihcbiAgICBjb2RlOiBLLFxuICAgIC4uLmRhdGE6IEsgZXh0ZW5kcyBrZXlvZiBFcnJvclBhcmFtcyA/IFtFcnJvclBhcmFtc1tLXV0gOiBbXVxuICApOiBGaXJlYmFzZUVycm9yIHtcbiAgICBjb25zdCBjdXN0b21EYXRhID0gKGRhdGFbMF0gYXMgRXJyb3JEYXRhKSB8fCB7fTtcbiAgICBjb25zdCBmdWxsQ29kZSA9IGAke3RoaXMuc2VydmljZX0vJHtjb2RlfWA7XG4gICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLmVycm9yc1tjb2RlXTtcblxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0ZW1wbGF0ZSA/IHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgY3VzdG9tRGF0YSkgOiAnRXJyb3InO1xuICAgIC8vIFNlcnZpY2UgTmFtZTogRXJyb3IgbWVzc2FnZSAoc2VydmljZS9jb2RlKS5cbiAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGAke3RoaXMuc2VydmljZU5hbWV9OiAke21lc3NhZ2V9ICgke2Z1bGxDb2RlfSkuYDtcblxuICAgIGNvbnN0IGVycm9yID0gbmV3IEZpcmViYXNlRXJyb3IoZnVsbENvZGUsIGZ1bGxNZXNzYWdlLCBjdXN0b21EYXRhKTtcblxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGU6IHN0cmluZywgZGF0YTogRXJyb3JEYXRhKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoUEFUVEVSTiwgKF8sIGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IGA8JHtrZXl9Pz5gO1xuICB9KTtcbn1cblxuY29uc3QgUEFUVEVSTiA9IC9cXHtcXCQoW159XSspfS9nO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBFdmFsdWF0ZXMgYSBKU09OIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBjb250YWluaW5nIEpTT04uXG4gKiBAcmV0dXJuIHsqfSBUaGUgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgSlNPTi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25FdmFsKHN0cjogc3RyaW5nKTogdW5rbm93biB7XG4gIHJldHVybiBKU09OLnBhcnNlKHN0cik7XG59XG5cbi8qKlxuICogUmV0dXJucyBKU09OIHJlcHJlc2VudGluZyBhIGphdmFzY3JpcHQgb2JqZWN0LlxuICogQHBhcmFtIHsqfSBkYXRhIEphdmFzY3JpcHQgb2JqZWN0IHRvIGJlIHN0cmluZ2lmaWVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSlNPTiBjb250ZW50cyBvZiB0aGUgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGE6IHVua25vd24pOiBzdHJpbmcge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBiYXNlNjREZWNvZGUgfSBmcm9tICcuL2NyeXB0JztcbmltcG9ydCB7IGpzb25FdmFsIH0gZnJvbSAnLi9qc29uJztcblxuaW50ZXJmYWNlIENsYWltcyB7XG4gIFtrZXk6IHN0cmluZ106IHt9O1xufVxuXG5pbnRlcmZhY2UgRGVjb2RlZFRva2VuIHtcbiAgaGVhZGVyOiBvYmplY3Q7XG4gIGNsYWltczogQ2xhaW1zO1xuICBkYXRhOiBvYmplY3Q7XG4gIHNpZ25hdHVyZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBpbnRvIGNvbnN0aXR1ZW50IHBhcnRzLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIHdpdGggaW52YWxpZCAvIGluY29tcGxldGUgY2xhaW1zIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uICh0b2tlbjogc3RyaW5nKTogRGVjb2RlZFRva2VuIHtcbiAgbGV0IGhlYWRlciA9IHt9LFxuICAgIGNsYWltczogQ2xhaW1zID0ge30sXG4gICAgZGF0YSA9IHt9LFxuICAgIHNpZ25hdHVyZSA9ICcnO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xuICAgIGhlYWRlciA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1swXSkgfHwgJycpIGFzIG9iamVjdDtcbiAgICBjbGFpbXMgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMV0pIHx8ICcnKSBhcyBDbGFpbXM7XG4gICAgc2lnbmF0dXJlID0gcGFydHNbMl07XG4gICAgZGF0YSA9IGNsYWltc1snZCddIHx8IHt9O1xuICAgIGRlbGV0ZSBjbGFpbXNbJ2QnXTtcbiAgfSBjYXRjaCAoZSkge31cblxuICByZXR1cm4ge1xuICAgIGhlYWRlcixcbiAgICBjbGFpbXMsXG4gICAgZGF0YSxcbiAgICBzaWduYXR1cmVcbiAgfTtcbn07XG5cbmludGVyZmFjZSBEZWNvZGVkVG9rZW4ge1xuICBoZWFkZXI6IG9iamVjdDtcbiAgY2xhaW1zOiBDbGFpbXM7XG4gIGRhdGE6IG9iamVjdDtcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyB0aW1lLWJhc2VkIGNsYWltcy4gV2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGVcbiAqIHRva2VuIGlzIHdpdGhpbiB0aGUgdGltZSB3aW5kb3cgYXV0aG9yaXplZCBieSB0aGUgJ25iZicgKG5vdC1iZWZvcmUpIGFuZCAnaWF0JyAoaXNzdWVkLWF0KSBjbGFpbXMuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmV4cG9ydCBjb25zdCBpc1ZhbGlkVGltZXN0YW1wID0gZnVuY3Rpb24gKHRva2VuOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgY2xhaW1zOiBDbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcbiAgY29uc3Qgbm93OiBudW1iZXIgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gIGxldCB2YWxpZFNpbmNlOiBudW1iZXIgPSAwLFxuICAgIHZhbGlkVW50aWw6IG51bWJlciA9IDA7XG5cbiAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnbmJmJykpIHtcbiAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ25iZiddIGFzIG51bWJlcjtcbiAgICB9IGVsc2UgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ2lhdCddIGFzIG51bWJlcjtcbiAgICB9XG5cbiAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdleHAnKSkge1xuICAgICAgdmFsaWRVbnRpbCA9IGNsYWltc1snZXhwJ10gYXMgbnVtYmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0b2tlbiB3aWxsIGV4cGlyZSBhZnRlciAyNGggYnkgZGVmYXVsdFxuICAgICAgdmFsaWRVbnRpbCA9IHZhbGlkU2luY2UgKyA4NjQwMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgICEhbm93ICYmXG4gICAgISF2YWxpZFNpbmNlICYmXG4gICAgISF2YWxpZFVudGlsICYmXG4gICAgbm93ID49IHZhbGlkU2luY2UgJiZcbiAgICBub3cgPD0gdmFsaWRVbnRpbFxuICApO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIHJldHVybnMgaXRzIGlzc3VlZCBhdCB0aW1lIGlmIHZhbGlkLCBudWxsIG90aGVyd2lzZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBudWxsIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzc3VlZEF0VGltZSA9IGZ1bmN0aW9uICh0b2tlbjogc3RyaW5nKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IGNsYWltczogQ2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XG4gICAgcmV0dXJuIGNsYWltc1snaWF0J10gYXMgbnVtYmVyO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIGZvcm1hdC4gRXhwZWN0cyBhIHZhbGlkIGlzc3VlZC1hdCB0aW1lLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodG9rZW4pLFxuICAgIGNsYWltcyA9IGRlY29kZWQuY2xhaW1zO1xuXG4gIHJldHVybiAhIWNsYWltcyAmJiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBwZWVyIGludG8gYW4gYXV0aCB0b2tlbiBhbmQgZGV0ZXJtaW5lIGlmIGl0J3MgYW4gYWRtaW4gYXV0aCB0b2tlbiBieSBsb29raW5nIGF0IHRoZSBjbGFpbXMgcG9ydGlvbi5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQWRtaW4gPSBmdW5jdGlvbiAodG9rZW46IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBjbGFpbXM6IENsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xuICByZXR1cm4gdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zWydhZG1pbiddID09PSB0cnVlO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluczxUIGV4dGVuZHMgb2JqZWN0PihvYmo6IFQsIGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FmZUdldDxUIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMga2V5b2YgVD4oXG4gIG9iajogVCxcbiAga2V5OiBLXG4pOiBUW0tdIHwgdW5kZWZpbmVkIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eShvYmo6IG9iamVjdCk6IG9iaiBpcyB7fSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwPEsgZXh0ZW5kcyBzdHJpbmcsIFYsIFU+KFxuICBvYmo6IHsgW2tleSBpbiBLXTogViB9LFxuICBmbjogKHZhbHVlOiBWLCBrZXk6IEssIG9iajogeyBba2V5IGluIEtdOiBWIH0pID0+IFUsXG4gIGNvbnRleHRPYmo/OiB1bmtub3duXG4pOiB7IFtrZXkgaW4gS106IFUgfSB7XG4gIGNvbnN0IHJlczogUGFydGlhbDx7IFtrZXkgaW4gS106IFUgfT4gPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gZm4uY2FsbChjb250ZXh0T2JqLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzIGFzIHsgW2tleSBpbiBLXTogVSB9O1xufVxuXG4vKipcbiAqIERlZXAgZXF1YWwgdHdvIG9iamVjdHMuIFN1cHBvcnQgQXJyYXlzIGFuZCBPYmplY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcEVxdWFsKGE6IG9iamVjdCwgYjogb2JqZWN0KTogYm9vbGVhbiB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICBmb3IgKGNvbnN0IGsgb2YgYUtleXMpIHtcbiAgICBpZiAoIWJLZXlzLmluY2x1ZGVzKGspKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYVByb3AgPSAoYSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilba107XG4gICAgY29uc3QgYlByb3AgPSAoYiBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilba107XG4gICAgaWYgKGlzT2JqZWN0KGFQcm9wKSAmJiBpc09iamVjdChiUHJvcCkpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGFQcm9wLCBiUHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYVByb3AgIT09IGJQcm9wKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBrIG9mIGJLZXlzKSB7XG4gICAgaWYgKCFhS2V5cy5pbmNsdWRlcyhrKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodGhpbmc6IHVua25vd24pOiB0aGluZyBpcyBvYmplY3Qge1xuICByZXR1cm4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0Jztcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IERlZmVycmVkIH0gZnJvbSAnLi9kZWZlcnJlZCc7XG5cbi8qKlxuICogUmVqZWN0cyBpZiB0aGUgZ2l2ZW4gcHJvbWlzZSBkb2Vzbid0IHJlc29sdmUgaW4gdGltZUluTVMgbWlsbGlzZWNvbmRzLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlV2l0aFRpbWVvdXQ8VD4oXG4gIHByb21pc2U6IFByb21pc2U8VD4sXG4gIHRpbWVJbk1TID0gMjAwMFxuKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IGRlZmVycmVkUHJvbWlzZSA9IG5ldyBEZWZlcnJlZDxUPigpO1xuICBzZXRUaW1lb3V0KCgpID0+IGRlZmVycmVkUHJvbWlzZS5yZWplY3QoJ3RpbWVvdXQhJyksIHRpbWVJbk1TKTtcbiAgcHJvbWlzZS50aGVuKGRlZmVycmVkUHJvbWlzZS5yZXNvbHZlLCBkZWZlcnJlZFByb21pc2UucmVqZWN0KTtcbiAgcmV0dXJuIGRlZmVycmVkUHJvbWlzZS5wcm9taXNlO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgcXVlcnlzdHJpbmctZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAmYXJnPXZhbCZhcmcyPXZhbDIpIGZyb20gYVxuICogcGFyYW1zIG9iamVjdCAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnlzdHJpbmdQYXJhbXM6IHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyO1xufSk6IHN0cmluZyB7XG4gIGNvbnN0IHBhcmFtcyA9IFtdO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhxdWVyeXN0cmluZ1BhcmFtcykpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goYXJyYXlWYWwgPT4ge1xuICAgICAgICBwYXJhbXMucHVzaChcbiAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChhcnJheVZhbClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyYW1zLmxlbmd0aCA/ICcmJyArIHBhcmFtcy5qb2luKCcmJykgOiAnJztcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgcXVlcnlzdHJpbmcgKGUuZy4gP2FyZz12YWwmYXJnMj12YWwyKSBpbnRvIGEgcGFyYW1zIG9iamVjdFxuICogKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeXN0cmluZ0RlY29kZShxdWVyeXN0cmluZzogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gIGNvbnN0IG9iajogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBjb25zdCB0b2tlbnMgPSBxdWVyeXN0cmluZy5yZXBsYWNlKC9eXFw/LywgJycpLnNwbGl0KCcmJyk7XG5cbiAgdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xuICAgIGlmICh0b2tlbikge1xuICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gdG9rZW4uc3BsaXQoJz0nKTtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQoa2V5KV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogRXh0cmFjdCB0aGUgcXVlcnkgc3RyaW5nIHBhcnQgb2YgYSBVUkwsIGluY2x1ZGluZyB0aGUgbGVhZGluZyBxdWVzdGlvbiBtYXJrIChpZiBwcmVzZW50KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RRdWVyeXN0cmluZyh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHF1ZXJ5U3RhcnQgPSB1cmwuaW5kZXhPZignPycpO1xuICBpZiAoIXF1ZXJ5U3RhcnQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3QgZnJhZ21lbnRTdGFydCA9IHVybC5pbmRleE9mKCcjJywgcXVlcnlTdGFydCk7XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKFxuICAgIHF1ZXJ5U3RhcnQsXG4gICAgZnJhZ21lbnRTdGFydCA+IDAgPyBmcmFnbWVudFN0YXJ0IDogdW5kZWZpbmVkXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoLlxuICogVmFyaWFibGUgbmFtZXMgZm9sbG93IHRoZSBub3RhdGlvbiBpbiBGSVBTIFBVQiAxODAtMzpcbiAqIGh0dHA6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9maXBzL2ZpcHMxODAtMy9maXBzMTgwLTNfZmluYWwucGRmLlxuICpcbiAqIFVzYWdlOlxuICogICB2YXIgc2hhMSA9IG5ldyBzaGExKCk7XG4gKiAgIHNoYTEudXBkYXRlKGJ5dGVzKTtcbiAqICAgdmFyIGhhc2ggPSBzaGExLmRpZ2VzdCgpO1xuICpcbiAqIFBlcmZvcm1hbmNlOlxuICogICBDaHJvbWUgMjM6ICAgfjQwMCBNYml0L3NcbiAqICAgRmlyZWZveCAxNjogIH4yNTAgTWJpdC9zXG4gKlxuICovXG5cbi8qKlxuICogU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoIGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSBwcm9wZXJ0aWVzIGRlY2xhcmVkIGhlcmUgYXJlIGRpc2N1c3NlZCBpbiB0aGUgYWJvdmUgYWxnb3JpdGhtIGRvY3VtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqL1xuZXhwb3J0IGNsYXNzIFNoYTEge1xuICAvKipcbiAgICogSG9sZHMgdGhlIHByZXZpb3VzIHZhbHVlcyBvZiBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYS1lIGluIHRoZSBjb21wcmVzc19cbiAgICogZnVuY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNoYWluXzogbnVtYmVyW10gPSBbXTtcblxuICAvKipcbiAgICogQSBidWZmZXIgaG9sZGluZyB0aGUgcGFydGlhbGx5IGNvbXB1dGVkIGhhc2ggcmVzdWx0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBidWZfOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiA4MCBieXRlcywgZWFjaCBhIHBhcnQgb2YgdGhlIG1lc3NhZ2UgdG8gYmUgaGFzaGVkLiAgUmVmZXJyZWQgdG9cbiAgICogYXMgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgaW4gdGhlIGRvY3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIFdfOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBDb250YWlucyBkYXRhIG5lZWRlZCB0byBwYWQgbWVzc2FnZXMgbGVzcyB0aGFuIDY0IGJ5dGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBwYWRfOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgKi9cbiAgcHJpdmF0ZSBpbmJ1Zl86IG51bWJlciA9IDA7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAqL1xuICBwcml2YXRlIHRvdGFsXzogbnVtYmVyID0gMDtcblxuICBibG9ja1NpemU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJsb2NrU2l6ZSA9IDUxMiAvIDg7XG5cbiAgICB0aGlzLnBhZF9bMF0gPSAxMjg7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgKytpKSB7XG4gICAgICB0aGlzLnBhZF9baV0gPSAwO1xuICAgIH1cblxuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY2hhaW5fWzBdID0gMHg2NzQ1MjMwMTtcbiAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XG4gICAgdGhpcy5jaGFpbl9bMl0gPSAweDk4YmFkY2ZlO1xuICAgIHRoaXMuY2hhaW5fWzNdID0gMHgxMDMyNTQ3NjtcbiAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XG5cbiAgICB0aGlzLmluYnVmXyA9IDA7XG4gICAgdGhpcy50b3RhbF8gPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGNvbXByZXNzIGhlbHBlciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIGJ1ZiBCbG9jayB0byBjb21wcmVzcy5cbiAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgb2YgdGhlIGJsb2NrIGluIHRoZSBidWZmZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wcmVzc18oYnVmOiBudW1iZXJbXSB8IFVpbnQ4QXJyYXkgfCBzdHJpbmcsIG9mZnNldD86IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGNvbnN0IFcgPSB0aGlzLldfO1xuXG4gICAgLy8gZ2V0IDE2IGJpZyBlbmRpYW4gd29yZHNcbiAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAvLyBUT0RPKHVzZXIpOiBbYnVnIDgxNDAxMjJdIFJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmkgZm9yIE1hYyBPUyBhbmQgaU9TXG4gICAgICAgIC8vIGhhdmUgYSBidWcgdGhhdCB0dXJucyB0aGUgcG9zdC1pbmNyZW1lbnQgKysgb3BlcmF0b3IgaW50byBwcmUtaW5jcmVtZW50XG4gICAgICAgIC8vIGR1cmluZyBKSVQgY29tcGlsYXRpb24uICBXZSBoYXZlIGNvZGUgdGhhdCBkZXBlbmRzIGhlYXZpbHkgb24gU0hBLTEgZm9yXG4gICAgICAgIC8vIGNvcnJlY3RuZXNzIGFuZCB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIGJ1Zywgc28gSSd2ZSByZW1vdmVkIGFsbCB1c2VzXG4gICAgICAgIC8vIG9mIHBvc3QtaW5jcmVtZW50ICsrIGluIHdoaWNoIHRoZSByZXN1bHQgdmFsdWUgaXMgdXNlZC4gIFdlIGNhbiByZXZlcnRcbiAgICAgICAgLy8gdGhpcyBjaGFuZ2Ugb25jZSB0aGUgU2FmYXJpIGJ1Z1xuICAgICAgICAvLyAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwOTAzNikgaGFzIGJlZW4gZml4ZWQgYW5kXG4gICAgICAgIC8vIG1vc3QgY2xpZW50cyBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAgICAgV1tpXSA9XG4gICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQpIHxcbiAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYpIHxcbiAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCkgfFxuICAgICAgICAgIGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDMpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIFdbaV0gPVxuICAgICAgICAgIChidWZbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICAgICAgIChidWZbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgICBidWZbb2Zmc2V0ICsgM107XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV4cGFuZCB0byA4MCB3b3Jkc1xuICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGNvbnN0IHQgPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuICAgICAgV1tpXSA9ICgodCA8PCAxKSB8ICh0ID4+PiAzMSkpICYgMHhmZmZmZmZmZjtcbiAgICB9XG5cbiAgICBsZXQgYSA9IHRoaXMuY2hhaW5fWzBdO1xuICAgIGxldCBiID0gdGhpcy5jaGFpbl9bMV07XG4gICAgbGV0IGMgPSB0aGlzLmNoYWluX1syXTtcbiAgICBsZXQgZCA9IHRoaXMuY2hhaW5fWzNdO1xuICAgIGxldCBlID0gdGhpcy5jaGFpbl9bNF07XG4gICAgbGV0IGYsIGs7XG5cbiAgICAvLyBUT0RPKHVzZXIpOiBUcnkgdG8gdW5yb2xsIHRoaXMgbG9vcCB0byBzcGVlZCB1cCB0aGUgY29tcHV0YXRpb24uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICBpZiAoaSA8IDQwKSB7XG4gICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICBmID0gZCBeIChiICYgKGMgXiBkKSk7XG4gICAgICAgICAgayA9IDB4NWE4Mjc5OTk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgICBrID0gMHg2ZWQ5ZWJhMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGkgPCA2MCkge1xuICAgICAgICAgIGYgPSAoYiAmIGMpIHwgKGQgJiAoYiB8IGMpKTtcbiAgICAgICAgICBrID0gMHg4ZjFiYmNkYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgdGhpcy5jaGFpbl9bMF0gPSAodGhpcy5jaGFpbl9bMF0gKyBhKSAmIDB4ZmZmZmZmZmY7XG4gICAgdGhpcy5jaGFpbl9bMV0gPSAodGhpcy5jaGFpbl9bMV0gKyBiKSAmIDB4ZmZmZmZmZmY7XG4gICAgdGhpcy5jaGFpbl9bMl0gPSAodGhpcy5jaGFpbl9bMl0gKyBjKSAmIDB4ZmZmZmZmZmY7XG4gICAgdGhpcy5jaGFpbl9bM10gPSAodGhpcy5jaGFpbl9bM10gKyBkKSAmIDB4ZmZmZmZmZmY7XG4gICAgdGhpcy5jaGFpbl9bNF0gPSAodGhpcy5jaGFpbl9bNF0gKyBlKSAmIDB4ZmZmZmZmZmY7XG4gIH1cblxuICB1cGRhdGUoYnl0ZXM/OiBudW1iZXJbXSB8IFVpbnQ4QXJyYXkgfCBzdHJpbmcsIGxlbmd0aD86IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFRPRE8oam9obmxlbnopOiB0aWdodGVuIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgYW5kIHJlbW92ZSB0aGlzIGNoZWNrXG4gICAgaWYgKGJ5dGVzID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGhNaW51c0Jsb2NrID0gbGVuZ3RoIC0gdGhpcy5ibG9ja1NpemU7XG4gICAgbGV0IG4gPSAwO1xuICAgIC8vIFVzaW5nIGxvY2FsIGluc3RlYWQgb2YgbWVtYmVyIHZhcmlhYmxlcyBnaXZlcyB+NSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LlxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuYnVmXztcbiAgICBsZXQgaW5idWYgPSB0aGlzLmluYnVmXztcblxuICAgIC8vIFRoZSBvdXRlciB3aGlsZSBsb29wIHNob3VsZCBleGVjdXRlIGF0IG1vc3QgdHdpY2UuXG4gICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxuICAgICAgLy8gaW5wdXQgYnVmZmVyIChhc3N1bWluZyBpdCBjb250YWlucyBzdWZmaWNpZW50IGRhdGEpLiBUaGlzIGdpdmVzIH4yNSVcbiAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcbiAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cbiAgICAgIGlmIChpbmJ1ZiA9PT0gMCkge1xuICAgICAgICB3aGlsZSAobiA8PSBsZW5ndGhNaW51c0Jsb2NrKSB7XG4gICAgICAgICAgdGhpcy5jb21wcmVzc18oYnl0ZXMsIG4pO1xuICAgICAgICAgIG4gKz0gdGhpcy5ibG9ja1NpemU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXMuY2hhckNvZGVBdChuKTtcbiAgICAgICAgICArK2luYnVmO1xuICAgICAgICAgICsrbjtcbiAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xuICAgICAgICAgICAgaW5idWYgPSAwO1xuICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xuICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlc1tuXTtcbiAgICAgICAgICArK2luYnVmO1xuICAgICAgICAgICsrbjtcbiAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xuICAgICAgICAgICAgaW5idWYgPSAwO1xuICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbmJ1Zl8gPSBpbmJ1ZjtcbiAgICB0aGlzLnRvdGFsXyArPSBsZW5ndGg7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRpZ2VzdCgpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgZGlnZXN0OiBudW1iZXJbXSA9IFtdO1xuICAgIGxldCB0b3RhbEJpdHMgPSB0aGlzLnRvdGFsXyAqIDg7XG5cbiAgICAvLyBBZGQgcGFkIDB4ODAgMHgwMCouXG4gICAgaWYgKHRoaXMuaW5idWZfIDwgNTYpIHtcbiAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgNTYgLSB0aGlzLmluYnVmXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgdGhpcy5ibG9ja1NpemUgLSAodGhpcy5pbmJ1Zl8gLSA1NikpO1xuICAgIH1cblxuICAgIC8vIEFkZCAjIGJpdHMuXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuYmxvY2tTaXplIC0gMTsgaSA+PSA1NjsgaS0tKSB7XG4gICAgICB0aGlzLmJ1Zl9baV0gPSB0b3RhbEJpdHMgJiAyNTU7XG4gICAgICB0b3RhbEJpdHMgLz0gMjU2OyAvLyBEb24ndCB1c2UgYml0LXNoaWZ0aW5nIGhlcmUhXG4gICAgfVxuXG4gICAgdGhpcy5jb21wcmVzc18odGhpcy5idWZfKTtcblxuICAgIGxldCBuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgICBkaWdlc3Rbbl0gPSAodGhpcy5jaGFpbl9baV0gPj4gaikgJiAyNTU7XG4gICAgICAgICsrbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZ2VzdDtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRGbjxUPiA9ICh2YWx1ZTogVCkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIEVycm9yRm4gPSAoZXJyb3I6IEVycm9yKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgQ29tcGxldGVGbiA9ICgpID0+IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2JzZXJ2ZXI8VD4ge1xuICAvLyBDYWxsZWQgb25jZSBmb3IgZWFjaCB2YWx1ZSBpbiBhIHN0cmVhbSBvZiB2YWx1ZXMuXG4gIG5leHQ6IE5leHRGbjxUPjtcblxuICAvLyBBIHN0cmVhbSB0ZXJtaW5hdGVzIGJ5IGEgc2luZ2xlIGNhbGwgdG8gRUlUSEVSIGVycm9yKCkgb3IgY29tcGxldGUoKS5cbiAgZXJyb3I6IEVycm9yRm47XG5cbiAgLy8gTm8gZXZlbnRzIHdpbGwgYmUgc2VudCB0byBuZXh0KCkgb25jZSBjb21wbGV0ZSgpIGlzIGNhbGxlZC5cbiAgY29tcGxldGU6IENvbXBsZXRlRm47XG59XG5cbmV4cG9ydCB0eXBlIFBhcnRpYWxPYnNlcnZlcjxUPiA9IFBhcnRpYWw8T2JzZXJ2ZXI8VD4+O1xuXG4vLyBUT0RPOiBTdXBwb3J0IGFsc28gVW5zdWJzY3JpYmUudW5zdWJzY3JpYmU/XG5leHBvcnQgdHlwZSBVbnN1YnNjcmliZSA9ICgpID0+IHZvaWQ7XG5cbi8qKlxuICogVGhlIFN1YnNjcmliZSBpbnRlcmZhY2UgaGFzIHR3byBmb3JtcyAtIHBhc3NpbmcgdGhlIGlubGluZSBmdW5jdGlvblxuICogY2FsbGJhY2tzLCBvciBhIG9iamVjdCBpbnRlcmZhY2Ugd2l0aCBjYWxsYmFjayBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1YnNjcmliZTxUPiB7XG4gIChuZXh0PzogTmV4dEZuPFQ+LCBlcnJvcj86IEVycm9yRm4sIGNvbXBsZXRlPzogQ29tcGxldGVGbik6IFVuc3Vic2NyaWJlO1xuICAob2JzZXJ2ZXI6IFBhcnRpYWxPYnNlcnZlcjxUPik6IFVuc3Vic2NyaWJlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAvLyBTdWJzY3JpYmUgbWV0aG9kXG4gIHN1YnNjcmliZTogU3Vic2NyaWJlPFQ+O1xufVxuXG5leHBvcnQgdHlwZSBFeGVjdXRvcjxUPiA9IChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHZvaWQ7XG5cbi8qKlxuICogSGVscGVyIHRvIG1ha2UgYSBTdWJzY3JpYmUgZnVuY3Rpb24gKGp1c3QgbGlrZSBQcm9taXNlIGhlbHBzIG1ha2UgYVxuICogVGhlbmFibGUpLlxuICpcbiAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxuICogICAgIGFzIGEgcHJveHkuXG4gKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmU8VD4oXG4gIGV4ZWN1dG9yOiBFeGVjdXRvcjxUPixcbiAgb25Ob09ic2VydmVycz86IEV4ZWN1dG9yPFQ+XG4pOiBTdWJzY3JpYmU8VD4ge1xuICBjb25zdCBwcm94eSA9IG5ldyBPYnNlcnZlclByb3h5PFQ+KGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKTtcbiAgcmV0dXJuIHByb3h5LnN1YnNjcmliZS5iaW5kKHByb3h5KTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnQgZmFuLW91dCBmb3IgYW55IG51bWJlciBvZiBPYnNlcnZlcnMgYXR0YWNoZWQgdmlhIGEgc3Vic2NyaWJlXG4gKiBmdW5jdGlvbi5cbiAqL1xuY2xhc3MgT2JzZXJ2ZXJQcm94eTxUPiBpbXBsZW1lbnRzIE9ic2VydmVyPFQ+IHtcbiAgcHJpdmF0ZSBvYnNlcnZlcnM6IEFycmF5PE9ic2VydmVyPFQ+PiB8IHVuZGVmaW5lZCA9IFtdO1xuICBwcml2YXRlIHVuc3Vic2NyaWJlczogVW5zdWJzY3JpYmVbXSA9IFtdO1xuICBwcml2YXRlIG9uTm9PYnNlcnZlcnM6IEV4ZWN1dG9yPFQ+IHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIG9ic2VydmVyQ291bnQgPSAwO1xuICAvLyBNaWNyby10YXNrIHNjaGVkdWxpbmcgYnkgY2FsbGluZyB0YXNrLnRoZW4oKS5cbiAgcHJpdmF0ZSB0YXNrID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHByaXZhdGUgZmluYWxpemVkID0gZmFsc2U7XG4gIHByaXZhdGUgZmluYWxFcnJvcj86IEVycm9yO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcbiAgICogICAgIGFzIGEgcHJveHkuXG4gICAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yOiBFeGVjdXRvcjxUPiwgb25Ob09ic2VydmVycz86IEV4ZWN1dG9yPFQ+KSB7XG4gICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gb25Ob09ic2VydmVycztcbiAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcbiAgICAvLyBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBjcmVhdGlvbiBvZiB0aGUgc3Vic2NyaWJlIGZ1bmN0aW9uXG4gICAgLy8gY2FuIHN0aWxsIHJlY2VpdmUgdGhlIHZlcnkgZmlyc3QgdmFsdWUgZ2VuZXJhdGVkIGluIHRoZSBleGVjdXRvci5cbiAgICB0aGlzLnRhc2tcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgZXhlY3V0b3IodGhpcyk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgfSk7XG4gIH1cblxuICBuZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xuICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBlcnJvcihlcnJvcjogRXJyb3IpOiB2b2lkIHtcbiAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB7XG4gICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XG4gICAgfSk7XG4gICAgdGhpcy5jbG9zZShlcnJvcik7XG4gIH1cblxuICBjb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB7XG4gICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgYW4gT2JzZXJ2ZXIgdG8gdGhlIGZhbi1vdXQgbGlzdC5cbiAgICpcbiAgICogLSBXZSByZXF1aXJlIHRoYXQgbm8gZXZlbnQgaXMgc2VudCB0byBhIHN1YnNjcmliZXIgc3ljaHJvbm91c2x5IHRvIHRoZWlyXG4gICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cbiAgICovXG4gIHN1YnNjcmliZShcbiAgICBuZXh0T3JPYnNlcnZlcj86IE5leHRGbjxUPiB8IFBhcnRpYWxPYnNlcnZlcjxUPixcbiAgICBlcnJvcj86IEVycm9yRm4sXG4gICAgY29tcGxldGU/OiBDb21wbGV0ZUZuXG4gICk6IFVuc3Vic2NyaWJlIHtcbiAgICBsZXQgb2JzZXJ2ZXI6IE9ic2VydmVyPFQ+O1xuXG4gICAgaWYgKFxuICAgICAgbmV4dE9yT2JzZXJ2ZXIgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgZXJyb3IgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgY29tcGxldGUgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE9ic2VydmVyLicpO1xuICAgIH1cblxuICAgIC8vIEFzc2VtYmxlIGFuIE9ic2VydmVyIG9iamVjdCB3aGVuIHBhc3NlZCBhcyBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgaWYgKFxuICAgICAgaW1wbGVtZW50c0FueU1ldGhvZHMobmV4dE9yT2JzZXJ2ZXIgYXMgeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0sIFtcbiAgICAgICAgJ25leHQnLFxuICAgICAgICAnZXJyb3InLFxuICAgICAgICAnY29tcGxldGUnXG4gICAgICBdKVxuICAgICkge1xuICAgICAgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlciBhcyBPYnNlcnZlcjxUPjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JzZXJ2ZXIgPSB7XG4gICAgICAgIG5leHQ6IG5leHRPck9ic2VydmVyIGFzIE5leHRGbjxUPixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGNvbXBsZXRlXG4gICAgICB9IGFzIE9ic2VydmVyPFQ+O1xuICAgIH1cblxuICAgIGlmIChvYnNlcnZlci5uZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9ic2VydmVyLm5leHQgPSBub29wIGFzIE5leHRGbjxUPjtcbiAgICB9XG4gICAgaWYgKG9ic2VydmVyLmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9ic2VydmVyLmVycm9yID0gbm9vcCBhcyBFcnJvckZuO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIuY29tcGxldGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JzZXJ2ZXIuY29tcGxldGUgPSBub29wIGFzIENvbXBsZXRlRm47XG4gICAgfVxuXG4gICAgY29uc3QgdW5zdWIgPSB0aGlzLnVuc3Vic2NyaWJlT25lLmJpbmQodGhpcywgdGhpcy5vYnNlcnZlcnMhLmxlbmd0aCk7XG5cbiAgICAvLyBBdHRlbXB0IHRvIHN1YnNjcmliZSB0byBhIHRlcm1pbmF0ZWQgT2JzZXJ2YWJsZSAtIHdlXG4gICAgLy8ganVzdCByZXNwb25kIHRvIHRoZSBPYnNlcnZlciB3aXRoIHRoZSBmaW5hbCBlcnJvciBvciBjb21wbGV0ZVxuICAgIC8vIGV2ZW50LlxuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0aGlzLmZpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHRoaXMuZmluYWxFcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMub2JzZXJ2ZXJzIS5wdXNoKG9ic2VydmVyIGFzIE9ic2VydmVyPFQ+KTtcblxuICAgIHJldHVybiB1bnN1YjtcbiAgfVxuXG4gIC8vIFVuc3Vic2NyaWJlIGlzIHN5bmNocm9ub3VzIC0gd2UgZ3VhcmFudGVlIHRoYXQgbm8gZXZlbnRzIGFyZSBzZW50IHRvXG4gIC8vIGFueSB1bnN1YnNjcmliZWQgT2JzZXJ2ZXIuXG4gIHByaXZhdGUgdW5zdWJzY3JpYmVPbmUoaTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXJzID09PSB1bmRlZmluZWQgfHwgdGhpcy5vYnNlcnZlcnNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVyc1tpXTtcblxuICAgIHRoaXMub2JzZXJ2ZXJDb3VudCAtPSAxO1xuICAgIGlmICh0aGlzLm9ic2VydmVyQ291bnQgPT09IDAgJiYgdGhpcy5vbk5vT2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub25Ob09ic2VydmVycyh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZvckVhY2hPYnNlcnZlcihmbjogKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4gdm9pZCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgLy8gQWxyZWFkeSBjbG9zZWQgYnkgcHJldmlvdXMgZXZlbnQuLi4uanVzdCBlYXQgdGhlIGFkZGl0aW9uYWwgdmFsdWVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNpbmNlIHNlbmRPbmUgY2FsbHMgYXN5bmNocm9ub3VzbHkgLSB0aGVyZSBpcyBubyBjaGFuY2UgdGhhdFxuICAgIC8vIHRoaXMub2JzZXJ2ZXJzIHdpbGwgYmVjb21lIHVuZGVmaW5lZC5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZXJzIS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXG4gIC8vIGNvbmZpcm0gdGhhdCB0aGUgb2JzZXJ2ZSBoYXMgbm90IGJlZW4gdW5zdWJzY3JpYmVkIHNpbmNlIHRoaXMgYXN5bmNocm9ub3VzXG4gIC8vIGZ1bmN0aW9uIGhhZCBiZWVuIHF1ZXVlZC5cbiAgcHJpdmF0ZSBzZW5kT25lKGk6IG51bWJlciwgZm46IChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhc3luY2hyb25vdXNseVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XG4gICAgICBpZiAodGhpcy5vYnNlcnZlcnMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9ic2VydmVyc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm4odGhpcy5vYnNlcnZlcnNbaV0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGV4Y2VwdGlvbnMgcmFpc2VkIGluIE9ic2VydmVycyBvciBtaXNzaW5nIG1ldGhvZHMgb2YgYW5cbiAgICAgICAgICAvLyBPYnNlcnZlci5cbiAgICAgICAgICAvLyBMb2cgZXJyb3IgdG8gY29uc29sZS4gYi8zMTQwNDgwNlxuICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY2xvc2UoZXJyPzogRXJyb3IpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5maW5hbEVycm9yID0gZXJyO1xuICAgIH1cbiAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5vYnNlcnZlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqIFR1cm4gc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBvbmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmV4cG9ydCBmdW5jdGlvbiBhc3luYyhmbjogRnVuY3Rpb24sIG9uRXJyb3I/OiBFcnJvckZuKTogRnVuY3Rpb24ge1xuICByZXR1cm4gKC4uLmFyZ3M6IHVua25vd25bXSkgPT4ge1xuICAgIFByb21pc2UucmVzb2x2ZSh0cnVlKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpbXBsZW1lbnRzIGFueSBvZiB0aGUgbmFtZWQgbWV0aG9kcy5cbiAqL1xuZnVuY3Rpb24gaW1wbGVtZW50c0FueU1ldGhvZHMoXG4gIG9iajogeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0sXG4gIG1ldGhvZHM6IHN0cmluZ1tdXG4pOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICBpZiAobWV0aG9kIGluIG9iaiAmJiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpOiB2b2lkIHtcbiAgLy8gZG8gbm90aGluZ1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBDaGVjayB0byBtYWtlIHN1cmUgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIGZvciBhIHB1YmxpYyBmdW5jdGlvbi5cbiAqIFRocm93cyBhbiBlcnJvciBpZiBpdCBmYWlscy5cbiAqXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXG4gKiBAcGFyYW0gbWluQ291bnQgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcbiAqIEBwYXJhbSBtYXhDb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnQgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXG4gKiBAcGFyYW0gYXJnQ291bnQgVGhlIGFjdHVhbCBudW1iZXIgb2YgYXJndW1lbnRzIHByb3ZpZGVkLlxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVBcmdDb3VudCA9IGZ1bmN0aW9uIChcbiAgZm5OYW1lOiBzdHJpbmcsXG4gIG1pbkNvdW50OiBudW1iZXIsXG4gIG1heENvdW50OiBudW1iZXIsXG4gIGFyZ0NvdW50OiBudW1iZXJcbik6IHZvaWQge1xuICBsZXQgYXJnRXJyb3I7XG4gIGlmIChhcmdDb3VudCA8IG1pbkNvdW50KSB7XG4gICAgYXJnRXJyb3IgPSAnYXQgbGVhc3QgJyArIG1pbkNvdW50O1xuICB9IGVsc2UgaWYgKGFyZ0NvdW50ID4gbWF4Q291bnQpIHtcbiAgICBhcmdFcnJvciA9IG1heENvdW50ID09PSAwID8gJ25vbmUnIDogJ25vIG1vcmUgdGhhbiAnICsgbWF4Q291bnQ7XG4gIH1cbiAgaWYgKGFyZ0Vycm9yKSB7XG4gICAgY29uc3QgZXJyb3IgPVxuICAgICAgZm5OYW1lICtcbiAgICAgICcgZmFpbGVkOiBXYXMgY2FsbGVkIHdpdGggJyArXG4gICAgICBhcmdDb3VudCArXG4gICAgICAoYXJnQ291bnQgPT09IDEgPyAnIGFyZ3VtZW50LicgOiAnIGFyZ3VtZW50cy4nKSArXG4gICAgICAnIEV4cGVjdHMgJyArXG4gICAgICBhcmdFcnJvciArXG4gICAgICAnLic7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzdHJpbmcgdG8gcHJlZml4IGFuIGVycm9yIG1lc3NhZ2UgYWJvdXQgZmFpbGVkIGFyZ3VtZW50IHZhbGlkYXRpb25cbiAqXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXG4gKiBAcGFyYW0gYXJnTmFtZSBUaGUgbmFtZSBvZiB0aGUgYXJndW1lbnRcbiAqIEByZXR1cm4gVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIHRocm93biBmb3IgdmFsaWRhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yUHJlZml4KGZuTmFtZTogc3RyaW5nLCBhcmdOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7Zm5OYW1lfSBmYWlsZWQ6ICR7YXJnTmFtZX0gYXJndW1lbnQgYDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gZm5OYW1lXG4gKiBAcGFyYW0gYXJndW1lbnROdW1iZXJcbiAqIEBwYXJhbSBuYW1lc3BhY2VcbiAqIEBwYXJhbSBvcHRpb25hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVOYW1lc3BhY2UoXG4gIGZuTmFtZTogc3RyaW5nLFxuICBuYW1lc3BhY2U6IHN0cmluZyxcbiAgb3B0aW9uYWw6IGJvb2xlYW5cbik6IHZvaWQge1xuICBpZiAob3B0aW9uYWwgJiYgIW5hbWVzcGFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAvL1RPRE86IEkgc2hvdWxkIGRvIG1vcmUgdmFsaWRhdGlvbiBoZXJlLiBXZSBvbmx5IGFsbG93IGNlcnRhaW4gY2hhcnMgaW4gbmFtZXNwYWNlcy5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvclByZWZpeChmbk5hbWUsICduYW1lc3BhY2UnKSArICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgbmFtZXNwYWNlLidcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNhbGxiYWNrKFxuICBmbk5hbWU6IHN0cmluZyxcbiAgYXJndW1lbnROYW1lOiBzdHJpbmcsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gIGNhbGxiYWNrOiBGdW5jdGlvbixcbiAgb3B0aW9uYWw6IGJvb2xlYW5cbik6IHZvaWQge1xuICBpZiAob3B0aW9uYWwgJiYgIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgKyAnbXVzdCBiZSBhIHZhbGlkIGZ1bmN0aW9uLidcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHRPYmplY3QoXG4gIGZuTmFtZTogc3RyaW5nLFxuICBhcmd1bWVudE5hbWU6IHN0cmluZyxcbiAgY29udGV4dDogdW5rbm93bixcbiAgb3B0aW9uYWw6IGJvb2xlYW5cbik6IHZvaWQge1xuICBpZiAob3B0aW9uYWwgJiYgIWNvbnRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JyB8fCBjb250ZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC4nXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi9hc3NlcnQnO1xuXG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcbi8vIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgJ1xcclxcbicgd2l0aCAnXFxuJywgYW5kIHRoZXkgZGlkbid0IGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMsXG4vLyBzbyBpdCdzIGJlZW4gbW9kaWZpZWQuXG5cbi8vIE5vdGUgdGhhdCBub3QgYWxsIFVuaWNvZGUgY2hhcmFjdGVycyBhcHBlYXIgYXMgc2luZ2xlIGNoYXJhY3RlcnMgaW4gSmF2YVNjcmlwdCBzdHJpbmdzLlxuLy8gZnJvbUNoYXJDb2RlIHJldHVybnMgdGhlIFVURi0xNiBlbmNvZGluZyBvZiBhIGNoYXJhY3RlciAtIHNvIHNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzXG4vLyB1c2UgMiBjaGFyYWN0ZXJzIGluIEphdmFzY3JpcHQuICBBbGwgNC1ieXRlIFVURi04IGNoYXJhY3RlcnMgYmVnaW4gd2l0aCBhIGZpcnN0XG4vLyBjaGFyYWN0ZXIgaW4gdGhlIHJhbmdlIDB4RDgwMCAtIDB4REJGRiAodGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHNvLWNhbGxlZCBzdXJyb2dhdGVcbi8vIHBhaXIpLlxuLy8gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy0xNS4xLjNcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHN0cjogc3RyaW5nKTogbnVtYmVyW10ge1xuICBjb25zdCBvdXQ6IG51bWJlcltdID0gW107XG4gIGxldCBwID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgLy8gSXMgdGhpcyB0aGUgbGVhZCBzdXJyb2dhdGUgaW4gYSBzdXJyb2dhdGUgcGFpcj9cbiAgICBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcbiAgICAgIGNvbnN0IGhpZ2ggPSBjIC0gMHhkODAwOyAvLyB0aGUgaGlnaCAxMCBiaXRzLlxuICAgICAgaSsrO1xuICAgICAgYXNzZXJ0KGkgPCBzdHIubGVuZ3RoLCAnU3Vycm9nYXRlIHBhaXIgbWlzc2luZyB0cmFpbCBzdXJyb2dhdGUuJyk7XG4gICAgICBjb25zdCBsb3cgPSBzdHIuY2hhckNvZGVBdChpKSAtIDB4ZGMwMDsgLy8gdGhlIGxvdyAxMCBiaXRzLlxuICAgICAgYyA9IDB4MTAwMDAgKyAoaGlnaCA8PCAxMCkgKyBsb3c7XG4gICAgfVxuXG4gICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgIG91dFtwKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICB9IGVsc2UgaWYgKGMgPCA2NTUzNikge1xuICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xuICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgbGVuZ3RoIHdpdGhvdXQgYWN0dWFsbHkgY29udmVydGluZzsgdXNlZnVsIGZvciBkb2luZyBjaGVhcGVyIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdMZW5ndGggPSBmdW5jdGlvbiAoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICBsZXQgcCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICBwKys7XG4gICAgfSBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgcCArPSAyO1xuICAgIH0gZWxzZSBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcbiAgICAgIC8vIExlYWQgc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuICBUaGUgcGFpciB0b2dldGhlciB3aWxsIHRha2UgNCBieXRlcyB0byByZXByZXNlbnQuXG4gICAgICBwICs9IDQ7XG4gICAgICBpKys7IC8vIHNraXAgdHJhaWwgc3Vycm9nYXRlLlxuICAgIH0gZWxzZSB7XG4gICAgICBwICs9IDM7XG4gICAgfVxuICB9XG4gIHJldHVybiBwO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQ29waWVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcbiAqIEdlbmVyYXRlcyBhIG5ldyB1dWlkLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdXVpZHY0ID0gZnVuY3Rpb24gKCk6IHN0cmluZyB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xuICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsXG4gICAgICB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogVGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gZXhwb25lbnRpYWxseSBpbmNyZWFzZS5cbiAqL1xuY29uc3QgREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMgPSAxMDAwO1xuXG4vKipcbiAqIFRoZSBmYWN0b3IgdG8gYmFja29mZiBieS5cbiAqIFNob3VsZCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMS5cbiAqL1xuY29uc3QgREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiA9IDI7XG5cbi8qKlxuICogVGhlIG1heGltdW0gbWlsbGlzZWNvbmRzIHRvIGluY3JlYXNlIHRvLlxuICpcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9WQUxVRV9NSUxMSVMgPSA0ICogNjAgKiA2MCAqIDEwMDA7IC8vIEZvdXIgaG91cnMsIGxpa2UgaU9TIGFuZCBBbmRyb2lkLlxuXG4vKipcbiAqIFRoZSBwZXJjZW50YWdlIG9mIGJhY2tvZmYgdGltZSB0byByYW5kb21pemUgYnkuXG4gKiBTZWVcbiAqIGh0dHA6Ly9nby9zYWZlLWNsaWVudC1iZWhhdmlvciNzdGVwLTEtZGV0ZXJtaW5lLXRoZS1hcHByb3ByaWF0ZS1yZXRyeS1pbnRlcnZhbC10by1oYW5kbGUtc3Bpa2UtdHJhZmZpY1xuICogZm9yIGNvbnRleHQuXG4gKlxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xuICovXG5leHBvcnQgY29uc3QgUkFORE9NX0ZBQ1RPUiA9IDAuNTtcblxuLyoqXG4gKiBCYXNlZCBvbiB0aGUgYmFja29mZiBtZXRob2QgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvZXhwb25lbnRpYWxiYWNrb2ZmLmpzLlxuICogRXh0cmFjdGVkIGhlcmUgc28gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG1ldGFkYXRhIGFuZCBhIHN0YXRlZnVsIEV4cG9uZW50aWFsQmFja29mZiBvYmplY3QgYXJvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQmFja29mZk1pbGxpcyhcbiAgYmFja29mZkNvdW50OiBudW1iZXIsXG4gIGludGVydmFsTWlsbGlzOiBudW1iZXIgPSBERUZBVUxUX0lOVEVSVkFMX01JTExJUyxcbiAgYmFja29mZkZhY3RvcjogbnVtYmVyID0gREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUlxuKTogbnVtYmVyIHtcbiAgLy8gQ2FsY3VsYXRlcyBhbiBleHBvbmVudGlhbGx5IGluY3JlYXNpbmcgdmFsdWUuXG4gIC8vIERldmlhdGlvbjogY2FsY3VsYXRlcyB2YWx1ZSBmcm9tIGNvdW50IGFuZCBhIGNvbnN0YW50IGludGVydmFsLCBzbyB3ZSBvbmx5IG5lZWQgdG8gc2F2ZSB2YWx1ZVxuICAvLyBhbmQgY291bnQgdG8gcmVzdG9yZSBzdGF0ZS5cbiAgY29uc3QgY3VyckJhc2VWYWx1ZSA9IGludGVydmFsTWlsbGlzICogTWF0aC5wb3coYmFja29mZkZhY3RvciwgYmFja29mZkNvdW50KTtcblxuICAvLyBBIHJhbmRvbSBcImZ1enpcIiB0byBhdm9pZCB3YXZlcyBvZiByZXRyaWVzLlxuICAvLyBEZXZpYXRpb246IHJhbmRvbUZhY3RvciBpcyByZXF1aXJlZC5cbiAgY29uc3QgcmFuZG9tV2FpdCA9IE1hdGgucm91bmQoXG4gICAgLy8gQSBmcmFjdGlvbiBvZiB0aGUgYmFja29mZiB2YWx1ZSB0byBhZGQvc3VidHJhY3QuXG4gICAgLy8gRGV2aWF0aW9uOiBjaGFuZ2VzIG11bHRpcGxpY2F0aW9uIG9yZGVyIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkuXG4gICAgUkFORE9NX0ZBQ1RPUiAqXG4gICAgICBjdXJyQmFzZVZhbHVlICpcbiAgICAgIC8vIEEgcmFuZG9tIGZsb2F0IChyb3VuZGVkIHRvIGludCBieSBNYXRoLnJvdW5kIGFib3ZlKSBpbiB0aGUgcmFuZ2UgWy0xLCAxXS4gRGV0ZXJtaW5lc1xuICAgICAgLy8gaWYgd2UgYWRkIG9yIHN1YnRyYWN0LlxuICAgICAgKE1hdGgucmFuZG9tKCkgLSAwLjUpICpcbiAgICAgIDJcbiAgKTtcblxuICAvLyBMaW1pdHMgYmFja29mZiB0byBtYXggdG8gYXZvaWQgZWZmZWN0aXZlbHkgcGVybWFuZW50IGJhY2tvZmYuXG4gIHJldHVybiBNYXRoLm1pbihNQVhfVkFMVUVfTUlMTElTLCBjdXJyQmFzZVZhbHVlICsgcmFuZG9tV2FpdCk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFByb3ZpZGUgRW5nbGlzaCBvcmRpbmFsIGxldHRlcnMgYWZ0ZXIgYSBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yZGluYWwoaTogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaSkpIHtcbiAgICByZXR1cm4gYCR7aX1gO1xuICB9XG4gIHJldHVybiBpICsgaW5kaWNhdG9yKGkpO1xufVxuXG5mdW5jdGlvbiBpbmRpY2F0b3IoaTogbnVtYmVyKTogc3RyaW5nIHtcbiAgaSA9IE1hdGguYWJzKGkpO1xuICBjb25zdCBjZW50ID0gaSAlIDEwMDtcbiAgaWYgKGNlbnQgPj0gMTAgJiYgY2VudCA8PSAyMCkge1xuICAgIHJldHVybiAndGgnO1xuICB9XG4gIGNvbnN0IGRlYyA9IGkgJSAxMDtcbiAgaWYgKGRlYyA9PT0gMSkge1xuICAgIHJldHVybiAnc3QnO1xuICB9XG4gIGlmIChkZWMgPT09IDIpIHtcbiAgICByZXR1cm4gJ25kJztcbiAgfVxuICBpZiAoZGVjID09PSAzKSB7XG4gICAgcmV0dXJuICdyZCc7XG4gIH1cbiAgcmV0dXJuICd0aCc7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBhdDxUPiB7XG4gIF9kZWxlZ2F0ZTogVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vZHVsYXJJbnN0YW5jZTxFeHBTZXJ2aWNlPihcbiAgc2VydmljZTogQ29tcGF0PEV4cFNlcnZpY2U+IHwgRXhwU2VydmljZVxuKTogRXhwU2VydmljZSB7XG4gIGlmIChzZXJ2aWNlICYmIChzZXJ2aWNlIGFzIENvbXBhdDxFeHBTZXJ2aWNlPikuX2RlbGVnYXRlKSB7XG4gICAgcmV0dXJuIChzZXJ2aWNlIGFzIENvbXBhdDxFeHBTZXJ2aWNlPikuX2RlbGVnYXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzZXJ2aWNlIGFzIEV4cFNlcnZpY2U7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQge1xuICBJbnN0YW50aWF0aW9uTW9kZSxcbiAgSW5zdGFuY2VGYWN0b3J5LFxuICBDb21wb25lbnRUeXBlLFxuICBEaWN0aW9uYXJ5LFxuICBOYW1lLFxuICBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIENvbXBvbmVudCBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcbiAqL1xuZXhwb3J0IGNsYXNzIENvbXBvbmVudDxUIGV4dGVuZHMgTmFtZSA9IE5hbWU+IHtcbiAgbXVsdGlwbGVJbnN0YW5jZXMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFByb3BlcnRpZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHNlcnZpY2UgbmFtZXNwYWNlXG4gICAqL1xuICBzZXJ2aWNlUHJvcHM6IERpY3Rpb25hcnkgPSB7fTtcblxuICBpbnN0YW50aWF0aW9uTW9kZSA9IEluc3RhbnRpYXRpb25Nb2RlLkxBWlk7XG5cbiAgb25JbnN0YW5jZUNyZWF0ZWQ6IG9uSW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2s8VD4gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgVGhlIHB1YmxpYyBzZXJ2aWNlIG5hbWUsIGUuZy4gYXBwLCBhdXRoLCBmaXJlc3RvcmUsIGRhdGFiYXNlXG4gICAqIEBwYXJhbSBpbnN0YW5jZUZhY3RvcnkgU2VydmljZSBmYWN0b3J5IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcHVibGljIGludGVyZmFjZVxuICAgKiBAcGFyYW0gdHlwZSB3aGV0aGVyIHRoZSBzZXJ2aWNlIHByb3ZpZGVkIGJ5IHRoZSBjb21wb25lbnQgaXMgcHVibGljIG9yIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IG5hbWU6IFQsXG4gICAgcmVhZG9ubHkgaW5zdGFuY2VGYWN0b3J5OiBJbnN0YW5jZUZhY3Rvcnk8VD4sXG4gICAgcmVhZG9ubHkgdHlwZTogQ29tcG9uZW50VHlwZVxuICApIHt9XG5cbiAgc2V0SW5zdGFudGlhdGlvbk1vZGUobW9kZTogSW5zdGFudGlhdGlvbk1vZGUpOiB0aGlzIHtcbiAgICB0aGlzLmluc3RhbnRpYXRpb25Nb2RlID0gbW9kZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE11bHRpcGxlSW5zdGFuY2VzKG11bHRpcGxlSW5zdGFuY2VzOiBib29sZWFuKTogdGhpcyB7XG4gICAgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyA9IG11bHRpcGxlSW5zdGFuY2VzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0U2VydmljZVByb3BzKHByb3BzOiBEaWN0aW9uYXJ5KTogdGhpcyB7XG4gICAgdGhpcy5zZXJ2aWNlUHJvcHMgPSBwcm9wcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEluc3RhbmNlQ3JlYXRlZENhbGxiYWNrKGNhbGxiYWNrOiBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrPFQ+KTogdGhpcyB7XG4gICAgdGhpcy5vbkluc3RhbmNlQ3JlYXRlZCA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IENvbXBvbmVudENvbnRhaW5lciB9IGZyb20gJy4vY29tcG9uZW50X2NvbnRhaW5lcic7XG5pbXBvcnQgeyBERUZBVUxUX0VOVFJZX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBJbml0aWFsaXplT3B0aW9ucyxcbiAgSW5zdGFudGlhdGlvbk1vZGUsXG4gIE5hbWUsXG4gIE5hbWVTZXJ2aWNlTWFwcGluZyxcbiAgT25Jbml0Q2FsbEJhY2tcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGluc3RhbmNlIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiAnYXV0aCcsICdhdXRoLWludGVybmFsJ1xuICogTmFtZVNlcnZpY2VNYXBwaW5nW1RdIGlzIGFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNsYXNzIFByb3ZpZGVyPFQgZXh0ZW5kcyBOYW1lPiB7XG4gIHByaXZhdGUgY29tcG9uZW50OiBDb21wb25lbnQ8VD4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSByZWFkb25seSBpbnN0YW5jZXM6IE1hcDxzdHJpbmcsIE5hbWVTZXJ2aWNlTWFwcGluZ1tUXT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgaW5zdGFuY2VzRGVmZXJyZWQ6IE1hcDxcbiAgICBzdHJpbmcsXG4gICAgRGVmZXJyZWQ8TmFtZVNlcnZpY2VNYXBwaW5nW1RdPlxuICA+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlYWRvbmx5IGluc3RhbmNlc09wdGlvbnM6IE1hcDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9XG4gICAgbmV3IE1hcCgpO1xuICBwcml2YXRlIG9uSW5pdENhbGxiYWNrczogTWFwPHN0cmluZywgU2V0PE9uSW5pdENhbGxCYWNrPFQ+Pj4gPSBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBuYW1lOiBULFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29udGFpbmVyOiBDb21wb25lbnRDb250YWluZXJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gaWRlbnRpZmllciBBIHByb3ZpZGVyIGNhbiBwcm92aWRlIG11bGl0cGxlIGluc3RhbmNlcyBvZiBhIHNlcnZpY2VcbiAgICogaWYgdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgaXMgdHJ1ZS5cbiAgICovXG4gIGdldChpZGVudGlmaWVyPzogc3RyaW5nKTogUHJvbWlzZTxOYW1lU2VydmljZU1hcHBpbmdbVF0+IHtcbiAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG5cbiAgICBpZiAoIXRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuaGFzKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQ8TmFtZVNlcnZpY2VNYXBwaW5nW1RdPigpO1xuICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGRlZmVycmVkKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICAgIHRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKVxuICAgICAgKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNlcnZpY2UgaWYgaXQgY2FuIGJlIGF1dG8taW5pdGlhbGl6ZWRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IHRocm93cyBhbiBleGNlcHRpb24gZHVyaW5nIGdldCgpLCBpdCBzaG91bGQgbm90IGNhdXNlXG4gICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCByZXR1cm4gdGhlIHVucmVzb2x2ZWQgcHJvbWlzZSBpbiB0aGlzIGNhc2UuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpIS5wcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWxpdHBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXG4gICAqIGlmIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzIGlzIHRydWUuXG4gICAqIEBwYXJhbSBvcHRpb25zLm9wdGlvbmFsIElmIG9wdGlvbmFsIGlzIGZhbHNlIG9yIG5vdCBwcm92aWRlZCwgdGhlIG1ldGhvZCB0aHJvd3MgYW4gZXJyb3Igd2hlblxuICAgKiB0aGUgc2VydmljZSBpcyBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLlxuICAgKiBJZiBvcHRpb25hbCBpcyB0cnVlLCB0aGUgbWV0aG9kIHJldHVybnMgbnVsbCBpZiB0aGUgc2VydmljZSBpcyBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLlxuICAgKi9cbiAgZ2V0SW1tZWRpYXRlKG9wdGlvbnM6IHtcbiAgICBpZGVudGlmaWVyPzogc3RyaW5nO1xuICAgIG9wdGlvbmFsOiB0cnVlO1xuICB9KTogTmFtZVNlcnZpY2VNYXBwaW5nW1RdIHwgbnVsbDtcbiAgZ2V0SW1tZWRpYXRlKG9wdGlvbnM/OiB7XG4gICAgaWRlbnRpZmllcj86IHN0cmluZztcbiAgICBvcHRpb25hbD86IGZhbHNlO1xuICB9KTogTmFtZVNlcnZpY2VNYXBwaW5nW1RdO1xuICBnZXRJbW1lZGlhdGUob3B0aW9ucz86IHtcbiAgICBpZGVudGlmaWVyPzogc3RyaW5nO1xuICAgIG9wdGlvbmFsPzogYm9vbGVhbjtcbiAgfSk6IE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSB8IG51bGwge1xuICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXG4gICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihcbiAgICAgIG9wdGlvbnM/LmlkZW50aWZpZXJcbiAgICApO1xuICAgIGNvbnN0IG9wdGlvbmFsID0gb3B0aW9ucz8ub3B0aW9uYWwgPz8gZmFsc2U7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKClcbiAgICApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xuICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gY2FzZSBhIGNvbXBvbmVudCBpcyBub3QgaW5pdGlhbGl6ZWQgYW5kIHNob3VsZC9jYW4gbm90IGJlIGF1dG8taW5pdGlhbGl6ZWQgYXQgdGhlIG1vbWVudCwgcmV0dXJuIG51bGwgaWYgdGhlIG9wdGlvbmFsIGZsYWcgaXMgc2V0LCBvciB0aHJvd1xuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFNlcnZpY2UgJHt0aGlzLm5hbWV9IGlzIG5vdCBhdmFpbGFibGVgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRDb21wb25lbnQoKTogQ29tcG9uZW50PFQ+IHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50O1xuICB9XG5cbiAgc2V0Q29tcG9uZW50KGNvbXBvbmVudDogQ29tcG9uZW50PFQ+KTogdm9pZCB7XG4gICAgaWYgKGNvbXBvbmVudC5uYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgTWlzbWF0Y2hpbmcgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGZvciBQcm92aWRlciAke3RoaXMubmFtZX0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgZm9yICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkYCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG5cbiAgICAvLyByZXR1cm4gZWFybHkgd2l0aG91dCBhdHRlbXB0aW5nIHRvIGluaXRpYWxpemUgdGhlIGNvbXBvbmVudCBpZiB0aGUgY29tcG9uZW50IHJlcXVpcmVzIGV4cGxpY2l0IGluaXRpYWxpemF0aW9uIChjYWxsaW5nIGBQcm92aWRlci5pbml0aWFsaXplKClgKVxuICAgIGlmICghdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHNlcnZpY2UgaXMgZWFnZXIsIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgaW5zdGFuY2VcbiAgICBpZiAoaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXI6IERFRkFVTFRfRU5UUllfTkFNRSB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSBmb3IgYW4gZWFnZXIgQ29tcG9uZW50IHRocm93cyBhbiBleGNlcHRpb24gZHVyaW5nIHRoZSBlYWdlclxuICAgICAgICAvLyBpbml0aWFsaXphdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZSBhIGZhdGFsIGVycm9yLlxuICAgICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB3ZSBuZWVkIHRvIG1ha2UgaXQgY29uZmlndXJhYmxlLCBiZWNhdXNlIHNvbWUgY29tcG9uZW50IG1heSB3YW50IHRvIGNhdXNlXG4gICAgICAgIC8vIGEgZmF0YWwgZXJyb3IgaW4gdGhpcyBjYXNlP1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBzZXJ2aWNlIGluc3RhbmNlcyBmb3IgdGhlIHBlbmRpbmcgcHJvbWlzZXMgYW5kIHJlc29sdmUgdGhlbVxuICAgIC8vIE5PVEU6IGlmIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgaXMgZmFsc2UsIG9ubHkgdGhlIGRlZmF1bHQgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkXG4gICAgLy8gYW5kIGFsbCBwcm9taXNlcyB3aXRoIHJlc29sdmUgd2l0aCBpdCByZWdhcmRsZXNzIG9mIHRoZSBpZGVudGlmaWVyLlxuICAgIGZvciAoY29uc3QgW1xuICAgICAgaW5zdGFuY2VJZGVudGlmaWVyLFxuICAgICAgaW5zdGFuY2VEZWZlcnJlZFxuICAgIF0gb2YgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID1cbiAgICAgICAgdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaW5zdGFuY2VJZGVudGlmaWVyKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gYGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoKWAgc2hvdWxkIGFsd2F5cyByZXR1cm4gYSB2YWxpZCBpbnN0YW5jZSBzaW5jZSBhIGNvbXBvbmVudCBpcyBndWFyYW50ZWVkLiB1c2UgISB0byBtYWtlIHR5cGVzY3JpcHQgaGFwcHkuXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXG4gICAgICAgIH0pITtcbiAgICAgICAgaW5zdGFuY2VEZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uLCBpdCBzaG91bGQgbm90IGNhdXNlXG4gICAgICAgIC8vIGEgZmF0YWwgZXJyb3IuIFdlIGp1c3QgbGVhdmUgdGhlIHByb21pc2UgdW5yZXNvbHZlZC5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbGVhckluc3RhbmNlKGlkZW50aWZpZXI6IHN0cmluZyA9IERFRkFVTFRfRU5UUllfTkFNRSk6IHZvaWQge1xuICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucy5kZWxldGUoaWRlbnRpZmllcik7XG4gICAgdGhpcy5pbnN0YW5jZXMuZGVsZXRlKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgLy8gYXBwLmRlbGV0ZSgpIHdpbGwgY2FsbCB0aGlzIG1ldGhvZCBvbiBldmVyeSBwcm92aWRlciB0byBkZWxldGUgdGhlIHNlcnZpY2VzXG4gIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xuICBhc3luYyBkZWxldGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc2VydmljZXMgPSBBcnJheS5mcm9tKHRoaXMuaW5zdGFuY2VzLnZhbHVlcygpKTtcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIC4uLnNlcnZpY2VzXG4gICAgICAgIC5maWx0ZXIoc2VydmljZSA9PiAnSU5URVJOQUwnIGluIHNlcnZpY2UpIC8vIGxlZ2FjeSBzZXJ2aWNlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAubWFwKHNlcnZpY2UgPT4gKHNlcnZpY2UgYXMgYW55KS5JTlRFUk5BTCEuZGVsZXRlKCkpLFxuICAgICAgLi4uc2VydmljZXNcbiAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAubWFwKHNlcnZpY2UgPT4gKHNlcnZpY2UgYXMgYW55KS5fZGVsZXRlKCkpXG4gICAgXSk7XG4gIH1cblxuICBpc0NvbXBvbmVudFNldCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnQgIT0gbnVsbDtcbiAgfVxuXG4gIGlzSW5pdGlhbGl6ZWQoaWRlbnRpZmllcjogc3RyaW5nID0gREVGQVVMVF9FTlRSWV9OQU1FKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcbiAgfVxuXG4gIGdldE9wdGlvbnMoaWRlbnRpZmllcjogc3RyaW5nID0gREVGQVVMVF9FTlRSWV9OQU1FKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZShvcHRzOiBJbml0aWFsaXplT3B0aW9ucyA9IHt9KTogTmFtZVNlcnZpY2VNYXBwaW5nW1RdIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcbiAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKFxuICAgICAgb3B0cy5pbnN0YW5jZUlkZW50aWZpZXJcbiAgICApO1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYCR7dGhpcy5uYW1lfSgke25vcm1hbGl6ZWRJZGVudGlmaWVyfSkgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzQ29tcG9uZW50U2V0KCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXG4gICAgICBvcHRpb25zXG4gICAgfSkhO1xuXG4gICAgLy8gcmVzb2x2ZSBhbnkgcGVuZGluZyBwcm9taXNlIHdhaXRpbmcgZm9yIHRoZSBzZXJ2aWNlIGluc3RhbmNlXG4gICAgZm9yIChjb25zdCBbXG4gICAgICBpbnN0YW5jZUlkZW50aWZpZXIsXG4gICAgICBpbnN0YW5jZURlZmVycmVkXG4gICAgXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllciA9XG4gICAgICAgIHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcbiAgICAgICAgaW5zdGFuY2VEZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCAgYWZ0ZXIgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ5IGNhbGxpbmcgcHJvdmlkZXIuaW5pdGlhbGl6ZSgpLlxuICAgKiBUaGUgZnVuY3Rpb24gaXMgaW52b2tlZCBTWU5DSFJPTk9VU0xZLCBzbyBpdCBzaG91bGQgbm90IGV4ZWN1dGUgYW55IGxvbmdydW5uaW5nIHRhc2tzIGluIG9yZGVyIHRvIG5vdCBibG9jayB0aGUgcHJvZ3JhbS5cbiAgICpcbiAgICogQHBhcmFtIGlkZW50aWZpZXIgQW4gb3B0aW9uYWwgaW5zdGFuY2UgaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVucmVnaXN0ZXIgdGhlIGNhbGxiYWNrXG4gICAqL1xuICBvbkluaXQoY2FsbGJhY2s6IE9uSW5pdENhbGxCYWNrPFQ+LCBpZGVudGlmaWVyPzogc3RyaW5nKTogKCkgPT4gdm9pZCB7XG4gICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICBjb25zdCBleGlzdGluZ0NhbGxiYWNrcyA9XG4gICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpID8/XG4gICAgICBuZXcgU2V0PE9uSW5pdENhbGxCYWNrPFQ+PigpO1xuICAgIGV4aXN0aW5nQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgdGhpcy5vbkluaXRDYWxsYmFja3Muc2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyLCBleGlzdGluZ0NhbGxiYWNrcyk7XG5cbiAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcbiAgICBpZiAoZXhpc3RpbmdJbnN0YW5jZSkge1xuICAgICAgY2FsbGJhY2soZXhpc3RpbmdJbnN0YW5jZSwgbm9ybWFsaXplZElkZW50aWZpZXIpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBleGlzdGluZ0NhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlIG9uSW5pdCBjYWxsYmFja3Mgc3luY2hyb25vdXNseVxuICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXG4gICAqL1xuICBwcml2YXRlIGludm9rZU9uSW5pdENhbGxiYWNrcyhcbiAgICBpbnN0YW5jZTogTmFtZVNlcnZpY2VNYXBwaW5nW1RdLFxuICAgIGlkZW50aWZpZXI6IHN0cmluZ1xuICApOiB2b2lkIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLm9uSW5pdENhbGxiYWNrcy5nZXQoaWRlbnRpZmllcik7XG4gICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKGluc3RhbmNlLCBpZGVudGlmaWVyKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xuICAgIGluc3RhbmNlSWRlbnRpZmllcixcbiAgICBvcHRpb25zID0ge31cbiAgfToge1xuICAgIGluc3RhbmNlSWRlbnRpZmllcjogc3RyaW5nO1xuICAgIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfSk6IE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSB8IG51bGwge1xuICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChpbnN0YW5jZUlkZW50aWZpZXIpO1xuICAgIGlmICghaW5zdGFuY2UgJiYgdGhpcy5jb21wb25lbnQpIHtcbiAgICAgIGluc3RhbmNlID0gdGhpcy5jb21wb25lbnQuaW5zdGFuY2VGYWN0b3J5KHRoaXMuY29udGFpbmVyLCB7XG4gICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaW5zdGFuY2VJZGVudGlmaWVyKSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgICB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XG4gICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogSW52b2tlIG9uSW5pdCBsaXN0ZW5lcnMuXG4gICAgICAgKiBOb3RlIHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkIGlzIGRpZmZlcmVudCwgd2hpY2ggaXMgdXNlZCBieSB0aGUgY29tcG9uZW50IGNyZWF0b3IsXG4gICAgICAgKiB3aGlsZSBvbkluaXQgbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGJ5IGNvbnN1bWVycyBvZiB0aGUgcHJvdmlkZXIuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuaW52b2tlT25Jbml0Q2FsbGJhY2tzKGluc3RhbmNlLCBpbnN0YW5jZUlkZW50aWZpZXIpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9yZGVyIGlzIGltcG9ydGFudFxuICAgICAgICogb25JbnN0YW5jZUNyZWF0ZWQoKSBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMuaW5zdGFuY2VzLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTsgd2hpY2hcbiAgICAgICAqIG1ha2VzIGBpc0luaXRpYWxpemVkKClgIHJldHVybiB0cnVlLlxuICAgICAgICovXG4gICAgICBpZiAodGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZChcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2UgfHwgbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgbm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKFxuICAgIGlkZW50aWZpZXI6IHN0cmluZyA9IERFRkFVTFRfRU5UUllfTkFNRVxuICApOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzID8gaWRlbnRpZmllciA6IERFRkFVTFRfRU5UUllfTkFNRTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlkZW50aWZpZXI7IC8vIGFzc3VtZSBtdWx0aXBsZSBpbnN0YW5jZXMgYXJlIHN1cHBvcnRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNob3VsZEF1dG9Jbml0aWFsaXplKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICAhIXRoaXMuY29tcG9uZW50ICYmXG4gICAgICB0aGlzLmNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSAhPT0gSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVRcbiAgICApO1xuICB9XG59XG5cbi8vIHVuZGVmaW5lZCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBzZXJ2aWNlIGZhY3RvcnkgZm9yIHRoZSBkZWZhdWx0IGluc3RhbmNlXG5mdW5jdGlvbiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpZGVudGlmaWVyOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gaWRlbnRpZmllciA9PT0gREVGQVVMVF9FTlRSWV9OQU1FID8gdW5kZWZpbmVkIDogaWRlbnRpZmllcjtcbn1cblxuZnVuY3Rpb24gaXNDb21wb25lbnRFYWdlcjxUIGV4dGVuZHMgTmFtZT4oY29tcG9uZW50OiBDb21wb25lbnQ8VD4pOiBib29sZWFuIHtcbiAgcmV0dXJuIGNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSA9PT0gSW5zdGFudGlhdGlvbk1vZGUuRUFHRVI7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJy4vcHJvdmlkZXInO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgTmFtZSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIENvbXBvbmVudENvbnRhaW5lciB0aGF0IHByb3ZpZGVzIFByb3ZpZGVycyBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcbiAqL1xuZXhwb3J0IGNsYXNzIENvbXBvbmVudENvbnRhaW5lciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvdmlkZXJzID0gbmV3IE1hcDxzdHJpbmcsIFByb3ZpZGVyPE5hbWU+PigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgbmFtZTogc3RyaW5nKSB7fVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gY29tcG9uZW50IENvbXBvbmVudCBiZWluZyBhZGRlZFxuICAgKiBAcGFyYW0gb3ZlcndyaXRlIFdoZW4gYSBjb21wb25lbnQgd2l0aCB0aGUgc2FtZSBuYW1lIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCxcbiAgICogaWYgb3ZlcndyaXRlIGlzIHRydWU6IG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggdGhlIG5ldyBjb21wb25lbnQgYW5kIGNyZWF0ZSBhIG5ld1xuICAgKiBwcm92aWRlciB3aXRoIHRoZSBuZXcgY29tcG9uZW50LiBJdCBjYW4gYmUgdXNlZnVsIGluIHRlc3RzIHdoZXJlIHlvdSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgbW9ja3NcbiAgICogZm9yIGRpZmZlcmVudCB0ZXN0cy5cbiAgICogaWYgb3ZlcndyaXRlIGlzIGZhbHNlOiB0aHJvdyBhbiBleGNlcHRpb25cbiAgICovXG4gIGFkZENvbXBvbmVudDxUIGV4dGVuZHMgTmFtZT4oY29tcG9uZW50OiBDb21wb25lbnQ8VD4pOiB2b2lkIHtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xuICAgIGlmIChwcm92aWRlci5pc0NvbXBvbmVudFNldCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBwcm92aWRlci5zZXRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgfVxuXG4gIGFkZE9yT3ZlcndyaXRlQ29tcG9uZW50PFQgZXh0ZW5kcyBOYW1lPihjb21wb25lbnQ6IENvbXBvbmVudDxUPik6IHZvaWQge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XG4gICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcbiAgICAgIC8vIGRlbGV0ZSB0aGUgZXhpc3RpbmcgcHJvdmlkZXIgZnJvbSB0aGUgY29udGFpbmVyLCBzbyB3ZSBjYW4gcmVnaXN0ZXIgdGhlIG5ldyBjb21wb25lbnRcbiAgICAgIHRoaXMucHJvdmlkZXJzLmRlbGV0ZShjb21wb25lbnQubmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRQcm92aWRlciBwcm92aWRlcyBhIHR5cGUgc2FmZSBpbnRlcmZhY2Ugd2hlcmUgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSBmaWVsZCBuYW1lXG4gICAqIHByZXNlbnQgaW4gTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZS5cbiAgICpcbiAgICogRmlyZWJhc2UgU0RLcyBwcm92aWRpbmcgc2VydmljZXMgc2hvdWxkIGV4dGVuZCBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlIHRvIHJlZ2lzdGVyXG4gICAqIHRoZW1zZWx2ZXMuXG4gICAqL1xuICBnZXRQcm92aWRlcjxUIGV4dGVuZHMgTmFtZT4obmFtZTogVCk6IFByb3ZpZGVyPFQ+IHtcbiAgICBpZiAodGhpcy5wcm92aWRlcnMuaGFzKG5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnMuZ2V0KG5hbWUpIGFzIHVua25vd24gYXMgUHJvdmlkZXI8VD47XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgUHJvdmlkZXIgZm9yIGEgc2VydmljZSB0aGF0IGhhc24ndCByZWdpc3RlcmVkIHdpdGggRmlyZWJhc2VcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBQcm92aWRlcjxUPihuYW1lLCB0aGlzKTtcbiAgICB0aGlzLnByb3ZpZGVycy5zZXQobmFtZSwgcHJvdmlkZXIgYXMgdW5rbm93biBhcyBQcm92aWRlcjxOYW1lPik7XG5cbiAgICByZXR1cm4gcHJvdmlkZXIgYXMgUHJvdmlkZXI8VD47XG4gIH1cblxuICBnZXRQcm92aWRlcnMoKTogQXJyYXk8UHJvdmlkZXI8TmFtZT4+IHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy52YWx1ZXMoKSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCB0eXBlIExvZ0xldmVsU3RyaW5nID1cbiAgfCAnZGVidWcnXG4gIHwgJ3ZlcmJvc2UnXG4gIHwgJ2luZm8nXG4gIHwgJ3dhcm4nXG4gIHwgJ2Vycm9yJ1xuICB8ICdzaWxlbnQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvZ09wdGlvbnMge1xuICBsZXZlbDogTG9nTGV2ZWxTdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIExvZ0NhbGxiYWNrID0gKGNhbGxiYWNrUGFyYW1zOiBMb2dDYWxsYmFja1BhcmFtcykgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBMb2dDYWxsYmFja1BhcmFtcyB7XG4gIGxldmVsOiBMb2dMZXZlbFN0cmluZztcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBhcmdzOiB1bmtub3duW107XG4gIHR5cGU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXG4gKi9cbmV4cG9ydCBjb25zdCBpbnN0YW5jZXM6IExvZ2dlcltdID0gW107XG5cbi8qKlxuICogVGhlIEpTIFNESyBzdXBwb3J0cyA1IGxvZyBsZXZlbHMgYW5kIGFsc28gYWxsb3dzIGEgdXNlciB0aGUgYWJpbGl0eSB0b1xuICogc2lsZW5jZSB0aGUgbG9ncyBhbHRvZ2V0aGVyLlxuICpcbiAqIFRoZSBvcmRlciBpcyBhIGZvbGxvd3M6XG4gKiBERUJVRyA8IFZFUkJPU0UgPCBJTkZPIDwgV0FSTiA8IEVSUk9SXG4gKlxuICogQWxsIG9mIHRoZSBsb2cgdHlwZXMgYWJvdmUgdGhlIGN1cnJlbnQgbG9nIGxldmVsIHdpbGwgYmUgY2FwdHVyZWQgKGkuZS4gaWZcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgSU5GT2AsIGVycm9ycyB3aWxsIHN0aWxsIGJlIGxvZ2dlZCwgYnV0IGBERUJVR2AgYW5kXG4gKiBgVkVSQk9TRWAgbG9ncyB3aWxsIG5vdClcbiAqL1xuZXhwb3J0IGVudW0gTG9nTGV2ZWwge1xuICBERUJVRyxcbiAgVkVSQk9TRSxcbiAgSU5GTyxcbiAgV0FSTixcbiAgRVJST1IsXG4gIFNJTEVOVFxufVxuXG5jb25zdCBsZXZlbFN0cmluZ1RvRW51bTogeyBba2V5IGluIExvZ0xldmVsU3RyaW5nXTogTG9nTGV2ZWwgfSA9IHtcbiAgJ2RlYnVnJzogTG9nTGV2ZWwuREVCVUcsXG4gICd2ZXJib3NlJzogTG9nTGV2ZWwuVkVSQk9TRSxcbiAgJ2luZm8nOiBMb2dMZXZlbC5JTkZPLFxuICAnd2Fybic6IExvZ0xldmVsLldBUk4sXG4gICdlcnJvcic6IExvZ0xldmVsLkVSUk9SLFxuICAnc2lsZW50JzogTG9nTGV2ZWwuU0lMRU5UXG59O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGxvZyBsZXZlbFxuICovXG5jb25zdCBkZWZhdWx0TG9nTGV2ZWw6IExvZ0xldmVsID0gTG9nTGV2ZWwuSU5GTztcblxuLyoqXG4gKiBXZSBhbGxvdyB1c2VycyB0aGUgYWJpbGl0eSB0byBwYXNzIHRoZWlyIG93biBsb2cgaGFuZGxlci4gV2Ugd2lsbCBwYXNzIHRoZVxuICogdHlwZSBvZiBsb2csIHRoZSBjdXJyZW50IGxvZyBsZXZlbCwgYW5kIGFueSBvdGhlciBhcmd1bWVudHMgcGFzc2VkIChpLmUuIHRoZVxuICogbWVzc2FnZXMgdGhhdCB0aGUgdXNlciB3YW50cyB0byBsb2cpIHRvIHRoaXMgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCB0eXBlIExvZ0hhbmRsZXIgPSAoXG4gIGxvZ2dlckluc3RhbmNlOiBMb2dnZXIsXG4gIGxvZ1R5cGU6IExvZ0xldmVsLFxuICAuLi5hcmdzOiB1bmtub3duW11cbikgPT4gdm9pZDtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGRpc3BsYXllZCBpbiB0aGUgZGV2ZWxvcGVyIGNvbnNvbGUgKGluXG4gKiBjaHJvbWUpLiBUbyBhdm9pZCBmb3JjaW5nIHVzZXJzIHRvIGhhdmUgdG8gb3B0LWluIHRvIHRoZXNlIGxvZ3MgdHdpY2VcbiAqIChpLmUuIG9uY2UgZm9yIGZpcmViYXNlLCBhbmQgb25jZSBpbiB0aGUgY29uc29sZSksIHdlIGFyZSBzZW5kaW5nIGBERUJVR2BcbiAqIGxvZ3MgdG8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24uXG4gKi9cbmNvbnN0IENvbnNvbGVNZXRob2QgPSB7XG4gIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxuICBbTG9nTGV2ZWwuVkVSQk9TRV06ICdsb2cnLFxuICBbTG9nTGV2ZWwuSU5GT106ICdpbmZvJyxcbiAgW0xvZ0xldmVsLldBUk5dOiAnd2FybicsXG4gIFtMb2dMZXZlbC5FUlJPUl06ICdlcnJvcidcbn07XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgbG9nIGhhbmRsZXIgd2lsbCBmb3J3YXJkIERFQlVHLCBWRVJCT1NFLCBJTkZPLCBXQVJOLCBhbmQgRVJST1JcbiAqIG1lc3NhZ2VzIG9uIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgY29uc29sZSBjb3VudGVycGFydHMgKGlmIHRoZSBsb2cgbWV0aG9kXG4gKiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbG9nIGxldmVsKVxuICovXG5jb25zdCBkZWZhdWx0TG9nSGFuZGxlcjogTG9nSGFuZGxlciA9IChpbnN0YW5jZSwgbG9nVHlwZSwgLi4uYXJncyk6IHZvaWQgPT4ge1xuICBpZiAobG9nVHlwZSA8IGluc3RhbmNlLmxvZ0xldmVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgY29uc3QgbWV0aG9kID0gQ29uc29sZU1ldGhvZFtsb2dUeXBlIGFzIGtleW9mIHR5cGVvZiBDb25zb2xlTWV0aG9kXTtcbiAgaWYgKG1ldGhvZCkge1xuICAgIGNvbnNvbGVbbWV0aG9kIGFzICdsb2cnIHwgJ2luZm8nIHwgJ3dhcm4nIHwgJ2Vycm9yJ10oXG4gICAgICBgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCxcbiAgICAgIC4uLmFyZ3NcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gbG9nIGEgbWVzc2FnZSB3aXRoIGFuIGludmFsaWQgbG9nVHlwZSAodmFsdWU6ICR7bG9nVHlwZX0pYFxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBMb2dnZXIge1xuICAvKipcbiAgICogR2l2ZXMgeW91IGFuIGluc3RhbmNlIG9mIGEgTG9nZ2VyIHRvIGNhcHR1cmUgbWVzc2FnZXMgYWNjb3JkaW5nIHRvXG4gICAqIEZpcmViYXNlJ3MgbG9nZ2luZyBzY2hlbWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRoYXQgdGhlIGxvZ3Mgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYW1lOiBzdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDYXB0dXJlIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBsYXRlciB1c2VcbiAgICAgKi9cbiAgICBpbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbG9nIGxldmVsIG9mIHRoZSBnaXZlbiBMb2dnZXIgaW5zdGFuY2UuXG4gICAqL1xuICBwcml2YXRlIF9sb2dMZXZlbCA9IGRlZmF1bHRMb2dMZXZlbDtcblxuICBnZXQgbG9nTGV2ZWwoKTogTG9nTGV2ZWwge1xuICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcbiAgfVxuXG4gIHNldCBsb2dMZXZlbCh2YWw6IExvZ0xldmVsKSB7XG4gICAgaWYgKCEodmFsIGluIExvZ0xldmVsKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XG4gICAgfVxuICAgIHRoaXMuX2xvZ0xldmVsID0gdmFsO1xuICB9XG5cbiAgLy8gV29ya2Fyb3VuZCBmb3Igc2V0dGVyL2dldHRlciBoYXZpbmcgdG8gYmUgdGhlIHNhbWUgdHlwZS5cbiAgc2V0TG9nTGV2ZWwodmFsOiBMb2dMZXZlbCB8IExvZ0xldmVsU3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5fbG9nTGV2ZWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IGxldmVsU3RyaW5nVG9FbnVtW3ZhbF0gOiB2YWw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1haW4gKGludGVybmFsKSBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICogQ2FuIGJlIHNldCB0byBhIG5ldyBmdW5jdGlvbiBpbiBpbnRlcm5hbCBwYWNrYWdlIGNvZGUgYnV0IG5vdCBieSB1c2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBfbG9nSGFuZGxlcjogTG9nSGFuZGxlciA9IGRlZmF1bHRMb2dIYW5kbGVyO1xuICBnZXQgbG9nSGFuZGxlcigpOiBMb2dIYW5kbGVyIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nSGFuZGxlcjtcbiAgfVxuICBzZXQgbG9nSGFuZGxlcih2YWw6IExvZ0hhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgYXNzaWduZWQgdG8gYGxvZ0hhbmRsZXJgIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9sb2dIYW5kbGVyID0gdmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvcHRpb25hbCwgYWRkaXRpb25hbCwgdXNlci1kZWZpbmVkIGxvZyBoYW5kbGVyIGZvciB0aGUgTG9nZ2VyIGluc3RhbmNlLlxuICAgKi9cbiAgcHJpdmF0ZSBfdXNlckxvZ0hhbmRsZXI6IExvZ0hhbmRsZXIgfCBudWxsID0gbnVsbDtcbiAgZ2V0IHVzZXJMb2dIYW5kbGVyKCk6IExvZ0hhbmRsZXIgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckxvZ0hhbmRsZXI7XG4gIH1cbiAgc2V0IHVzZXJMb2dIYW5kbGVyKHZhbDogTG9nSGFuZGxlciB8IG51bGwpIHtcbiAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBhbGwgYmFzZWQgb24gdGhlIGBjb25zb2xlYCBpbnRlcmZhY2VcbiAgICovXG5cbiAgZGVidWcoLi4uYXJnczogdW5rbm93bltdKTogdm9pZCB7XG4gICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuREVCVUcsIC4uLmFyZ3MpO1xuICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuREVCVUcsIC4uLmFyZ3MpO1xuICB9XG4gIGxvZyguLi5hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJlxuICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XG4gICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcbiAgfVxuICBpbmZvKC4uLmFyZ3M6IHVua25vd25bXSk6IHZvaWQge1xuICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xuICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XG4gIH1cbiAgd2FybiguLi5hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcbiAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xuICB9XG4gIGVycm9yKC4uLmFyZ3M6IHVua25vd25bXSk6IHZvaWQge1xuICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcbiAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWw6IExvZ0xldmVsU3RyaW5nIHwgTG9nTGV2ZWwpOiB2b2lkIHtcbiAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XG4gICAgaW5zdC5zZXRMb2dMZXZlbChsZXZlbCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VXNlckxvZ0hhbmRsZXIoXG4gIGxvZ0NhbGxiYWNrOiBMb2dDYWxsYmFjayB8IG51bGwsXG4gIG9wdGlvbnM/OiBMb2dPcHRpb25zXG4pOiB2b2lkIHtcbiAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICBsZXQgY3VzdG9tTG9nTGV2ZWw6IExvZ0xldmVsIHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5sZXZlbCkge1xuICAgICAgY3VzdG9tTG9nTGV2ZWwgPSBsZXZlbFN0cmluZ1RvRW51bVtvcHRpb25zLmxldmVsXTtcbiAgICB9XG4gICAgaWYgKGxvZ0NhbGxiYWNrID09PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZS51c2VyTG9nSGFuZGxlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gKFxuICAgICAgICBpbnN0YW5jZTogTG9nZ2VyLFxuICAgICAgICBsZXZlbDogTG9nTGV2ZWwsXG4gICAgICAgIC4uLmFyZ3M6IHVua25vd25bXVxuICAgICAgKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhcmdzXG4gICAgICAgICAgLm1hcChhcmcgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIoYXJnID0+IGFyZylcbiAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICBpZiAobGV2ZWwgPj0gKGN1c3RvbUxvZ0xldmVsID8/IGluc3RhbmNlLmxvZ0xldmVsKSkge1xuICAgICAgICAgIGxvZ0NhbGxiYWNrKHtcbiAgICAgICAgICAgIGxldmVsOiBMb2dMZXZlbFtsZXZlbF0udG9Mb3dlckNhc2UoKSBhcyBMb2dMZXZlbFN0cmluZyxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgdHlwZTogaW5zdGFuY2UubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuIiwiY29uc3QgaW5zdGFuY2VPZkFueSA9IChvYmplY3QsIGNvbnN0cnVjdG9ycykgPT4gY29uc3RydWN0b3JzLnNvbWUoKGMpID0+IG9iamVjdCBpbnN0YW5jZW9mIGMpO1xuXG5sZXQgaWRiUHJveHlhYmxlVHlwZXM7XG5sZXQgY3Vyc29yQWR2YW5jZU1ldGhvZHM7XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldElkYlByb3h5YWJsZVR5cGVzKCkge1xuICAgIHJldHVybiAoaWRiUHJveHlhYmxlVHlwZXMgfHxcbiAgICAgICAgKGlkYlByb3h5YWJsZVR5cGVzID0gW1xuICAgICAgICAgICAgSURCRGF0YWJhc2UsXG4gICAgICAgICAgICBJREJPYmplY3RTdG9yZSxcbiAgICAgICAgICAgIElEQkluZGV4LFxuICAgICAgICAgICAgSURCQ3Vyc29yLFxuICAgICAgICAgICAgSURCVHJhbnNhY3Rpb24sXG4gICAgICAgIF0pKTtcbn1cbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0byBwcmV2ZW50IGl0IHRocm93aW5nIHVwIGluIG5vZGUgZW52aXJvbm1lbnRzLlxuZnVuY3Rpb24gZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIChjdXJzb3JBZHZhbmNlTWV0aG9kcyB8fFxuICAgICAgICAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgPSBbXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmFkdmFuY2UsXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZVByaW1hcnlLZXksXG4gICAgICAgIF0pKTtcbn1cbmNvbnN0IGN1cnNvclJlcXVlc3RNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNhY3Rpb25Eb25lTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2Zvcm1DYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gcHJvbWlzaWZ5UmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdW5saXN0ZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHdyYXAocmVxdWVzdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgfSk7XG4gICAgcHJvbWlzZVxuICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgLy8gU2luY2UgY3Vyc29yaW5nIHJldXNlcyB0aGUgSURCUmVxdWVzdCAoKnNpZ2gqKSwgd2UgY2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbFxuICAgICAgICAvLyAoc2VlIHdyYXBGdW5jdGlvbikuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQkN1cnNvcikge1xuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdE1hcC5zZXQodmFsdWUsIHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhdGNoaW5nIHRvIGF2b2lkIFwiVW5jYXVnaHQgUHJvbWlzZSBleGNlcHRpb25zXCJcbiAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAvLyBUaGlzIG1hcHBpbmcgZXhpc3RzIGluIHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBidXQgZG9lc24ndCBkb2Vzbid0IGV4aXN0IGluIHRyYW5zZm9ybUNhY2hlLiBUaGlzXG4gICAgLy8gaXMgYmVjYXVzZSB3ZSBjcmVhdGUgbWFueSBwcm9taXNlcyBmcm9tIGEgc2luZ2xlIElEQlJlcXVlc3QuXG4gICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChwcm9taXNlLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih0eCkge1xuICAgIC8vIEVhcmx5IGJhaWwgaWYgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGEgZG9uZSBwcm9taXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIGlmICh0cmFuc2FjdGlvbkRvbmVNYXAuaGFzKHR4KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRvbmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHR4LmVycm9yIHx8IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0RXJyb3InLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XG4gICAgfSk7XG4gICAgLy8gQ2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICB0cmFuc2FjdGlvbkRvbmVNYXAuc2V0KHR4LCBkb25lKTtcbn1cbmxldCBpZGJQcm94eVRyYXBzID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdHJhbnNhY3Rpb24uZG9uZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnZG9uZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRG9uZU1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIFBvbHlmaWxsIGZvciBvYmplY3RTdG9yZU5hbWVzIGJlY2F1c2Ugb2YgRWRnZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnb2JqZWN0U3RvcmVOYW1lcycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Lm9iamVjdFN0b3JlTmFtZXMgfHwgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSB0eC5zdG9yZSByZXR1cm4gdGhlIG9ubHkgc3RvcmUgaW4gdGhlIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG1hbnkuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3N0b3JlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzFdXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogcmVjZWl2ZXIub2JqZWN0U3RvcmUocmVjZWl2ZXIub2JqZWN0U3RvcmVOYW1lc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZSB0cmFuc2Zvcm0gd2hhdGV2ZXIgd2UgZ2V0IGJhY2suXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldFtwcm9wXSk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbiAmJlxuICAgICAgICAgICAgKHByb3AgPT09ICdkb25lJyB8fCBwcm9wID09PSAnc3RvcmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3AgaW4gdGFyZ2V0O1xuICAgIH0sXG59O1xuZnVuY3Rpb24gcmVwbGFjZVRyYXBzKGNhbGxiYWNrKSB7XG4gICAgaWRiUHJveHlUcmFwcyA9IGNhbGxiYWNrKGlkYlByb3h5VHJhcHMpO1xufVxuZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBEdWUgdG8gZXhwZWN0ZWQgb2JqZWN0IGVxdWFsaXR5ICh3aGljaCBpcyBlbmZvcmNlZCBieSB0aGUgY2FjaGluZyBpbiBgd3JhcGApLCB3ZVxuICAgIC8vIG9ubHkgY3JlYXRlIG9uZSBuZXcgZnVuYyBwZXIgZnVuYy5cbiAgICAvLyBFZGdlIGRvZXNuJ3Qgc3VwcG9ydCBvYmplY3RTdG9yZU5hbWVzIChib29vKSwgc28gd2UgcG9seWZpbGwgaXQgaGVyZS5cbiAgICBpZiAoZnVuYyA9PT0gSURCRGF0YWJhc2UucHJvdG90eXBlLnRyYW5zYWN0aW9uICYmXG4gICAgICAgICEoJ29iamVjdFN0b3JlTmFtZXMnIGluIElEQlRyYW5zYWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZU5hbWVzLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGZ1bmMuY2FsbCh1bndyYXAodGhpcyksIHN0b3JlTmFtZXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwLnNldCh0eCwgc3RvcmVOYW1lcy5zb3J0ID8gc3RvcmVOYW1lcy5zb3J0KCkgOiBbc3RvcmVOYW1lc10pO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAodHgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDdXJzb3IgbWV0aG9kcyBhcmUgc3BlY2lhbCwgYXMgdGhlIGJlaGF2aW91ciBpcyBhIGxpdHRsZSBtb3JlIGRpZmZlcmVudCB0byBzdGFuZGFyZCBJREIuIEluXG4gICAgLy8gSURCLCB5b3UgYWR2YW5jZSB0aGUgY3Vyc29yIGFuZCB3YWl0IGZvciBhIG5ldyAnc3VjY2Vzcycgb24gdGhlIElEQlJlcXVlc3QgdGhhdCBnYXZlIHlvdSB0aGVcbiAgICAvLyBjdXJzb3IuIEl0J3Mga2luZGEgbGlrZSBhIHByb21pc2UgdGhhdCBjYW4gcmVzb2x2ZSB3aXRoIG1hbnkgdmFsdWVzLiBUaGF0IGRvZXNuJ3QgbWFrZSBzZW5zZVxuICAgIC8vIHdpdGggcmVhbCBwcm9taXNlcywgc28gZWFjaCBhZHZhbmNlIG1ldGhvZHMgcmV0dXJucyBhIG5ldyBwcm9taXNlIGZvciB0aGUgY3Vyc29yIG9iamVjdCwgb3JcbiAgICAvLyB1bmRlZmluZWQgaWYgdGhlIGVuZCBvZiB0aGUgY3Vyc29yIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgaWYgKGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkuaW5jbHVkZXMoZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICAgICAgZnVuYy5hcHBseSh1bndyYXAodGhpcyksIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAoY3Vyc29yUmVxdWVzdE1hcC5nZXQodGhpcykpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICByZXR1cm4gd3JhcChmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncykpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHdyYXBGdW5jdGlvbih2YWx1ZSk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHJldHVybiwgaXQganVzdCBjcmVhdGVzIGEgJ2RvbmUnIHByb21pc2UgZm9yIHRoZSB0cmFuc2FjdGlvbixcbiAgICAvLyB3aGljaCBpcyBsYXRlciByZXR1cm5lZCBmb3IgdHJhbnNhY3Rpb24uZG9uZSAoc2VlIGlkYk9iamVjdEhhbmRsZXIpLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uKVxuICAgICAgICBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odmFsdWUpO1xuICAgIGlmIChpbnN0YW5jZU9mQW55KHZhbHVlLCBnZXRJZGJQcm94eWFibGVUeXBlcygpKSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh2YWx1ZSwgaWRiUHJveHlUcmFwcyk7XG4gICAgLy8gUmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2sgaWYgd2UncmUgbm90IGdvaW5nIHRvIHRyYW5zZm9ybSBpdC5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB3cmFwKHZhbHVlKSB7XG4gICAgLy8gV2Ugc29tZXRpbWVzIGdlbmVyYXRlIG11bHRpcGxlIHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdCAoZWcgd2hlbiBjdXJzb3JpbmcpLCBiZWNhdXNlXG4gICAgLy8gSURCIGlzIHdlaXJkIGFuZCBhIHNpbmdsZSBJREJSZXF1ZXN0IGNhbiB5aWVsZCBtYW55IHJlc3BvbnNlcywgc28gdGhlc2UgY2FuJ3QgYmUgY2FjaGVkLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlJlcXVlc3QpXG4gICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KHZhbHVlKTtcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHRyYW5zZm9ybWVkIHRoaXMgdmFsdWUgYmVmb3JlLCByZXVzZSB0aGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gICAgLy8gVGhpcyBpcyBmYXN0ZXIsIGJ1dCBpdCBhbHNvIHByb3ZpZGVzIG9iamVjdCBlcXVhbGl0eS5cbiAgICBpZiAodHJhbnNmb3JtQ2FjaGUuaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKTtcbiAgICAvLyBOb3QgYWxsIHR5cGVzIGFyZSB0cmFuc2Zvcm1lZC5cbiAgICAvLyBUaGVzZSBtYXkgYmUgcHJpbWl0aXZlIHR5cGVzLCBzbyB0aGV5IGNhbid0IGJlIFdlYWtNYXAga2V5cy5cbiAgICBpZiAobmV3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRyYW5zZm9ybUNhY2hlLnNldCh2YWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KG5ld1ZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmNvbnN0IHVud3JhcCA9ICh2YWx1ZSkgPT4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG5cbmV4cG9ydCB7IHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBhcyBhLCBpbnN0YW5jZU9mQW55IGFzIGksIHJlcGxhY2VUcmFwcyBhcyByLCB1bndyYXAgYXMgdSwgd3JhcCBhcyB3IH07XG4iLCJpbXBvcnQgeyB3IGFzIHdyYXAsIHIgYXMgcmVwbGFjZVRyYXBzIH0gZnJvbSAnLi93cmFwLWlkYi12YWx1ZS5qcyc7XG5leHBvcnQgeyB1IGFzIHVud3JhcCwgdyBhcyB3cmFwIH0gZnJvbSAnLi93cmFwLWlkYi12YWx1ZS5qcyc7XG5cbi8qKlxuICogT3BlbiBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICogQHBhcmFtIHZlcnNpb24gU2NoZW1hIHZlcnNpb24uXG4gKiBAcGFyYW0gY2FsbGJhY2tzIEFkZGl0aW9uYWwgY2FsbGJhY2tzLlxuICovXG5mdW5jdGlvbiBvcGVuREIobmFtZSwgdmVyc2lvbiwgeyBibG9ja2VkLCB1cGdyYWRlLCBibG9ja2luZywgdGVybWluYXRlZCB9ID0ge30pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4obmFtZSwgdmVyc2lvbik7XG4gICAgY29uc3Qgb3BlblByb21pc2UgPSB3cmFwKHJlcXVlc3QpO1xuICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigndXBncmFkZW5lZWRlZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdXBncmFkZSh3cmFwKHJlcXVlc3QucmVzdWx0KSwgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQubmV3VmVyc2lvbiwgd3JhcChyZXF1ZXN0LnRyYW5zYWN0aW9uKSwgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJsb2NrZWQpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKGV2ZW50KSA9PiBibG9ja2VkKFxuICAgICAgICAvLyBDYXN0aW5nIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNDA1XG4gICAgICAgIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIGV2ZW50KSk7XG4gICAgfVxuICAgIG9wZW5Qcm9taXNlXG4gICAgICAgIC50aGVuKChkYikgPT4ge1xuICAgICAgICBpZiAodGVybWluYXRlZClcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4gdGVybWluYXRlZCgpKTtcbiAgICAgICAgaWYgKGJsb2NraW5nKSB7XG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCd2ZXJzaW9uY2hhbmdlJywgKGV2ZW50KSA9PiBibG9ja2luZyhldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCBldmVudCkpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgcmV0dXJuIG9wZW5Qcm9taXNlO1xufVxuLyoqXG4gKiBEZWxldGUgYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlREIobmFtZSwgeyBibG9ja2VkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSk7XG4gICAgaWYgKGJsb2NrZWQpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKGV2ZW50KSA9PiBibG9ja2VkKFxuICAgICAgICAvLyBDYXN0aW5nIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNDA1XG4gICAgICAgIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50KSk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwKHJlcXVlc3QpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbn1cblxuY29uc3QgcmVhZE1ldGhvZHMgPSBbJ2dldCcsICdnZXRLZXknLCAnZ2V0QWxsJywgJ2dldEFsbEtleXMnLCAnY291bnQnXTtcbmNvbnN0IHdyaXRlTWV0aG9kcyA9IFsncHV0JywgJ2FkZCcsICdkZWxldGUnLCAnY2xlYXInXTtcbmNvbnN0IGNhY2hlZE1ldGhvZHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB7XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSURCRGF0YWJhc2UgJiZcbiAgICAgICAgIShwcm9wIGluIHRhcmdldCkgJiZcbiAgICAgICAgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYWNoZWRNZXRob2RzLmdldChwcm9wKSlcbiAgICAgICAgcmV0dXJuIGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApO1xuICAgIGNvbnN0IHRhcmdldEZ1bmNOYW1lID0gcHJvcC5yZXBsYWNlKC9Gcm9tSW5kZXgkLywgJycpO1xuICAgIGNvbnN0IHVzZUluZGV4ID0gcHJvcCAhPT0gdGFyZ2V0RnVuY05hbWU7XG4gICAgY29uc3QgaXNXcml0ZSA9IHdyaXRlTWV0aG9kcy5pbmNsdWRlcyh0YXJnZXRGdW5jTmFtZSk7XG4gICAgaWYgKFxuICAgIC8vIEJhaWwgaWYgdGhlIHRhcmdldCBkb2Vzbid0IGV4aXN0IG9uIHRoZSB0YXJnZXQuIEVnLCBnZXRBbGwgaXNuJ3QgaW4gRWRnZS5cbiAgICAhKHRhcmdldEZ1bmNOYW1lIGluICh1c2VJbmRleCA/IElEQkluZGV4IDogSURCT2JqZWN0U3RvcmUpLnByb3RvdHlwZSkgfHxcbiAgICAgICAgIShpc1dyaXRlIHx8IHJlYWRNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyBmdW5jdGlvbiAoc3RvcmVOYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6IHVuZGVmaW5lZCBnemlwcHMgYmV0dGVyLCBidXQgZmFpbHMgaW4gRWRnZSA6KFxuICAgICAgICBjb25zdCB0eCA9IHRoaXMudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCBpc1dyaXRlID8gJ3JlYWR3cml0ZScgOiAncmVhZG9ubHknKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHR4LnN0b3JlO1xuICAgICAgICBpZiAodXNlSW5kZXgpXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaW5kZXgoYXJncy5zaGlmdCgpKTtcbiAgICAgICAgLy8gTXVzdCByZWplY3QgaWYgb3AgcmVqZWN0cy5cbiAgICAgICAgLy8gSWYgaXQncyBhIHdyaXRlIG9wZXJhdGlvbiwgbXVzdCByZWplY3QgaWYgdHguZG9uZSByZWplY3RzLlxuICAgICAgICAvLyBNdXN0IHJlamVjdCB3aXRoIG9wIHJlamVjdGlvbiBmaXJzdC5cbiAgICAgICAgLy8gTXVzdCByZXNvbHZlIHdpdGggb3AgdmFsdWUuXG4gICAgICAgIC8vIE11c3QgaGFuZGxlIGJvdGggcHJvbWlzZXMgKG5vIHVuaGFuZGxlZCByZWplY3Rpb25zKVxuICAgICAgICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRhcmdldFt0YXJnZXRGdW5jTmFtZV0oLi4uYXJncyksXG4gICAgICAgICAgICBpc1dyaXRlICYmIHR4LmRvbmUsXG4gICAgICAgIF0pKVswXTtcbiAgICB9O1xuICAgIGNhY2hlZE1ldGhvZHMuc2V0KHByb3AsIG1ldGhvZCk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbnJlcGxhY2VUcmFwcygob2xkVHJhcHMpID0+ICh7XG4gICAgLi4ub2xkVHJhcHMsXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4gZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpLFxuICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gISFnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5oYXModGFyZ2V0LCBwcm9wKSxcbn0pKTtcblxuZXhwb3J0IHsgZGVsZXRlREIsIG9wZW5EQiB9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgQ29tcG9uZW50Q29udGFpbmVyLFxuICBDb21wb25lbnRUeXBlLFxuICBQcm92aWRlcixcbiAgTmFtZVxufSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IFBsYXRmb3JtTG9nZ2VyU2VydmljZSwgVmVyc2lvblNlcnZpY2UgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwgaW1wbGVtZW50cyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNvbnRhaW5lcjogQ29tcG9uZW50Q29udGFpbmVyKSB7fVxuICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cbiAgLy8gYXV0aCB0b2tlbiByZWZyZXNoLCBhbmQgaW5zdGFsbGF0aW9ucyB3aWxsIHNlbmQgdGhpcyBzdHJpbmcuXG4gIGdldFBsYXRmb3JtSW5mb1N0cmluZygpOiBzdHJpbmcge1xuICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xuICAgIC8vIExvb3AgdGhyb3VnaCBwcm92aWRlcnMgYW5kIGdldCBsaWJyYXJ5L3ZlcnNpb24gcGFpcnMgZnJvbSBhbnkgdGhhdCBhcmVcbiAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXG4gICAgcmV0dXJuIHByb3ZpZGVyc1xuICAgICAgLm1hcChwcm92aWRlciA9PiB7XG4gICAgICAgIGlmIChpc1ZlcnNpb25TZXJ2aWNlUHJvdmlkZXIocHJvdmlkZXIpKSB7XG4gICAgICAgICAgY29uc3Qgc2VydmljZSA9IHByb3ZpZGVyLmdldEltbWVkaWF0ZSgpIGFzIFZlcnNpb25TZXJ2aWNlO1xuICAgICAgICAgIHJldHVybiBgJHtzZXJ2aWNlLmxpYnJhcnl9LyR7c2VydmljZS52ZXJzaW9ufWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKGxvZ1N0cmluZyA9PiBsb2dTdHJpbmcpXG4gICAgICAuam9pbignICcpO1xuICB9XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXIgY2hlY2sgaWYgdGhpcyBwcm92aWRlciBwcm92aWRlcyBhIFZlcnNpb25TZXJ2aWNlXG4gKlxuICogTk9URTogVXNpbmcgUHJvdmlkZXI8J2FwcC12ZXJzaW9uJz4gaXMgYSBoYWNrIHRvIGluZGljYXRlIHRoYXQgdGhlIHByb3ZpZGVyXG4gKiBwcm92aWRlcyBWZXJzaW9uU2VydmljZS4gVGhlIHByb3ZpZGVyIGlzIG5vdCBuZWNlc3NhcmlseSBhICdhcHAtdmVyc2lvbidcbiAqIHByb3ZpZGVyLlxuICovXG5mdW5jdGlvbiBpc1ZlcnNpb25TZXJ2aWNlUHJvdmlkZXIocHJvdmlkZXI6IFByb3ZpZGVyPE5hbWU+KTogYm9vbGVhbiB7XG4gIGNvbnN0IGNvbXBvbmVudCA9IHByb3ZpZGVyLmdldENvbXBvbmVudCgpO1xuICByZXR1cm4gY29tcG9uZW50Py50eXBlID09PSBDb21wb25lbnRUeXBlLlZFUlNJT047XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcblxuZXhwb3J0IGNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9hcHAnKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IG5hbWUgYXMgYXBwTmFtZSB9IGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGFwcENvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi9hcHAtY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGFuYWx5dGljc0NvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9hbmFseXRpY3MtY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGFuYWx5dGljc05hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9hbmFseXRpY3MvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgYXBwQ2hlY2tDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvYXBwLWNoZWNrLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBhcHBDaGVja05hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9hcHAtY2hlY2svcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgYXV0aE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9hdXRoL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGF1dGhDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvYXV0aC1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgZGF0YWJhc2VOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvZGF0YWJhc2UvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgZGF0YWJhc2VDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvZGF0YWJhc2UtY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGZ1bmN0aW9uc05hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9mdW5jdGlvbnMvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgZnVuY3Rpb25zQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2Z1bmN0aW9ucy1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgaW5zdGFsbGF0aW9uc05hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9pbnN0YWxsYXRpb25zL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGluc3RhbGxhdGlvbnNDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvaW5zdGFsbGF0aW9ucy1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgbWVzc2FnaW5nTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL21lc3NhZ2luZy9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBtZXNzYWdpbmdDb21wYXROYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvbWVzc2FnaW5nLWNvbXBhdC9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBwZXJmb3JtYW5jZU5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9wZXJmb3JtYW5jZS9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBwZXJmb3JtYW5jZUNvbXBhdE5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9wZXJmb3JtYW5jZS1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgcmVtb3RlQ29uZmlnTmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL3JlbW90ZS1jb25maWcvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgcmVtb3RlQ29uZmlnQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL3JlbW90ZS1jb25maWctY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIHN0b3JhZ2VOYW1lIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZXMvc3RvcmFnZS9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgbmFtZSBhcyBzdG9yYWdlQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL3N0b3JhZ2UtY29tcGF0L3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBuYW1lIGFzIGZpcmVzdG9yZU5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9maXJlc3RvcmUvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgZmlyZXN0b3JlQ29tcGF0TmFtZSB9IGZyb20gJy4uLy4uLy4uL3BhY2thZ2VzL2ZpcmVzdG9yZS1jb21wYXQvcGFja2FnZS5qc29uJztcbmltcG9ydCB7IG5hbWUgYXMgcGFja2FnZU5hbWUgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlcy9maXJlYmFzZS9wYWNrYWdlLmpzb24nO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGFwcCBuYW1lXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcblxuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX0xPR19TVFJJTkcgPSB7XG4gIFthcHBOYW1lXTogJ2ZpcmUtY29yZScsXG4gIFthcHBDb21wYXROYW1lXTogJ2ZpcmUtY29yZS1jb21wYXQnLFxuICBbYW5hbHl0aWNzTmFtZV06ICdmaXJlLWFuYWx5dGljcycsXG4gIFthbmFseXRpY3NDb21wYXROYW1lXTogJ2ZpcmUtYW5hbHl0aWNzLWNvbXBhdCcsXG4gIFthcHBDaGVja05hbWVdOiAnZmlyZS1hcHAtY2hlY2snLFxuICBbYXBwQ2hlY2tDb21wYXROYW1lXTogJ2ZpcmUtYXBwLWNoZWNrLWNvbXBhdCcsXG4gIFthdXRoTmFtZV06ICdmaXJlLWF1dGgnLFxuICBbYXV0aENvbXBhdE5hbWVdOiAnZmlyZS1hdXRoLWNvbXBhdCcsXG4gIFtkYXRhYmFzZU5hbWVdOiAnZmlyZS1ydGRiJyxcbiAgW2RhdGFiYXNlQ29tcGF0TmFtZV06ICdmaXJlLXJ0ZGItY29tcGF0JyxcbiAgW2Z1bmN0aW9uc05hbWVdOiAnZmlyZS1mbicsXG4gIFtmdW5jdGlvbnNDb21wYXROYW1lXTogJ2ZpcmUtZm4tY29tcGF0JyxcbiAgW2luc3RhbGxhdGlvbnNOYW1lXTogJ2ZpcmUtaWlkJyxcbiAgW2luc3RhbGxhdGlvbnNDb21wYXROYW1lXTogJ2ZpcmUtaWlkLWNvbXBhdCcsXG4gIFttZXNzYWdpbmdOYW1lXTogJ2ZpcmUtZmNtJyxcbiAgW21lc3NhZ2luZ0NvbXBhdE5hbWVdOiAnZmlyZS1mY20tY29tcGF0JyxcbiAgW3BlcmZvcm1hbmNlTmFtZV06ICdmaXJlLXBlcmYnLFxuICBbcGVyZm9ybWFuY2VDb21wYXROYW1lXTogJ2ZpcmUtcGVyZi1jb21wYXQnLFxuICBbcmVtb3RlQ29uZmlnTmFtZV06ICdmaXJlLXJjJyxcbiAgW3JlbW90ZUNvbmZpZ0NvbXBhdE5hbWVdOiAnZmlyZS1yYy1jb21wYXQnLFxuICBbc3RvcmFnZU5hbWVdOiAnZmlyZS1nY3MnLFxuICBbc3RvcmFnZUNvbXBhdE5hbWVdOiAnZmlyZS1nY3MtY29tcGF0JyxcbiAgW2ZpcmVzdG9yZU5hbWVdOiAnZmlyZS1mc3QnLFxuICBbZmlyZXN0b3JlQ29tcGF0TmFtZV06ICdmaXJlLWZzdC1jb21wYXQnLFxuICAnZmlyZS1qcyc6ICdmaXJlLWpzJywgLy8gUGxhdGZvcm0gaWRlbnRpZmllciBmb3IgSlMgU0RLLlxuICBbcGFja2FnZU5hbWVdOiAnZmlyZS1qcy1hbGwnXG59IGFzIGNvbnN0O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmlyZWJhc2VBcHAgfSBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIFByb3ZpZGVyLCBOYW1lIH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBERUZBVUxUX0VOVFJZX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBGaXJlYmFzZUFwcEltcGwgfSBmcm9tICcuL2ZpcmViYXNlQXBwJztcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IF9hcHBzID0gbmV3IE1hcDxzdHJpbmcsIEZpcmViYXNlQXBwPigpO1xuXG4vKipcbiAqIFJlZ2lzdGVyZWQgY29tcG9uZW50cy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBjb25zdCBfY29tcG9uZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBDb21wb25lbnQ8YW55Pj4oKTtcblxuLyoqXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCBiZWluZyBhZGRlZCB0byB0aGlzIGFwcCdzIGNvbnRhaW5lclxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FkZENvbXBvbmVudDxUIGV4dGVuZHMgTmFtZT4oXG4gIGFwcDogRmlyZWJhc2VBcHAsXG4gIGNvbXBvbmVudDogQ29tcG9uZW50PFQ+XG4pOiB2b2lkIHtcbiAgdHJ5IHtcbiAgICAoYXBwIGFzIEZpcmViYXNlQXBwSW1wbCkuY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmYWlsZWQgdG8gcmVnaXN0ZXIgd2l0aCBGaXJlYmFzZUFwcCAke2FwcC5uYW1lfWAsXG4gICAgICBlXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChcbiAgYXBwOiBGaXJlYmFzZUFwcCxcbiAgY29tcG9uZW50OiBDb21wb25lbnRcbik6IHZvaWQge1xuICAoYXBwIGFzIEZpcmViYXNlQXBwSW1wbCkuY29udGFpbmVyLmFkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGNvbXBvbmVudCk7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IHRvIHJlZ2lzdGVyXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5XG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcmVnaXN0ZXJDb21wb25lbnQ8VCBleHRlbmRzIE5hbWU+KFxuICBjb21wb25lbnQ6IENvbXBvbmVudDxUPlxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQubmFtZTtcbiAgaWYgKF9jb21wb25lbnRzLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBUaGVyZSB3ZXJlIG11bHRpcGxlIGF0dGVtcHRzIHRvIHJlZ2lzdGVyIGNvbXBvbmVudCAke2NvbXBvbmVudE5hbWV9LmBcbiAgICApO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX2NvbXBvbmVudHMuc2V0KGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudCk7XG5cbiAgLy8gYWRkIHRoZSBjb21wb25lbnQgdG8gZXhpc3RpbmcgYXBwIGluc3RhbmNlc1xuICBmb3IgKGNvbnN0IGFwcCBvZiBfYXBwcy52YWx1ZXMoKSkge1xuICAgIF9hZGRDb21wb25lbnQoYXBwIGFzIEZpcmViYXNlQXBwSW1wbCwgY29tcG9uZW50KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2VBcHAgaW5zdGFuY2VcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXG4gKlxuICogQHJldHVybnMgdGhlIHByb3ZpZGVyIGZvciB0aGUgc2VydmljZSB3aXRoIHRoZSBtYXRjaGluZyBuYW1lXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UHJvdmlkZXI8VCBleHRlbmRzIE5hbWU+KFxuICBhcHA6IEZpcmViYXNlQXBwLFxuICBuYW1lOiBUXG4pOiBQcm92aWRlcjxUPiB7XG4gIGNvbnN0IGhlYXJ0YmVhdENvbnRyb2xsZXIgPSAoYXBwIGFzIEZpcmViYXNlQXBwSW1wbCkuY29udGFpbmVyXG4gICAgLmdldFByb3ZpZGVyKCdoZWFydGJlYXQnKVxuICAgIC5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcbiAgaWYgKGhlYXJ0YmVhdENvbnRyb2xsZXIpIHtcbiAgICB2b2lkIGhlYXJ0YmVhdENvbnRyb2xsZXIudHJpZ2dlckhlYXJ0YmVhdCgpO1xuICB9XG4gIHJldHVybiAoYXBwIGFzIEZpcmViYXNlQXBwSW1wbCkuY29udGFpbmVyLmdldFByb3ZpZGVyKG5hbWUpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2VBcHAgaW5zdGFuY2VcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXG4gKiBAcGFyYW0gaW5zdGFuY2VJZGVudGlmaWVyIC0gc2VydmljZSBpbnN0YW5jZSBpZGVudGlmaWVyIGluIGNhc2UgdGhlIHNlcnZpY2Ugc3VwcG9ydHMgbXVsdGlwbGUgaW5zdGFuY2VzXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcmVtb3ZlU2VydmljZUluc3RhbmNlPFQgZXh0ZW5kcyBOYW1lPihcbiAgYXBwOiBGaXJlYmFzZUFwcCxcbiAgbmFtZTogVCxcbiAgaW5zdGFuY2VJZGVudGlmaWVyOiBzdHJpbmcgPSBERUZBVUxUX0VOVFJZX05BTUVcbik6IHZvaWQge1xuICBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKS5jbGVhckluc3RhbmNlKGluc3RhbmNlSWRlbnRpZmllcik7XG59XG5cbi8qKlxuICogVGVzdCBvbmx5XG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2xlYXJDb21wb25lbnRzKCk6IHZvaWQge1xuICBfY29tcG9uZW50cy5jbGVhcigpO1xufVxuXG4vKipcbiAqIEV4cG9ydGVkIGluIG9yZGVyIHRvIGJlIHVzZWQgaW4gYXBwLWNvbXBhdCBwYWNrYWdlXG4gKi9cbmV4cG9ydCB7IERFRkFVTFRfRU5UUllfTkFNRSBhcyBfREVGQVVMVF9FTlRSWV9OQU1FIH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIEVycm9yTWFwIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5leHBvcnQgY29uc3QgZW51bSBBcHBFcnJvciB7XG4gIE5PX0FQUCA9ICduby1hcHAnLFxuICBCQURfQVBQX05BTUUgPSAnYmFkLWFwcC1uYW1lJyxcbiAgRFVQTElDQVRFX0FQUCA9ICdkdXBsaWNhdGUtYXBwJyxcbiAgQVBQX0RFTEVURUQgPSAnYXBwLWRlbGV0ZWQnLFxuICBOT19PUFRJT05TID0gJ25vLW9wdGlvbnMnLFxuICBJTlZBTElEX0FQUF9BUkdVTUVOVCA9ICdpbnZhbGlkLWFwcC1hcmd1bWVudCcsXG4gIElOVkFMSURfTE9HX0FSR1VNRU5UID0gJ2ludmFsaWQtbG9nLWFyZ3VtZW50JyxcbiAgSURCX09QRU4gPSAnaWRiLW9wZW4nLFxuICBJREJfR0VUID0gJ2lkYi1nZXQnLFxuICBJREJfV1JJVEUgPSAnaWRiLXNldCcsXG4gIElEQl9ERUxFVEUgPSAnaWRiLWRlbGV0ZSdcbn1cblxuY29uc3QgRVJST1JTOiBFcnJvck1hcDxBcHBFcnJvcj4gPSB7XG4gIFtBcHBFcnJvci5OT19BUFBdOlxuICAgIFwiTm8gRmlyZWJhc2UgQXBwICd7JGFwcE5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xuICAgICdjYWxsIGluaXRpYWxpemVBcHAoKSBmaXJzdCcsXG4gIFtBcHBFcnJvci5CQURfQVBQX05BTUVdOiBcIklsbGVnYWwgQXBwIG5hbWU6ICd7JGFwcE5hbWV9XCIsXG4gIFtBcHBFcnJvci5EVVBMSUNBVEVfQVBQXTpcbiAgICBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcbiAgW0FwcEVycm9yLkFQUF9ERUxFVEVEXTogXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skYXBwTmFtZX0nIGFscmVhZHkgZGVsZXRlZFwiLFxuICBbQXBwRXJyb3IuTk9fT1BUSU9OU106XG4gICAgJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcbiAgW0FwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5UXTpcbiAgICAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xuICAgICdGaXJlYmFzZSBBcHAgaW5zdGFuY2UuJyxcbiAgW0FwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UXTpcbiAgICAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxuICBbQXBwRXJyb3IuSURCX09QRU5dOlxuICAgICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gIFtBcHBFcnJvci5JREJfR0VUXTpcbiAgICAnRXJyb3IgdGhyb3duIHdoZW4gcmVhZGluZyBmcm9tIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gIFtBcHBFcnJvci5JREJfV1JJVEVdOlxuICAgICdFcnJvciB0aHJvd24gd2hlbiB3cml0aW5nIHRvIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gIFtBcHBFcnJvci5JREJfREVMRVRFXTpcbiAgICAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nXG59O1xuXG5pbnRlcmZhY2UgRXJyb3JQYXJhbXMge1xuICBbQXBwRXJyb3IuTk9fQVBQXTogeyBhcHBOYW1lOiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLkJBRF9BUFBfTkFNRV06IHsgYXBwTmFtZTogc3RyaW5nIH07XG4gIFtBcHBFcnJvci5EVVBMSUNBVEVfQVBQXTogeyBhcHBOYW1lOiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLkFQUF9ERUxFVEVEXTogeyBhcHBOYW1lOiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5UXTogeyBhcHBOYW1lOiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLklEQl9PUEVOXTogeyBvcmlnaW5hbEVycm9yTWVzc2FnZT86IHN0cmluZyB9O1xuICBbQXBwRXJyb3IuSURCX0dFVF06IHsgb3JpZ2luYWxFcnJvck1lc3NhZ2U/OiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLklEQl9XUklURV06IHsgb3JpZ2luYWxFcnJvck1lc3NhZ2U/OiBzdHJpbmcgfTtcbiAgW0FwcEVycm9yLklEQl9ERUxFVEVdOiB7IG9yaWdpbmFsRXJyb3JNZXNzYWdlPzogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBjb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeTxBcHBFcnJvciwgRXJyb3JQYXJhbXM+KFxuICAnYXBwJyxcbiAgJ0ZpcmViYXNlJyxcbiAgRVJST1JTXG4pO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRmlyZWJhc2VBcHAsXG4gIEZpcmViYXNlT3B0aW9ucyxcbiAgRmlyZWJhc2VBcHBTZXR0aW5nc1xufSBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5pbXBvcnQge1xuICBDb21wb25lbnRDb250YWluZXIsXG4gIENvbXBvbmVudCxcbiAgQ29tcG9uZW50VHlwZVxufSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IEVSUk9SX0ZBQ1RPUlksIEFwcEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuXG5leHBvcnQgY2xhc3MgRmlyZWJhc2VBcHBJbXBsIGltcGxlbWVudHMgRmlyZWJhc2VBcHAge1xuICBwcml2YXRlIHJlYWRvbmx5IF9vcHRpb25zOiBGaXJlYmFzZU9wdGlvbnM7XG4gIHByaXZhdGUgcmVhZG9ubHkgX25hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIE9yaWdpbmFsIGNvbmZpZyB2YWx1ZXMgcGFzc2VkIGluIGFzIGEgY29uc3RydWN0b3IgcGFyYW1ldGVyLlxuICAgKiBJdCBpcyBvbmx5IHVzZWQgdG8gY29tcGFyZSB3aXRoIGFub3RoZXIgY29uZmlnIG9iamVjdCB0byBzdXBwb3J0IGlkZW1wb3RlbnQgaW5pdGlhbGl6ZUFwcCgpLlxuICAgKlxuICAgKiBVcGRhdGluZyBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgb24gdGhlIEFwcCBpbnN0YW5jZSB3aWxsIG5vdCBjaGFuZ2UgaXRzIHZhbHVlIGluIF9jb25maWcuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF9jb25maWc6IFJlcXVpcmVkPEZpcmViYXNlQXBwU2V0dGluZ3M+O1xuICBwcml2YXRlIF9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgX2lzRGVsZXRlZCA9IGZhbHNlO1xuICBwcml2YXRlIHJlYWRvbmx5IF9jb250YWluZXI6IENvbXBvbmVudENvbnRhaW5lcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBvcHRpb25zOiBGaXJlYmFzZU9wdGlvbnMsXG4gICAgY29uZmlnOiBSZXF1aXJlZDxGaXJlYmFzZUFwcFNldHRpbmdzPixcbiAgICBjb250YWluZXI6IENvbXBvbmVudENvbnRhaW5lclxuICApIHtcbiAgICB0aGlzLl9vcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgdGhpcy5fY29uZmlnID0geyAuLi5jb25maWcgfTtcbiAgICB0aGlzLl9uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cbiAgICAgIGNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29udGFpbmVyLmFkZENvbXBvbmVudChcbiAgICAgIG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIENvbXBvbmVudFR5cGUuUFVCTElDKVxuICAgICk7XG4gIH1cblxuICBnZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkO1xuICB9XG5cbiAgc2V0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCh2YWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gdmFsO1xuICB9XG5cbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpOiBGaXJlYmFzZU9wdGlvbnMge1xuICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIGdldCBjb25maWcoKTogUmVxdWlyZWQ8RmlyZWJhc2VBcHBTZXR0aW5ncz4ge1xuICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xuICB9XG5cbiAgZ2V0IGNvbnRhaW5lcigpOiBDb21wb25lbnRDb250YWluZXIge1xuICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gIH1cblxuICBnZXQgaXNEZWxldGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pc0RlbGV0ZWQ7XG4gIH1cblxuICBzZXQgaXNEZWxldGVkKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuX2lzRGVsZXRlZCA9IHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxuICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cbiAgICovXG4gIHByaXZhdGUgY2hlY2tEZXN0cm95ZWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XG4gICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShBcHBFcnJvci5BUFBfREVMRVRFRCwgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRmlyZWJhc2VBcHAsXG4gIEZpcmViYXNlT3B0aW9ucyxcbiAgRmlyZWJhc2VBcHBTZXR0aW5nc1xufSBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5pbXBvcnQgeyBERUZBVUxUX0VOVFJZX05BTUUsIFBMQVRGT1JNX0xPR19TVFJJTkcgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFUlJPUl9GQUNUT1JZLCBBcHBFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7XG4gIENvbXBvbmVudENvbnRhaW5lcixcbiAgQ29tcG9uZW50LFxuICBOYW1lLFxuICBDb21wb25lbnRUeXBlXG59IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uLy4uL2ZpcmViYXNlL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBGaXJlYmFzZUFwcEltcGwgfSBmcm9tICcuL2ZpcmViYXNlQXBwJztcbmltcG9ydCB7IF9hcHBzLCBfY29tcG9uZW50cywgX3JlZ2lzdGVyQ29tcG9uZW50IH0gZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQge1xuICBMb2dMZXZlbFN0cmluZyxcbiAgc2V0TG9nTGV2ZWwgYXMgc2V0TG9nTGV2ZWxJbXBsLFxuICBMb2dDYWxsYmFjayxcbiAgTG9nT3B0aW9ucyxcbiAgc2V0VXNlckxvZ0hhbmRsZXJcbn0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5pbXBvcnQgeyBkZWVwRXF1YWwsIGdldERlZmF1bHRBcHBDb25maWcgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmV4cG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgU0RLIHZlcnNpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxuICpcbiAqIFNlZVxuICoge0BsaW5rXG4gKiAgIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL3dlYi9zZXR1cCNhZGRfZmlyZWJhc2VfdG9feW91cl9hcHBcbiAqICAgfCBBZGQgRmlyZWJhc2UgdG8geW91ciBhcHB9IGFuZFxuICoge0BsaW5rXG4gKiAgIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL3dlYi9zZXR1cCNtdWx0aXBsZS1wcm9qZWN0c1xuICogICB8IEluaXRpYWxpemUgbXVsdGlwbGUgcHJvamVjdHN9IGZvciBkZXRhaWxlZCBkb2N1bWVudGF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKlxuICogLy8gSW5pdGlhbGl6ZSBkZWZhdWx0IGFwcFxuICogLy8gUmV0cmlldmUgeW91ciBvd24gb3B0aW9ucyB2YWx1ZXMgYnkgYWRkaW5nIGEgd2ViIGFwcCBvblxuICogLy8gaHR0cHM6Ly9jb25zb2xlLmZpcmViYXNlLmdvb2dsZS5jb21cbiAqIGluaXRpYWxpemVBcHAoe1xuICogICBhcGlLZXk6IFwiQUl6YS4uLi5cIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF1dGggLyBHZW5lcmFsIFVzZVxuICogICBhdXRoRG9tYWluOiBcIllPVVJfQVBQLmZpcmViYXNlYXBwLmNvbVwiLCAgICAgICAgIC8vIEF1dGggd2l0aCBwb3B1cC9yZWRpcmVjdFxuICogICBkYXRhYmFzZVVSTDogXCJodHRwczovL1lPVVJfQVBQLmZpcmViYXNlaW8uY29tXCIsIC8vIFJlYWx0aW1lIERhdGFiYXNlXG4gKiAgIHN0b3JhZ2VCdWNrZXQ6IFwiWU9VUl9BUFAuYXBwc3BvdC5jb21cIiwgICAgICAgICAgLy8gU3RvcmFnZVxuICogICBtZXNzYWdpbmdTZW5kZXJJZDogXCIxMjM0NTY3ODlcIiAgICAgICAgICAgICAgICAgIC8vIENsb3VkIE1lc3NhZ2luZ1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICpcbiAqIC8vIEluaXRpYWxpemUgYW5vdGhlciBhcHBcbiAqIGNvbnN0IG90aGVyQXBwID0gaW5pdGlhbGl6ZUFwcCh7XG4gKiAgIGRhdGFiYXNlVVJMOiBcImh0dHBzOi8vPE9USEVSX0RBVEFCQVNFX05BTUU+LmZpcmViYXNlaW8uY29tXCIsXG4gKiAgIHN0b3JhZ2VCdWNrZXQ6IFwiPE9USEVSX1NUT1JBR0VfQlVDS0VUPi5hcHBzcG90LmNvbVwiXG4gKiB9LCBcIm90aGVyQXBwXCIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgYXBwJ3Mgc2VydmljZXMuXG4gKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGFwcCB0byBpbml0aWFsaXplLiBJZiBubyBuYW1lXG4gKiAgIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyBgXCJbREVGQVVMVF1cImAuXG4gKlxuICogQHJldHVybnMgVGhlIGluaXRpYWxpemVkIGFwcC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplQXBwKFxuICBvcHRpb25zOiBGaXJlYmFzZU9wdGlvbnMsXG4gIG5hbWU/OiBzdHJpbmdcbik6IEZpcmViYXNlQXBwO1xuLyoqXG4gKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyBhIEZpcmViYXNlQXBwIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIGFwcCdzIHNlcnZpY2VzLlxuICogQHBhcmFtIGNvbmZpZyAtIEZpcmViYXNlQXBwIENvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplQXBwKFxuICBvcHRpb25zOiBGaXJlYmFzZU9wdGlvbnMsXG4gIGNvbmZpZz86IEZpcmViYXNlQXBwU2V0dGluZ3Ncbik6IEZpcmViYXNlQXBwO1xuLyoqXG4gKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyBhIEZpcmViYXNlQXBwIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVBcHAoKTogRmlyZWJhc2VBcHA7XG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChcbiAgX29wdGlvbnM/OiBGaXJlYmFzZU9wdGlvbnMsXG4gIHJhd0NvbmZpZyA9IHt9XG4pOiBGaXJlYmFzZUFwcCB7XG4gIGxldCBvcHRpb25zID0gX29wdGlvbnM7XG5cbiAgaWYgKHR5cGVvZiByYXdDb25maWcgIT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgbmFtZSA9IHJhd0NvbmZpZztcbiAgICByYXdDb25maWcgPSB7IG5hbWUgfTtcbiAgfVxuXG4gIGNvbnN0IGNvbmZpZzogUmVxdWlyZWQ8RmlyZWJhc2VBcHBTZXR0aW5ncz4gPSB7XG4gICAgbmFtZTogREVGQVVMVF9FTlRSWV9OQU1FLFxuICAgIGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDogZmFsc2UsXG4gICAgLi4ucmF3Q29uZmlnXG4gIH07XG4gIGNvbnN0IG5hbWUgPSBjb25maWcubmFtZTtcblxuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8ICFuYW1lKSB7XG4gICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuQkFEX0FQUF9OQU1FLCB7XG4gICAgICBhcHBOYW1lOiBTdHJpbmcobmFtZSlcbiAgICB9KTtcbiAgfVxuXG4gIG9wdGlvbnMgfHw9IGdldERlZmF1bHRBcHBDb25maWcoKTtcblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShBcHBFcnJvci5OT19PUFRJT05TKTtcbiAgfVxuXG4gIGNvbnN0IGV4aXN0aW5nQXBwID0gX2FwcHMuZ2V0KG5hbWUpIGFzIEZpcmViYXNlQXBwSW1wbDtcbiAgaWYgKGV4aXN0aW5nQXBwKSB7XG4gICAgLy8gcmV0dXJuIHRoZSBleGlzdGluZyBhcHAgaWYgb3B0aW9ucyBhbmQgY29uZmlnIGRlZXAgZXF1YWwgdGhlIG9uZXMgaW4gdGhlIGV4aXN0aW5nIGFwcC5cbiAgICBpZiAoXG4gICAgICBkZWVwRXF1YWwob3B0aW9ucywgZXhpc3RpbmdBcHAub3B0aW9ucykgJiZcbiAgICAgIGRlZXBFcXVhbChjb25maWcsIGV4aXN0aW5nQXBwLmNvbmZpZylcbiAgICApIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuRFVQTElDQVRFX0FQUCwgeyBhcHBOYW1lOiBuYW1lIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZSk7XG4gIGZvciAoY29uc3QgY29tcG9uZW50IG9mIF9jb21wb25lbnRzLnZhbHVlcygpKSB7XG4gICAgY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICB9XG5cbiAgY29uc3QgbmV3QXBwID0gbmV3IEZpcmViYXNlQXBwSW1wbChvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XG5cbiAgX2FwcHMuc2V0KG5hbWUsIG5ld0FwcCk7XG5cbiAgcmV0dXJuIG5ld0FwcDtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UuXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC4gV2hlbiBhbiBhcHAgbmFtZVxuICogaXMgcHJvdmlkZWQsIHRoZSBhcHAgY29ycmVzcG9uZGluZyB0byB0aGF0IG5hbWUgaXMgcmV0dXJuZWQuXG4gKlxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgYXBwIGJlaW5nIHJldHJpZXZlZCBoYXMgbm90IHlldCBiZWVuXG4gKiBpbml0aWFsaXplZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gUmV0dXJuIHRoZSBkZWZhdWx0IGFwcFxuICogY29uc3QgYXBwID0gZ2V0QXBwKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gUmV0dXJuIGEgbmFtZWQgYXBwXG4gKiBjb25zdCBvdGhlckFwcCA9IGdldEFwcChcIm90aGVyQXBwXCIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBPcHRpb25hbCBuYW1lIG9mIHRoZSBhcHAgdG8gcmV0dXJuLiBJZiBubyBuYW1lIGlzXG4gKiAgIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyBgXCJbREVGQVVMVF1cImAuXG4gKlxuICogQHJldHVybnMgVGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBhcHAgbmFtZS5cbiAqICAgSWYgbm8gYXBwIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcHAobmFtZTogc3RyaW5nID0gREVGQVVMVF9FTlRSWV9OQU1FKTogRmlyZWJhc2VBcHAge1xuICBjb25zdCBhcHAgPSBfYXBwcy5nZXQobmFtZSk7XG4gIGlmICghYXBwICYmIG5hbWUgPT09IERFRkFVTFRfRU5UUllfTkFNRSAmJiBnZXREZWZhdWx0QXBwQ29uZmlnKCkpIHtcbiAgICByZXR1cm4gaW5pdGlhbGl6ZUFwcCgpO1xuICB9XG4gIGlmICghYXBwKSB7XG4gICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuTk9fQVBQLCB7IGFwcE5hbWU6IG5hbWUgfSk7XG4gIH1cblxuICByZXR1cm4gYXBwO1xufVxuXG4vKipcbiAqIEEgKHJlYWQtb25seSkgYXJyYXkgb2YgYWxsIGluaXRpYWxpemVkIGFwcHMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcHBzKCk6IEZpcmViYXNlQXBwW10ge1xuICByZXR1cm4gQXJyYXkuZnJvbShfYXBwcy52YWx1ZXMoKSk7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGlzIGFwcCB1bnVzYWJsZSBhbmQgZnJlZXMgdGhlIHJlc291cmNlcyBvZiBhbGwgYXNzb2NpYXRlZFxuICogc2VydmljZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGRlbGV0ZUFwcChhcHApXG4gKiAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICogICAgIGNvbnNvbGUubG9nKFwiQXBwIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICogICB9KVxuICogICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGRlbGV0aW5nIGFwcDpcIiwgZXJyb3IpO1xuICogICB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFwcChhcHA6IEZpcmViYXNlQXBwKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IG5hbWUgPSBhcHAubmFtZTtcbiAgaWYgKF9hcHBzLmhhcyhuYW1lKSkge1xuICAgIF9hcHBzLmRlbGV0ZShuYW1lKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIChhcHAgYXMgRmlyZWJhc2VBcHBJbXBsKS5jb250YWluZXJcbiAgICAgICAgLmdldFByb3ZpZGVycygpXG4gICAgICAgIC5tYXAocHJvdmlkZXIgPT4gcHJvdmlkZXIuZGVsZXRlKCkpXG4gICAgKTtcbiAgICAoYXBwIGFzIEZpcmViYXNlQXBwSW1wbCkuaXNEZWxldGVkID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGxpYnJhcnkncyBuYW1lIGFuZCB2ZXJzaW9uIGZvciBwbGF0Zm9ybSBsb2dnaW5nIHB1cnBvc2VzLlxuICogQHBhcmFtIGxpYnJhcnkgLSBOYW1lIG9mIDFwIG9yIDNwIGxpYnJhcnkgKGUuZy4gZmlyZXN0b3JlLCBhbmd1bGFyZmlyZSlcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQ3VycmVudCB2ZXJzaW9uIG9mIHRoYXQgbGlicmFyeS5cbiAqIEBwYXJhbSB2YXJpYW50IC0gQnVuZGxlIHZhcmlhbnQsIGUuZy4sIG5vZGUsIHJuLCBldGMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJWZXJzaW9uKFxuICBsaWJyYXJ5S2V5T3JOYW1lOiBzdHJpbmcsXG4gIHZlcnNpb246IHN0cmluZyxcbiAgdmFyaWFudD86IHN0cmluZ1xuKTogdm9pZCB7XG4gIC8vIFRPRE86IFdlIGNhbiB1c2UgdGhpcyBjaGVjayB0byB3aGl0ZWxpc3Qgc3RyaW5ncyB3aGVuL2lmIHdlIHNldCB1cFxuICAvLyBhIGdvb2Qgd2hpdGVsaXN0IHN5c3RlbS5cbiAgbGV0IGxpYnJhcnkgPSBQTEFURk9STV9MT0dfU1RSSU5HW2xpYnJhcnlLZXlPck5hbWVdID8/IGxpYnJhcnlLZXlPck5hbWU7XG4gIGlmICh2YXJpYW50KSB7XG4gICAgbGlicmFyeSArPSBgLSR7dmFyaWFudH1gO1xuICB9XG4gIGNvbnN0IGxpYnJhcnlNaXNtYXRjaCA9IGxpYnJhcnkubWF0Y2goL1xcc3xcXC8vKTtcbiAgY29uc3QgdmVyc2lvbk1pc21hdGNoID0gdmVyc2lvbi5tYXRjaCgvXFxzfFxcLy8pO1xuICBpZiAobGlicmFyeU1pc21hdGNoIHx8IHZlcnNpb25NaXNtYXRjaCkge1xuICAgIGNvbnN0IHdhcm5pbmcgPSBbXG4gICAgICBgVW5hYmxlIHRvIHJlZ2lzdGVyIGxpYnJhcnkgXCIke2xpYnJhcnl9XCIgd2l0aCB2ZXJzaW9uIFwiJHt2ZXJzaW9ufVwiOmBcbiAgICBdO1xuICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2gpIHtcbiAgICAgIHdhcm5pbmcucHVzaChcbiAgICAgICAgYGxpYnJhcnkgbmFtZSBcIiR7bGlicmFyeX1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGxpYnJhcnlNaXNtYXRjaCAmJiB2ZXJzaW9uTWlzbWF0Y2gpIHtcbiAgICAgIHdhcm5pbmcucHVzaCgnYW5kJyk7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uTWlzbWF0Y2gpIHtcbiAgICAgIHdhcm5pbmcucHVzaChcbiAgICAgICAgYHZlcnNpb24gbmFtZSBcIiR7dmVyc2lvbn1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYFxuICAgICAgKTtcbiAgICB9XG4gICAgbG9nZ2VyLndhcm4od2FybmluZy5qb2luKCcgJykpO1xuICAgIHJldHVybjtcbiAgfVxuICBfcmVnaXN0ZXJDb21wb25lbnQoXG4gICAgbmV3IENvbXBvbmVudChcbiAgICAgIGAke2xpYnJhcnl9LXZlcnNpb25gIGFzIE5hbWUsXG4gICAgICAoKSA9PiAoeyBsaWJyYXJ5LCB2ZXJzaW9uIH0pLFxuICAgICAgQ29tcG9uZW50VHlwZS5WRVJTSU9OXG4gICAgKVxuICApO1xufVxuXG4vKipcbiAqIFNldHMgbG9nIGhhbmRsZXIgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxuICogQHBhcmFtIGxvZ0NhbGxiYWNrIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGxvZyBoYW5kbGVyIHRoYXQgZXhlY3V0ZXMgdXNlciBjb2RlIHdoZW5ldmVyXG4gKiB0aGUgRmlyZWJhc2UgU0RLIG1ha2VzIGEgbG9nZ2luZyBjYWxsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uTG9nKFxuICBsb2dDYWxsYmFjazogTG9nQ2FsbGJhY2sgfCBudWxsLFxuICBvcHRpb25zPzogTG9nT3B0aW9uc1xuKTogdm9pZCB7XG4gIGlmIChsb2dDYWxsYmFjayAhPT0gbnVsbCAmJiB0eXBlb2YgbG9nQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVCk7XG4gIH1cbiAgc2V0VXNlckxvZ0hhbmRsZXIobG9nQ2FsbGJhY2ssIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFNldHMgbG9nIGxldmVsIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cbiAqXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgYXJlIGNhcHR1cmVkIChpLmUuIGlmXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYGluZm9gLCBlcnJvcnMgYXJlIGxvZ2dlZCwgYnV0IGBkZWJ1Z2AgYW5kXG4gKiBgdmVyYm9zZWAgbG9ncyBhcmUgbm90KS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRMb2dMZXZlbChsb2dMZXZlbDogTG9nTGV2ZWxTdHJpbmcpOiB2b2lkIHtcbiAgc2V0TG9nTGV2ZWxJbXBsKGxvZ0xldmVsKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBEQlNjaGVtYSwgb3BlbkRCLCBJREJQRGF0YWJhc2UgfSBmcm9tICdpZGInO1xuaW1wb3J0IHsgQXBwRXJyb3IsIEVSUk9SX0ZBQ1RPUlkgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBGaXJlYmFzZUFwcCB9IGZyb20gJy4vcHVibGljLXR5cGVzJztcbmltcG9ydCB7IEhlYXJ0YmVhdHNJbkluZGV4ZWREQiB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuXG5jb25zdCBEQl9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1kYXRhYmFzZSc7XG5jb25zdCBEQl9WRVJTSU9OID0gMTtcbmNvbnN0IFNUT1JFX05BTUUgPSAnZmlyZWJhc2UtaGVhcnRiZWF0LXN0b3JlJztcblxuaW50ZXJmYWNlIEFwcERCIGV4dGVuZHMgREJTY2hlbWEge1xuICAnZmlyZWJhc2UtaGVhcnRiZWF0LXN0b3JlJzoge1xuICAgIGtleTogc3RyaW5nO1xuICAgIHZhbHVlOiBIZWFydGJlYXRzSW5JbmRleGVkREI7XG4gIH07XG59XG5cbmxldCBkYlByb21pc2U6IFByb21pc2U8SURCUERhdGFiYXNlPEFwcERCPj4gfCBudWxsID0gbnVsbDtcbmZ1bmN0aW9uIGdldERiUHJvbWlzZSgpOiBQcm9taXNlPElEQlBEYXRhYmFzZTxBcHBEQj4+IHtcbiAgaWYgKCFkYlByb21pc2UpIHtcbiAgICBkYlByb21pc2UgPSBvcGVuREI8QXBwREI+KERCX05BTUUsIERCX1ZFUlNJT04sIHtcbiAgICAgIHVwZ3JhZGU6IChkYiwgb2xkVmVyc2lvbikgPT4ge1xuICAgICAgICAvLyBXZSBkb24ndCB1c2UgJ2JyZWFrJyBpbiB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQsIHRoZSBmYWxsLXRocm91Z2hcbiAgICAgICAgLy8gYmVoYXZpb3IgaXMgd2hhdCB3ZSB3YW50LCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB2ZXJzaW9ucyBiZXR3ZWVuXG4gICAgICAgIC8vIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2Ugd2FudCBBTEwgdGhlIG1pZ3JhdGlvbnNcbiAgICAgICAgLy8gdGhhdCBjb3JyZXNwb25kIHRvIHRob3NlIHZlcnNpb25zIHRvIHJ1biwgbm90IG9ubHkgdGhlIGxhc3Qgb25lLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgICAgIHN3aXRjaCAob2xkVmVyc2lvbikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShBcHBFcnJvci5JREJfT1BFTiwge1xuICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZS5tZXNzYWdlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZGJQcm9taXNlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKFxuICBhcHA6IEZpcmViYXNlQXBwXG4pOiBQcm9taXNlPEhlYXJ0YmVhdHNJbkluZGV4ZWREQiB8IHVuZGVmaW5lZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGJcbiAgICAgIC50cmFuc2FjdGlvbihTVE9SRV9OQU1FKVxuICAgICAgLm9iamVjdFN0b3JlKFNUT1JFX05BTUUpXG4gICAgICAuZ2V0KGNvbXB1dGVLZXkoYXBwKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xuICAgICAgbG9nZ2VyLndhcm4oZS5tZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaWRiR2V0RXJyb3IgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShBcHBFcnJvci5JREJfR0VULCB7XG4gICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiAoZSBhcyBFcnJvcik/Lm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQihcbiAgYXBwOiBGaXJlYmFzZUFwcCxcbiAgaGVhcnRiZWF0T2JqZWN0OiBIZWFydGJlYXRzSW5JbmRleGVkREJcbik6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XG4gICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQoaGVhcnRiZWF0T2JqZWN0LCBjb21wdXRlS2V5KGFwcCkpO1xuICAgIGF3YWl0IHR4LmRvbmU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlkYkdldEVycm9yID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoQXBwRXJyb3IuSURCX1dSSVRFLCB7XG4gICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiAoZSBhcyBFcnJvcik/Lm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVLZXkoYXBwOiBGaXJlYmFzZUFwcCk6IHN0cmluZyB7XG4gIHJldHVybiBgJHthcHAubmFtZX0hJHthcHAub3B0aW9ucy5hcHBJZH1gO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50Q29udGFpbmVyIH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQge1xuICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyxcbiAgaXNJbmRleGVkREJBdmFpbGFibGUsXG4gIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGVcbn0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHtcbiAgcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCLFxuICB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQlxufSBmcm9tICcuL2luZGV4ZWRkYic7XG5pbXBvcnQgeyBGaXJlYmFzZUFwcCB9IGZyb20gJy4vcHVibGljLXR5cGVzJztcbmltcG9ydCB7XG4gIEhlYXJ0YmVhdHNCeVVzZXJBZ2VudCxcbiAgSGVhcnRiZWF0U2VydmljZSxcbiAgSGVhcnRiZWF0c0luSW5kZXhlZERCLFxuICBIZWFydGJlYXRTdG9yYWdlLFxuICBTaW5nbGVEYXRlSGVhcnRiZWF0XG59IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBNQVhfSEVBREVSX0JZVEVTID0gMTAyNDtcbi8vIDMwIGRheXNcbmNvbnN0IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVMgPSAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cbmV4cG9ydCBjbGFzcyBIZWFydGJlYXRTZXJ2aWNlSW1wbCBpbXBsZW1lbnRzIEhlYXJ0YmVhdFNlcnZpY2Uge1xuICAvKipcbiAgICogVGhlIHBlcnNpc3RlbmNlIGxheWVyIGZvciBoZWFydGJlYXRzXG4gICAqIExlYXZlIHB1YmxpYyBmb3IgZWFzaWVyIHRlc3RpbmcuXG4gICAqL1xuICBfc3RvcmFnZTogSGVhcnRiZWF0U3RvcmFnZUltcGw7XG5cbiAgLyoqXG4gICAqIEluLW1lbW9yeSBjYWNoZSBmb3IgaGVhcnRiZWF0cywgdXNlZCBieSBnZXRIZWFydGJlYXRzSGVhZGVyKCkgdG8gZ2VuZXJhdGVcbiAgICogdGhlIGhlYWRlciBzdHJpbmcuXG4gICAqIFN0b3JlcyBvbmUgcmVjb3JkIHBlciBkYXRlLiBUaGlzIHdpbGwgYmUgY29uc29saWRhdGVkIGludG8gdGhlIHN0YW5kYXJkXG4gICAqIGZvcm1hdCBvZiBvbmUgcmVjb3JkIHBlciB1c2VyIGFnZW50IHN0cmluZyBiZWZvcmUgYmVpbmcgc2VudCBhcyBhIGhlYWRlci5cbiAgICogUG9wdWxhdGVkIGZyb20gaW5kZXhlZERCIHdoZW4gdGhlIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkIGFuZCBzaG91bGRcbiAgICogYmUga2VwdCBpbiBzeW5jIHdpdGggaW5kZXhlZERCLlxuICAgKiBMZWF2ZSBwdWJsaWMgZm9yIGVhc2llciB0ZXN0aW5nLlxuICAgKi9cbiAgX2hlYXJ0YmVhdHNDYWNoZTogSGVhcnRiZWF0c0luSW5kZXhlZERCIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIHRoZSBpbml0aWFsaXphdGlvbiBwcm9taXNlIGZvciBwb3B1bGF0aW5nIGhlYXJ0YmVhdENhY2hlLlxuICAgKiBJZiBnZXRIZWFydGJlYXRzSGVhZGVyKCkgaXMgY2FsbGVkIGJlZm9yZSB0aGUgcHJvbWlzZSByZXNvbHZlc1xuICAgKiAoaGVhcmJlYXRzQ2FjaGUgPT0gbnVsbCksIGl0IHNob3VsZCB3YWl0IGZvciB0aGlzIHByb21pc2VcbiAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cbiAgICovXG4gIF9oZWFydGJlYXRzQ2FjaGVQcm9taXNlOiBQcm9taXNlPEhlYXJ0YmVhdHNJbkluZGV4ZWREQj47XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgY29udGFpbmVyOiBDb21wb25lbnRDb250YWluZXIpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgdGhpcy5fc3RvcmFnZSA9IG5ldyBIZWFydGJlYXRTdG9yYWdlSW1wbChhcHApO1xuICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2UgPSB0aGlzLl9zdG9yYWdlLnJlYWQoKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSByZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB0byByZXBvcnQgYSBoZWFydGJlYXQuIFRoZSBmdW5jdGlvbiB3aWxsIGdlbmVyYXRlXG4gICAqIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IG9iamVjdCwgdXBkYXRlIGhlYXJ0YmVhdHNDYWNoZSwgYW5kIHBlcnNpc3QgaXRcbiAgICogdG8gSW5kZXhlZERCLlxuICAgKiBOb3RlIHRoYXQgd2Ugb25seSBzdG9yZSBvbmUgaGVhcnRiZWF0IHBlciBkYXkuIFNvIGlmIGEgaGVhcnRiZWF0IGZvciB0b2RheSBpc1xuICAgKiBhbHJlYWR5IGxvZ2dlZCwgc3Vic2VxdWVudCBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIGluIHRoZSBzYW1lIGRheSB3aWxsIGJlIGlnbm9yZWQuXG4gICAqL1xuICBhc3luYyB0cmlnZ2VySGVhcnRiZWF0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHBsYXRmb3JtTG9nZ2VyID0gdGhpcy5jb250YWluZXJcbiAgICAgIC5nZXRQcm92aWRlcigncGxhdGZvcm0tbG9nZ2VyJylcbiAgICAgIC5nZXRJbW1lZGlhdGUoKTtcblxuICAgIC8vIFRoaXMgaXMgdGhlIFwiRmlyZWJhc2UgdXNlciBhZ2VudFwiIHN0cmluZyBmcm9tIHRoZSBwbGF0Zm9ybSBsb2dnZXJcbiAgICAvLyBzZXJ2aWNlLCBub3QgdGhlIGJyb3dzZXIgdXNlciBhZ2VudC5cbiAgICBjb25zdCBhZ2VudCA9IHBsYXRmb3JtTG9nZ2VyLmdldFBsYXRmb3JtSW5mb1N0cmluZygpO1xuICAgIGNvbnN0IGRhdGUgPSBnZXRVVENEYXRlU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcbiAgICB9XG4gICAgLy8gRG8gbm90IHN0b3JlIGEgaGVhcnRiZWF0IGlmIG9uZSBpcyBhbHJlYWR5IHN0b3JlZCBmb3IgdGhpcyBkYXlcbiAgICAvLyBvciBpZiBhIGhlYWRlciBoYXMgYWxyZWFkeSBiZWVuIHNlbnQgdG9kYXkuXG4gICAgaWYgKFxuICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9PT0gZGF0ZSB8fFxuICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuc29tZShcbiAgICAgICAgc2luZ2xlRGF0ZUhlYXJ0YmVhdCA9PiBzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUgPT09IGRhdGVcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gZW50cnkgZm9yIHRoaXMgZGF0ZS4gQ3JlYXRlIG9uZS5cbiAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLnB1c2goeyBkYXRlLCBhZ2VudCB9KTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGVudHJpZXMgb2xkZXIgdGhhbiAzMCBkYXlzLlxuICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuZmlsdGVyKFxuICAgICAgc2luZ2xlRGF0ZUhlYXJ0YmVhdCA9PiB7XG4gICAgICAgIGNvbnN0IGhiVGltZXN0YW1wID0gbmV3IERhdGUoc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKS52YWx1ZU9mKCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBub3cgLSBoYlRpbWVzdGFtcCA8PSBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB3aGljaCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIGhlYXJ0YmVhdC1zcGVjaWZpYyBoZWFkZXIgZGlyZWN0bHkuXG4gICAqIEl0IGFsc28gY2xlYXJzIGFsbCBoZWFydGJlYXRzIGZyb20gbWVtb3J5IGFzIHdlbGwgYXMgaW4gSW5kZXhlZERCLlxuICAgKlxuICAgKiBOT1RFOiBDb25zdW1pbmcgcHJvZHVjdCBTREtzIHNob3VsZCBub3Qgc2VuZCB0aGUgaGVhZGVyIGlmIHRoaXMgbWV0aG9kXG4gICAqIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cbiAgYXN5bmMgZ2V0SGVhcnRiZWF0c0hlYWRlcigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XG4gICAgfVxuICAgIC8vIElmIGl0J3Mgc3RpbGwgbnVsbCBvciB0aGUgYXJyYXkgaXMgZW1wdHksIHRoZXJlIGlzIG5vIGRhdGEgdG8gc2VuZC5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwgfHxcbiAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xuICAgIC8vIEV4dHJhY3QgYXMgbWFueSBoZWFydGJlYXRzIGZyb20gdGhlIGNhY2hlIGFzIHdpbGwgZml0IHVuZGVyIHRoZSBzaXplIGxpbWl0LlxuICAgIGNvbnN0IHsgaGVhcnRiZWF0c1RvU2VuZCwgdW5zZW50RW50cmllcyB9ID0gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIoXG4gICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0c1xuICAgICk7XG4gICAgY29uc3QgaGVhZGVyU3RyaW5nID0gYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoXG4gICAgICBKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNUb1NlbmQgfSlcbiAgICApO1xuICAgIC8vIFN0b3JlIGxhc3Qgc2VudCBkYXRlIHRvIHByZXZlbnQgYW5vdGhlciBiZWluZyBsb2dnZWQvc2VudCBmb3IgdGhlIHNhbWUgZGF5LlxuICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPSBkYXRlO1xuICAgIGlmICh1bnNlbnRFbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFN0b3JlIGFueSB1bnNlbnQgZW50cmllcyBpZiB0aGV5IGV4aXN0LlxuICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB1bnNlbnRFbnRyaWVzO1xuICAgICAgLy8gVGhpcyBzZWVtcyBtb3JlIGxpa2VseSB0aGFuIGVtcHR5aW5nIHRoZSBhcnJheSAoYmVsb3cpIHRvIGxlYWQgdG8gc29tZSBvZGQgc3RhdGVcbiAgICAgIC8vIHNpbmNlIHRoZSBjYWNoZSBpc24ndCBlbXB0eSBhbmQgdGhpcyB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBvbiB0aGUgbmV4dCByZXF1ZXN0LFxuICAgICAgLy8gYW5kIGlzIHByb2JhYmx5IHNhZmVzdCBpZiB3ZSBhd2FpdCBpdC5cbiAgICAgIGF3YWl0IHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gW107XG4gICAgICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhpcywgdG8gcmVkdWNlIGxhdGVuY3kuXG4gICAgICB2b2lkIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJTdHJpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VVRDRGF0ZVN0cmluZygpOiBzdHJpbmcge1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gIC8vIFJldHVybnMgZGF0ZSBmb3JtYXQgJ1lZWVktTU0tREQnXG4gIHJldHVybiB0b2RheS50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcihcbiAgaGVhcnRiZWF0c0NhY2hlOiBTaW5nbGVEYXRlSGVhcnRiZWF0W10sXG4gIG1heFNpemUgPSBNQVhfSEVBREVSX0JZVEVTXG4pOiB7XG4gIGhlYXJ0YmVhdHNUb1NlbmQ6IEhlYXJ0YmVhdHNCeVVzZXJBZ2VudFtdO1xuICB1bnNlbnRFbnRyaWVzOiBTaW5nbGVEYXRlSGVhcnRiZWF0W107XG59IHtcbiAgLy8gSGVhcnRiZWF0cyBncm91cGVkIGJ5IHVzZXIgYWdlbnQgaW4gdGhlIHN0YW5kYXJkIGZvcm1hdCB0byBiZSBzZW50IGluXG4gIC8vIHRoZSBoZWFkZXIuXG4gIGNvbnN0IGhlYXJ0YmVhdHNUb1NlbmQ6IEhlYXJ0YmVhdHNCeVVzZXJBZ2VudFtdID0gW107XG4gIC8vIFNpbmdsZSBkYXRlIGZvcm1hdCBoZWFydGJlYXRzIHRoYXQgYXJlIG5vdCBzZW50LlxuICBsZXQgdW5zZW50RW50cmllcyA9IGhlYXJ0YmVhdHNDYWNoZS5zbGljZSgpO1xuICBmb3IgKGNvbnN0IHNpbmdsZURhdGVIZWFydGJlYXQgb2YgaGVhcnRiZWF0c0NhY2hlKSB7XG4gICAgLy8gTG9vayBmb3IgYW4gZXhpc3RpbmcgZW50cnkgd2l0aCB0aGUgc2FtZSB1c2VyIGFnZW50LlxuICAgIGNvbnN0IGhlYXJ0YmVhdEVudHJ5ID0gaGVhcnRiZWF0c1RvU2VuZC5maW5kKFxuICAgICAgaGIgPT4gaGIuYWdlbnQgPT09IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnRcbiAgICApO1xuICAgIGlmICghaGVhcnRiZWF0RW50cnkpIHtcbiAgICAgIC8vIElmIG5vIGVudHJ5IGZvciB0aGlzIHVzZXIgYWdlbnQgZXhpc3RzLCBjcmVhdGUgb25lLlxuICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wdXNoKHtcbiAgICAgICAgYWdlbnQ6IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQsXG4gICAgICAgIGRhdGVzOiBbc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlXVxuICAgICAgfSk7XG4gICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcbiAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgaGVhcnRiZWF0XG4gICAgICAgIC8vIGVudHJ5IGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxuICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucHVzaChzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpO1xuICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgZGF0ZVxuICAgICAgLy8gYW5kIHN0b3AgYWRkaW5nIHRvIHRoZSBoZWFkZXIuXG4gICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcbiAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQb3AgdW5zZW50IGVudHJ5IGZyb20gcXVldWUuIChTa2lwcGVkIGlmIGFkZGluZyB0aGUgZW50cnkgZXhjZWVkZWRcbiAgICAvLyBxdW90YSBhbmQgdGhlIGxvb3AgYnJlYWtzIGVhcmx5LilcbiAgICB1bnNlbnRFbnRyaWVzID0gdW5zZW50RW50cmllcy5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhlYXJ0YmVhdHNUb1NlbmQsXG4gICAgdW5zZW50RW50cmllc1xuICB9O1xufVxuXG5leHBvcnQgY2xhc3MgSGVhcnRiZWF0U3RvcmFnZUltcGwgaW1wbGVtZW50cyBIZWFydGJlYXRTdG9yYWdlIHtcbiAgcHJpdmF0ZSBfY2FuVXNlSW5kZXhlZERCUHJvbWlzZTogUHJvbWlzZTxib29sZWFuPjtcbiAgY29uc3RydWN0b3IocHVibGljIGFwcDogRmlyZWJhc2VBcHApIHtcbiAgICB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlID0gdGhpcy5ydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCk7XG4gIH1cbiAgYXN5bmMgcnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKVxuICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxuICAgICAgICAuY2F0Y2goKCkgPT4gZmFsc2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVhZCBhbGwgaGVhcnRiZWF0cy5cbiAgICovXG4gIGFzeW5jIHJlYWQoKTogUHJvbWlzZTxIZWFydGJlYXRzSW5JbmRleGVkREI+IHtcbiAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xuICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpZGJIZWFydGJlYXRPYmplY3QgPSBhd2FpdCByZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIodGhpcy5hcHApO1xuICAgICAgcmV0dXJuIGlkYkhlYXJ0YmVhdE9iamVjdCB8fCB7IGhlYXJ0YmVhdHM6IFtdIH07XG4gICAgfVxuICB9XG4gIC8vIG92ZXJ3cml0ZSB0aGUgc3RvcmFnZSB3aXRoIHRoZSBwcm92aWRlZCBoZWFydGJlYXRzXG4gIGFzeW5jIG92ZXJ3cml0ZShoZWFydGJlYXRzT2JqZWN0OiBIZWFydGJlYXRzSW5JbmRleGVkREIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xuICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xuICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XG4gICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTpcbiAgICAgICAgICBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA/P1xuICAgICAgICAgIGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXG4gICAgICAgIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0c1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIGFkZCBoZWFydGJlYXRzXG4gIGFzeW5jIGFkZChoZWFydGJlYXRzT2JqZWN0OiBIZWFydGJlYXRzSW5JbmRleGVkREIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xuICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xuICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XG4gICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTpcbiAgICAgICAgICBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA/P1xuICAgICAgICAgIGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXG4gICAgICAgIGhlYXJ0YmVhdHM6IFtcbiAgICAgICAgICAuLi5leGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0cyxcbiAgICAgICAgICAuLi5oZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGJ5dGVzIG9mIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IGFycmF5IGFmdGVyIGJlaW5nIHdyYXBwZWRcbiAqIGluIGEgcGxhdGZvcm0gbG9nZ2luZyBoZWFkZXIgSlNPTiBvYmplY3QsIHN0cmluZ2lmaWVkLCBhbmQgY29udmVydGVkXG4gKiB0byBiYXNlIDY0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY291bnRCeXRlcyhoZWFydGJlYXRzQ2FjaGU6IEhlYXJ0YmVhdHNCeVVzZXJBZ2VudFtdKTogbnVtYmVyIHtcbiAgLy8gYmFzZTY0IGhhcyBhIHJlc3RyaWN0ZWQgc2V0IG9mIGNoYXJhY3RlcnMsIGFsbCBvZiB3aGljaCBzaG91bGQgYmUgMSBieXRlLlxuICByZXR1cm4gYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoXG4gICAgLy8gaGVhcnRiZWF0c0NhY2hlIHdyYXBwZXIgcHJvcGVydGllc1xuICAgIEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c0NhY2hlIH0pXG4gICkubGVuZ3RoO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRUeXBlIH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsIH0gZnJvbSAnLi9wbGF0Zm9ybUxvZ2dlclNlcnZpY2UnO1xuaW1wb3J0IHsgbmFtZSwgdmVyc2lvbiB9IGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBfcmVnaXN0ZXJDb21wb25lbnQgfSBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCB7IHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJy4vYXBpJztcbmltcG9ydCB7IEhlYXJ0YmVhdFNlcnZpY2VJbXBsIH0gZnJvbSAnLi9oZWFydGJlYXRTZXJ2aWNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQ29yZUNvbXBvbmVudHModmFyaWFudD86IHN0cmluZyk6IHZvaWQge1xuICBfcmVnaXN0ZXJDb21wb25lbnQoXG4gICAgbmV3IENvbXBvbmVudChcbiAgICAgICdwbGF0Zm9ybS1sb2dnZXInLFxuICAgICAgY29udGFpbmVyID0+IG5ldyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsKGNvbnRhaW5lciksXG4gICAgICBDb21wb25lbnRUeXBlLlBSSVZBVEVcbiAgICApXG4gICk7XG4gIF9yZWdpc3RlckNvbXBvbmVudChcbiAgICBuZXcgQ29tcG9uZW50KFxuICAgICAgJ2hlYXJ0YmVhdCcsXG4gICAgICBjb250YWluZXIgPT4gbmV3IEhlYXJ0YmVhdFNlcnZpY2VJbXBsKGNvbnRhaW5lciksXG4gICAgICBDb21wb25lbnRUeXBlLlBSSVZBVEVcbiAgICApXG4gICk7XG5cbiAgLy8gUmVnaXN0ZXIgYGFwcGAgcGFja2FnZS5cbiAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sIHZhcmlhbnQpO1xuICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxuICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ19fQlVJTERfVEFSR0VUX18nKTtcbiAgLy8gUmVnaXN0ZXIgcGxhdGZvcm0gU0RLIGlkZW50aWZpZXIgKG5vIHZlcnNpb24pLlxuICByZWdpc3RlclZlcnNpb24oJ2ZpcmUtanMnLCAnJyk7XG59XG4iLCIvKipcbiAqIEZpcmViYXNlIEFwcFxuICpcbiAqIEByZW1hcmtzIFRoaXMgcGFja2FnZSBjb29yZGluYXRlcyB0aGUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHRoZSBkaWZmZXJlbnQgRmlyZWJhc2UgY29tcG9uZW50c1xuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyB9IGZyb20gJy4vcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vYXBpJztcbmV4cG9ydCAqIGZyb20gJy4vaW50ZXJuYWwnO1xuZXhwb3J0ICogZnJvbSAnLi9wdWJsaWMtdHlwZXMnO1xuXG5yZWdpc3RlckNvcmVDb21wb25lbnRzKCdfX1JVTlRJTUVfRU5WX18nKTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgfVxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgfVxuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19lc0RlY29yYXRlKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gIHZhciBfLCBkb25lID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgIH1cbiAgfVxuICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gIGRvbmUgPSB0cnVlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gIH1cbiAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19wcm9wS2V5KHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiID8geCA6IFwiXCIuY29uY2F0KHgpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fc2V0RnVuY3Rpb25OYW1lKGYsIG5hbWUsIHByZWZpeCkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJuYW1lXCIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIiwgbmFtZSkgOiBuYW1lIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbn1cblxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gIGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgcltrXSA9IGFbal07XG4gIHJldHVybiByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICB2YXIgaSwgcDtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgcmV0dXJuIGNvb2tlZDtcbn07XG5cbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XG4gIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XG4gIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZXh0ZW5kcyxcbiAgX19hc3NpZ24sXG4gIF9fcmVzdCxcbiAgX19kZWNvcmF0ZSxcbiAgX19wYXJhbSxcbiAgX19tZXRhZGF0YSxcbiAgX19hd2FpdGVyLFxuICBfX2dlbmVyYXRvcixcbiAgX19jcmVhdGVCaW5kaW5nLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fdmFsdWVzLFxuICBfX3JlYWQsXG4gIF9fc3ByZWFkLFxuICBfX3NwcmVhZEFycmF5cyxcbiAgX19zcHJlYWRBcnJheSxcbiAgX19hd2FpdCxcbiAgX19hc3luY0dlbmVyYXRvcixcbiAgX19hc3luY0RlbGVnYXRvcixcbiAgX19hc3luY1ZhbHVlcyxcbiAgX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gIF9faW1wb3J0U3RhcixcbiAgX19pbXBvcnREZWZhdWx0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtIG9mIGZhY3RvcnMgdGhhdCBtYXkgYmUgdXNlZCBmb3IgbXVsdGlmYWN0b3IgYXV0aGVudGljYXRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgRmFjdG9ySWQgPSB7XG4gIC8qKiBQaG9uZSBhcyBzZWNvbmQgZmFjdG9yICovXG4gIFBIT05FOiAncGhvbmUnLFxuICBUT1RQOiAndG90cCdcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogRW51bWVyYXRpb24gb2Ygc3VwcG9ydGVkIHByb3ZpZGVycy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBQcm92aWRlcklkID0ge1xuICAvKiogRmFjZWJvb2sgcHJvdmlkZXIgSUQgKi9cbiAgRkFDRUJPT0s6ICdmYWNlYm9vay5jb20nLFxuICAvKiogR2l0SHViIHByb3ZpZGVyIElEICovXG4gIEdJVEhVQjogJ2dpdGh1Yi5jb20nLFxuICAvKiogR29vZ2xlIHByb3ZpZGVyIElEICovXG4gIEdPT0dMRTogJ2dvb2dsZS5jb20nLFxuICAvKiogUGFzc3dvcmQgcHJvdmlkZXIgKi9cbiAgUEFTU1dPUkQ6ICdwYXNzd29yZCcsXG4gIC8qKiBQaG9uZSBwcm92aWRlciAqL1xuICBQSE9ORTogJ3Bob25lJyxcbiAgLyoqIFR3aXR0ZXIgcHJvdmlkZXIgSUQgKi9cbiAgVFdJVFRFUjogJ3R3aXR0ZXIuY29tJ1xufSBhcyBjb25zdDtcblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgc2lnbi1pbiBtZXRob2RzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IFNpZ25Jbk1ldGhvZCA9IHtcbiAgLyoqIEVtYWlsIGxpbmsgc2lnbiBpbiBtZXRob2QgKi9cbiAgRU1BSUxfTElOSzogJ2VtYWlsTGluaycsXG4gIC8qKiBFbWFpbC9wYXNzd29yZCBzaWduIGluIG1ldGhvZCAqL1xuICBFTUFJTF9QQVNTV09SRDogJ3Bhc3N3b3JkJyxcbiAgLyoqIEZhY2Vib29rIHNpZ24gaW4gbWV0aG9kICovXG4gIEZBQ0VCT09LOiAnZmFjZWJvb2suY29tJyxcbiAgLyoqIEdpdEh1YiBzaWduIGluIG1ldGhvZCAqL1xuICBHSVRIVUI6ICdnaXRodWIuY29tJyxcbiAgLyoqIEdvb2dsZSBzaWduIGluIG1ldGhvZCAqL1xuICBHT09HTEU6ICdnb29nbGUuY29tJyxcbiAgLyoqIFBob25lIHNpZ24gaW4gbWV0aG9kICovXG4gIFBIT05FOiAncGhvbmUnLFxuICAvKiogVHdpdHRlciBzaWduIGluIG1ldGhvZCAqL1xuICBUV0lUVEVSOiAndHdpdHRlci5jb20nXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHN1cHBvcnRlZCBvcGVyYXRpb24gdHlwZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgT3BlcmF0aW9uVHlwZSA9IHtcbiAgLyoqIE9wZXJhdGlvbiBpbnZvbHZpbmcgbGlua2luZyBhbiBhZGRpdGlvbmFsIHByb3ZpZGVyIHRvIGFuIGFscmVhZHkgc2lnbmVkLWluIHVzZXIuICovXG4gIExJTks6ICdsaW5rJyxcbiAgLyoqIE9wZXJhdGlvbiBpbnZvbHZpbmcgdXNpbmcgYSBwcm92aWRlciB0byByZWF1dGhlbnRpY2F0ZSBhbiBhbHJlYWR5IHNpZ25lZC1pbiB1c2VyLiAqL1xuICBSRUFVVEhFTlRJQ0FURTogJ3JlYXV0aGVudGljYXRlJyxcbiAgLyoqIE9wZXJhdGlvbiBpbnZvbHZpbmcgc2lnbmluZyBpbiBhIHVzZXIuICovXG4gIFNJR05fSU46ICdzaWduSW4nXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHRoZSBwb3NzaWJsZSBlbWFpbCBhY3Rpb24gdHlwZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgQWN0aW9uQ29kZU9wZXJhdGlvbiA9IHtcbiAgLyoqIFRoZSBlbWFpbCBsaW5rIHNpZ24taW4gYWN0aW9uLiAqL1xuICBFTUFJTF9TSUdOSU46ICdFTUFJTF9TSUdOSU4nLFxuICAvKiogVGhlIHBhc3N3b3JkIHJlc2V0IGFjdGlvbi4gKi9cbiAgUEFTU1dPUkRfUkVTRVQ6ICdQQVNTV09SRF9SRVNFVCcsXG4gIC8qKiBUaGUgZW1haWwgcmV2b2NhdGlvbiBhY3Rpb24uICovXG4gIFJFQ09WRVJfRU1BSUw6ICdSRUNPVkVSX0VNQUlMJyxcbiAgLyoqIFRoZSByZXZlcnQgc2Vjb25kIGZhY3RvciBhZGRpdGlvbiBlbWFpbCBhY3Rpb24uICovXG4gIFJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OOiAnUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04nLFxuICAvKiogVGhlIHJldmVydCBzZWNvbmQgZmFjdG9yIGFkZGl0aW9uIGVtYWlsIGFjdGlvbi4gKi9cbiAgVkVSSUZZX0FORF9DSEFOR0VfRU1BSUw6ICdWRVJJRllfQU5EX0NIQU5HRV9FTUFJTCcsXG4gIC8qKiBUaGUgZW1haWwgdmVyaWZpY2F0aW9uIGFjdGlvbi4gKi9cbiAgVkVSSUZZX0VNQUlMOiAnVkVSSUZZX0VNQUlMJ1xufSBhcyBjb25zdDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEF1dGhFcnJvck1hcCwgVXNlciB9IGZyb20gJy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIEVycm9yTWFwIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbXBvcnQgeyBJZFRva2VuTWZhUmVzcG9uc2UgfSBmcm9tICcuLi9hcGkvYXV0aGVudGljYXRpb24vbWZhJztcbmltcG9ydCB7IEFwcE5hbWUgfSBmcm9tICcuLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IEF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi9jcmVkZW50aWFscyc7XG5cbi8qKlxuICogRW51bWVyYXRpb24gb2YgRmlyZWJhc2UgQXV0aCBlcnJvciBjb2Rlcy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gQXV0aEVycm9yQ29kZSB7XG4gIEFETUlOX09OTFlfT1BFUkFUSU9OID0gJ2FkbWluLXJlc3RyaWN0ZWQtb3BlcmF0aW9uJyxcbiAgQVJHVU1FTlRfRVJST1IgPSAnYXJndW1lbnQtZXJyb3InLFxuICBBUFBfTk9UX0FVVEhPUklaRUQgPSAnYXBwLW5vdC1hdXRob3JpemVkJyxcbiAgQVBQX05PVF9JTlNUQUxMRUQgPSAnYXBwLW5vdC1pbnN0YWxsZWQnLFxuICBDQVBUQ0hBX0NIRUNLX0ZBSUxFRCA9ICdjYXB0Y2hhLWNoZWNrLWZhaWxlZCcsXG4gIENPREVfRVhQSVJFRCA9ICdjb2RlLWV4cGlyZWQnLFxuICBDT1JET1ZBX05PVF9SRUFEWSA9ICdjb3Jkb3ZhLW5vdC1yZWFkeScsXG4gIENPUlNfVU5TVVBQT1JURUQgPSAnY29ycy11bnN1cHBvcnRlZCcsXG4gIENSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0UgPSAnY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZScsXG4gIENSRURFTlRJQUxfTUlTTUFUQ0ggPSAnY3VzdG9tLXRva2VuLW1pc21hdGNoJyxcbiAgQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOID0gJ3JlcXVpcmVzLXJlY2VudC1sb2dpbicsXG4gIERFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSCA9ICdkZXBlbmRlbnQtc2RrLWluaXRpYWxpemVkLWJlZm9yZS1hdXRoJyxcbiAgRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQgPSAnZHluYW1pYy1saW5rLW5vdC1hY3RpdmF0ZWQnLFxuICBFTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OID0gJ2VtYWlsLWNoYW5nZS1uZWVkcy12ZXJpZmljYXRpb24nLFxuICBFTUFJTF9FWElTVFMgPSAnZW1haWwtYWxyZWFkeS1pbi11c2UnLFxuICBFTVVMQVRPUl9DT05GSUdfRkFJTEVEID0gJ2VtdWxhdG9yLWNvbmZpZy1mYWlsZWQnLFxuICBFWFBJUkVEX09PQl9DT0RFID0gJ2V4cGlyZWQtYWN0aW9uLWNvZGUnLFxuICBFWFBJUkVEX1BPUFVQX1JFUVVFU1QgPSAnY2FuY2VsbGVkLXBvcHVwLXJlcXVlc3QnLFxuICBJTlRFUk5BTF9FUlJPUiA9ICdpbnRlcm5hbC1lcnJvcicsXG4gIElOVkFMSURfQVBJX0tFWSA9ICdpbnZhbGlkLWFwaS1rZXknLFxuICBJTlZBTElEX0FQUF9DUkVERU5USUFMID0gJ2ludmFsaWQtYXBwLWNyZWRlbnRpYWwnLFxuICBJTlZBTElEX0FQUF9JRCA9ICdpbnZhbGlkLWFwcC1pZCcsXG4gIElOVkFMSURfQVVUSCA9ICdpbnZhbGlkLXVzZXItdG9rZW4nLFxuICBJTlZBTElEX0FVVEhfRVZFTlQgPSAnaW52YWxpZC1hdXRoLWV2ZW50JyxcbiAgSU5WQUxJRF9DRVJUX0hBU0ggPSAnaW52YWxpZC1jZXJ0LWhhc2gnLFxuICBJTlZBTElEX0NPREUgPSAnaW52YWxpZC12ZXJpZmljYXRpb24tY29kZScsXG4gIElOVkFMSURfQ09OVElOVUVfVVJJID0gJ2ludmFsaWQtY29udGludWUtdXJpJyxcbiAgSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT04gPSAnaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb24nLFxuICBJTlZBTElEX0NVU1RPTV9UT0tFTiA9ICdpbnZhbGlkLWN1c3RvbS10b2tlbicsXG4gIElOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTiA9ICdpbnZhbGlkLWR5bmFtaWMtbGluay1kb21haW4nLFxuICBJTlZBTElEX0VNQUlMID0gJ2ludmFsaWQtZW1haWwnLFxuICBJTlZBTElEX0VNVUxBVE9SX1NDSEVNRSA9ICdpbnZhbGlkLWVtdWxhdG9yLXNjaGVtZScsXG4gIElOVkFMSURfSURQX1JFU1BPTlNFID0gJ2ludmFsaWQtY3JlZGVudGlhbCcsXG4gIElOVkFMSURfTUVTU0FHRV9QQVlMT0FEID0gJ2ludmFsaWQtbWVzc2FnZS1wYXlsb2FkJyxcbiAgSU5WQUxJRF9NRkFfU0VTU0lPTiA9ICdpbnZhbGlkLW11bHRpLWZhY3Rvci1zZXNzaW9uJyxcbiAgSU5WQUxJRF9PQVVUSF9DTElFTlRfSUQgPSAnaW52YWxpZC1vYXV0aC1jbGllbnQtaWQnLFxuICBJTlZBTElEX09BVVRIX1BST1ZJREVSID0gJ2ludmFsaWQtb2F1dGgtcHJvdmlkZXInLFxuICBJTlZBTElEX09PQl9DT0RFID0gJ2ludmFsaWQtYWN0aW9uLWNvZGUnLFxuICBJTlZBTElEX09SSUdJTiA9ICd1bmF1dGhvcml6ZWQtZG9tYWluJyxcbiAgSU5WQUxJRF9QQVNTV09SRCA9ICd3cm9uZy1wYXNzd29yZCcsXG4gIElOVkFMSURfUEVSU0lTVEVOQ0UgPSAnaW52YWxpZC1wZXJzaXN0ZW5jZS10eXBlJyxcbiAgSU5WQUxJRF9QSE9ORV9OVU1CRVIgPSAnaW52YWxpZC1waG9uZS1udW1iZXInLFxuICBJTlZBTElEX1BST1ZJREVSX0lEID0gJ2ludmFsaWQtcHJvdmlkZXItaWQnLFxuICBJTlZBTElEX1JFQ0lQSUVOVF9FTUFJTCA9ICdpbnZhbGlkLXJlY2lwaWVudC1lbWFpbCcsXG4gIElOVkFMSURfU0VOREVSID0gJ2ludmFsaWQtc2VuZGVyJyxcbiAgSU5WQUxJRF9TRVNTSU9OX0lORk8gPSAnaW52YWxpZC12ZXJpZmljYXRpb24taWQnLFxuICBJTlZBTElEX1RFTkFOVF9JRCA9ICdpbnZhbGlkLXRlbmFudC1pZCcsXG4gIExPR0lOX0JMT0NLRUQgPSAnbG9naW4tYmxvY2tlZCcsXG4gIE1GQV9JTkZPX05PVF9GT1VORCA9ICdtdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmQnLFxuICBNRkFfUkVRVUlSRUQgPSAnbXVsdGktZmFjdG9yLWF1dGgtcmVxdWlyZWQnLFxuICBNSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FID0gJ21pc3NpbmctYW5kcm9pZC1wa2ctbmFtZScsXG4gIE1JU1NJTkdfQVBQX0NSRURFTlRJQUwgPSAnbWlzc2luZy1hcHAtY3JlZGVudGlhbCcsXG4gIE1JU1NJTkdfQVVUSF9ET01BSU4gPSAnYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkJyxcbiAgTUlTU0lOR19DT0RFID0gJ21pc3NpbmctdmVyaWZpY2F0aW9uLWNvZGUnLFxuICBNSVNTSU5HX0NPTlRJTlVFX1VSSSA9ICdtaXNzaW5nLWNvbnRpbnVlLXVyaScsXG4gIE1JU1NJTkdfSUZSQU1FX1NUQVJUID0gJ21pc3NpbmctaWZyYW1lLXN0YXJ0JyxcbiAgTUlTU0lOR19JT1NfQlVORExFX0lEID0gJ21pc3NpbmctaW9zLWJ1bmRsZS1pZCcsXG4gIE1JU1NJTkdfT1JfSU5WQUxJRF9OT05DRSA9ICdtaXNzaW5nLW9yLWludmFsaWQtbm9uY2UnLFxuICBNSVNTSU5HX01GQV9JTkZPID0gJ21pc3NpbmctbXVsdGktZmFjdG9yLWluZm8nLFxuICBNSVNTSU5HX01GQV9TRVNTSU9OID0gJ21pc3NpbmctbXVsdGktZmFjdG9yLXNlc3Npb24nLFxuICBNSVNTSU5HX1BIT05FX05VTUJFUiA9ICdtaXNzaW5nLXBob25lLW51bWJlcicsXG4gIE1JU1NJTkdfUEFTU1dPUkQgPSAnbWlzc2luZy1wYXNzd29yZCcsXG4gIE1JU1NJTkdfU0VTU0lPTl9JTkZPID0gJ21pc3NpbmctdmVyaWZpY2F0aW9uLWlkJyxcbiAgTU9EVUxFX0RFU1RST1lFRCA9ICdhcHAtZGVsZXRlZCcsXG4gIE5FRURfQ09ORklSTUFUSU9OID0gJ2FjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWwnLFxuICBORVRXT1JLX1JFUVVFU1RfRkFJTEVEID0gJ25ldHdvcmstcmVxdWVzdC1mYWlsZWQnLFxuICBOVUxMX1VTRVIgPSAnbnVsbC11c2VyJyxcbiAgTk9fQVVUSF9FVkVOVCA9ICduby1hdXRoLWV2ZW50JyxcbiAgTk9fU1VDSF9QUk9WSURFUiA9ICduby1zdWNoLXByb3ZpZGVyJyxcbiAgT1BFUkFUSU9OX05PVF9BTExPV0VEID0gJ29wZXJhdGlvbi1ub3QtYWxsb3dlZCcsXG4gIE9QRVJBVElPTl9OT1RfU1VQUE9SVEVEID0gJ29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQnLFxuICBQT1BVUF9CTE9DS0VEID0gJ3BvcHVwLWJsb2NrZWQnLFxuICBQT1BVUF9DTE9TRURfQllfVVNFUiA9ICdwb3B1cC1jbG9zZWQtYnktdXNlcicsXG4gIFBST1ZJREVSX0FMUkVBRFlfTElOS0VEID0gJ3Byb3ZpZGVyLWFscmVhZHktbGlua2VkJyxcbiAgUVVPVEFfRVhDRUVERUQgPSAncXVvdGEtZXhjZWVkZWQnLFxuICBSRURJUkVDVF9DQU5DRUxMRURfQllfVVNFUiA9ICdyZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlcicsXG4gIFJFRElSRUNUX09QRVJBVElPTl9QRU5ESU5HID0gJ3JlZGlyZWN0LW9wZXJhdGlvbi1wZW5kaW5nJyxcbiAgUkVKRUNURURfQ1JFREVOVElBTCA9ICdyZWplY3RlZC1jcmVkZW50aWFsJyxcbiAgU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEID0gJ3NlY29uZC1mYWN0b3ItYWxyZWFkeS1pbi11c2UnLFxuICBTRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEID0gJ21heGltdW0tc2Vjb25kLWZhY3Rvci1jb3VudC1leGNlZWRlZCcsXG4gIFRFTkFOVF9JRF9NSVNNQVRDSCA9ICd0ZW5hbnQtaWQtbWlzbWF0Y2gnLFxuICBUSU1FT1VUID0gJ3RpbWVvdXQnLFxuICBUT0tFTl9FWFBJUkVEID0gJ3VzZXItdG9rZW4tZXhwaXJlZCcsXG4gIFRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiA9ICd0b28tbWFueS1yZXF1ZXN0cycsXG4gIFVOQVVUSE9SSVpFRF9ET01BSU4gPSAndW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaScsXG4gIFVOU1VQUE9SVEVEX0ZJUlNUX0ZBQ1RPUiA9ICd1bnN1cHBvcnRlZC1maXJzdC1mYWN0b3InLFxuICBVTlNVUFBPUlRFRF9QRVJTSVNURU5DRSA9ICd1bnN1cHBvcnRlZC1wZXJzaXN0ZW5jZS10eXBlJyxcbiAgVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTiA9ICd1bnN1cHBvcnRlZC10ZW5hbnQtb3BlcmF0aW9uJyxcbiAgVU5WRVJJRklFRF9FTUFJTCA9ICd1bnZlcmlmaWVkLWVtYWlsJyxcbiAgVVNFUl9DQU5DRUxMRUQgPSAndXNlci1jYW5jZWxsZWQnLFxuICBVU0VSX0RFTEVURUQgPSAndXNlci1ub3QtZm91bmQnLFxuICBVU0VSX0RJU0FCTEVEID0gJ3VzZXItZGlzYWJsZWQnLFxuICBVU0VSX01JU01BVENIID0gJ3VzZXItbWlzbWF0Y2gnLFxuICBVU0VSX1NJR05FRF9PVVQgPSAndXNlci1zaWduZWQtb3V0JyxcbiAgV0VBS19QQVNTV09SRCA9ICd3ZWFrLXBhc3N3b3JkJyxcbiAgV0VCX1NUT1JBR0VfVU5TVVBQT1JURUQgPSAnd2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWQnLFxuICBBTFJFQURZX0lOSVRJQUxJWkVEID0gJ2FscmVhZHktaW5pdGlhbGl6ZWQnLFxuICBSRUNBUFRDSEFfTk9UX0VOQUJMRUQgPSAncmVjYXB0Y2hhLW5vdC1lbmFibGVkJyxcbiAgTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gPSAnbWlzc2luZy1yZWNhcHRjaGEtdG9rZW4nLFxuICBJTlZBTElEX1JFQ0FQVENIQV9UT0tFTiA9ICdpbnZhbGlkLXJlY2FwdGNoYS10b2tlbicsXG4gIElOVkFMSURfUkVDQVBUQ0hBX0FDVElPTiA9ICdpbnZhbGlkLXJlY2FwdGNoYS1hY3Rpb24nLFxuICBNSVNTSU5HX0NMSUVOVF9UWVBFID0gJ21pc3NpbmctY2xpZW50LXR5cGUnLFxuICBNSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OID0gJ21pc3NpbmctcmVjYXB0Y2hhLXZlcnNpb24nLFxuICBJTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OID0gJ2ludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb24nLFxuICBJTlZBTElEX1JFUV9UWVBFID0gJ2ludmFsaWQtcmVxLXR5cGUnXG59XG5cbmZ1bmN0aW9uIF9kZWJ1Z0Vycm9yTWFwKCk6IEVycm9yTWFwPEF1dGhFcnJvckNvZGU+IHtcbiAgcmV0dXJuIHtcbiAgICBbQXV0aEVycm9yQ29kZS5BRE1JTl9PTkxZX09QRVJBVElPTl06XG4gICAgICAnVGhpcyBvcGVyYXRpb24gaXMgcmVzdHJpY3RlZCB0byBhZG1pbmlzdHJhdG9ycyBvbmx5LicsXG4gICAgW0F1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1JdOiAnJyxcbiAgICBbQXV0aEVycm9yQ29kZS5BUFBfTk9UX0FVVEhPUklaRURdOlxuICAgICAgXCJUaGlzIGFwcCwgaWRlbnRpZmllZCBieSB0aGUgZG9tYWluIHdoZXJlIGl0J3MgaG9zdGVkLCBpcyBub3QgXCIgK1xuICAgICAgJ2F1dGhvcml6ZWQgdG8gdXNlIEZpcmViYXNlIEF1dGhlbnRpY2F0aW9uIHdpdGggdGhlIHByb3ZpZGVkIEFQSSBrZXkuICcgK1xuICAgICAgJ1JldmlldyB5b3VyIGtleSBjb25maWd1cmF0aW9uIGluIHRoZSBHb29nbGUgQVBJIGNvbnNvbGUuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5BUFBfTk9UX0lOU1RBTExFRF06XG4gICAgICAnVGhlIHJlcXVlc3RlZCBtb2JpbGUgYXBwbGljYXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgaWRlbnRpZmllciAoJyArXG4gICAgICAnQW5kcm9pZCBwYWNrYWdlIG5hbWUgb3IgaU9TIGJ1bmRsZSBJRCkgcHJvdmlkZWQgaXMgbm90IGluc3RhbGxlZCBvbiAnICtcbiAgICAgICd0aGlzIGRldmljZS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkNBUFRDSEFfQ0hFQ0tfRkFJTEVEXTpcbiAgICAgICdUaGUgcmVDQVBUQ0hBIHJlc3BvbnNlIHRva2VuIHByb3ZpZGVkIGlzIGVpdGhlciBpbnZhbGlkLCBleHBpcmVkLCAnICtcbiAgICAgICdhbHJlYWR5IHVzZWQgb3IgdGhlIGRvbWFpbiBhc3NvY2lhdGVkIHdpdGggaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGxpc3QgJyArXG4gICAgICAnb2Ygd2hpdGVsaXN0ZWQgZG9tYWlucy4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkNPREVfRVhQSVJFRF06XG4gICAgICAnVGhlIFNNUyBjb2RlIGhhcyBleHBpcmVkLiBQbGVhc2UgcmUtc2VuZCB0aGUgdmVyaWZpY2F0aW9uIGNvZGUgdG8gdHJ5ICcgK1xuICAgICAgJ2FnYWluLicsXG4gICAgW0F1dGhFcnJvckNvZGUuQ09SRE9WQV9OT1RfUkVBRFldOiAnQ29yZG92YSBmcmFtZXdvcmsgaXMgbm90IHJlYWR5LicsXG4gICAgW0F1dGhFcnJvckNvZGUuQ09SU19VTlNVUFBPUlRFRF06ICdUaGlzIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0VdOlxuICAgICAgJ1RoaXMgY3JlZGVudGlhbCBpcyBhbHJlYWR5IGFzc29jaWF0ZWQgd2l0aCBhIGRpZmZlcmVudCB1c2VyIGFjY291bnQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX01JU01BVENIXTpcbiAgICAgICdUaGUgY3VzdG9tIHRva2VuIGNvcnJlc3BvbmRzIHRvIGEgZGlmZmVyZW50IGF1ZGllbmNlLicsXG4gICAgW0F1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOXTpcbiAgICAgICdUaGlzIG9wZXJhdGlvbiBpcyBzZW5zaXRpdmUgYW5kIHJlcXVpcmVzIHJlY2VudCBhdXRoZW50aWNhdGlvbi4gTG9nIGluICcgK1xuICAgICAgJ2FnYWluIGJlZm9yZSByZXRyeWluZyB0aGlzIHJlcXVlc3QuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5ERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEhdOlxuICAgICAgJ0Fub3RoZXIgRmlyZWJhc2UgU0RLIHdhcyBpbml0aWFsaXplZCBhbmQgaXMgdHJ5aW5nIHRvIHVzZSBBdXRoIGJlZm9yZSBBdXRoIGlzICcgK1xuICAgICAgJ2luaXRpYWxpemVkLiBQbGVhc2UgYmUgc3VyZSB0byBjYWxsIGBpbml0aWFsaXplQXV0aGAgb3IgYGdldEF1dGhgIGJlZm9yZSAnICtcbiAgICAgICdzdGFydGluZyBhbnkgb3RoZXIgRmlyZWJhc2UgU0RLLicsXG4gICAgW0F1dGhFcnJvckNvZGUuRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURURdOlxuICAgICAgJ1BsZWFzZSBhY3RpdmF0ZSBEeW5hbWljIExpbmtzIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlIGFuZCBhZ3JlZSB0byB0aGUgdGVybXMgYW5kICcgK1xuICAgICAgJ2NvbmRpdGlvbnMuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5FTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OXTpcbiAgICAgICdNdWx0aS1mYWN0b3IgdXNlcnMgbXVzdCBhbHdheXMgaGF2ZSBhIHZlcmlmaWVkIGVtYWlsLicsXG4gICAgW0F1dGhFcnJvckNvZGUuRU1BSUxfRVhJU1RTXTpcbiAgICAgICdUaGUgZW1haWwgYWRkcmVzcyBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIGFjY291bnQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5FTVVMQVRPUl9DT05GSUdfRkFJTEVEXTpcbiAgICAgICdBdXRoIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCB0byBtYWtlIGEgbmV0d29yayBjYWxsLiBBdXRoIGNhbiAnICtcbiAgICAgICdubyBsb25nZXIgYmUgY29uZmlndXJlZCB0byB1c2UgdGhlIGVtdWxhdG9yLiBUcnkgY2FsbGluZyAnICtcbiAgICAgICdcImNvbm5lY3RBdXRoRW11bGF0b3IoKVwiIHNvb25lci4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkVYUElSRURfT09CX0NPREVdOiAnVGhlIGFjdGlvbiBjb2RlIGhhcyBleHBpcmVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuRVhQSVJFRF9QT1BVUF9SRVFVRVNUXTpcbiAgICAgICdUaGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgZHVlIHRvIGFub3RoZXIgY29uZmxpY3RpbmcgcG9wdXAgYmVpbmcgb3BlbmVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1JdOiAnQW4gaW50ZXJuYWwgQXV0aEVycm9yIGhhcyBvY2N1cnJlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBQX0NSRURFTlRJQUxdOlxuICAgICAgJ1RoZSBwaG9uZSB2ZXJpZmljYXRpb24gcmVxdWVzdCBjb250YWlucyBhbiBpbnZhbGlkIGFwcGxpY2F0aW9uIHZlcmlmaWVyLicgK1xuICAgICAgJyBUaGUgcmVDQVBUQ0hBIHRva2VuIHJlc3BvbnNlIGlzIGVpdGhlciBpbnZhbGlkIG9yIGV4cGlyZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9JRF06XG4gICAgICAnVGhlIG1vYmlsZSBhcHAgaWRlbnRpZmllciBpcyBub3QgcmVnaXN0ZWQgZm9yIHRoZSBjdXJyZW50IHByb2plY3QuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX0FVVEhdOlxuICAgICAgXCJUaGlzIHVzZXIncyBjcmVkZW50aWFsIGlzbid0IHZhbGlkIGZvciB0aGlzIHByb2plY3QuIFRoaXMgY2FuIGhhcHBlbiBcIiArXG4gICAgICBcImlmIHRoZSB1c2VyJ3MgdG9rZW4gaGFzIGJlZW4gdGFtcGVyZWQgd2l0aCwgb3IgaWYgdGhlIHVzZXIgaXNuJ3QgZm9yIFwiICtcbiAgICAgICd0aGUgcHJvamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBBUEkga2V5LicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIX0VWRU5UXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPREVdOlxuICAgICAgJ1RoZSBTTVMgdmVyaWZpY2F0aW9uIGNvZGUgdXNlZCB0byBjcmVhdGUgdGhlIHBob25lIGF1dGggY3JlZGVudGlhbCBpcyAnICtcbiAgICAgICdpbnZhbGlkLiBQbGVhc2UgcmVzZW5kIHRoZSB2ZXJpZmljYXRpb24gY29kZSBzbXMgYW5kIGJlIHN1cmUgdG8gdXNlIHRoZSAnICtcbiAgICAgICd2ZXJpZmljYXRpb24gY29kZSBwcm92aWRlZCBieSB0aGUgdXNlci4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09OVElOVUVfVVJJXTpcbiAgICAgICdUaGUgY29udGludWUgVVJMIHByb3ZpZGVkIGluIHRoZSByZXF1ZXN0IGlzIGludmFsaWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPUkRPVkFfQ09ORklHVVJBVElPTl06XG4gICAgICAnVGhlIGZvbGxvd2luZyBDb3Jkb3ZhIHBsdWdpbnMgbXVzdCBiZSBpbnN0YWxsZWQgdG8gZW5hYmxlIE9BdXRoIHNpZ24taW46ICcgK1xuICAgICAgJ2NvcmRvdmEtcGx1Z2luLWJ1aWxkaW5mbywgY29yZG92YS11bml2ZXJzYWwtbGlua3MtcGx1Z2luLCAnICtcbiAgICAgICdjb3Jkb3ZhLXBsdWdpbi1icm93c2VydGFiLCBjb3Jkb3ZhLXBsdWdpbi1pbmFwcGJyb3dzZXIgYW5kICcgK1xuICAgICAgJ2NvcmRvdmEtcGx1Z2luLWN1c3RvbXVybHNjaGVtZS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1VTVE9NX1RPS0VOXTpcbiAgICAgICdUaGUgY3VzdG9tIHRva2VuIGZvcm1hdCBpcyBpbmNvcnJlY3QuIFBsZWFzZSBjaGVjayB0aGUgZG9jdW1lbnRhdGlvbi4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTl06XG4gICAgICAnVGhlIHByb3ZpZGVkIGR5bmFtaWMgbGluayBkb21haW4gaXMgbm90IGNvbmZpZ3VyZWQgb3IgYXV0aG9yaXplZCBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1BSUxdOiAnVGhlIGVtYWlsIGFkZHJlc3MgaXMgYmFkbHkgZm9ybWF0dGVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9FTVVMQVRPUl9TQ0hFTUVdOlxuICAgICAgJ0VtdWxhdG9yIFVSTCBtdXN0IHN0YXJ0IHdpdGggYSB2YWxpZCBzY2hlbWUgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9BUElfS0VZXTpcbiAgICAgICdZb3VyIEFQSSBrZXkgaXMgaW52YWxpZCwgcGxlYXNlIGNoZWNrIHlvdSBoYXZlIGNvcGllZCBpdCBjb3JyZWN0bHkuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX0NFUlRfSEFTSF06XG4gICAgICAnVGhlIFNIQS0xIGNlcnRpZmljYXRlIGhhc2ggcHJvdmlkZWQgaXMgaW52YWxpZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfSURQX1JFU1BPTlNFXTpcbiAgICAgICdUaGUgc3VwcGxpZWQgYXV0aCBjcmVkZW50aWFsIGlzIG1hbGZvcm1lZCBvciBoYXMgZXhwaXJlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRV9QQVlMT0FEXTpcbiAgICAgICdUaGUgZW1haWwgdGVtcGxhdGUgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gaXRzIG1lc3NhZ2UuICcgK1xuICAgICAgJ1BsZWFzZSBmaXggYnkgZ29pbmcgdG8gdGhlIEF1dGggZW1haWwgdGVtcGxhdGVzIHNlY3Rpb24gaW4gdGhlIEZpcmViYXNlIENvbnNvbGUuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX01GQV9TRVNTSU9OXTpcbiAgICAgICdUaGUgcmVxdWVzdCBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgcHJvb2Ygb2YgZmlyc3QgZmFjdG9yIHN1Y2Nlc3NmdWwgc2lnbi1pbi4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfT0FVVEhfUFJPVklERVJdOlxuICAgICAgJ0VtYWlsQXV0aFByb3ZpZGVyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgb3BlcmF0aW9uLiBUaGlzIG9wZXJhdGlvbiAnICtcbiAgICAgICdvbmx5IHN1cHBvcnRzIE9BdXRoIHByb3ZpZGVycy4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEXTpcbiAgICAgICdUaGUgT0F1dGggY2xpZW50IElEIHByb3ZpZGVkIGlzIGVpdGhlciBpbnZhbGlkIG9yIGRvZXMgbm90IG1hdGNoIHRoZSAnICtcbiAgICAgICdzcGVjaWZpZWQgQVBJIGtleS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfT1JJR0lOXTpcbiAgICAgICdUaGlzIGRvbWFpbiBpcyBub3QgYXV0aG9yaXplZCBmb3IgT0F1dGggb3BlcmF0aW9ucyBmb3IgeW91ciBGaXJlYmFzZSAnICtcbiAgICAgICdwcm9qZWN0LiBFZGl0IHRoZSBsaXN0IG9mIGF1dGhvcml6ZWQgZG9tYWlucyBmcm9tIHRoZSBGaXJlYmFzZSBjb25zb2xlLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9PT0JfQ09ERV06XG4gICAgICAnVGhlIGFjdGlvbiBjb2RlIGlzIGludmFsaWQuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgY29kZSBpcyBtYWxmb3JtZWQsICcgK1xuICAgICAgJ2V4cGlyZWQsIG9yIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfUEFTU1dPUkRdOlxuICAgICAgJ1RoZSBwYXNzd29yZCBpcyBpbnZhbGlkIG9yIHRoZSB1c2VyIGRvZXMgbm90IGhhdmUgYSBwYXNzd29yZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfUEVSU0lTVEVOQ0VdOlxuICAgICAgJ1RoZSBzcGVjaWZpZWQgcGVyc2lzdGVuY2UgdHlwZSBpcyBpbnZhbGlkLiBJdCBjYW4gb25seSBiZSBsb2NhbCwgc2Vzc2lvbiBvciBub25lLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9QSE9ORV9OVU1CRVJdOlxuICAgICAgJ1RoZSBmb3JtYXQgb2YgdGhlIHBob25lIG51bWJlciBwcm92aWRlZCBpcyBpbmNvcnJlY3QuIFBsZWFzZSBlbnRlciB0aGUgJyArXG4gICAgICAncGhvbmUgbnVtYmVyIGluIGEgZm9ybWF0IHRoYXQgY2FuIGJlIHBhcnNlZCBpbnRvIEUuMTY0IGZvcm1hdC4gRS4xNjQgJyArXG4gICAgICAncGhvbmUgbnVtYmVycyBhcmUgd3JpdHRlbiBpbiB0aGUgZm9ybWF0IFsrXVtjb3VudHJ5IGNvZGVdW3N1YnNjcmliZXIgJyArXG4gICAgICAnbnVtYmVyIGluY2x1ZGluZyBhcmVhIGNvZGVdLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9QUk9WSURFUl9JRF06XG4gICAgICAnVGhlIHNwZWNpZmllZCBwcm92aWRlciBJRCBpcyBpbnZhbGlkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNJUElFTlRfRU1BSUxdOlxuICAgICAgJ1RoZSBlbWFpbCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYWN0aW9uIGZhaWxlZCB0byBzZW5kIGFzIHRoZSBwcm92aWRlZCAnICtcbiAgICAgICdyZWNpcGllbnQgZW1haWwgYWRkcmVzcyBpcyBpbnZhbGlkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9TRU5ERVJdOlxuICAgICAgJ1RoZSBlbWFpbCB0ZW1wbGF0ZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYWN0aW9uIGNvbnRhaW5zIGFuIGludmFsaWQgc2VuZGVyIGVtYWlsIG9yIG5hbWUuICcgK1xuICAgICAgJ1BsZWFzZSBmaXggYnkgZ29pbmcgdG8gdGhlIEF1dGggZW1haWwgdGVtcGxhdGVzIHNlY3Rpb24gaW4gdGhlIEZpcmViYXNlIENvbnNvbGUuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX1NFU1NJT05fSU5GT106XG4gICAgICAnVGhlIHZlcmlmaWNhdGlvbiBJRCB1c2VkIHRvIGNyZWF0ZSB0aGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIGlzIGludmFsaWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX1RFTkFOVF9JRF06XG4gICAgICBcIlRoZSBBdXRoIGluc3RhbmNlJ3MgdGVuYW50IElEIGlzIGludmFsaWQuXCIsXG4gICAgW0F1dGhFcnJvckNvZGUuTE9HSU5fQkxPQ0tFRF06XG4gICAgICAnTG9naW4gYmxvY2tlZCBieSB1c2VyLXByb3ZpZGVkIG1ldGhvZDogeyRvcmlnaW5hbE1lc3NhZ2V9JyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FXTpcbiAgICAgICdBbiBBbmRyb2lkIFBhY2thZ2UgTmFtZSBtdXN0IGJlIHByb3ZpZGVkIGlmIHRoZSBBbmRyb2lkIEFwcCBpcyByZXF1aXJlZCB0byBiZSBpbnN0YWxsZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FVVEhfRE9NQUlOXTpcbiAgICAgICdCZSBzdXJlIHRvIGluY2x1ZGUgYXV0aERvbWFpbiB3aGVuIGNhbGxpbmcgZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcCgpLCAnICtcbiAgICAgICdieSBmb2xsb3dpbmcgdGhlIGluc3RydWN0aW9ucyBpbiB0aGUgRmlyZWJhc2UgY29uc29sZS4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQVBQX0NSRURFTlRJQUxdOlxuICAgICAgJ1RoZSBwaG9uZSB2ZXJpZmljYXRpb24gcmVxdWVzdCBpcyBtaXNzaW5nIGFuIGFwcGxpY2F0aW9uIHZlcmlmaWVyICcgK1xuICAgICAgJ2Fzc2VydGlvbi4gQSByZUNBUFRDSEEgcmVzcG9uc2UgdG9rZW4gbmVlZHMgdG8gYmUgcHJvdmlkZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX0NPREVdOlxuICAgICAgJ1RoZSBwaG9uZSBhdXRoIGNyZWRlbnRpYWwgd2FzIGNyZWF0ZWQgd2l0aCBhbiBlbXB0eSBTTVMgdmVyaWZpY2F0aW9uIGNvZGUuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX0NPTlRJTlVFX1VSSV06XG4gICAgICAnQSBjb250aW51ZSBVUkwgbXVzdCBiZSBwcm92aWRlZCBpbiB0aGUgcmVxdWVzdC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk1JU1NJTkdfSUZSQU1FX1NUQVJUXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX0lPU19CVU5ETEVfSURdOlxuICAgICAgJ0FuIGlPUyBCdW5kbGUgSUQgbXVzdCBiZSBwcm92aWRlZCBpZiBhbiBBcHAgU3RvcmUgSUQgaXMgcHJvdmlkZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX09SX0lOVkFMSURfTk9OQ0VdOlxuICAgICAgJ1RoZSByZXF1ZXN0IGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCBub25jZS4gVGhpcyBjYW4gb2NjdXIgaWYgdGhlICcgK1xuICAgICAgJ1NIQS0yNTYgaGFzaCBvZiB0aGUgcHJvdmlkZWQgcmF3IG5vbmNlIGRvZXMgbm90IG1hdGNoIHRoZSBoYXNoZWQgbm9uY2UgJyArXG4gICAgICAnaW4gdGhlIElEIHRva2VuIHBheWxvYWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX1BBU1NXT1JEXTogJ0Egbm9uLWVtcHR5IHBhc3N3b3JkIG11c3QgYmUgcHJvdmlkZWQnLFxuICAgIFtBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX0lORk9dOlxuICAgICAgJ05vIHNlY29uZCBmYWN0b3IgaWRlbnRpZmllciBpcyBwcm92aWRlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX1NFU1NJT05dOlxuICAgICAgJ1RoZSByZXF1ZXN0IGlzIG1pc3NpbmcgcHJvb2Ygb2YgZmlyc3QgZmFjdG9yIHN1Y2Nlc3NmdWwgc2lnbi1pbi4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUEhPTkVfTlVNQkVSXTpcbiAgICAgICdUbyBzZW5kIHZlcmlmaWNhdGlvbiBjb2RlcywgcHJvdmlkZSBhIHBob25lIG51bWJlciBmb3IgdGhlIHJlY2lwaWVudC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk1JU1NJTkdfU0VTU0lPTl9JTkZPXTpcbiAgICAgICdUaGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIHdhcyBjcmVhdGVkIHdpdGggYW4gZW1wdHkgdmVyaWZpY2F0aW9uIElELicsXG4gICAgW0F1dGhFcnJvckNvZGUuTU9EVUxFX0RFU1RST1lFRF06XG4gICAgICAnVGhpcyBpbnN0YW5jZSBvZiBGaXJlYmFzZUFwcCBoYXMgYmVlbiBkZWxldGVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTUZBX0lORk9fTk9UX0ZPVU5EXTpcbiAgICAgICdUaGUgdXNlciBkb2VzIG5vdCBoYXZlIGEgc2Vjb25kIGZhY3RvciBtYXRjaGluZyB0aGUgaWRlbnRpZmllciBwcm92aWRlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLk1GQV9SRVFVSVJFRF06XG4gICAgICAnUHJvb2Ygb2Ygb3duZXJzaGlwIG9mIGEgc2Vjb25kIGZhY3RvciBpcyByZXF1aXJlZCB0byBjb21wbGV0ZSBzaWduLWluLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTkVFRF9DT05GSVJNQVRJT05dOlxuICAgICAgJ0FuIGFjY291bnQgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGUgc2FtZSBlbWFpbCBhZGRyZXNzIGJ1dCBkaWZmZXJlbnQgJyArXG4gICAgICAnc2lnbi1pbiBjcmVkZW50aWFscy4gU2lnbiBpbiB1c2luZyBhIHByb3ZpZGVyIGFzc29jaWF0ZWQgd2l0aCB0aGlzICcgK1xuICAgICAgJ2VtYWlsIGFkZHJlc3MuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEXTpcbiAgICAgICdBIG5ldHdvcmsgQXV0aEVycm9yIChzdWNoIGFzIHRpbWVvdXQsIGludGVycnVwdGVkIGNvbm5lY3Rpb24gb3IgdW5yZWFjaGFibGUgaG9zdCkgaGFzIG9jY3VycmVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTk9fQVVUSF9FVkVOVF06ICdBbiBpbnRlcm5hbCBBdXRoRXJyb3IgaGFzIG9jY3VycmVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTk9fU1VDSF9QUk9WSURFUl06XG4gICAgICAnVXNlciB3YXMgbm90IGxpbmtlZCB0byBhbiBhY2NvdW50IHdpdGggdGhlIGdpdmVuIHByb3ZpZGVyLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTlVMTF9VU0VSXTpcbiAgICAgICdBIG51bGwgdXNlciBvYmplY3Qgd2FzIHByb3ZpZGVkIGFzIHRoZSBhcmd1bWVudCBmb3IgYW4gb3BlcmF0aW9uIHdoaWNoICcgK1xuICAgICAgJ3JlcXVpcmVzIGEgbm9uLW51bGwgdXNlciBvYmplY3QuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX0FMTE9XRURdOlxuICAgICAgJ1RoZSBnaXZlbiBzaWduLWluIHByb3ZpZGVyIGlzIGRpc2FibGVkIGZvciB0aGlzIEZpcmViYXNlIHByb2plY3QuICcgK1xuICAgICAgJ0VuYWJsZSBpdCBpbiB0aGUgRmlyZWJhc2UgY29uc29sZSwgdW5kZXIgdGhlIHNpZ24taW4gbWV0aG9kIHRhYiBvZiB0aGUgJyArXG4gICAgICAnQXV0aCBzZWN0aW9uLicsXG4gICAgW0F1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9TVVBQT1JURURdOlxuICAgICAgJ1RoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGVudmlyb25tZW50IHRoaXMgYXBwbGljYXRpb24gaXMgJyArXG4gICAgICAncnVubmluZyBvbi4gXCJsb2NhdGlvbi5wcm90b2NvbFwiIG11c3QgYmUgaHR0cCwgaHR0cHMgb3IgY2hyb21lLWV4dGVuc2lvbicgK1xuICAgICAgJyBhbmQgd2ViIHN0b3JhZ2UgbXVzdCBiZSBlbmFibGVkLicsXG4gICAgW0F1dGhFcnJvckNvZGUuUE9QVVBfQkxPQ0tFRF06XG4gICAgICAnVW5hYmxlIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgcG9wdXAuIEl0IG1heSBoYXZlIGJlZW4gYmxvY2tlZCBieSB0aGUgYnJvd3Nlci4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLlBPUFVQX0NMT1NFRF9CWV9VU0VSXTpcbiAgICAgICdUaGUgcG9wdXAgaGFzIGJlZW4gY2xvc2VkIGJ5IHRoZSB1c2VyIGJlZm9yZSBmaW5hbGl6aW5nIHRoZSBvcGVyYXRpb24uJyxcbiAgICBbQXV0aEVycm9yQ29kZS5QUk9WSURFUl9BTFJFQURZX0xJTktFRF06XG4gICAgICAnVXNlciBjYW4gb25seSBiZSBsaW5rZWQgdG8gb25lIGlkZW50aXR5IGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5RVU9UQV9FWENFRURFRF06XG4gICAgICBcIlRoZSBwcm9qZWN0J3MgcXVvdGEgZm9yIHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIGV4Y2VlZGVkLlwiLFxuICAgIFtBdXRoRXJyb3JDb2RlLlJFRElSRUNUX0NBTkNFTExFRF9CWV9VU0VSXTpcbiAgICAgICdUaGUgcmVkaXJlY3Qgb3BlcmF0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCBieSB0aGUgdXNlciBiZWZvcmUgZmluYWxpemluZy4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLlJFRElSRUNUX09QRVJBVElPTl9QRU5ESU5HXTpcbiAgICAgICdBIHJlZGlyZWN0IHNpZ24taW4gb3BlcmF0aW9uIGlzIGFscmVhZHkgcGVuZGluZy4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLlJFSkVDVEVEX0NSRURFTlRJQUxdOlxuICAgICAgJ1RoZSByZXF1ZXN0IGNvbnRhaW5zIG1hbGZvcm1lZCBvciBtaXNtYXRjaGluZyBjcmVkZW50aWFscy4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLlNFQ09ORF9GQUNUT1JfQUxSRUFEWV9FTlJPTExFRF06XG4gICAgICAnVGhlIHNlY29uZCBmYWN0b3IgaXMgYWxyZWFkeSBlbnJvbGxlZCBvbiB0aGlzIGFjY291bnQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEXTpcbiAgICAgICdUaGUgbWF4aW11bSBhbGxvd2VkIG51bWJlciBvZiBzZWNvbmQgZmFjdG9ycyBvbiBhIHVzZXIgaGFzIGJlZW4gZXhjZWVkZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5URU5BTlRfSURfTUlTTUFUQ0hdOlxuICAgICAgXCJUaGUgcHJvdmlkZWQgdGVuYW50IElEIGRvZXMgbm90IG1hdGNoIHRoZSBBdXRoIGluc3RhbmNlJ3MgdGVuYW50IElEXCIsXG4gICAgW0F1dGhFcnJvckNvZGUuVElNRU9VVF06ICdUaGUgb3BlcmF0aW9uIGhhcyB0aW1lZCBvdXQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVEXTpcbiAgICAgIFwiVGhlIHVzZXIncyBjcmVkZW50aWFsIGlzIG5vIGxvbmdlciB2YWxpZC4gVGhlIHVzZXIgbXVzdCBzaWduIGluIGFnYWluLlwiLFxuICAgIFtBdXRoRXJyb3JDb2RlLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUl06XG4gICAgICAnV2UgaGF2ZSBibG9ja2VkIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgZGV2aWNlIGR1ZSB0byB1bnVzdWFsIGFjdGl2aXR5LiAnICtcbiAgICAgICdUcnkgYWdhaW4gbGF0ZXIuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5VTkFVVEhPUklaRURfRE9NQUlOXTpcbiAgICAgICdUaGUgZG9tYWluIG9mIHRoZSBjb250aW51ZSBVUkwgaXMgbm90IHdoaXRlbGlzdGVkLiAgUGxlYXNlIHdoaXRlbGlzdCAnICtcbiAgICAgICd0aGUgZG9tYWluIGluIHRoZSBGaXJlYmFzZSBjb25zb2xlLicsXG4gICAgW0F1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfRklSU1RfRkFDVE9SXTpcbiAgICAgICdFbnJvbGxpbmcgYSBzZWNvbmQgZmFjdG9yIG9yIHNpZ25pbmcgaW4gd2l0aCBhIG11bHRpLWZhY3RvciBhY2NvdW50IHJlcXVpcmVzIHNpZ24taW4gd2l0aCBhIHN1cHBvcnRlZCBmaXJzdCBmYWN0b3IuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5VTlNVUFBPUlRFRF9QRVJTSVNURU5DRV06XG4gICAgICAnVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgc3BlY2lmaWVkIHBlcnNpc3RlbmNlIHR5cGUuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5VTlNVUFBPUlRFRF9URU5BTlRfT1BFUkFUSU9OXTpcbiAgICAgICdUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIGEgbXVsdGktdGVuYW50IGNvbnRleHQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5VTlZFUklGSUVEX0VNQUlMXTpcbiAgICAgICdUaGUgb3BlcmF0aW9uIHJlcXVpcmVzIGEgdmVyaWZpZWQgZW1haWwuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5VU0VSX0NBTkNFTExFRF06XG4gICAgICAnVGhlIHVzZXIgZGlkIG5vdCBncmFudCB5b3VyIGFwcGxpY2F0aW9uIHRoZSBwZXJtaXNzaW9ucyBpdCByZXF1ZXN0ZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURURdOlxuICAgICAgJ1RoZXJlIGlzIG5vIHVzZXIgcmVjb3JkIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpZGVudGlmaWVyLiBUaGUgdXNlciBtYXkgJyArXG4gICAgICAnaGF2ZSBiZWVuIGRlbGV0ZWQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5VU0VSX0RJU0FCTEVEXTpcbiAgICAgICdUaGUgdXNlciBhY2NvdW50IGhhcyBiZWVuIGRpc2FibGVkIGJ5IGFuIGFkbWluaXN0cmF0b3IuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIXTpcbiAgICAgICdUaGUgc3VwcGxpZWQgY3JlZGVudGlhbHMgZG8gbm90IGNvcnJlc3BvbmQgdG8gdGhlIHByZXZpb3VzbHkgc2lnbmVkIGluIHVzZXIuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5VU0VSX1NJR05FRF9PVVRdOiAnJyxcbiAgICBbQXV0aEVycm9yQ29kZS5XRUFLX1BBU1NXT1JEXTpcbiAgICAgICdUaGUgcGFzc3dvcmQgbXVzdCBiZSA2IGNoYXJhY3RlcnMgbG9uZyBvciBtb3JlLicsXG4gICAgW0F1dGhFcnJvckNvZGUuV0VCX1NUT1JBR0VfVU5TVVBQT1JURURdOlxuICAgICAgJ1RoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkIG9yIDNyZCBwYXJ0eSBjb29raWVzIGFuZCBkYXRhIG1heSBiZSBkaXNhYmxlZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLkFMUkVBRFlfSU5JVElBTElaRURdOlxuICAgICAgJ2luaXRpYWxpemVBdXRoKCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgd2l0aCAnICtcbiAgICAgICdkaWZmZXJlbnQgb3B0aW9ucy4gVG8gYXZvaWQgdGhpcyBlcnJvciwgY2FsbCBpbml0aWFsaXplQXV0aCgpIHdpdGggdGhlICcgK1xuICAgICAgJ3NhbWUgb3B0aW9ucyBhcyB3aGVuIGl0IHdhcyBvcmlnaW5hbGx5IGNhbGxlZCwgb3IgY2FsbCBnZXRBdXRoKCkgdG8gcmV0dXJuIHRoZScgK1xuICAgICAgJyBhbHJlYWR5IGluaXRpYWxpemVkIGluc3RhbmNlLicsXG4gICAgW0F1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU5dOlxuICAgICAgJ1RoZSByZUNBUFRDSEEgdG9rZW4gaXMgbWlzc2luZyB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOXTpcbiAgICAgICdUaGUgcmVDQVBUQ0hBIHRva2VuIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9BQ1RJT05dOlxuICAgICAgJ1RoZSByZUNBUFRDSEEgYWN0aW9uIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5SRUNBUFRDSEFfTk9UX0VOQUJMRURdOlxuICAgICAgJ3JlQ0FQVENIQSBFbnRlcnByaXNlIGludGVncmF0aW9uIGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIHByb2plY3QuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX0NMSUVOVF9UWVBFXTpcbiAgICAgICdUaGUgcmVDQVBUQ0hBIGNsaWVudCB0eXBlIGlzIG1pc3Npbmcgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OXTpcbiAgICAgICdUaGUgcmVDQVBUQ0hBIHZlcnNpb24gaXMgbWlzc2luZyB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxuICAgIFtBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVRX1RZUEVdOiAnSW52YWxpZCByZXF1ZXN0IHBhcmFtZXRlcnMuJyxcbiAgICBbQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OXTpcbiAgICAgICdUaGUgcmVDQVBUQ0hBIHZlcnNpb24gaXMgaW52YWxpZCB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nXG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JNYXBSZXRyaWV2ZXIgZXh0ZW5kcyBBdXRoRXJyb3JNYXAge1xuICAoKTogRXJyb3JNYXA8QXV0aEVycm9yQ29kZT47XG59XG5cbmZ1bmN0aW9uIF9wcm9kRXJyb3JNYXAoKTogRXJyb3JNYXA8QXV0aEVycm9yQ29kZT4ge1xuICAvLyBXZSB3aWxsIGluY2x1ZGUgdGhpcyBvbmUgbWVzc2FnZSBpbiB0aGUgcHJvZCBlcnJvciBtYXAgc2luY2UgYnkgdGhlIHZlcnlcbiAgLy8gbmF0dXJlIG9mIHRoaXMgZXJyb3IsIGRldmVsb3BlcnMgd2lsbCBuZXZlciBiZSBhYmxlIHRvIHNlZSB0aGUgbWVzc2FnZVxuICAvLyB1c2luZyB0aGUgZGVidWdFcnJvck1hcCAod2hpY2ggaXMgaW5zdGFsbGVkIGR1cmluZyBhdXRoIGluaXRpYWxpemF0aW9uKS5cbiAgcmV0dXJuIHtcbiAgICBbQXV0aEVycm9yQ29kZS5ERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEhdOlxuICAgICAgJ0Fub3RoZXIgRmlyZWJhc2UgU0RLIHdhcyBpbml0aWFsaXplZCBhbmQgaXMgdHJ5aW5nIHRvIHVzZSBBdXRoIGJlZm9yZSBBdXRoIGlzICcgK1xuICAgICAgJ2luaXRpYWxpemVkLiBQbGVhc2UgYmUgc3VyZSB0byBjYWxsIGBpbml0aWFsaXplQXV0aGAgb3IgYGdldEF1dGhgIGJlZm9yZSAnICtcbiAgICAgICdzdGFydGluZyBhbnkgb3RoZXIgRmlyZWJhc2UgU0RLLidcbiAgfSBhcyBFcnJvck1hcDxBdXRoRXJyb3JDb2RlPjtcbn1cblxuLyoqXG4gKiBBIHZlcmJvc2UgZXJyb3IgbWFwIHdpdGggZGV0YWlsZWQgZGVzY3JpcHRpb25zIGZvciBtb3N0IGVycm9yIGNvZGVzLlxuICpcbiAqIFNlZSBkaXNjdXNzaW9uIGF0IHtAbGluayBBdXRoRXJyb3JNYXB9XG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgZGVidWdFcnJvck1hcDogQXV0aEVycm9yTWFwID0gX2RlYnVnRXJyb3JNYXA7XG5cbi8qKlxuICogQSBtaW5pbWFsIGVycm9yIG1hcCB3aXRoIGFsbCB2ZXJib3NlIGVycm9yIG1lc3NhZ2VzIHN0cmlwcGVkLlxuICpcbiAqIFNlZSBkaXNjdXNzaW9uIGF0IHtAbGluayBBdXRoRXJyb3JNYXB9XG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcHJvZEVycm9yTWFwOiBBdXRoRXJyb3JNYXAgPSBfcHJvZEVycm9yTWFwO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVkRXJyb3JQYXJhbXMge1xuICBhcHBOYW1lOiBBcHBOYW1lO1xuICBjcmVkZW50aWFsPzogQXV0aENyZWRlbnRpYWw7XG4gIGVtYWlsPzogc3RyaW5nO1xuICBwaG9uZU51bWJlcj86IHN0cmluZztcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG4gIHVzZXI/OiBVc2VyO1xuICBfc2VydmVyUmVzcG9uc2U/OiBvYmplY3Q7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbnR5cGUgR2VuZXJpY0F1dGhFcnJvclBhcmFtcyA9IHtcbiAgW2tleSBpbiBFeGNsdWRlPFxuICAgIEF1dGhFcnJvckNvZGUsXG4gICAgfCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SXG4gICAgfCBBdXRoRXJyb3JDb2RlLkRFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSFxuICAgIHwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUlxuICAgIHwgQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRURcbiAgICB8IEF1dGhFcnJvckNvZGUuTk9fQVVUSF9FVkVOVFxuICAgIHwgQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX1NVUFBPUlRFRFxuICA+XToge1xuICAgIGFwcE5hbWU/OiBBcHBOYW1lO1xuICAgIGVtYWlsPzogc3RyaW5nO1xuICAgIHBob25lTnVtYmVyPzogc3RyaW5nO1xuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIH07XG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhFcnJvclBhcmFtcyBleHRlbmRzIEdlbmVyaWNBdXRoRXJyb3JQYXJhbXMge1xuICBbQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUl06IHsgYXBwTmFtZT86IEFwcE5hbWUgfTtcbiAgW0F1dGhFcnJvckNvZGUuREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIXTogeyBhcHBOYW1lPzogQXBwTmFtZSB9O1xuICBbQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUl06IHsgYXBwTmFtZT86IEFwcE5hbWUgfTtcbiAgW0F1dGhFcnJvckNvZGUuTE9HSU5fQkxPQ0tFRF06IHtcbiAgICBhcHBOYW1lPzogQXBwTmFtZTtcbiAgICBvcmlnaW5hbE1lc3NhZ2U/OiBzdHJpbmc7XG4gIH07XG4gIFtBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEXTogeyBhcHBOYW1lPzogQXBwTmFtZSB9O1xuICBbQXV0aEVycm9yQ29kZS5OT19BVVRIX0VWRU5UXTogeyBhcHBOYW1lPzogQXBwTmFtZSB9O1xuICBbQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRURdOiB7XG4gICAgYXBwTmFtZTogQXBwTmFtZTtcbiAgICBfc2VydmVyUmVzcG9uc2U6IElkVG9rZW5NZmFSZXNwb25zZTtcbiAgfTtcbiAgW0F1dGhFcnJvckNvZGUuSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT05dOiB7XG4gICAgYXBwTmFtZTogQXBwTmFtZTtcbiAgICBtaXNzaW5nUGx1Z2luPzogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgX0RFRkFVTFRfQVVUSF9FUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeTxcbiAgQXV0aEVycm9yQ29kZSxcbiAgQXV0aEVycm9yUGFyYW1zXG4+KCdhdXRoJywgJ0ZpcmViYXNlJywgX3Byb2RFcnJvck1hcCgpKTtcblxuLyoqXG4gKiBBIG1hcCBvZiBwb3RlbnRpYWwgYEF1dGhgIGVycm9yIGNvZGVzLCBmb3IgZWFzaWVyIGNvbXBhcmlzb24gd2l0aCBlcnJvcnNcbiAqIHRocm93biBieSB0aGUgU0RLLlxuICpcbiAqIEByZW1hcmtzXG4gKiBOb3RlIHRoYXQgeW91IGNhbid0IHRyZWUtc2hha2UgaW5kaXZpZHVhbCBrZXlzXG4gKiBpbiB0aGUgbWFwLCBzbyBieSB1c2luZyB0aGUgbWFwIHlvdSBtaWdodCBzdWJzdGFudGlhbGx5IGluY3JlYXNlIHlvdXJcbiAqIGJ1bmRsZSBzaXplLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IEFVVEhfRVJST1JfQ09ERVNfTUFQX0RPX05PVF9VU0VfSU5URVJOQUxMWSA9IHtcbiAgQURNSU5fT05MWV9PUEVSQVRJT046ICdhdXRoL2FkbWluLXJlc3RyaWN0ZWQtb3BlcmF0aW9uJyxcbiAgQVJHVU1FTlRfRVJST1I6ICdhdXRoL2FyZ3VtZW50LWVycm9yJyxcbiAgQVBQX05PVF9BVVRIT1JJWkVEOiAnYXV0aC9hcHAtbm90LWF1dGhvcml6ZWQnLFxuICBBUFBfTk9UX0lOU1RBTExFRDogJ2F1dGgvYXBwLW5vdC1pbnN0YWxsZWQnLFxuICBDQVBUQ0hBX0NIRUNLX0ZBSUxFRDogJ2F1dGgvY2FwdGNoYS1jaGVjay1mYWlsZWQnLFxuICBDT0RFX0VYUElSRUQ6ICdhdXRoL2NvZGUtZXhwaXJlZCcsXG4gIENPUkRPVkFfTk9UX1JFQURZOiAnYXV0aC9jb3Jkb3ZhLW5vdC1yZWFkeScsXG4gIENPUlNfVU5TVVBQT1JURUQ6ICdhdXRoL2NvcnMtdW5zdXBwb3J0ZWQnLFxuICBDUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFOiAnYXV0aC9jcmVkZW50aWFsLWFscmVhZHktaW4tdXNlJyxcbiAgQ1JFREVOVElBTF9NSVNNQVRDSDogJ2F1dGgvY3VzdG9tLXRva2VuLW1pc21hdGNoJyxcbiAgQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOOiAnYXV0aC9yZXF1aXJlcy1yZWNlbnQtbG9naW4nLFxuICBERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEg6ICdhdXRoL2RlcGVuZGVudC1zZGstaW5pdGlhbGl6ZWQtYmVmb3JlLWF1dGgnLFxuICBEWU5BTUlDX0xJTktfTk9UX0FDVElWQVRFRDogJ2F1dGgvZHluYW1pYy1saW5rLW5vdC1hY3RpdmF0ZWQnLFxuICBFTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OOiAnYXV0aC9lbWFpbC1jaGFuZ2UtbmVlZHMtdmVyaWZpY2F0aW9uJyxcbiAgRU1BSUxfRVhJU1RTOiAnYXV0aC9lbWFpbC1hbHJlYWR5LWluLXVzZScsXG4gIEVNVUxBVE9SX0NPTkZJR19GQUlMRUQ6ICdhdXRoL2VtdWxhdG9yLWNvbmZpZy1mYWlsZWQnLFxuICBFWFBJUkVEX09PQl9DT0RFOiAnYXV0aC9leHBpcmVkLWFjdGlvbi1jb2RlJyxcbiAgRVhQSVJFRF9QT1BVUF9SRVFVRVNUOiAnYXV0aC9jYW5jZWxsZWQtcG9wdXAtcmVxdWVzdCcsXG4gIElOVEVSTkFMX0VSUk9SOiAnYXV0aC9pbnRlcm5hbC1lcnJvcicsXG4gIElOVkFMSURfQVBJX0tFWTogJ2F1dGgvaW52YWxpZC1hcGkta2V5JyxcbiAgSU5WQUxJRF9BUFBfQ1JFREVOVElBTDogJ2F1dGgvaW52YWxpZC1hcHAtY3JlZGVudGlhbCcsXG4gIElOVkFMSURfQVBQX0lEOiAnYXV0aC9pbnZhbGlkLWFwcC1pZCcsXG4gIElOVkFMSURfQVVUSDogJ2F1dGgvaW52YWxpZC11c2VyLXRva2VuJyxcbiAgSU5WQUxJRF9BVVRIX0VWRU5UOiAnYXV0aC9pbnZhbGlkLWF1dGgtZXZlbnQnLFxuICBJTlZBTElEX0NFUlRfSEFTSDogJ2F1dGgvaW52YWxpZC1jZXJ0LWhhc2gnLFxuICBJTlZBTElEX0NPREU6ICdhdXRoL2ludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGUnLFxuICBJTlZBTElEX0NPTlRJTlVFX1VSSTogJ2F1dGgvaW52YWxpZC1jb250aW51ZS11cmknLFxuICBJTlZBTElEX0NPUkRPVkFfQ09ORklHVVJBVElPTjogJ2F1dGgvaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb24nLFxuICBJTlZBTElEX0NVU1RPTV9UT0tFTjogJ2F1dGgvaW52YWxpZC1jdXN0b20tdG9rZW4nLFxuICBJTlZBTElEX0RZTkFNSUNfTElOS19ET01BSU46ICdhdXRoL2ludmFsaWQtZHluYW1pYy1saW5rLWRvbWFpbicsXG4gIElOVkFMSURfRU1BSUw6ICdhdXRoL2ludmFsaWQtZW1haWwnLFxuICBJTlZBTElEX0VNVUxBVE9SX1NDSEVNRTogJ2F1dGgvaW52YWxpZC1lbXVsYXRvci1zY2hlbWUnLFxuICBJTlZBTElEX0lEUF9SRVNQT05TRTogJ2F1dGgvaW52YWxpZC1jcmVkZW50aWFsJyxcbiAgSU5WQUxJRF9NRVNTQUdFX1BBWUxPQUQ6ICdhdXRoL2ludmFsaWQtbWVzc2FnZS1wYXlsb2FkJyxcbiAgSU5WQUxJRF9NRkFfU0VTU0lPTjogJ2F1dGgvaW52YWxpZC1tdWx0aS1mYWN0b3Itc2Vzc2lvbicsXG4gIElOVkFMSURfT0FVVEhfQ0xJRU5UX0lEOiAnYXV0aC9pbnZhbGlkLW9hdXRoLWNsaWVudC1pZCcsXG4gIElOVkFMSURfT0FVVEhfUFJPVklERVI6ICdhdXRoL2ludmFsaWQtb2F1dGgtcHJvdmlkZXInLFxuICBJTlZBTElEX09PQl9DT0RFOiAnYXV0aC9pbnZhbGlkLWFjdGlvbi1jb2RlJyxcbiAgSU5WQUxJRF9PUklHSU46ICdhdXRoL3VuYXV0aG9yaXplZC1kb21haW4nLFxuICBJTlZBTElEX1BBU1NXT1JEOiAnYXV0aC93cm9uZy1wYXNzd29yZCcsXG4gIElOVkFMSURfUEVSU0lTVEVOQ0U6ICdhdXRoL2ludmFsaWQtcGVyc2lzdGVuY2UtdHlwZScsXG4gIElOVkFMSURfUEhPTkVfTlVNQkVSOiAnYXV0aC9pbnZhbGlkLXBob25lLW51bWJlcicsXG4gIElOVkFMSURfUFJPVklERVJfSUQ6ICdhdXRoL2ludmFsaWQtcHJvdmlkZXItaWQnLFxuICBJTlZBTElEX1JFQ0lQSUVOVF9FTUFJTDogJ2F1dGgvaW52YWxpZC1yZWNpcGllbnQtZW1haWwnLFxuICBJTlZBTElEX1NFTkRFUjogJ2F1dGgvaW52YWxpZC1zZW5kZXInLFxuICBJTlZBTElEX1NFU1NJT05fSU5GTzogJ2F1dGgvaW52YWxpZC12ZXJpZmljYXRpb24taWQnLFxuICBJTlZBTElEX1RFTkFOVF9JRDogJ2F1dGgvaW52YWxpZC10ZW5hbnQtaWQnLFxuICBNRkFfSU5GT19OT1RfRk9VTkQ6ICdhdXRoL211bHRpLWZhY3Rvci1pbmZvLW5vdC1mb3VuZCcsXG4gIE1GQV9SRVFVSVJFRDogJ2F1dGgvbXVsdGktZmFjdG9yLWF1dGgtcmVxdWlyZWQnLFxuICBNSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FOiAnYXV0aC9taXNzaW5nLWFuZHJvaWQtcGtnLW5hbWUnLFxuICBNSVNTSU5HX0FQUF9DUkVERU5USUFMOiAnYXV0aC9taXNzaW5nLWFwcC1jcmVkZW50aWFsJyxcbiAgTUlTU0lOR19BVVRIX0RPTUFJTjogJ2F1dGgvYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkJyxcbiAgTUlTU0lOR19DT0RFOiAnYXV0aC9taXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlJyxcbiAgTUlTU0lOR19DT05USU5VRV9VUkk6ICdhdXRoL21pc3NpbmctY29udGludWUtdXJpJyxcbiAgTUlTU0lOR19JRlJBTUVfU1RBUlQ6ICdhdXRoL21pc3NpbmctaWZyYW1lLXN0YXJ0JyxcbiAgTUlTU0lOR19JT1NfQlVORExFX0lEOiAnYXV0aC9taXNzaW5nLWlvcy1idW5kbGUtaWQnLFxuICBNSVNTSU5HX09SX0lOVkFMSURfTk9OQ0U6ICdhdXRoL21pc3Npbmctb3ItaW52YWxpZC1ub25jZScsXG4gIE1JU1NJTkdfTUZBX0lORk86ICdhdXRoL21pc3NpbmctbXVsdGktZmFjdG9yLWluZm8nLFxuICBNSVNTSU5HX01GQV9TRVNTSU9OOiAnYXV0aC9taXNzaW5nLW11bHRpLWZhY3Rvci1zZXNzaW9uJyxcbiAgTUlTU0lOR19QSE9ORV9OVU1CRVI6ICdhdXRoL21pc3NpbmctcGhvbmUtbnVtYmVyJyxcbiAgTUlTU0lOR19TRVNTSU9OX0lORk86ICdhdXRoL21pc3NpbmctdmVyaWZpY2F0aW9uLWlkJyxcbiAgTU9EVUxFX0RFU1RST1lFRDogJ2F1dGgvYXBwLWRlbGV0ZWQnLFxuICBORUVEX0NPTkZJUk1BVElPTjogJ2F1dGgvYWNjb3VudC1leGlzdHMtd2l0aC1kaWZmZXJlbnQtY3JlZGVudGlhbCcsXG4gIE5FVFdPUktfUkVRVUVTVF9GQUlMRUQ6ICdhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWQnLFxuICBOVUxMX1VTRVI6ICdhdXRoL251bGwtdXNlcicsXG4gIE5PX0FVVEhfRVZFTlQ6ICdhdXRoL25vLWF1dGgtZXZlbnQnLFxuICBOT19TVUNIX1BST1ZJREVSOiAnYXV0aC9uby1zdWNoLXByb3ZpZGVyJyxcbiAgT1BFUkFUSU9OX05PVF9BTExPV0VEOiAnYXV0aC9vcGVyYXRpb24tbm90LWFsbG93ZWQnLFxuICBPUEVSQVRJT05fTk9UX1NVUFBPUlRFRDogJ2F1dGgvb3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudCcsXG4gIFBPUFVQX0JMT0NLRUQ6ICdhdXRoL3BvcHVwLWJsb2NrZWQnLFxuICBQT1BVUF9DTE9TRURfQllfVVNFUjogJ2F1dGgvcG9wdXAtY2xvc2VkLWJ5LXVzZXInLFxuICBQUk9WSURFUl9BTFJFQURZX0xJTktFRDogJ2F1dGgvcHJvdmlkZXItYWxyZWFkeS1saW5rZWQnLFxuICBRVU9UQV9FWENFRURFRDogJ2F1dGgvcXVvdGEtZXhjZWVkZWQnLFxuICBSRURJUkVDVF9DQU5DRUxMRURfQllfVVNFUjogJ2F1dGgvcmVkaXJlY3QtY2FuY2VsbGVkLWJ5LXVzZXInLFxuICBSRURJUkVDVF9PUEVSQVRJT05fUEVORElORzogJ2F1dGgvcmVkaXJlY3Qtb3BlcmF0aW9uLXBlbmRpbmcnLFxuICBSRUpFQ1RFRF9DUkVERU5USUFMOiAnYXV0aC9yZWplY3RlZC1jcmVkZW50aWFsJyxcbiAgU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEOiAnYXV0aC9zZWNvbmQtZmFjdG9yLWFscmVhZHktaW4tdXNlJyxcbiAgU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRDogJ2F1dGgvbWF4aW11bS1zZWNvbmQtZmFjdG9yLWNvdW50LWV4Y2VlZGVkJyxcbiAgVEVOQU5UX0lEX01JU01BVENIOiAnYXV0aC90ZW5hbnQtaWQtbWlzbWF0Y2gnLFxuICBUSU1FT1VUOiAnYXV0aC90aW1lb3V0JyxcbiAgVE9LRU5fRVhQSVJFRDogJ2F1dGgvdXNlci10b2tlbi1leHBpcmVkJyxcbiAgVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSOiAnYXV0aC90b28tbWFueS1yZXF1ZXN0cycsXG4gIFVOQVVUSE9SSVpFRF9ET01BSU46ICdhdXRoL3VuYXV0aG9yaXplZC1jb250aW51ZS11cmknLFxuICBVTlNVUFBPUlRFRF9GSVJTVF9GQUNUT1I6ICdhdXRoL3Vuc3VwcG9ydGVkLWZpcnN0LWZhY3RvcicsXG4gIFVOU1VQUE9SVEVEX1BFUlNJU1RFTkNFOiAnYXV0aC91bnN1cHBvcnRlZC1wZXJzaXN0ZW5jZS10eXBlJyxcbiAgVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTjogJ2F1dGgvdW5zdXBwb3J0ZWQtdGVuYW50LW9wZXJhdGlvbicsXG4gIFVOVkVSSUZJRURfRU1BSUw6ICdhdXRoL3VudmVyaWZpZWQtZW1haWwnLFxuICBVU0VSX0NBTkNFTExFRDogJ2F1dGgvdXNlci1jYW5jZWxsZWQnLFxuICBVU0VSX0RFTEVURUQ6ICdhdXRoL3VzZXItbm90LWZvdW5kJyxcbiAgVVNFUl9ESVNBQkxFRDogJ2F1dGgvdXNlci1kaXNhYmxlZCcsXG4gIFVTRVJfTUlTTUFUQ0g6ICdhdXRoL3VzZXItbWlzbWF0Y2gnLFxuICBVU0VSX1NJR05FRF9PVVQ6ICdhdXRoL3VzZXItc2lnbmVkLW91dCcsXG4gIFdFQUtfUEFTU1dPUkQ6ICdhdXRoL3dlYWstcGFzc3dvcmQnLFxuICBXRUJfU1RPUkFHRV9VTlNVUFBPUlRFRDogJ2F1dGgvd2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWQnLFxuICBBTFJFQURZX0lOSVRJQUxJWkVEOiAnYXV0aC9hbHJlYWR5LWluaXRpYWxpemVkJyxcbiAgUkVDQVBUQ0hBX05PVF9FTkFCTEVEOiAnYXV0aC9yZWNhcHRjaGEtbm90LWVuYWJsZWQnLFxuICBNSVNTSU5HX1JFQ0FQVENIQV9UT0tFTjogJ2F1dGgvbWlzc2luZy1yZWNhcHRjaGEtdG9rZW4nLFxuICBJTlZBTElEX1JFQ0FQVENIQV9UT0tFTjogJ2F1dGgvaW52YWxpZC1yZWNhcHRjaGEtdG9rZW4nLFxuICBJTlZBTElEX1JFQ0FQVENIQV9BQ1RJT046ICdhdXRoL2ludmFsaWQtcmVjYXB0Y2hhLWFjdGlvbicsXG4gIE1JU1NJTkdfQ0xJRU5UX1RZUEU6ICdhdXRoL21pc3NpbmctY2xpZW50LXR5cGUnLFxuICBNSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OOiAnYXV0aC9taXNzaW5nLXJlY2FwdGNoYS12ZXJzaW9uJyxcbiAgSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTjogJ2F1dGgvaW52YWxpZC1yZWNhcHRjaGEtdmVyc2lvbicsXG4gIElOVkFMSURfUkVRX1RZUEU6ICdhdXRoL2ludmFsaWQtcmVxLXR5cGUnXG59IGFzIGNvbnN0O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgTG9nZ2VyLCBMb2dMZXZlbCB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgU0RLX1ZFUlNJT04gfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcblxuZXhwb3J0IHsgTG9nTGV2ZWwgfTtcblxuY29uc3QgbG9nQ2xpZW50ID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2F1dGgnKTtcblxuLy8gSGVscGVyIG1ldGhvZHMgYXJlIG5lZWRlZCBiZWNhdXNlIHZhcmlhYmxlcyBjYW4ndCBiZSBleHBvcnRlZCBhcyByZWFkL3dyaXRlXG5leHBvcnQgZnVuY3Rpb24gX2dldExvZ0xldmVsKCk6IExvZ0xldmVsIHtcbiAgcmV0dXJuIGxvZ0NsaWVudC5sb2dMZXZlbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9zZXRMb2dMZXZlbChuZXdMZXZlbDogTG9nTGV2ZWwpOiB2b2lkIHtcbiAgbG9nQ2xpZW50LmxvZ0xldmVsID0gbmV3TGV2ZWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfbG9nRGVidWcobXNnOiBzdHJpbmcsIC4uLmFyZ3M6IHN0cmluZ1tdKTogdm9pZCB7XG4gIGlmIChsb2dDbGllbnQubG9nTGV2ZWwgPD0gTG9nTGV2ZWwuREVCVUcpIHtcbiAgICBsb2dDbGllbnQuZGVidWcoYEF1dGggKCR7U0RLX1ZFUlNJT059KTogJHttc2d9YCwgLi4uYXJncyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9sb2dXYXJuKG1zZzogc3RyaW5nLCAuLi5hcmdzOiBzdHJpbmdbXSk6IHZvaWQge1xuICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLldBUk4pIHtcbiAgICBsb2dDbGllbnQud2FybihgQXV0aCAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX2xvZ0Vycm9yKG1zZzogc3RyaW5nLCAuLi5hcmdzOiBzdHJpbmdbXSk6IHZvaWQge1xuICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLkVSUk9SKSB7XG4gICAgbG9nQ2xpZW50LmVycm9yKGBBdXRoICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IEVycm9yRmFjdG9yeSwgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHtcbiAgX0RFRkFVTFRfQVVUSF9FUlJPUl9GQUNUT1JZLFxuICBBdXRoRXJyb3JDb2RlLFxuICBBdXRoRXJyb3JQYXJhbXMsXG4gIHByb2RFcnJvck1hcCxcbiAgRXJyb3JNYXBSZXRyaWV2ZXJcbn0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IF9sb2dFcnJvciB9IGZyb20gJy4vbG9nJztcblxudHlwZSBBdXRoRXJyb3JMaXN0UGFyYW1zPEs+ID0gSyBleHRlbmRzIGtleW9mIEF1dGhFcnJvclBhcmFtc1xuICA/IFtBdXRoRXJyb3JQYXJhbXNbS11dXG4gIDogW107XG50eXBlIExlc3NBcHBOYW1lPEsgZXh0ZW5kcyBBdXRoRXJyb3JDb2RlPiA9IE9taXQ8QXV0aEVycm9yUGFyYW1zW0tdLCAnYXBwTmFtZSc+O1xuXG4vKipcbiAqIFVuY29uZGl0aW9uYWxseSBmYWlscywgdGhyb3dpbmcgYSBkZXZlbG9wZXIgZmFjaW5nIElOVEVSTkFMX0VSUk9SXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZhaWwoYXV0aCwgQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRUQpOyAgLy8gRXJyb3I6IHRoZSBNRkFfUkVRVUlSRUQgZXJyb3IgbmVlZHMgbW9yZSBwYXJhbXMgdGhhbiBhcHBOYW1lXG4gKiBmYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVELCB7c2VydmVyUmVzcG9uc2V9KTsgIC8vIENvbXBpbGVzXG4gKiBmYWlsKEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpOyAgLy8gQ29tcGlsZXM7IGludGVybmFsIGVycm9yIGRvZXMgbm90IG5lZWQgYXBwTmFtZVxuICogZmFpbChBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRCk7ICAvLyBFcnJvcjogVVNFUl9ERUxFVEVEIHJlcXVpcmVzIGFwcCBuYW1lXG4gKiBmYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuVVNFUl9ERUxFVEVEKTsgIC8vIENvbXBpbGVzOyBVU0VSX0RFTEVURUQgX29ubHlfIG5lZWRzIGFwcCBuYW1lXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXBwTmFtZSBBcHAgbmFtZSBmb3IgdGFnZ2luZyB0aGUgZXJyb3JcbiAqIEB0aHJvd3MgRmlyZWJhc2VFcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZhaWw8SyBleHRlbmRzIEF1dGhFcnJvckNvZGU+KFxuICBjb2RlOiBLLFxuICAuLi5kYXRhOiB7fSBleHRlbmRzIEF1dGhFcnJvclBhcmFtc1tLXVxuICAgID8gW0F1dGhFcnJvclBhcmFtc1tLXT9dXG4gICAgOiBbQXV0aEVycm9yUGFyYW1zW0tdXVxuKTogbmV2ZXI7XG5leHBvcnQgZnVuY3Rpb24gX2ZhaWw8SyBleHRlbmRzIEF1dGhFcnJvckNvZGU+KFxuICBhdXRoOiBBdXRoLFxuICBjb2RlOiBLLFxuICAuLi5kYXRhOiB7fSBleHRlbmRzIExlc3NBcHBOYW1lPEs+ID8gW0xlc3NBcHBOYW1lPEs+P10gOiBbTGVzc0FwcE5hbWU8Sz5dXG4pOiBuZXZlcjtcbmV4cG9ydCBmdW5jdGlvbiBfZmFpbDxLIGV4dGVuZHMgQXV0aEVycm9yQ29kZT4oXG4gIGF1dGhPckNvZGU6IEF1dGggfCBLLFxuICAuLi5yZXN0OiB1bmtub3duW11cbik6IG5ldmVyIHtcbiAgdGhyb3cgY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVFcnJvcjxLIGV4dGVuZHMgQXV0aEVycm9yQ29kZT4oXG4gIGNvZGU6IEssXG4gIC4uLmRhdGE6IHt9IGV4dGVuZHMgQXV0aEVycm9yUGFyYW1zW0tdXG4gICAgPyBbQXV0aEVycm9yUGFyYW1zW0tdP11cbiAgICA6IFtBdXRoRXJyb3JQYXJhbXNbS11dXG4pOiBGaXJlYmFzZUVycm9yO1xuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVFcnJvcjxLIGV4dGVuZHMgQXV0aEVycm9yQ29kZT4oXG4gIGF1dGg6IEF1dGgsXG4gIGNvZGU6IEssXG4gIC4uLmRhdGE6IHt9IGV4dGVuZHMgTGVzc0FwcE5hbWU8Sz4gPyBbTGVzc0FwcE5hbWU8Sz4/XSA6IFtMZXNzQXBwTmFtZTxLPl1cbik6IEZpcmViYXNlRXJyb3I7XG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZUVycm9yPEsgZXh0ZW5kcyBBdXRoRXJyb3JDb2RlPihcbiAgYXV0aE9yQ29kZTogQXV0aCB8IEssXG4gIC4uLnJlc3Q6IHVua25vd25bXVxuKTogRmlyZWJhc2VFcnJvciB7XG4gIHJldHVybiBjcmVhdGVFcnJvckludGVybmFsKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2Vycm9yV2l0aEN1c3RvbU1lc3NhZ2UoXG4gIGF1dGg6IEF1dGgsXG4gIGNvZGU6IEF1dGhFcnJvckNvZGUsXG4gIG1lc3NhZ2U6IHN0cmluZ1xuKTogRmlyZWJhc2VFcnJvciB7XG4gIGNvbnN0IGVycm9yTWFwID0ge1xuICAgIC4uLihwcm9kRXJyb3JNYXAgYXMgRXJyb3JNYXBSZXRyaWV2ZXIpKCksXG4gICAgW2NvZGVdOiBtZXNzYWdlXG4gIH07XG4gIGNvbnN0IGZhY3RvcnkgPSBuZXcgRXJyb3JGYWN0b3J5PEF1dGhFcnJvckNvZGUsIEF1dGhFcnJvclBhcmFtcz4oXG4gICAgJ2F1dGgnLFxuICAgICdGaXJlYmFzZScsXG4gICAgZXJyb3JNYXBcbiAgKTtcbiAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlKGNvZGUsIHtcbiAgICBhcHBOYW1lOiBhdXRoLm5hbWVcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfYXNzZXJ0SW5zdGFuY2VPZihcbiAgYXV0aDogQXV0aCxcbiAgb2JqZWN0OiBvYmplY3QsXG4gIGluc3RhbmNlOiB1bmtub3duXG4pOiB2b2lkIHtcbiAgY29uc3QgY29uc3RydWN0b3JJbnN0YW5jZSA9IGluc3RhbmNlIGFzIHsgbmV3ICguLi5hcmdzOiB1bmtub3duW10pOiB1bmtub3duIH07XG4gIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9ySW5zdGFuY2UpKSB7XG4gICAgaWYgKGNvbnN0cnVjdG9ySW5zdGFuY2UubmFtZSAhPT0gb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIF9mYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IpO1xuICAgIH1cblxuICAgIHRocm93IF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKFxuICAgICAgYXV0aCxcbiAgICAgIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IsXG4gICAgICBgVHlwZSBvZiAke29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lfSBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBpbnN0YW5jZS5gICtcbiAgICAgICAgYERpZCB5b3UgcGFzcyBhIHJlZmVyZW5jZSBmcm9tIGEgZGlmZmVyZW50IEF1dGggU0RLP2BcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9ySW50ZXJuYWw8SyBleHRlbmRzIEF1dGhFcnJvckNvZGU+KFxuICBhdXRoT3JDb2RlOiBBdXRoIHwgSyxcbiAgLi4ucmVzdDogdW5rbm93bltdXG4pOiBGaXJlYmFzZUVycm9yIHtcbiAgaWYgKHR5cGVvZiBhdXRoT3JDb2RlICE9PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNvZGUgPSByZXN0WzBdIGFzIEs7XG4gICAgY29uc3QgZnVsbFBhcmFtcyA9IFsuLi5yZXN0LnNsaWNlKDEpXSBhcyBBdXRoRXJyb3JMaXN0UGFyYW1zPEs+O1xuICAgIGlmIChmdWxsUGFyYW1zWzBdKSB7XG4gICAgICBmdWxsUGFyYW1zWzBdLmFwcE5hbWUgPSBhdXRoT3JDb2RlLm5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIChhdXRoT3JDb2RlIGFzIEF1dGhJbnRlcm5hbCkuX2Vycm9yRmFjdG9yeS5jcmVhdGUoXG4gICAgICBjb2RlLFxuICAgICAgLi4uZnVsbFBhcmFtc1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gX0RFRkFVTFRfQVVUSF9FUlJPUl9GQUNUT1JZLmNyZWF0ZShcbiAgICBhdXRoT3JDb2RlLFxuICAgIC4uLihyZXN0IGFzIEF1dGhFcnJvckxpc3RQYXJhbXM8Sz4pXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfYXNzZXJ0PEsgZXh0ZW5kcyBBdXRoRXJyb3JDb2RlPihcbiAgYXNzZXJ0aW9uOiB1bmtub3duLFxuICBjb2RlOiBLLFxuICAuLi5kYXRhOiB7fSBleHRlbmRzIEF1dGhFcnJvclBhcmFtc1tLXVxuICAgID8gW0F1dGhFcnJvclBhcmFtc1tLXT9dXG4gICAgOiBbQXV0aEVycm9yUGFyYW1zW0tdXVxuKTogYXNzZXJ0cyBhc3NlcnRpb247XG5leHBvcnQgZnVuY3Rpb24gX2Fzc2VydDxLIGV4dGVuZHMgQXV0aEVycm9yQ29kZT4oXG4gIGFzc2VydGlvbjogdW5rbm93bixcbiAgYXV0aDogQXV0aCxcbiAgY29kZTogSyxcbiAgLi4uZGF0YToge30gZXh0ZW5kcyBMZXNzQXBwTmFtZTxLPiA/IFtMZXNzQXBwTmFtZTxLPj9dIDogW0xlc3NBcHBOYW1lPEs+XVxuKTogYXNzZXJ0cyBhc3NlcnRpb247XG5leHBvcnQgZnVuY3Rpb24gX2Fzc2VydDxLIGV4dGVuZHMgQXV0aEVycm9yQ29kZT4oXG4gIGFzc2VydGlvbjogdW5rbm93bixcbiAgYXV0aE9yQ29kZTogQXV0aCB8IEssXG4gIC4uLnJlc3Q6IHVua25vd25bXVxuKTogYXNzZXJ0cyBhc3NlcnRpb24ge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIHRocm93IGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XG4gIH1cbn1cblxuLy8gV2UgcmVhbGx5IGRvIHdhbnQgdG8gYWNjZXB0IGxpdGVyYWxseSBhbnkgZnVuY3Rpb24gdHlwZSBoZXJlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xudHlwZSBUeXBlRXhwZWN0YXRpb24gPSBGdW5jdGlvbiB8IHN0cmluZyB8IE1hcFR5cGU7XG5cbmludGVyZmFjZSBNYXBUeXBlIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgVHlwZUV4cGVjdGF0aW9uIHwgT3B0aW9uYWw+IHt9XG5cbmNsYXNzIE9wdGlvbmFsIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgdHlwZTogVHlwZUV4cGVjdGF0aW9uKSB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb3B0KHR5cGU6IFR5cGVFeHBlY3RhdGlvbik6IE9wdGlvbmFsIHtcbiAgcmV0dXJuIG5ldyBPcHRpb25hbCh0eXBlKTtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoZSBydW50aW1lIHR5cGVzIG9mIGFyZ3VtZW50cy4gVGhlICdleHBlY3RlZCcgZmllbGQgY2FuIGJlIG9uZSBvZlxuICogYSBjbGFzcywgYSBzdHJpbmcgKHJlcHJlc2VudGluZyBhIFwidHlwZW9mXCIgY2FsbCksIG9yIGEgcmVjb3JkIG1hcCBvZiBuYW1lXG4gKiB0byB0eXBlLiBGdXJ0aGVybW9yZSwgdGhlIG9wdCgpIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIG1hcmsgYSBmaWVsZCBhc1xuICogb3B0aW9uYWwuIEZvciBleGFtcGxlOlxuICpcbiAqIGZ1bmN0aW9uIGZvbyhhdXRoOiBBdXRoLCBwcm9maWxlOiB7ZGlzcGxheU5hbWU/OiBzdHJpbmd9LCB1cGRhdGUgPSBmYWxzZSkge1xuICogICBhc3NlcnRUeXBlcyhhcmd1bWVudHMsIFtBdXRoSW1wbCwge2Rpc3BsYXlOYW1lOiBvcHQoJ3N0cmluZycpfSwgb3B0KCdib29sZWFuJyldKTtcbiAqIH1cbiAqXG4gKiBvcHQoKSBjYW4gYmUgdXNlZCBmb3IgYW55IHR5cGU6XG4gKiBmdW5jdGlvbiBmb28oYXV0aD86IEF1dGgpIHtcbiAqICAgYXNzZXJ0VHlwZXMoYXJndW1lbnRzLCBbb3B0KEF1dGhJbXBsKV0pO1xuICogfVxuICpcbiAqIFRoZSBzdHJpbmcgdHlwZXMgY2FuIGJlIG9yJ2QgdG9nZXRoZXIsIGFuZCB5b3UgY2FuIHVzZSBcIm51bGxcIiBhcyB3ZWxsIChub3RlXG4gKiB0aGF0IHR5cGVvZiBudWxsID09PSAnb2JqZWN0JzsgdGhpcyBpcyBhbiBlZGdlIGNhc2UpLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBmdW5jdGlvbiBmb28ocHJvZmlsZToge2Rpc3BsYXlOYW1lPzogc3RyaW5nIHwgbnVsbH0pIHtcbiAqICAgYXNzZXJ0VHlwZXMoYXJndW1lbnRzLCBbe2Rpc3BsYXlOYW1lOiBvcHQoJ3N0cmluZ3xudWxsJyl9XSk7XG4gKiB9XG4gKlxuICogQHBhcmFtIGFyZ3NcbiAqIEBwYXJhbSBleHBlY3RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VHlwZXMoXG4gIGFyZ3M6IE9taXQ8SUFyZ3VtZW50cywgJ2NhbGxlZSc+LFxuICAuLi5leHBlY3RlZDogQXJyYXk8VHlwZUV4cGVjdGF0aW9uIHwgT3B0aW9uYWw+XG4pOiB2b2lkIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID4gZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgX2ZhaWwoQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiwge30pO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgIGxldCBleHBlY3QgPSBleHBlY3RlZFtpXTtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuXG4gICAgaWYgKGV4cGVjdCBpbnN0YW5jZW9mIE9wdGlvbmFsKSB7XG4gICAgICAvLyBJZiB0aGUgYXJnIGlzIHVuZGVmaW5lZCwgdGhlbiBpdCBtYXRjaGVzIFwib3B0aW9uYWxcIiBhbmQgd2UgY2FuIG1vdmUgdG9cbiAgICAgIC8vIHRoZSBuZXh0IGFyZ1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZXhwZWN0ID0gZXhwZWN0LnR5cGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBleHBlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBIYW5kbGUgdGhlIGVkZ2UgY2FzZSBmb3IgbnVsbCBiZWNhdXNlIHR5cGVvZiBudWxsID09PSAnb2JqZWN0J1xuICAgICAgaWYgKGV4cGVjdC5pbmNsdWRlcygnbnVsbCcpICYmIGFyZyA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVxdWlyZWQgPSBleHBlY3Quc3BsaXQoJ3wnKTtcbiAgICAgIF9hc3NlcnQocmVxdWlyZWQuaW5jbHVkZXModHlwZW9mIGFyZyksIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IsIHt9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBlY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBSZWN1cnNpdmVseSBjaGVjayByZWNvcmQgYXJndW1lbnRzXG4gICAgICBjb25zdCByZWNvcmQgPSBhcmcgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICBjb25zdCBtYXAgPSBleHBlY3QgYXMgTWFwVHlwZTtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3QpO1xuXG4gICAgICBhc3NlcnRUeXBlcyhcbiAgICAgICAga2V5cy5tYXAoayA9PiByZWNvcmRba10pLFxuICAgICAgICAuLi5rZXlzLm1hcChrID0+IG1hcFtrXSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hc3NlcnQoYXJnIGluc3RhbmNlb2YgZXhwZWN0LCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SLCB7fSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVW5jb25kaXRpb25hbGx5IGZhaWxzLCB0aHJvd2luZyBhbiBpbnRlcm5hbCBlcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBmYWlsdXJlIHR5cGUgb2YgZmFpbHVyZSBlbmNvdW50ZXJlZFxuICogQHRocm93cyBFcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVidWdGYWlsKGZhaWx1cmU6IHN0cmluZyk6IG5ldmVyIHtcbiAgLy8gTG9nIHRoZSBmYWlsdXJlIGluIGFkZGl0aW9uIHRvIHRocm93IGFuIGV4Y2VwdGlvbiwganVzdCBpbiBjYXNlIHRoZVxuICAvLyBleGNlcHRpb24gaXMgc3dhbGxvd2VkLlxuICBjb25zdCBtZXNzYWdlID0gYElOVEVSTkFMIEFTU0VSVElPTiBGQUlMRUQ6IGAgKyBmYWlsdXJlO1xuICBfbG9nRXJyb3IobWVzc2FnZSk7XG5cbiAgLy8gTk9URTogV2UgZG9uJ3QgdXNlIEZpcmViYXNlRXJyb3IgaGVyZSBiZWNhdXNlIHRoZXNlIGFyZSBpbnRlcm5hbCBmYWlsdXJlc1xuICAvLyB0aGF0IGNhbm5vdCBiZSBoYW5kbGVkIGJ5IHRoZSB1c2VyLiAoQWxzbyBpdCB3b3VsZCBjcmVhdGUgYSBjaXJjdWxhclxuICAvLyBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIGVycm9yIGFuZCBhc3NlcnQgbW9kdWxlcyB3aGljaCBkb2Vzbid0IHdvcmsuKVxuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogRmFpbHMgaWYgdGhlIGdpdmVuIGFzc2VydGlvbiBjb25kaXRpb24gaXMgZmFsc2UsIHRocm93aW5nIGFuIEVycm9yIHdpdGggdGhlXG4gKiBnaXZlbiBtZXNzYWdlIGlmIGl0IGRpZC5cbiAqXG4gKiBAcGFyYW0gYXNzZXJ0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVidWdBc3NlcnQoXG4gIGFzc2VydGlvbjogdW5rbm93bixcbiAgbWVzc2FnZTogc3RyaW5nXG4pOiBhc3NlcnRzIGFzc2VydGlvbiB7XG4gIGlmICghYXNzZXJ0aW9uKSB7XG4gICAgZGVidWdGYWlsKG1lc3NhZ2UpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gX2dldEN1cnJlbnRVcmwoKTogc3RyaW5nIHtcbiAgcmV0dXJuICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5sb2NhdGlvbj8uaHJlZikgfHwgJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNIdHRwT3JIdHRwcygpOiBib29sZWFuIHtcbiAgcmV0dXJuIF9nZXRDdXJyZW50U2NoZW1lKCkgPT09ICdodHRwOicgfHwgX2dldEN1cnJlbnRTY2hlbWUoKSA9PT0gJ2h0dHBzOic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0Q3VycmVudFNjaGVtZSgpOiBzdHJpbmcgfCBudWxsIHtcbiAgcmV0dXJuICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5sb2NhdGlvbj8ucHJvdG9jb2wpIHx8IG51bGw7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBpc0Jyb3dzZXJFeHRlbnNpb24gfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBfaXNIdHRwT3JIdHRwcyB9IGZyb20gJy4vbG9jYXRpb24nO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBicm93c2VyIGlzIHdvcmtpbmcgb25saW5lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNPbmxpbmUoKTogYm9vbGVhbiB7XG4gIGlmIChcbiAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIG5hdmlnYXRvciAmJlxuICAgICdvbkxpbmUnIGluIG5hdmlnYXRvciAmJlxuICAgIHR5cGVvZiBuYXZpZ2F0b3Iub25MaW5lID09PSAnYm9vbGVhbicgJiZcbiAgICAvLyBBcHBseSBvbmx5IGZvciB0cmFkaXRpb25hbCB3ZWIgYXBwcyBhbmQgQ2hyb21lIGV4dGVuc2lvbnMuXG4gICAgLy8gVGhpcyBpcyBlc3BlY2lhbGx5IHRydWUgZm9yIENvcmRvdmEgYXBwcyB3aGljaCBoYXZlIHVucmVsaWFibGVcbiAgICAvLyBuYXZpZ2F0b3Iub25MaW5lIGJlaGF2aW9yIHVubGVzcyBjb3Jkb3ZhLXBsdWdpbi1uZXR3b3JrLWluZm9ybWF0aW9uIGlzXG4gICAgLy8gaW5zdGFsbGVkIHdoaWNoIG92ZXJ3cml0ZXMgdGhlIG5hdGl2ZSBuYXZpZ2F0b3Iub25MaW5lIHZhbHVlIGFuZFxuICAgIC8vIGRlZmluZXMgbmF2aWdhdG9yLmNvbm5lY3Rpb24uXG4gICAgKF9pc0h0dHBPckh0dHBzKCkgfHwgaXNCcm93c2VyRXh0ZW5zaW9uKCkgfHwgJ2Nvbm5lY3Rpb24nIGluIG5hdmlnYXRvcilcbiAgKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5vbkxpbmU7XG4gIH1cbiAgLy8gSWYgd2UgY2FuJ3QgZGV0ZXJtaW5lIHRoZSBzdGF0ZSwgYXNzdW1lIGl0IGlzIG9ubGluZS5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VXNlckxhbmd1YWdlKCk6IHN0cmluZyB8IG51bGwge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBuYXZpZ2F0b3JMYW5ndWFnZTogTmF2aWdhdG9yTGFuZ3VhZ2UgPSBuYXZpZ2F0b3I7XG4gIHJldHVybiAoXG4gICAgLy8gTW9zdCByZWxpYWJsZSwgYnV0IG9ubHkgc3VwcG9ydGVkIGluIENocm9tZS9GaXJlZm94LlxuICAgIChuYXZpZ2F0b3JMYW5ndWFnZS5sYW5ndWFnZXMgJiYgbmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2VzWzBdKSB8fFxuICAgIC8vIFN1cHBvcnRlZCBpbiBtb3N0IGJyb3dzZXJzLCBidXQgcmV0dXJucyB0aGUgbGFuZ3VhZ2Ugb2YgdGhlIGJyb3dzZXJcbiAgICAvLyBVSSwgbm90IHRoZSBsYW5ndWFnZSBzZXQgaW4gYnJvd3NlciBzZXR0aW5ncy5cbiAgICBuYXZpZ2F0b3JMYW5ndWFnZS5sYW5ndWFnZSB8fFxuICAgIC8vIENvdWxkbid0IGRldGVybWluZSBsYW5ndWFnZS5cbiAgICBudWxsXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBpc01vYmlsZUNvcmRvdmEsIGlzUmVhY3ROYXRpdmUgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBfaXNPbmxpbmUgfSBmcm9tICcuL25hdmlnYXRvcic7XG5pbXBvcnQgeyBkZWJ1Z0Fzc2VydCB9IGZyb20gJy4vYXNzZXJ0JztcblxuZXhwb3J0IGNvbnN0IGVudW0gRGVsYXlNaW4ge1xuICBPRkZMSU5FID0gNTAwMFxufVxuXG4vKipcbiAqIEEgc3RydWN0dXJlIHRvIGhlbHAgcGljayBiZXR3ZWVuIGEgcmFuZ2Ugb2YgbG9uZyBhbmQgc2hvcnQgZGVsYXkgZHVyYXRpb25zXG4gKiBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEluIGdlbmVyYWwsIHRoZSBsb25nIGRlbGF5IGlzIHVzZWQgZm9yXG4gKiBtb2JpbGUgZW52aXJvbm1lbnRzIHdoZXJlYXMgc2hvcnQgZGVsYXlzIGFyZSB1c2VkIGZvciBkZXNrdG9wIGVudmlyb25tZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIERlbGF5IHtcbiAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBvZmZsaW5lIGRlbGF5IHRpbWVvdXQgaW4gbXMuXG5cbiAgcHJpdmF0ZSByZWFkb25seSBpc01vYmlsZTogYm9vbGVhbjtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzaG9ydERlbGF5OiBudW1iZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBsb25nRGVsYXk6IG51bWJlclxuICApIHtcbiAgICAvLyBJbnRlcm5hbCBlcnJvciB3aGVuIGltcHJvcGVybHkgaW5pdGlhbGl6ZWQuXG4gICAgZGVidWdBc3NlcnQoXG4gICAgICBsb25nRGVsYXkgPiBzaG9ydERlbGF5LFxuICAgICAgJ1Nob3J0IGRlbGF5IHNob3VsZCBiZSBsZXNzIHRoYW4gbG9uZyBkZWxheSEnXG4gICAgKTtcbiAgICB0aGlzLmlzTW9iaWxlID0gaXNNb2JpbGVDb3Jkb3ZhKCkgfHwgaXNSZWFjdE5hdGl2ZSgpO1xuICB9XG5cbiAgZ2V0KCk6IG51bWJlciB7XG4gICAgaWYgKCFfaXNPbmxpbmUoKSkge1xuICAgICAgLy8gUGljayB0aGUgc2hvcnRlciB0aW1lb3V0LlxuICAgICAgcmV0dXJuIE1hdGgubWluKERlbGF5TWluLk9GRkxJTkUsIHRoaXMuc2hvcnREZWxheSk7XG4gICAgfVxuICAgIC8vIElmIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZW52aXJvbm1lbnQsIHJldHVybiB0aGUgbG9uZyBkZWxheSwgb3RoZXJ3aXNlXG4gICAgLy8gcmV0dXJuIHRoZSBzaG9ydCBkZWxheS5cbiAgICAvLyBUaGlzIGNvdWxkIGJlIGltcHJvdmVkIGluIHRoZSBmdXR1cmUgdG8gZHluYW1pY2FsbHkgY2hhbmdlIGJhc2VkIG9uIG90aGVyXG4gICAgLy8gdmFyaWFibGVzIGluc3RlYWQgb2YganVzdCByZWFkaW5nIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuICAgIHJldHVybiB0aGlzLmlzTW9iaWxlID8gdGhpcy5sb25nRGVsYXkgOiB0aGlzLnNob3J0RGVsYXk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbmZpZ0ludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBkZWJ1Z0Fzc2VydCB9IGZyb20gJy4vYXNzZXJ0JztcblxuZXhwb3J0IGZ1bmN0aW9uIF9lbXVsYXRvclVybChjb25maWc6IENvbmZpZ0ludGVybmFsLCBwYXRoPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgZGVidWdBc3NlcnQoY29uZmlnLmVtdWxhdG9yLCAnRW11bGF0b3Igc2hvdWxkIGFsd2F5cyBiZSBzZXQgaGVyZScpO1xuICBjb25zdCB7IHVybCB9ID0gY29uZmlnLmVtdWxhdG9yO1xuXG4gIGlmICghcGF0aCkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICByZXR1cm4gYCR7dXJsfSR7cGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aH1gO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgZGVidWdGYWlsIH0gZnJvbSAnLi9hc3NlcnQnO1xuXG5leHBvcnQgY2xhc3MgRmV0Y2hQcm92aWRlciB7XG4gIHByaXZhdGUgc3RhdGljIGZldGNoSW1wbDogdHlwZW9mIGZldGNoIHwgbnVsbDtcbiAgcHJpdmF0ZSBzdGF0aWMgaGVhZGVyc0ltcGw6IHR5cGVvZiBIZWFkZXJzIHwgbnVsbDtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVzcG9uc2VJbXBsOiB0eXBlb2YgUmVzcG9uc2UgfCBudWxsO1xuXG4gIHN0YXRpYyBpbml0aWFsaXplKFxuICAgIGZldGNoSW1wbDogdHlwZW9mIGZldGNoLFxuICAgIGhlYWRlcnNJbXBsPzogdHlwZW9mIEhlYWRlcnMsXG4gICAgcmVzcG9uc2VJbXBsPzogdHlwZW9mIFJlc3BvbnNlXG4gICk6IHZvaWQge1xuICAgIHRoaXMuZmV0Y2hJbXBsID0gZmV0Y2hJbXBsO1xuICAgIGlmIChoZWFkZXJzSW1wbCkge1xuICAgICAgdGhpcy5oZWFkZXJzSW1wbCA9IGhlYWRlcnNJbXBsO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2VJbXBsKSB7XG4gICAgICB0aGlzLnJlc3BvbnNlSW1wbCA9IHJlc3BvbnNlSW1wbDtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZmV0Y2goKTogdHlwZW9mIGZldGNoIHtcbiAgICBpZiAodGhpcy5mZXRjaEltcGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoSW1wbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAnZmV0Y2gnIGluIHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLmZldGNoO1xuICAgIH1cbiAgICBkZWJ1Z0ZhaWwoXG4gICAgICAnQ291bGQgbm90IGZpbmQgZmV0Y2ggaW1wbGVtZW50YXRpb24sIG1ha2Ugc3VyZSB5b3UgY2FsbCBGZXRjaFByb3ZpZGVyLmluaXRpYWxpemUoKSB3aXRoIGFuIGFwcHJvcHJpYXRlIHBvbHlmaWxsJ1xuICAgICk7XG4gIH1cblxuICBzdGF0aWMgaGVhZGVycygpOiB0eXBlb2YgSGVhZGVycyB7XG4gICAgaWYgKHRoaXMuaGVhZGVyc0ltcGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNJbXBsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICdIZWFkZXJzJyBpbiBzZWxmKSB7XG4gICAgICByZXR1cm4gc2VsZi5IZWFkZXJzO1xuICAgIH1cbiAgICBkZWJ1Z0ZhaWwoXG4gICAgICAnQ291bGQgbm90IGZpbmQgSGVhZGVycyBpbXBsZW1lbnRhdGlvbiwgbWFrZSBzdXJlIHlvdSBjYWxsIEZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZSgpIHdpdGggYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwnXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyByZXNwb25zZSgpOiB0eXBlb2YgUmVzcG9uc2Uge1xuICAgIGlmICh0aGlzLnJlc3BvbnNlSW1wbCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VJbXBsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICdSZXNwb25zZScgaW4gc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuUmVzcG9uc2U7XG4gICAgfVxuICAgIGRlYnVnRmFpbChcbiAgICAgICdDb3VsZCBub3QgZmluZCBSZXNwb25zZSBpbXBsZW1lbnRhdGlvbiwgbWFrZSBzdXJlIHlvdSBjYWxsIEZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZSgpIHdpdGggYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwnXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2NvcmUvZXJyb3JzJztcblxuLyoqXG4gKiBFcnJvcnMgdGhhdCBjYW4gYmUgcmV0dXJuZWQgYnkgdGhlIGJhY2tlbmRcbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gU2VydmVyRXJyb3Ige1xuICBBRE1JTl9PTkxZX09QRVJBVElPTiA9ICdBRE1JTl9PTkxZX09QRVJBVElPTicsXG4gIEJMT0NLSU5HX0ZVTkNUSU9OX0VSUk9SX1JFU1BPTlNFID0gJ0JMT0NLSU5HX0ZVTkNUSU9OX0VSUk9SX1JFU1BPTlNFJyxcbiAgQ0FQVENIQV9DSEVDS19GQUlMRUQgPSAnQ0FQVENIQV9DSEVDS19GQUlMRUQnLFxuICBDT1JTX1VOU1VQUE9SVEVEID0gJ0NPUlNfVU5TVVBQT1JURUQnLFxuICBDUkVERU5USUFMX01JU01BVENIID0gJ0NSRURFTlRJQUxfTUlTTUFUQ0gnLFxuICBDUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU4gPSAnQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOJyxcbiAgRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQgPSAnRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQnLFxuICBFTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OID0gJ0VNQUlMX0NIQU5HRV9ORUVEU19WRVJJRklDQVRJT04nLFxuICBFTUFJTF9FWElTVFMgPSAnRU1BSUxfRVhJU1RTJyxcbiAgRU1BSUxfTk9UX0ZPVU5EID0gJ0VNQUlMX05PVF9GT1VORCcsXG4gIEVYUElSRURfT09CX0NPREUgPSAnRVhQSVJFRF9PT0JfQ09ERScsXG4gIEZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEID0gJ0ZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEJyxcbiAgSU5WQUxJRF9BUFBfQ1JFREVOVElBTCA9ICdJTlZBTElEX0FQUF9DUkVERU5USUFMJyxcbiAgSU5WQUxJRF9BUFBfSUQgPSAnSU5WQUxJRF9BUFBfSUQnLFxuICBJTlZBTElEX0NFUlRfSEFTSCA9ICdJTlZBTElEX0NFUlRfSEFTSCcsXG4gIElOVkFMSURfQ09ERSA9ICdJTlZBTElEX0NPREUnLFxuICBJTlZBTElEX0NPTlRJTlVFX1VSSSA9ICdJTlZBTElEX0NPTlRJTlVFX1VSSScsXG4gIElOVkFMSURfQ1VTVE9NX1RPS0VOID0gJ0lOVkFMSURfQ1VTVE9NX1RPS0VOJyxcbiAgSU5WQUxJRF9EWU5BTUlDX0xJTktfRE9NQUlOID0gJ0lOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTicsXG4gIElOVkFMSURfRU1BSUwgPSAnSU5WQUxJRF9FTUFJTCcsXG4gIElOVkFMSURfSURfVE9LRU4gPSAnSU5WQUxJRF9JRF9UT0tFTicsXG4gIElOVkFMSURfSURQX1JFU1BPTlNFID0gJ0lOVkFMSURfSURQX1JFU1BPTlNFJyxcbiAgSU5WQUxJRF9JREVOVElGSUVSID0gJ0lOVkFMSURfSURFTlRJRklFUicsXG4gIElOVkFMSURfTUVTU0FHRV9QQVlMT0FEID0gJ0lOVkFMSURfTUVTU0FHRV9QQVlMT0FEJyxcbiAgSU5WQUxJRF9NRkFfUEVORElOR19DUkVERU5USUFMID0gJ0lOVkFMSURfTUZBX1BFTkRJTkdfQ1JFREVOVElBTCcsXG4gIElOVkFMSURfT0FVVEhfQ0xJRU5UX0lEID0gJ0lOVkFMSURfT0FVVEhfQ0xJRU5UX0lEJyxcbiAgSU5WQUxJRF9PT0JfQ09ERSA9ICdJTlZBTElEX09PQl9DT0RFJyxcbiAgSU5WQUxJRF9QQVNTV09SRCA9ICdJTlZBTElEX1BBU1NXT1JEJyxcbiAgSU5WQUxJRF9QRU5ESU5HX1RPS0VOID0gJ0lOVkFMSURfUEVORElOR19UT0tFTicsXG4gIElOVkFMSURfUEhPTkVfTlVNQkVSID0gJ0lOVkFMSURfUEhPTkVfTlVNQkVSJyxcbiAgSU5WQUxJRF9QUk9WSURFUl9JRCA9ICdJTlZBTElEX1BST1ZJREVSX0lEJyxcbiAgSU5WQUxJRF9SRUNJUElFTlRfRU1BSUwgPSAnSU5WQUxJRF9SRUNJUElFTlRfRU1BSUwnLFxuICBJTlZBTElEX1NFTkRFUiA9ICdJTlZBTElEX1NFTkRFUicsXG4gIElOVkFMSURfU0VTU0lPTl9JTkZPID0gJ0lOVkFMSURfU0VTU0lPTl9JTkZPJyxcbiAgSU5WQUxJRF9URU1QT1JBUllfUFJPT0YgPSAnSU5WQUxJRF9URU1QT1JBUllfUFJPT0YnLFxuICBJTlZBTElEX1RFTkFOVF9JRCA9ICdJTlZBTElEX1RFTkFOVF9JRCcsXG4gIE1GQV9FTlJPTExNRU5UX05PVF9GT1VORCA9ICdNRkFfRU5ST0xMTUVOVF9OT1RfRk9VTkQnLFxuICBNSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FID0gJ01JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUnLFxuICBNSVNTSU5HX0FQUF9DUkVERU5USUFMID0gJ01JU1NJTkdfQVBQX0NSRURFTlRJQUwnLFxuICBNSVNTSU5HX0NPREUgPSAnTUlTU0lOR19DT0RFJyxcbiAgTUlTU0lOR19DT05USU5VRV9VUkkgPSAnTUlTU0lOR19DT05USU5VRV9VUkknLFxuICBNSVNTSU5HX0NVU1RPTV9UT0tFTiA9ICdNSVNTSU5HX0NVU1RPTV9UT0tFTicsXG4gIE1JU1NJTkdfSU9TX0JVTkRMRV9JRCA9ICdNSVNTSU5HX0lPU19CVU5ETEVfSUQnLFxuICBNSVNTSU5HX01GQV9FTlJPTExNRU5UX0lEID0gJ01JU1NJTkdfTUZBX0VOUk9MTE1FTlRfSUQnLFxuICBNSVNTSU5HX01GQV9QRU5ESU5HX0NSRURFTlRJQUwgPSAnTUlTU0lOR19NRkFfUEVORElOR19DUkVERU5USUFMJyxcbiAgTUlTU0lOR19PT0JfQ09ERSA9ICdNSVNTSU5HX09PQl9DT0RFJyxcbiAgTUlTU0lOR19PUl9JTlZBTElEX05PTkNFID0gJ01JU1NJTkdfT1JfSU5WQUxJRF9OT05DRScsXG4gIE1JU1NJTkdfUEFTU1dPUkQgPSAnTUlTU0lOR19QQVNTV09SRCcsXG4gIE1JU1NJTkdfUkVRX1RZUEUgPSAnTUlTU0lOR19SRVFfVFlQRScsXG4gIE1JU1NJTkdfUEhPTkVfTlVNQkVSID0gJ01JU1NJTkdfUEhPTkVfTlVNQkVSJyxcbiAgTUlTU0lOR19TRVNTSU9OX0lORk8gPSAnTUlTU0lOR19TRVNTSU9OX0lORk8nLFxuICBPUEVSQVRJT05fTk9UX0FMTE9XRUQgPSAnT1BFUkFUSU9OX05PVF9BTExPV0VEJyxcbiAgUEFTU1dPUkRfTE9HSU5fRElTQUJMRUQgPSAnUEFTU1dPUkRfTE9HSU5fRElTQUJMRUQnLFxuICBRVU9UQV9FWENFRURFRCA9ICdRVU9UQV9FWENFRURFRCcsXG4gIFJFU0VUX1BBU1NXT1JEX0VYQ0VFRF9MSU1JVCA9ICdSRVNFVF9QQVNTV09SRF9FWENFRURfTElNSVQnLFxuICBSRUpFQ1RFRF9DUkVERU5USUFMID0gJ1JFSkVDVEVEX0NSRURFTlRJQUwnLFxuICBTRUNPTkRfRkFDVE9SX0VYSVNUUyA9ICdTRUNPTkRfRkFDVE9SX0VYSVNUUycsXG4gIFNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQgPSAnU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCcsXG4gIFNFU1NJT05fRVhQSVJFRCA9ICdTRVNTSU9OX0VYUElSRUQnLFxuICBURU5BTlRfSURfTUlTTUFUQ0ggPSAnVEVOQU5UX0lEX01JU01BVENIJyxcbiAgVE9LRU5fRVhQSVJFRCA9ICdUT0tFTl9FWFBJUkVEJyxcbiAgVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSID0gJ1RPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUicsXG4gIFVOU1VQUE9SVEVEX0ZJUlNUX0ZBQ1RPUiA9ICdVTlNVUFBPUlRFRF9GSVJTVF9GQUNUT1InLFxuICBVTlNVUFBPUlRFRF9URU5BTlRfT1BFUkFUSU9OID0gJ1VOU1VQUE9SVEVEX1RFTkFOVF9PUEVSQVRJT04nLFxuICBVTkFVVEhPUklaRURfRE9NQUlOID0gJ1VOQVVUSE9SSVpFRF9ET01BSU4nLFxuICBVTlZFUklGSUVEX0VNQUlMID0gJ1VOVkVSSUZJRURfRU1BSUwnLFxuICBVU0VSX0NBTkNFTExFRCA9ICdVU0VSX0NBTkNFTExFRCcsXG4gIFVTRVJfRElTQUJMRUQgPSAnVVNFUl9ESVNBQkxFRCcsXG4gIFVTRVJfTk9UX0ZPVU5EID0gJ1VTRVJfTk9UX0ZPVU5EJyxcbiAgV0VBS19QQVNTV09SRCA9ICdXRUFLX1BBU1NXT1JEJyxcbiAgUkVDQVBUQ0hBX05PVF9FTkFCTEVEID0gJ1JFQ0FQVENIQV9OT1RfRU5BQkxFRCcsXG4gIE1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOID0gJ01JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOJyxcbiAgSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4gPSAnSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4nLFxuICBJTlZBTElEX1JFQ0FQVENIQV9BQ1RJT04gPSAnSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OJyxcbiAgTUlTU0lOR19DTElFTlRfVFlQRSA9ICdNSVNTSU5HX0NMSUVOVF9UWVBFJyxcbiAgTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTiA9ICdNSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OJyxcbiAgSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTiA9ICdJTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OJyxcbiAgSU5WQUxJRF9SRVFfVFlQRSA9ICdJTlZBTElEX1JFUV9UWVBFJ1xufVxuXG4vKipcbiAqIEFQSSBSZXNwb25zZSBpbiB0aGUgZXZlbnQgb2YgYW4gZXJyb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBKc29uRXJyb3Ige1xuICBlcnJvcjoge1xuICAgIGNvZGU6IG51bWJlcjtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgZXJyb3JzPzogW1xuICAgICAge1xuICAgICAgICBtZXNzYWdlOiBTZXJ2ZXJFcnJvcjtcbiAgICAgICAgZG9tYWluOiBzdHJpbmc7XG4gICAgICAgIHJlYXNvbjogc3RyaW5nO1xuICAgICAgfVxuICAgIF07XG4gIH07XG59XG5cbi8qKlxuICogVHlwZSBkZWZpbml0aW9uIGZvciBhIG1hcCBmcm9tIHNlcnZlciBlcnJvcnMgdG8gZGV2ZWxvcGVyIHZpc2libGUgZXJyb3JzXG4gKi9cbmV4cG9ydCBkZWNsYXJlIHR5cGUgU2VydmVyRXJyb3JNYXA8QXBpRXJyb3IgZXh0ZW5kcyBzdHJpbmc+ID0ge1xuICByZWFkb25seSBbSyBpbiBBcGlFcnJvcl06IEF1dGhFcnJvckNvZGU7XG59O1xuXG4vKipcbiAqIE1hcCBmcm9tIGVycm9ycyByZXR1cm5lZCBieSB0aGUgc2VydmVyIHRvIGVycm9ycyB0byBkZXZlbG9wZXIgdmlzaWJsZSBlcnJvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IFNFUlZFUl9FUlJPUl9NQVA6IFBhcnRpYWw8U2VydmVyRXJyb3JNYXA8U2VydmVyRXJyb3I+PiA9IHtcbiAgLy8gQ3VzdG9tIHRva2VuIGVycm9ycy5cbiAgW1NlcnZlckVycm9yLkNSRURFTlRJQUxfTUlTTUFUQ0hdOiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfTUlTTUFUQ0gsXG4gIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cbiAgW1NlcnZlckVycm9yLk1JU1NJTkdfQ1VTVE9NX1RPS0VOXTogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUixcblxuICAvLyBDcmVhdGUgQXV0aCBVUkkgZXJyb3JzLlxuICBbU2VydmVyRXJyb3IuSU5WQUxJRF9JREVOVElGSUVSXTogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNQUlMLFxuICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXG4gIFtTZXJ2ZXJFcnJvci5NSVNTSU5HX0NPTlRJTlVFX1VSSV06IEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IsXG5cbiAgLy8gU2lnbiBpbiB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZCBlcnJvcnMgKHNvbWUgYXBwbHkgdG8gc2lnbiB1cCB0b28pLlxuICBbU2VydmVyRXJyb3IuSU5WQUxJRF9QQVNTV09SRF06IEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QQVNTV09SRCxcbiAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxuICBbU2VydmVyRXJyb3IuTUlTU0lOR19QQVNTV09SRF06IEF1dGhFcnJvckNvZGUuTUlTU0lOR19QQVNTV09SRCxcblxuICAvLyBTaWduIHVwIHdpdGggZW1haWwgYW5kIHBhc3N3b3JkIGVycm9ycy5cbiAgW1NlcnZlckVycm9yLkVNQUlMX0VYSVNUU106IEF1dGhFcnJvckNvZGUuRU1BSUxfRVhJU1RTLFxuICBbU2VydmVyRXJyb3IuUEFTU1dPUkRfTE9HSU5fRElTQUJMRURdOiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfQUxMT1dFRCxcblxuICAvLyBWZXJpZnkgYXNzZXJ0aW9uIGZvciBzaWduIGluIHdpdGggY3JlZGVudGlhbCBlcnJvcnM6XG4gIFtTZXJ2ZXJFcnJvci5JTlZBTElEX0lEUF9SRVNQT05TRV06IEF1dGhFcnJvckNvZGUuSU5WQUxJRF9JRFBfUkVTUE9OU0UsXG4gIFtTZXJ2ZXJFcnJvci5JTlZBTElEX1BFTkRJTkdfVE9LRU5dOiBBdXRoRXJyb3JDb2RlLklOVkFMSURfSURQX1JFU1BPTlNFLFxuICBbU2VydmVyRXJyb3IuRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRURdOlxuICAgIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRSxcblxuICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXG4gIFtTZXJ2ZXJFcnJvci5NSVNTSU5HX1JFUV9UWVBFXTogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUixcblxuICAvLyBTZW5kIFBhc3N3b3JkIHJlc2V0IGVtYWlsIGVycm9yczpcbiAgW1NlcnZlckVycm9yLkVNQUlMX05PVF9GT1VORF06IEF1dGhFcnJvckNvZGUuVVNFUl9ERUxFVEVELFxuICBbU2VydmVyRXJyb3IuUkVTRVRfUEFTU1dPUkRfRVhDRUVEX0xJTUlUXTpcbiAgICBBdXRoRXJyb3JDb2RlLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUixcblxuICBbU2VydmVyRXJyb3IuRVhQSVJFRF9PT0JfQ09ERV06IEF1dGhFcnJvckNvZGUuRVhQSVJFRF9PT0JfQ09ERSxcbiAgW1NlcnZlckVycm9yLklOVkFMSURfT09CX0NPREVdOiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT09CX0NPREUsXG4gIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cbiAgW1NlcnZlckVycm9yLk1JU1NJTkdfT09CX0NPREVdOiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SLFxuXG4gIC8vIE9wZXJhdGlvbnMgdGhhdCByZXF1aXJlIElEIHRva2VuIGluIHJlcXVlc3Q6XG4gIFtTZXJ2ZXJFcnJvci5DUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU5dOlxuICAgIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOLFxuICBbU2VydmVyRXJyb3IuSU5WQUxJRF9JRF9UT0tFTl06IEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRILFxuICBbU2VydmVyRXJyb3IuVE9LRU5fRVhQSVJFRF06IEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCxcbiAgW1NlcnZlckVycm9yLlVTRVJfTk9UX0ZPVU5EXTogQXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVELFxuXG4gIC8vIE90aGVyIGVycm9ycy5cbiAgW1NlcnZlckVycm9yLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUl06XG4gICAgQXV0aEVycm9yQ29kZS5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVIsXG5cbiAgLy8gUGhvbmUgQXV0aCByZWxhdGVkIGVycm9ycy5cbiAgW1NlcnZlckVycm9yLklOVkFMSURfQ09ERV06IEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT0RFLFxuICBbU2VydmVyRXJyb3IuSU5WQUxJRF9TRVNTSU9OX0lORk9dOiBBdXRoRXJyb3JDb2RlLklOVkFMSURfU0VTU0lPTl9JTkZPLFxuICBbU2VydmVyRXJyb3IuSU5WQUxJRF9URU1QT1JBUllfUFJPT0ZdOiBBdXRoRXJyb3JDb2RlLklOVkFMSURfSURQX1JFU1BPTlNFLFxuICBbU2VydmVyRXJyb3IuTUlTU0lOR19TRVNTSU9OX0lORk9dOiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfU0VTU0lPTl9JTkZPLFxuICBbU2VydmVyRXJyb3IuU0VTU0lPTl9FWFBJUkVEXTogQXV0aEVycm9yQ29kZS5DT0RFX0VYUElSRUQsXG5cbiAgLy8gT3RoZXIgYWN0aW9uIGNvZGUgZXJyb3JzIHdoZW4gYWRkaXRpb25hbCBzZXR0aW5ncyBwYXNzZWQuXG4gIC8vIE1JU1NJTkdfQ09OVElOVUVfVVJJIGlzIGdldHRpbmcgbWFwcGVkIHRvIElOVEVSTkFMX0VSUk9SIGFib3ZlLlxuICAvLyBUaGlzIGlzIE9LIGFzIHRoaXMgZXJyb3Igd2lsbCBiZSBjYXVnaHQgYnkgY2xpZW50IHNpZGUgdmFsaWRhdGlvbi5cbiAgW1NlcnZlckVycm9yLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUVdOlxuICAgIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSxcbiAgW1NlcnZlckVycm9yLlVOQVVUSE9SSVpFRF9ET01BSU5dOiBBdXRoRXJyb3JDb2RlLlVOQVVUSE9SSVpFRF9ET01BSU4sXG5cbiAgLy8gZ2V0UHJvamVjdENvbmZpZyBlcnJvcnMgd2hlbiBjbGllbnRJZCBpcyBwYXNzZWQuXG4gIFtTZXJ2ZXJFcnJvci5JTlZBTElEX09BVVRIX0NMSUVOVF9JRF06IEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PQVVUSF9DTElFTlRfSUQsXG5cbiAgLy8gVXNlciBhY3Rpb25zIChzaWduLXVwIG9yIGRlbGV0aW9uKSBkaXNhYmxlZCBlcnJvcnMuXG4gIFtTZXJ2ZXJFcnJvci5BRE1JTl9PTkxZX09QRVJBVElPTl06IEF1dGhFcnJvckNvZGUuQURNSU5fT05MWV9PUEVSQVRJT04sXG5cbiAgLy8gTXVsdGkgZmFjdG9yIHJlbGF0ZWQgZXJyb3JzLlxuICBbU2VydmVyRXJyb3IuSU5WQUxJRF9NRkFfUEVORElOR19DUkVERU5USUFMXTpcbiAgICBBdXRoRXJyb3JDb2RlLklOVkFMSURfTUZBX1NFU1NJT04sXG4gIFtTZXJ2ZXJFcnJvci5NRkFfRU5ST0xMTUVOVF9OT1RfRk9VTkRdOiBBdXRoRXJyb3JDb2RlLk1GQV9JTkZPX05PVF9GT1VORCxcbiAgW1NlcnZlckVycm9yLk1JU1NJTkdfTUZBX0VOUk9MTE1FTlRfSURdOiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX0lORk8sXG4gIFtTZXJ2ZXJFcnJvci5NSVNTSU5HX01GQV9QRU5ESU5HX0NSRURFTlRJQUxdOlxuICAgIEF1dGhFcnJvckNvZGUuTUlTU0lOR19NRkFfU0VTU0lPTixcbiAgW1NlcnZlckVycm9yLlNFQ09ORF9GQUNUT1JfRVhJU1RTXTpcbiAgICBBdXRoRXJyb3JDb2RlLlNFQ09ORF9GQUNUT1JfQUxSRUFEWV9FTlJPTExFRCxcbiAgW1NlcnZlckVycm9yLlNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERURdOlxuICAgIEF1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCxcblxuICAvLyBCbG9ja2luZyBmdW5jdGlvbnMgcmVsYXRlZCBlcnJvcnMuXG4gIFtTZXJ2ZXJFcnJvci5CTE9DS0lOR19GVU5DVElPTl9FUlJPUl9SRVNQT05TRV06IEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IsXG5cbiAgLy8gUmVjYXB0Y2hhIHJlbGF0ZWQgZXJyb3JzLlxuICBbU2VydmVyRXJyb3IuUkVDQVBUQ0hBX05PVF9FTkFCTEVEXTogQXV0aEVycm9yQ29kZS5SRUNBUFRDSEFfTk9UX0VOQUJMRUQsXG4gIFtTZXJ2ZXJFcnJvci5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTl06IEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4sXG4gIFtTZXJ2ZXJFcnJvci5JTlZBTElEX1JFQ0FQVENIQV9UT0tFTl06IEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4sXG4gIFtTZXJ2ZXJFcnJvci5JTlZBTElEX1JFQ0FQVENIQV9BQ1RJT05dOlxuICAgIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OLFxuICBbU2VydmVyRXJyb3IuTUlTU0lOR19DTElFTlRfVFlQRV06IEF1dGhFcnJvckNvZGUuTUlTU0lOR19DTElFTlRfVFlQRSxcbiAgW1NlcnZlckVycm9yLk1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT05dOlxuICAgIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTixcbiAgW1NlcnZlckVycm9yLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT05dOlxuICAgIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTixcbiAgW1NlcnZlckVycm9yLklOVkFMSURfUkVRX1RZUEVdOiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVRX1RZUEVcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yLCBxdWVyeXN0cmluZyB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSwgTmFtZWRFcnJvclBhcmFtcyB9IGZyb20gJy4uL2NvcmUvZXJyb3JzJztcbmltcG9ydCB7XG4gIF9jcmVhdGVFcnJvcixcbiAgX2Vycm9yV2l0aEN1c3RvbU1lc3NhZ2UsXG4gIF9mYWlsXG59IGZyb20gJy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgRGVsYXkgfSBmcm9tICcuLi9jb3JlL3V0aWwvZGVsYXknO1xuaW1wb3J0IHsgX2VtdWxhdG9yVXJsIH0gZnJvbSAnLi4vY29yZS91dGlsL2VtdWxhdG9yJztcbmltcG9ydCB7IEZldGNoUHJvdmlkZXIgfSBmcm9tICcuLi9jb3JlL3V0aWwvZmV0Y2hfcHJvdmlkZXInO1xuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwsIENvbmZpZ0ludGVybmFsIH0gZnJvbSAnLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UsIFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgSWRUb2tlbk1mYVJlc3BvbnNlIH0gZnJvbSAnLi9hdXRoZW50aWNhdGlvbi9tZmEnO1xuaW1wb3J0IHsgU0VSVkVSX0VSUk9SX01BUCwgU2VydmVyRXJyb3IsIFNlcnZlckVycm9yTWFwIH0gZnJvbSAnLi9lcnJvcnMnO1xuXG5leHBvcnQgY29uc3QgZW51bSBIdHRwTWV0aG9kIHtcbiAgUE9TVCA9ICdQT1NUJyxcbiAgR0VUID0gJ0dFVCdcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gSHR0cEhlYWRlciB7XG4gIENPTlRFTlRfVFlQRSA9ICdDb250ZW50LVR5cGUnLFxuICBYX0ZJUkVCQVNFX0xPQ0FMRSA9ICdYLUZpcmViYXNlLUxvY2FsZScsXG4gIFhfQ0xJRU5UX1ZFUlNJT04gPSAnWC1DbGllbnQtVmVyc2lvbicsXG4gIFhfRklSRUJBU0VfR01QSUQgPSAnWC1GaXJlYmFzZS1nbXBpZCcsXG4gIFhfRklSRUJBU0VfQ0xJRU5UID0gJ1gtRmlyZWJhc2UtQ2xpZW50JyxcbiAgWF9GSVJFQkFTRV9BUFBfQ0hFQ0sgPSAnWC1GaXJlYmFzZS1BcHBDaGVjaydcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gRW5kcG9pbnQge1xuICBDUkVBVEVfQVVUSF9VUkkgPSAnL3YxL2FjY291bnRzOmNyZWF0ZUF1dGhVcmknLFxuICBERUxFVEVfQUNDT1VOVCA9ICcvdjEvYWNjb3VudHM6ZGVsZXRlJyxcbiAgUkVTRVRfUEFTU1dPUkQgPSAnL3YxL2FjY291bnRzOnJlc2V0UGFzc3dvcmQnLFxuICBTSUdOX1VQID0gJy92MS9hY2NvdW50czpzaWduVXAnLFxuICBTSUdOX0lOX1dJVEhfQ1VTVE9NX1RPS0VOID0gJy92MS9hY2NvdW50czpzaWduSW5XaXRoQ3VzdG9tVG9rZW4nLFxuICBTSUdOX0lOX1dJVEhfRU1BSUxfTElOSyA9ICcvdjEvYWNjb3VudHM6c2lnbkluV2l0aEVtYWlsTGluaycsXG4gIFNJR05fSU5fV0lUSF9JRFAgPSAnL3YxL2FjY291bnRzOnNpZ25JbldpdGhJZHAnLFxuICBTSUdOX0lOX1dJVEhfUEFTU1dPUkQgPSAnL3YxL2FjY291bnRzOnNpZ25JbldpdGhQYXNzd29yZCcsXG4gIFNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIgPSAnL3YxL2FjY291bnRzOnNpZ25JbldpdGhQaG9uZU51bWJlcicsXG4gIFNFTkRfVkVSSUZJQ0FUSU9OX0NPREUgPSAnL3YxL2FjY291bnRzOnNlbmRWZXJpZmljYXRpb25Db2RlJyxcbiAgU0VORF9PT0JfQ09ERSA9ICcvdjEvYWNjb3VudHM6c2VuZE9vYkNvZGUnLFxuICBTRVRfQUNDT1VOVF9JTkZPID0gJy92MS9hY2NvdW50czp1cGRhdGUnLFxuICBHRVRfQUNDT1VOVF9JTkZPID0gJy92MS9hY2NvdW50czpsb29rdXAnLFxuICBHRVRfUkVDQVBUQ0hBX1BBUkFNID0gJy92MS9yZWNhcHRjaGFQYXJhbXMnLFxuICBTVEFSVF9NRkFfRU5ST0xMTUVOVCA9ICcvdjIvYWNjb3VudHMvbWZhRW5yb2xsbWVudDpzdGFydCcsXG4gIEZJTkFMSVpFX01GQV9FTlJPTExNRU5UID0gJy92Mi9hY2NvdW50cy9tZmFFbnJvbGxtZW50OmZpbmFsaXplJyxcbiAgU1RBUlRfTUZBX1NJR05fSU4gPSAnL3YyL2FjY291bnRzL21mYVNpZ25JbjpzdGFydCcsXG4gIEZJTkFMSVpFX01GQV9TSUdOX0lOID0gJy92Mi9hY2NvdW50cy9tZmFTaWduSW46ZmluYWxpemUnLFxuICBXSVRIRFJBV19NRkEgPSAnL3YyL2FjY291bnRzL21mYUVucm9sbG1lbnQ6d2l0aGRyYXcnLFxuICBHRVRfUFJPSkVDVF9DT05GSUcgPSAnL3YxL3Byb2plY3RzJyxcbiAgR0VUX1JFQ0FQVENIQV9DT05GSUcgPSAnL3YyL3JlY2FwdGNoYUNvbmZpZydcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gUmVjYXB0Y2hhQ2xpZW50VHlwZSB7XG4gIFdFQiA9ICdDTElFTlRfVFlQRV9XRUInLFxuICBBTkRST0lEID0gJ0NMSUVOVF9UWVBFX0FORFJPSUQnLFxuICBJT1MgPSAnQ0xJRU5UX1RZUEVfSU9TJ1xufVxuXG5leHBvcnQgY29uc3QgZW51bSBSZWNhcHRjaGFWZXJzaW9uIHtcbiAgRU5URVJQUklTRSA9ICdSRUNBUFRDSEFfRU5URVJQUklTRSdcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gUmVjYXB0Y2hhQWN0aW9uTmFtZSB7XG4gIFNJR05fSU5fV0lUSF9QQVNTV09SRCA9ICdzaWduSW5XaXRoUGFzc3dvcmQnLFxuICBHRVRfT09CX0NPREUgPSAnZ2V0T29iQ29kZScsXG4gIFNJR05fVVBfUEFTU1dPUkQgPSAnc2lnblVwUGFzc3dvcmQnXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0FQSV9USU1FT1VUX01TID0gbmV3IERlbGF5KDMwXzAwMCwgNjBfMDAwKTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9hZGRUaWRJZk5lY2Vzc2FyeTxUIGV4dGVuZHMgeyB0ZW5hbnRJZD86IHN0cmluZyB9PihcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogVFxuKTogVCB7XG4gIGlmIChhdXRoLnRlbmFudElkICYmICFyZXF1ZXN0LnRlbmFudElkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICB0ZW5hbnRJZDogYXV0aC50ZW5hbnRJZFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3Q7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcGVyZm9ybUFwaVJlcXVlc3Q8VCwgVj4oXG4gIGF1dGg6IEF1dGgsXG4gIG1ldGhvZDogSHR0cE1ldGhvZCxcbiAgcGF0aDogRW5kcG9pbnQsXG4gIHJlcXVlc3Q/OiBULFxuICBjdXN0b21FcnJvck1hcDogUGFydGlhbDxTZXJ2ZXJFcnJvck1hcDxTZXJ2ZXJFcnJvcj4+ID0ge31cbik6IFByb21pc2U8Vj4ge1xuICByZXR1cm4gX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nKGF1dGgsIGN1c3RvbUVycm9yTWFwLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGJvZHkgPSB7fTtcbiAgICBsZXQgcGFyYW1zID0ge307XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgIGlmIChtZXRob2QgPT09IEh0dHBNZXRob2QuR0VUKSB7XG4gICAgICAgIHBhcmFtcyA9IHJlcXVlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5ID0ge1xuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnkgPSBxdWVyeXN0cmluZyh7XG4gICAgICBrZXk6IGF1dGguY29uZmlnLmFwaUtleSxcbiAgICAgIC4uLnBhcmFtc1xuICAgIH0pLnNsaWNlKDEpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IChhdXRoIGFzIEF1dGhJbnRlcm5hbCkuX2dldEFkZGl0aW9uYWxIZWFkZXJzKCk7XG4gICAgaGVhZGVyc1tIdHRwSGVhZGVyLkNPTlRFTlRfVFlQRV0gPSAnYXBwbGljYXRpb24vanNvbic7XG5cbiAgICBpZiAoYXV0aC5sYW5ndWFnZUNvZGUpIHtcbiAgICAgIGhlYWRlcnNbSHR0cEhlYWRlci5YX0ZJUkVCQVNFX0xPQ0FMRV0gPSBhdXRoLmxhbmd1YWdlQ29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gRmV0Y2hQcm92aWRlci5mZXRjaCgpKFxuICAgICAgX2dldEZpbmFsVGFyZ2V0KGF1dGgsIGF1dGguY29uZmlnLmFwaUhvc3QsIHBhdGgsIHF1ZXJ5KSxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICByZWZlcnJlclBvbGljeTogJ25vLXJlZmVycmVyJyxcbiAgICAgICAgLi4uYm9keVxuICAgICAgfVxuICAgICk7XG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nPFY+KFxuICBhdXRoOiBBdXRoLFxuICBjdXN0b21FcnJvck1hcDogUGFydGlhbDxTZXJ2ZXJFcnJvck1hcDxTZXJ2ZXJFcnJvcj4+LFxuICBmZXRjaEZuOiAoKSA9PiBQcm9taXNlPFJlc3BvbnNlPlxuKTogUHJvbWlzZTxWPiB7XG4gIChhdXRoIGFzIEF1dGhJbnRlcm5hbCkuX2NhbkluaXRFbXVsYXRvciA9IGZhbHNlO1xuICBjb25zdCBlcnJvck1hcCA9IHsgLi4uU0VSVkVSX0VSUk9SX01BUCwgLi4uY3VzdG9tRXJyb3JNYXAgfTtcbiAgdHJ5IHtcbiAgICBjb25zdCBuZXR3b3JrVGltZW91dCA9IG5ldyBOZXR3b3JrVGltZW91dDxSZXNwb25zZT4oYXV0aCk7XG4gICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5yYWNlPFByb21pc2U8UmVzcG9uc2U+PihbXG4gICAgICBmZXRjaEZuKCksXG4gICAgICBuZXR3b3JrVGltZW91dC5wcm9taXNlXG4gICAgXSk7XG5cbiAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoaXMgcG9pbnQsIHRoZSBmZXRjaCBzdWNjZWVkZWQgYW5kIHRoZSBuZXR3b3JrVGltZW91dFxuICAgIC8vIGRpZG4ndCB0aHJvdzsgY2xlYXIgdGhlIG5ldHdvcmsgdGltZW91dCBkZWxheSBzbyB0aGF0IE5vZGUgd29uJ3QgaGFuZ1xuICAgIG5ldHdvcmtUaW1lb3V0LmNsZWFyTmV0d29ya1RpbWVvdXQoKTtcblxuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgaWYgKCduZWVkQ29uZmlybWF0aW9uJyBpbiBqc29uKSB7XG4gICAgICB0aHJvdyBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIEF1dGhFcnJvckNvZGUuTkVFRF9DT05GSVJNQVRJT04sIGpzb24pO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS5vayAmJiAhKCdlcnJvck1lc3NhZ2UnIGluIGpzb24pKSB7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2Uub2sgPyBqc29uLmVycm9yTWVzc2FnZSA6IGpzb24uZXJyb3IubWVzc2FnZTtcbiAgICAgIGNvbnN0IFtzZXJ2ZXJFcnJvckNvZGUsIHNlcnZlckVycm9yTWVzc2FnZV0gPSBlcnJvck1lc3NhZ2Uuc3BsaXQoJyA6ICcpO1xuICAgICAgaWYgKHNlcnZlckVycm9yQ29kZSA9PT0gU2VydmVyRXJyb3IuRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRUQpIHtcbiAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihcbiAgICAgICAgICBhdXRoLFxuICAgICAgICAgIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRSxcbiAgICAgICAgICBqc29uXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHNlcnZlckVycm9yQ29kZSA9PT0gU2VydmVyRXJyb3IuRU1BSUxfRVhJU1RTKSB7XG4gICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgQXV0aEVycm9yQ29kZS5FTUFJTF9FWElTVFMsIGpzb24pO1xuICAgICAgfSBlbHNlIGlmIChzZXJ2ZXJFcnJvckNvZGUgPT09IFNlcnZlckVycm9yLlVTRVJfRElTQUJMRUQpIHtcbiAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBBdXRoRXJyb3JDb2RlLlVTRVJfRElTQUJMRUQsIGpzb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgYXV0aEVycm9yID1cbiAgICAgICAgZXJyb3JNYXBbc2VydmVyRXJyb3JDb2RlIGFzIFNlcnZlckVycm9yXSB8fFxuICAgICAgICAoc2VydmVyRXJyb3JDb2RlXG4gICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAucmVwbGFjZSgvW19cXHNdKy9nLCAnLScpIGFzIHVua25vd24gYXMgQXV0aEVycm9yQ29kZSk7XG4gICAgICBpZiAoc2VydmVyRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRocm93IF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKGF1dGgsIGF1dGhFcnJvciwgc2VydmVyRXJyb3JNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9mYWlsKGF1dGgsIGF1dGhFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICAvLyBDaGFuZ2luZyB0aGlzIHRvIGEgZGlmZmVyZW50IGVycm9yIGNvZGUgd2lsbCBsb2cgdXNlciBvdXQgd2hlbiB0aGVyZSBpcyBhIG5ldHdvcmsgZXJyb3JcbiAgICAvLyBiZWNhdXNlIHdlIHRyZWF0IGFueSBlcnJvciBvdGhlciB0aGFuIE5FVFdPUktfUkVRVUVTVF9GQUlMRUQgYXMgdG9rZW4gaXMgaW52YWxpZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2Jsb2IvNGZiYzczNjEwZDcwYmU0ZTA4NTJlN2RlNjNhMzljYjc4OTdlODU0Ni9wYWNrYWdlcy9hdXRoL3NyYy9jb3JlL2F1dGgvYXV0aF9pbXBsLnRzI0wzMDktTDMxNlxuICAgIF9mYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCwgeyAnbWVzc2FnZSc6IFN0cmluZyhlKSB9KTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3BlcmZvcm1TaWduSW5SZXF1ZXN0PFQsIFYgZXh0ZW5kcyBJZFRva2VuUmVzcG9uc2U+KFxuICBhdXRoOiBBdXRoLFxuICBtZXRob2Q6IEh0dHBNZXRob2QsXG4gIHBhdGg6IEVuZHBvaW50LFxuICByZXF1ZXN0PzogVCxcbiAgY3VzdG9tRXJyb3JNYXA6IFBhcnRpYWw8U2VydmVyRXJyb3JNYXA8U2VydmVyRXJyb3I+PiA9IHt9XG4pOiBQcm9taXNlPFY+IHtcbiAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSAoYXdhaXQgX3BlcmZvcm1BcGlSZXF1ZXN0PFQsIFYgfCBJZFRva2VuTWZhUmVzcG9uc2U+KFxuICAgIGF1dGgsXG4gICAgbWV0aG9kLFxuICAgIHBhdGgsXG4gICAgcmVxdWVzdCxcbiAgICBjdXN0b21FcnJvck1hcFxuICApKSBhcyBWO1xuICBpZiAoJ21mYVBlbmRpbmdDcmVkZW50aWFsJyBpbiBzZXJ2ZXJSZXNwb25zZSkge1xuICAgIF9mYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVELCB7XG4gICAgICBfc2VydmVyUmVzcG9uc2U6IHNlcnZlclJlc3BvbnNlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc2VydmVyUmVzcG9uc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0RmluYWxUYXJnZXQoXG4gIGF1dGg6IEF1dGgsXG4gIGhvc3Q6IHN0cmluZyxcbiAgcGF0aDogc3RyaW5nLFxuICBxdWVyeTogc3RyaW5nXG4pOiBzdHJpbmcge1xuICBjb25zdCBiYXNlID0gYCR7aG9zdH0ke3BhdGh9PyR7cXVlcnl9YDtcblxuICBpZiAoIShhdXRoIGFzIEF1dGhJbnRlcm5hbCkuY29uZmlnLmVtdWxhdG9yKSB7XG4gICAgcmV0dXJuIGAke2F1dGguY29uZmlnLmFwaVNjaGVtZX06Ly8ke2Jhc2V9YDtcbiAgfVxuXG4gIHJldHVybiBfZW11bGF0b3JVcmwoYXV0aC5jb25maWcgYXMgQ29uZmlnSW50ZXJuYWwsIGJhc2UpO1xufVxuXG5jbGFzcyBOZXR3b3JrVGltZW91dDxUPiB7XG4gIC8vIE5vZGUgdGltZXJzIGFuZCBicm93c2VyIHRpbWVycyBhcmUgZnVuZGFtZW50YWxseSBpbmNvbXBhdGlibGUsIGJ1dCB3ZVxuICAvLyBkb24ndCBjYXJlIGFib3V0IHRoZSB2YWx1ZSBoZXJlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHByaXZhdGUgdGltZXI6IGFueSB8IG51bGwgPSBudWxsO1xuICByZWFkb25seSBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKF8sIHJlamVjdCkgPT4ge1xuICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgIF9jcmVhdGVFcnJvcih0aGlzLmF1dGgsIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRClcbiAgICAgICk7XG4gICAgfSwgREVGQVVMVF9BUElfVElNRU9VVF9NUy5nZXQoKSk7XG4gIH0pO1xuXG4gIGNsZWFyTmV0d29ya1RpbWVvdXQoKTogdm9pZCB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBhdXRoOiBBdXRoKSB7fVxufVxuXG5pbnRlcmZhY2UgUG90ZW50aWFsUmVzcG9uc2UgZXh0ZW5kcyBJZFRva2VuUmVzcG9uc2Uge1xuICBlbWFpbD86IHN0cmluZztcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfbWFrZVRhZ2dlZEVycm9yKFxuICBhdXRoOiBBdXRoLFxuICBjb2RlOiBBdXRoRXJyb3JDb2RlLFxuICByZXNwb25zZTogUG90ZW50aWFsUmVzcG9uc2Vcbik6IEZpcmViYXNlRXJyb3Ige1xuICBjb25zdCBlcnJvclBhcmFtczogTmFtZWRFcnJvclBhcmFtcyA9IHtcbiAgICBhcHBOYW1lOiBhdXRoLm5hbWVcbiAgfTtcblxuICBpZiAocmVzcG9uc2UuZW1haWwpIHtcbiAgICBlcnJvclBhcmFtcy5lbWFpbCA9IHJlc3BvbnNlLmVtYWlsO1xuICB9XG4gIGlmIChyZXNwb25zZS5waG9uZU51bWJlcikge1xuICAgIGVycm9yUGFyYW1zLnBob25lTnVtYmVyID0gcmVzcG9uc2UucGhvbmVOdW1iZXI7XG4gIH1cblxuICBjb25zdCBlcnJvciA9IF9jcmVhdGVFcnJvcihhdXRoLCBjb2RlLCBlcnJvclBhcmFtcyk7XG5cbiAgLy8gV2Uga25vdyBjdXN0b21EYXRhIGlzIGRlZmluZWQgb24gZXJyb3IgYmVjYXVzZSBlcnJvclBhcmFtcyBpcyBkZWZpbmVkXG4gIChlcnJvci5jdXN0b21EYXRhISBhcyBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZSkuX3Rva2VuUmVzcG9uc2UgPSByZXNwb25zZTtcbiAgcmV0dXJuIGVycm9yO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRW5kcG9pbnQsIEh0dHBNZXRob2QsIF9wZXJmb3JtQXBpUmVxdWVzdCB9IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IE1mYUVucm9sbG1lbnQgfSBmcm9tICcuL21mYSc7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBEZWxldGVBY2NvdW50UmVxdWVzdCB7XG4gIGlkVG9rZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFjY291bnQoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IERlbGV0ZUFjY291bnRSZXF1ZXN0XG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxEZWxldGVBY2NvdW50UmVxdWVzdCwgdm9pZD4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuREVMRVRFX0FDQ09VTlQsXG4gICAgcmVxdWVzdFxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb3ZpZGVyVXNlckluZm8ge1xuICBwcm92aWRlcklkOiBzdHJpbmc7XG4gIHJhd0lkPzogc3RyaW5nO1xuICBlbWFpbD86IHN0cmluZztcbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG4gIHBob3RvVXJsPzogc3RyaW5nO1xuICBwaG9uZU51bWJlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWxldGVMaW5rZWRBY2NvdW50c1JlcXVlc3Qge1xuICBpZFRva2VuOiBzdHJpbmc7XG4gIGRlbGV0ZVByb3ZpZGVyOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWxldGVMaW5rZWRBY2NvdW50c1Jlc3BvbnNlIHtcbiAgcHJvdmlkZXJVc2VySW5mbzogUHJvdmlkZXJVc2VySW5mb1tdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlTGlua2VkQWNjb3VudHMoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IERlbGV0ZUxpbmtlZEFjY291bnRzUmVxdWVzdFxuKTogUHJvbWlzZTxEZWxldGVMaW5rZWRBY2NvdW50c1Jlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8XG4gICAgRGVsZXRlTGlua2VkQWNjb3VudHNSZXF1ZXN0LFxuICAgIERlbGV0ZUxpbmtlZEFjY291bnRzUmVzcG9uc2VcbiAgPihhdXRoLCBIdHRwTWV0aG9kLlBPU1QsIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8sIHJlcXVlc3QpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFQSVVzZXJJbmZvIHtcbiAgbG9jYWxJZD86IHN0cmluZztcbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG4gIHBob3RvVXJsPzogc3RyaW5nO1xuICBlbWFpbD86IHN0cmluZztcbiAgZW1haWxWZXJpZmllZD86IGJvb2xlYW47XG4gIHBob25lTnVtYmVyPzogc3RyaW5nO1xuICBsYXN0TG9naW5BdD86IG51bWJlcjtcbiAgY3JlYXRlZEF0PzogbnVtYmVyO1xuICB0ZW5hbnRJZD86IHN0cmluZztcbiAgcGFzc3dvcmRIYXNoPzogc3RyaW5nO1xuICBwcm92aWRlclVzZXJJbmZvPzogUHJvdmlkZXJVc2VySW5mb1tdO1xuICBtZmFJbmZvPzogTWZhRW5yb2xsbWVudFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldEFjY291bnRJbmZvUmVxdWVzdCB7XG4gIGlkVG9rZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRBY2NvdW50SW5mb1Jlc3BvbnNlIHtcbiAgdXNlcnM6IEFQSVVzZXJJbmZvW107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50SW5mbyhcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogR2V0QWNjb3VudEluZm9SZXF1ZXN0XG4pOiBQcm9taXNlPEdldEFjY291bnRJbmZvUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxHZXRBY2NvdW50SW5mb1JlcXVlc3QsIEdldEFjY291bnRJbmZvUmVzcG9uc2U+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LkdFVF9BQ0NPVU5UX0lORk8sXG4gICAgcmVxdWVzdFxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyhcbiAgdXRjVGltZXN0YW1wPzogc3RyaW5nIHwgbnVtYmVyXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoIXV0Y1RpbWVzdGFtcCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBDb252ZXJ0IHRvIGRhdGUgb2JqZWN0LlxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShOdW1iZXIodXRjVGltZXN0YW1wKSk7XG4gICAgLy8gVGVzdCBkYXRlIGlzIHZhbGlkLlxuICAgIGlmICghaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIFVUQyBkYXRlIHN0cmluZy5cbiAgICAgIHJldHVybiBkYXRlLnRvVVRDU3RyaW5nKCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gRG8gbm90aGluZy4gdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQuXG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IElkVG9rZW5SZXN1bHQsIFBhcnNlZFRva2VuLCBVc2VyIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IGJhc2U2NERlY29kZSwgZ2V0TW9kdWxhckluc3RhbmNlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBfbG9nRXJyb3IgfSBmcm9tICcuLi91dGlsL2xvZyc7XG5pbXBvcnQgeyB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcgfSBmcm9tICcuLi91dGlsL3RpbWUnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbi8qKlxuICogUmV0dXJucyBhIEpTT04gV2ViIFRva2VuIChKV1QpIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHVzZXIgdG8gYSBGaXJlYmFzZSBzZXJ2aWNlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRva2VuIGlmIGl0IGhhcyBub3QgZXhwaXJlZCBvciBpZiBpdCB3aWxsIG5vdCBleHBpcmUgaW4gdGhlIG5leHQgZml2ZVxuICogbWludXRlcy4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgcmVmcmVzaCB0aGUgdG9rZW4gYW5kIHJldHVybiBhIG5ldyBvbmUuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBmb3JjZVJlZnJlc2ggLSBGb3JjZSByZWZyZXNoIHJlZ2FyZGxlc3Mgb2YgdG9rZW4gZXhwaXJhdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJZFRva2VuKHVzZXI6IFVzZXIsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKS5nZXRJZFRva2VuKGZvcmNlUmVmcmVzaCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGRlc2VyaWFsaXplZCBKU09OIFdlYiBUb2tlbiAoSldUKSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB1c2VyIHRvIGEgRmlyZWJhc2Ugc2VydmljZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogUmV0dXJucyB0aGUgY3VycmVudCB0b2tlbiBpZiBpdCBoYXMgbm90IGV4cGlyZWQgb3IgaWYgaXQgd2lsbCBub3QgZXhwaXJlIGluIHRoZSBuZXh0IGZpdmVcbiAqIG1pbnV0ZXMuIE90aGVyd2lzZSwgdGhpcyB3aWxsIHJlZnJlc2ggdGhlIHRva2VuIGFuZCByZXR1cm4gYSBuZXcgb25lLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gRm9yY2UgcmVmcmVzaCByZWdhcmRsZXNzIG9mIHRva2VuIGV4cGlyYXRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SWRUb2tlblJlc3VsdChcbiAgdXNlcjogVXNlcixcbiAgZm9yY2VSZWZyZXNoID0gZmFsc2Vcbik6IFByb21pc2U8SWRUb2tlblJlc3VsdD4ge1xuICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsO1xuICBjb25zdCB0b2tlbiA9IGF3YWl0IHVzZXJJbnRlcm5hbC5nZXRJZFRva2VuKGZvcmNlUmVmcmVzaCk7XG4gIGNvbnN0IGNsYWltcyA9IF9wYXJzZVRva2VuKHRva2VuKTtcblxuICBfYXNzZXJ0KFxuICAgIGNsYWltcyAmJiBjbGFpbXMuZXhwICYmIGNsYWltcy5hdXRoX3RpbWUgJiYgY2xhaW1zLmlhdCxcbiAgICB1c2VySW50ZXJuYWwuYXV0aCxcbiAgICBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SXG4gICk7XG4gIGNvbnN0IGZpcmViYXNlID1cbiAgICB0eXBlb2YgY2xhaW1zLmZpcmViYXNlID09PSAnb2JqZWN0JyA/IGNsYWltcy5maXJlYmFzZSA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBzaWduSW5Qcm92aWRlcjogc3RyaW5nIHwgdW5kZWZpbmVkID0gZmlyZWJhc2U/Llsnc2lnbl9pbl9wcm92aWRlciddO1xuXG4gIHJldHVybiB7XG4gICAgY2xhaW1zLFxuICAgIHRva2VuLFxuICAgIGF1dGhUaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoXG4gICAgICBzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoY2xhaW1zLmF1dGhfdGltZSlcbiAgICApISxcbiAgICBpc3N1ZWRBdFRpbWU6IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyhcbiAgICAgIHNlY29uZHNTdHJpbmdUb01pbGxpc2Vjb25kcyhjbGFpbXMuaWF0KVxuICAgICkhLFxuICAgIGV4cGlyYXRpb25UaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoXG4gICAgICBzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoY2xhaW1zLmV4cClcbiAgICApISxcbiAgICBzaWduSW5Qcm92aWRlcjogc2lnbkluUHJvdmlkZXIgfHwgbnVsbCxcbiAgICBzaWduSW5TZWNvbmRGYWN0b3I6IGZpcmViYXNlPy5bJ3NpZ25faW5fc2Vjb25kX2ZhY3RvciddIHx8IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKHNlY29uZHM6IHN0cmluZyk6IG51bWJlciB7XG4gIHJldHVybiBOdW1iZXIoc2Vjb25kcykgKiAxMDAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3BhcnNlVG9rZW4odG9rZW46IHN0cmluZyk6IFBhcnNlZFRva2VuIHwgbnVsbCB7XG4gIGNvbnN0IFthbGdvcml0aG0sIHBheWxvYWQsIHNpZ25hdHVyZV0gPSB0b2tlbi5zcGxpdCgnLicpO1xuICBpZiAoXG4gICAgYWxnb3JpdGhtID09PSB1bmRlZmluZWQgfHxcbiAgICBwYXlsb2FkID09PSB1bmRlZmluZWQgfHxcbiAgICBzaWduYXR1cmUgPT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBfbG9nRXJyb3IoJ0pXVCBtYWxmb3JtZWQsIGNvbnRhaW5lZCBmZXdlciB0aGFuIDMgc2VjdGlvbnMnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGJhc2U2NERlY29kZShwYXlsb2FkKTtcbiAgICBpZiAoIWRlY29kZWQpIHtcbiAgICAgIF9sb2dFcnJvcignRmFpbGVkIHRvIGRlY29kZSBiYXNlNjQgSldUIHBheWxvYWQnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIF9sb2dFcnJvcihcbiAgICAgICdDYXVnaHQgZXJyb3IgcGFyc2luZyBKV1QgcGF5bG9hZCBhcyBKU09OJyxcbiAgICAgIChlIGFzIEVycm9yKT8udG9TdHJpbmcoKVxuICAgICk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGV4cGlyZXNJbiBUVEwgZnJvbSBhIHRva2VuIGJ5IHN1YnRyYWN0aW5nIHRoZSBleHBpcmF0aW9uIGZyb20gdGhlIGlzc3VhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX3Rva2VuRXhwaXJlc0luKHRva2VuOiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBwYXJzZWRUb2tlbiA9IF9wYXJzZVRva2VuKHRva2VuKTtcbiAgX2Fzc2VydChwYXJzZWRUb2tlbiwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gIF9hc3NlcnQodHlwZW9mIHBhcnNlZFRva2VuLmV4cCAhPT0gJ3VuZGVmaW5lZCcsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICBfYXNzZXJ0KHR5cGVvZiBwYXJzZWRUb2tlbi5pYXQgIT09ICd1bmRlZmluZWQnLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgcmV0dXJuIE51bWJlcihwYXJzZWRUb2tlbi5leHApIC0gTnVtYmVyKHBhcnNlZFRva2VuLmlhdCk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX2xvZ291dElmSW52YWxpZGF0ZWQ8VD4oXG4gIHVzZXI6IFVzZXJJbnRlcm5hbCxcbiAgcHJvbWlzZTogUHJvbWlzZTxUPixcbiAgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2Vcbik6IFByb21pc2U8VD4ge1xuICBpZiAoYnlwYXNzQXV0aFN0YXRlKSB7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvciAmJiBpc1VzZXJJbnZhbGlkYXRlZChlKSkge1xuICAgICAgaWYgKHVzZXIuYXV0aC5jdXJyZW50VXNlciA9PT0gdXNlcikge1xuICAgICAgICBhd2FpdCB1c2VyLmF1dGguc2lnbk91dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVc2VySW52YWxpZGF0ZWQoeyBjb2RlIH06IEZpcmViYXNlRXJyb3IpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBjb2RlID09PSBgYXV0aC8ke0F1dGhFcnJvckNvZGUuVVNFUl9ESVNBQkxFRH1gIHx8XG4gICAgY29kZSA9PT0gYGF1dGgvJHtBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUR9YFxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbi8vIFJlZnJlc2ggdGhlIHRva2VuIGZpdmUgbWludXRlcyBiZWZvcmUgZXhwaXJhdGlvblxuZXhwb3J0IGNvbnN0IGVudW0gRHVyYXRpb24ge1xuICBPRkZTRVQgPSA1ICogMTAwMCAqIDYwLFxuICBSRVRSWV9CQUNLT0ZGX01JTiA9IDMwICogMTAwMCxcbiAgUkVUUllfQkFDS09GRl9NQVggPSAxNiAqIDYwICogMTAwMFxufVxuXG5leHBvcnQgY2xhc3MgUHJvYWN0aXZlUmVmcmVzaCB7XG4gIHByaXZhdGUgaXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgLy8gTm9kZSB0aW1lcnMgYW5kIGJyb3dzZXIgdGltZXJzIHJldHVybiBmdW5kYW1lbnRhbGx5IGRpZmZlcmVudCB0eXBlcy5cbiAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgY2FyZSB3aGF0IHRoZSB2YWx1ZSBpcyBidXQgVFMgd29uJ3QgYWNjZXB0IHVua25vd24gYW5kXG4gIC8vIHdlIGNhbid0IGNhc3QgcHJvcGVybHkgaW4gYm90aCBlbnZpcm9ubWVudHMuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHByaXZhdGUgdGltZXJJZDogYW55IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZXJyb3JCYWNrb2ZmID0gRHVyYXRpb24uUkVUUllfQkFDS09GRl9NSU47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB1c2VyOiBVc2VySW50ZXJuYWwpIHt9XG5cbiAgX3N0YXJ0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzUnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnNjaGVkdWxlKCk7XG4gIH1cblxuICBfc3RvcCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy50aW1lcklkICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEludGVydmFsKHdhc0Vycm9yOiBib29sZWFuKTogbnVtYmVyIHtcbiAgICBpZiAod2FzRXJyb3IpIHtcbiAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5lcnJvckJhY2tvZmY7XG4gICAgICB0aGlzLmVycm9yQmFja29mZiA9IE1hdGgubWluKFxuICAgICAgICB0aGlzLmVycm9yQmFja29mZiAqIDIsXG4gICAgICAgIER1cmF0aW9uLlJFVFJZX0JBQ0tPRkZfTUFYXG4gICAgICApO1xuICAgICAgcmV0dXJuIGludGVydmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCB0aGUgZXJyb3IgYmFja29mZlxuICAgICAgdGhpcy5lcnJvckJhY2tvZmYgPSBEdXJhdGlvbi5SRVRSWV9CQUNLT0ZGX01JTjtcbiAgICAgIGNvbnN0IGV4cFRpbWUgPSB0aGlzLnVzZXIuc3RzVG9rZW5NYW5hZ2VyLmV4cGlyYXRpb25UaW1lID8/IDA7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IGV4cFRpbWUgLSBEYXRlLm5vdygpIC0gRHVyYXRpb24uT0ZGU0VUO1xuXG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgaW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2NoZWR1bGUod2FzRXJyb3IgPSBmYWxzZSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIC8vIEp1c3QgaW4gY2FzZS4uLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5nZXRJbnRlcnZhbCh3YXNFcnJvcik7XG4gICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLml0ZXJhdGlvbigpO1xuICAgIH0sIGludGVydmFsKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaXRlcmF0aW9uKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnVzZXIuZ2V0SWRUb2tlbih0cnVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBPbmx5IHJldHJ5IG9uIG5ldHdvcmsgZXJyb3JzXG4gICAgICBpZiAoXG4gICAgICAgIChlIGFzIEZpcmViYXNlRXJyb3IpPy5jb2RlID09PVxuICAgICAgICBgYXV0aC8ke0F1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRH1gXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZSgvKiB3YXNFcnJvciAqLyB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNjaGVkdWxlKCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFVzZXJNZXRhZGF0YSBhcyBVc2VyTWV0YWRhdGFUeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHsgdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nIH0gZnJvbSAnLi4vdXRpbC90aW1lJztcblxuZXhwb3J0IGNsYXNzIFVzZXJNZXRhZGF0YSBpbXBsZW1lbnRzIFVzZXJNZXRhZGF0YVR5cGUge1xuICBjcmVhdGlvblRpbWU/OiBzdHJpbmc7XG4gIGxhc3RTaWduSW5UaW1lPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY3JlYXRlZEF0Pzogc3RyaW5nIHwgbnVtYmVyLFxuICAgIHByaXZhdGUgbGFzdExvZ2luQXQ/OiBzdHJpbmcgfCBudW1iZXJcbiAgKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZVRpbWUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRpYWxpemVUaW1lKCk6IHZvaWQge1xuICAgIHRoaXMubGFzdFNpZ25JblRpbWUgPSB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcodGhpcy5sYXN0TG9naW5BdCk7XG4gICAgdGhpcy5jcmVhdGlvblRpbWUgPSB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcodGhpcy5jcmVhdGVkQXQpO1xuICB9XG5cbiAgX2NvcHkobWV0YWRhdGE6IFVzZXJNZXRhZGF0YSk6IHZvaWQge1xuICAgIHRoaXMuY3JlYXRlZEF0ID0gbWV0YWRhdGEuY3JlYXRlZEF0O1xuICAgIHRoaXMubGFzdExvZ2luQXQgPSBtZXRhZGF0YS5sYXN0TG9naW5BdDtcbiAgICB0aGlzLl9pbml0aWFsaXplVGltZSgpO1xuICB9XG5cbiAgdG9KU09OKCk6IG9iamVjdCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZWRBdDogdGhpcy5jcmVhdGVkQXQsXG4gICAgICBsYXN0TG9naW5BdDogdGhpcy5sYXN0TG9naW5BdFxuICAgIH07XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFVzZXIsIFVzZXJJbmZvIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHtcbiAgZ2V0QWNjb3VudEluZm8sXG4gIFByb3ZpZGVyVXNlckluZm9cbn0gZnJvbSAnLi4vLi4vYXBpL2FjY291bnRfbWFuYWdlbWVudC9hY2NvdW50JztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgX2xvZ291dElmSW52YWxpZGF0ZWQgfSBmcm9tICcuL2ludmFsaWRhdGlvbic7XG5pbXBvcnQgeyBVc2VyTWV0YWRhdGEgfSBmcm9tICcuL3VzZXJfbWV0YWRhdGEnO1xuaW1wb3J0IHsgZ2V0TW9kdWxhckluc3RhbmNlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlcjogVXNlckludGVybmFsKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGF1dGggPSB1c2VyLmF1dGg7XG4gIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZChcbiAgICB1c2VyLFxuICAgIGdldEFjY291bnRJbmZvKGF1dGgsIHsgaWRUb2tlbiB9KVxuICApO1xuXG4gIF9hc3NlcnQocmVzcG9uc2U/LnVzZXJzLmxlbmd0aCwgYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG5cbiAgY29uc3QgY29yZUFjY291bnQgPSByZXNwb25zZS51c2Vyc1swXTtcblxuICB1c2VyLl9ub3RpZnlSZWxvYWRMaXN0ZW5lcihjb3JlQWNjb3VudCk7XG5cbiAgY29uc3QgbmV3UHJvdmlkZXJEYXRhID0gY29yZUFjY291bnQucHJvdmlkZXJVc2VySW5mbz8ubGVuZ3RoXG4gICAgPyBleHRyYWN0UHJvdmlkZXJEYXRhKGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pXG4gICAgOiBbXTtcblxuICBjb25zdCBwcm92aWRlckRhdGEgPSBtZXJnZVByb3ZpZGVyRGF0YSh1c2VyLnByb3ZpZGVyRGF0YSwgbmV3UHJvdmlkZXJEYXRhKTtcblxuICAvLyBQcmVzZXJ2ZXMgdGhlIG5vbi1ub255bW91cyBzdGF0dXMgb2YgdGhlIHN0b3JlZCB1c2VyLCBldmVuIGlmIG5vIG1vcmVcbiAgLy8gY3JlZGVudGlhbHMgKGZlZGVyYXRlZCBvciBlbWFpbC9wYXNzd29yZCkgYXJlIGxpbmtlZCB0byB0aGUgdXNlci4gSWZcbiAgLy8gdGhlIHVzZXIgd2FzIHByZXZpb3VzbHkgYW5vbnltb3VzLCB0aGVuIHVzZSBwcm92aWRlciBkYXRhIHRvIHVwZGF0ZS5cbiAgLy8gT24gdGhlIG90aGVyIGhhbmQsIGlmIGl0IHdhcyBub3QgYW5vbnltb3VzIGJlZm9yZSwgaXQgc2hvdWxkIG5ldmVyIGJlXG4gIC8vIGNvbnNpZGVyZWQgYW5vbnltb3VzIG5vdy5cbiAgY29uc3Qgb2xkSXNBbm9ueW1vdXMgPSB1c2VyLmlzQW5vbnltb3VzO1xuICBjb25zdCBuZXdJc0Fub255bW91cyA9XG4gICAgISh1c2VyLmVtYWlsICYmIGNvcmVBY2NvdW50LnBhc3N3b3JkSGFzaCkgJiYgIXByb3ZpZGVyRGF0YT8ubGVuZ3RoO1xuICBjb25zdCBpc0Fub255bW91cyA9ICFvbGRJc0Fub255bW91cyA/IGZhbHNlIDogbmV3SXNBbm9ueW1vdXM7XG5cbiAgY29uc3QgdXBkYXRlczogUGFydGlhbDxVc2VySW50ZXJuYWw+ID0ge1xuICAgIHVpZDogY29yZUFjY291bnQubG9jYWxJZCxcbiAgICBkaXNwbGF5TmFtZTogY29yZUFjY291bnQuZGlzcGxheU5hbWUgfHwgbnVsbCxcbiAgICBwaG90b1VSTDogY29yZUFjY291bnQucGhvdG9VcmwgfHwgbnVsbCxcbiAgICBlbWFpbDogY29yZUFjY291bnQuZW1haWwgfHwgbnVsbCxcbiAgICBlbWFpbFZlcmlmaWVkOiBjb3JlQWNjb3VudC5lbWFpbFZlcmlmaWVkIHx8IGZhbHNlLFxuICAgIHBob25lTnVtYmVyOiBjb3JlQWNjb3VudC5waG9uZU51bWJlciB8fCBudWxsLFxuICAgIHRlbmFudElkOiBjb3JlQWNjb3VudC50ZW5hbnRJZCB8fCBudWxsLFxuICAgIHByb3ZpZGVyRGF0YSxcbiAgICBtZXRhZGF0YTogbmV3IFVzZXJNZXRhZGF0YShjb3JlQWNjb3VudC5jcmVhdGVkQXQsIGNvcmVBY2NvdW50Lmxhc3RMb2dpbkF0KSxcbiAgICBpc0Fub255bW91c1xuICB9O1xuXG4gIE9iamVjdC5hc3NpZ24odXNlciwgdXBkYXRlcyk7XG59XG5cbi8qKlxuICogUmVsb2FkcyB1c2VyIGFjY291bnQgZGF0YSwgaWYgc2lnbmVkIGluLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVsb2FkKHVzZXI6IFVzZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgdXNlckludGVybmFsOiBVc2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsO1xuICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VySW50ZXJuYWwpO1xuXG4gIC8vIEV2ZW4gdGhvdWdoIHRoZSBjdXJyZW50IHVzZXIgaGFzbid0IGNoYW5nZWQsIHVwZGF0ZVxuICAvLyBjdXJyZW50IHVzZXIgd2lsbCB0cmlnZ2VyIGEgcGVyc2lzdGVuY2UgdXBkYXRlIHcvIHRoZVxuICAvLyBuZXcgaW5mby5cbiAgYXdhaXQgdXNlckludGVybmFsLmF1dGguX3BlcnNpc3RVc2VySWZDdXJyZW50KHVzZXJJbnRlcm5hbCk7XG4gIHVzZXJJbnRlcm5hbC5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodXNlckludGVybmFsKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm92aWRlckRhdGEoXG4gIG9yaWdpbmFsOiBVc2VySW5mb1tdLFxuICBuZXdEYXRhOiBVc2VySW5mb1tdXG4pOiBVc2VySW5mb1tdIHtcbiAgY29uc3QgZGVkdXBlZCA9IG9yaWdpbmFsLmZpbHRlcihcbiAgICBvID0+ICFuZXdEYXRhLnNvbWUobiA9PiBuLnByb3ZpZGVySWQgPT09IG8ucHJvdmlkZXJJZClcbiAgKTtcbiAgcmV0dXJuIFsuLi5kZWR1cGVkLCAuLi5uZXdEYXRhXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByb3ZpZGVyRGF0YShwcm92aWRlcnM6IFByb3ZpZGVyVXNlckluZm9bXSk6IFVzZXJJbmZvW10ge1xuICByZXR1cm4gcHJvdmlkZXJzLm1hcCgoeyBwcm92aWRlcklkLCAuLi5wcm92aWRlciB9KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3ZpZGVySWQsXG4gICAgICB1aWQ6IHByb3ZpZGVyLnJhd0lkIHx8ICcnLFxuICAgICAgZGlzcGxheU5hbWU6IHByb3ZpZGVyLmRpc3BsYXlOYW1lIHx8IG51bGwsXG4gICAgICBlbWFpbDogcHJvdmlkZXIuZW1haWwgfHwgbnVsbCxcbiAgICAgIHBob25lTnVtYmVyOiBwcm92aWRlci5waG9uZU51bWJlciB8fCBudWxsLFxuICAgICAgcGhvdG9VUkw6IHByb3ZpZGVyLnBob3RvVXJsIHx8IG51bGxcbiAgICB9O1xuICB9KTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuXG5pbXBvcnQgeyBxdWVyeXN0cmluZyB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHtcbiAgX2dldEZpbmFsVGFyZ2V0LFxuICBfcGVyZm9ybUZldGNoV2l0aEVycm9ySGFuZGxpbmcsXG4gIEh0dHBNZXRob2QsXG4gIEh0dHBIZWFkZXJcbn0gZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgRmV0Y2hQcm92aWRlciB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9mZXRjaF9wcm92aWRlcic7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuXG5leHBvcnQgY29uc3QgZW51bSBFbmRwb2ludCB7XG4gIFRPS0VOID0gJy92MS90b2tlbidcbn1cblxuLyoqIFRoZSBzZXJ2ZXIgcmVzcG9uc2VzIHdpdGggc25ha2VfY2FzZTsgd2UgY29udmVydCB0byBjYW1lbENhc2UgKi9cbmludGVyZmFjZSBSZXF1ZXN0U3RzVG9rZW5TZXJ2ZXJSZXNwb25zZSB7XG4gIGFjY2Vzc190b2tlbjogc3RyaW5nO1xuICBleHBpcmVzX2luOiBzdHJpbmc7XG4gIHJlZnJlc2hfdG9rZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXF1ZXN0U3RzVG9rZW5SZXNwb25zZSB7XG4gIGFjY2Vzc1Rva2VuOiBzdHJpbmc7XG4gIGV4cGlyZXNJbjogc3RyaW5nO1xuICByZWZyZXNoVG9rZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RTdHNUb2tlbihcbiAgYXV0aDogQXV0aCxcbiAgcmVmcmVzaFRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8UmVxdWVzdFN0c1Rva2VuUmVzcG9uc2U+IHtcbiAgY29uc3QgcmVzcG9uc2UgPVxuICAgIGF3YWl0IF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZzxSZXF1ZXN0U3RzVG9rZW5TZXJ2ZXJSZXNwb25zZT4oXG4gICAgICBhdXRoLFxuICAgICAge30sXG4gICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBxdWVyeXN0cmluZyh7XG4gICAgICAgICAgJ2dyYW50X3R5cGUnOiAncmVmcmVzaF90b2tlbicsXG4gICAgICAgICAgJ3JlZnJlc2hfdG9rZW4nOiByZWZyZXNoVG9rZW5cbiAgICAgICAgfSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHsgdG9rZW5BcGlIb3N0LCBhcGlLZXkgfSA9IGF1dGguY29uZmlnO1xuICAgICAgICBjb25zdCB1cmwgPSBfZ2V0RmluYWxUYXJnZXQoXG4gICAgICAgICAgYXV0aCxcbiAgICAgICAgICB0b2tlbkFwaUhvc3QsXG4gICAgICAgICAgRW5kcG9pbnQuVE9LRU4sXG4gICAgICAgICAgYGtleT0ke2FwaUtleX1gXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IChhdXRoIGFzIEF1dGhJbnRlcm5hbCkuX2dldEFkZGl0aW9uYWxIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnNbSHR0cEhlYWRlci5DT05URU5UX1RZUEVdID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG5cbiAgICAgICAgcmV0dXJuIEZldGNoUHJvdmlkZXIuZmV0Y2goKSh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IEh0dHBNZXRob2QuUE9TVCxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcblxuICAvLyBUaGUgcmVzcG9uc2UgY29tZXMgYmFjayBpbiBzbmFrZV9jYXNlLiBDb252ZXJ0IHRvIGNhbWVsOlxuICByZXR1cm4ge1xuICAgIGFjY2Vzc1Rva2VuOiByZXNwb25zZS5hY2Nlc3NfdG9rZW4sXG4gICAgZXhwaXJlc0luOiByZXNwb25zZS5leHBpcmVzX2luLFxuICAgIHJlZnJlc2hUb2tlbjogcmVzcG9uc2UucmVmcmVzaF90b2tlblxuICB9O1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmluYWxpemVNZmFSZXNwb25zZSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9tZmEnO1xuaW1wb3J0IHsgcmVxdWVzdFN0c1Rva2VuIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL3Rva2VuJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBQZXJzaXN0ZWRCbG9iIH0gZnJvbSAnLi4vcGVyc2lzdGVuY2UnO1xuaW1wb3J0IHsgX2Fzc2VydCwgZGVidWdGYWlsIH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgX3Rva2VuRXhwaXJlc0luIH0gZnJvbSAnLi9pZF90b2tlbl9yZXN1bHQnO1xuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgb2ZmaWNpYWwgZXhwaXJhdGlvbiB0aW1lIG9mIGEgdG9rZW5cbiAqIHRvIHJlZnJlc2ggdGhhdCB0b2tlbiwgdG8gcHJvdmlkZSBhIGJ1ZmZlciBmb3IgUlBDcyB0byBjb21wbGV0ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gQnVmZmVyIHtcbiAgVE9LRU5fUkVGUkVTSCA9IDMwXzAwMFxufVxuXG4vKipcbiAqIFdlIG5lZWQgdG8gbWFyayB0aGlzIGNsYXNzIGFzIGludGVybmFsIGV4cGxpY2l0bHkgdG8gZXhjbHVkZSBpdCBpbiB0aGUgcHVibGljIHR5cGluZ3MsIGJlY2F1c2VcbiAqIGl0IHJlZmVyZW5jZXMgQXV0aEludGVybmFsIHdoaWNoIGhhcyBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCBVc2VySW50ZXJuYWwuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHNUb2tlbk1hbmFnZXIge1xuICByZWZyZXNoVG9rZW46IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBhY2Nlc3NUb2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIGV4cGlyYXRpb25UaW1lOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBnZXQgaXNFeHBpcmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICAhdGhpcy5leHBpcmF0aW9uVGltZSB8fFxuICAgICAgRGF0ZS5ub3coKSA+IHRoaXMuZXhwaXJhdGlvblRpbWUgLSBCdWZmZXIuVE9LRU5fUkVGUkVTSFxuICAgICk7XG4gIH1cblxuICB1cGRhdGVGcm9tU2VydmVyUmVzcG9uc2UoXG4gICAgcmVzcG9uc2U6IElkVG9rZW5SZXNwb25zZSB8IEZpbmFsaXplTWZhUmVzcG9uc2VcbiAgKTogdm9pZCB7XG4gICAgX2Fzc2VydChyZXNwb25zZS5pZFRva2VuLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICBfYXNzZXJ0KFxuICAgICAgdHlwZW9mIHJlc3BvbnNlLmlkVG9rZW4gIT09ICd1bmRlZmluZWQnLFxuICAgICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUlxuICAgICk7XG4gICAgX2Fzc2VydChcbiAgICAgIHR5cGVvZiByZXNwb25zZS5yZWZyZXNoVG9rZW4gIT09ICd1bmRlZmluZWQnLFxuICAgICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUlxuICAgICk7XG4gICAgY29uc3QgZXhwaXJlc0luID1cbiAgICAgICdleHBpcmVzSW4nIGluIHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZS5leHBpcmVzSW4gIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gTnVtYmVyKHJlc3BvbnNlLmV4cGlyZXNJbilcbiAgICAgICAgOiBfdG9rZW5FeHBpcmVzSW4ocmVzcG9uc2UuaWRUb2tlbik7XG4gICAgdGhpcy51cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKFxuICAgICAgcmVzcG9uc2UuaWRUb2tlbixcbiAgICAgIHJlc3BvbnNlLnJlZnJlc2hUb2tlbixcbiAgICAgIGV4cGlyZXNJblxuICAgICk7XG4gIH1cblxuICBhc3luYyBnZXRUb2tlbihcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgZm9yY2VSZWZyZXNoID0gZmFsc2VcbiAgKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgX2Fzc2VydChcbiAgICAgICF0aGlzLmFjY2Vzc1Rva2VuIHx8IHRoaXMucmVmcmVzaFRva2VuLFxuICAgICAgYXV0aCxcbiAgICAgIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRFxuICAgICk7XG5cbiAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiB0aGlzLmFjY2Vzc1Rva2VuICYmICF0aGlzLmlzRXhwaXJlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWNjZXNzVG9rZW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVmcmVzaFRva2VuKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlZnJlc2goYXV0aCwgdGhpcy5yZWZyZXNoVG9rZW4hKTtcbiAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY2xlYXJSZWZyZXNoVG9rZW4oKTogdm9pZCB7XG4gICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZWZyZXNoKGF1dGg6IEF1dGhJbnRlcm5hbCwgb2xkVG9rZW46IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgZXhwaXJlc0luIH0gPSBhd2FpdCByZXF1ZXN0U3RzVG9rZW4oXG4gICAgICBhdXRoLFxuICAgICAgb2xkVG9rZW5cbiAgICApO1xuICAgIHRoaXMudXBkYXRlVG9rZW5zQW5kRXhwaXJhdGlvbihcbiAgICAgIGFjY2Vzc1Rva2VuLFxuICAgICAgcmVmcmVzaFRva2VuLFxuICAgICAgTnVtYmVyKGV4cGlyZXNJbilcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKFxuICAgIGFjY2Vzc1Rva2VuOiBzdHJpbmcsXG4gICAgcmVmcmVzaFRva2VuOiBzdHJpbmcsXG4gICAgZXhwaXJlc0luU2VjOiBudW1iZXJcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5yZWZyZXNoVG9rZW4gPSByZWZyZXNoVG9rZW4gfHwgbnVsbDtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgbnVsbDtcbiAgICB0aGlzLmV4cGlyYXRpb25UaW1lID0gRGF0ZS5ub3coKSArIGV4cGlyZXNJblNlYyAqIDEwMDA7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oYXBwTmFtZTogc3RyaW5nLCBvYmplY3Q6IFBlcnNpc3RlZEJsb2IpOiBTdHNUb2tlbk1hbmFnZXIge1xuICAgIGNvbnN0IHsgcmVmcmVzaFRva2VuLCBhY2Nlc3NUb2tlbiwgZXhwaXJhdGlvblRpbWUgfSA9IG9iamVjdDtcblxuICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgU3RzVG9rZW5NYW5hZ2VyKCk7XG4gICAgaWYgKHJlZnJlc2hUb2tlbikge1xuICAgICAgX2Fzc2VydCh0eXBlb2YgcmVmcmVzaFRva2VuID09PSAnc3RyaW5nJywgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiwge1xuICAgICAgICBhcHBOYW1lXG4gICAgICB9KTtcbiAgICAgIG1hbmFnZXIucmVmcmVzaFRva2VuID0gcmVmcmVzaFRva2VuO1xuICAgIH1cbiAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgIF9hc3NlcnQodHlwZW9mIGFjY2Vzc1Rva2VuID09PSAnc3RyaW5nJywgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiwge1xuICAgICAgICBhcHBOYW1lXG4gICAgICB9KTtcbiAgICAgIG1hbmFnZXIuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBfYXNzZXJ0KFxuICAgICAgICB0eXBlb2YgZXhwaXJhdGlvblRpbWUgPT09ICdudW1iZXInLFxuICAgICAgICBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SLFxuICAgICAgICB7XG4gICAgICAgICAgYXBwTmFtZVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgbWFuYWdlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgICByZXR1cm4gbWFuYWdlcjtcbiAgfVxuXG4gIHRvSlNPTigpOiBvYmplY3Qge1xuICAgIHJldHVybiB7XG4gICAgICByZWZyZXNoVG9rZW46IHRoaXMucmVmcmVzaFRva2VuLFxuICAgICAgYWNjZXNzVG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgICBleHBpcmF0aW9uVGltZTogdGhpcy5leHBpcmF0aW9uVGltZVxuICAgIH07XG4gIH1cblxuICBfYXNzaWduKHN0c1Rva2VuTWFuYWdlcjogU3RzVG9rZW5NYW5hZ2VyKTogdm9pZCB7XG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbjtcbiAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5yZWZyZXNoVG9rZW47XG4gICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IHN0c1Rva2VuTWFuYWdlci5leHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIF9jbG9uZSgpOiBTdHNUb2tlbk1hbmFnZXIge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBTdHNUb2tlbk1hbmFnZXIoKSwgdGhpcy50b0pTT04oKSk7XG4gIH1cblxuICBfcGVyZm9ybVJlZnJlc2goKTogbmV2ZXIge1xuICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJZFRva2VuUmVzdWx0IH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IE5leHRGbiB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHtcbiAgQVBJVXNlckluZm8sXG4gIGRlbGV0ZUFjY291bnRcbn0gZnJvbSAnLi4vLi4vYXBpL2FjY291bnRfbWFuYWdlbWVudC9hY2NvdW50JztcbmltcG9ydCB7IEZpbmFsaXplTWZhUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vbWZhJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHtcbiAgTXV0YWJsZVVzZXJJbmZvLFxuICBVc2VySW50ZXJuYWwsXG4gIFVzZXJQYXJhbWV0ZXJzXG59IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBQZXJzaXN0ZWRCbG9iIH0gZnJvbSAnLi4vcGVyc2lzdGVuY2UnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IGdldElkVG9rZW5SZXN1bHQgfSBmcm9tICcuL2lkX3Rva2VuX3Jlc3VsdCc7XG5pbXBvcnQgeyBfbG9nb3V0SWZJbnZhbGlkYXRlZCB9IGZyb20gJy4vaW52YWxpZGF0aW9uJztcbmltcG9ydCB7IFByb2FjdGl2ZVJlZnJlc2ggfSBmcm9tICcuL3Byb2FjdGl2ZV9yZWZyZXNoJztcbmltcG9ydCB7IF9yZWxvYWRXaXRob3V0U2F2aW5nLCByZWxvYWQgfSBmcm9tICcuL3JlbG9hZCc7XG5pbXBvcnQgeyBTdHNUb2tlbk1hbmFnZXIgfSBmcm9tICcuL3Rva2VuX21hbmFnZXInO1xuaW1wb3J0IHsgVXNlck1ldGFkYXRhIH0gZnJvbSAnLi91c2VyX21ldGFkYXRhJztcbmltcG9ydCB7IFByb3ZpZGVySWQgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKFxuICBhc3NlcnRpb246IHVua25vd24sXG4gIGFwcE5hbWU6IHN0cmluZ1xuKTogYXNzZXJ0cyBhc3NlcnRpb24gaXMgc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgX2Fzc2VydChcbiAgICB0eXBlb2YgYXNzZXJ0aW9uID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXNzZXJ0aW9uID09PSAndW5kZWZpbmVkJyxcbiAgICBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SLFxuICAgIHsgYXBwTmFtZSB9XG4gICk7XG59XG5cbmV4cG9ydCBjbGFzcyBVc2VySW1wbCBpbXBsZW1lbnRzIFVzZXJJbnRlcm5hbCB7XG4gIC8vIEZvciB0aGUgdXNlciBvYmplY3QsIHByb3ZpZGVyIGlzIGFsd2F5cyBGaXJlYmFzZS5cbiAgcmVhZG9ubHkgcHJvdmlkZXJJZCA9IFByb3ZpZGVySWQuRklSRUJBU0U7XG4gIHN0c1Rva2VuTWFuYWdlcjogU3RzVG9rZW5NYW5hZ2VyO1xuICAvLyBMYXN0IGtub3duIGFjY2Vzc1Rva2VuIHNvIHdlIGtub3cgd2hlbiBpdCBjaGFuZ2VzXG4gIHByaXZhdGUgYWNjZXNzVG9rZW46IHN0cmluZyB8IG51bGw7XG5cbiAgdWlkOiBzdHJpbmc7XG4gIGF1dGg6IEF1dGhJbnRlcm5hbDtcbiAgZW1haWxWZXJpZmllZDogYm9vbGVhbjtcbiAgaXNBbm9ueW1vdXM6IGJvb2xlYW47XG4gIHRlbmFudElkOiBzdHJpbmcgfCBudWxsO1xuICByZWFkb25seSBtZXRhZGF0YTogVXNlck1ldGFkYXRhO1xuICBwcm92aWRlckRhdGE6IE11dGFibGVVc2VySW5mb1tdO1xuXG4gIC8vIE9wdGlvbmFsIGZpZWxkcyBmcm9tIFVzZXJJbmZvXG4gIGRpc3BsYXlOYW1lOiBzdHJpbmcgfCBudWxsO1xuICBlbWFpbDogc3RyaW5nIHwgbnVsbDtcbiAgcGhvbmVOdW1iZXI6IHN0cmluZyB8IG51bGw7XG4gIHBob3RvVVJMOiBzdHJpbmcgfCBudWxsO1xuXG4gIF9yZWRpcmVjdEV2ZW50SWQ/OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvYWN0aXZlUmVmcmVzaCA9IG5ldyBQcm9hY3RpdmVSZWZyZXNoKHRoaXMpO1xuXG4gIGNvbnN0cnVjdG9yKHsgdWlkLCBhdXRoLCBzdHNUb2tlbk1hbmFnZXIsIC4uLm9wdCB9OiBVc2VyUGFyYW1ldGVycykge1xuICAgIHRoaXMudWlkID0gdWlkO1xuICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIgPSBzdHNUb2tlbk1hbmFnZXI7XG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbjtcbiAgICB0aGlzLmRpc3BsYXlOYW1lID0gb3B0LmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgdGhpcy5lbWFpbCA9IG9wdC5lbWFpbCB8fCBudWxsO1xuICAgIHRoaXMuZW1haWxWZXJpZmllZCA9IG9wdC5lbWFpbFZlcmlmaWVkIHx8IGZhbHNlO1xuICAgIHRoaXMucGhvbmVOdW1iZXIgPSBvcHQucGhvbmVOdW1iZXIgfHwgbnVsbDtcbiAgICB0aGlzLnBob3RvVVJMID0gb3B0LnBob3RvVVJMIHx8IG51bGw7XG4gICAgdGhpcy5pc0Fub255bW91cyA9IG9wdC5pc0Fub255bW91cyB8fCBmYWxzZTtcbiAgICB0aGlzLnRlbmFudElkID0gb3B0LnRlbmFudElkIHx8IG51bGw7XG4gICAgdGhpcy5wcm92aWRlckRhdGEgPSBvcHQucHJvdmlkZXJEYXRhID8gWy4uLm9wdC5wcm92aWRlckRhdGFdIDogW107XG4gICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBVc2VyTWV0YWRhdGEoXG4gICAgICBvcHQuY3JlYXRlZEF0IHx8IHVuZGVmaW5lZCxcbiAgICAgIG9wdC5sYXN0TG9naW5BdCB8fCB1bmRlZmluZWRcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgZ2V0SWRUb2tlbihmb3JjZVJlZnJlc2g/OiBib29sZWFuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLmdldFRva2VuKHRoaXMuYXV0aCwgZm9yY2VSZWZyZXNoKVxuICAgICk7XG4gICAgX2Fzc2VydChhY2Nlc3NUb2tlbiwgdGhpcy5hdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcblxuICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuICE9PSBhY2Nlc3NUb2tlbikge1xuICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgICAgYXdhaXQgdGhpcy5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh0aGlzKTtcbiAgICAgIHRoaXMuYXV0aC5fbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2Nlc3NUb2tlbjtcbiAgfVxuXG4gIGdldElkVG9rZW5SZXN1bHQoZm9yY2VSZWZyZXNoPzogYm9vbGVhbik6IFByb21pc2U8SWRUb2tlblJlc3VsdD4ge1xuICAgIHJldHVybiBnZXRJZFRva2VuUmVzdWx0KHRoaXMsIGZvcmNlUmVmcmVzaCk7XG4gIH1cblxuICByZWxvYWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHJlbG9hZCh0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVsb2FkVXNlckluZm86IEFQSVVzZXJJbmZvIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcmVsb2FkTGlzdGVuZXI6IE5leHRGbjxBUElVc2VySW5mbz4gfCBudWxsID0gbnVsbDtcblxuICBfYXNzaWduKHVzZXI6IFVzZXJJbnRlcm5hbCk6IHZvaWQge1xuICAgIGlmICh0aGlzID09PSB1c2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9hc3NlcnQodGhpcy51aWQgPT09IHVzZXIudWlkLCB0aGlzLmF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgIHRoaXMuZGlzcGxheU5hbWUgPSB1c2VyLmRpc3BsYXlOYW1lO1xuICAgIHRoaXMucGhvdG9VUkwgPSB1c2VyLnBob3RvVVJMO1xuICAgIHRoaXMuZW1haWwgPSB1c2VyLmVtYWlsO1xuICAgIHRoaXMuZW1haWxWZXJpZmllZCA9IHVzZXIuZW1haWxWZXJpZmllZDtcbiAgICB0aGlzLnBob25lTnVtYmVyID0gdXNlci5waG9uZU51bWJlcjtcbiAgICB0aGlzLmlzQW5vbnltb3VzID0gdXNlci5pc0Fub255bW91cztcbiAgICB0aGlzLnRlbmFudElkID0gdXNlci50ZW5hbnRJZDtcbiAgICB0aGlzLnByb3ZpZGVyRGF0YSA9IHVzZXIucHJvdmlkZXJEYXRhLm1hcCh1c2VySW5mbyA9PiAoeyAuLi51c2VySW5mbyB9KSk7XG4gICAgdGhpcy5tZXRhZGF0YS5fY29weSh1c2VyLm1ldGFkYXRhKTtcbiAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci5fYXNzaWduKHVzZXIuc3RzVG9rZW5NYW5hZ2VyKTtcbiAgfVxuXG4gIF9jbG9uZShhdXRoOiBBdXRoSW50ZXJuYWwpOiBVc2VySW50ZXJuYWwge1xuICAgIGNvbnN0IG5ld1VzZXIgPSBuZXcgVXNlckltcGwoe1xuICAgICAgLi4udGhpcyxcbiAgICAgIGF1dGgsXG4gICAgICBzdHNUb2tlbk1hbmFnZXI6IHRoaXMuc3RzVG9rZW5NYW5hZ2VyLl9jbG9uZSgpXG4gICAgfSk7XG4gICAgbmV3VXNlci5tZXRhZGF0YS5fY29weSh0aGlzLm1ldGFkYXRhKTtcbiAgICByZXR1cm4gbmV3VXNlcjtcbiAgfVxuXG4gIF9vblJlbG9hZChjYWxsYmFjazogTmV4dEZuPEFQSVVzZXJJbmZvPik6IHZvaWQge1xuICAgIC8vIFRoZXJlIHNob3VsZCBvbmx5IGV2ZXIgYmUgb25lIGxpc3RlbmVyLCBhbmQgdGhhdCBpcyBhIHNpbmdsZSBpbnN0YW5jZSBvZiBNdWx0aUZhY3RvclVzZXJcbiAgICBfYXNzZXJ0KCF0aGlzLnJlbG9hZExpc3RlbmVyLCB0aGlzLmF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgIHRoaXMucmVsb2FkTGlzdGVuZXIgPSBjYWxsYmFjaztcbiAgICBpZiAodGhpcy5yZWxvYWRVc2VySW5mbykge1xuICAgICAgdGhpcy5fbm90aWZ5UmVsb2FkTGlzdGVuZXIodGhpcy5yZWxvYWRVc2VySW5mbyk7XG4gICAgICB0aGlzLnJlbG9hZFVzZXJJbmZvID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfbm90aWZ5UmVsb2FkTGlzdGVuZXIodXNlckluZm86IEFQSVVzZXJJbmZvKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucmVsb2FkTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMucmVsb2FkTGlzdGVuZXIodXNlckluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyBsaXN0ZW5lciBpcyBzdWJzY3JpYmVkIHlldCwgc2F2ZSB0aGUgcmVzdWx0IHNvIGl0J3MgYXZhaWxhYmxlIHdoZW4gdGhleSBkbyBzdWJzY3JpYmVcbiAgICAgIHRoaXMucmVsb2FkVXNlckluZm8gPSB1c2VySW5mbztcbiAgICB9XG4gIH1cblxuICBfc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCk6IHZvaWQge1xuICAgIHRoaXMucHJvYWN0aXZlUmVmcmVzaC5fc3RhcnQoKTtcbiAgfVxuXG4gIF9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpOiB2b2lkIHtcbiAgICB0aGlzLnByb2FjdGl2ZVJlZnJlc2guX3N0b3AoKTtcbiAgfVxuXG4gIGFzeW5jIF91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShcbiAgICByZXNwb25zZTogSWRUb2tlblJlc3BvbnNlIHwgRmluYWxpemVNZmFSZXNwb25zZSxcbiAgICByZWxvYWQgPSBmYWxzZVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgdG9rZW5zUmVmcmVzaGVkID0gZmFsc2U7XG4gICAgaWYgKFxuICAgICAgcmVzcG9uc2UuaWRUb2tlbiAmJlxuICAgICAgcmVzcG9uc2UuaWRUb2tlbiAhPT0gdGhpcy5zdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW5cbiAgICApIHtcbiAgICAgIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLnVwZGF0ZUZyb21TZXJ2ZXJSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICB0b2tlbnNSZWZyZXNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChyZWxvYWQpIHtcbiAgICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHRoaXMpO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuYXV0aC5fcGVyc2lzdFVzZXJJZkN1cnJlbnQodGhpcyk7XG4gICAgaWYgKHRva2Vuc1JlZnJlc2hlZCkge1xuICAgICAgdGhpcy5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB0aGlzLmdldElkVG9rZW4oKTtcbiAgICBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh0aGlzLCBkZWxldGVBY2NvdW50KHRoaXMuYXV0aCwgeyBpZFRva2VuIH0pKTtcbiAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci5jbGVhclJlZnJlc2hUb2tlbigpO1xuXG4gICAgLy8gVE9ETzogRGV0ZXJtaW5lIGlmIGNhbmNlbGxhYmxlLXByb21pc2VzIGFyZSBuZWNlc3NhcnkgdG8gdXNlIGluIHRoaXMgY2xhc3Mgc28gdGhhdCBkZWxldGUoKVxuICAgIC8vICAgICAgIGNhbmNlbHMgcGVuZGluZyBhY3Rpb25zLi4uXG5cbiAgICByZXR1cm4gdGhpcy5hdXRoLnNpZ25PdXQoKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBQZXJzaXN0ZWRCbG9iIHtcbiAgICByZXR1cm4ge1xuICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgIGVtYWlsOiB0aGlzLmVtYWlsIHx8IHVuZGVmaW5lZCxcbiAgICAgIGVtYWlsVmVyaWZpZWQ6IHRoaXMuZW1haWxWZXJpZmllZCxcbiAgICAgIGRpc3BsYXlOYW1lOiB0aGlzLmRpc3BsYXlOYW1lIHx8IHVuZGVmaW5lZCxcbiAgICAgIGlzQW5vbnltb3VzOiB0aGlzLmlzQW5vbnltb3VzLFxuICAgICAgcGhvdG9VUkw6IHRoaXMucGhvdG9VUkwgfHwgdW5kZWZpbmVkLFxuICAgICAgcGhvbmVOdW1iZXI6IHRoaXMucGhvbmVOdW1iZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgdGVuYW50SWQ6IHRoaXMudGVuYW50SWQgfHwgdW5kZWZpbmVkLFxuICAgICAgcHJvdmlkZXJEYXRhOiB0aGlzLnByb3ZpZGVyRGF0YS5tYXAodXNlckluZm8gPT4gKHsgLi4udXNlckluZm8gfSkpLFxuICAgICAgc3RzVG9rZW5NYW5hZ2VyOiB0aGlzLnN0c1Rva2VuTWFuYWdlci50b0pTT04oKSxcbiAgICAgIC8vIFJlZGlyZWN0IGV2ZW50IElEIG11c3QgYmUgbWFpbnRhaW5lZCBpbiBjYXNlIHRoZXJlIGlzIGEgcGVuZGluZ1xuICAgICAgLy8gcmVkaXJlY3QgZXZlbnQuXG4gICAgICBfcmVkaXJlY3RFdmVudElkOiB0aGlzLl9yZWRpcmVjdEV2ZW50SWQsXG4gICAgICAuLi50aGlzLm1ldGFkYXRhLnRvSlNPTigpLFxuXG4gICAgICAvLyBSZXF1aXJlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBsZWdhY3kgU0RLIChnby9maXJlYmFzZS1hdXRoLXNkay1wZXJzaXN0ZW5jZS1wYXJzaW5nKTpcbiAgICAgIGFwaUtleTogdGhpcy5hdXRoLmNvbmZpZy5hcGlLZXksXG4gICAgICBhcHBOYW1lOiB0aGlzLmF1dGgubmFtZVxuICAgICAgLy8gTWlzc2luZyBhdXRoRG9tYWluIHdpbGwgYmUgdG9sZXJhdGVkIGJ5IHRoZSBsZWdhY3kgU0RLLlxuICAgICAgLy8gc3RzVG9rZW5NYW5hZ2VyLmFwaUtleSBpc24ndCBhY3R1YWxseSByZXF1aXJlZCAoZGVzcGl0ZSB0aGUgbGVnYWN5IFNESyBwZXJzaXN0aW5nIGl0KS5cbiAgICB9O1xuICB9XG5cbiAgZ2V0IHJlZnJlc2hUb2tlbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0c1Rva2VuTWFuYWdlci5yZWZyZXNoVG9rZW4gfHwgJyc7XG4gIH1cblxuICBzdGF0aWMgX2Zyb21KU09OKGF1dGg6IEF1dGhJbnRlcm5hbCwgb2JqZWN0OiBQZXJzaXN0ZWRCbG9iKTogVXNlckludGVybmFsIHtcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IG9iamVjdC5kaXNwbGF5TmFtZSA/PyB1bmRlZmluZWQ7XG4gICAgY29uc3QgZW1haWwgPSBvYmplY3QuZW1haWwgPz8gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHBob25lTnVtYmVyID0gb2JqZWN0LnBob25lTnVtYmVyID8/IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwaG90b1VSTCA9IG9iamVjdC5waG90b1VSTCA/PyB1bmRlZmluZWQ7XG4gICAgY29uc3QgdGVuYW50SWQgPSBvYmplY3QudGVuYW50SWQgPz8gdW5kZWZpbmVkO1xuICAgIGNvbnN0IF9yZWRpcmVjdEV2ZW50SWQgPSBvYmplY3QuX3JlZGlyZWN0RXZlbnRJZCA/PyB1bmRlZmluZWQ7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gb2JqZWN0LmNyZWF0ZWRBdCA/PyB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGFzdExvZ2luQXQgPSBvYmplY3QubGFzdExvZ2luQXQgPz8gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHtcbiAgICAgIHVpZCxcbiAgICAgIGVtYWlsVmVyaWZpZWQsXG4gICAgICBpc0Fub255bW91cyxcbiAgICAgIHByb3ZpZGVyRGF0YSxcbiAgICAgIHN0c1Rva2VuTWFuYWdlcjogcGxhaW5PYmplY3RUb2tlbk1hbmFnZXJcbiAgICB9ID0gb2JqZWN0O1xuXG4gICAgX2Fzc2VydCh1aWQgJiYgcGxhaW5PYmplY3RUb2tlbk1hbmFnZXIsIGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuXG4gICAgY29uc3Qgc3RzVG9rZW5NYW5hZ2VyID0gU3RzVG9rZW5NYW5hZ2VyLmZyb21KU09OKFxuICAgICAgdGhpcy5uYW1lLFxuICAgICAgcGxhaW5PYmplY3RUb2tlbk1hbmFnZXIgYXMgUGVyc2lzdGVkQmxvYlxuICAgICk7XG5cbiAgICBfYXNzZXJ0KHR5cGVvZiB1aWQgPT09ICdzdHJpbmcnLCBhdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChkaXNwbGF5TmFtZSwgYXV0aC5uYW1lKTtcbiAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChlbWFpbCwgYXV0aC5uYW1lKTtcbiAgICBfYXNzZXJ0KFxuICAgICAgdHlwZW9mIGVtYWlsVmVyaWZpZWQgPT09ICdib29sZWFuJyxcbiAgICAgIGF1dGgsXG4gICAgICBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SXG4gICAgKTtcbiAgICBfYXNzZXJ0KFxuICAgICAgdHlwZW9mIGlzQW5vbnltb3VzID09PSAnYm9vbGVhbicsXG4gICAgICBhdXRoLFxuICAgICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUlxuICAgICk7XG4gICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQocGhvbmVOdW1iZXIsIGF1dGgubmFtZSk7XG4gICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQocGhvdG9VUkwsIGF1dGgubmFtZSk7XG4gICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQodGVuYW50SWQsIGF1dGgubmFtZSk7XG4gICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoX3JlZGlyZWN0RXZlbnRJZCwgYXV0aC5uYW1lKTtcbiAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChjcmVhdGVkQXQsIGF1dGgubmFtZSk7XG4gICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQobGFzdExvZ2luQXQsIGF1dGgubmFtZSk7XG4gICAgY29uc3QgdXNlciA9IG5ldyBVc2VySW1wbCh7XG4gICAgICB1aWQsXG4gICAgICBhdXRoLFxuICAgICAgZW1haWwsXG4gICAgICBlbWFpbFZlcmlmaWVkLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICBpc0Fub255bW91cyxcbiAgICAgIHBob3RvVVJMLFxuICAgICAgcGhvbmVOdW1iZXIsXG4gICAgICB0ZW5hbnRJZCxcbiAgICAgIHN0c1Rva2VuTWFuYWdlcixcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGxhc3RMb2dpbkF0XG4gICAgfSk7XG5cbiAgICBpZiAocHJvdmlkZXJEYXRhICYmIEFycmF5LmlzQXJyYXkocHJvdmlkZXJEYXRhKSkge1xuICAgICAgdXNlci5wcm92aWRlckRhdGEgPSBwcm92aWRlckRhdGEubWFwKHVzZXJJbmZvID0+ICh7IC4uLnVzZXJJbmZvIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoX3JlZGlyZWN0RXZlbnRJZCkge1xuICAgICAgdXNlci5fcmVkaXJlY3RFdmVudElkID0gX3JlZGlyZWN0RXZlbnRJZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgVXNlciBmcm9tIGFuIGlkVG9rZW4gc2VydmVyIHJlc3BvbnNlXG4gICAqIEBwYXJhbSBhdXRoXG4gICAqIEBwYXJhbSBpZFRva2VuUmVzcG9uc2VcbiAgICovXG4gIHN0YXRpYyBhc3luYyBfZnJvbUlkVG9rZW5SZXNwb25zZShcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgaWRUb2tlblJlc3BvbnNlOiBJZFRva2VuUmVzcG9uc2UsXG4gICAgaXNBbm9ueW1vdXM6IGJvb2xlYW4gPSBmYWxzZVxuICApOiBQcm9taXNlPFVzZXJJbnRlcm5hbD4ge1xuICAgIGNvbnN0IHN0c1Rva2VuTWFuYWdlciA9IG5ldyBTdHNUb2tlbk1hbmFnZXIoKTtcbiAgICBzdHNUb2tlbk1hbmFnZXIudXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKGlkVG9rZW5SZXNwb25zZSk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBGaXJlYmFzZSBBdXRoIHVzZXIuXG4gICAgY29uc3QgdXNlciA9IG5ldyBVc2VySW1wbCh7XG4gICAgICB1aWQ6IGlkVG9rZW5SZXNwb25zZS5sb2NhbElkLFxuICAgICAgYXV0aCxcbiAgICAgIHN0c1Rva2VuTWFuYWdlcixcbiAgICAgIGlzQW5vbnltb3VzXG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGVzIHRoZSB1c2VyIGluZm8gYW5kIGRhdGEgYW5kIHJlc29sdmVzIHdpdGggYSB1c2VyIGluc3RhbmNlLlxuICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHVzZXIpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBkZWJ1Z0Fzc2VydCB9IGZyb20gJy4vYXNzZXJ0JztcblxuLyoqXG4gKiBPdXIgQVBJIGhhcyBhIGxvdCBvZiBvbmUtb2ZmIGNvbnN0YW50cyB0aGF0IGFyZSB1c2VkIHRvIGRvIHRoaW5ncy5cbiAqIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3QgZXhwb3J0IHRoZXNlIGFzIGNsYXNzZXMgaW5zdGFudGlhdGVkIGRpcmVjdGx5IHNpbmNlXG4gKiB0aGUgY29uc3RydWN0b3IgbWF5IHNpZGUgZWZmZWN0IGFuZCB0aGVyZWZvcmUgY2FuJ3QgYmUgcHJvdmVuIHRvIGJlIHNhZmVseVxuICogY3VsbGVkLiBJbnN0ZWFkLCB3ZSBleHBvcnQgdGhlc2UgY2xhc3NlcyB0aGVtc2VsdmVzIGFzIGEgbG93ZXJDYW1lbENhc2VcbiAqIGNvbnN0YW50LCBhbmQgaW5zdGFudGlhdGUgdGhlbSB1bmRlciB0aGUgaG9vZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaW5nbGV0b25JbnN0YW50aWF0b3I8VD4ge1xuICBuZXcgKCk6IFQ7XG59XG5cbmNvbnN0IGluc3RhbmNlQ2FjaGU6IE1hcDx1bmtub3duLCB1bmtub3duPiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRJbnN0YW5jZTxUPihjbHM6IHVua25vd24pOiBUIHtcbiAgZGVidWdBc3NlcnQoY2xzIGluc3RhbmNlb2YgRnVuY3Rpb24sICdFeHBlY3RlZCBhIGNsYXNzIGRlZmluaXRpb24nKTtcbiAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VDYWNoZS5nZXQoY2xzKSBhcyBUIHwgdW5kZWZpbmVkO1xuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGRlYnVnQXNzZXJ0KFxuICAgICAgaW5zdGFuY2UgaW5zdGFuY2VvZiBjbHMsXG4gICAgICAnSW5zdGFuY2Ugc3RvcmVkIGluIGNhY2hlIG1pc21hdGNoZWQgd2l0aCBjbGFzcydcbiAgICApO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIGluc3RhbmNlID0gbmV3IChjbHMgYXMgU2luZ2xldG9uSW5zdGFudGlhdG9yPFQ+KSgpO1xuICBpbnN0YW5jZUNhY2hlLnNldChjbHMsIGluc3RhbmNlKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2NsZWFySW5zdGFuY2VNYXAoKTogdm9pZCB7XG4gIGluc3RhbmNlQ2FjaGUuY2xlYXIoKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFBlcnNpc3RlbmNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHtcbiAgUGVyc2lzdGVuY2VJbnRlcm5hbCxcbiAgUGVyc2lzdGVuY2VUeXBlLFxuICBQZXJzaXN0ZW5jZVZhbHVlLFxuICBTdG9yYWdlRXZlbnRMaXN0ZW5lclxufSBmcm9tICcuLi9wZXJzaXN0ZW5jZSc7XG5cbmV4cG9ydCBjbGFzcyBJbk1lbW9yeVBlcnNpc3RlbmNlIGltcGxlbWVudHMgUGVyc2lzdGVuY2VJbnRlcm5hbCB7XG4gIHN0YXRpYyB0eXBlOiAnTk9ORScgPSAnTk9ORSc7XG4gIHJlYWRvbmx5IHR5cGUgPSBQZXJzaXN0ZW5jZVR5cGUuTk9ORTtcbiAgc3RvcmFnZTogUmVjb3JkPHN0cmluZywgUGVyc2lzdGVuY2VWYWx1ZT4gPSB7fTtcblxuICBhc3luYyBfaXNBdmFpbGFibGUoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBhc3luYyBfc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogUGVyc2lzdGVuY2VWYWx1ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuc3RvcmFnZVtrZXldID0gdmFsdWU7XG4gIH1cblxuICBhc3luYyBfZ2V0PFQgZXh0ZW5kcyBQZXJzaXN0ZW5jZVZhbHVlPihrZXk6IHN0cmluZyk6IFByb21pc2U8VCB8IG51bGw+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RvcmFnZVtrZXldO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6ICh2YWx1ZSBhcyBUKTtcbiAgfVxuXG4gIGFzeW5jIF9yZW1vdmUoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBkZWxldGUgdGhpcy5zdG9yYWdlW2tleV07XG4gIH1cblxuICBfYWRkTGlzdGVuZXIoX2tleTogc3RyaW5nLCBfbGlzdGVuZXI6IFN0b3JhZ2VFdmVudExpc3RlbmVyKTogdm9pZCB7XG4gICAgLy8gTGlzdGVuZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBpbi1tZW1vcnkgc3RvcmFnZSBzaW5jZSBpdCBjYW5ub3QgYmUgc2hhcmVkIGFjcm9zcyB3aW5kb3dzL3dvcmtlcnNcbiAgICByZXR1cm47XG4gIH1cblxuICBfcmVtb3ZlTGlzdGVuZXIoX2tleTogc3RyaW5nLCBfbGlzdGVuZXI6IFN0b3JhZ2VFdmVudExpc3RlbmVyKTogdm9pZCB7XG4gICAgLy8gTGlzdGVuZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBpbi1tZW1vcnkgc3RvcmFnZSBzaW5jZSBpdCBjYW5ub3QgYmUgc2hhcmVkIGFjcm9zcyB3aW5kb3dzL3dvcmtlcnNcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgUGVyc2lzdGVuY2V9IG9mIHR5cGUgJ05PTkUnLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGluTWVtb3J5UGVyc2lzdGVuY2U6IFBlcnNpc3RlbmNlID0gSW5NZW1vcnlQZXJzaXN0ZW5jZTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEFwaUtleSwgQXBwTmFtZSwgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IFBlcnNpc3RlZEJsb2IsIFBlcnNpc3RlbmNlSW50ZXJuYWwgfSBmcm9tICcuLi9wZXJzaXN0ZW5jZSc7XG5pbXBvcnQgeyBVc2VySW1wbCB9IGZyb20gJy4uL3VzZXIvdXNlcl9pbXBsJztcbmltcG9ydCB7IF9nZXRJbnN0YW5jZSB9IGZyb20gJy4uL3V0aWwvaW5zdGFudGlhdG9yJztcbmltcG9ydCB7IGluTWVtb3J5UGVyc2lzdGVuY2UgfSBmcm9tICcuL2luX21lbW9yeSc7XG5cbmV4cG9ydCBjb25zdCBlbnVtIEtleU5hbWUge1xuICBBVVRIX1VTRVIgPSAnYXV0aFVzZXInLFxuICBBVVRIX0VWRU5UID0gJ2F1dGhFdmVudCcsXG4gIFJFRElSRUNUX1VTRVIgPSAncmVkaXJlY3RVc2VyJyxcbiAgUEVSU0lTVEVOQ0VfVVNFUiA9ICdwZXJzaXN0ZW5jZSdcbn1cbmV4cG9ydCBjb25zdCBlbnVtIE5hbWVzcGFjZSB7XG4gIFBFUlNJU1RFTkNFID0gJ2ZpcmViYXNlJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3BlcnNpc3RlbmNlS2V5TmFtZShcbiAga2V5OiBzdHJpbmcsXG4gIGFwaUtleTogQXBpS2V5LFxuICBhcHBOYW1lOiBBcHBOYW1lXG4pOiBzdHJpbmcge1xuICByZXR1cm4gYCR7TmFtZXNwYWNlLlBFUlNJU1RFTkNFfToke2tleX06JHthcGlLZXl9OiR7YXBwTmFtZX1gO1xufVxuXG5leHBvcnQgY2xhc3MgUGVyc2lzdGVuY2VVc2VyTWFuYWdlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZnVsbFVzZXJLZXk6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBmdWxsUGVyc2lzdGVuY2VLZXk6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBib3VuZEV2ZW50SGFuZGxlcjogKCkgPT4gdm9pZDtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBwZXJzaXN0ZW5jZTogUGVyc2lzdGVuY2VJbnRlcm5hbCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHVzZXJLZXk6IHN0cmluZ1xuICApIHtcbiAgICBjb25zdCB7IGNvbmZpZywgbmFtZSB9ID0gdGhpcy5hdXRoO1xuICAgIHRoaXMuZnVsbFVzZXJLZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKHRoaXMudXNlcktleSwgY29uZmlnLmFwaUtleSwgbmFtZSk7XG4gICAgdGhpcy5mdWxsUGVyc2lzdGVuY2VLZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKFxuICAgICAgS2V5TmFtZS5QRVJTSVNURU5DRV9VU0VSLFxuICAgICAgY29uZmlnLmFwaUtleSxcbiAgICAgIG5hbWVcbiAgICApO1xuICAgIHRoaXMuYm91bmRFdmVudEhhbmRsZXIgPSBhdXRoLl9vblN0b3JhZ2VFdmVudC5iaW5kKGF1dGgpO1xuICAgIHRoaXMucGVyc2lzdGVuY2UuX2FkZExpc3RlbmVyKHRoaXMuZnVsbFVzZXJLZXksIHRoaXMuYm91bmRFdmVudEhhbmRsZXIpO1xuICB9XG5cbiAgc2V0Q3VycmVudFVzZXIodXNlcjogVXNlckludGVybmFsKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuX3NldCh0aGlzLmZ1bGxVc2VyS2V5LCB1c2VyLnRvSlNPTigpKTtcbiAgfVxuXG4gIGFzeW5jIGdldEN1cnJlbnRVc2VyKCk6IFByb21pc2U8VXNlckludGVybmFsIHwgbnVsbD4ge1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLl9nZXQ8UGVyc2lzdGVkQmxvYj4odGhpcy5mdWxsVXNlcktleSk7XG4gICAgcmV0dXJuIGJsb2IgPyBVc2VySW1wbC5fZnJvbUpTT04odGhpcy5hdXRoLCBibG9iKSA6IG51bGw7XG4gIH1cblxuICByZW1vdmVDdXJyZW50VXNlcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5fcmVtb3ZlKHRoaXMuZnVsbFVzZXJLZXkpO1xuICB9XG5cbiAgc2F2ZVBlcnNpc3RlbmNlRm9yUmVkaXJlY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuX3NldChcbiAgICAgIHRoaXMuZnVsbFBlcnNpc3RlbmNlS2V5LFxuICAgICAgdGhpcy5wZXJzaXN0ZW5jZS50eXBlXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIHNldFBlcnNpc3RlbmNlKG5ld1BlcnNpc3RlbmNlOiBQZXJzaXN0ZW5jZUludGVybmFsKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMucGVyc2lzdGVuY2UgPT09IG5ld1BlcnNpc3RlbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFVzZXIgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRVc2VyKCk7XG4gICAgYXdhaXQgdGhpcy5yZW1vdmVDdXJyZW50VXNlcigpO1xuXG4gICAgdGhpcy5wZXJzaXN0ZW5jZSA9IG5ld1BlcnNpc3RlbmNlO1xuXG4gICAgaWYgKGN1cnJlbnRVc2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VXNlcihjdXJyZW50VXNlcik7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMucGVyc2lzdGVuY2UuX3JlbW92ZUxpc3RlbmVyKHRoaXMuZnVsbFVzZXJLZXksIHRoaXMuYm91bmRFdmVudEhhbmRsZXIpO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZShcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgcGVyc2lzdGVuY2VIaWVyYXJjaHk6IFBlcnNpc3RlbmNlSW50ZXJuYWxbXSxcbiAgICB1c2VyS2V5ID0gS2V5TmFtZS5BVVRIX1VTRVJcbiAgKTogUHJvbWlzZTxQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyPiB7XG4gICAgaWYgKCFwZXJzaXN0ZW5jZUhpZXJhcmNoeS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VVc2VyTWFuYWdlcihcbiAgICAgICAgX2dldEluc3RhbmNlKGluTWVtb3J5UGVyc2lzdGVuY2UpLFxuICAgICAgICBhdXRoLFxuICAgICAgICB1c2VyS2V5XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEVsaW1pbmF0ZSBhbnkgcGVyc2lzdGVuY2VzIHRoYXQgYXJlIG5vdCBhdmFpbGFibGVcbiAgICBjb25zdCBhdmFpbGFibGVQZXJzaXN0ZW5jZXMgPSAoXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgcGVyc2lzdGVuY2VIaWVyYXJjaHkubWFwKGFzeW5jIHBlcnNpc3RlbmNlID0+IHtcbiAgICAgICAgICBpZiAoYXdhaXQgcGVyc2lzdGVuY2UuX2lzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwZXJzaXN0ZW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApLmZpbHRlcihwZXJzaXN0ZW5jZSA9PiBwZXJzaXN0ZW5jZSkgYXMgUGVyc2lzdGVuY2VJbnRlcm5hbFtdO1xuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBmaXJzdCBwZXJzaXN0ZW5jZSBsaXN0ZWQsIG9yIGluIG1lbW9yeSBpZiBub25lIGF2YWlsYWJsZVxuICAgIGxldCBzZWxlY3RlZFBlcnNpc3RlbmNlID1cbiAgICAgIGF2YWlsYWJsZVBlcnNpc3RlbmNlc1swXSB8fFxuICAgICAgX2dldEluc3RhbmNlPFBlcnNpc3RlbmNlSW50ZXJuYWw+KGluTWVtb3J5UGVyc2lzdGVuY2UpO1xuXG4gICAgY29uc3Qga2V5ID0gX3BlcnNpc3RlbmNlS2V5TmFtZSh1c2VyS2V5LCBhdXRoLmNvbmZpZy5hcGlLZXksIGF1dGgubmFtZSk7XG5cbiAgICAvLyBQdWxsIG91dCB0aGUgZXhpc3RpbmcgdXNlciwgc2V0dGluZyB0aGUgY2hvc2VuIHBlcnNpc3RlbmNlIHRvIHRoYXRcbiAgICAvLyBwZXJzaXN0ZW5jZSBpZiB0aGUgdXNlciBleGlzdHMuXG4gICAgbGV0IHVzZXJUb01pZ3JhdGU6IFVzZXJJbnRlcm5hbCB8IG51bGwgPSBudWxsO1xuICAgIC8vIE5vdGUsIGhlcmUgd2UgY2hlY2sgZm9yIGEgdXNlciBpbiBfYWxsXyBwZXJzaXN0ZW5jZXMsIG5vdCBqdXN0IHRoZVxuICAgIC8vIG9uZXMgZGVlbWVkIGF2YWlsYWJsZS4gSWYgd2UgY2FuIG1pZ3JhdGUgYSB1c2VyIG91dCBvZiBhIGJyb2tlblxuICAgIC8vIHBlcnNpc3RlbmNlLCB3ZSB3aWxsIChidXQgb25seSBpZiB0aGF0IHBlcnNpc3RlbmNlIHN1cHBvcnRzIG1pZ3JhdGlvbikuXG4gICAgZm9yIChjb25zdCBwZXJzaXN0ZW5jZSBvZiBwZXJzaXN0ZW5jZUhpZXJhcmNoeSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHBlcnNpc3RlbmNlLl9nZXQ8UGVyc2lzdGVkQmxvYj4oa2V5KTtcbiAgICAgICAgaWYgKGJsb2IpIHtcbiAgICAgICAgICBjb25zdCB1c2VyID0gVXNlckltcGwuX2Zyb21KU09OKGF1dGgsIGJsb2IpOyAvLyB0aHJvd3MgZm9yIHVucGFyc2FibGUgYmxvYiAod3JvbmcgZm9ybWF0KVxuICAgICAgICAgIGlmIChwZXJzaXN0ZW5jZSAhPT0gc2VsZWN0ZWRQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgdXNlclRvTWlncmF0ZSA9IHVzZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGVjdGVkUGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cblxuICAgIC8vIElmIHdlIGZpbmQgdGhlIHVzZXIgaW4gYSBwZXJzaXN0ZW5jZSB0aGF0IGRvZXMgc3VwcG9ydCBtaWdyYXRpb24sIHVzZVxuICAgIC8vIHRoYXQgbWlncmF0aW9uIHBhdGggKG9mIG9ubHkgcGVyc2lzdGVuY2VzIHRoYXQgc3VwcG9ydCBtaWdyYXRpb24pXG4gICAgY29uc3QgbWlncmF0aW9uSGllcmFyY2h5ID0gYXZhaWxhYmxlUGVyc2lzdGVuY2VzLmZpbHRlcihcbiAgICAgIHAgPT4gcC5fc2hvdWxkQWxsb3dNaWdyYXRpb25cbiAgICApO1xuXG4gICAgLy8gSWYgdGhlIHBlcnNpc3RlbmNlIGRvZXMgX25vdF8gYWxsb3cgbWlncmF0aW9uLCBqdXN0IGZpbmlzaCBvZmYgaGVyZVxuICAgIGlmIChcbiAgICAgICFzZWxlY3RlZFBlcnNpc3RlbmNlLl9zaG91bGRBbGxvd01pZ3JhdGlvbiB8fFxuICAgICAgIW1pZ3JhdGlvbkhpZXJhcmNoeS5sZW5ndGhcbiAgICApIHtcbiAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VVc2VyTWFuYWdlcihzZWxlY3RlZFBlcnNpc3RlbmNlLCBhdXRoLCB1c2VyS2V5KTtcbiAgICB9XG5cbiAgICBzZWxlY3RlZFBlcnNpc3RlbmNlID0gbWlncmF0aW9uSGllcmFyY2h5WzBdO1xuICAgIGlmICh1c2VyVG9NaWdyYXRlKSB7XG4gICAgICAvLyBUaGlzIG5vcm1hbGx5IHNob3VsZG4ndCB0aHJvdyBzaW5jZSBjaG9zZW5QZXJzaXN0ZW5jZS5pc0F2YWlsYWJsZSgpIGlzIHRydWUsIGJ1dCBpZiBpdCBkb2VzXG4gICAgICAvLyB3ZSdsbCBqdXN0IGxldCBpdCBidWJibGUgdG8gc3VyZmFjZSB0aGUgZXJyb3IuXG4gICAgICBhd2FpdCBzZWxlY3RlZFBlcnNpc3RlbmNlLl9zZXQoa2V5LCB1c2VyVG9NaWdyYXRlLnRvSlNPTigpKTtcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0IHRvIGNsZWFyIHRoZSBrZXkgaW4gb3RoZXIgcGVyc2lzdGVuY2VzIGJ1dCBpZ25vcmUgZXJyb3JzLiBUaGlzIGhlbHBzIHByZXZlbnQgaXNzdWVzXG4gICAgLy8gc3VjaCBhcyB1c2VycyBnZXR0aW5nIHN0dWNrIHdpdGggYSBwcmV2aW91cyBhY2NvdW50IGFmdGVyIHNpZ25pbmcgb3V0IGFuZCByZWZyZXNoaW5nIHRoZSB0YWIuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBwZXJzaXN0ZW5jZUhpZXJhcmNoeS5tYXAoYXN5bmMgcGVyc2lzdGVuY2UgPT4ge1xuICAgICAgICBpZiAocGVyc2lzdGVuY2UgIT09IHNlbGVjdGVkUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgcGVyc2lzdGVuY2UuX3JlbW92ZShrZXkpO1xuICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VVc2VyTWFuYWdlcihzZWxlY3RlZFBlcnNpc3RlbmNlLCBhdXRoLCB1c2VyS2V5KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgaXNJRSwgZ2V0VUEgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmludGVyZmFjZSBOYXZpZ2F0b3JTdGFuZGFsb25lIGV4dGVuZHMgTmF2aWdhdG9yIHtcbiAgc3RhbmRhbG9uZT86IHVua25vd247XG59XG5cbmludGVyZmFjZSBEb2N1bWVudCB7XG4gIGRvY3VtZW50TW9kZT86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBFbnVtcyBmb3IgQnJvd3NlciBuYW1lLlxuICovXG5leHBvcnQgY29uc3QgZW51bSBCcm93c2VyTmFtZSB7XG4gIEFORFJPSUQgPSAnQW5kcm9pZCcsXG4gIEJMQUNLQkVSUlkgPSAnQmxhY2tiZXJyeScsXG4gIEVER0UgPSAnRWRnZScsXG4gIEZJUkVGT1ggPSAnRmlyZWZveCcsXG4gIElFID0gJ0lFJyxcbiAgSUVNT0JJTEUgPSAnSUVNb2JpbGUnLFxuICBPUEVSQSA9ICdPcGVyYScsXG4gIE9USEVSID0gJ090aGVyJyxcbiAgQ0hST01FID0gJ0Nocm9tZScsXG4gIFNBRkFSSSA9ICdTYWZhcmknLFxuICBTSUxLID0gJ1NpbGsnLFxuICBXRUJPUyA9ICdXZWJvcydcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGJyb3dzZXIgZm9yIHRoZSBwdXJwb3NlcyBvZiByZXBvcnRpbmcgdXNhZ2UgdG8gdGhlIEFQSVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldEJyb3dzZXJOYW1lKHVzZXJBZ2VudDogc3RyaW5nKTogQnJvd3Nlck5hbWUgfCBzdHJpbmcge1xuICBjb25zdCB1YSA9IHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICBpZiAodWEuaW5jbHVkZXMoJ29wZXJhLycpIHx8IHVhLmluY2x1ZGVzKCdvcHIvJykgfHwgdWEuaW5jbHVkZXMoJ29waW9zLycpKSB7XG4gICAgcmV0dXJuIEJyb3dzZXJOYW1lLk9QRVJBO1xuICB9IGVsc2UgaWYgKF9pc0lFTW9iaWxlKHVhKSkge1xuICAgIC8vIFdpbmRvd3MgcGhvbmUgSUVNb2JpbGUgYnJvd3Nlci5cbiAgICByZXR1cm4gQnJvd3Nlck5hbWUuSUVNT0JJTEU7XG4gIH0gZWxzZSBpZiAodWEuaW5jbHVkZXMoJ21zaWUnKSB8fCB1YS5pbmNsdWRlcygndHJpZGVudC8nKSkge1xuICAgIHJldHVybiBCcm93c2VyTmFtZS5JRTtcbiAgfSBlbHNlIGlmICh1YS5pbmNsdWRlcygnZWRnZS8nKSkge1xuICAgIHJldHVybiBCcm93c2VyTmFtZS5FREdFO1xuICB9IGVsc2UgaWYgKF9pc0ZpcmVmb3godWEpKSB7XG4gICAgcmV0dXJuIEJyb3dzZXJOYW1lLkZJUkVGT1g7XG4gIH0gZWxzZSBpZiAodWEuaW5jbHVkZXMoJ3NpbGsvJykpIHtcbiAgICByZXR1cm4gQnJvd3Nlck5hbWUuU0lMSztcbiAgfSBlbHNlIGlmIChfaXNCbGFja0JlcnJ5KHVhKSkge1xuICAgIC8vIEJsYWNrYmVycnkgYnJvd3Nlci5cbiAgICByZXR1cm4gQnJvd3Nlck5hbWUuQkxBQ0tCRVJSWTtcbiAgfSBlbHNlIGlmIChfaXNXZWJPUyh1YSkpIHtcbiAgICAvLyBXZWJPUyBkZWZhdWx0IGJyb3dzZXIuXG4gICAgcmV0dXJuIEJyb3dzZXJOYW1lLldFQk9TO1xuICB9IGVsc2UgaWYgKF9pc1NhZmFyaSh1YSkpIHtcbiAgICByZXR1cm4gQnJvd3Nlck5hbWUuU0FGQVJJO1xuICB9IGVsc2UgaWYgKFxuICAgICh1YS5pbmNsdWRlcygnY2hyb21lLycpIHx8IF9pc0Nocm9tZUlPUyh1YSkpICYmXG4gICAgIXVhLmluY2x1ZGVzKCdlZGdlLycpXG4gICkge1xuICAgIHJldHVybiBCcm93c2VyTmFtZS5DSFJPTUU7XG4gIH0gZWxzZSBpZiAoX2lzQW5kcm9pZCh1YSkpIHtcbiAgICAvLyBBbmRyb2lkIHN0b2NrIGJyb3dzZXIuXG4gICAgcmV0dXJuIEJyb3dzZXJOYW1lLkFORFJPSUQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gTW9zdCBtb2Rlcm4gYnJvd3NlcnMgaGF2ZSBuYW1lL3ZlcnNpb24gYXQgZW5kIG9mIHVzZXIgYWdlbnQgc3RyaW5nLlxuICAgIGNvbnN0IHJlID0gLyhbYS16QS1aXFxkXFwuXSspXFwvW2EtekEtWlxcZFxcLl0qJC87XG4gICAgY29uc3QgbWF0Y2hlcyA9IHVzZXJBZ2VudC5tYXRjaChyZSk7XG4gICAgaWYgKG1hdGNoZXM/Lmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBCcm93c2VyTmFtZS5PVEhFUjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pc0ZpcmVmb3godWEgPSBnZXRVQSgpKTogYm9vbGVhbiB7XG4gIHJldHVybiAvZmlyZWZveFxcLy9pLnRlc3QodWEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2lzU2FmYXJpKHVzZXJBZ2VudCA9IGdldFVBKCkpOiBib29sZWFuIHtcbiAgY29uc3QgdWEgPSB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChcbiAgICB1YS5pbmNsdWRlcygnc2FmYXJpLycpICYmXG4gICAgIXVhLmluY2x1ZGVzKCdjaHJvbWUvJykgJiZcbiAgICAhdWEuaW5jbHVkZXMoJ2NyaW9zLycpICYmXG4gICAgIXVhLmluY2x1ZGVzKCdhbmRyb2lkJylcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pc0Nocm9tZUlPUyh1YSA9IGdldFVBKCkpOiBib29sZWFuIHtcbiAgcmV0dXJuIC9jcmlvc1xcLy9pLnRlc3QodWEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2lzSUVNb2JpbGUodWEgPSBnZXRVQSgpKTogYm9vbGVhbiB7XG4gIHJldHVybiAvaWVtb2JpbGUvaS50ZXN0KHVhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pc0FuZHJvaWQodWEgPSBnZXRVQSgpKTogYm9vbGVhbiB7XG4gIHJldHVybiAvYW5kcm9pZC9pLnRlc3QodWEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2lzQmxhY2tCZXJyeSh1YSA9IGdldFVBKCkpOiBib29sZWFuIHtcbiAgcmV0dXJuIC9ibGFja2JlcnJ5L2kudGVzdCh1YSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNXZWJPUyh1YSA9IGdldFVBKCkpOiBib29sZWFuIHtcbiAgcmV0dXJuIC93ZWJvcy9pLnRlc3QodWEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2lzSU9TKHVhID0gZ2V0VUEoKSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIC9pcGhvbmV8aXBhZHxpcG9kL2kudGVzdCh1YSkgfHxcbiAgICAoL21hY2ludG9zaC9pLnRlc3QodWEpICYmIC9tb2JpbGUvaS50ZXN0KHVhKSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pc0lPUzdPcjgodWEgPSBnZXRVQSgpKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgLyhpUGFkfGlQaG9uZXxpUG9kKS4qT1MgN19cXGQvaS50ZXN0KHVhKSB8fFxuICAgIC8oaVBhZHxpUGhvbmV8aVBvZCkuKk9TIDhfXFxkL2kudGVzdCh1YSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pc0lPU1N0YW5kYWxvbmUodWEgPSBnZXRVQSgpKTogYm9vbGVhbiB7XG4gIHJldHVybiBfaXNJT1ModWEpICYmICEhKHdpbmRvdy5uYXZpZ2F0b3IgYXMgTmF2aWdhdG9yU3RhbmRhbG9uZSk/LnN0YW5kYWxvbmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNJRTEwKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNJRSgpICYmIChkb2N1bWVudCBhcyBEb2N1bWVudCkuZG9jdW1lbnRNb2RlID09PSAxMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9pc01vYmlsZUJyb3dzZXIodWE6IHN0cmluZyA9IGdldFVBKCkpOiBib29sZWFuIHtcbiAgLy8gVE9ETzogaW1wbGVtZW50IGdldEJyb3dzZXJOYW1lIGVxdWl2YWxlbnQgZm9yIE9TLlxuICByZXR1cm4gKFxuICAgIF9pc0lPUyh1YSkgfHxcbiAgICBfaXNBbmRyb2lkKHVhKSB8fFxuICAgIF9pc1dlYk9TKHVhKSB8fFxuICAgIF9pc0JsYWNrQmVycnkodWEpIHx8XG4gICAgL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVhKSB8fFxuICAgIF9pc0lFTW9iaWxlKHVhKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2lzSWZyYW1lKCk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIGN1cnJlbnQgd2luZG93IGlzIG5vdCB0aGUgdG9wIHdpbmRvdy5cbiAgICAvLyBJZiBzbywgcmV0dXJuIHRydWUuXG4gICAgcmV0dXJuICEhKHdpbmRvdyAmJiB3aW5kb3cgIT09IHdpbmRvdy50b3ApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBTREtfVkVSU0lPTiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgX2dldEJyb3dzZXJOYW1lIH0gZnJvbSAnLi9icm93c2VyJztcbmltcG9ydCB7IGdldFVBIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5leHBvcnQgY29uc3QgZW51bSBDbGllbnRJbXBsZW1lbnRhdGlvbiB7XG4gIENPUkUgPSAnSnNDb3JlJ1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgZW51bSBDbGllbnRQbGF0Zm9ybSB7XG4gIEJST1dTRVIgPSAnQnJvd3NlcicsXG4gIE5PREUgPSAnTm9kZScsXG4gIFJFQUNUX05BVElWRSA9ICdSZWFjdE5hdGl2ZScsXG4gIENPUkRPVkEgPSAnQ29yZG92YScsXG4gIFdPUktFUiA9ICdXb3JrZXInXG59XG5cbi8qXG4gKiBEZXRlcm1pbmUgdGhlIFNESyB2ZXJzaW9uIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldENsaWVudFZlcnNpb24oXG4gIGNsaWVudFBsYXRmb3JtOiBDbGllbnRQbGF0Zm9ybSxcbiAgZnJhbWV3b3JrczogcmVhZG9ubHkgc3RyaW5nW10gPSBbXVxuKTogc3RyaW5nIHtcbiAgbGV0IHJlcG9ydGVkUGxhdGZvcm06IHN0cmluZztcbiAgc3dpdGNoIChjbGllbnRQbGF0Zm9ybSkge1xuICAgIGNhc2UgQ2xpZW50UGxhdGZvcm0uQlJPV1NFUjpcbiAgICAgIC8vIEluIGEgYnJvd3NlciBlbnZpcm9ubWVudCwgcmVwb3J0IHRoZSBicm93c2VyIG5hbWUuXG4gICAgICByZXBvcnRlZFBsYXRmb3JtID0gX2dldEJyb3dzZXJOYW1lKGdldFVBKCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDbGllbnRQbGF0Zm9ybS5XT1JLRVI6XG4gICAgICAvLyBUZWNobmljYWxseSBhIHdvcmtlciBydW5zIGZyb20gYSBicm93c2VyIGJ1dCB3ZSBuZWVkIHRvIGRpZmZlcmVudGlhdGUgYVxuICAgICAgLy8gd29ya2VyIGZyb20gYSBicm93c2VyLlxuICAgICAgLy8gRm9yIGV4YW1wbGU6IENocm9tZS1Xb3JrZXIvSnNDb3JlLzQuOS4xL0ZpcmViYXNlQ29yZS13ZWIuXG4gICAgICByZXBvcnRlZFBsYXRmb3JtID0gYCR7X2dldEJyb3dzZXJOYW1lKGdldFVBKCkpfS0ke2NsaWVudFBsYXRmb3JtfWA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVwb3J0ZWRQbGF0Zm9ybSA9IGNsaWVudFBsYXRmb3JtO1xuICB9XG4gIGNvbnN0IHJlcG9ydGVkRnJhbWV3b3JrcyA9IGZyYW1ld29ya3MubGVuZ3RoXG4gICAgPyBmcmFtZXdvcmtzLmpvaW4oJywnKVxuICAgIDogJ0ZpcmViYXNlQ29yZS13ZWInOyAvKiBkZWZhdWx0IHZhbHVlIGlmIG5vIG90aGVyIGZyYW1ld29yayBpcyB1c2VkICovXG4gIHJldHVybiBgJHtyZXBvcnRlZFBsYXRmb3JtfS8ke0NsaWVudEltcGxlbWVudGF0aW9uLkNPUkV9LyR7U0RLX1ZFUlNJT059LyR7cmVwb3J0ZWRGcmFtZXdvcmtzfWA7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBFbmRwb2ludCxcbiAgSHR0cE1ldGhvZCxcbiAgUmVjYXB0Y2hhQ2xpZW50VHlwZSxcbiAgUmVjYXB0Y2hhVmVyc2lvbixcbiAgX3BlcmZvcm1BcGlSZXF1ZXN0LFxuICBfYWRkVGlkSWZOZWNlc3Nhcnlcbn0gZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmludGVyZmFjZSBHZXRSZWNhcHRjaGFQYXJhbVJlc3BvbnNlIHtcbiAgcmVjYXB0Y2hhU2l0ZUtleT86IHN0cmluZztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJlY2FwdGNoYVBhcmFtcyhhdXRoOiBBdXRoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIChcbiAgICAoXG4gICAgICBhd2FpdCBfcGVyZm9ybUFwaVJlcXVlc3Q8dm9pZCwgR2V0UmVjYXB0Y2hhUGFyYW1SZXNwb25zZT4oXG4gICAgICAgIGF1dGgsXG4gICAgICAgIEh0dHBNZXRob2QuR0VULFxuICAgICAgICBFbmRwb2ludC5HRVRfUkVDQVBUQ0hBX1BBUkFNXG4gICAgICApXG4gICAgKS5yZWNhcHRjaGFTaXRlS2V5IHx8ICcnXG4gICk7XG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSBmb3IgcmVDQVBUQ0hBIGVudGVycHJpc2UgaW50ZWdyYXRpb24uXG5pbnRlcmZhY2UgR2V0UmVjYXB0Y2hhQ29uZmlnUmVxdWVzdCB7XG4gIHRlbmFudElkPzogc3RyaW5nO1xuICBjbGllbnRUeXBlPzogUmVjYXB0Y2hhQ2xpZW50VHlwZTtcbiAgdmVyc2lvbj86IFJlY2FwdGNoYVZlcnNpb247XG59XG5cbmludGVyZmFjZSBSZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlIHtcbiAgcHJvdmlkZXI6IHN0cmluZztcbiAgZW5mb3JjZW1lbnRTdGF0ZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldFJlY2FwdGNoYUNvbmZpZ1Jlc3BvbnNlIHtcbiAgcmVjYXB0Y2hhS2V5OiBzdHJpbmc7XG4gIHJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGU6IFJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGVbXTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJlY2FwdGNoYUNvbmZpZyhcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogR2V0UmVjYXB0Y2hhQ29uZmlnUmVxdWVzdFxuKTogUHJvbWlzZTxHZXRSZWNhcHRjaGFDb25maWdSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PFxuICAgIEdldFJlY2FwdGNoYUNvbmZpZ1JlcXVlc3QsXG4gICAgR2V0UmVjYXB0Y2hhQ29uZmlnUmVzcG9uc2VcbiAgPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuR0VULFxuICAgIEVuZHBvaW50LkdFVF9SRUNBUFRDSEFfQ09ORklHLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUmVjYXB0Y2hhUGFyYW1ldGVycyB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBHZXRSZWNhcHRjaGFDb25maWdSZXNwb25zZSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9yZWNhcHRjaGEnO1xuXG4vLyByZUNBUFRDSEEgdjIgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFJlY2FwdGNoYSB7XG4gIHJlbmRlcjogKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIHBhcmFtZXRlcnM6IFJlY2FwdGNoYVBhcmFtZXRlcnMpID0+IG51bWJlcjtcbiAgZ2V0UmVzcG9uc2U6IChpZDogbnVtYmVyKSA9PiBzdHJpbmc7XG4gIGV4ZWN1dGU6IChpZDogbnVtYmVyKSA9PiB1bmtub3duO1xuICByZXNldDogKGlkOiBudW1iZXIpID0+IHVua25vd247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1YyKFxuICBncmVjYXB0Y2hhOiBSZWNhcHRjaGEgfCBHcmVDQVBUQ0hBIHwgdW5kZWZpbmVkXG4pOiBncmVjYXB0Y2hhIGlzIFJlY2FwdGNoYSB7XG4gIHJldHVybiAoXG4gICAgZ3JlY2FwdGNoYSAhPT0gdW5kZWZpbmVkICYmXG4gICAgKGdyZWNhcHRjaGEgYXMgUmVjYXB0Y2hhKS5nZXRSZXNwb25zZSAhPT0gdW5kZWZpbmVkXG4gICk7XG59XG5cbi8vIHJlQ0FQVENIQSBFbnRlcnByaXNlICYgdjMgc2hhcmVkIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBHcmVDQVBUQ0hBVG9wTGV2ZWwgZXh0ZW5kcyBHcmVDQVBUQ0hBIHtcbiAgZW50ZXJwcmlzZTogR3JlQ0FQVENIQTtcbn1cblxuLy8gcmVDQVBUQ0hBIEVudGVycHJpc2UgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIEdyZUNBUFRDSEEge1xuICByZWFkeTogKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSA9PiB2b2lkO1xuICBleGVjdXRlOiAoc2l0ZUtleTogc3RyaW5nLCBvcHRpb25zOiB7IGFjdGlvbjogc3RyaW5nIH0pID0+IFByb21pc2U8c3RyaW5nPjtcbiAgcmVuZGVyOiAoXG4gICAgY29udGFpbmVyOiBzdHJpbmcgfCBIVE1MRWxlbWVudCxcbiAgICBwYXJhbWV0ZXJzOiBHcmVDQVBUQ0hBUmVuZGVyT3B0aW9uXG4gICkgPT4gc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyZUNBUFRDSEFSZW5kZXJPcHRpb24ge1xuICBzaXRla2V5OiBzdHJpbmc7XG4gIHNpemU6ICdpbnZpc2libGUnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbnRlcnByaXNlKFxuICBncmVjYXB0Y2hhOiBSZWNhcHRjaGEgfCBHcmVDQVBUQ0hBIHwgdW5kZWZpbmVkXG4pOiBncmVjYXB0Y2hhIGlzIEdyZUNBUFRDSEFUb3BMZXZlbCB7XG4gIHJldHVybiAoXG4gICAgZ3JlY2FwdGNoYSAhPT0gdW5kZWZpbmVkICYmXG4gICAgKGdyZWNhcHRjaGEgYXMgR3JlQ0FQVENIQVRvcExldmVsKS5lbnRlcnByaXNlICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cblxuLy8gVE9ETyhjaHVhbnIpOiBSZXBsYWNlIHRoaXMgd2l0aCB0aGUgQXV0aFdpbmRvdyBhZnRlciByZXNvbHZpbmcgdGhlIGRlcGVuZGVuY3kgaXNzdWUgaW4gTm9kZS5qcyBlbnYuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIGdyZWNhcHRjaGE/OiBSZWNhcHRjaGEgfCBHcmVDQVBUQ0hBVG9wTGV2ZWw7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlY2FwdGNoYUNvbmZpZyB7XG4gIC8qKlxuICAgKiBUaGUgcmVDQVBUQ0hBIHNpdGUga2V5LlxuICAgKi9cbiAgc2l0ZUtleTogc3RyaW5nID0gJyc7XG5cbiAgLyoqXG4gICAqIFRoZSByZUNBUFRDSEEgZW5hYmxlbWVudCBzdGF0dXMgb2YgdGhlIHtAbGluayBFbWFpbEF1dGhQcm92aWRlcn0gZm9yIHRoZSBjdXJyZW50IHRlbmFudC5cbiAgICovXG4gIGVtYWlsUGFzc3dvcmRFbmFibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocmVzcG9uc2U6IEdldFJlY2FwdGNoYUNvbmZpZ1Jlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnJlY2FwdGNoYUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2FwdGNoYUtleSB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgLy8gRXhhbXBsZSByZXNwb25zZS5yZWNhcHRjaGFLZXk6IFwicHJvamVjdHMvcHJvajEyMy9rZXlzL3NpdGVrZXkxMjNcIlxuICAgIHRoaXMuc2l0ZUtleSA9IHJlc3BvbnNlLnJlY2FwdGNoYUtleS5zcGxpdCgnLycpWzNdO1xuICAgIHRoaXMuZW1haWxQYXNzd29yZEVuYWJsZWQgPSByZXNwb25zZS5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlLnNvbWUoXG4gICAgICBlbmZvcmNlbWVudFN0YXRlID0+XG4gICAgICAgIGVuZm9yY2VtZW50U3RhdGUucHJvdmlkZXIgPT09ICdFTUFJTF9QQVNTV09SRF9QUk9WSURFUicgJiZcbiAgICAgICAgZW5mb3JjZW1lbnRTdGF0ZS5lbmZvcmNlbWVudFN0YXRlICE9PSAnT0ZGJ1xuICAgICk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9jb3JlL2Vycm9ycyc7XG5pbXBvcnQgeyBfY3JlYXRlRXJyb3IgfSBmcm9tICcuLi9jb3JlL3V0aWwvYXNzZXJ0JztcblxuZnVuY3Rpb24gZ2V0U2NyaXB0UGFyZW50RWxlbWVudCgpOiBIVE1MRG9jdW1lbnQgfCBIVE1MSGVhZEVsZW1lbnQge1xuICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKT8uWzBdID8/IGRvY3VtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2xvYWRKUyh1cmw6IHN0cmluZyk6IFByb21pc2U8RXZlbnQ+IHtcbiAgLy8gVE9ETzogY29uc2lkZXIgYWRkaW5nIHRpbWVvdXQgc3VwcG9ydCAmIGNhbmNlbGxhdGlvblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdzcmMnLCB1cmwpO1xuICAgIGVsLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgZWwub25lcnJvciA9IGUgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBfY3JlYXRlRXJyb3IoQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgICBlcnJvci5jdXN0b21EYXRhID0gZSBhcyB1bmtub3duIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9O1xuICAgIGVsLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBlbC5jaGFyc2V0ID0gJ1VURi04JztcbiAgICBnZXRTY3JpcHRQYXJlbnRFbGVtZW50KCkuYXBwZW5kQ2hpbGQoZWwpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZW5lcmF0ZUNhbGxiYWNrTmFtZShwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgX18ke3ByZWZpeH0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApfWA7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBpc0VudGVycHJpc2UsIFJlY2FwdGNoYUNvbmZpZyB9IGZyb20gJy4vcmVjYXB0Y2hhJztcbmltcG9ydCB7IGdldFJlY2FwdGNoYUNvbmZpZyB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9yZWNhcHRjaGEnO1xuaW1wb3J0IHtcbiAgUmVjYXB0Y2hhQ2xpZW50VHlwZSxcbiAgUmVjYXB0Y2hhVmVyc2lvbixcbiAgUmVjYXB0Y2hhQWN0aW9uTmFtZVxufSBmcm9tICcuLi8uLi9hcGknO1xuXG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgX2Nhc3RBdXRoIH0gZnJvbSAnLi4vLi4vY29yZS9hdXRoL2F1dGhfaW1wbCc7XG5pbXBvcnQgKiBhcyBqc0hlbHBlcnMgZnJvbSAnLi4vbG9hZF9qcyc7XG5cbmNvbnN0IFJFQ0FQVENIQV9FTlRFUlBSSVNFX1VSTCA9XG4gICdodHRwczovL3d3dy5nb29nbGUuY29tL3JlY2FwdGNoYS9lbnRlcnByaXNlLmpzP3JlbmRlcj0nO1xuXG5leHBvcnQgY29uc3QgUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVkVSSUZJRVJfVFlQRSA9ICdyZWNhcHRjaGEtZW50ZXJwcmlzZSc7XG5leHBvcnQgY29uc3QgRkFLRV9UT0tFTiA9ICdOT19SRUNBUFRDSEEnO1xuXG5leHBvcnQgY2xhc3MgUmVjYXB0Y2hhRW50ZXJwcmlzZVZlcmlmaWVyIHtcbiAgLyoqXG4gICAqIElkZW50aWZpZXMgdGhlIHR5cGUgb2YgYXBwbGljYXRpb24gdmVyaWZpZXIgKGUuZy4gXCJyZWNhcHRjaGEtZW50ZXJwcmlzZVwiKS5cbiAgICovXG4gIHJlYWRvbmx5IHR5cGUgPSBSRUNBUFRDSEFfRU5URVJQUklTRV9WRVJJRklFUl9UWVBFO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgYXV0aDogQXV0aEludGVybmFsO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gYXV0aEV4dGVybiAtIFRoZSBjb3JyZXNwb25kaW5nIEZpcmViYXNlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKGF1dGhFeHRlcm46IEF1dGgpIHtcbiAgICB0aGlzLmF1dGggPSBfY2FzdEF1dGgoYXV0aEV4dGVybik7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgZm9yIGEgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIHZhbGlkaXR5IG9mIGEgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIHZlcmlmeShcbiAgICBhY3Rpb246IHN0cmluZyA9ICd2ZXJpZnknLFxuICAgIGZvcmNlUmVmcmVzaCA9IGZhbHNlXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmV0cmlldmVTaXRlS2V5KGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICBpZiAoIWZvcmNlUmVmcmVzaCkge1xuICAgICAgICBpZiAoYXV0aC50ZW5hbnRJZCA9PSBudWxsICYmIGF1dGguX2FnZW50UmVjYXB0Y2hhQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXV0aC5fYWdlbnRSZWNhcHRjaGFDb25maWcuc2l0ZUtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgYXV0aC50ZW5hbnRJZCAhPSBudWxsICYmXG4gICAgICAgICAgYXV0aC5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1thdXRoLnRlbmFudElkXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBhdXRoLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW2F1dGgudGVuYW50SWRdLnNpdGVLZXk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBnZXRSZWNhcHRjaGFDb25maWcoYXV0aCwge1xuICAgICAgICAgIGNsaWVudFR5cGU6IFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCLFxuICAgICAgICAgIHZlcnNpb246IFJlY2FwdGNoYVZlcnNpb24uRU5URVJQUklTRVxuICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5yZWNhcHRjaGFLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdyZWNhcHRjaGEgRW50ZXJwcmlzZSBzaXRlIGtleSB1bmRlZmluZWQnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSBuZXcgUmVjYXB0Y2hhQ29uZmlnKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgaWYgKGF1dGgudGVuYW50SWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF1dGguX2FnZW50UmVjYXB0Y2hhQ29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0gPSBjb25maWc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY29uZmlnLnNpdGVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXRyaWV2ZVJlY2FwdGNoYVRva2VuKFxuICAgICAgc2l0ZUtleTogc3RyaW5nLFxuICAgICAgcmVzb2x2ZTogKHZhbHVlOiBzdHJpbmcgfCBQcm9taXNlTGlrZTxzdHJpbmc+KSA9PiB2b2lkLFxuICAgICAgcmVqZWN0OiAocmVhc29uPzogdW5rbm93bikgPT4gdm9pZFxuICAgICk6IHZvaWQge1xuICAgICAgY29uc3QgZ3JlY2FwdGNoYSA9IHdpbmRvdy5ncmVjYXB0Y2hhO1xuICAgICAgaWYgKGlzRW50ZXJwcmlzZShncmVjYXB0Y2hhKSkge1xuICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2UucmVhZHkoKCkgPT4ge1xuICAgICAgICAgIGdyZWNhcHRjaGEuZW50ZXJwcmlzZVxuICAgICAgICAgICAgLmV4ZWN1dGUoc2l0ZUtleSwgeyBhY3Rpb24gfSlcbiAgICAgICAgICAgIC50aGVuKHRva2VuID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0b2tlbik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShGQUtFX1RPS0VOKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChFcnJvcignTm8gcmVDQVBUQ0hBIGVudGVycHJpc2Ugc2NyaXB0IGxvYWRlZC4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmV0cmlldmVTaXRlS2V5KHRoaXMuYXV0aClcbiAgICAgICAgLnRoZW4oc2l0ZUtleSA9PiB7XG4gICAgICAgICAgaWYgKCFmb3JjZVJlZnJlc2ggJiYgaXNFbnRlcnByaXNlKHdpbmRvdy5ncmVjYXB0Y2hhKSkge1xuICAgICAgICAgICAgcmV0cmlldmVSZWNhcHRjaGFUb2tlbihzaXRlS2V5LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcignUmVjYXB0Y2hhVmVyaWZpZXIgaXMgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpzSGVscGVyc1xuICAgICAgICAgICAgICAuX2xvYWRKUyhSRUNBUFRDSEFfRU5URVJQUklTRV9VUkwgKyBzaXRlS2V5KVxuICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0cmlldmVSZWNhcHRjaGFUb2tlbihzaXRlS2V5LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5qZWN0UmVjYXB0Y2hhRmllbGRzPFQ+KFxuICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gIHJlcXVlc3Q6IFQsXG4gIGFjdGlvbjogUmVjYXB0Y2hhQWN0aW9uTmFtZSxcbiAgY2FwdGNoYVJlc3AgPSBmYWxzZVxuKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IHZlcmlmaWVyID0gbmV3IFJlY2FwdGNoYUVudGVycHJpc2VWZXJpZmllcihhdXRoKTtcbiAgbGV0IGNhcHRjaGFSZXNwb25zZTtcbiAgdHJ5IHtcbiAgICBjYXB0Y2hhUmVzcG9uc2UgPSBhd2FpdCB2ZXJpZmllci52ZXJpZnkoYWN0aW9uKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0Y2hhUmVzcG9uc2UgPSBhd2FpdCB2ZXJpZmllci52ZXJpZnkoYWN0aW9uLCB0cnVlKTtcbiAgfVxuICBjb25zdCBuZXdSZXF1ZXN0ID0geyAuLi5yZXF1ZXN0IH07XG4gIGlmICghY2FwdGNoYVJlc3ApIHtcbiAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgY2FwdGNoYVJlc3BvbnNlIH0pO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwgeyAnY2FwdGNoYVJlc3AnOiBjYXB0Y2hhUmVzcG9uc2UgfSk7XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihuZXdSZXF1ZXN0LCB7ICdjbGllbnRUeXBlJzogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgfSk7XG4gIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwge1xuICAgICdyZWNhcHRjaGFWZXJzaW9uJzogUmVjYXB0Y2hhVmVyc2lvbi5FTlRFUlBSSVNFXG4gIH0pO1xuICByZXR1cm4gbmV3UmVxdWVzdDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgVW5zdWJzY3JpYmUsIFVzZXIgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmludGVyZmFjZSBNaWRkbGV3YXJlRW50cnkge1xuICAodXNlcjogVXNlciB8IG51bGwpOiBQcm9taXNlPHZvaWQ+O1xuICBvbkFib3J0PzogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhNaWRkbGV3YXJlUXVldWUge1xuICBwcml2YXRlIHJlYWRvbmx5IHF1ZXVlOiBNaWRkbGV3YXJlRW50cnlbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXV0aDogQXV0aEludGVybmFsKSB7fVxuXG4gIHB1c2hDYWxsYmFjayhcbiAgICBjYWxsYmFjazogKHVzZXI6IFVzZXIgfCBudWxsKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPixcbiAgICBvbkFib3J0PzogKCkgPT4gdm9pZFxuICApOiBVbnN1YnNjcmliZSB7XG4gICAgLy8gVGhlIGNhbGxiYWNrIGNvdWxkIGJlIHN5bmMgb3IgYXN5bmMuIFdyYXAgaXQgaW50byBhXG4gICAgLy8gZnVuY3Rpb24gdGhhdCBpcyBhbHdheXMgYXN5bmMuXG4gICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrOiBNaWRkbGV3YXJlRW50cnkgPSAoXG4gICAgICB1c2VyOiBVc2VyIHwgbnVsbFxuICAgICk6IFByb21pc2U8dm9pZD4gPT5cbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayh1c2VyKTtcbiAgICAgICAgICAvLyBFaXRoZXIgcmVzb2x2ZSB3aXRoIGV4aXN0aW5nIHByb21pc2Ugb3Igd3JhcCBhIG5vbi1wcm9taXNlXG4gICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGludG8gYSBwcm9taXNlLlxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFN5bmMgY2FsbGJhY2sgdGhyb3dzLlxuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgLy8gQXR0YWNoIHRoZSBvbkFib3J0IGlmIHByZXNlbnRcbiAgICB3cmFwcGVkQ2FsbGJhY2sub25BYm9ydCA9IG9uQWJvcnQ7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKHdyYXBwZWRDYWxsYmFjayk7XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gVW5zdWJzY3JpYmUuIFJlcGxhY2Ugd2l0aCBuby1vcC4gRG8gbm90IHJlbW92ZSBmcm9tIGFycmF5LCBvciBpdCB3aWxsIGRpc3R1cmJcbiAgICAgIC8vIGluZGV4aW5nIG9mIG90aGVyIGVsZW1lbnRzLlxuICAgICAgdGhpcy5xdWV1ZVtpbmRleF0gPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgcnVuTWlkZGxld2FyZShuZXh0VXNlcjogVXNlciB8IG51bGwpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5hdXRoLmN1cnJlbnRVc2VyID09PSBuZXh0VXNlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdoaWxlIHJ1bm5pbmcgdGhlIG1pZGRsZXdhcmUsIGJ1aWxkIGEgdGVtcG9yYXJ5IHN0YWNrIG9mIG9uQWJvcnRcbiAgICAvLyBjYWxsYmFja3MgdG8gY2FsbCBpZiBvbmUgbWlkZGxld2FyZSBjYWxsYmFjayByZWplY3RzLlxuXG4gICAgY29uc3Qgb25BYm9ydFN0YWNrOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKGNvbnN0IGJlZm9yZVN0YXRlQ2FsbGJhY2sgb2YgdGhpcy5xdWV1ZSkge1xuICAgICAgICBhd2FpdCBiZWZvcmVTdGF0ZUNhbGxiYWNrKG5leHRVc2VyKTtcblxuICAgICAgICAvLyBPbmx5IHB1c2ggdGhlIG9uQWJvcnQgaWYgdGhlIGNhbGxiYWNrIHN1Y2NlZWRzXG4gICAgICAgIGlmIChiZWZvcmVTdGF0ZUNhbGxiYWNrLm9uQWJvcnQpIHtcbiAgICAgICAgICBvbkFib3J0U3RhY2sucHVzaChiZWZvcmVTdGF0ZUNhbGxiYWNrLm9uQWJvcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUnVuIGFsbCBvbkFib3J0LCB3aXRoIHNlcGFyYXRlIHRyeS9jYXRjaCB0byBpZ25vcmUgYW55IGVycm9ycyBhbmRcbiAgICAgIC8vIGNvbnRpbnVlXG4gICAgICBvbkFib3J0U3RhY2sucmV2ZXJzZSgpO1xuICAgICAgZm9yIChjb25zdCBvbkFib3J0IG9mIG9uQWJvcnRTdGFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9uQWJvcnQoKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIC8qIHN3YWxsb3cgZXJyb3IgKi9cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyB0aGlzLmF1dGguX2Vycm9yRmFjdG9yeS5jcmVhdGUoQXV0aEVycm9yQ29kZS5MT0dJTl9CTE9DS0VELCB7XG4gICAgICAgIG9yaWdpbmFsTWVzc2FnZTogKGUgYXMgRXJyb3IpPy5tZXNzYWdlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IF9GaXJlYmFzZVNlcnZpY2UsIEZpcmViYXNlQXBwIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgQXBwQ2hlY2tJbnRlcm5hbENvbXBvbmVudE5hbWUgfSBmcm9tICdAZmlyZWJhc2UvYXBwLWNoZWNrLWludGVyb3AtdHlwZXMnO1xuaW1wb3J0IHtcbiAgQXV0aCxcbiAgQXV0aEVycm9yTWFwLFxuICBBdXRoU2V0dGluZ3MsXG4gIEVtdWxhdG9yQ29uZmlnLFxuICBOZXh0T3JPYnNlcnZlcixcbiAgUGVyc2lzdGVuY2UsXG4gIFBvcHVwUmVkaXJlY3RSZXNvbHZlcixcbiAgVXNlcixcbiAgVXNlckNyZWRlbnRpYWwsXG4gIENvbXBsZXRlRm4sXG4gIEVycm9yRm4sXG4gIE5leHRGbixcbiAgVW5zdWJzY3JpYmVcbn0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVN1YnNjcmliZSxcbiAgRXJyb3JGYWN0b3J5LFxuICBGaXJlYmFzZUVycm9yLFxuICBnZXRNb2R1bGFySW5zdGFuY2UsXG4gIE9ic2VydmVyLFxuICBTdWJzY3JpYmVcbn0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwsIENvbmZpZ0ludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3BvcHVwX3JlZGlyZWN0JztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHtcbiAgQXV0aEVycm9yQ29kZSxcbiAgQXV0aEVycm9yUGFyYW1zLFxuICBFcnJvck1hcFJldHJpZXZlcixcbiAgX0RFRkFVTFRfQVVUSF9FUlJPUl9GQUNUT1JZXG59IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBQZXJzaXN0ZW5jZUludGVybmFsIH0gZnJvbSAnLi4vcGVyc2lzdGVuY2UnO1xuaW1wb3J0IHtcbiAgS2V5TmFtZSxcbiAgUGVyc2lzdGVuY2VVc2VyTWFuYWdlclxufSBmcm9tICcuLi9wZXJzaXN0ZW5jZS9wZXJzaXN0ZW5jZV91c2VyX21hbmFnZXInO1xuaW1wb3J0IHsgX3JlbG9hZFdpdGhvdXRTYXZpbmcgfSBmcm9tICcuLi91c2VyL3JlbG9hZCc7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgX2dldEluc3RhbmNlIH0gZnJvbSAnLi4vdXRpbC9pbnN0YW50aWF0b3InO1xuaW1wb3J0IHsgX2dldFVzZXJMYW5ndWFnZSB9IGZyb20gJy4uL3V0aWwvbmF2aWdhdG9yJztcbmltcG9ydCB7IF9nZXRDbGllbnRWZXJzaW9uIH0gZnJvbSAnLi4vdXRpbC92ZXJzaW9uJztcbmltcG9ydCB7IEh0dHBIZWFkZXIsIFJlY2FwdGNoYUNsaWVudFR5cGUsIFJlY2FwdGNoYVZlcnNpb24gfSBmcm9tICcuLi8uLi9hcGknO1xuaW1wb3J0IHsgZ2V0UmVjYXB0Y2hhQ29uZmlnIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL3JlY2FwdGNoYSc7XG5pbXBvcnQgeyBSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIgfSBmcm9tICcuLi8uLi9wbGF0Zm9ybV9icm93c2VyL3JlY2FwdGNoYS9yZWNhcHRjaGFfZW50ZXJwcmlzZV92ZXJpZmllcic7XG5pbXBvcnQgeyBBdXRoTWlkZGxld2FyZVF1ZXVlIH0gZnJvbSAnLi9taWRkbGV3YXJlJztcbmltcG9ydCB7IFJlY2FwdGNoYUNvbmZpZyB9IGZyb20gJy4uLy4uL3BsYXRmb3JtX2Jyb3dzZXIvcmVjYXB0Y2hhL3JlY2FwdGNoYSc7XG5pbXBvcnQgeyBfbG9nV2FybiB9IGZyb20gJy4uL3V0aWwvbG9nJztcblxuaW50ZXJmYWNlIEFzeW5jQWN0aW9uIHtcbiAgKCk6IFByb21pc2U8dm9pZD47XG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIERlZmF1bHRDb25maWcge1xuICBUT0tFTl9BUElfSE9TVCA9ICdzZWN1cmV0b2tlbi5nb29nbGVhcGlzLmNvbScsXG4gIEFQSV9IT1NUID0gJ2lkZW50aXR5dG9vbGtpdC5nb29nbGVhcGlzLmNvbScsXG4gIEFQSV9TQ0hFTUUgPSAnaHR0cHMnXG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoSW1wbCBpbXBsZW1lbnRzIEF1dGhJbnRlcm5hbCwgX0ZpcmViYXNlU2VydmljZSB7XG4gIGN1cnJlbnRVc2VyOiBVc2VyIHwgbnVsbCA9IG51bGw7XG4gIGVtdWxhdG9yQ29uZmlnOiBFbXVsYXRvckNvbmZpZyB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG9wZXJhdGlvbnMgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgcHJpdmF0ZSBwZXJzaXN0ZW5jZU1hbmFnZXI/OiBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyO1xuICBwcml2YXRlIHJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyPzogUGVyc2lzdGVuY2VVc2VyTWFuYWdlcjtcbiAgcHJpdmF0ZSBhdXRoU3RhdGVTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uPFVzZXI+KHRoaXMpO1xuICBwcml2YXRlIGlkVG9rZW5TdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uPFVzZXI+KHRoaXMpO1xuICBwcml2YXRlIHJlYWRvbmx5IGJlZm9yZVN0YXRlUXVldWUgPSBuZXcgQXV0aE1pZGRsZXdhcmVRdWV1ZSh0aGlzKTtcbiAgcHJpdmF0ZSByZWRpcmVjdFVzZXI6IFVzZXJJbnRlcm5hbCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBBbnkgbmV0d29yayBjYWxscyB3aWxsIHNldCB0aGlzIHRvIHRydWUgYW5kIHByZXZlbnQgc3Vic2VxdWVudCBlbXVsYXRvclxuICAvLyBpbml0aWFsaXphdGlvblxuICBfY2FuSW5pdEVtdWxhdG9yID0gdHJ1ZTtcbiAgX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgX2RlbGV0ZWQgPSBmYWxzZTtcbiAgX2luaXRpYWxpemF0aW9uUHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xuICBfcG9wdXBSZWRpcmVjdFJlc29sdmVyOiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJJbnRlcm5hbCB8IG51bGwgPSBudWxsO1xuICBfZXJyb3JGYWN0b3J5OiBFcnJvckZhY3Rvcnk8QXV0aEVycm9yQ29kZSwgQXV0aEVycm9yUGFyYW1zPiA9XG4gICAgX0RFRkFVTFRfQVVUSF9FUlJPUl9GQUNUT1JZO1xuICBfYWdlbnRSZWNhcHRjaGFDb25maWc6IFJlY2FwdGNoYUNvbmZpZyB8IG51bGwgPSBudWxsO1xuICBfdGVuYW50UmVjYXB0Y2hhQ29uZmlnczogUmVjb3JkPHN0cmluZywgUmVjYXB0Y2hhQ29uZmlnPiA9IHt9O1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLy8gVHJhY2tzIHRoZSBsYXN0IG5vdGlmaWVkIFVJRCBmb3Igc3RhdGUgY2hhbmdlIGxpc3RlbmVycyB0byBwcmV2ZW50XG4gIC8vIHJlcGVhdGVkIGNhbGxzIHRvIHRoZSBjYWxsYmFja3MuIFVuZGVmaW5lZCBtZWFucyBpdCdzIG5ldmVyIGJlZW5cbiAgLy8gY2FsbGVkLCB3aGVyZWFzIG51bGwgbWVhbnMgaXQncyBiZWVuIGNhbGxlZCB3aXRoIGEgc2lnbmVkIG91dCB1c2VyXG4gIHByaXZhdGUgbGFzdE5vdGlmaWVkVWlkOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIGxhbmd1YWdlQ29kZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHRlbmFudElkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgc2V0dGluZ3M6IEF1dGhTZXR0aW5ncyA9IHsgYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nOiBmYWxzZSB9O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBhcHA6IEZpcmViYXNlQXBwLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyOiBQcm92aWRlcjwnaGVhcnRiZWF0Jz4sXG4gICAgcHJpdmF0ZSByZWFkb25seSBhcHBDaGVja1NlcnZpY2VQcm92aWRlcjogUHJvdmlkZXI8QXBwQ2hlY2tJbnRlcm5hbENvbXBvbmVudE5hbWU+LFxuICAgIHB1YmxpYyByZWFkb25seSBjb25maWc6IENvbmZpZ0ludGVybmFsXG4gICkge1xuICAgIHRoaXMubmFtZSA9IGFwcC5uYW1lO1xuICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNvbmZpZy5zZGtDbGllbnRWZXJzaW9uO1xuICB9XG5cbiAgX2luaXRpYWxpemVXaXRoUGVyc2lzdGVuY2UoXG4gICAgcGVyc2lzdGVuY2VIaWVyYXJjaHk6IFBlcnNpc3RlbmNlSW50ZXJuYWxbXSxcbiAgICBwb3B1cFJlZGlyZWN0UmVzb2x2ZXI/OiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xuICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyID0gX2dldEluc3RhbmNlKHBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XG4gICAgfVxuXG4gICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgYXBwIGRlbGV0aW9uIHRocm91Z2hvdXQgaW5pdGlhbGl6YXRpb24gKGFmdGVyIGVhY2hcbiAgICAvLyBwcm9taXNlIHJlc29sdXRpb24pXG4gICAgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlID0gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGVyc2lzdGVuY2VNYW5hZ2VyID0gYXdhaXQgUGVyc2lzdGVuY2VVc2VyTWFuYWdlci5jcmVhdGUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHBlcnNpc3RlbmNlSGllcmFyY2h5XG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc29sdmVyIGVhcmx5IGlmIG5lY2Vzc2FyeSAob25seSBhcHBsaWNhYmxlIHRvIHdlYjpcbiAgICAgIC8vIHRoaXMgd2lsbCBjYXVzZSB0aGUgaWZyYW1lIHRvIGxvYWQgaW1tZWRpYXRlbHkgaW4gY2VydGFpbiBjYXNlcylcbiAgICAgIGlmICh0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXI/Ll9zaG91bGRJbml0UHJvYWN0aXZlbHkpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBmYWlscywgZG9uJ3QgaGFsdCBhdXRoIGxvYWRpbmdcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIuX2luaXRpYWxpemUodGhpcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvKiBJZ25vcmUgdGhlIGVycm9yICovXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplQ3VycmVudFVzZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcbiAgICAgIHRoaXMubGFzdE5vdGlmaWVkVWlkID0gdGhpcy5jdXJyZW50VXNlcj8udWlkIHx8IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBwZXJzaXN0ZW5jZSBpcyBjaGFuZ2VkIGluIGFub3RoZXIgd2luZG93LCB0aGUgdXNlciBtYW5hZ2VyIHdpbGwgbGV0IHVzIGtub3dcbiAgICovXG4gIGFzeW5jIF9vblN0b3JhZ2VFdmVudCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UuZ2V0Q3VycmVudFVzZXIoKTtcblxuICAgIGlmICghdGhpcy5jdXJyZW50VXNlciAmJiAhdXNlcikge1xuICAgICAgLy8gTm8gY2hhbmdlLCBkbyBub3RoaW5nICh3YXMgc2lnbmVkIG91dCBhbmQgcmVtYWluZWQgc2lnbmVkIG91dCkuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNhbWUgdXNlciBpcyB0byBiZSBzeW5jaHJvbml6ZWQuXG4gICAgaWYgKHRoaXMuY3VycmVudFVzZXIgJiYgdXNlciAmJiB0aGlzLmN1cnJlbnRVc2VyLnVpZCA9PT0gdXNlci51aWQpIHtcbiAgICAgIC8vIERhdGEgdXBkYXRlLCBzaW1wbHkgY29weSBkYXRhIGNoYW5nZXMuXG4gICAgICB0aGlzLl9jdXJyZW50VXNlci5fYXNzaWduKHVzZXIpO1xuICAgICAgLy8gSWYgdG9rZW5zIGNoYW5nZWQgZnJvbSBwcmV2aW91cyB1c2VyIHRva2VucywgdGhpcyB3aWxsIHRyaWdnZXJcbiAgICAgIC8vIG5vdGlmeUF1dGhMaXN0ZW5lcnNfLlxuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50VXNlci5nZXRJZFRva2VuKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGN1cnJlbnQgQXV0aCBzdGF0ZS4gRWl0aGVyIGEgbmV3IGxvZ2luIG9yIGxvZ291dC5cbiAgICAvLyBTa2lwIGJsb2NraW5nIGNhbGxiYWNrcywgdGhleSBzaG91bGQgbm90IGFwcGx5IHRvIGEgY2hhbmdlIGluIGFub3RoZXIgdGFiLlxuICAgIGF3YWl0IHRoaXMuX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXIsIC8qIHNraXBCZWZvcmVTdGF0ZUNhbGxiYWNrcyAqLyB0cnVlKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZUN1cnJlbnRVc2VyKFxuICAgIHBvcHVwUmVkaXJlY3RSZXNvbHZlcj86IFBvcHVwUmVkaXJlY3RSZXNvbHZlclxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBGaXJzdCBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHBlbmRpbmcgcmVkaXJlY3QgZXZlbnQuXG4gICAgY29uc3QgcHJldmlvdXNseVN0b3JlZFVzZXIgPVxuICAgICAgKGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5nZXRDdXJyZW50VXNlcigpKSBhcyBVc2VySW50ZXJuYWwgfCBudWxsO1xuICAgIGxldCBmdXR1cmVDdXJyZW50VXNlciA9IHByZXZpb3VzbHlTdG9yZWRVc2VyO1xuICAgIGxldCBuZWVkc1RvY2hlY2tNaWRkbGV3YXJlID0gZmFsc2U7XG4gICAgaWYgKHBvcHVwUmVkaXJlY3RSZXNvbHZlciAmJiB0aGlzLmNvbmZpZy5hdXRoRG9tYWluKSB7XG4gICAgICBhd2FpdCB0aGlzLmdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKCk7XG4gICAgICBjb25zdCByZWRpcmVjdFVzZXJFdmVudElkID0gdGhpcy5yZWRpcmVjdFVzZXI/Ll9yZWRpcmVjdEV2ZW50SWQ7XG4gICAgICBjb25zdCBzdG9yZWRVc2VyRXZlbnRJZCA9IGZ1dHVyZUN1cnJlbnRVc2VyPy5fcmVkaXJlY3RFdmVudElkO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy50cnlSZWRpcmVjdFNpZ25Jbihwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpO1xuXG4gICAgICAvLyBJZiB0aGUgc3RvcmVkIHVzZXIgKGkuZS4gdGhlIG9sZCBcImN1cnJlbnRVc2VyXCIpIGhhcyBhIHJlZGlyZWN0SWQgdGhhdFxuICAgICAgLy8gbWF0Y2hlcyB0aGUgcmVkaXJlY3QgdXNlciwgdGhlbiB3ZSB3YW50IHRvIGluaXRpYWxseSBzaWduIGluIHdpdGggdGhlXG4gICAgICAvLyBuZXcgdXNlciBvYmplY3QgZnJvbSByZXN1bHQuXG4gICAgICAvLyBUT0RPKHNhbWdobyk6IE1vcmUgdGhvcm91Z2hseSB0ZXN0IGFsbCBvZiB0aGlzXG4gICAgICBpZiAoXG4gICAgICAgICghcmVkaXJlY3RVc2VyRXZlbnRJZCB8fCByZWRpcmVjdFVzZXJFdmVudElkID09PSBzdG9yZWRVc2VyRXZlbnRJZCkgJiZcbiAgICAgICAgcmVzdWx0Py51c2VyXG4gICAgICApIHtcbiAgICAgICAgZnV0dXJlQ3VycmVudFVzZXIgPSByZXN1bHQudXNlciBhcyBVc2VySW50ZXJuYWw7XG4gICAgICAgIG5lZWRzVG9jaGVja01pZGRsZXdhcmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIHVzZXIgaW4gcGVyc2lzdGVuY2UsIHRoZXJlIGlzIG5vIGN1cnJlbnQgdXNlci4gU2V0IHRvIG51bGwuXG4gICAgaWYgKCFmdXR1cmVDdXJyZW50VXNlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoIWZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQpIHtcbiAgICAgIC8vIFRoaXMgaXNuJ3QgYSByZWRpcmVjdCBsaW5rIG9wZXJhdGlvbiwgd2UgY2FuIHJlbG9hZCBhbmQgYmFpbC5cbiAgICAgIC8vIEZpcnN0IHRob3VnaCwgZW5zdXJlIHRoYXQgd2UgY2hlY2sgdGhlIG1pZGRsZXdhcmUgaXMgaGFwcHkuXG4gICAgICBpZiAobmVlZHNUb2NoZWNrTWlkZGxld2FyZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuYmVmb3JlU3RhdGVRdWV1ZS5ydW5NaWRkbGV3YXJlKGZ1dHVyZUN1cnJlbnRVc2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGZ1dHVyZUN1cnJlbnRVc2VyID0gcHJldmlvdXNseVN0b3JlZFVzZXI7XG4gICAgICAgICAgLy8gV2Uga25vdyB0aGlzIGlzIGF2YWlsYWJsZSBzaW5jZSB0aGUgYml0IGlzIG9ubHkgc2V0IHdoZW4gdGhlXG4gICAgICAgICAgLy8gcmVzb2x2ZXIgaXMgYXZhaWxhYmxlXG4gICAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyIS5fb3ZlcnJpZGVSZWRpcmVjdFJlc3VsdCh0aGlzLCAoKSA9PlxuICAgICAgICAgICAgUHJvbWlzZS5yZWplY3QoZSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmdXR1cmVDdXJyZW50VXNlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxvYWRBbmRTZXRDdXJyZW50VXNlck9yQ2xlYXIoZnV0dXJlQ3VycmVudFVzZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXNzZXJ0KHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciwgdGhpcywgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUik7XG4gICAgYXdhaXQgdGhpcy5nZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcigpO1xuXG4gICAgLy8gSWYgdGhlIHJlZGlyZWN0IHVzZXIncyBldmVudCBJRCBtYXRjaGVzIHRoZSBjdXJyZW50IHVzZXIncyBldmVudCBJRCxcbiAgICAvLyBETyBOT1QgcmVsb2FkIHRoZSBjdXJyZW50IHVzZXIsIG90aGVyd2lzZSB0aGV5J2xsIGJlIGNsZWFyZWQgZnJvbSBzdG9yYWdlLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciB0aGUgcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3QoKSBmbG93LlxuICAgIGlmIChcbiAgICAgIHRoaXMucmVkaXJlY3RVc2VyICYmXG4gICAgICB0aGlzLnJlZGlyZWN0VXNlci5fcmVkaXJlY3RFdmVudElkID09PSBmdXR1cmVDdXJyZW50VXNlci5fcmVkaXJlY3RFdmVudElkXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKGZ1dHVyZUN1cnJlbnRVc2VyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWxvYWRBbmRTZXRDdXJyZW50VXNlck9yQ2xlYXIoZnV0dXJlQ3VycmVudFVzZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB0cnlSZWRpcmVjdFNpZ25JbihcbiAgICByZWRpcmVjdFJlc29sdmVyOiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJcbiAgKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbCB8IG51bGw+IHtcbiAgICAvLyBUaGUgcmVkaXJlY3QgdXNlciBuZWVkcyB0byBiZSBjaGVja2VkIChhbmQgc2lnbmVkIGluIGlmIGF2YWlsYWJsZSlcbiAgICAvLyBkdXJpbmcgYXV0aCBpbml0aWFsaXphdGlvbi4gQWxsIG9mIHRoZSBub3JtYWwgc2lnbiBpbiBhbmQgbGluay9yZWF1dGhcbiAgICAvLyBmbG93cyBjYWxsIGJhY2sgaW50byBhdXRoIGFuZCBwdXNoIHRoaW5ncyBvbnRvIHRoZSBwcm9taXNlIHF1ZXVlLiBXZVxuICAgIC8vIG5lZWQgdG8gYXdhaXQgdGhlIHJlc3VsdCBvZiB0aGUgcmVkaXJlY3Qgc2lnbiBpbiAqaW5zaWRlIHRoZSBwcm9taXNlXG4gICAgLy8gcXVldWUqLiBUaGlzIHByZXNlbnRzIGEgcHJvYmxlbTogd2UgcnVuIGludG8gZGVhZGxvY2suIFNlZTpcbiAgICAvLyAgICDilIw+IFtJbml0aWFsaXphdGlvbl0g4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgLy8gICAg4pSMPiBbPG90aGVyIHF1ZXVlIHRhc2tzPl0g4pSCXG4gICAgLy8gICAg4pSU4pSAIFtnZXRSZWRpcmVjdFJlc3VsdF0gPOKUgOKUmFxuICAgIC8vICAgIHdoZXJlIFtdIGFyZSB0YXNrcyBvbiB0aGUgcXVldWUgYW5kIGFycm93cyBkZW5vdGUgYXdhaXRzXG4gICAgLy8gSW5pdGlhbGl6YXRpb24gd2lsbCBuZXZlciBjb21wbGV0ZSBiZWNhdXNlIGl0J3Mgd2FpdGluZyBvbiBzb21ldGhpbmdcbiAgICAvLyB0aGF0J3Mgd2FpdGluZyBmb3IgaW5pdGlhbGl6YXRpb24gdG8gY29tcGxldGUhXG4gICAgLy9cbiAgICAvLyBJbnN0ZWFkLCB0aGlzIG1ldGhvZCBjYWxscyBnZXRSZWRpcmVjdFJlc3VsdCgpIChzdG9yZWQgaW5cbiAgICAvLyBfY29tcGxldGVSZWRpcmVjdEZuKSB3aXRoIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IGluc3RydWN0cyBhbGwgb2ZcbiAgICAvLyB0aGUgdW5kZXJseWluZyBhdXRoIG9wZXJhdGlvbnMgdG8gc2tpcCBhbnl0aGluZyB0aGF0IG11dGF0ZXMgYXV0aCBzdGF0ZS5cblxuICAgIGxldCByZXN1bHQ6IFVzZXJDcmVkZW50aWFsIHwgbnVsbCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlIGtub3cgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyIGlzIHNldCBzaW5jZSByZWRpcmVjdFJlc29sdmVyXG4gICAgICAvLyBpcyBwYXNzZWQgaW4uIFRoZSBfY29tcGxldGVSZWRpcmVjdEZuIGV4cGVjdHMgdGhlIHVud3JhcHBlZCBleHRlcm4uXG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIhLl9jb21wbGV0ZVJlZGlyZWN0Rm4oXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHJlZGlyZWN0UmVzb2x2ZXIsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gU3dhbGxvdyBhbnkgZXJyb3JzIGhlcmU7IHRoZSBjb2RlIGNhbiByZXRyaWV2ZSB0aGVtIGluXG4gICAgICAvLyBnZXRSZWRpcmVjdFJlc3VsdCgpLlxuICAgICAgYXdhaXQgdGhpcy5fc2V0UmVkaXJlY3RVc2VyKG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlbG9hZEFuZFNldEN1cnJlbnRVc2VyT3JDbGVhcihcbiAgICB1c2VyOiBVc2VySW50ZXJuYWxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHVzZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKGUgYXMgRmlyZWJhc2VFcnJvcik/LmNvZGUgIT09XG4gICAgICAgIGBhdXRoLyR7QXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEfWBcbiAgICAgICkge1xuICAgICAgICAvLyBTb21ldGhpbmcncyB3cm9uZyB3aXRoIHRoZSB1c2VyJ3MgdG9rZW4uIExvZyB0aGVtIG91dCBhbmQgcmVtb3ZlXG4gICAgICAgIC8vIHRoZW0gZnJvbSBzdG9yYWdlXG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcih1c2VyKTtcbiAgfVxuXG4gIHVzZURldmljZUxhbmd1YWdlKCk6IHZvaWQge1xuICAgIHRoaXMubGFuZ3VhZ2VDb2RlID0gX2dldFVzZXJMYW5ndWFnZSgpO1xuICB9XG5cbiAgYXN5bmMgX2RlbGV0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLl9kZWxldGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZUN1cnJlbnRVc2VyKHVzZXJFeHRlcm46IFVzZXIgfCBudWxsKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gVGhlIHB1YmxpYyB1cGRhdGVDdXJyZW50VXNlciBtZXRob2QgbmVlZHMgdG8gbWFrZSBhIGNvcHkgb2YgdGhlIHVzZXIsXG4gICAgLy8gYW5kIGFsc28gY2hlY2sgdGhhdCB0aGUgcHJvamVjdCBtYXRjaGVzXG4gICAgY29uc3QgdXNlciA9IHVzZXJFeHRlcm5cbiAgICAgID8gKGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyRXh0ZXJuKSBhcyBVc2VySW50ZXJuYWwpXG4gICAgICA6IG51bGw7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIF9hc3NlcnQoXG4gICAgICAgIHVzZXIuYXV0aC5jb25maWcuYXBpS2V5ID09PSB0aGlzLmNvbmZpZy5hcGlLZXksXG4gICAgICAgIHRoaXMsXG4gICAgICAgIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlQ3VycmVudFVzZXIodXNlciAmJiB1c2VyLl9jbG9uZSh0aGlzKSk7XG4gIH1cblxuICBhc3luYyBfdXBkYXRlQ3VycmVudFVzZXIoXG4gICAgdXNlcjogVXNlciB8IG51bGwsXG4gICAgc2tpcEJlZm9yZVN0YXRlQ2FsbGJhY2tzOiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIF9hc3NlcnQoXG4gICAgICAgIHRoaXMudGVuYW50SWQgPT09IHVzZXIudGVuYW50SWQsXG4gICAgICAgIHRoaXMsXG4gICAgICAgIEF1dGhFcnJvckNvZGUuVEVOQU5UX0lEX01JU01BVENIXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghc2tpcEJlZm9yZVN0YXRlQ2FsbGJhY2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZSh1c2VyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlciBhcyBVc2VySW50ZXJuYWwgfCBudWxsKTtcbiAgICAgIHRoaXMubm90aWZ5QXV0aExpc3RlbmVycygpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2lnbk91dCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBSdW4gZmlyc3QsIHRvIGJsb2NrIF9zZXRSZWRpcmVjdFVzZXIoKSBpZiBhbnkgY2FsbGJhY2tzIGZhaWwuXG4gICAgYXdhaXQgdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnJ1bk1pZGRsZXdhcmUobnVsbCk7XG4gICAgLy8gQ2xlYXIgdGhlIHJlZGlyZWN0IHVzZXIgd2hlbiBzaWduT3V0IGlzIGNhbGxlZFxuICAgIGlmICh0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyIHx8IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xuICAgICAgYXdhaXQgdGhpcy5fc2V0UmVkaXJlY3RVc2VyKG51bGwpO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgY2FsbGJhY2tzIGZyb20gYmVpbmcgY2FsbGVkIGFnYWluIGluIF91cGRhdGVDdXJyZW50VXNlciwgYXNcbiAgICAvLyB0aGV5IHdlcmUgYWxyZWFkeSBjYWxsZWQgaW4gdGhlIGZpcnN0IGxpbmUuXG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUN1cnJlbnRVc2VyKG51bGwsIC8qIHNraXBCZWZvcmVTdGF0ZUNhbGxiYWNrcyAqLyB0cnVlKTtcbiAgfVxuXG4gIHNldFBlcnNpc3RlbmNlKHBlcnNpc3RlbmNlOiBQZXJzaXN0ZW5jZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5zZXRQZXJzaXN0ZW5jZShfZ2V0SW5zdGFuY2UocGVyc2lzdGVuY2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRSZWNhcHRjaGFDb25maWcodGhpcywge1xuICAgICAgY2xpZW50VHlwZTogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIsXG4gICAgICB2ZXJzaW9uOiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0VcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBSZWNhcHRjaGFDb25maWcocmVzcG9uc2UpO1xuICAgIGlmICh0aGlzLnRlbmFudElkID09IG51bGwpIHtcbiAgICAgIHRoaXMuX2FnZW50UmVjYXB0Y2hhQ29uZmlnID0gY29uZmlnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW3RoaXMudGVuYW50SWRdID0gY29uZmlnO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuZW1haWxQYXNzd29yZEVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHZlcmlmaWVyID0gbmV3IFJlY2FwdGNoYUVudGVycHJpc2VWZXJpZmllcih0aGlzKTtcbiAgICAgIHZvaWQgdmVyaWZpZXIudmVyaWZ5KCk7XG4gICAgfVxuICB9XG5cbiAgX2dldFJlY2FwdGNoYUNvbmZpZygpOiBSZWNhcHRjaGFDb25maWcgfCBudWxsIHtcbiAgICBpZiAodGhpcy50ZW5hbnRJZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWdlbnRSZWNhcHRjaGFDb25maWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW3RoaXMudGVuYW50SWRdO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRQZXJzaXN0ZW5jZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UucGVyc2lzdGVuY2UudHlwZTtcbiAgfVxuXG4gIF91cGRhdGVFcnJvck1hcChlcnJvck1hcDogQXV0aEVycm9yTWFwKTogdm9pZCB7XG4gICAgdGhpcy5fZXJyb3JGYWN0b3J5ID0gbmV3IEVycm9yRmFjdG9yeTxBdXRoRXJyb3JDb2RlLCBBdXRoRXJyb3JQYXJhbXM+KFxuICAgICAgJ2F1dGgnLFxuICAgICAgJ0ZpcmViYXNlJyxcbiAgICAgIChlcnJvck1hcCBhcyBFcnJvck1hcFJldHJpZXZlcikoKVxuICAgICk7XG4gIH1cblxuICBvbkF1dGhTdGF0ZUNoYW5nZWQoXG4gICAgbmV4dE9yT2JzZXJ2ZXI6IE5leHRPck9ic2VydmVyPFVzZXI+LFxuICAgIGVycm9yPzogRXJyb3JGbixcbiAgICBjb21wbGV0ZWQ/OiBDb21wbGV0ZUZuXG4gICk6IFVuc3Vic2NyaWJlIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlclN0YXRlTGlzdGVuZXIoXG4gICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbixcbiAgICAgIG5leHRPck9ic2VydmVyLFxuICAgICAgZXJyb3IsXG4gICAgICBjb21wbGV0ZWRcbiAgICApO1xuICB9XG5cbiAgYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZChcbiAgICBjYWxsYmFjazogKHVzZXI6IFVzZXIgfCBudWxsKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPixcbiAgICBvbkFib3J0PzogKCkgPT4gdm9pZFxuICApOiBVbnN1YnNjcmliZSB7XG4gICAgcmV0dXJuIHRoaXMuYmVmb3JlU3RhdGVRdWV1ZS5wdXNoQ2FsbGJhY2soY2FsbGJhY2ssIG9uQWJvcnQpO1xuICB9XG5cbiAgb25JZFRva2VuQ2hhbmdlZChcbiAgICBuZXh0T3JPYnNlcnZlcjogTmV4dE9yT2JzZXJ2ZXI8VXNlcj4sXG4gICAgZXJyb3I/OiBFcnJvckZuLFxuICAgIGNvbXBsZXRlZD86IENvbXBsZXRlRm5cbiAgKTogVW5zdWJzY3JpYmUge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyU3RhdGVMaXN0ZW5lcihcbiAgICAgIHRoaXMuaWRUb2tlblN1YnNjcmlwdGlvbixcbiAgICAgIG5leHRPck9ic2VydmVyLFxuICAgICAgZXJyb3IsXG4gICAgICBjb21wbGV0ZWRcbiAgICApO1xuICB9XG5cbiAgdG9KU09OKCk6IG9iamVjdCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFwaUtleTogdGhpcy5jb25maWcuYXBpS2V5LFxuICAgICAgYXV0aERvbWFpbjogdGhpcy5jb25maWcuYXV0aERvbWFpbixcbiAgICAgIGFwcE5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGN1cnJlbnRVc2VyOiB0aGlzLl9jdXJyZW50VXNlcj8udG9KU09OKClcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgX3NldFJlZGlyZWN0VXNlcihcbiAgICB1c2VyOiBVc2VySW50ZXJuYWwgfCBudWxsLFxuICAgIHBvcHVwUmVkaXJlY3RSZXNvbHZlcj86IFBvcHVwUmVkaXJlY3RSZXNvbHZlclxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByZWRpcmVjdE1hbmFnZXIgPSBhd2FpdCB0aGlzLmdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKFxuICAgICAgcG9wdXBSZWRpcmVjdFJlc29sdmVyXG4gICAgKTtcbiAgICByZXR1cm4gdXNlciA9PT0gbnVsbFxuICAgICAgPyByZWRpcmVjdE1hbmFnZXIucmVtb3ZlQ3VycmVudFVzZXIoKVxuICAgICAgOiByZWRpcmVjdE1hbmFnZXIuc2V0Q3VycmVudFVzZXIodXNlcik7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKFxuICAgIHBvcHVwUmVkaXJlY3RSZXNvbHZlcj86IFBvcHVwUmVkaXJlY3RSZXNvbHZlclxuICApOiBQcm9taXNlPFBlcnNpc3RlbmNlVXNlck1hbmFnZXI+IHtcbiAgICBpZiAoIXRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyOiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJJbnRlcm5hbCB8IG51bGwgPVxuICAgICAgICAocG9wdXBSZWRpcmVjdFJlc29sdmVyICYmIF9nZXRJbnN0YW5jZShwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpKSB8fFxuICAgICAgICB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXI7XG4gICAgICBfYXNzZXJ0KHJlc29sdmVyLCB0aGlzLCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SKTtcbiAgICAgIHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIgPSBhd2FpdCBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyLmNyZWF0ZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgW19nZXRJbnN0YW5jZShyZXNvbHZlci5fcmVkaXJlY3RQZXJzaXN0ZW5jZSldLFxuICAgICAgICBLZXlOYW1lLlJFRElSRUNUX1VTRVJcbiAgICAgICk7XG4gICAgICB0aGlzLnJlZGlyZWN0VXNlciA9XG4gICAgICAgIGF3YWl0IHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIuZ2V0Q3VycmVudFVzZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcjtcbiAgfVxuXG4gIGFzeW5jIF9yZWRpcmVjdFVzZXJGb3JJZChpZDogc3RyaW5nKTogUHJvbWlzZTxVc2VySW50ZXJuYWwgfCBudWxsPiB7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3ZlIGNsZWFyZWQgYW55IHBlbmRpbmcgcGVyc2lzdGVuY2UgYWN0aW9ucyBpZiB3ZSdyZSBub3QgaW5cbiAgICAvLyB0aGUgaW5pdGlhbGl6ZXJcbiAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7fSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRVc2VyPy5fcmVkaXJlY3RFdmVudElkID09PSBpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRVc2VyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlZGlyZWN0VXNlcj8uX3JlZGlyZWN0RXZlbnRJZCA9PT0gaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZGlyZWN0VXNlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIF9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VyOiBVc2VySW50ZXJuYWwpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodXNlciA9PT0gdGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgcmV0dXJuIHRoaXMucXVldWUoYXN5bmMgKCkgPT4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIpKTtcbiAgICB9XG4gIH1cblxuICAvKiogTm90aWZpZXMgbGlzdGVuZXJzIG9ubHkgaWYgdGhlIHVzZXIgaXMgY3VycmVudCAqL1xuICBfbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHVzZXI6IFVzZXJJbnRlcm5hbCk6IHZvaWQge1xuICAgIGlmICh1c2VyID09PSB0aGlzLmN1cnJlbnRVc2VyKSB7XG4gICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH1cblxuICBfa2V5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uZmlnLmF1dGhEb21haW59OiR7dGhpcy5jb25maWcuYXBpS2V5fToke3RoaXMubmFtZX1gO1xuICB9XG5cbiAgX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpOiB2b2lkIHtcbiAgICB0aGlzLmlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgfVxuICB9XG5cbiAgX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCk6IHZvaWQge1xuICAgIHRoaXMuaXNQcm9hY3RpdmVSZWZyZXNoRW5hYmxlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RvcFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICB9XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgY3VycmVudCB1c2VyIGNhc3QgYXMgdGhlIGludGVybmFsIHR5cGUgKi9cbiAgZ2V0IF9jdXJyZW50VXNlcigpOiBVc2VySW50ZXJuYWwge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRVc2VyIGFzIFVzZXJJbnRlcm5hbDtcbiAgfVxuXG4gIHByaXZhdGUgbm90aWZ5QXV0aExpc3RlbmVycygpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlkVG9rZW5TdWJzY3JpcHRpb24ubmV4dCh0aGlzLmN1cnJlbnRVc2VyKTtcblxuICAgIGNvbnN0IGN1cnJlbnRVaWQgPSB0aGlzLmN1cnJlbnRVc2VyPy51aWQgPz8gbnVsbDtcbiAgICBpZiAodGhpcy5sYXN0Tm90aWZpZWRVaWQgIT09IGN1cnJlbnRVaWQpIHtcbiAgICAgIHRoaXMubGFzdE5vdGlmaWVkVWlkID0gY3VycmVudFVpZDtcbiAgICAgIHRoaXMuYXV0aFN0YXRlU3Vic2NyaXB0aW9uLm5leHQodGhpcy5jdXJyZW50VXNlcik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlclN0YXRlTGlzdGVuZXIoXG4gICAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb248VXNlcj4sXG4gICAgbmV4dE9yT2JzZXJ2ZXI6IE5leHRPck9ic2VydmVyPFVzZXI+LFxuICAgIGVycm9yPzogRXJyb3JGbixcbiAgICBjb21wbGV0ZWQ/OiBDb21wbGV0ZUZuXG4gICk6IFVuc3Vic2NyaWJlIHtcbiAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGNiID1cbiAgICAgIHR5cGVvZiBuZXh0T3JPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG5leHRPck9ic2VydmVyXG4gICAgICAgIDogbmV4dE9yT2JzZXJ2ZXIubmV4dC5iaW5kKG5leHRPck9ic2VydmVyKTtcblxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9pc0luaXRpYWxpemVkXG4gICAgICA/IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICA6IHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgICBfYXNzZXJ0KHByb21pc2UsIHRoaXMsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgIC8vIFRoZSBjYWxsYmFjayBuZWVkcyB0byBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkgcGVyIHRoZSBzcGVjLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICBwcm9taXNlLnRoZW4oKCkgPT4gY2IodGhpcy5jdXJyZW50VXNlcikpO1xuXG4gICAgaWYgKHR5cGVvZiBuZXh0T3JPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbi5hZGRPYnNlcnZlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb24uYWRkT2JzZXJ2ZXIobmV4dE9yT2JzZXJ2ZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb3RlY3RlZCAoZnJvbSByYWNlIGNvbmRpdGlvbnMpIG1ldGhvZCB0byBzZXQgdGhlIGN1cnJlbnQgdXNlci4gVGhpc1xuICAgKiBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBxdWV1ZWQgY2FsbGJhY2suIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIGJlY2F1c2UgdGhlIHF1ZXVlIHNob3VsZG4ndCByZWx5IG9uIGFub3RoZXIgcXVldWVkIGNhbGxiYWNrLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBkaXJlY3RseVNldEN1cnJlbnRVc2VyKFxuICAgIHVzZXI6IFVzZXJJbnRlcm5hbCB8IG51bGxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuY3VycmVudFVzZXIgJiYgdGhpcy5jdXJyZW50VXNlciAhPT0gdXNlcikge1xuICAgICAgdGhpcy5fY3VycmVudFVzZXIuX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgfVxuICAgIGlmICh1c2VyICYmIHRoaXMuaXNQcm9hY3RpdmVSZWZyZXNoRW5hYmxlZCkge1xuICAgICAgdXNlci5fc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50VXNlciA9IHVzZXI7XG5cbiAgICBpZiAodXNlcikge1xuICAgICAgYXdhaXQgdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLnNldEN1cnJlbnRVc2VyKHVzZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UucmVtb3ZlQ3VycmVudFVzZXIoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHF1ZXVlKGFjdGlvbjogQXN5bmNBY3Rpb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBJbiBjYXNlIHNvbWV0aGluZyBlcnJvcnMsIHRoZSBjYWxsYmFjayBzdGlsbCBzaG91bGQgYmUgY2FsbGVkIGluIG9yZGVyXG4gICAgLy8gdG8ga2VlcCB0aGUgcHJvbWlzZSBjaGFpbiBhbGl2ZVxuICAgIHRoaXMub3BlcmF0aW9ucyA9IHRoaXMub3BlcmF0aW9ucy50aGVuKGFjdGlvbiwgYWN0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgYXNzZXJ0ZWRQZXJzaXN0ZW5jZSgpOiBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyIHtcbiAgICBfYXNzZXJ0KHRoaXMucGVyc2lzdGVuY2VNYW5hZ2VyLCB0aGlzLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZU1hbmFnZXI7XG4gIH1cblxuICBwcml2YXRlIGZyYW1ld29ya3M6IHN0cmluZ1tdID0gW107XG4gIHByaXZhdGUgY2xpZW50VmVyc2lvbjogc3RyaW5nO1xuICBfbG9nRnJhbWV3b3JrKGZyYW1ld29yazogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFmcmFtZXdvcmsgfHwgdGhpcy5mcmFtZXdvcmtzLmluY2x1ZGVzKGZyYW1ld29yaykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mcmFtZXdvcmtzLnB1c2goZnJhbWV3b3JrKTtcblxuICAgIC8vIFNvcnQgYWxwaGFiZXRpY2FsbHkgc28gdGhhdCBcIkZpcmViYXNlQ29yZS13ZWIsRmlyZWJhc2VVSS13ZWJcIiBhbmRcbiAgICAvLyBcIkZpcmViYXNlVUktd2ViLEZpcmViYXNlQ29yZS13ZWJcIiBhcmVuJ3Qgdmlld2VkIGFzIGRpZmZlcmVudC5cbiAgICB0aGlzLmZyYW1ld29ya3Muc29ydCgpO1xuICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IF9nZXRDbGllbnRWZXJzaW9uKFxuICAgICAgdGhpcy5jb25maWcuY2xpZW50UGxhdGZvcm0sXG4gICAgICB0aGlzLl9nZXRGcmFtZXdvcmtzKClcbiAgICApO1xuICB9XG4gIF9nZXRGcmFtZXdvcmtzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5mcmFtZXdvcmtzO1xuICB9XG4gIGFzeW5jIF9nZXRBZGRpdGlvbmFsSGVhZGVycygpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+IHtcbiAgICAvLyBBZGRpdGlvbmFsIGhlYWRlcnMgb24gZXZlcnkgcmVxdWVzdFxuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICBbSHR0cEhlYWRlci5YX0NMSUVOVF9WRVJTSU9OXTogdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmFwcC5vcHRpb25zLmFwcElkKSB7XG4gICAgICBoZWFkZXJzW0h0dHBIZWFkZXIuWF9GSVJFQkFTRV9HTVBJRF0gPSB0aGlzLmFwcC5vcHRpb25zLmFwcElkO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBoZWFydGJlYXQgc2VydmljZSBleGlzdHMsIGFkZCB0aGUgaGVhcnRiZWF0IHN0cmluZ1xuICAgIGNvbnN0IGhlYXJ0YmVhdHNIZWFkZXIgPSBhd2FpdCB0aGlzLmhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlclxuICAgICAgLmdldEltbWVkaWF0ZSh7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICB9KVxuICAgICAgPy5nZXRIZWFydGJlYXRzSGVhZGVyKCk7XG4gICAgaWYgKGhlYXJ0YmVhdHNIZWFkZXIpIHtcbiAgICAgIGhlYWRlcnNbSHR0cEhlYWRlci5YX0ZJUkVCQVNFX0NMSUVOVF0gPSBoZWFydGJlYXRzSGVhZGVyO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBBcHAgQ2hlY2sgc2VydmljZSBleGlzdHMsIGFkZCB0aGUgQXBwIENoZWNrIHRva2VuIGluIHRoZSBoZWFkZXJzXG4gICAgY29uc3QgYXBwQ2hlY2tUb2tlbiA9IGF3YWl0IHRoaXMuX2dldEFwcENoZWNrVG9rZW4oKTtcbiAgICBpZiAoYXBwQ2hlY2tUb2tlbikge1xuICAgICAgaGVhZGVyc1tIdHRwSGVhZGVyLlhfRklSRUJBU0VfQVBQX0NIRUNLXSA9IGFwcENoZWNrVG9rZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cblxuICBhc3luYyBfZ2V0QXBwQ2hlY2tUb2tlbigpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IGFwcENoZWNrVG9rZW5SZXN1bHQgPSBhd2FpdCB0aGlzLmFwcENoZWNrU2VydmljZVByb3ZpZGVyXG4gICAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSlcbiAgICAgID8uZ2V0VG9rZW4oKTtcbiAgICBpZiAoYXBwQ2hlY2tUb2tlblJlc3VsdD8uZXJyb3IpIHtcbiAgICAgIC8vIENvbnRleHQ6IGFwcENoZWNrLmdldFRva2VuKCkgd2lsbCBuZXZlciB0aHJvdyBldmVuIGlmIGFuIGVycm9yIGhhcHBlbmVkLlxuICAgICAgLy8gSW4gdGhlIGVycm9yIGNhc2UsIGEgZHVtbXkgdG9rZW4gd2lsbCBiZSByZXR1cm5lZCBhbG9uZyB3aXRoIGFuIGVycm9yIGZpZWxkIGRlc2NyaWJpbmdcbiAgICAgIC8vIHRoZSBlcnJvci4gSW4gZ2VuZXJhbCwgd2Ugc2hvdWxkbid0IGNhcmUgYWJvdXQgdGhlIGVycm9yIGNvbmRpdGlvbiBhbmQganVzdCB1c2VcbiAgICAgIC8vIHRoZSB0b2tlbiAoYWN0dWFsIG9yIGR1bW15KSB0byBzZW5kIHJlcXVlc3RzLlxuICAgICAgX2xvZ1dhcm4oXG4gICAgICAgIGBFcnJvciB3aGlsZSByZXRyaWV2aW5nIEFwcCBDaGVjayB0b2tlbjogJHthcHBDaGVja1Rva2VuUmVzdWx0LmVycm9yfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhcHBDaGVja1Rva2VuUmVzdWx0Py50b2tlbjtcbiAgfVxufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSB1c2VkIHRvIGNhc3QgZG93biB0byBvdXIgcHJpdmF0ZSBpbXBsbWVudGF0aW9uIG9mIEF1dGguXG4gKiBJdCB3aWxsIGFsc28gaGFuZGxlIHVud3JhcHBpbmcgZnJvbSB0aGUgY29tcGF0IHR5cGUgaWYgbmVjZXNzYXJ5XG4gKlxuICogQHBhcmFtIGF1dGggQXV0aCBvYmplY3QgcGFzc2VkIGluIGZyb20gZGV2ZWxvcGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2FzdEF1dGgoYXV0aDogQXV0aCk6IEF1dGhJbnRlcm5hbCB7XG4gIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkgYXMgQXV0aEludGVybmFsO1xufVxuXG4vKiogSGVscGVyIGNsYXNzIHRvIHdyYXAgc3Vic2NyaWJlciBsb2dpYyAqL1xuY2xhc3MgU3Vic2NyaXB0aW9uPFQ+IHtcbiAgcHJpdmF0ZSBvYnNlcnZlcjogT2JzZXJ2ZXI8VCB8IG51bGw+IHwgbnVsbCA9IG51bGw7XG4gIHJlYWRvbmx5IGFkZE9ic2VydmVyOiBTdWJzY3JpYmU8VCB8IG51bGw+ID0gY3JlYXRlU3Vic2NyaWJlKFxuICAgIG9ic2VydmVyID0+ICh0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXIpXG4gICk7XG5cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgYXV0aDogQXV0aEludGVybmFsKSB7fVxuXG4gIGdldCBuZXh0KCk6IE5leHRGbjxUIHwgbnVsbD4ge1xuICAgIF9hc3NlcnQodGhpcy5vYnNlcnZlciwgdGhpcy5hdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICByZXR1cm4gdGhpcy5vYnNlcnZlci5uZXh0LmJpbmQodGhpcy5vYnNlcnZlcik7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IF9nZXRQcm92aWRlciwgRmlyZWJhc2VBcHAgfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IGRlZXBFcXVhbCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IEF1dGgsIERlcGVuZGVuY2llcyB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgUGVyc2lzdGVuY2VJbnRlcm5hbCB9IGZyb20gJy4uL3BlcnNpc3RlbmNlJztcbmltcG9ydCB7IF9mYWlsIH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgX2dldEluc3RhbmNlIH0gZnJvbSAnLi4vdXRpbC9pbnN0YW50aWF0b3InO1xuaW1wb3J0IHsgQXV0aEltcGwgfSBmcm9tICcuL2F1dGhfaW1wbCc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlIHdpdGggZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlclxuICoge0BsaW5rIERlcGVuZGVuY2llc30uXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyBtb3JlIGNvbnRyb2wgb3ZlciB0aGUge0BsaW5rIEF1dGh9IGluc3RhbmNlIHRoYW5cbiAqIHtAbGluayBnZXRBdXRofS4gYGdldEF1dGhgIHVzZXMgcGxhdGZvcm0tc3BlY2lmaWMgZGVmYXVsdHMgdG8gc3VwcGx5XG4gKiB0aGUge0BsaW5rIERlcGVuZGVuY2llc30uIEluIGdlbmVyYWwsIGBnZXRBdXRoYCBpcyB0aGUgZWFzaWVzdCB3YXkgdG9cbiAqIGluaXRpYWxpemUgQXV0aCBhbmQgd29ya3MgZm9yIG1vc3QgdXNlIGNhc2VzLiBVc2UgYGluaXRpYWxpemVBdXRoYCBpZiB5b3VcbiAqIG5lZWQgY29udHJvbCBvdmVyIHdoaWNoIHBlcnNpc3RlbmNlIGxheWVyIGlzIHVzZWQsIG9yIHRvIG1pbmltaXplIGJ1bmRsZVxuICogc2l6ZSBpZiB5b3UncmUgbm90IHVzaW5nIGVpdGhlciBgc2lnbkluV2l0aFBvcHVwYCBvciBgc2lnbkluV2l0aFJlZGlyZWN0YC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91ciBhcHAgb25seSB1c2VzIGFub255bW91cyBhY2NvdW50cyBhbmQgeW91IG9ubHkgd2FudFxuICogYWNjb3VudHMgc2F2ZWQgZm9yIHRoZSBjdXJyZW50IHNlc3Npb24sIGluaXRpYWxpemUgYEF1dGhgIHdpdGg6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IGF1dGggPSBpbml0aWFsaXplQXV0aChhcHAsIHtcbiAqICAgcGVyc2lzdGVuY2U6IGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UsXG4gKiAgIHBvcHVwUmVkaXJlY3RSZXNvbHZlcjogdW5kZWZpbmVkLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplQXV0aChhcHA6IEZpcmViYXNlQXBwLCBkZXBzPzogRGVwZW5kZW5jaWVzKTogQXV0aCB7XG4gIGNvbnN0IHByb3ZpZGVyID0gX2dldFByb3ZpZGVyKGFwcCwgJ2F1dGgnKTtcblxuICBpZiAocHJvdmlkZXIuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgY29uc3QgYXV0aCA9IHByb3ZpZGVyLmdldEltbWVkaWF0ZSgpIGFzIEF1dGhJbXBsO1xuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gcHJvdmlkZXIuZ2V0T3B0aW9ucygpIGFzIERlcGVuZGVuY2llcztcbiAgICBpZiAoZGVlcEVxdWFsKGluaXRpYWxPcHRpb25zLCBkZXBzID8/IHt9KSkge1xuICAgICAgcmV0dXJuIGF1dGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9mYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYXV0aCA9IHByb3ZpZGVyLmluaXRpYWxpemUoeyBvcHRpb25zOiBkZXBzIH0pIGFzIEF1dGhJbXBsO1xuXG4gIHJldHVybiBhdXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2luaXRpYWxpemVBdXRoSW5zdGFuY2UoXG4gIGF1dGg6IEF1dGhJbXBsLFxuICBkZXBzPzogRGVwZW5kZW5jaWVzXG4pOiB2b2lkIHtcbiAgY29uc3QgcGVyc2lzdGVuY2UgPSBkZXBzPy5wZXJzaXN0ZW5jZSB8fCBbXTtcbiAgY29uc3QgaGllcmFyY2h5ID0gKFxuICAgIEFycmF5LmlzQXJyYXkocGVyc2lzdGVuY2UpID8gcGVyc2lzdGVuY2UgOiBbcGVyc2lzdGVuY2VdXG4gICkubWFwPFBlcnNpc3RlbmNlSW50ZXJuYWw+KF9nZXRJbnN0YW5jZSk7XG4gIGlmIChkZXBzPy5lcnJvck1hcCkge1xuICAgIGF1dGguX3VwZGF0ZUVycm9yTWFwKGRlcHMuZXJyb3JNYXApO1xuICB9XG5cbiAgLy8gVGhpcyBwcm9taXNlIGlzIGludGVuZGVkIHRvIGZsb2F0OyBhdXRoIGluaXRpYWxpemF0aW9uIGhhcHBlbnMgaW4gdGhlXG4gIC8vIGJhY2tncm91bmQsIG1lYW53aGlsZSB0aGUgYXV0aCBvYmplY3QgbWF5IGJlIHVzZWQgYnkgdGhlIGFwcC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICBhdXRoLl9pbml0aWFsaXplV2l0aFBlcnNpc3RlbmNlKGhpZXJhcmNoeSwgZGVwcz8ucG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4vYXV0aF9pbXBsJztcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgRmlyZWJhc2UgQXV0aCBFbXVsYXRvciwgaW5zdGVhZCBvZiBwcm9kdWN0aW9uXG4gKiBGaXJlYmFzZSBBdXRoIHNlcnZpY2VzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIG11c3QgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgaW1tZWRpYXRlbHkgZm9sbG93aW5nIHRoZSBmaXJzdCBjYWxsIHRvXG4gKiB7QGxpbmsgaW5pdGlhbGl6ZUF1dGh9LiAgRG8gbm90IHVzZSB3aXRoIHByb2R1Y3Rpb24gY3JlZGVudGlhbHMgYXMgZW11bGF0b3JcbiAqIHRyYWZmaWMgaXMgbm90IGVuY3J5cHRlZC5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbm5lY3RBdXRoRW11bGF0b3IoYXV0aCwgJ2h0dHA6Ly8xMjcuMC4wLjE6OTA5OScsIHsgZGlzYWJsZVdhcm5pbmdzOiB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgYXQgd2hpY2ggdGhlIGVtdWxhdG9yIGlzIHJ1bm5pbmcgKGVnLCAnaHR0cDovL2xvY2FsaG9zdDo5MDk5JykuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBgb3B0aW9ucy5kaXNhYmxlV2FybmluZ3NgIGRlZmF1bHRzIHRvIGBmYWxzZWAuIFNldCBpdCB0b1xuICogYHRydWVgIHRvIGRpc2FibGUgdGhlIHdhcm5pbmcgYmFubmVyIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdEF1dGhFbXVsYXRvcihcbiAgYXV0aDogQXV0aCxcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiB7IGRpc2FibGVXYXJuaW5nczogYm9vbGVhbiB9XG4pOiB2b2lkIHtcbiAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICBfYXNzZXJ0KFxuICAgIGF1dGhJbnRlcm5hbC5fY2FuSW5pdEVtdWxhdG9yLFxuICAgIGF1dGhJbnRlcm5hbCxcbiAgICBBdXRoRXJyb3JDb2RlLkVNVUxBVE9SX0NPTkZJR19GQUlMRURcbiAgKTtcblxuICBfYXNzZXJ0KFxuICAgIC9eaHR0cHM/OlxcL1xcLy8udGVzdCh1cmwpLFxuICAgIGF1dGhJbnRlcm5hbCxcbiAgICBBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1VTEFUT1JfU0NIRU1FXG4gICk7XG5cbiAgY29uc3QgZGlzYWJsZVdhcm5pbmdzID0gISFvcHRpb25zPy5kaXNhYmxlV2FybmluZ3M7XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2wodXJsKTtcbiAgY29uc3QgeyBob3N0LCBwb3J0IH0gPSBleHRyYWN0SG9zdEFuZFBvcnQodXJsKTtcbiAgY29uc3QgcG9ydFN0ciA9IHBvcnQgPT09IG51bGwgPyAnJyA6IGA6JHtwb3J0fWA7XG5cbiAgLy8gQWx3YXlzIHJlcGxhY2UgcGF0aCB3aXRoIFwiL1wiIChldmVuIGlmIGlucHV0IHVybCBoYWQgbm8gcGF0aCBhdCBhbGwsIG9yIGhhZCBhIGRpZmZlcmVudCBvbmUpLlxuICBhdXRoSW50ZXJuYWwuY29uZmlnLmVtdWxhdG9yID0geyB1cmw6IGAke3Byb3RvY29sfS8vJHtob3N0fSR7cG9ydFN0cn0vYCB9O1xuICBhdXRoSW50ZXJuYWwuc2V0dGluZ3MuYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nID0gdHJ1ZTtcbiAgYXV0aEludGVybmFsLmVtdWxhdG9yQ29uZmlnID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgaG9zdCxcbiAgICBwb3J0LFxuICAgIHByb3RvY29sOiBwcm90b2NvbC5yZXBsYWNlKCc6JywgJycpLFxuICAgIG9wdGlvbnM6IE9iamVjdC5mcmVlemUoeyBkaXNhYmxlV2FybmluZ3MgfSlcbiAgfSk7XG5cbiAgaWYgKCFkaXNhYmxlV2FybmluZ3MpIHtcbiAgICBlbWl0RW11bGF0b3JXYXJuaW5nKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgcHJvdG9jb2xFbmQgPSB1cmwuaW5kZXhPZignOicpO1xuICByZXR1cm4gcHJvdG9jb2xFbmQgPCAwID8gJycgOiB1cmwuc3Vic3RyKDAsIHByb3RvY29sRW5kICsgMSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RIb3N0QW5kUG9ydCh1cmw6IHN0cmluZyk6IHtcbiAgaG9zdDogc3RyaW5nO1xuICBwb3J0OiBudW1iZXIgfCBudWxsO1xufSB7XG4gIGNvbnN0IHByb3RvY29sID0gZXh0cmFjdFByb3RvY29sKHVybCk7XG4gIGNvbnN0IGF1dGhvcml0eSA9IC8oXFwvXFwvKT8oW14/Iy9dKykvLmV4ZWModXJsLnN1YnN0cihwcm90b2NvbC5sZW5ndGgpKTsgLy8gQmV0d2VlbiAvLyBhbmQgLywgPyBvciAjLlxuICBpZiAoIWF1dGhvcml0eSkge1xuICAgIHJldHVybiB7IGhvc3Q6ICcnLCBwb3J0OiBudWxsIH07XG4gIH1cbiAgY29uc3QgaG9zdEFuZFBvcnQgPSBhdXRob3JpdHlbMl0uc3BsaXQoJ0AnKS5wb3AoKSB8fCAnJzsgLy8gU3RyaXAgb3V0IFwidXNlcm5hbWU6cGFzc3dvcmRAXCIuXG4gIGNvbnN0IGJyYWNrZXRlZElQdjYgPSAvXihcXFtbXlxcXV0rXFxdKSg6fCQpLy5leGVjKGhvc3RBbmRQb3J0KTtcbiAgaWYgKGJyYWNrZXRlZElQdjYpIHtcbiAgICBjb25zdCBob3N0ID0gYnJhY2tldGVkSVB2NlsxXTtcbiAgICByZXR1cm4geyBob3N0LCBwb3J0OiBwYXJzZVBvcnQoaG9zdEFuZFBvcnQuc3Vic3RyKGhvc3QubGVuZ3RoICsgMSkpIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW2hvc3QsIHBvcnRdID0gaG9zdEFuZFBvcnQuc3BsaXQoJzonKTtcbiAgICByZXR1cm4geyBob3N0LCBwb3J0OiBwYXJzZVBvcnQocG9ydCkgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVBvcnQocG9ydFN0cjogc3RyaW5nKTogbnVtYmVyIHwgbnVsbCB7XG4gIGlmICghcG9ydFN0cikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHBvcnQgPSBOdW1iZXIocG9ydFN0cik7XG4gIGlmIChpc05hTihwb3J0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwb3J0O1xufVxuXG5mdW5jdGlvbiBlbWl0RW11bGF0b3JXYXJuaW5nKCk6IHZvaWQge1xuICBmdW5jdGlvbiBhdHRhY2hCYW5uZXIoKTogdm9pZCB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgY29uc3Qgc3R5ID0gZWwuc3R5bGU7XG4gICAgZWwuaW5uZXJUZXh0ID1cbiAgICAgICdSdW5uaW5nIGluIGVtdWxhdG9yIG1vZGUuIERvIG5vdCB1c2Ugd2l0aCBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzLic7XG4gICAgc3R5LnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICBzdHkud2lkdGggPSAnMTAwJSc7XG4gICAgc3R5LmJhY2tncm91bmRDb2xvciA9ICcjZmZmZmZmJztcbiAgICBzdHkuYm9yZGVyID0gJy4xZW0gc29saWQgIzAwMDAwMCc7XG4gICAgc3R5LmNvbG9yID0gJyNiNTAwMDAnO1xuICAgIHN0eS5ib3R0b20gPSAnMHB4JztcbiAgICBzdHkubGVmdCA9ICcwcHgnO1xuICAgIHN0eS5tYXJnaW4gPSAnMHB4JztcbiAgICBzdHkuekluZGV4ID0gJzEwMDAwJztcbiAgICBzdHkudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnZmlyZWJhc2UtZW11bGF0b3Itd2FybmluZycpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5pbmZvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5pbmZvKFxuICAgICAgJ1dBUk5JTkc6IFlvdSBhcmUgdXNpbmcgdGhlIEF1dGggRW11bGF0b3IsJyArXG4gICAgICAgICcgd2hpY2ggaXMgaW50ZW5kZWQgZm9yIGxvY2FsIHRlc3Rpbmcgb25seS4gIERvIG5vdCB1c2Ugd2l0aCcgK1xuICAgICAgICAnIHByb2R1Y3Rpb24gY3JlZGVudGlhbHMuJ1xuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGF0dGFjaEJhbm5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dGFjaEJhbm5lcigpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUGhvbmVPck9hdXRoVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9tZmEnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBkZWJ1Z0ZhaWwgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5cbi8qKlxuICogSW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgYW4ge0BsaW5rIEF1dGhQcm92aWRlcn0uXG4gKlxuICogQHJlbWFya3NcbiAqIEltcGxlbWVudGF0aW9ucyBzcGVjaWZ5IHRoZSBkZXRhaWxzIGFib3V0IGVhY2ggYXV0aCBwcm92aWRlcidzIGNyZWRlbnRpYWwgcmVxdWlyZW1lbnRzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhDcmVkZW50aWFsIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIElEIGZvciB0aGUgY3JlZGVudGlhbC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRm9yIGV4YW1wbGUsICdmYWNlYm9vay5jb20nLCBvciAnZ29vZ2xlLmNvbScuXG4gICAgICovXG4gICAgcmVhZG9ubHkgcHJvdmlkZXJJZDogc3RyaW5nLFxuICAgIC8qKlxuICAgICAqIFRoZSBhdXRoZW50aWNhdGlvbiBzaWduIGluIG1ldGhvZCBmb3IgdGhlIGNyZWRlbnRpYWwuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEZvciBleGFtcGxlLCB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9QQVNTV09SRCwgb3JcbiAgICAgKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBzaWduLWluIG1ldGhvZFxuICAgICAqIGlkZW50aWZpZXIgYXMgcmV0dXJuZWQgaW4ge0BsaW5rIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsfS5cbiAgICAgKi9cbiAgICByZWFkb25seSBzaWduSW5NZXRob2Q6IHN0cmluZ1xuICApIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICovXG4gIHRvSlNPTigpOiBvYmplY3Qge1xuICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0SWRUb2tlblJlc3BvbnNlKF9hdXRoOiBBdXRoSW50ZXJuYWwpOiBQcm9taXNlPFBob25lT3JPYXV0aFRva2VuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9saW5rVG9JZFRva2VuKFxuICAgIF9hdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgX2lkVG9rZW46IHN0cmluZ1xuICApOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT4ge1xuICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihfYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxJZFRva2VuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQWN0aW9uQ29kZU9wZXJhdGlvbiwgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7XG4gIEVuZHBvaW50LFxuICBIdHRwTWV0aG9kLFxuICBfYWRkVGlkSWZOZWNlc3NhcnksXG4gIF9wZXJmb3JtQXBpUmVxdWVzdFxufSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBNZmFFbnJvbGxtZW50IH0gZnJvbSAnLi9tZmEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlc2V0UGFzc3dvcmRSZXF1ZXN0IHtcbiAgb29iQ29kZTogc3RyaW5nO1xuICBuZXdQYXNzd29yZD86IHN0cmluZztcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzZXRQYXNzd29yZFJlc3BvbnNlIHtcbiAgZW1haWw6IHN0cmluZztcbiAgbmV3RW1haWw/OiBzdHJpbmc7XG4gIHJlcXVlc3RUeXBlPzogQWN0aW9uQ29kZU9wZXJhdGlvbjtcbiAgbWZhSW5mbz86IE1mYUVucm9sbG1lbnQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNldFBhc3N3b3JkKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBSZXNldFBhc3N3b3JkUmVxdWVzdFxuKTogUHJvbWlzZTxSZXNldFBhc3N3b3JkUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxSZXNldFBhc3N3b3JkUmVxdWVzdCwgUmVzZXRQYXNzd29yZFJlc3BvbnNlPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5SRVNFVF9QQVNTV09SRCxcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlRW1haWxQYXNzd29yZFJlcXVlc3Qge1xuICBpZFRva2VuOiBzdHJpbmc7XG4gIHJldHVyblNlY3VyZVRva2VuPzogYm9vbGVhbjtcbiAgZW1haWw/OiBzdHJpbmc7XG4gIHBhc3N3b3JkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUVtYWlsUGFzc3dvcmRSZXNwb25zZSBleHRlbmRzIElkVG9rZW5SZXNwb25zZSB7fVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRW1haWxQYXNzd29yZChcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogVXBkYXRlRW1haWxQYXNzd29yZFJlcXVlc3Rcbik6IFByb21pc2U8VXBkYXRlRW1haWxQYXNzd29yZFJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8XG4gICAgVXBkYXRlRW1haWxQYXNzd29yZFJlcXVlc3QsXG4gICAgVXBkYXRlRW1haWxQYXNzd29yZFJlc3BvbnNlXG4gID4oYXV0aCwgSHR0cE1ldGhvZC5QT1NULCBFbmRwb2ludC5TRVRfQUNDT1VOVF9JTkZPLCByZXF1ZXN0KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcHBseUFjdGlvbkNvZGVSZXF1ZXN0IHtcbiAgb29iQ29kZTogc3RyaW5nO1xuICB0ZW5hbnRJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcHBseUFjdGlvbkNvZGVSZXNwb25zZSB7fVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXBwbHlBY3Rpb25Db2RlKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBBcHBseUFjdGlvbkNvZGVSZXF1ZXN0XG4pOiBQcm9taXNlPEFwcGx5QWN0aW9uQ29kZVJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8QXBwbHlBY3Rpb25Db2RlUmVxdWVzdCwgQXBwbHlBY3Rpb25Db2RlUmVzcG9uc2U+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8sXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBY3Rpb25Db2RlT3BlcmF0aW9uLCBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHtcbiAgRW5kcG9pbnQsXG4gIEh0dHBNZXRob2QsXG4gIFJlY2FwdGNoYUNsaWVudFR5cGUsXG4gIFJlY2FwdGNoYVZlcnNpb24sXG4gIF9hZGRUaWRJZk5lY2Vzc2FyeSxcbiAgX3BlcmZvcm1BcGlSZXF1ZXN0LFxuICBfcGVyZm9ybVNpZ25JblJlcXVlc3Rcbn0gZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgSWRUb2tlbiwgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25JbldpdGhQYXNzd29yZFJlcXVlc3Qge1xuICByZXR1cm5TZWN1cmVUb2tlbj86IGJvb2xlYW47XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG4gIHRlbmFudElkPzogc3RyaW5nO1xuICBjYXB0Y2hhUmVzcG9uc2U/OiBzdHJpbmc7XG4gIGNsaWVudFR5cGU/OiBSZWNhcHRjaGFDbGllbnRUeXBlO1xuICByZWNhcHRjaGFWZXJzaW9uPzogUmVjYXB0Y2hhVmVyc2lvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaWduSW5XaXRoUGFzc3dvcmRSZXNwb25zZSBleHRlbmRzIElkVG9rZW5SZXNwb25zZSB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGRpc3BsYXlOYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGFzc3dvcmQoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFNpZ25JbldpdGhQYXNzd29yZFJlcXVlc3Rcbik6IFByb21pc2U8U2lnbkluV2l0aFBhc3N3b3JkUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdDxcbiAgICBTaWduSW5XaXRoUGFzc3dvcmRSZXF1ZXN0LFxuICAgIFNpZ25JbldpdGhQYXNzd29yZFJlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BBU1NXT1JELFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldE9vYkNvZGVSZXF1ZXN0IHtcbiAgZW1haWw/OiBzdHJpbmc7IC8vIEV2ZXJ5dGhpbmcgZXhjZXB0IFZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXG4gIGNvbnRpbnVlVXJsPzogc3RyaW5nO1xuICBpT1NCdW5kbGVJZD86IHN0cmluZztcbiAgaW9zQXBwU3RvcmVJZD86IHN0cmluZztcbiAgYW5kcm9pZFBhY2thZ2VOYW1lPzogc3RyaW5nO1xuICBhbmRyb2lkSW5zdGFsbEFwcD86IGJvb2xlYW47XG4gIGFuZHJvaWRNaW5pbXVtVmVyc2lvbkNvZGU/OiBzdHJpbmc7XG4gIGNhbkhhbmRsZUNvZGVJbkFwcD86IGJvb2xlYW47XG4gIGR5bmFtaWNMaW5rRG9tYWluPzogc3RyaW5nO1xuICB0ZW5hbnRJZD86IHN0cmluZztcbiAgdGFyZ2V0UHJvamVjdGlkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeUVtYWlsUmVxdWVzdCBleHRlbmRzIEdldE9vYkNvZGVSZXF1ZXN0IHtcbiAgcmVxdWVzdFR5cGU6IEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0VNQUlMO1xuICBpZFRva2VuOiBJZFRva2VuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhc3N3b3JkUmVzZXRSZXF1ZXN0IGV4dGVuZHMgR2V0T29iQ29kZVJlcXVlc3Qge1xuICByZXF1ZXN0VHlwZTogQWN0aW9uQ29kZU9wZXJhdGlvbi5QQVNTV09SRF9SRVNFVDtcbiAgZW1haWw6IHN0cmluZztcbiAgY2FwdGNoYVJlc3A/OiBzdHJpbmc7XG4gIGNsaWVudFR5cGU/OiBSZWNhcHRjaGFDbGllbnRUeXBlO1xuICByZWNhcHRjaGFWZXJzaW9uPzogUmVjYXB0Y2hhVmVyc2lvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbWFpbFNpZ25JblJlcXVlc3QgZXh0ZW5kcyBHZXRPb2JDb2RlUmVxdWVzdCB7XG4gIHJlcXVlc3RUeXBlOiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTjtcbiAgZW1haWw6IHN0cmluZztcbiAgY2FwdGNoYVJlc3A/OiBzdHJpbmc7XG4gIGNsaWVudFR5cGU/OiBSZWNhcHRjaGFDbGllbnRUeXBlO1xuICByZWNhcHRjaGFWZXJzaW9uPzogUmVjYXB0Y2hhVmVyc2lvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlBbmRDaGFuZ2VFbWFpbFJlcXVlc3QgZXh0ZW5kcyBHZXRPb2JDb2RlUmVxdWVzdCB7XG4gIHJlcXVlc3RUeXBlOiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMO1xuICBpZFRva2VuOiBJZFRva2VuO1xuICBuZXdFbWFpbDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgR2V0T29iQ29kZVJlc3BvbnNlIHtcbiAgZW1haWw6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlFbWFpbFJlc3BvbnNlIGV4dGVuZHMgR2V0T29iQ29kZVJlc3BvbnNlIHt9XG5leHBvcnQgaW50ZXJmYWNlIFBhc3N3b3JkUmVzZXRSZXNwb25zZSBleHRlbmRzIEdldE9vYkNvZGVSZXNwb25zZSB7fVxuZXhwb3J0IGludGVyZmFjZSBFbWFpbFNpZ25JblJlc3BvbnNlIGV4dGVuZHMgR2V0T29iQ29kZVJlc3BvbnNlIHt9XG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeUFuZENoYW5nZUVtYWlsUmVzcG9uc2UgZXh0ZW5kcyBHZXRPb2JDb2RlUmVxdWVzdCB7fVxuXG5hc3luYyBmdW5jdGlvbiBzZW5kT29iQ29kZShcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogR2V0T29iQ29kZVJlcXVlc3Rcbik6IFByb21pc2U8R2V0T29iQ29kZVJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8R2V0T29iQ29kZVJlcXVlc3QsIEdldE9vYkNvZGVSZXNwb25zZT4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU0VORF9PT0JfQ09ERSxcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRFbWFpbFZlcmlmaWNhdGlvbihcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogVmVyaWZ5RW1haWxSZXF1ZXN0XG4pOiBQcm9taXNlPFZlcmlmeUVtYWlsUmVzcG9uc2U+IHtcbiAgcmV0dXJuIHNlbmRPb2JDb2RlKGF1dGgsIHJlcXVlc3QpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZFBhc3N3b3JkUmVzZXRFbWFpbChcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogUGFzc3dvcmRSZXNldFJlcXVlc3Rcbik6IFByb21pc2U8UGFzc3dvcmRSZXNldFJlc3BvbnNlPiB7XG4gIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRTaWduSW5MaW5rVG9FbWFpbChcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogRW1haWxTaWduSW5SZXF1ZXN0XG4pOiBQcm9taXNlPEVtYWlsU2lnbkluUmVzcG9uc2U+IHtcbiAgcmV0dXJuIHNlbmRPb2JDb2RlKGF1dGgsIHJlcXVlc3QpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5QW5kQ2hhbmdlRW1haWwoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFZlcmlmeUFuZENoYW5nZUVtYWlsUmVxdWVzdFxuKTogUHJvbWlzZTxWZXJpZnlBbmRDaGFuZ2VFbWFpbFJlc3BvbnNlPiB7XG4gIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIF9wZXJmb3JtU2lnbkluUmVxdWVzdCxcbiAgRW5kcG9pbnQsXG4gIEh0dHBNZXRob2QsXG4gIF9hZGRUaWRJZk5lY2Vzc2FyeVxufSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBTaWduSW5XaXRoRW1haWxMaW5rUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG9vYkNvZGU6IHN0cmluZztcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbkluV2l0aEVtYWlsTGlua1Jlc3BvbnNlIGV4dGVuZHMgSWRUb2tlblJlc3BvbnNlIHtcbiAgZW1haWw6IHN0cmluZztcbiAgaXNOZXdVc2VyOiBib29sZWFuO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsTGluayhcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogU2lnbkluV2l0aEVtYWlsTGlua1JlcXVlc3Rcbik6IFByb21pc2U8U2lnbkluV2l0aEVtYWlsTGlua1Jlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3Q8XG4gICAgU2lnbkluV2l0aEVtYWlsTGlua1JlcXVlc3QsXG4gICAgU2lnbkluV2l0aEVtYWlsTGlua1Jlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0VNQUlMX0xJTkssXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbkluV2l0aEVtYWlsTGlua0ZvckxpbmtpbmdSZXF1ZXN0XG4gIGV4dGVuZHMgU2lnbkluV2l0aEVtYWlsTGlua1JlcXVlc3Qge1xuICBpZFRva2VuOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoRW1haWxMaW5rRm9yTGlua2luZyhcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogU2lnbkluV2l0aEVtYWlsTGlua0ZvckxpbmtpbmdSZXF1ZXN0XG4pOiBQcm9taXNlPFNpZ25JbldpdGhFbWFpbExpbmtSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0PFxuICAgIFNpZ25JbldpdGhFbWFpbExpbmtGb3JMaW5raW5nUmVxdWVzdCxcbiAgICBTaWduSW5XaXRoRW1haWxMaW5rUmVzcG9uc2VcbiAgPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5TSUdOX0lOX1dJVEhfRU1BSUxfTElOSyxcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFByb3ZpZGVySWQsIFNpZ25Jbk1ldGhvZCB9IGZyb20gJy4uLy4uL21vZGVsL2VudW1zJztcblxuaW1wb3J0IHsgdXBkYXRlRW1haWxQYXNzd29yZCB9IGZyb20gJy4uLy4uL2FwaS9hY2NvdW50X21hbmFnZW1lbnQvZW1haWxfYW5kX3Bhc3N3b3JkJztcbmltcG9ydCB7XG4gIHNpZ25JbldpdGhQYXNzd29yZCxcbiAgU2lnbkluV2l0aFBhc3N3b3JkUmVxdWVzdFxufSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vZW1haWxfYW5kX3Bhc3N3b3JkJztcbmltcG9ydCB7XG4gIHNpZ25JbldpdGhFbWFpbExpbmssXG4gIHNpZ25JbldpdGhFbWFpbExpbmtGb3JMaW5raW5nXG59IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9lbWFpbF9saW5rJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBfZmFpbCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IEF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi9hdXRoX2NyZWRlbnRpYWwnO1xuaW1wb3J0IHsgaW5qZWN0UmVjYXB0Y2hhRmllbGRzIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm1fYnJvd3Nlci9yZWNhcHRjaGEvcmVjYXB0Y2hhX2VudGVycHJpc2VfdmVyaWZpZXInO1xuaW1wb3J0IHsgUmVjYXB0Y2hhQWN0aW9uTmFtZSwgUmVjYXB0Y2hhQ2xpZW50VHlwZSB9IGZyb20gJy4uLy4uL2FwaSc7XG4vKipcbiAqIEludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IHtAbGluayBFbWFpbEF1dGhQcm92aWRlcn0gZm9yXG4gKiB7QGxpbmsgUHJvdmlkZXJJZH0uUEFTU1dPUkRcbiAqXG4gKiBAcmVtYXJrc1xuICogQ292ZXJzIGJvdGgge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQgYW5kXG4gKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEVtYWlsQXV0aENyZWRlbnRpYWwgZXh0ZW5kcyBBdXRoQ3JlZGVudGlhbCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICAvKiogQGludGVybmFsICovXG4gICAgcmVhZG9ubHkgX2VtYWlsOiBzdHJpbmcsXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHJlYWRvbmx5IF9wYXNzd29yZDogc3RyaW5nLFxuICAgIHNpZ25Jbk1ldGhvZDogU2lnbkluTWV0aG9kLFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICByZWFkb25seSBfdGVuYW50SWQ6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICkge1xuICAgIHN1cGVyKFByb3ZpZGVySWQuUEFTU1dPUkQsIHNpZ25Jbk1ldGhvZCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZnJvbUVtYWlsQW5kUGFzc3dvcmQoXG4gICAgZW1haWw6IHN0cmluZyxcbiAgICBwYXNzd29yZDogc3RyaW5nXG4gICk6IEVtYWlsQXV0aENyZWRlbnRpYWwge1xuICAgIHJldHVybiBuZXcgRW1haWxBdXRoQ3JlZGVudGlhbChcbiAgICAgIGVtYWlsLFxuICAgICAgcGFzc3dvcmQsXG4gICAgICBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkRcbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21FbWFpbEFuZENvZGUoXG4gICAgZW1haWw6IHN0cmluZyxcbiAgICBvb2JDb2RlOiBzdHJpbmcsXG4gICAgdGVuYW50SWQ6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICk6IEVtYWlsQXV0aENyZWRlbnRpYWwge1xuICAgIHJldHVybiBuZXcgRW1haWxBdXRoQ3JlZGVudGlhbChcbiAgICAgIGVtYWlsLFxuICAgICAgb29iQ29kZSxcbiAgICAgIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LLFxuICAgICAgdGVuYW50SWRcbiAgICApO1xuICB9XG5cbiAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICovXG4gIHRvSlNPTigpOiBvYmplY3Qge1xuICAgIHJldHVybiB7XG4gICAgICBlbWFpbDogdGhpcy5fZW1haWwsXG4gICAgICBwYXNzd29yZDogdGhpcy5fcGFzc3dvcmQsXG4gICAgICBzaWduSW5NZXRob2Q6IHRoaXMuc2lnbkluTWV0aG9kLFxuICAgICAgdGVuYW50SWQ6IHRoaXMuX3RlbmFudElkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIHRvIGRlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW50byBhbiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfS5cbiAgICpcbiAgICogQHBhcmFtIGpzb24gLSBFaXRoZXIgYG9iamVjdGAgb3IgdGhlIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuIFdoZW4gc3RyaW5nIGlzXG4gICAqIHByb3ZpZGVkLCBgSlNPTi5wYXJzZWAgd291bGQgYmUgY2FsbGVkIGZpcnN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICovXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uOiBvYmplY3QgfCBzdHJpbmcpOiBFbWFpbEF1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XG4gICAgaWYgKG9iaj8uZW1haWwgJiYgb2JqPy5wYXNzd29yZCkge1xuICAgICAgaWYgKG9iai5zaWduSW5NZXRob2QgPT09IFNpZ25Jbk1ldGhvZC5FTUFJTF9QQVNTV09SRCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJvbUVtYWlsQW5kUGFzc3dvcmQob2JqLmVtYWlsLCBvYmoucGFzc3dvcmQpO1xuICAgICAgfSBlbHNlIGlmIChvYmouc2lnbkluTWV0aG9kID09PSBTaWduSW5NZXRob2QuRU1BSUxfTElOSykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJvbUVtYWlsQW5kQ29kZShvYmouZW1haWwsIG9iai5wYXNzd29yZCwgb2JqLnRlbmFudElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxJZFRva2VuUmVzcG9uc2U+IHtcbiAgICBzd2l0Y2ggKHRoaXMuc2lnbkluTWV0aG9kKSB7XG4gICAgICBjYXNlIFNpZ25Jbk1ldGhvZC5FTUFJTF9QQVNTV09SRDpcbiAgICAgICAgY29uc3QgcmVxdWVzdDogU2lnbkluV2l0aFBhc3N3b3JkUmVxdWVzdCA9IHtcbiAgICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcbiAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXG4gICAgICAgICAgcGFzc3dvcmQ6IHRoaXMuX3Bhc3N3b3JkLFxuICAgICAgICAgIGNsaWVudFR5cGU6IFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCXG4gICAgICAgIH07XG4gICAgICAgIGlmIChhdXRoLl9nZXRSZWNhcHRjaGFDb25maWcoKT8uZW1haWxQYXNzd29yZEVuYWJsZWQpIHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhcbiAgICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgUmVjYXB0Y2hhQWN0aW9uTmFtZS5TSUdOX0lOX1dJVEhfUEFTU1dPUkRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBzaWduSW5XaXRoUGFzc3dvcmQoYXV0aCwgcmVxdWVzdFdpdGhSZWNhcHRjaGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzaWduSW5XaXRoUGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkuY2F0Y2goYXN5bmMgZXJyb3IgPT4ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlcnJvci5jb2RlID09PSBgYXV0aC8ke0F1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU59YFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICdTaWduLWluIHdpdGggZW1haWwgYWRkcmVzcyBhbmQgcGFzc3dvcmQgaXMgcHJvdGVjdGVkIGJ5IHJlQ0FQVENIQSBmb3IgdGhpcyBwcm9qZWN0LiBBdXRvbWF0aWNhbGx5IHRyaWdnZXJpbmcgdGhlIHJlQ0FQVENIQSBmbG93IGFuZCByZXN0YXJ0aW5nIHRoZSBzaWduLWluIGZsb3cuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhcbiAgICAgICAgICAgICAgICBhdXRoLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgUmVjYXB0Y2hhQWN0aW9uTmFtZS5TSUdOX0lOX1dJVEhfUEFTU1dPUkRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhQYXNzd29yZChhdXRoLCByZXF1ZXN0V2l0aFJlY2FwdGNoYSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LOlxuICAgICAgICByZXR1cm4gc2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCB7XG4gICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxuICAgICAgICAgIG9vYkNvZGU6IHRoaXMuX3Bhc3N3b3JkXG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgX2ZhaWwoYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBfbGlua1RvSWRUb2tlbihcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgaWRUb2tlbjogc3RyaW5nXG4gICk6IFByb21pc2U8SWRUb2tlblJlc3BvbnNlPiB7XG4gICAgc3dpdGNoICh0aGlzLnNpZ25Jbk1ldGhvZCkge1xuICAgICAgY2FzZSBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVFbWFpbFBhc3N3b3JkKGF1dGgsIHtcbiAgICAgICAgICBpZFRva2VuLFxuICAgICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlLFxuICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcbiAgICAgICAgICBwYXNzd29yZDogdGhpcy5fcGFzc3dvcmRcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LOlxuICAgICAgICByZXR1cm4gc2lnbkluV2l0aEVtYWlsTGlua0ZvckxpbmtpbmcoYXV0aCwge1xuICAgICAgICAgIGlkVG9rZW4sXG4gICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxuICAgICAgICAgIG9vYkNvZGU6IHRoaXMuX3Bhc3N3b3JkXG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgX2ZhaWwoYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8SWRUb2tlblJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2dldElkVG9rZW5SZXNwb25zZShhdXRoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRW5kcG9pbnQsXG4gIEh0dHBNZXRob2QsXG4gIF9hZGRUaWRJZk5lY2Vzc2FyeSxcbiAgX3BlcmZvcm1TaWduSW5SZXF1ZXN0XG59IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IElkVG9rZW4sIElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IEF1dGggfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25JbldpdGhJZHBSZXF1ZXN0IHtcbiAgcmVxdWVzdFVyaTogc3RyaW5nO1xuICBwb3N0Qm9keT86IHN0cmluZztcbiAgc2Vzc2lvbklkPzogc3RyaW5nO1xuICB0ZW5hbnRJZD86IHN0cmluZztcbiAgcmV0dXJuU2VjdXJlVG9rZW46IGJvb2xlYW47XG4gIHJldHVybklkcENyZWRlbnRpYWw/OiBib29sZWFuO1xuICBpZFRva2VuPzogSWRUb2tlbjtcbiAgYXV0b0NyZWF0ZT86IGJvb2xlYW47XG4gIHBlbmRpbmdUb2tlbj86IHN0cmluZztcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaWduSW5XaXRoSWRwUmVzcG9uc2UgZXh0ZW5kcyBJZFRva2VuUmVzcG9uc2Uge1xuICBvYXV0aEFjY2Vzc1Rva2VuPzogc3RyaW5nO1xuICBvYXV0aFRva2VuU2VjcmV0Pzogc3RyaW5nO1xuICBub25jZT86IHN0cmluZztcbiAgb2F1dGhJZFRva2VuPzogc3RyaW5nO1xuICBwZW5kaW5nVG9rZW4/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoSWRwKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBTaWduSW5XaXRoSWRwUmVxdWVzdFxuKTogUHJvbWlzZTxTaWduSW5XaXRoSWRwUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdDxTaWduSW5XaXRoSWRwUmVxdWVzdCwgU2lnbkluV2l0aElkcFJlc3BvbnNlPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5TSUdOX0lOX1dJVEhfSURQLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgcXVlcnlzdHJpbmcgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmltcG9ydCB7XG4gIHNpZ25JbldpdGhJZHAsXG4gIFNpZ25JbldpdGhJZHBSZXF1ZXN0XG59IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9pZHAnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IF9mYWlsIH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuL2F1dGhfY3JlZGVudGlhbCc7XG5cbmNvbnN0IElEUF9SRVFVRVNUX1VSSSA9ICdodHRwOi8vbG9jYWxob3N0JztcblxuZXhwb3J0IGludGVyZmFjZSBPQXV0aENyZWRlbnRpYWxQYXJhbXMge1xuICAvLyBPQXV0aCAyIHVzZXMgZWl0aGVyIGlkIHRva2VuIG9yIGFjY2VzcyB0b2tlblxuICBpZFRva2VuPzogc3RyaW5nIHwgbnVsbDtcbiAgYWNjZXNzVG9rZW4/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8vIFRoZXNlIGZpZWxkcyBhcmUgdXNlZCB3aXRoIE9BdXRoIDFcbiAgb2F1dGhUb2tlbj86IHN0cmluZztcbiAgc2VjcmV0Pzogc3RyaW5nO1xuICBvYXV0aFRva2VuU2VjcmV0Pzogc3RyaW5nO1xuXG4gIC8vIE5vbmNlIGlzIG9ubHkgc2V0IGlmIHBlbmRpbmdUb2tlbiBpcyBub3QgcHJlc2VudFxuICBub25jZT86IHN0cmluZztcbiAgcGVuZGluZ1Rva2VuPzogc3RyaW5nO1xuXG4gIC8vIFV0aWxpdGllc1xuICBwcm92aWRlcklkOiBzdHJpbmc7XG4gIHNpZ25Jbk1ldGhvZDogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIE9BdXRoIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IGFuIHtAbGluayBPQXV0aFByb3ZpZGVyfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogSW1wbGVtZW50YXRpb25zIHNwZWNpZnkgdGhlIGRldGFpbHMgYWJvdXQgZWFjaCBhdXRoIHByb3ZpZGVyJ3MgY3JlZGVudGlhbCByZXF1aXJlbWVudHMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgT0F1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xuICAvKipcbiAgICogVGhlIE9BdXRoIElEIHRva2VuIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3JlZGVudGlhbCBpZiBpdCBiZWxvbmdzIHRvIGFuIE9JREMgcHJvdmlkZXIsXG4gICAqIHN1Y2ggYXMgYGdvb2dsZS5jb21gLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGlkVG9rZW4/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgT0F1dGggYWNjZXNzIHRva2VuIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3JlZGVudGlhbCBpZiBpdCBiZWxvbmdzIHRvIGFuXG4gICAqIHtAbGluayBPQXV0aFByb3ZpZGVyfSwgc3VjaCBhcyBgZmFjZWJvb2suY29tYCwgYHR3aXR0ZXIuY29tYCwgZXRjLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGFjY2Vzc1Rva2VuPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIE9BdXRoIGFjY2VzcyB0b2tlbiBzZWNyZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjcmVkZW50aWFsIGlmIGl0IGJlbG9uZ3MgdG8gYW4gT0F1dGggMS4wXG4gICAqIHByb3ZpZGVyLCBzdWNoIGFzIGB0d2l0dGVyLmNvbWAuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc2VjcmV0Pzogc3RyaW5nO1xuXG4gIHByaXZhdGUgbm9uY2U/OiBzdHJpbmc7XG4gIHByaXZhdGUgcGVuZGluZ1Rva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZnJvbVBhcmFtcyhwYXJhbXM6IE9BdXRoQ3JlZGVudGlhbFBhcmFtcyk6IE9BdXRoQ3JlZGVudGlhbCB7XG4gICAgY29uc3QgY3JlZCA9IG5ldyBPQXV0aENyZWRlbnRpYWwocGFyYW1zLnByb3ZpZGVySWQsIHBhcmFtcy5zaWduSW5NZXRob2QpO1xuXG4gICAgaWYgKHBhcmFtcy5pZFRva2VuIHx8IHBhcmFtcy5hY2Nlc3NUb2tlbikge1xuICAgICAgLy8gT0F1dGggMiBhbmQgZWl0aGVyIElEIHRva2VuIG9yIGFjY2VzcyB0b2tlbi5cbiAgICAgIGlmIChwYXJhbXMuaWRUb2tlbikge1xuICAgICAgICBjcmVkLmlkVG9rZW4gPSBwYXJhbXMuaWRUb2tlbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcGFyYW1zLmFjY2Vzc1Rva2VuO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgbm9uY2UgaWYgYXZhaWxhYmxlIGFuZCBubyBwZW5kaW5nVG9rZW4gaXMgcHJlc2VudC5cbiAgICAgIGlmIChwYXJhbXMubm9uY2UgJiYgIXBhcmFtcy5wZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgY3JlZC5ub25jZSA9IHBhcmFtcy5ub25jZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5wZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgY3JlZC5wZW5kaW5nVG9rZW4gPSBwYXJhbXMucGVuZGluZ1Rva2VuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1zLm9hdXRoVG9rZW4gJiYgcGFyYW1zLm9hdXRoVG9rZW5TZWNyZXQpIHtcbiAgICAgIC8vIE9BdXRoIDEgYW5kIE9BdXRoIHRva2VuIHdpdGggdG9rZW4gc2VjcmV0XG4gICAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcGFyYW1zLm9hdXRoVG9rZW47XG4gICAgICBjcmVkLnNlY3JldCA9IHBhcmFtcy5vYXV0aFRva2VuU2VjcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICBfZmFpbChBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlZDtcbiAgfVxuXG4gIC8qKiB7QGluaGVyaXRkb2MgQXV0aENyZWRlbnRpYWwudG9KU09OfSAgKi9cbiAgdG9KU09OKCk6IG9iamVjdCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkVG9rZW46IHRoaXMuaWRUb2tlbixcbiAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgICAgc2VjcmV0OiB0aGlzLnNlY3JldCxcbiAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlbixcbiAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCxcbiAgICAgIHNpZ25Jbk1ldGhvZDogdGhpcy5zaWduSW5NZXRob2RcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgdG8gZGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbnRvIGFuXG4gICAqIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LlxuICAgKlxuICAgKiBAcGFyYW0ganNvbiAtIElucHV0IGNhbiBiZSBlaXRoZXIgT2JqZWN0IG9yIHRoZSBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgKiBXaGVuIHN0cmluZyBpcyBwcm92aWRlZCwgSlNPTi5wYXJzZSB3b3VsZCBiZSBjYWxsZWQgZmlyc3QuXG4gICAqXG4gICAqIEByZXR1cm5zIElmIHRoZSBKU09OIGlucHV0IGRvZXMgbm90IHJlcHJlc2VudCBhbiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfSwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICovXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uOiBzdHJpbmcgfCBvYmplY3QpOiBPQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbiAgICBjb25zdCB7IHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCwgLi4ucmVzdCB9OiBPQXV0aENyZWRlbnRpYWxQYXJhbXMgPSBvYmo7XG4gICAgaWYgKCFwcm92aWRlcklkIHx8ICFzaWduSW5NZXRob2QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGNyZWQgPSBuZXcgT0F1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCk7XG4gICAgY3JlZC5pZFRva2VuID0gcmVzdC5pZFRva2VuIHx8IHVuZGVmaW5lZDtcbiAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcmVzdC5hY2Nlc3NUb2tlbiB8fCB1bmRlZmluZWQ7XG4gICAgY3JlZC5zZWNyZXQgPSByZXN0LnNlY3JldDtcbiAgICBjcmVkLm5vbmNlID0gcmVzdC5ub25jZTtcbiAgICBjcmVkLnBlbmRpbmdUb2tlbiA9IHJlc3QucGVuZGluZ1Rva2VuIHx8IG51bGw7XG4gICAgcmV0dXJuIGNyZWQ7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxJZFRva2VuUmVzcG9uc2U+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcbiAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2xpbmtUb0lkVG9rZW4oXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGlkVG9rZW46IHN0cmluZ1xuICApOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgIHJlcXVlc3QuaWRUb2tlbiA9IGlkVG9rZW47XG4gICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxJZFRva2VuUmVzcG9uc2U+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0LmF1dG9DcmVhdGUgPSBmYWxzZTtcbiAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRSZXF1ZXN0KCk6IFNpZ25JbldpdGhJZHBSZXF1ZXN0IHtcbiAgICBjb25zdCByZXF1ZXN0OiBTaWduSW5XaXRoSWRwUmVxdWVzdCA9IHtcbiAgICAgIHJlcXVlc3RVcmk6IElEUF9SRVFVRVNUX1VSSSxcbiAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnBlbmRpbmdUb2tlbikge1xuICAgICAgcmVxdWVzdC5wZW5kaW5nVG9rZW4gPSB0aGlzLnBlbmRpbmdUb2tlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcG9zdEJvZHk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICAgIGlmICh0aGlzLmlkVG9rZW4pIHtcbiAgICAgICAgcG9zdEJvZHlbJ2lkX3Rva2VuJ10gPSB0aGlzLmlkVG9rZW47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICBwb3N0Qm9keVsnYWNjZXNzX3Rva2VuJ10gPSB0aGlzLmFjY2Vzc1Rva2VuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VjcmV0KSB7XG4gICAgICAgIHBvc3RCb2R5WydvYXV0aF90b2tlbl9zZWNyZXQnXSA9IHRoaXMuc2VjcmV0O1xuICAgICAgfVxuXG4gICAgICBwb3N0Qm9keVsncHJvdmlkZXJJZCddID0gdGhpcy5wcm92aWRlcklkO1xuICAgICAgaWYgKHRoaXMubm9uY2UgJiYgIXRoaXMucGVuZGluZ1Rva2VuKSB7XG4gICAgICAgIHBvc3RCb2R5Wydub25jZSddID0gdGhpcy5ub25jZTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5wb3N0Qm9keSA9IHF1ZXJ5c3RyaW5nKHBvc3RCb2R5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRW5kcG9pbnQsXG4gIEh0dHBNZXRob2QsXG4gIF9hZGRUaWRJZk5lY2Vzc2FyeSxcbiAgX21ha2VUYWdnZWRFcnJvcixcbiAgX3BlcmZvcm1BcGlSZXF1ZXN0LFxuICBfcGVyZm9ybVNpZ25JblJlcXVlc3Rcbn0gZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzJztcbmltcG9ydCB7IElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IFNlcnZlckVycm9yLCBTZXJ2ZXJFcnJvck1hcCB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBTZW5kUGhvbmVWZXJpZmljYXRpb25Db2RlUmVxdWVzdCB7XG4gIHBob25lTnVtYmVyOiBzdHJpbmc7XG4gIHJlY2FwdGNoYVRva2VuOiBzdHJpbmc7XG4gIHRlbmFudElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbmRQaG9uZVZlcmlmaWNhdGlvbkNvZGVSZXNwb25zZSB7XG4gIHNlc3Npb25JbmZvOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kUGhvbmVWZXJpZmljYXRpb25Db2RlKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBTZW5kUGhvbmVWZXJpZmljYXRpb25Db2RlUmVxdWVzdFxuKTogUHJvbWlzZTxTZW5kUGhvbmVWZXJpZmljYXRpb25Db2RlUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxcbiAgICBTZW5kUGhvbmVWZXJpZmljYXRpb25Db2RlUmVxdWVzdCxcbiAgICBTZW5kUGhvbmVWZXJpZmljYXRpb25Db2RlUmVzcG9uc2VcbiAgPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5TRU5EX1ZFUklGSUNBVElPTl9DT0RFLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25JbldpdGhQaG9uZU51bWJlclJlcXVlc3Qge1xuICB0ZW1wb3JhcnlQcm9vZj86IHN0cmluZztcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG4gIHNlc3Npb25JbmZvPzogc3RyaW5nO1xuICBjb2RlPzogc3RyaW5nO1xuICB0ZW5hbnRJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaW5rV2l0aFBob25lTnVtYmVyUmVxdWVzdFxuICBleHRlbmRzIFNpZ25JbldpdGhQaG9uZU51bWJlclJlcXVlc3Qge1xuICBpZFRva2VuOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbkluV2l0aFBob25lTnVtYmVyUmVzcG9uc2UgZXh0ZW5kcyBJZFRva2VuUmVzcG9uc2Uge1xuICB0ZW1wb3JhcnlQcm9vZj86IHN0cmluZztcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGhvbmVOdW1iZXIoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFNpZ25JbldpdGhQaG9uZU51bWJlclJlcXVlc3Rcbik6IFByb21pc2U8U2lnbkluV2l0aFBob25lTnVtYmVyUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdDxcbiAgICBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXF1ZXN0LFxuICAgIFNpZ25JbldpdGhQaG9uZU51bWJlclJlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BIT05FX05VTUJFUixcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpbmtXaXRoUGhvbmVOdW1iZXIoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IExpbmtXaXRoUGhvbmVOdW1iZXJSZXF1ZXN0XG4pOiBQcm9taXNlPFNpZ25JbldpdGhQaG9uZU51bWJlclJlc3BvbnNlPiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3BlcmZvcm1TaWduSW5SZXF1ZXN0PFxuICAgIExpbmtXaXRoUGhvbmVOdW1iZXJSZXF1ZXN0LFxuICAgIFNpZ25JbldpdGhQaG9uZU51bWJlclJlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BIT05FX05VTUJFUixcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbiAgaWYgKHJlc3BvbnNlLnRlbXBvcmFyeVByb29mKSB7XG4gICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OLCByZXNwb25zZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG5pbnRlcmZhY2UgVmVyaWZ5UGhvbmVOdW1iZXJGb3JFeGlzdGluZ1JlcXVlc3RcbiAgZXh0ZW5kcyBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXF1ZXN0IHtcbiAgb3BlcmF0aW9uOiAnUkVBVVRIJztcbn1cblxuY29uc3QgVkVSSUZZX1BIT05FX05VTUJFUl9GT1JfRVhJU1RJTkdfRVJST1JfTUFQXzogUGFydGlhbDxcbiAgU2VydmVyRXJyb3JNYXA8U2VydmVyRXJyb3I+XG4+ID0ge1xuICBbU2VydmVyRXJyb3IuVVNFUl9OT1RfRk9VTkRdOiBBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRFxufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmcoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFNpZ25JbldpdGhQaG9uZU51bWJlclJlcXVlc3Rcbik6IFByb21pc2U8U2lnbkluV2l0aFBob25lTnVtYmVyUmVzcG9uc2U+IHtcbiAgY29uc3QgYXBpUmVxdWVzdDogVmVyaWZ5UGhvbmVOdW1iZXJGb3JFeGlzdGluZ1JlcXVlc3QgPSB7XG4gICAgLi4ucmVxdWVzdCxcbiAgICBvcGVyYXRpb246ICdSRUFVVEgnXG4gIH07XG4gIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3Q8XG4gICAgVmVyaWZ5UGhvbmVOdW1iZXJGb3JFeGlzdGluZ1JlcXVlc3QsXG4gICAgU2lnbkluV2l0aFBob25lTnVtYmVyUmVzcG9uc2VcbiAgPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5TSUdOX0lOX1dJVEhfUEhPTkVfTlVNQkVSLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCBhcGlSZXF1ZXN0KSxcbiAgICBWRVJJRllfUEhPTkVfTlVNQkVSX0ZPUl9FWElTVElOR19FUlJPUl9NQVBfXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQcm92aWRlcklkLCBTaWduSW5NZXRob2QgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbmltcG9ydCB7IFBob25lT3JPYXV0aFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vbWZhJztcbmltcG9ydCB7XG4gIGxpbmtXaXRoUGhvbmVOdW1iZXIsXG4gIHNpZ25JbldpdGhQaG9uZU51bWJlcixcbiAgU2lnbkluV2l0aFBob25lTnVtYmVyUmVxdWVzdCxcbiAgdmVyaWZ5UGhvbmVOdW1iZXJGb3JFeGlzdGluZ1xufSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vc21zJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuL2F1dGhfY3JlZGVudGlhbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGhvbmVBdXRoQ3JlZGVudGlhbFBhcmFtZXRlcnMge1xuICB2ZXJpZmljYXRpb25JZD86IHN0cmluZztcbiAgdmVyaWZpY2F0aW9uQ29kZT86IHN0cmluZztcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG4gIHRlbXBvcmFyeVByb29mPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IHtAbGluayBQaG9uZUF1dGhQcm92aWRlcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUGhvbmVBdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHBhcmFtczogUGhvbmVBdXRoQ3JlZGVudGlhbFBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihQcm92aWRlcklkLlBIT05FLCBTaWduSW5NZXRob2QuUEhPTkUpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21WZXJpZmljYXRpb24oXG4gICAgdmVyaWZpY2F0aW9uSWQ6IHN0cmluZyxcbiAgICB2ZXJpZmljYXRpb25Db2RlOiBzdHJpbmdcbiAgKTogUGhvbmVBdXRoQ3JlZGVudGlhbCB7XG4gICAgcmV0dXJuIG5ldyBQaG9uZUF1dGhDcmVkZW50aWFsKHsgdmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUgfSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZnJvbVRva2VuUmVzcG9uc2UoXG4gICAgcGhvbmVOdW1iZXI6IHN0cmluZyxcbiAgICB0ZW1wb3JhcnlQcm9vZjogc3RyaW5nXG4gICk6IFBob25lQXV0aENyZWRlbnRpYWwge1xuICAgIHJldHVybiBuZXcgUGhvbmVBdXRoQ3JlZGVudGlhbCh7IHBob25lTnVtYmVyLCB0ZW1wb3JhcnlQcm9vZiB9KTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoOiBBdXRoSW50ZXJuYWwpOiBQcm9taXNlPFBob25lT3JPYXV0aFRva2VuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gc2lnbkluV2l0aFBob25lTnVtYmVyKGF1dGgsIHRoaXMuX21ha2VWZXJpZmljYXRpb25SZXF1ZXN0KCkpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfbGlua1RvSWRUb2tlbihcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgaWRUb2tlbjogc3RyaW5nXG4gICk6IFByb21pc2U8SWRUb2tlblJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGxpbmtXaXRoUGhvbmVOdW1iZXIoYXV0aCwge1xuICAgICAgaWRUb2tlbixcbiAgICAgIC4uLnRoaXMuX21ha2VWZXJpZmljYXRpb25SZXF1ZXN0KClcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoOiBBdXRoSW50ZXJuYWwpOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT4ge1xuICAgIHJldHVybiB2ZXJpZnlQaG9uZU51bWJlckZvckV4aXN0aW5nKGF1dGgsIHRoaXMuX21ha2VWZXJpZmljYXRpb25SZXF1ZXN0KCkpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKTogU2lnbkluV2l0aFBob25lTnVtYmVyUmVxdWVzdCB7XG4gICAgY29uc3QgeyB0ZW1wb3JhcnlQcm9vZiwgcGhvbmVOdW1iZXIsIHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlIH0gPVxuICAgICAgdGhpcy5wYXJhbXM7XG4gICAgaWYgKHRlbXBvcmFyeVByb29mICYmIHBob25lTnVtYmVyKSB7XG4gICAgICByZXR1cm4geyB0ZW1wb3JhcnlQcm9vZiwgcGhvbmVOdW1iZXIgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2Vzc2lvbkluZm86IHZlcmlmaWNhdGlvbklkLFxuICAgICAgY29kZTogdmVyaWZpY2F0aW9uQ29kZVxuICAgIH07XG4gIH1cblxuICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gKi9cbiAgdG9KU09OKCk6IG9iamVjdCB7XG4gICAgY29uc3Qgb2JqOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkXG4gICAgfTtcbiAgICBpZiAodGhpcy5wYXJhbXMucGhvbmVOdW1iZXIpIHtcbiAgICAgIG9iai5waG9uZU51bWJlciA9IHRoaXMucGFyYW1zLnBob25lTnVtYmVyO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJhbXMudGVtcG9yYXJ5UHJvb2YpIHtcbiAgICAgIG9iai50ZW1wb3JhcnlQcm9vZiA9IHRoaXMucGFyYW1zLnRlbXBvcmFyeVByb29mO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJhbXMudmVyaWZpY2F0aW9uQ29kZSkge1xuICAgICAgb2JqLnZlcmlmaWNhdGlvbkNvZGUgPSB0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25Db2RlO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJhbXMudmVyaWZpY2F0aW9uSWQpIHtcbiAgICAgIG9iai52ZXJpZmljYXRpb25JZCA9IHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbklkO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKiogR2VuZXJhdGVzIGEgcGhvbmUgY3JlZGVudGlhbCBiYXNlZCBvbiBhIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nLiAqL1xuICBzdGF0aWMgZnJvbUpTT04oanNvbjogb2JqZWN0IHwgc3RyaW5nKTogUGhvbmVBdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIH1cblxuICAgIGNvbnN0IHsgdmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUsIHBob25lTnVtYmVyLCB0ZW1wb3JhcnlQcm9vZiB9ID1cbiAgICAgIGpzb24gYXMgeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgICBpZiAoXG4gICAgICAhdmVyaWZpY2F0aW9uQ29kZSAmJlxuICAgICAgIXZlcmlmaWNhdGlvbklkICYmXG4gICAgICAhcGhvbmVOdW1iZXIgJiZcbiAgICAgICF0ZW1wb3JhcnlQcm9vZlxuICAgICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQaG9uZUF1dGhDcmVkZW50aWFsKHtcbiAgICAgIHZlcmlmaWNhdGlvbklkLFxuICAgICAgdmVyaWZpY2F0aW9uQ29kZSxcbiAgICAgIHBob25lTnVtYmVyLFxuICAgICAgdGVtcG9yYXJ5UHJvb2ZcbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgZXh0cmFjdFF1ZXJ5c3RyaW5nLCBxdWVyeXN0cmluZ0RlY29kZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IEFjdGlvbkNvZGVPcGVyYXRpb24gfSBmcm9tICcuLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuL3V0aWwvYXNzZXJ0JztcblxuLyoqXG4gKiBFbnVtcyBmb3IgZmllbGRzIGluIFVSTCBxdWVyeSBzdHJpbmcuXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgZW51bSBRdWVyeUZpZWxkIHtcbiAgQVBJX0tFWSA9ICdhcGlLZXknLFxuICBDT0RFID0gJ29vYkNvZGUnLFxuICBDT05USU5VRV9VUkwgPSAnY29udGludWVVcmwnLFxuICBMQU5HVUFHRV9DT0RFID0gJ2xhbmd1YWdlQ29kZScsXG4gIE1PREUgPSAnbW9kZScsXG4gIFRFTkFOVF9JRCA9ICd0ZW5hbnRJZCdcbn1cblxuLyoqXG4gKiBNYXBzIHRoZSBtb2RlIHN0cmluZyBpbiBhY3Rpb24gY29kZSBVUkwgdG8gQWN0aW9uIENvZGUgSW5mbyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIG1vZGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VNb2RlKG1vZGU6IHN0cmluZyB8IG51bGwpOiBBY3Rpb25Db2RlT3BlcmF0aW9uIHwgbnVsbCB7XG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ3JlY292ZXJFbWFpbCc6XG4gICAgICByZXR1cm4gQWN0aW9uQ29kZU9wZXJhdGlvbi5SRUNPVkVSX0VNQUlMO1xuICAgIGNhc2UgJ3Jlc2V0UGFzc3dvcmQnOlxuICAgICAgcmV0dXJuIEFjdGlvbkNvZGVPcGVyYXRpb24uUEFTU1dPUkRfUkVTRVQ7XG4gICAgY2FzZSAnc2lnbkluJzpcbiAgICAgIHJldHVybiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTjtcbiAgICBjYXNlICd2ZXJpZnlFbWFpbCc6XG4gICAgICByZXR1cm4gQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfRU1BSUw7XG4gICAgY2FzZSAndmVyaWZ5QW5kQ2hhbmdlRW1haWwnOlxuICAgICAgcmV0dXJuIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUw7XG4gICAgY2FzZSAncmV2ZXJ0U2Vjb25kRmFjdG9yQWRkaXRpb24nOlxuICAgICAgcmV0dXJuIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT047XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHRvIHBhcnNlIEZETCBsaW5rc1xuICpcbiAqIEBwYXJhbSB1cmxcbiAqL1xuZnVuY3Rpb24gcGFyc2VEZWVwTGluayh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGxpbmsgPSBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcodXJsKSlbJ2xpbmsnXTtcblxuICAvLyBEb3VibGUgbGluayBjYXNlIChhdXRvbWF0aWMgcmVkaXJlY3QpLlxuICBjb25zdCBkb3VibGVEZWVwTGluayA9IGxpbmtcbiAgICA/IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyhsaW5rKSlbJ2RlZXBfbGlua19pZCddXG4gICAgOiBudWxsO1xuICAvLyBpT1MgY3VzdG9tIHNjaGVtZSBsaW5rcy5cbiAgY29uc3QgaU9TRGVlcExpbmsgPSBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcodXJsKSlbXG4gICAgJ2RlZXBfbGlua19pZCdcbiAgXTtcbiAgY29uc3QgaU9TRG91YmxlRGVlcExpbmsgPSBpT1NEZWVwTGlua1xuICAgID8gcXVlcnlzdHJpbmdEZWNvZGUoZXh0cmFjdFF1ZXJ5c3RyaW5nKGlPU0RlZXBMaW5rKSlbJ2xpbmsnXVxuICAgIDogbnVsbDtcbiAgcmV0dXJuIGlPU0RvdWJsZURlZXBMaW5rIHx8IGlPU0RlZXBMaW5rIHx8IGRvdWJsZURlZXBMaW5rIHx8IGxpbmsgfHwgdXJsO1xufVxuXG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBwYXJzZSBlbWFpbCBhY3Rpb24gVVJMcyBzdWNoIGFzIHBhc3N3b3JkIHJlc2V0LCBlbWFpbCB2ZXJpZmljYXRpb24sXG4gKiBlbWFpbCBsaW5rIHNpZ24gaW4sIGV0Yy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3Rpb25Db2RlVVJMIHtcbiAgLyoqXG4gICAqIFRoZSBBUEkga2V5IG9mIHRoZSBlbWFpbCBhY3Rpb24gbGluay5cbiAgICovXG4gIHJlYWRvbmx5IGFwaUtleTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGFjdGlvbiBjb2RlIG9mIHRoZSBlbWFpbCBhY3Rpb24gbGluay5cbiAgICovXG4gIHJlYWRvbmx5IGNvZGU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBjb250aW51ZSBVUkwgb2YgdGhlIGVtYWlsIGFjdGlvbiBsaW5rLiBOdWxsIGlmIG5vdCBwcm92aWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGNvbnRpbnVlVXJsOiBzdHJpbmcgfCBudWxsO1xuICAvKipcbiAgICogVGhlIGxhbmd1YWdlIGNvZGUgb2YgdGhlIGVtYWlsIGFjdGlvbiBsaW5rLiBOdWxsIGlmIG5vdCBwcm92aWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGxhbmd1YWdlQ29kZTogc3RyaW5nIHwgbnVsbDtcbiAgLyoqXG4gICAqIFRoZSBhY3Rpb24gcGVyZm9ybWVkIGJ5IHRoZSBlbWFpbCBhY3Rpb24gbGluay4gSXQgcmV0dXJucyBmcm9tIG9uZSBvZiB0aGUgdHlwZXMgZnJvbVxuICAgKiB7QGxpbmsgQWN0aW9uQ29kZUluZm99XG4gICAqL1xuICByZWFkb25seSBvcGVyYXRpb246IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0ZW5hbnQgSUQgb2YgdGhlIGVtYWlsIGFjdGlvbiBsaW5rLiBOdWxsIGlmIHRoZSBlbWFpbCBhY3Rpb24gaXMgZnJvbSB0aGUgcGFyZW50IHByb2plY3QuXG4gICAqL1xuICByZWFkb25seSB0ZW5hbnRJZDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogQHBhcmFtIGFjdGlvbkxpbmsgLSBUaGUgbGluayBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIFVSTC5cbiAgICogQHJldHVybnMgVGhlIHtAbGluayBBY3Rpb25Db2RlVVJMfSBvYmplY3QsIG9yIG51bGwgaWYgdGhlIGxpbmsgaXMgaW52YWxpZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhY3Rpb25MaW5rOiBzdHJpbmcpIHtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcoYWN0aW9uTGluaykpO1xuICAgIGNvbnN0IGFwaUtleSA9IHNlYXJjaFBhcmFtc1tRdWVyeUZpZWxkLkFQSV9LRVldID8/IG51bGw7XG4gICAgY29uc3QgY29kZSA9IHNlYXJjaFBhcmFtc1tRdWVyeUZpZWxkLkNPREVdID8/IG51bGw7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyc2VNb2RlKHNlYXJjaFBhcmFtc1tRdWVyeUZpZWxkLk1PREVdID8/IG51bGwpO1xuICAgIC8vIFZhbGlkYXRlIEFQSSBrZXksIGNvZGUgYW5kIG1vZGUuXG4gICAgX2Fzc2VydChhcGlLZXkgJiYgY29kZSAmJiBvcGVyYXRpb24sIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IpO1xuICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgIHRoaXMub3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5jb250aW51ZVVybCA9IHNlYXJjaFBhcmFtc1tRdWVyeUZpZWxkLkNPTlRJTlVFX1VSTF0gPz8gbnVsbDtcbiAgICB0aGlzLmxhbmd1YWdlQ29kZSA9IHNlYXJjaFBhcmFtc1tRdWVyeUZpZWxkLkxBTkdVQUdFX0NPREVdID8/IG51bGw7XG4gICAgdGhpcy50ZW5hbnRJZCA9IHNlYXJjaFBhcmFtc1tRdWVyeUZpZWxkLlRFTkFOVF9JRF0gPz8gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGVtYWlsIGFjdGlvbiBsaW5rIHN0cmluZyBhbmQgcmV0dXJucyBhbiB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gaWYgdGhlIGxpbmsgaXMgdmFsaWQsXG4gICAqIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXG4gICAqXG4gICAqIEBwYXJhbSBsaW5rICAtIFRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcuXG4gICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gb2JqZWN0LCBvciBudWxsIGlmIHRoZSBsaW5rIGlzIGludmFsaWQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBwYXJzZUxpbmsobGluazogc3RyaW5nKTogQWN0aW9uQ29kZVVSTCB8IG51bGwge1xuICAgIGNvbnN0IGFjdGlvbkxpbmsgPSBwYXJzZURlZXBMaW5rKGxpbmspO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFjdGlvbkNvZGVVUkwoYWN0aW9uTGluayk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGVtYWlsIGFjdGlvbiBsaW5rIHN0cmluZyBhbmQgcmV0dXJucyBhbiB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gaWZcbiAqIHRoZSBsaW5rIGlzIHZhbGlkLCBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQWN0aW9uQ29kZVVSTChsaW5rOiBzdHJpbmcpOiBBY3Rpb25Db2RlVVJMIHwgbnVsbCB7XG4gIHJldHVybiBBY3Rpb25Db2RlVVJMLnBhcnNlTGluayhsaW5rKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFByb3ZpZGVySWQsIFNpZ25Jbk1ldGhvZCB9IGZyb20gJy4uLy4uL21vZGVsL2VudW1zJztcbmltcG9ydCB7IEF1dGhQcm92aWRlciB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IEFjdGlvbkNvZGVVUkwgfSBmcm9tICcuLi9hY3Rpb25fY29kZV91cmwnO1xuaW1wb3J0IHsgRW1haWxBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uL2NyZWRlbnRpYWxzL2VtYWlsJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcblxuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyB7QGxpbmsgRW1haWxBdXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgRW1haWxBdXRoUHJvdmlkZXIgaW1wbGVtZW50cyBBdXRoUHJvdmlkZXIge1xuICAvKipcbiAgICogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uUEFTU1dPUkQsIGV2ZW4gZm9yIGVtYWlsIGxpbmsuXG4gICAqL1xuICBzdGF0aWMgcmVhZG9ubHkgUFJPVklERVJfSUQ6ICdwYXNzd29yZCcgPSBQcm92aWRlcklkLlBBU1NXT1JEO1xuICAvKipcbiAgICogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9QQVNTV09SRC5cbiAgICovXG4gIHN0YXRpYyByZWFkb25seSBFTUFJTF9QQVNTV09SRF9TSUdOX0lOX01FVEhPRDogJ3Bhc3N3b3JkJyA9XG4gICAgU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEO1xuICAvKipcbiAgICogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLlxuICAgKi9cbiAgc3RhdGljIHJlYWRvbmx5IEVNQUlMX0xJTktfU0lHTl9JTl9NRVRIT0Q6ICdlbWFpbExpbmsnID1cbiAgICBTaWduSW5NZXRob2QuRU1BSUxfTElOSztcbiAgLyoqXG4gICAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LlBBU1NXT1JELCBldmVuIGZvciBlbWFpbCBsaW5rLlxuICAgKi9cbiAgcmVhZG9ubHkgcHJvdmlkZXJJZCA9IEVtYWlsQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gdXNpbmcgYW4gZW1haWwgYW5kIHBhc3N3b3JkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGF1dGhDcmVkZW50aWFsID0gRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQpO1xuICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGF1dGhDcmVkZW50aWFsKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGVtYWlsIC0gRW1haWwgYWRkcmVzcy5cbiAgICogQHBhcmFtIHBhc3N3b3JkIC0gVXNlciBhY2NvdW50IHBhc3N3b3JkLlxuICAgKiBAcmV0dXJucyBUaGUgYXV0aCBwcm92aWRlciBjcmVkZW50aWFsLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWwoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IEVtYWlsQXV0aENyZWRlbnRpYWwge1xuICAgIHJldHVybiBFbWFpbEF1dGhDcmVkZW50aWFsLl9mcm9tRW1haWxBbmRQYXNzd29yZChlbWFpbCwgcGFzc3dvcmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSB1c2luZyBhbiBlbWFpbCBhbmQgYW4gZW1haWwgbGluayBhZnRlciBhIHNpZ24gaW4gd2l0aFxuICAgKiBlbWFpbCBsaW5rIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBhdXRoQ3JlZGVudGlhbCA9IEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxXaXRoTGluayhhdXRoLCBlbWFpbCwgZW1haWxMaW5rKTtcbiAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBhdXRoQ3JlZGVudGlhbCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCBlbWFpbCk7XG4gICAqIC8vIE9idGFpbiBlbWFpbExpbmsgZnJvbSB1c2VyLlxuICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWwsIGVtYWlsTGluayk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgdXNlZCB0byB2ZXJpZnkgdGhlIGxpbmsuXG4gICAqIEBwYXJhbSBlbWFpbCAtIEVtYWlsIGFkZHJlc3MuXG4gICAqIEBwYXJhbSBlbWFpbExpbmsgLSBTaWduLWluIGVtYWlsIGxpbmsuXG4gICAqIEByZXR1cm5zIC0gVGhlIGF1dGggcHJvdmlkZXIgY3JlZGVudGlhbC5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsV2l0aExpbmsoXG4gICAgZW1haWw6IHN0cmluZyxcbiAgICBlbWFpbExpbms6IHN0cmluZ1xuICApOiBFbWFpbEF1dGhDcmVkZW50aWFsIHtcbiAgICBjb25zdCBhY3Rpb25Db2RlVXJsID0gQWN0aW9uQ29kZVVSTC5wYXJzZUxpbmsoZW1haWxMaW5rKTtcbiAgICBfYXNzZXJ0KGFjdGlvbkNvZGVVcmwsIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IpO1xuXG4gICAgcmV0dXJuIEVtYWlsQXV0aENyZWRlbnRpYWwuX2Zyb21FbWFpbEFuZENvZGUoXG4gICAgICBlbWFpbCxcbiAgICAgIGFjdGlvbkNvZGVVcmwuY29kZSxcbiAgICAgIGFjdGlvbkNvZGVVcmwudGVuYW50SWRcbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG4vKipcbiAqIE1hcCBvZiBPQXV0aCBDdXN0b20gUGFyYW1ldGVycy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEN1c3RvbVBhcmFtZXRlcnMgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgRmVkZXJhdGVkIHByb3ZpZGVycyAoT0F1dGggKGluY2x1ZGluZyBPSURDKSwgU0FNTCkuXG4gKlxuICogVGhpcyBjbGFzcyBpcyBub3QgbWVhbnQgdG8gYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZlZGVyYXRlZEF1dGhQcm92aWRlciBpbXBsZW1lbnRzIEF1dGhQcm92aWRlciB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZGVmYXVsdExhbmd1YWdlQ29kZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBjdXN0b21QYXJhbWV0ZXJzOiBDdXN0b21QYXJhbWV0ZXJzID0ge307XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZvciBnZW5lcmljIE9BdXRoIHByb3ZpZGVycy5cbiAgICpcbiAgICogQHBhcmFtIHByb3ZpZGVySWQgLSBQcm92aWRlciBmb3Igd2hpY2ggY3JlZGVudGlhbHMgc2hvdWxkIGJlIGdlbmVyYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHByb3ZpZGVySWQ6IHN0cmluZykge31cblxuICAvKipcbiAgICogU2V0IHRoZSBsYW5ndWFnZSBnb2RlLlxuICAgKlxuICAgKiBAcGFyYW0gbGFuZ3VhZ2VDb2RlIC0gbGFuZ3VhZ2UgY29kZVxuICAgKi9cbiAgc2V0RGVmYXVsdExhbmd1YWdlKGxhbmd1YWdlQ29kZTogc3RyaW5nIHwgbnVsbCk6IHZvaWQge1xuICAgIHRoaXMuZGVmYXVsdExhbmd1YWdlQ29kZSA9IGxhbmd1YWdlQ29kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBPQXV0aCBjdXN0b20gcGFyYW1ldGVycyB0byBwYXNzIGluIGFuIE9BdXRoIHJlcXVlc3QgZm9yIHBvcHVwIGFuZCByZWRpcmVjdCBzaWduLWluXG4gICAqIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEZvciBhIGRldGFpbGVkIGxpc3QsIGNoZWNrIHRoZSByZXNlcnZlZCByZXF1aXJlZCBPQXV0aCAyLjAgcGFyYW1ldGVycyBzdWNoIGFzIGBjbGllbnRfaWRgLFxuICAgKiBgcmVkaXJlY3RfdXJpYCwgYHNjb3BlYCwgYHJlc3BvbnNlX3R5cGVgLCBhbmQgYHN0YXRlYCBhcmUgbm90IGFsbG93ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC5cbiAgICpcbiAgICogQHBhcmFtIGN1c3RvbU9BdXRoUGFyYW1ldGVycyAtIFRoZSBjdXN0b20gT0F1dGggcGFyYW1ldGVycyB0byBwYXNzIGluIHRoZSBPQXV0aCByZXF1ZXN0LlxuICAgKi9cbiAgc2V0Q3VzdG9tUGFyYW1ldGVycyhjdXN0b21PQXV0aFBhcmFtZXRlcnM6IEN1c3RvbVBhcmFtZXRlcnMpOiBBdXRoUHJvdmlkZXIge1xuICAgIHRoaXMuY3VzdG9tUGFyYW1ldGVycyA9IGN1c3RvbU9BdXRoUGFyYW1ldGVycztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBDdXN0b21QYXJhbWV0ZXJzfS5cbiAgICovXG4gIGdldEN1c3RvbVBhcmFtZXRlcnMoKTogQ3VzdG9tUGFyYW1ldGVycyB7XG4gICAgcmV0dXJuIHRoaXMuY3VzdG9tUGFyYW1ldGVycztcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aFByb3ZpZGVyLCBVc2VyQ3JlZGVudGlhbCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuaW1wb3J0IHsgT0F1dGhDcmVkZW50aWFsLCBPQXV0aENyZWRlbnRpYWxQYXJhbXMgfSBmcm9tICcuLi9jcmVkZW50aWFscy9vYXV0aCc7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBTaWduSW5XaXRoSWRwUmVzcG9uc2UgfSBmcm9tICcuLi8uLi8uLi9pbnRlcm5hbCc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIgfSBmcm9tICcuL2ZlZGVyYXRlZCc7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBGb3IgSUQgdG9rZW5zIHdpdGggbm9uY2UgY2xhaW0sIHRoZSByYXcgbm9uY2UgaGFzIHRvIGFsc28gYmUgcHJvdmlkZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE9BdXRoQ3JlZGVudGlhbE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIE9BdXRoIElEIHRva2VuIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0uXG4gICAqL1xuICBpZFRva2VuPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIE9BdXRoIGFjY2VzcyB0b2tlbiB1c2VkIHRvIGluaXRpYWxpemUgdGhlIHtAbGluayBPQXV0aENyZWRlbnRpYWx9LlxuICAgKi9cbiAgYWNjZXNzVG9rZW4/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcmF3IG5vbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgSUQgdG9rZW4uXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEl0IGlzIHJlcXVpcmVkIHdoZW4gYW4gSUQgdG9rZW4gd2l0aCBhIG5vbmNlIGZpZWxkIGlzIHByb3ZpZGVkLiBUaGUgU0hBLTI1NiBoYXNoIG9mIHRoZVxuICAgKiByYXcgbm9uY2UgbXVzdCBtYXRjaCB0aGUgbm9uY2UgZmllbGQgaW4gdGhlIElEIHRva2VuLlxuICAgKi9cbiAgcmF3Tm9uY2U/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ29tbW9uIGNvZGUgdG8gYWxsIE9BdXRoIHByb3ZpZGVycy4gVGhpcyBpcyBzZXBhcmF0ZSBmcm9tIHRoZVxuICoge0BsaW5rIE9BdXRoUHJvdmlkZXJ9IHNvIHRoYXQgY2hpbGQgcHJvdmlkZXJzIChsaWtlXG4gKiB7QGxpbmsgR29vZ2xlQXV0aFByb3ZpZGVyfSkgZG9uJ3QgaW5oZXJpdCB0aGUgYGNyZWRlbnRpYWxgIGluc3RhbmNlIG1ldGhvZC5cbiAqIEluc3RlYWQsIHRoZXkgcmVseSBvbiBhIHN0YXRpYyBgY3JlZGVudGlhbGAgbWV0aG9kLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZU9BdXRoUHJvdmlkZXJcbiAgZXh0ZW5kcyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXJcbiAgaW1wbGVtZW50cyBBdXRoUHJvdmlkZXJcbntcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHNjb3Blczogc3RyaW5nW10gPSBbXTtcblxuICAvKipcbiAgICogQWRkIGFuIE9BdXRoIHNjb3BlIHRvIHRoZSBjcmVkZW50aWFsLlxuICAgKlxuICAgKiBAcGFyYW0gc2NvcGUgLSBQcm92aWRlciBPQXV0aCBzY29wZSB0byBhZGQuXG4gICAqL1xuICBhZGRTY29wZShzY29wZTogc3RyaW5nKTogQXV0aFByb3ZpZGVyIHtcbiAgICAvLyBJZiBub3QgYWxyZWFkeSBhZGRlZCwgYWRkIHNjb3BlIHRvIGxpc3QuXG4gICAgaWYgKCF0aGlzLnNjb3Blcy5pbmNsdWRlcyhzY29wZSkpIHtcbiAgICAgIHRoaXMuc2NvcGVzLnB1c2goc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBsaXN0IG9mIE9BdXRoIHNjb3Blcy5cbiAgICovXG4gIGdldFNjb3BlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLnNjb3Blc107XG4gIH1cbn1cblxuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBnZW5lcmljIHtAbGluayBPQXV0aENyZWRlbnRpYWx9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBpZiAocmVzdWx0KSB7XG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBPQXV0aCBBY2Nlc3MgVG9rZW4gZm9yIHRoZSBwcm92aWRlci5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IHByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KGF1dGgsIHJlc3VsdCk7XG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBPQXV0aCBBY2Nlc3MgVG9rZW4gZm9yIHRoZSBwcm92aWRlci5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBwcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChhdXRoLCByZXN1bHQpO1xuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBPQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEgSlNPTiBzdHJpbmcgb3IgYSBwbGFpbiBvYmplY3QuXG4gICAqIEBwYXJhbSBqc29uIC0gQSBwbGFpbiBvYmplY3Qgb3IgYSBKU09OIHN0cmluZ1xuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tSlNPTihqc29uOiBvYmplY3QgfCBzdHJpbmcpOiBPQXV0aENyZWRlbnRpYWwge1xuICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICAgIF9hc3NlcnQoXG4gICAgICAncHJvdmlkZXJJZCcgaW4gb2JqICYmICdzaWduSW5NZXRob2QnIGluIG9iaixcbiAgICAgIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1JcbiAgICApO1xuICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMob2JqKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIGdlbmVyaWMgT0F1dGggcHJvdmlkZXIncyBhY2Nlc3MgdG9rZW4gb3IgSUQgdG9rZW4uXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSByYXcgbm9uY2UgaXMgcmVxdWlyZWQgd2hlbiBhbiBJRCB0b2tlbiB3aXRoIGEgbm9uY2UgZmllbGQgaXMgcHJvdmlkZWQuIFRoZSBTSEEtMjU2IGhhc2ggb2ZcbiAgICogdGhlIHJhdyBub25jZSBtdXN0IG1hdGNoIHRoZSBub25jZSBmaWVsZCBpbiB0aGUgSUQgdG9rZW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gYGdvb2dsZVVzZXJgIGZyb20gdGhlIG9uc3VjY2VzcyBHb29nbGUgU2lnbiBJbiBjYWxsYmFjay5cbiAgICogLy8gSW5pdGlhbGl6ZSBhIGdlbmVyYXRlIE9BdXRoIHByb3ZpZGVyIHdpdGggYSBgZ29vZ2xlLmNvbWAgcHJvdmlkZXJJZC5cbiAgICogY29uc3QgcHJvdmlkZXIgPSBuZXcgT0F1dGhQcm92aWRlcignZ29vZ2xlLmNvbScpO1xuICAgKiBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbCh7XG4gICAqICAgaWRUb2tlbjogZ29vZ2xlVXNlci5nZXRBdXRoUmVzcG9uc2UoKS5pZF90b2tlbixcbiAgICogfSk7XG4gICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGNyZWRlbnRpYWwpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIEVpdGhlciB0aGUgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyB0aGUgSUQgdG9rZW4sIGFjY2VzcyB0b2tlbiBhbmQgcmF3IG5vbmNlXG4gICAqIG9yIHRoZSBJRCB0b2tlbiBzdHJpbmcuXG4gICAqL1xuICBjcmVkZW50aWFsKHBhcmFtczogT0F1dGhDcmVkZW50aWFsT3B0aW9ucyk6IE9BdXRoQ3JlZGVudGlhbCB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWRlbnRpYWwoeyAuLi5wYXJhbXMsIG5vbmNlOiBwYXJhbXMucmF3Tm9uY2UgfSk7XG4gIH1cblxuICAvKiogQW4gaW50ZXJuYWwgY3JlZGVudGlhbCBtZXRob2QgdGhhdCBhY2NlcHRzIG1vcmUgcGVybWlzc2l2ZSBvcHRpb25zICovXG4gIHByaXZhdGUgX2NyZWRlbnRpYWwoXG4gICAgcGFyYW1zOiBPbWl0PE9BdXRoQ3JlZGVudGlhbFBhcmFtcywgJ3NpZ25Jbk1ldGhvZCcgfCAncHJvdmlkZXJJZCc+XG4gICk6IE9BdXRoQ3JlZGVudGlhbCB7XG4gICAgX2Fzc2VydChwYXJhbXMuaWRUb2tlbiB8fCBwYXJhbXMuYWNjZXNzVG9rZW4sIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IpO1xuICAgIC8vIEZvciBPQXV0aENyZWRlbnRpYWwsIHNpZ24gaW4gbWV0aG9kIGlzIHNhbWUgYXMgcHJvdmlkZXJJZC5cbiAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCxcbiAgICAgIHNpZ25Jbk1ldGhvZDogdGhpcy5wcm92aWRlcklkXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KFxuICAgIHVzZXJDcmVkZW50aWFsOiBVc2VyQ3JlZGVudGlhbFxuICApOiBPQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICByZXR1cm4gT0F1dGhQcm92aWRlci5vYXV0aENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KFxuICAgICAgdXNlckNyZWRlbnRpYWwgYXMgVXNlckNyZWRlbnRpYWxJbnRlcm5hbFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcjogRmlyZWJhc2VFcnJvcik6IE9BdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIHJldHVybiBPQXV0aFByb3ZpZGVyLm9hdXRoQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoXG4gICAgICAoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkgYXMgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2VcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgb2F1dGhDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7XG4gICAgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2VcbiAgfTogVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2UpOiBPQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICBpZiAoIXRva2VuUmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIG9hdXRoSWRUb2tlbixcbiAgICAgIG9hdXRoQWNjZXNzVG9rZW4sXG4gICAgICBvYXV0aFRva2VuU2VjcmV0LFxuICAgICAgcGVuZGluZ1Rva2VuLFxuICAgICAgbm9uY2UsXG4gICAgICBwcm92aWRlcklkXG4gICAgfSA9IHRva2VuUmVzcG9uc2UgYXMgU2lnbkluV2l0aElkcFJlc3BvbnNlO1xuICAgIGlmIChcbiAgICAgICFvYXV0aEFjY2Vzc1Rva2VuICYmXG4gICAgICAhb2F1dGhUb2tlblNlY3JldCAmJlxuICAgICAgIW9hdXRoSWRUb2tlbiAmJlxuICAgICAgIXBlbmRpbmdUb2tlblxuICAgICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFwcm92aWRlcklkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBPQXV0aFByb3ZpZGVyKHByb3ZpZGVySWQpLl9jcmVkZW50aWFsKHtcbiAgICAgICAgaWRUb2tlbjogb2F1dGhJZFRva2VuLFxuICAgICAgICBhY2Nlc3NUb2tlbjogb2F1dGhBY2Nlc3NUb2tlbixcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIHBlbmRpbmdUb2tlblxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbXBvcnQgeyBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IE9BdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uL2NyZWRlbnRpYWxzL29hdXRoJztcbmltcG9ydCB7IEJhc2VPQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi9vYXV0aCc7XG5pbXBvcnQgeyBQcm92aWRlcklkLCBTaWduSW5NZXRob2QgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZm9yIHtAbGluayBQcm92aWRlcklkfS5GQUNFQk9PSy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCd1c2VyX2JpcnRoZGF5Jyk7XG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBpZiAocmVzdWx0KSB7XG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCd1c2VyX2JpcnRoZGF5Jyk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXG4gKiBjb25zdCBjcmVkZW50aWFsID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEZhY2Vib29rQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xuICAvKiogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5GQUNFQk9PSy4gKi9cbiAgc3RhdGljIHJlYWRvbmx5IEZBQ0VCT09LX1NJR05fSU5fTUVUSE9EOiAnZmFjZWJvb2suY29tJyA9XG4gICAgU2lnbkluTWV0aG9kLkZBQ0VCT09LO1xuICAvKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uRkFDRUJPT0suICovXG4gIHN0YXRpYyByZWFkb25seSBQUk9WSURFUl9JRDogJ2ZhY2Vib29rLmNvbScgPSBQcm92aWRlcklkLkZBQ0VCT09LO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFByb3ZpZGVySWQuRkFDRUJPT0spO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBGYWNlYm9vay5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBgZXZlbnRgIGZyb20gdGhlIEZhY2Vib29rIGF1dGguYXV0aFJlc3BvbnNlQ2hhbmdlIGNhbGxiYWNrLlxuICAgKiBjb25zdCBjcmVkZW50aWFsID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChldmVudC5hdXRoUmVzcG9uc2UuYWNjZXNzVG9rZW4pO1xuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsKGFjY2Vzc1Rva2VuOiBzdHJpbmcpOiBPQXV0aENyZWRlbnRpYWwge1xuICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoe1xuICAgICAgcHJvdmlkZXJJZDogRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXG4gICAgICBzaWduSW5NZXRob2Q6IEZhY2Vib29rQXV0aFByb3ZpZGVyLkZBQ0VCT09LX1NJR05fSU5fTUVUSE9ELFxuICAgICAgYWNjZXNzVG9rZW5cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQoXG4gICAgdXNlckNyZWRlbnRpYWw6IFVzZXJDcmVkZW50aWFsXG4gICk6IE9BdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIHJldHVybiBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdChcbiAgICAgIHVzZXJDcmVkZW50aWFsIGFzIFVzZXJDcmVkZW50aWFsSW50ZXJuYWxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcjogRmlyZWJhc2VFcnJvcik6IE9BdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIHJldHVybiBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdChcbiAgICAgIChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSBhcyBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7XG4gICAgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2VcbiAgfTogVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2UpOiBPQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICBpZiAoIXRva2VuUmVzcG9uc2UgfHwgISgnb2F1dGhBY2Nlc3NUb2tlbicgaW4gdG9rZW5SZXNwb25zZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdG9rZW5SZXNwb25zZS5vYXV0aEFjY2Vzc1Rva2VuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwodG9rZW5SZXNwb25zZS5vYXV0aEFjY2Vzc1Rva2VuKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuaW1wb3J0IHsgU2lnbkluV2l0aElkcFJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL2lkcCc7XG5pbXBvcnQgeyBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IE9BdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uL2NyZWRlbnRpYWxzL29hdXRoJztcbmltcG9ydCB7IEJhc2VPQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi9vYXV0aCc7XG5pbXBvcnQgeyBQcm92aWRlcklkLCBTaWduSW5NZXRob2QgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYW4gYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZm9yIHtAbGluayBQcm92aWRlcklkfS5HT09HTEUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdvb2dsZUF1dGhQcm92aWRlcigpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR29vZ2xlIEFjY2VzcyBUb2tlbi5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR29vZ2xlQXV0aFByb3ZpZGVyKCk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBHb29nbGUgQWNjZXNzIFRva2VuLlxuICogY29uc3QgY3JlZGVudGlhbCA9IEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgR29vZ2xlQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xuICAvKiogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5HT09HTEUuICovXG4gIHN0YXRpYyByZWFkb25seSBHT09HTEVfU0lHTl9JTl9NRVRIT0Q6ICdnb29nbGUuY29tJyA9IFNpZ25Jbk1ldGhvZC5HT09HTEU7XG4gIC8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5HT09HTEUuICovXG4gIHN0YXRpYyByZWFkb25seSBQUk9WSURFUl9JRDogJ2dvb2dsZS5jb20nID0gUHJvdmlkZXJJZC5HT09HTEU7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoUHJvdmlkZXJJZC5HT09HTEUpO1xuICAgIHRoaXMuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgR29vZ2xlLiBBdCBsZWFzdCBvbmUgb2YgSUQgdG9rZW4gYW5kIGFjY2VzcyB0b2tlbiBpcyByZXF1aXJlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBcXGBnb29nbGVVc2VyXFxgIGZyb20gdGhlIG9uc3VjY2VzcyBHb29nbGUgU2lnbiBJbiBjYWxsYmFjay5cbiAgICogY29uc3QgY3JlZGVudGlhbCA9IEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsKGdvb2dsZVVzZXIuZ2V0QXV0aFJlc3BvbnNlKCkuaWRfdG9rZW4pO1xuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBpZFRva2VuIC0gR29vZ2xlIElEIHRva2VuLlxuICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gLSBHb29nbGUgYWNjZXNzIHRva2VuLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWwoXG4gICAgaWRUb2tlbj86IHN0cmluZyB8IG51bGwsXG4gICAgYWNjZXNzVG9rZW4/OiBzdHJpbmcgfCBudWxsXG4gICk6IE9BdXRoQ3JlZGVudGlhbCB7XG4gICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XG4gICAgICBwcm92aWRlcklkOiBHb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXG4gICAgICBzaWduSW5NZXRob2Q6IEdvb2dsZUF1dGhQcm92aWRlci5HT09HTEVfU0lHTl9JTl9NRVRIT0QsXG4gICAgICBpZFRva2VuLFxuICAgICAgYWNjZXNzVG9rZW5cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQoXG4gICAgdXNlckNyZWRlbnRpYWw6IFVzZXJDcmVkZW50aWFsXG4gICk6IE9BdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIHJldHVybiBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoXG4gICAgICB1c2VyQ3JlZGVudGlhbCBhcyBVc2VyQ3JlZGVudGlhbEludGVybmFsXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcbiAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yOiBGaXJlYmFzZUVycm9yKTogT0F1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgcmV0dXJuIEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdChcbiAgICAgIChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSBhcyBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7XG4gICAgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2VcbiAgfTogVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2UpOiBPQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICBpZiAoIXRva2VuUmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHsgb2F1dGhJZFRva2VuLCBvYXV0aEFjY2Vzc1Rva2VuIH0gPVxuICAgICAgdG9rZW5SZXNwb25zZSBhcyBTaWduSW5XaXRoSWRwUmVzcG9uc2U7XG4gICAgaWYgKCFvYXV0aElkVG9rZW4gJiYgIW9hdXRoQWNjZXNzVG9rZW4pIHtcbiAgICAgIC8vIFRoaXMgY291bGQgYmUgYW4gb2F1dGggMSBjcmVkZW50aWFsIG9yIGEgcGhvbmUgY3JlZGVudGlhbFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChvYXV0aElkVG9rZW4sIG9hdXRoQWNjZXNzVG9rZW4pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbXBvcnQgeyBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IE9BdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uL2NyZWRlbnRpYWxzL29hdXRoJztcbmltcG9ydCB7IEJhc2VPQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi9vYXV0aCc7XG5pbXBvcnQgeyBQcm92aWRlcklkLCBTaWduSW5NZXRob2QgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZm9yIHtAbGluayBQcm92aWRlcklkfS5HSVRIVUIuXG4gKlxuICogQHJlbWFya3NcbiAqIEdpdEh1YiByZXF1aXJlcyBhbiBPQXV0aCAyLjAgcmVkaXJlY3QsIHNvIHlvdSBjYW4gZWl0aGVyIGhhbmRsZSB0aGUgcmVkaXJlY3QgZGlyZWN0bHksIG9yIHVzZVxuICogdGhlIHtAbGluayBzaWduSW5XaXRoUG9wdXB9IGhhbmRsZXI6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdpdGh1YkF1dGhQcm92aWRlcigpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3JlcG8nKTtcbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGlmIChyZXN1bHQpIHtcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIEdpdGh1YiBBY2Nlc3MgVG9rZW4uXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdpdGh1YkF1dGhQcm92aWRlcigpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3JlcG8nKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XG4gKlxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXG4gKiBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIEdpdGh1YiBBY2Nlc3MgVG9rZW4uXG4gKiBjb25zdCBjcmVkZW50aWFsID0gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEdpdGh1YkF1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcbiAgLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uR0lUSFVCLiAqL1xuICBzdGF0aWMgcmVhZG9ubHkgR0lUSFVCX1NJR05fSU5fTUVUSE9EOiAnZ2l0aHViLmNvbScgPSBTaWduSW5NZXRob2QuR0lUSFVCO1xuICAvKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uR0lUSFVCLiAqL1xuICBzdGF0aWMgcmVhZG9ubHkgUFJPVklERVJfSUQ6ICdnaXRodWIuY29tJyA9IFByb3ZpZGVySWQuR0lUSFVCO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFByb3ZpZGVySWQuR0lUSFVCKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgR2l0aHViLlxuICAgKlxuICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gLSBHaXRodWIgYWNjZXNzIHRva2VuLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWwoYWNjZXNzVG9rZW46IHN0cmluZyk6IE9BdXRoQ3JlZGVudGlhbCB7XG4gICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XG4gICAgICBwcm92aWRlcklkOiBHaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXG4gICAgICBzaWduSW5NZXRob2Q6IEdpdGh1YkF1dGhQcm92aWRlci5HSVRIVUJfU0lHTl9JTl9NRVRIT0QsXG4gICAgICBhY2Nlc3NUb2tlblxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdChcbiAgICB1c2VyQ3JlZGVudGlhbDogVXNlckNyZWRlbnRpYWxcbiAgKTogT0F1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgcmV0dXJuIEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdChcbiAgICAgIHVzZXJDcmVkZW50aWFsIGFzIFVzZXJDcmVkZW50aWFsSW50ZXJuYWxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcjogRmlyZWJhc2VFcnJvcik6IE9BdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIHJldHVybiBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoXG4gICAgICAoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkgYXMgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2VcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3Qoe1xuICAgIF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlXG4gIH06IFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlKTogT0F1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgaWYgKCF0b2tlblJlc3BvbnNlIHx8ICEoJ29hdXRoQWNjZXNzVG9rZW4nIGluIHRva2VuUmVzcG9uc2UpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbCh0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFNBTUwgY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgYW4ge0BsaW5rIFNBTUxBdXRoUHJvdmlkZXJ9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5pbXBvcnQge1xuICBzaWduSW5XaXRoSWRwLFxuICBTaWduSW5XaXRoSWRwUmVxdWVzdFxufSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vaWRwJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuL2F1dGhfY3JlZGVudGlhbCc7XG5cbmNvbnN0IElEUF9SRVFVRVNUX1VSSSA9ICdodHRwOi8vbG9jYWxob3N0JztcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBTQU1MQXV0aENyZWRlbnRpYWwgZXh0ZW5kcyBBdXRoQ3JlZGVudGlhbCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwcm92aWRlcklkOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwZW5kaW5nVG9rZW46IHN0cmluZ1xuICApIHtcbiAgICBzdXBlcihwcm92aWRlcklkLCBwcm92aWRlcklkKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoOiBBdXRoSW50ZXJuYWwpOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfbGlua1RvSWRUb2tlbihcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgaWRUb2tlbjogc3RyaW5nXG4gICk6IFByb21pc2U8SWRUb2tlblJlc3BvbnNlPiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5pZFRva2VuID0gaWRUb2tlbjtcbiAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoOiBBdXRoSW50ZXJuYWwpOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgIHJlcXVlc3QuYXV0b0NyZWF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xuICB9XG5cbiAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICAqL1xuICB0b0pTT04oKTogb2JqZWN0IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbkluTWV0aG9kOiB0aGlzLnNpZ25Jbk1ldGhvZCxcbiAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCxcbiAgICAgIHBlbmRpbmdUb2tlbjogdGhpcy5wZW5kaW5nVG9rZW5cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgdG8gZGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbnRvIGFuXG4gICAqIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LlxuICAgKlxuICAgKiBAcGFyYW0ganNvbiAtIElucHV0IGNhbiBiZSBlaXRoZXIgT2JqZWN0IG9yIHRoZSBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgKiBXaGVuIHN0cmluZyBpcyBwcm92aWRlZCwgSlNPTi5wYXJzZSB3b3VsZCBiZSBjYWxsZWQgZmlyc3QuXG4gICAqXG4gICAqIEByZXR1cm5zIElmIHRoZSBKU09OIGlucHV0IGRvZXMgbm90IHJlcHJlc2VudCBhbiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfSwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICovXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uOiBzdHJpbmcgfCBvYmplY3QpOiBTQU1MQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbiAgICBjb25zdCB7IHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCwgcGVuZGluZ1Rva2VuIH06IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPVxuICAgICAgb2JqO1xuICAgIGlmIChcbiAgICAgICFwcm92aWRlcklkIHx8XG4gICAgICAhc2lnbkluTWV0aG9kIHx8XG4gICAgICAhcGVuZGluZ1Rva2VuIHx8XG4gICAgICBwcm92aWRlcklkICE9PSBzaWduSW5NZXRob2RcbiAgICApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU0FNTEF1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbik7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHN0YXRpYyBtZXRob2QgdG8gYXZvaWQgZXhwb3NpbmcgdGhlIGNvbnN0cnVjdG9yIHRvIGVuZCB1c2Vycy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgX2NyZWF0ZShwcm92aWRlcklkOiBzdHJpbmcsIHBlbmRpbmdUb2tlbjogc3RyaW5nKTogU0FNTEF1dGhDcmVkZW50aWFsIHtcbiAgICByZXR1cm4gbmV3IFNBTUxBdXRoQ3JlZGVudGlhbChwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pO1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZFJlcXVlc3QoKTogU2lnbkluV2l0aElkcFJlcXVlc3Qge1xuICAgIHJldHVybiB7XG4gICAgICByZXF1ZXN0VXJpOiBJRFBfUkVRVUVTVF9VUkksXG4gICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcbiAgICAgIHBlbmRpbmdUb2tlbjogdGhpcy5wZW5kaW5nVG9rZW5cbiAgICB9O1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgU2lnbkluV2l0aElkcFJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL2lkcCc7XG5pbXBvcnQgeyBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IEF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi4vY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgU0FNTEF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi4vY3JlZGVudGlhbHMvc2FtbCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIgfSBmcm9tICcuL2ZlZGVyYXRlZCc7XG5cbmNvbnN0IFNBTUxfUFJPVklERVJfUFJFRklYID0gJ3NhbWwuJztcblxuLyoqXG4gKiBBbiB7QGxpbmsgQXV0aFByb3ZpZGVyfSBmb3IgU0FNTC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBTQU1MQXV0aFByb3ZpZGVyIGV4dGVuZHMgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLiBUaGUgcHJvdmlkZXJJZCBtdXN0IHN0YXJ0IHdpdGggXCJzYW1sLlwiXG4gICAqIEBwYXJhbSBwcm92aWRlcklkIC0gU0FNTCBwcm92aWRlciBJRC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVySWQ6IHN0cmluZykge1xuICAgIF9hc3NlcnQoXG4gICAgICBwcm92aWRlcklkLnN0YXJ0c1dpdGgoU0FNTF9QUk9WSURFUl9QUkVGSVgpLFxuICAgICAgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUlxuICAgICk7XG4gICAgc3VwZXIocHJvdmlkZXJJZCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0gYWZ0ZXIgYVxuICAgKiBzdWNjZXNzZnVsIFNBTUwgZmxvdyBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCB0byBnZXQgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSwgeW91IGNvdWxkIHdyaXRlIHRoZVxuICAgKiBmb2xsb3dpbmcgY29kZTpcbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgc2FtbFByb3ZpZGVyKTtcbiAgICogY29uc3QgY3JlZGVudGlhbCA9IFNBTUxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdChcbiAgICB1c2VyQ3JlZGVudGlhbDogVXNlckNyZWRlbnRpYWxcbiAgKTogQXV0aENyZWRlbnRpYWwgfCBudWxsIHtcbiAgICByZXR1cm4gU0FNTEF1dGhQcm92aWRlci5zYW1sQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoXG4gICAgICB1c2VyQ3JlZGVudGlhbCBhcyBVc2VyQ3JlZGVudGlhbEludGVybmFsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3I6IEZpcmViYXNlRXJyb3IpOiBBdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIHJldHVybiBTQU1MQXV0aFByb3ZpZGVyLnNhbWxDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdChcbiAgICAgIChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSBhcyBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IGZyb20gYSBKU09OIHN0cmluZyBvciBhIHBsYWluIG9iamVjdC5cbiAgICogQHBhcmFtIGpzb24gLSBBIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21KU09OKGpzb246IHN0cmluZyB8IG9iamVjdCk6IEF1dGhDcmVkZW50aWFsIHtcbiAgICBjb25zdCBjcmVkZW50aWFsID0gU0FNTEF1dGhDcmVkZW50aWFsLmZyb21KU09OKGpzb24pO1xuICAgIF9hc3NlcnQoY3JlZGVudGlhbCwgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUik7XG4gICAgcmV0dXJuIGNyZWRlbnRpYWw7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBzYW1sQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3Qoe1xuICAgIF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlXG4gIH06IFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlKTogU0FNTEF1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7IHBlbmRpbmdUb2tlbiwgcHJvdmlkZXJJZCB9ID0gdG9rZW5SZXNwb25zZSBhcyBTaWduSW5XaXRoSWRwUmVzcG9uc2U7XG5cbiAgICBpZiAoIXBlbmRpbmdUb2tlbiB8fCAhcHJvdmlkZXJJZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBTQU1MQXV0aENyZWRlbnRpYWwuX2NyZWF0ZShwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgVHdpdHRlciBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmltcG9ydCB7IFNpZ25JbldpdGhJZHBSZXNwb25zZSB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9pZHAnO1xuaW1wb3J0IHsgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBPQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuLi9jcmVkZW50aWFscy9vYXV0aCc7XG5pbXBvcnQgeyBCYXNlT0F1dGhQcm92aWRlciB9IGZyb20gJy4vb2F1dGgnO1xuaW1wb3J0IHsgUHJvdmlkZXJJZCwgU2lnbkluTWV0aG9kIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uVFdJVFRFUi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgVHdpdHRlckF1dGhQcm92aWRlcigpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgVHdpdHRlciBBY2Nlc3MgVG9rZW4gYW5kIFNlY3JldC5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogICBjb25zdCBzZWNyZXQgPSBjcmVkZW50aWFsLnNlY3JldDtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBUd2l0dGVyQXV0aFByb3ZpZGVyKCk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBUd2l0dGVyIEFjY2VzcyBUb2tlbiBhbmQgU2VjcmV0LlxuICogY29uc3QgY3JlZGVudGlhbCA9IFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGNvbnN0IHNlY3JldCA9IGNyZWRlbnRpYWwuc2VjcmV0O1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVHdpdHRlckF1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcbiAgLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uVFdJVFRFUi4gKi9cbiAgc3RhdGljIHJlYWRvbmx5IFRXSVRURVJfU0lHTl9JTl9NRVRIT0Q6ICd0d2l0dGVyLmNvbScgPSBTaWduSW5NZXRob2QuVFdJVFRFUjtcbiAgLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LlRXSVRURVIuICovXG4gIHN0YXRpYyByZWFkb25seSBQUk9WSURFUl9JRDogJ3R3aXR0ZXIuY29tJyA9IFByb3ZpZGVySWQuVFdJVFRFUjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihQcm92aWRlcklkLlRXSVRURVIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBUd2l0dGVyLlxuICAgKlxuICAgKiBAcGFyYW0gdG9rZW4gLSBUd2l0dGVyIGFjY2VzcyB0b2tlbi5cbiAgICogQHBhcmFtIHNlY3JldCAtIFR3aXR0ZXIgc2VjcmV0LlxuICAgKi9cbiAgc3RhdGljIGNyZWRlbnRpYWwodG9rZW46IHN0cmluZywgc2VjcmV0OiBzdHJpbmcpOiBPQXV0aENyZWRlbnRpYWwge1xuICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoe1xuICAgICAgcHJvdmlkZXJJZDogVHdpdHRlckF1dGhQcm92aWRlci5QUk9WSURFUl9JRCxcbiAgICAgIHNpZ25Jbk1ldGhvZDogVHdpdHRlckF1dGhQcm92aWRlci5UV0lUVEVSX1NJR05fSU5fTUVUSE9ELFxuICAgICAgb2F1dGhUb2tlbjogdG9rZW4sXG4gICAgICBvYXV0aFRva2VuU2VjcmV0OiBzZWNyZXRcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQoXG4gICAgdXNlckNyZWRlbnRpYWw6IFVzZXJDcmVkZW50aWFsXG4gICk6IE9BdXRoQ3JlZGVudGlhbCB8IG51bGwge1xuICAgIHJldHVybiBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KFxuICAgICAgdXNlckNyZWRlbnRpYWwgYXMgVXNlckNyZWRlbnRpYWxJbnRlcm5hbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcbiAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICovXG4gIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yOiBGaXJlYmFzZUVycm9yKTogT0F1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgcmV0dXJuIFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoXG4gICAgICAoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkgYXMgVGFnZ2VkV2l0aFRva2VuUmVzcG9uc2VcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3Qoe1xuICAgIF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlXG4gIH06IFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlKTogT0F1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBvYXV0aEFjY2Vzc1Rva2VuLCBvYXV0aFRva2VuU2VjcmV0IH0gPVxuICAgICAgdG9rZW5SZXNwb25zZSBhcyBTaWduSW5XaXRoSWRwUmVzcG9uc2U7XG4gICAgaWYgKCFvYXV0aEFjY2Vzc1Rva2VuIHx8ICFvYXV0aFRva2VuU2VjcmV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChvYXV0aEFjY2Vzc1Rva2VuLCBvYXV0aFRva2VuU2VjcmV0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRW5kcG9pbnQsXG4gIEh0dHBNZXRob2QsXG4gIFJlY2FwdGNoYUNsaWVudFR5cGUsXG4gIFJlY2FwdGNoYVZlcnNpb24sXG4gIF9hZGRUaWRJZk5lY2Vzc2FyeSxcbiAgX3BlcmZvcm1TaWduSW5SZXF1ZXN0XG59IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IEF1dGggfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25VcFJlcXVlc3Qge1xuICByZXR1cm5TZWN1cmVUb2tlbj86IGJvb2xlYW47XG4gIGVtYWlsPzogc3RyaW5nO1xuICBwYXNzd29yZD86IHN0cmluZztcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG4gIGNhcHRjaGFSZXNwb25zZT86IHN0cmluZztcbiAgY2xpZW50VHlwZT86IFJlY2FwdGNoYUNsaWVudFR5cGU7XG4gIHJlY2FwdGNoYVZlcnNpb24/OiBSZWNhcHRjaGFWZXJzaW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25VcFJlc3BvbnNlIGV4dGVuZHMgSWRUb2tlblJlc3BvbnNlIHtcbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG4gIGVtYWlsPzogc3RyaW5nO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnblVwKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBTaWduVXBSZXF1ZXN0XG4pOiBQcm9taXNlPFNpZ25VcFJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3Q8U2lnblVwUmVxdWVzdCwgU2lnblVwUmVzcG9uc2U+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LlNJR05fVVAsXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQaG9uZU9yT2F1dGhUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL21mYSc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwsIFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IFVzZXJJbXBsIH0gZnJvbSAnLi91c2VyX2ltcGwnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBPcGVyYXRpb25UeXBlLCBQcm92aWRlcklkIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG5pbnRlcmZhY2UgVXNlckNyZWRlbnRpYWxQYXJhbXMge1xuICByZWFkb25seSB1c2VyOiBVc2VySW50ZXJuYWw7XG4gIHJlYWRvbmx5IHByb3ZpZGVySWQ6IFByb3ZpZGVySWQgfCBzdHJpbmcgfCBudWxsO1xuICByZWFkb25seSBfdG9rZW5SZXNwb25zZT86IFBob25lT3JPYXV0aFRva2VuUmVzcG9uc2U7XG4gIHJlYWRvbmx5IG9wZXJhdGlvblR5cGU6IE9wZXJhdGlvblR5cGU7XG59XG5cbmV4cG9ydCBjbGFzcyBVc2VyQ3JlZGVudGlhbEltcGxcbiAgaW1wbGVtZW50cyBVc2VyQ3JlZGVudGlhbEludGVybmFsLCBVc2VyQ3JlZGVudGlhbFBhcmFtc1xue1xuICByZWFkb25seSB1c2VyOiBVc2VySW50ZXJuYWw7XG4gIHJlYWRvbmx5IHByb3ZpZGVySWQ6IFByb3ZpZGVySWQgfCBzdHJpbmcgfCBudWxsO1xuICByZWFkb25seSBfdG9rZW5SZXNwb25zZTogUGhvbmVPck9hdXRoVG9rZW5SZXNwb25zZSB8IHVuZGVmaW5lZDtcbiAgcmVhZG9ubHkgb3BlcmF0aW9uVHlwZTogT3BlcmF0aW9uVHlwZTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXM6IFVzZXJDcmVkZW50aWFsUGFyYW1zKSB7XG4gICAgdGhpcy51c2VyID0gcGFyYW1zLnVzZXI7XG4gICAgdGhpcy5wcm92aWRlcklkID0gcGFyYW1zLnByb3ZpZGVySWQ7XG4gICAgdGhpcy5fdG9rZW5SZXNwb25zZSA9IHBhcmFtcy5fdG9rZW5SZXNwb25zZTtcbiAgICB0aGlzLm9wZXJhdGlvblR5cGUgPSBwYXJhbXMub3BlcmF0aW9uVHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBfZnJvbUlkVG9rZW5SZXNwb25zZShcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgb3BlcmF0aW9uVHlwZTogT3BlcmF0aW9uVHlwZSxcbiAgICBpZFRva2VuUmVzcG9uc2U6IElkVG9rZW5SZXNwb25zZSxcbiAgICBpc0Fub255bW91czogYm9vbGVhbiA9IGZhbHNlXG4gICk6IFByb21pc2U8VXNlckNyZWRlbnRpYWxJbnRlcm5hbD4ge1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VySW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShcbiAgICAgIGF1dGgsXG4gICAgICBpZFRva2VuUmVzcG9uc2UsXG4gICAgICBpc0Fub255bW91c1xuICAgICk7XG4gICAgY29uc3QgcHJvdmlkZXJJZCA9IHByb3ZpZGVySWRGb3JSZXNwb25zZShpZFRva2VuUmVzcG9uc2UpO1xuICAgIGNvbnN0IHVzZXJDcmVkID0gbmV3IFVzZXJDcmVkZW50aWFsSW1wbCh7XG4gICAgICB1c2VyLFxuICAgICAgcHJvdmlkZXJJZCxcbiAgICAgIF90b2tlblJlc3BvbnNlOiBpZFRva2VuUmVzcG9uc2UsXG4gICAgICBvcGVyYXRpb25UeXBlXG4gICAgfSk7XG4gICAgcmV0dXJuIHVzZXJDcmVkO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIF9mb3JPcGVyYXRpb24oXG4gICAgdXNlcjogVXNlckludGVybmFsLFxuICAgIG9wZXJhdGlvblR5cGU6IE9wZXJhdGlvblR5cGUsXG4gICAgcmVzcG9uc2U6IFBob25lT3JPYXV0aFRva2VuUmVzcG9uc2VcbiAgKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEltcGw+IHtcbiAgICBhd2FpdCB1c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSwgLyogcmVsb2FkICovIHRydWUpO1xuICAgIGNvbnN0IHByb3ZpZGVySWQgPSBwcm92aWRlcklkRm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIHJldHVybiBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcbiAgICAgIHVzZXIsXG4gICAgICBwcm92aWRlcklkLFxuICAgICAgX3Rva2VuUmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgb3BlcmF0aW9uVHlwZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb3ZpZGVySWRGb3JSZXNwb25zZShcbiAgcmVzcG9uc2U6IElkVG9rZW5SZXNwb25zZVxuKTogUHJvdmlkZXJJZCB8IHN0cmluZyB8IG51bGwge1xuICBpZiAocmVzcG9uc2UucHJvdmlkZXJJZCkge1xuICAgIHJldHVybiByZXNwb25zZS5wcm92aWRlcklkO1xuICB9XG5cbiAgaWYgKCdwaG9uZU51bWJlcicgaW4gcmVzcG9uc2UpIHtcbiAgICByZXR1cm4gUHJvdmlkZXJJZC5QSE9ORTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aCwgVXNlckNyZWRlbnRpYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgc2lnblVwIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL3NpZ25fdXAnO1xuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEltcGwgfSBmcm9tICcuLi91c2VyL3VzZXJfY3JlZGVudGlhbF9pbXBsJztcbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4uL2F1dGgvYXV0aF9pbXBsJztcbmltcG9ydCB7IE9wZXJhdGlvblR5cGUgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gYXMgYW4gYW5vbnltb3VzIHVzZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHRoZXJlIGlzIGFscmVhZHkgYW4gYW5vbnltb3VzIHVzZXIgc2lnbmVkIGluLCB0aGF0IHVzZXIgd2lsbCBiZSByZXR1cm5lZDsgb3RoZXJ3aXNlLCBhXG4gKiBuZXcgYW5vbnltb3VzIHVzZXIgaWRlbnRpdHkgd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkluQW5vbnltb3VzbHkoYXV0aDogQXV0aCk6IFByb21pc2U8VXNlckNyZWRlbnRpYWw+IHtcbiAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICBhd2FpdCBhdXRoSW50ZXJuYWwuX2luaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgaWYgKGF1dGhJbnRlcm5hbC5jdXJyZW50VXNlcj8uaXNBbm9ueW1vdXMpIHtcbiAgICAvLyBJZiBhbiBhbm9ueW1vdXMgdXNlciBpcyBhbHJlYWR5IHNpZ25lZCBpbiwgbm8gbmVlZCB0byBzaWduIHRoZW0gaW4gYWdhaW4uXG4gICAgcmV0dXJuIG5ldyBVc2VyQ3JlZGVudGlhbEltcGwoe1xuICAgICAgdXNlcjogYXV0aEludGVybmFsLmN1cnJlbnRVc2VyIGFzIFVzZXJJbnRlcm5hbCxcbiAgICAgIHByb3ZpZGVySWQ6IG51bGwsXG4gICAgICBvcGVyYXRpb25UeXBlOiBPcGVyYXRpb25UeXBlLlNJR05fSU5cbiAgICB9KTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25VcChhdXRoSW50ZXJuYWwsIHtcbiAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxuICB9KTtcbiAgY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoXG4gICAgYXV0aEludGVybmFsLFxuICAgIE9wZXJhdGlvblR5cGUuU0lHTl9JTixcbiAgICByZXNwb25zZSxcbiAgICB0cnVlXG4gICk7XG4gIGF3YWl0IGF1dGhJbnRlcm5hbC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XG4gIHJldHVybiB1c2VyQ3JlZGVudGlhbDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IE11bHRpRmFjdG9yRXJyb3IgYXMgTXVsdGlGYWN0b3JFcnJvclB1YmxpYyB9IGZyb20gJy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uL2NvcmUvY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgSWRUb2tlbk1mYVJlc3BvbnNlIH0gZnJvbSAnLi4vYXBpL2F1dGhlbnRpY2F0aW9uL21mYSc7XG5pbXBvcnQgeyBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi4vbW9kZWwvZW51bXMnO1xuXG5leHBvcnQgdHlwZSBNdWx0aUZhY3RvckVycm9yRGF0YSA9IE11bHRpRmFjdG9yRXJyb3JQdWJsaWNbJ2N1c3RvbURhdGEnXSAmIHtcbiAgX3NlcnZlclJlc3BvbnNlOiBJZFRva2VuTWZhUmVzcG9uc2U7XG59O1xuXG5leHBvcnQgY2xhc3MgTXVsdGlGYWN0b3JFcnJvclxuICBleHRlbmRzIEZpcmViYXNlRXJyb3JcbiAgaW1wbGVtZW50cyBNdWx0aUZhY3RvckVycm9yUHVibGljXG57XG4gIHJlYWRvbmx5IGN1c3RvbURhdGE6IE11bHRpRmFjdG9yRXJyb3JEYXRhO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGVycm9yOiBGaXJlYmFzZUVycm9yLFxuICAgIHJlYWRvbmx5IG9wZXJhdGlvblR5cGU6IE9wZXJhdGlvblR5cGUsXG4gICAgcmVhZG9ubHkgdXNlcj86IFVzZXJJbnRlcm5hbFxuICApIHtcbiAgICBzdXBlcihlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBNdWx0aUZhY3RvckVycm9yLnByb3RvdHlwZSk7XG4gICAgdGhpcy5jdXN0b21EYXRhID0ge1xuICAgICAgYXBwTmFtZTogYXV0aC5uYW1lLFxuICAgICAgdGVuYW50SWQ6IGF1dGgudGVuYW50SWQgPz8gdW5kZWZpbmVkLFxuICAgICAgX3NlcnZlclJlc3BvbnNlOiBlcnJvci5jdXN0b21EYXRhIS5fc2VydmVyUmVzcG9uc2UgYXMgSWRUb2tlbk1mYVJlc3BvbnNlLFxuICAgICAgb3BlcmF0aW9uVHlwZVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgX2Zyb21FcnJvckFuZE9wZXJhdGlvbihcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgZXJyb3I6IEZpcmViYXNlRXJyb3IsXG4gICAgb3BlcmF0aW9uVHlwZTogT3BlcmF0aW9uVHlwZSxcbiAgICB1c2VyPzogVXNlckludGVybmFsXG4gICk6IE11bHRpRmFjdG9yRXJyb3Ige1xuICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JFcnJvcihhdXRoLCBlcnJvciwgb3BlcmF0aW9uVHlwZSwgdXNlcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShcbiAgYXV0aDogQXV0aEludGVybmFsLFxuICBvcGVyYXRpb25UeXBlOiBPcGVyYXRpb25UeXBlLFxuICBjcmVkZW50aWFsOiBBdXRoQ3JlZGVudGlhbCxcbiAgdXNlcj86IFVzZXJJbnRlcm5hbFxuKTogUHJvbWlzZTxJZFRva2VuUmVzcG9uc2U+IHtcbiAgY29uc3QgaWRUb2tlblByb3ZpZGVyID1cbiAgICBvcGVyYXRpb25UeXBlID09PSBPcGVyYXRpb25UeXBlLlJFQVVUSEVOVElDQVRFXG4gICAgICA/IGNyZWRlbnRpYWwuX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKVxuICAgICAgOiBjcmVkZW50aWFsLl9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCk7XG5cbiAgcmV0dXJuIGlkVG9rZW5Qcm92aWRlci5jYXRjaChlcnJvciA9PiB7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09IGBhdXRoLyR7QXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRUR9YCkge1xuICAgICAgdGhyb3cgTXVsdGlGYWN0b3JFcnJvci5fZnJvbUVycm9yQW5kT3BlcmF0aW9uKFxuICAgICAgICBhdXRoLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgb3BlcmF0aW9uVHlwZSxcbiAgICAgICAgdXNlclxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3ZpZGVyQXNzb2NpYXRlZE9iamVjdCB7XG4gIHByb3ZpZGVySWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGFrZXMgYSBzZXQgb2YgVXNlckluZm8gcHJvdmlkZXIgZGF0YSBhbmQgY29udmVydHMgaXQgdG8gYSBzZXQgb2YgbmFtZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3ZpZGVyRGF0YUFzTmFtZXM8VCBleHRlbmRzIFByb3ZpZGVyQXNzb2NpYXRlZE9iamVjdD4oXG4gIHByb3ZpZGVyRGF0YTogVFtdXG4pOiBTZXQ8c3RyaW5nPiB7XG4gIHJldHVybiBuZXcgU2V0KFxuICAgIHByb3ZpZGVyRGF0YVxuICAgICAgLm1hcCgoeyBwcm92aWRlcklkIH0pID0+IHByb3ZpZGVySWQpXG4gICAgICAuZmlsdGVyKHBpZCA9PiAhIXBpZCkgYXMgc3RyaW5nW11cbiAgKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBkZWxldGVMaW5rZWRBY2NvdW50cyB9IGZyb20gJy4uLy4uL2FwaS9hY2NvdW50X21hbmFnZW1lbnQvYWNjb3VudCc7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwsIFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IEF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi4vY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgcHJvdmlkZXJEYXRhQXNOYW1lcyB9IGZyb20gJy4uL3V0aWwvcHJvdmlkZXJzJztcbmltcG9ydCB7IF9sb2dvdXRJZkludmFsaWRhdGVkIH0gZnJvbSAnLi9pbnZhbGlkYXRpb24nO1xuaW1wb3J0IHsgX3JlbG9hZFdpdGhvdXRTYXZpbmcgfSBmcm9tICcuL3JlbG9hZCc7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEltcGwgfSBmcm9tICcuL3VzZXJfY3JlZGVudGlhbF9pbXBsJztcbmltcG9ydCB7IGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IE9wZXJhdGlvblR5cGUsIFByb3ZpZGVySWQgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbi8qKlxuICogVW5saW5rcyBhIHByb3ZpZGVyIGZyb20gYSB1c2VyIGFjY291bnQuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBwcm92aWRlcklkIC0gVGhlIHByb3ZpZGVyIHRvIHVubGluay5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1bmxpbmsodXNlcjogVXNlciwgcHJvdmlkZXJJZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyPiB7XG4gIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWw7XG4gIGF3YWl0IF9hc3NlcnRMaW5rZWRTdGF0dXModHJ1ZSwgdXNlckludGVybmFsLCBwcm92aWRlcklkKTtcbiAgY29uc3QgeyBwcm92aWRlclVzZXJJbmZvIH0gPSBhd2FpdCBkZWxldGVMaW5rZWRBY2NvdW50cyh1c2VySW50ZXJuYWwuYXV0aCwge1xuICAgIGlkVG9rZW46IGF3YWl0IHVzZXJJbnRlcm5hbC5nZXRJZFRva2VuKCksXG4gICAgZGVsZXRlUHJvdmlkZXI6IFtwcm92aWRlcklkXVxuICB9KTtcblxuICBjb25zdCBwcm92aWRlcnNMZWZ0ID0gcHJvdmlkZXJEYXRhQXNOYW1lcyhwcm92aWRlclVzZXJJbmZvIHx8IFtdKTtcblxuICB1c2VySW50ZXJuYWwucHJvdmlkZXJEYXRhID0gdXNlckludGVybmFsLnByb3ZpZGVyRGF0YS5maWx0ZXIocGQgPT5cbiAgICBwcm92aWRlcnNMZWZ0LmhhcyhwZC5wcm92aWRlcklkKVxuICApO1xuICBpZiAoIXByb3ZpZGVyc0xlZnQuaGFzKFByb3ZpZGVySWQuUEhPTkUpKSB7XG4gICAgdXNlckludGVybmFsLnBob25lTnVtYmVyID0gbnVsbDtcbiAgfVxuXG4gIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VySW50ZXJuYWwpO1xuICByZXR1cm4gdXNlckludGVybmFsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX2xpbmsoXG4gIHVzZXI6IFVzZXJJbnRlcm5hbCxcbiAgY3JlZGVudGlhbDogQXV0aENyZWRlbnRpYWwsXG4gIGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWw+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZChcbiAgICB1c2VyLFxuICAgIGNyZWRlbnRpYWwuX2xpbmtUb0lkVG9rZW4odXNlci5hdXRoLCBhd2FpdCB1c2VyLmdldElkVG9rZW4oKSksXG4gICAgYnlwYXNzQXV0aFN0YXRlXG4gICk7XG4gIHJldHVybiBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbih1c2VyLCBPcGVyYXRpb25UeXBlLkxJTkssIHJlc3BvbnNlKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9hc3NlcnRMaW5rZWRTdGF0dXMoXG4gIGV4cGVjdGVkOiBib29sZWFuLFxuICB1c2VyOiBVc2VySW50ZXJuYWwsXG4gIHByb3ZpZGVyOiBzdHJpbmdcbik6IFByb21pc2U8dm9pZD4ge1xuICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcbiAgY29uc3QgcHJvdmlkZXJJZHMgPSBwcm92aWRlckRhdGFBc05hbWVzKHVzZXIucHJvdmlkZXJEYXRhKTtcblxuICBjb25zdCBjb2RlID1cbiAgICBleHBlY3RlZCA9PT0gZmFsc2VcbiAgICAgID8gQXV0aEVycm9yQ29kZS5QUk9WSURFUl9BTFJFQURZX0xJTktFRFxuICAgICAgOiBBdXRoRXJyb3JDb2RlLk5PX1NVQ0hfUFJPVklERVI7XG4gIF9hc3NlcnQocHJvdmlkZXJJZHMuaGFzKHByb3ZpZGVyKSA9PT0gZXhwZWN0ZWQsIHVzZXIuYXV0aCwgY29kZSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgX3Byb2Nlc3NDcmVkZW50aWFsU2F2aW5nTWZhQ29udGV4dElmTmVjZXNzYXJ5IH0gZnJvbSAnLi4vLi4vbWZhL21mYV9lcnJvcic7XG5pbXBvcnQgeyBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCwgX2ZhaWwgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBfcGFyc2VUb2tlbiB9IGZyb20gJy4vaWRfdG9rZW5fcmVzdWx0JztcbmltcG9ydCB7IF9sb2dvdXRJZkludmFsaWRhdGVkIH0gZnJvbSAnLi9pbnZhbGlkYXRpb24nO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbXBsIH0gZnJvbSAnLi91c2VyX2NyZWRlbnRpYWxfaW1wbCc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcmVhdXRoZW50aWNhdGUoXG4gIHVzZXI6IFVzZXJJbnRlcm5hbCxcbiAgY3JlZGVudGlhbDogQXV0aENyZWRlbnRpYWwsXG4gIGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW1wbD4ge1xuICBjb25zdCB7IGF1dGggfSA9IHVzZXI7XG4gIGNvbnN0IG9wZXJhdGlvblR5cGUgPSBPcGVyYXRpb25UeXBlLlJFQVVUSEVOVElDQVRFO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZChcbiAgICAgIHVzZXIsXG4gICAgICBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkoXG4gICAgICAgIGF1dGgsXG4gICAgICAgIG9wZXJhdGlvblR5cGUsXG4gICAgICAgIGNyZWRlbnRpYWwsXG4gICAgICAgIHVzZXJcbiAgICAgICksXG4gICAgICBieXBhc3NBdXRoU3RhdGVcbiAgICApO1xuICAgIF9hc3NlcnQocmVzcG9uc2UuaWRUb2tlbiwgYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgY29uc3QgcGFyc2VkID0gX3BhcnNlVG9rZW4ocmVzcG9uc2UuaWRUb2tlbik7XG4gICAgX2Fzc2VydChwYXJzZWQsIGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuXG4gICAgY29uc3QgeyBzdWI6IGxvY2FsSWQgfSA9IHBhcnNlZDtcbiAgICBfYXNzZXJ0KHVzZXIudWlkID09PSBsb2NhbElkLCBhdXRoLCBBdXRoRXJyb3JDb2RlLlVTRVJfTUlTTUFUQ0gpO1xuXG4gICAgcmV0dXJuIFVzZXJDcmVkZW50aWFsSW1wbC5fZm9yT3BlcmF0aW9uKHVzZXIsIG9wZXJhdGlvblR5cGUsIHJlc3BvbnNlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENvbnZlcnQgdXNlciBkZWxldGVkIGVycm9yIGludG8gdXNlciBtaXNtYXRjaFxuICAgIGlmICgoZSBhcyBGaXJlYmFzZUVycm9yKT8uY29kZSA9PT0gYGF1dGgvJHtBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRH1gKSB7XG4gICAgICBfZmFpbChhdXRoLCBBdXRoRXJyb3JDb2RlLlVTRVJfTUlTTUFUQ0gpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbCwgQXV0aCwgVXNlciB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeSB9IGZyb20gJy4uLy4uL21mYS9tZmFfZXJyb3InO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IEF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi4vY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgX2Fzc2VydExpbmtlZFN0YXR1cywgX2xpbmsgfSBmcm9tICcuLi91c2VyL2xpbmtfdW5saW5rJztcbmltcG9ydCB7IF9yZWF1dGhlbnRpY2F0ZSB9IGZyb20gJy4uL3VzZXIvcmVhdXRoZW50aWNhdGUnO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbXBsIH0gZnJvbSAnLi4vdXNlci91c2VyX2NyZWRlbnRpYWxfaW1wbCc7XG5pbXBvcnQgeyBfY2FzdEF1dGggfSBmcm9tICcuLi9hdXRoL2F1dGhfaW1wbCc7XG5pbXBvcnQgeyBnZXRNb2R1bGFySW5zdGFuY2UgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3NpZ25JbldpdGhDcmVkZW50aWFsKFxuICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gIGNyZWRlbnRpYWw6IEF1dGhDcmVkZW50aWFsLFxuICBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZVxuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbD4ge1xuICBjb25zdCBvcGVyYXRpb25UeXBlID0gT3BlcmF0aW9uVHlwZS5TSUdOX0lOO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShcbiAgICBhdXRoLFxuICAgIG9wZXJhdGlvblR5cGUsXG4gICAgY3JlZGVudGlhbFxuICApO1xuICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShcbiAgICBhdXRoLFxuICAgIG9wZXJhdGlvblR5cGUsXG4gICAgcmVzcG9uc2VcbiAgKTtcblxuICBpZiAoIWJ5cGFzc0F1dGhTdGF0ZSkge1xuICAgIGF3YWl0IGF1dGguX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xuICB9XG4gIHJldHVybiB1c2VyQ3JlZGVudGlhbDtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBzaWducyBpbiB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy5cbiAqXG4gKiBAcmVtYXJrc1xuICogQW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNyZWRlbnRpYWwuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGNyZWRlbnRpYWwgLSBUaGUgYXV0aCBjcmVkZW50aWFsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDcmVkZW50aWFsKFxuICBhdXRoOiBBdXRoLFxuICBjcmVkZW50aWFsOiBBdXRoQ3JlZGVudGlhbFxuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbD4ge1xuICByZXR1cm4gX3NpZ25JbldpdGhDcmVkZW50aWFsKF9jYXN0QXV0aChhdXRoKSwgY3JlZGVudGlhbCk7XG59XG5cbi8qKlxuICogTGlua3MgdGhlIHVzZXIgYWNjb3VudCB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy5cbiAqXG4gKiBAcmVtYXJrc1xuICogQW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNyZWRlbnRpYWwuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGF1dGggY3JlZGVudGlhbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsaW5rV2l0aENyZWRlbnRpYWwoXG4gIHVzZXI6IFVzZXIsXG4gIGNyZWRlbnRpYWw6IEF1dGhDcmVkZW50aWFsXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsPiB7XG4gIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWw7XG5cbiAgYXdhaXQgX2Fzc2VydExpbmtlZFN0YXR1cyhmYWxzZSwgdXNlckludGVybmFsLCBjcmVkZW50aWFsLnByb3ZpZGVySWQpO1xuXG4gIHJldHVybiBfbGluayh1c2VySW50ZXJuYWwsIGNyZWRlbnRpYWwpO1xufVxuXG4vKipcbiAqIFJlLWF1dGhlbnRpY2F0ZXMgYSB1c2VyIHVzaW5nIGEgZnJlc2ggY3JlZGVudGlhbC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVXNlIGJlZm9yZSBvcGVyYXRpb25zIHN1Y2ggYXMge0BsaW5rIHVwZGF0ZVBhc3N3b3JkfSB0aGF0IHJlcXVpcmUgdG9rZW5zIGZyb20gcmVjZW50IHNpZ24taW5cbiAqIGF0dGVtcHRzLiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byByZWNvdmVyIGZyb20gYSBgQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOYCBlcnJvclxuICogb3IgYSBgVE9LRU5fRVhQSVJFRGAgZXJyb3IuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGF1dGggY3JlZGVudGlhbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsKFxuICB1c2VyOiBVc2VyLFxuICBjcmVkZW50aWFsOiBBdXRoQ3JlZGVudGlhbFxuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbD4ge1xuICByZXR1cm4gX3JlYXV0aGVudGljYXRlKGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWwsIGNyZWRlbnRpYWwpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRW5kcG9pbnQsXG4gIEh0dHBNZXRob2QsXG4gIF9hZGRUaWRJZk5lY2Vzc2FyeSxcbiAgX3BlcmZvcm1TaWduSW5SZXF1ZXN0XG59IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IEF1dGggfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25JbldpdGhDdXN0b21Ub2tlblJlcXVlc3Qge1xuICB0b2tlbjogc3RyaW5nO1xuICByZXR1cm5TZWN1cmVUb2tlbjogYm9vbGVhbjtcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbkluV2l0aEN1c3RvbVRva2VuUmVzcG9uc2UgZXh0ZW5kcyBJZFRva2VuUmVzcG9uc2Uge31cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDdXN0b21Ub2tlbihcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogU2lnbkluV2l0aEN1c3RvbVRva2VuUmVxdWVzdFxuKTogUHJvbWlzZTxTaWduSW5XaXRoQ3VzdG9tVG9rZW5SZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0PFxuICAgIFNpZ25JbldpdGhDdXN0b21Ub2tlblJlcXVlc3QsXG4gICAgU2lnbkluV2l0aEN1c3RvbVRva2VuUmVzcG9uc2VcbiAgPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5TSUdOX0lOX1dJVEhfQ1VTVE9NX1RPS0VOLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aCwgVXNlckNyZWRlbnRpYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBzaWduSW5XaXRoQ3VzdG9tVG9rZW4gYXMgZ2V0SWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL2N1c3RvbV90b2tlbic7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEltcGwgfSBmcm9tICcuLi91c2VyL3VzZXJfY3JlZGVudGlhbF9pbXBsJztcbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4uL2F1dGgvYXV0aF9pbXBsJztcbmltcG9ydCB7IE9wZXJhdGlvblR5cGUgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gdXNpbmcgYSBjdXN0b20gdG9rZW4uXG4gKlxuICogQHJlbWFya3NcbiAqIEN1c3RvbSB0b2tlbnMgYXJlIHVzZWQgdG8gaW50ZWdyYXRlIEZpcmViYXNlIEF1dGggd2l0aCBleGlzdGluZyBhdXRoIHN5c3RlbXMsIGFuZCBtdXN0XG4gKiBiZSBnZW5lcmF0ZWQgYnkgYW4gYXV0aCBiYWNrZW5kIHVzaW5nIHRoZVxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL3JlZmVyZW5jZS9hZG1pbi9ub2RlL2FkbWluLmF1dGguQXV0aCNjcmVhdGVjdXN0b210b2tlbiB8IGNyZWF0ZUN1c3RvbVRva2VufVxuICogbWV0aG9kIGluIHRoZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvYXV0aC9hZG1pbiB8IEFkbWluIFNES30gLlxuICpcbiAqIEZhaWxzIHdpdGggYW4gZXJyb3IgaWYgdGhlIHRva2VuIGlzIGludmFsaWQsIGV4cGlyZWQsIG9yIG5vdCBhY2NlcHRlZCBieSB0aGUgRmlyZWJhc2UgQXV0aCBzZXJ2aWNlLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBjdXN0b21Ub2tlbiAtIFRoZSBjdXN0b20gdG9rZW4gdG8gc2lnbiBpbiB3aXRoLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDdXN0b21Ub2tlbihcbiAgYXV0aDogQXV0aCxcbiAgY3VzdG9tVG9rZW46IHN0cmluZ1xuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbD4ge1xuICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gIGNvbnN0IHJlc3BvbnNlOiBJZFRva2VuUmVzcG9uc2UgPSBhd2FpdCBnZXRJZFRva2VuUmVzcG9uc2UoYXV0aEludGVybmFsLCB7XG4gICAgdG9rZW46IGN1c3RvbVRva2VuLFxuICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXG4gIH0pO1xuICBjb25zdCBjcmVkID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKFxuICAgIGF1dGhJbnRlcm5hbCxcbiAgICBPcGVyYXRpb25UeXBlLlNJR05fSU4sXG4gICAgcmVzcG9uc2VcbiAgKTtcbiAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVDdXJyZW50VXNlcihjcmVkLnVzZXIpO1xuICByZXR1cm4gY3JlZDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEZhY3RvcklkLFxuICBNdWx0aUZhY3RvckluZm8sXG4gIFBob25lTXVsdGlGYWN0b3JJbmZvLFxuICBUb3RwTXVsdGlGYWN0b3JJbmZvXG59IGZyb20gJy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQge1xuICBQaG9uZU1mYUVucm9sbG1lbnQsXG4gIE1mYUVucm9sbG1lbnQsXG4gIFRvdHBNZmFFbnJvbGxtZW50XG59IGZyb20gJy4uL2FwaS9hY2NvdW50X21hbmFnZW1lbnQvbWZhJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9jb3JlL2Vycm9ycyc7XG5pbXBvcnQgeyBfZmFpbCB9IGZyb20gJy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vbW9kZWwvYXV0aCc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNdWx0aUZhY3RvckluZm9JbXBsIGltcGxlbWVudHMgTXVsdGlGYWN0b3JJbmZvIHtcbiAgcmVhZG9ubHkgdWlkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGRpc3BsYXlOYW1lPzogc3RyaW5nIHwgbnVsbDtcbiAgcmVhZG9ubHkgZW5yb2xsbWVudFRpbWU6IHN0cmluZztcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IocmVhZG9ubHkgZmFjdG9ySWQ6IEZhY3RvcklkLCByZXNwb25zZTogTWZhRW5yb2xsbWVudCkge1xuICAgIHRoaXMudWlkID0gcmVzcG9uc2UubWZhRW5yb2xsbWVudElkO1xuICAgIHRoaXMuZW5yb2xsbWVudFRpbWUgPSBuZXcgRGF0ZShyZXNwb25zZS5lbnJvbGxlZEF0KS50b1VUQ1N0cmluZygpO1xuICAgIHRoaXMuZGlzcGxheU5hbWUgPSByZXNwb25zZS5kaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHN0YXRpYyBfZnJvbVNlcnZlclJlc3BvbnNlKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBlbnJvbGxtZW50OiBNZmFFbnJvbGxtZW50XG4gICk6IE11bHRpRmFjdG9ySW5mb0ltcGwge1xuICAgIGlmICgncGhvbmVJbmZvJyBpbiBlbnJvbGxtZW50KSB7XG4gICAgICByZXR1cm4gUGhvbmVNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCk7XG4gICAgfSBlbHNlIGlmICgndG90cEluZm8nIGluIGVucm9sbG1lbnQpIHtcbiAgICAgIHJldHVybiBUb3RwTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKGF1dGgsIGVucm9sbG1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gX2ZhaWwoYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBob25lTXVsdGlGYWN0b3JJbmZvSW1wbFxuICBleHRlbmRzIE11bHRpRmFjdG9ySW5mb0ltcGxcbiAgaW1wbGVtZW50cyBQaG9uZU11bHRpRmFjdG9ySW5mb1xue1xuICByZWFkb25seSBwaG9uZU51bWJlcjogc3RyaW5nO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IocmVzcG9uc2U6IFBob25lTWZhRW5yb2xsbWVudCkge1xuICAgIHN1cGVyKEZhY3RvcklkLlBIT05FLCByZXNwb25zZSk7XG4gICAgdGhpcy5waG9uZU51bWJlciA9IHJlc3BvbnNlLnBob25lSW5mbztcbiAgfVxuXG4gIHN0YXRpYyBfZnJvbVNlcnZlclJlc3BvbnNlKFxuICAgIF9hdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgZW5yb2xsbWVudDogTWZhRW5yb2xsbWVudFxuICApOiBQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwge1xuICAgIHJldHVybiBuZXcgUGhvbmVNdWx0aUZhY3RvckluZm9JbXBsKGVucm9sbG1lbnQgYXMgUGhvbmVNZmFFbnJvbGxtZW50KTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFRvdHBNdWx0aUZhY3RvckluZm9JbXBsXG4gIGV4dGVuZHMgTXVsdGlGYWN0b3JJbmZvSW1wbFxuICBpbXBsZW1lbnRzIFRvdHBNdWx0aUZhY3RvckluZm9cbntcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihyZXNwb25zZTogVG90cE1mYUVucm9sbG1lbnQpIHtcbiAgICBzdXBlcihGYWN0b3JJZC5UT1RQLCByZXNwb25zZSk7XG4gIH1cblxuICBzdGF0aWMgX2Zyb21TZXJ2ZXJSZXNwb25zZShcbiAgICBfYXV0aDogQXV0aEludGVybmFsLFxuICAgIGVucm9sbG1lbnQ6IE1mYUVucm9sbG1lbnRcbiAgKTogVG90cE11bHRpRmFjdG9ySW5mb0ltcGwge1xuICAgIHJldHVybiBuZXcgVG90cE11bHRpRmFjdG9ySW5mb0ltcGwoZW5yb2xsbWVudCBhcyBUb3RwTWZhRW5yb2xsbWVudCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEFjdGlvbkNvZGVTZXR0aW5ncywgQXV0aCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IEdldE9vYkNvZGVSZXF1ZXN0IH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL2VtYWlsX2FuZF9wYXNzd29yZCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBHZXRPb2JDb2RlUmVxdWVzdCxcbiAgYWN0aW9uQ29kZVNldHRpbmdzOiBBY3Rpb25Db2RlU2V0dGluZ3Ncbik6IHZvaWQge1xuICBfYXNzZXJ0KFxuICAgIGFjdGlvbkNvZGVTZXR0aW5ncy51cmw/Lmxlbmd0aCA+IDAsXG4gICAgYXV0aCxcbiAgICBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09OVElOVUVfVVJJXG4gICk7XG4gIF9hc3NlcnQoXG4gICAgdHlwZW9mIGFjdGlvbkNvZGVTZXR0aW5ncy5keW5hbWljTGlua0RvbWFpbiA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgIGFjdGlvbkNvZGVTZXR0aW5ncy5keW5hbWljTGlua0RvbWFpbi5sZW5ndGggPiAwLFxuICAgIGF1dGgsXG4gICAgQXV0aEVycm9yQ29kZS5JTlZBTElEX0RZTkFNSUNfTElOS19ET01BSU5cbiAgKTtcblxuICByZXF1ZXN0LmNvbnRpbnVlVXJsID0gYWN0aW9uQ29kZVNldHRpbmdzLnVybDtcbiAgcmVxdWVzdC5keW5hbWljTGlua0RvbWFpbiA9IGFjdGlvbkNvZGVTZXR0aW5ncy5keW5hbWljTGlua0RvbWFpbjtcbiAgcmVxdWVzdC5jYW5IYW5kbGVDb2RlSW5BcHAgPSBhY3Rpb25Db2RlU2V0dGluZ3MuaGFuZGxlQ29kZUluQXBwO1xuXG4gIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MuaU9TKSB7XG4gICAgX2Fzc2VydChcbiAgICAgIGFjdGlvbkNvZGVTZXR0aW5ncy5pT1MuYnVuZGxlSWQubGVuZ3RoID4gMCxcbiAgICAgIGF1dGgsXG4gICAgICBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfSU9TX0JVTkRMRV9JRFxuICAgICk7XG4gICAgcmVxdWVzdC5pT1NCdW5kbGVJZCA9IGFjdGlvbkNvZGVTZXR0aW5ncy5pT1MuYnVuZGxlSWQ7XG4gIH1cblxuICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQpIHtcbiAgICBfYXNzZXJ0KFxuICAgICAgYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQucGFja2FnZU5hbWUubGVuZ3RoID4gMCxcbiAgICAgIGF1dGgsXG4gICAgICBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUVcbiAgICApO1xuICAgIHJlcXVlc3QuYW5kcm9pZEluc3RhbGxBcHAgPSBhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5pbnN0YWxsQXBwO1xuICAgIHJlcXVlc3QuYW5kcm9pZE1pbmltdW1WZXJzaW9uQ29kZSA9XG4gICAgICBhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5taW5pbXVtVmVyc2lvbjtcbiAgICByZXF1ZXN0LmFuZHJvaWRQYWNrYWdlTmFtZSA9IGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkLnBhY2thZ2VOYW1lO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBBY3Rpb25Db2RlSW5mbyxcbiAgQWN0aW9uQ29kZU9wZXJhdGlvbixcbiAgQWN0aW9uQ29kZVNldHRpbmdzLFxuICBBdXRoLFxuICBVc2VyQ3JlZGVudGlhbFxufSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgKiBhcyBhY2NvdW50IGZyb20gJy4uLy4uL2FwaS9hY2NvdW50X21hbmFnZW1lbnQvZW1haWxfYW5kX3Bhc3N3b3JkJztcbmltcG9ydCAqIGFzIGF1dGhlbnRpY2F0aW9uIGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9lbWFpbF9hbmRfcGFzc3dvcmQnO1xuaW1wb3J0IHsgc2lnblVwLCBTaWduVXBSZXF1ZXN0IH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL3NpZ25fdXAnO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JJbmZvSW1wbCB9IGZyb20gJy4uLy4uL21mYS9tZmFfaW5mbyc7XG5pbXBvcnQgeyBFbWFpbEF1dGhQcm92aWRlciB9IGZyb20gJy4uL3Byb3ZpZGVycy9lbWFpbCc7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEltcGwgfSBmcm9tICcuLi91c2VyL3VzZXJfY3JlZGVudGlhbF9pbXBsJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0IH0gZnJvbSAnLi9hY3Rpb25fY29kZV9zZXR0aW5ncyc7XG5pbXBvcnQgeyBzaWduSW5XaXRoQ3JlZGVudGlhbCB9IGZyb20gJy4vY3JlZGVudGlhbCc7XG5pbXBvcnQgeyBfY2FzdEF1dGggfSBmcm9tICcuLi9hdXRoL2F1dGhfaW1wbCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IE9wZXJhdGlvblR5cGUgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5pbXBvcnQgeyBpbmplY3RSZWNhcHRjaGFGaWVsZHMgfSBmcm9tICcuLi8uLi9wbGF0Zm9ybV9icm93c2VyL3JlY2FwdGNoYS9yZWNhcHRjaGFfZW50ZXJwcmlzZV92ZXJpZmllcic7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBSZWNhcHRjaGFBY3Rpb25OYW1lLCBSZWNhcHRjaGFDbGllbnRUeXBlIH0gZnJvbSAnLi4vLi4vYXBpJztcblxuLyoqXG4gKiBTZW5kcyBhIHBhc3N3b3JkIHJlc2V0IGVtYWlsIHRvIHRoZSBnaXZlbiBlbWFpbCBhZGRyZXNzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUbyBjb21wbGV0ZSB0aGUgcGFzc3dvcmQgcmVzZXQsIGNhbGwge0BsaW5rIGNvbmZpcm1QYXNzd29yZFJlc2V0fSB3aXRoIHRoZSBjb2RlIHN1cHBsaWVkIGluXG4gKiB0aGUgZW1haWwgc2VudCB0byB0aGUgdXNlciwgYWxvbmcgd2l0aCB0aGUgbmV3IHBhc3N3b3JkIHNwZWNpZmllZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXG4gKiAgIGlPUzoge1xuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcbiAqICAgfSxcbiAqICAgYW5kcm9pZDoge1xuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xuICogICB9LFxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcbiAqIH07XG4gKiBhd2FpdCBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAqIC8vIE9idGFpbiBjb2RlIGZyb20gdXNlci5cbiAqIGF3YWl0IGNvbmZpcm1QYXNzd29yZFJlc2V0KCd1c2VyQGV4YW1wbGUuY29tJywgY29kZSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0gYWN0aW9uQ29kZVNldHRpbmdzIC0gVGhlIHtAbGluayBBY3Rpb25Db2RlU2V0dGluZ3N9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRQYXNzd29yZFJlc2V0RW1haWwoXG4gIGF1dGg6IEF1dGgsXG4gIGVtYWlsOiBzdHJpbmcsXG4gIGFjdGlvbkNvZGVTZXR0aW5ncz86IEFjdGlvbkNvZGVTZXR0aW5nc1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgY29uc3QgcmVxdWVzdDogYXV0aGVudGljYXRpb24uUGFzc3dvcmRSZXNldFJlcXVlc3QgPSB7XG4gICAgcmVxdWVzdFR5cGU6IEFjdGlvbkNvZGVPcGVyYXRpb24uUEFTU1dPUkRfUkVTRVQsXG4gICAgZW1haWwsXG4gICAgY2xpZW50VHlwZTogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUJcbiAgfTtcbiAgaWYgKGF1dGhJbnRlcm5hbC5fZ2V0UmVjYXB0Y2hhQ29uZmlnKCk/LmVtYWlsUGFzc3dvcmRFbmFibGVkKSB7XG4gICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoXG4gICAgICBhdXRoSW50ZXJuYWwsXG4gICAgICByZXF1ZXN0LFxuICAgICAgUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KFxuICAgICAgICBhdXRoSW50ZXJuYWwsXG4gICAgICAgIHJlcXVlc3RXaXRoUmVjYXB0Y2hhLFxuICAgICAgICBhY3Rpb25Db2RlU2V0dGluZ3NcbiAgICAgICk7XG4gICAgfVxuICAgIGF3YWl0IGF1dGhlbnRpY2F0aW9uLnNlbmRQYXNzd29yZFJlc2V0RW1haWwoXG4gICAgICBhdXRoSW50ZXJuYWwsXG4gICAgICByZXF1ZXN0V2l0aFJlY2FwdGNoYVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChcbiAgICAgICAgYXV0aEludGVybmFsLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBhY3Rpb25Db2RlU2V0dGluZ3NcbiAgICAgICk7XG4gICAgfVxuICAgIGF3YWl0IGF1dGhlbnRpY2F0aW9uXG4gICAgICAuc2VuZFBhc3N3b3JkUmVzZXRFbWFpbChhdXRoSW50ZXJuYWwsIHJlcXVlc3QpXG4gICAgICAuY2F0Y2goYXN5bmMgZXJyb3IgPT4ge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOfWApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICdQYXNzd29yZCByZXNldHMgYXJlIHByb3RlY3RlZCBieSByZUNBUFRDSEEgZm9yIHRoaXMgcHJvamVjdC4gQXV0b21hdGljYWxseSB0cmlnZ2VyaW5nIHRoZSByZUNBUFRDSEEgZmxvdyBhbmQgcmVzdGFydGluZyB0aGUgcGFzc3dvcmQgcmVzZXQgZmxvdy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhcbiAgICAgICAgICAgIGF1dGhJbnRlcm5hbCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBSZWNhcHRjaGFBY3Rpb25OYW1lLkdFVF9PT0JfQ09ERSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QoXG4gICAgICAgICAgICAgIGF1dGhJbnRlcm5hbCxcbiAgICAgICAgICAgICAgcmVxdWVzdFdpdGhSZWNhcHRjaGEsXG4gICAgICAgICAgICAgIGFjdGlvbkNvZGVTZXR0aW5nc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgYXV0aGVudGljYXRpb24uc2VuZFBhc3N3b3JkUmVzZXRFbWFpbChcbiAgICAgICAgICAgIGF1dGhJbnRlcm5hbCxcbiAgICAgICAgICAgIHJlcXVlc3RXaXRoUmVjYXB0Y2hhXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBsZXRlcyB0aGUgcGFzc3dvcmQgcmVzZXQgcHJvY2VzcywgZ2l2ZW4gYSBjb25maXJtYXRpb24gY29kZSBhbmQgbmV3IHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvb2JDb2RlIC0gQSBjb25maXJtYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxuICogQHBhcmFtIG5ld1Bhc3N3b3JkIC0gVGhlIG5ldyBwYXNzd29yZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25maXJtUGFzc3dvcmRSZXNldChcbiAgYXV0aDogQXV0aCxcbiAgb29iQ29kZTogc3RyaW5nLFxuICBuZXdQYXNzd29yZDogc3RyaW5nXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgYWNjb3VudC5yZXNldFBhc3N3b3JkKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwge1xuICAgIG9vYkNvZGUsXG4gICAgbmV3UGFzc3dvcmRcbiAgfSk7XG4gIC8vIERvIG5vdCByZXR1cm4gdGhlIGVtYWlsLlxufVxuXG4vKipcbiAqIEFwcGxpZXMgYSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gb29iQ29kZSAtIEEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhcHBseUFjdGlvbkNvZGUoXG4gIGF1dGg6IEF1dGgsXG4gIG9vYkNvZGU6IHN0cmluZ1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IGFjY291bnQuYXBwbHlBY3Rpb25Db2RlKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgeyBvb2JDb2RlIH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIgYnkgZW1haWwgb3Igb3RoZXIgb3V0LW9mLWJhbmQgbWVjaGFuaXNtLlxuICpcbiAqIEByZXR1cm5zIG1ldGFkYXRhIGFib3V0IHRoZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvb2JDb2RlIC0gQSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrQWN0aW9uQ29kZShcbiAgYXV0aDogQXV0aCxcbiAgb29iQ29kZTogc3RyaW5nXG4pOiBQcm9taXNlPEFjdGlvbkNvZGVJbmZvPiB7XG4gIGNvbnN0IGF1dGhNb2R1bGFyID0gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFjY291bnQucmVzZXRQYXNzd29yZChhdXRoTW9kdWxhciwgeyBvb2JDb2RlIH0pO1xuXG4gIC8vIEVtYWlsIGNvdWxkIGJlIGVtcHR5IG9ubHkgaWYgdGhlIHJlcXVlc3QgdHlwZSBpcyBFTUFJTF9TSUdOSU4gb3JcbiAgLy8gVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwuXG4gIC8vIE5ldyBlbWFpbCBzaG91bGQgbm90IGJlIGVtcHR5IGlmIHRoZSByZXF1ZXN0IHR5cGUgaXNcbiAgLy8gVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwuXG4gIC8vIE11bHRpLWZhY3RvciBpbmZvIGNvdWxkIG5vdCBiZSBlbXB0eSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzXG4gIC8vIFJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OLlxuICBjb25zdCBvcGVyYXRpb24gPSByZXNwb25zZS5yZXF1ZXN0VHlwZTtcbiAgX2Fzc2VydChvcGVyYXRpb24sIGF1dGhNb2R1bGFyLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgc3dpdGNoIChvcGVyYXRpb24pIHtcbiAgICBjYXNlIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMOlxuICAgICAgX2Fzc2VydChyZXNwb25zZS5uZXdFbWFpbCwgYXV0aE1vZHVsYXIsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBY3Rpb25Db2RlT3BlcmF0aW9uLlJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OOlxuICAgICAgX2Fzc2VydChyZXNwb25zZS5tZmFJbmZvLCBhdXRoTW9kdWxhciwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgZGVmYXVsdDpcbiAgICAgIF9hc3NlcnQocmVzcG9uc2UuZW1haWwsIGF1dGhNb2R1bGFyLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgfVxuXG4gIC8vIFRoZSBtdWx0aS1mYWN0b3IgaW5mbyBmb3IgcmV2ZXJ0IHNlY29uZCBmYWN0b3IgYWRkaXRpb25cbiAgbGV0IG11bHRpRmFjdG9ySW5mbzogTXVsdGlGYWN0b3JJbmZvSW1wbCB8IG51bGwgPSBudWxsO1xuICBpZiAocmVzcG9uc2UubWZhSW5mbykge1xuICAgIG11bHRpRmFjdG9ySW5mbyA9IE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShcbiAgICAgIF9jYXN0QXV0aChhdXRoTW9kdWxhciksXG4gICAgICByZXNwb25zZS5tZmFJbmZvXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGF0YToge1xuICAgICAgZW1haWw6XG4gICAgICAgIChyZXNwb25zZS5yZXF1ZXN0VHlwZSA9PT0gQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTFxuICAgICAgICAgID8gcmVzcG9uc2UubmV3RW1haWxcbiAgICAgICAgICA6IHJlc3BvbnNlLmVtYWlsKSB8fCBudWxsLFxuICAgICAgcHJldmlvdXNFbWFpbDpcbiAgICAgICAgKHJlc3BvbnNlLnJlcXVlc3RUeXBlID09PSBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXG4gICAgICAgICAgPyByZXNwb25zZS5lbWFpbFxuICAgICAgICAgIDogcmVzcG9uc2UubmV3RW1haWwpIHx8IG51bGwsXG4gICAgICBtdWx0aUZhY3RvckluZm9cbiAgICB9LFxuICAgIG9wZXJhdGlvblxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBhIHBhc3N3b3JkIHJlc2V0IGNvZGUgc2VudCB0byB0aGUgdXNlciBieSBlbWFpbCBvciBvdGhlciBvdXQtb2YtYmFuZCBtZWNoYW5pc20uXG4gKlxuICogQHJldHVybnMgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzIGlmIHZhbGlkLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBjb2RlIC0gQSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlKFxuICBhdXRoOiBBdXRoLFxuICBjb2RlOiBzdHJpbmdcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgY2hlY2tBY3Rpb25Db2RlKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgY29kZSk7XG4gIC8vIEVtYWlsIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBzaW5jZSBhIGNvZGUgd2FzIHNlbnQgdG8gaXRcbiAgcmV0dXJuIGRhdGEuZW1haWwhO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdXNlciBhY2NvdW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGVtYWlsIGFkZHJlc3MgYW5kIHBhc3N3b3JkLlxuICpcbiAqIEByZW1hcmtzXG4gKiBPbiBzdWNjZXNzZnVsIGNyZWF0aW9uIG9mIHRoZSB1c2VyIGFjY291bnQsIHRoaXMgdXNlciB3aWxsIGFsc28gYmUgc2lnbmVkIGluIHRvIHlvdXIgYXBwbGljYXRpb24uXG4gKlxuICogVXNlciBhY2NvdW50IGNyZWF0aW9uIGNhbiBmYWlsIGlmIHRoZSBhY2NvdW50IGFscmVhZHkgZXhpc3RzIG9yIHRoZSBwYXNzd29yZCBpcyBpbnZhbGlkLlxuICpcbiAqIE5vdGU6IFRoZSBlbWFpbCBhZGRyZXNzIGFjdHMgYXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHVzZXIgYW5kIGVuYWJsZXMgYW4gZW1haWwtYmFzZWRcbiAqIHBhc3N3b3JkIHJlc2V0LiBUaGlzIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgbmV3IHVzZXIgYWNjb3VudCBhbmQgc2V0IHRoZSBpbml0aWFsIHVzZXIgcGFzc3dvcmQuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHVzZXIncyBjaG9zZW4gcGFzc3dvcmQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkKFxuICBhdXRoOiBBdXRoLFxuICBlbWFpbDogc3RyaW5nLFxuICBwYXNzd29yZDogc3RyaW5nXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsPiB7XG4gIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgY29uc3QgcmVxdWVzdDogU2lnblVwUmVxdWVzdCA9IHtcbiAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcbiAgICBlbWFpbCxcbiAgICBwYXNzd29yZCxcbiAgICBjbGllbnRUeXBlOiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQlxuICB9O1xuICBsZXQgc2lnblVwUmVzcG9uc2U6IFByb21pc2U8SWRUb2tlblJlc3BvbnNlPjtcbiAgaWYgKGF1dGhJbnRlcm5hbC5fZ2V0UmVjYXB0Y2hhQ29uZmlnKCk/LmVtYWlsUGFzc3dvcmRFbmFibGVkKSB7XG4gICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoXG4gICAgICBhdXRoSW50ZXJuYWwsXG4gICAgICByZXF1ZXN0LFxuICAgICAgUmVjYXB0Y2hhQWN0aW9uTmFtZS5TSUdOX1VQX1BBU1NXT1JEXG4gICAgKTtcbiAgICBzaWduVXBSZXNwb25zZSA9IHNpZ25VcChhdXRoSW50ZXJuYWwsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcbiAgfSBlbHNlIHtcbiAgICBzaWduVXBSZXNwb25zZSA9IHNpZ25VcChhdXRoSW50ZXJuYWwsIHJlcXVlc3QpLmNhdGNoKGFzeW5jIGVycm9yID0+IHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke0F1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU59YCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAnU2lnbi11cCBpcyBwcm90ZWN0ZWQgYnkgcmVDQVBUQ0hBIGZvciB0aGlzIHByb2plY3QuIEF1dG9tYXRpY2FsbHkgdHJpZ2dlcmluZyB0aGUgcmVDQVBUQ0hBIGZsb3cgYW5kIHJlc3RhcnRpbmcgdGhlIHNpZ24tdXAgZmxvdy4nXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKFxuICAgICAgICAgIGF1dGhJbnRlcm5hbCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9VUF9QQVNTV09SRFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gc2lnblVwKGF1dGhJbnRlcm5hbCwgcmVxdWVzdFdpdGhSZWNhcHRjaGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2lnblVwUmVzcG9uc2UuY2F0Y2goZXJyb3IgPT4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH0pO1xuXG4gIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKFxuICAgIGF1dGhJbnRlcm5hbCxcbiAgICBPcGVyYXRpb25UeXBlLlNJR05fSU4sXG4gICAgcmVzcG9uc2VcbiAgKTtcbiAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVDdXJyZW50VXNlcih1c2VyQ3JlZGVudGlhbC51c2VyKTtcblxuICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gdXNpbmcgYW4gZW1haWwgYW5kIHBhc3N3b3JkLlxuICpcbiAqIEByZW1hcmtzXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSBlbWFpbCBhZGRyZXNzIGFuZCBwYXNzd29yZCBkbyBub3QgbWF0Y2guXG4gKlxuICogTm90ZTogVGhlIHVzZXIncyBwYXNzd29yZCBpcyBOT1QgdGhlIHBhc3N3b3JkIHVzZWQgdG8gYWNjZXNzIHRoZSB1c2VyJ3MgZW1haWwgYWNjb3VudC4gVGhlXG4gKiBlbWFpbCBhZGRyZXNzIHNlcnZlcyBhcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdXNlciwgYW5kIHRoZSBwYXNzd29yZCBpcyB1c2VkIHRvIGFjY2Vzc1xuICogdGhlIHVzZXIncyBhY2NvdW50IGluIHlvdXIgRmlyZWJhc2UgcHJvamVjdC4gU2VlIGFsc286IHtAbGluayBjcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmR9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VycyBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHVzZXJzIHBhc3N3b3JkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkKFxuICBhdXRoOiBBdXRoLFxuICBlbWFpbDogc3RyaW5nLFxuICBwYXNzd29yZDogc3RyaW5nXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsPiB7XG4gIHJldHVybiBzaWduSW5XaXRoQ3JlZGVudGlhbChcbiAgICBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksXG4gICAgRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQpXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBBY3Rpb25Db2RlT3BlcmF0aW9uLFxuICBBY3Rpb25Db2RlU2V0dGluZ3MsXG4gIEF1dGgsXG4gIFVzZXJDcmVkZW50aWFsXG59IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCAqIGFzIGFwaSBmcm9tICcuLi8uLi9hcGkvYXV0aGVudGljYXRpb24vZW1haWxfYW5kX3Bhc3N3b3JkJztcbmltcG9ydCB7IEFjdGlvbkNvZGVVUkwgfSBmcm9tICcuLi9hY3Rpb25fY29kZV91cmwnO1xuaW1wb3J0IHsgRW1haWxBdXRoUHJvdmlkZXIgfSBmcm9tICcuLi9wcm92aWRlcnMvZW1haWwnO1xuaW1wb3J0IHsgX2dldEN1cnJlbnRVcmwgfSBmcm9tICcuLi91dGlsL2xvY2F0aW9uJztcbmltcG9ydCB7IF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QgfSBmcm9tICcuL2FjdGlvbl9jb2RlX3NldHRpbmdzJztcbmltcG9ydCB7IHNpZ25JbldpdGhDcmVkZW50aWFsIH0gZnJvbSAnLi9jcmVkZW50aWFsJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4uL2F1dGgvYXV0aF9pbXBsJztcbmltcG9ydCB7IGluamVjdFJlY2FwdGNoYUZpZWxkcyB9IGZyb20gJy4uLy4uL3BsYXRmb3JtX2Jyb3dzZXIvcmVjYXB0Y2hhL3JlY2FwdGNoYV9lbnRlcnByaXNlX3ZlcmlmaWVyJztcbmltcG9ydCB7IFJlY2FwdGNoYUFjdGlvbk5hbWUsIFJlY2FwdGNoYUNsaWVudFR5cGUgfSBmcm9tICcuLi8uLi9hcGknO1xuXG4vKipcbiAqIFNlbmRzIGEgc2lnbi1pbiBlbWFpbCBsaW5rIHRvIHRoZSB1c2VyIHdpdGggdGhlIHNwZWNpZmllZCBlbWFpbC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHNpZ24taW4gb3BlcmF0aW9uIGhhcyB0byBhbHdheXMgYmUgY29tcGxldGVkIGluIHRoZSBhcHAgdW5saWtlIG90aGVyIG91dCBvZiBiYW5kIGVtYWlsXG4gKiBhY3Rpb25zIChwYXNzd29yZCByZXNldCBhbmQgZW1haWwgdmVyaWZpY2F0aW9ucykuIFRoaXMgaXMgYmVjYXVzZSwgYXQgdGhlIGVuZCBvZiB0aGUgZmxvdyxcbiAqIHRoZSB1c2VyIGlzIGV4cGVjdGVkIHRvIGJlIHNpZ25lZCBpbiBhbmQgdGhlaXIgQXV0aCBzdGF0ZSBwZXJzaXN0ZWQgd2l0aGluIHRoZSBhcHAuXG4gKlxuICogVG8gY29tcGxldGUgc2lnbiBpbiB3aXRoIHRoZSBlbWFpbCBsaW5rLCBjYWxsIHtAbGluayBzaWduSW5XaXRoRW1haWxMaW5rfSB3aXRoIHRoZSBlbWFpbFxuICogYWRkcmVzcyBhbmQgdGhlIGVtYWlsIGxpbmsgc3VwcGxpZWQgaW4gdGhlIGVtYWlsIHNlbnQgdG8gdGhlIHVzZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcbiAqICAgdXJsOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vP2VtYWlsPXVzZXJAZXhhbXBsZS5jb20nLFxuICogICBpT1M6IHtcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXG4gKiAgIH0sXG4gKiAgIGFuZHJvaWQ6IHtcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxuICogICAgIGluc3RhbGxBcHA6IHRydWUsXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcbiAqICAgfSxcbiAqICAgaGFuZGxlQ29kZUluQXBwOiB0cnVlXG4gKiB9O1xuICogYXdhaXQgc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAqIC8vIE9idGFpbiBlbWFpbExpbmsgZnJvbSB0aGUgdXNlci5cbiAqIGlmKGlzU2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbExpbmspKSB7XG4gKiAgIGF3YWl0IHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBlbWFpbExpbmspO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhJbnRlcm5hbCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0gYWN0aW9uQ29kZVNldHRpbmdzIC0gVGhlIHtAbGluayBBY3Rpb25Db2RlU2V0dGluZ3N9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRTaWduSW5MaW5rVG9FbWFpbChcbiAgYXV0aDogQXV0aCxcbiAgZW1haWw6IHN0cmluZyxcbiAgYWN0aW9uQ29kZVNldHRpbmdzOiBBY3Rpb25Db2RlU2V0dGluZ3Ncbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gIGNvbnN0IHJlcXVlc3Q6IGFwaS5FbWFpbFNpZ25JblJlcXVlc3QgPSB7XG4gICAgcmVxdWVzdFR5cGU6IEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOLFxuICAgIGVtYWlsLFxuICAgIGNsaWVudFR5cGU6IFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCXG4gIH07XG4gIGZ1bmN0aW9uIHNldEFjdGlvbkNvZGVTZXR0aW5ncyhcbiAgICByZXF1ZXN0OiBhcGkuRW1haWxTaWduSW5SZXF1ZXN0LFxuICAgIGFjdGlvbkNvZGVTZXR0aW5nczogQWN0aW9uQ29kZVNldHRpbmdzXG4gICk6IHZvaWQge1xuICAgIF9hc3NlcnQoXG4gICAgICBhY3Rpb25Db2RlU2V0dGluZ3MuaGFuZGxlQ29kZUluQXBwLFxuICAgICAgYXV0aEludGVybmFsLFxuICAgICAgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUlxuICAgICk7XG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChcbiAgICAgICAgYXV0aEludGVybmFsLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBhY3Rpb25Db2RlU2V0dGluZ3NcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChhdXRoSW50ZXJuYWwuX2dldFJlY2FwdGNoYUNvbmZpZygpPy5lbWFpbFBhc3N3b3JkRW5hYmxlZCkge1xuICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKFxuICAgICAgYXV0aEludGVybmFsLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgc2V0QWN0aW9uQ29kZVNldHRpbmdzKHJlcXVlc3RXaXRoUmVjYXB0Y2hhLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICAgIGF3YWl0IGFwaS5zZW5kU2lnbkluTGlua1RvRW1haWwoYXV0aEludGVybmFsLCByZXF1ZXN0V2l0aFJlY2FwdGNoYSk7XG4gIH0gZWxzZSB7XG4gICAgc2V0QWN0aW9uQ29kZVNldHRpbmdzKHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gICAgYXdhaXQgYXBpXG4gICAgICAuc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGhJbnRlcm5hbCwgcmVxdWVzdClcbiAgICAgIC5jYXRjaChhc3luYyBlcnJvciA9PiB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke0F1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU59YCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgJ0VtYWlsIGxpbmsgc2lnbi1pbiBpcyBwcm90ZWN0ZWQgYnkgcmVDQVBUQ0hBIGZvciB0aGlzIHByb2plY3QuIEF1dG9tYXRpY2FsbHkgdHJpZ2dlcmluZyB0aGUgcmVDQVBUQ0hBIGZsb3cgYW5kIHJlc3RhcnRpbmcgdGhlIHNpZ24taW4gZmxvdy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhcbiAgICAgICAgICAgIGF1dGhJbnRlcm5hbCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBSZWNhcHRjaGFBY3Rpb25OYW1lLkdFVF9PT0JfQ09ERSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldEFjdGlvbkNvZGVTZXR0aW5ncyhyZXF1ZXN0V2l0aFJlY2FwdGNoYSwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAgICAgICAgICBhd2FpdCBhcGkuc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGhJbnRlcm5hbCwgcmVxdWVzdFdpdGhSZWNhcHRjaGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGluY29taW5nIGxpbmsgaXMgYSBzaWduLWluIHdpdGggZW1haWwgbGluayBzdWl0YWJsZSBmb3Ige0BsaW5rIHNpZ25JbldpdGhFbWFpbExpbmt9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbExpbmsgLSBUaGUgbGluayBzZW50IHRvIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NpZ25JbldpdGhFbWFpbExpbmsoYXV0aDogQXV0aCwgZW1haWxMaW5rOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgYWN0aW9uQ29kZVVybCA9IEFjdGlvbkNvZGVVUkwucGFyc2VMaW5rKGVtYWlsTGluayk7XG4gIHJldHVybiBhY3Rpb25Db2RlVXJsPy5vcGVyYXRpb24gPT09IEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOO1xufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHVzaW5nIGFuIGVtYWlsIGFuZCBzaWduLWluIGVtYWlsIGxpbmsuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIG5vIGxpbmsgaXMgcGFzc2VkLCB0aGUgbGluayBpcyBpbmZlcnJlZCBmcm9tIHRoZSBjdXJyZW50IFVSTC5cbiAqXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSBlbWFpbCBhZGRyZXNzIGlzIGludmFsaWQgb3IgT1RQIGluIGVtYWlsIGxpbmsgZXhwaXJlcy5cbiAqXG4gKiBOb3RlOiBDb25maXJtIHRoZSBsaW5rIGlzIGEgc2lnbi1pbiBlbWFpbCBsaW5rIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kIGZpcmViYXNlLmF1dGguQXV0aC5pc1NpZ25JbldpdGhFbWFpbExpbmsuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcbiAqICAgdXJsOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vP2VtYWlsPXVzZXJAZXhhbXBsZS5jb20nLFxuICogICBpT1M6IHtcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXG4gKiAgIH0sXG4gKiAgIGFuZHJvaWQ6IHtcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxuICogICAgIGluc3RhbGxBcHA6IHRydWUsXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcbiAqICAgfSxcbiAqICAgaGFuZGxlQ29kZUluQXBwOiB0cnVlXG4gKiB9O1xuICogYXdhaXQgc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAqIC8vIE9idGFpbiBlbWFpbExpbmsgZnJvbSB0aGUgdXNlci5cbiAqIGlmKGlzU2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbExpbmspKSB7XG4gKiAgIGF3YWl0IHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBlbWFpbExpbmspO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIGVtYWlsTGluayAtIFRoZSBsaW5rIHNlbnQgdG8gdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbExpbmsoXG4gIGF1dGg6IEF1dGgsXG4gIGVtYWlsOiBzdHJpbmcsXG4gIGVtYWlsTGluaz86IHN0cmluZ1xuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbD4ge1xuICBjb25zdCBhdXRoTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcbiAgY29uc3QgY3JlZGVudGlhbCA9IEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxXaXRoTGluayhcbiAgICBlbWFpbCxcbiAgICBlbWFpbExpbmsgfHwgX2dldEN1cnJlbnRVcmwoKVxuICApO1xuICAvLyBDaGVjayBpZiB0aGUgdGVuYW50IElEIGluIHRoZSBlbWFpbCBsaW5rIG1hdGNoZXMgdGhlIHRlbmFudCBJRCBvbiBBdXRoXG4gIC8vIGluc3RhbmNlLlxuICBfYXNzZXJ0KFxuICAgIGNyZWRlbnRpYWwuX3RlbmFudElkID09PSAoYXV0aE1vZHVsYXIudGVuYW50SWQgfHwgbnVsbCksXG4gICAgYXV0aE1vZHVsYXIsXG4gICAgQXV0aEVycm9yQ29kZS5URU5BTlRfSURfTUlTTUFUQ0hcbiAgKTtcbiAgcmV0dXJuIHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGhNb2R1bGFyLCBjcmVkZW50aWFsKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEVuZHBvaW50LFxuICBIdHRwTWV0aG9kLFxuICBfYWRkVGlkSWZOZWNlc3NhcnksXG4gIF9wZXJmb3JtQXBpUmVxdWVzdFxufSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVBdXRoVXJpUmVxdWVzdCB7XG4gIGlkZW50aWZpZXI6IHN0cmluZztcbiAgY29udGludWVVcmk6IHN0cmluZztcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQXV0aFVyaVJlc3BvbnNlIHtcbiAgc2lnbmluTWV0aG9kczogc3RyaW5nW107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVBdXRoVXJpKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBDcmVhdGVBdXRoVXJpUmVxdWVzdFxuKTogUHJvbWlzZTxDcmVhdGVBdXRoVXJpUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxDcmVhdGVBdXRoVXJpUmVxdWVzdCwgQ3JlYXRlQXV0aFVyaVJlc3BvbnNlPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5DUkVBVEVfQVVUSF9VUkksXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBBY3Rpb25Db2RlT3BlcmF0aW9uLFxuICBBY3Rpb25Db2RlU2V0dGluZ3MsXG4gIEF1dGgsXG4gIFVzZXJcbn0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlQXV0aFVyaSxcbiAgQ3JlYXRlQXV0aFVyaVJlcXVlc3Rcbn0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL2NyZWF0ZV9hdXRoX3VyaSc7XG5pbXBvcnQgKiBhcyBhcGkgZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL2VtYWlsX2FuZF9wYXNzd29yZCc7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IF9nZXRDdXJyZW50VXJsLCBfaXNIdHRwT3JIdHRwcyB9IGZyb20gJy4uL3V0aWwvbG9jYXRpb24nO1xuaW1wb3J0IHsgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdCB9IGZyb20gJy4vYWN0aW9uX2NvZGVfc2V0dGluZ3MnO1xuaW1wb3J0IHsgZ2V0TW9kdWxhckluc3RhbmNlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3Qgb2YgcG9zc2libGUgc2lnbiBpbiBtZXRob2RzIGZvciB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBpcyB1c2VmdWwgdG8gZGlmZmVyZW50aWF0ZSBtZXRob2RzIG9mIHNpZ24taW4gZm9yIHRoZSBzYW1lIHByb3ZpZGVyLCBlZy5cbiAqIHtAbGluayBFbWFpbEF1dGhQcm92aWRlcn0gd2hpY2ggaGFzIDIgbWV0aG9kcyBvZiBzaWduLWluLFxuICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQgYW5kXG4gKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbChcbiAgYXV0aDogQXV0aCxcbiAgZW1haWw6IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAvLyBjcmVhdGVBdXRoVXJpIHJldHVybnMgYW4gZXJyb3IgaWYgY29udGludWUgVVJJIGlzIG5vdCBodHRwIG9yIGh0dHBzLlxuICAvLyBGb3IgZW52aXJvbm1lbnRzIGxpa2UgQ29yZG92YSwgQ2hyb21lIGV4dGVuc2lvbnMsIG5hdGl2ZSBmcmFtZXdvcmtzLCBmaWxlXG4gIC8vIHN5c3RlbXMsIGV0YywgdXNlIGh0dHA6Ly9sb2NhbGhvc3QgYXMgY29udGludWUgVVJMLlxuICBjb25zdCBjb250aW51ZVVyaSA9IF9pc0h0dHBPckh0dHBzKCkgPyBfZ2V0Q3VycmVudFVybCgpIDogJ2h0dHA6Ly9sb2NhbGhvc3QnO1xuICBjb25zdCByZXF1ZXN0OiBDcmVhdGVBdXRoVXJpUmVxdWVzdCA9IHtcbiAgICBpZGVudGlmaWVyOiBlbWFpbCxcbiAgICBjb250aW51ZVVyaVxuICB9O1xuXG4gIGNvbnN0IHsgc2lnbmluTWV0aG9kcyB9ID0gYXdhaXQgY3JlYXRlQXV0aFVyaShcbiAgICBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksXG4gICAgcmVxdWVzdFxuICApO1xuXG4gIHJldHVybiBzaWduaW5NZXRob2RzIHx8IFtdO1xufVxuXG4vKipcbiAqIFNlbmRzIGEgdmVyaWZpY2F0aW9uIGVtYWlsIHRvIGEgdXNlci5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzIGlzIGNvbXBsZXRlZCBieSBjYWxsaW5nIHtAbGluayBhcHBseUFjdGlvbkNvZGV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHNlbmRFbWFpbFZlcmlmaWNhdGlvbih1c2VyLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICogLy8gT2J0YWluIGNvZGUgZnJvbSB0aGUgdXNlci5cbiAqIGF3YWl0IGFwcGx5QWN0aW9uQ29kZShhdXRoLCBjb2RlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gYWN0aW9uQ29kZVNldHRpbmdzIC0gVGhlIHtAbGluayBBY3Rpb25Db2RlU2V0dGluZ3N9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRFbWFpbFZlcmlmaWNhdGlvbihcbiAgdXNlcjogVXNlcixcbiAgYWN0aW9uQ29kZVNldHRpbmdzPzogQWN0aW9uQ29kZVNldHRpbmdzIHwgbnVsbFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWw7XG4gIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcbiAgY29uc3QgcmVxdWVzdDogYXBpLlZlcmlmeUVtYWlsUmVxdWVzdCA9IHtcbiAgICByZXF1ZXN0VHlwZTogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfRU1BSUwsXG4gICAgaWRUb2tlblxuICB9O1xuICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChcbiAgICAgIHVzZXJJbnRlcm5hbC5hdXRoLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGFjdGlvbkNvZGVTZXR0aW5nc1xuICAgICk7XG4gIH1cblxuICBjb25zdCB7IGVtYWlsIH0gPSBhd2FpdCBhcGkuc2VuZEVtYWlsVmVyaWZpY2F0aW9uKHVzZXJJbnRlcm5hbC5hdXRoLCByZXF1ZXN0KTtcblxuICBpZiAoZW1haWwgIT09IHVzZXIuZW1haWwpIHtcbiAgICBhd2FpdCB1c2VyLnJlbG9hZCgpO1xuICB9XG59XG5cbi8qKlxuICogU2VuZHMgYSB2ZXJpZmljYXRpb24gZW1haWwgdG8gYSBuZXcgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHVzZXIncyBlbWFpbCB3aWxsIGJlIHVwZGF0ZWQgdG8gdGhlIG5ldyBvbmUgYWZ0ZXIgYmVpbmcgdmVyaWZpZWQuXG4gKlxuICogSWYgeW91IGhhdmUgYSBjdXN0b20gZW1haWwgYWN0aW9uIGhhbmRsZXIsIHlvdSBjYW4gY29tcGxldGUgdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzIGJ5IGNhbGxpbmdcbiAqIHtAbGluayBhcHBseUFjdGlvbkNvZGV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsKHVzZXIsICduZXdlbWFpbEBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gY29kZSBmcm9tIHRoZSB1c2VyLlxuICogYXdhaXQgYXBwbHlBY3Rpb25Db2RlKGF1dGgsIGNvZGUpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBuZXdFbWFpbCAtIFRoZSBuZXcgZW1haWwgYWRkcmVzcyB0byBiZSB2ZXJpZmllZCBiZWZvcmUgdXBkYXRlLlxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbChcbiAgdXNlcjogVXNlcixcbiAgbmV3RW1haWw6IHN0cmluZyxcbiAgYWN0aW9uQ29kZVNldHRpbmdzPzogQWN0aW9uQ29kZVNldHRpbmdzIHwgbnVsbFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWw7XG4gIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcbiAgY29uc3QgcmVxdWVzdDogYXBpLlZlcmlmeUFuZENoYW5nZUVtYWlsUmVxdWVzdCA9IHtcbiAgICByZXF1ZXN0VHlwZTogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCxcbiAgICBpZFRva2VuLFxuICAgIG5ld0VtYWlsXG4gIH07XG4gIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KFxuICAgICAgdXNlckludGVybmFsLmF1dGgsXG4gICAgICByZXF1ZXN0LFxuICAgICAgYWN0aW9uQ29kZVNldHRpbmdzXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHsgZW1haWwgfSA9IGF3YWl0IGFwaS52ZXJpZnlBbmRDaGFuZ2VFbWFpbCh1c2VySW50ZXJuYWwuYXV0aCwgcmVxdWVzdCk7XG5cbiAgaWYgKGVtYWlsICE9PSB1c2VyLmVtYWlsKSB7XG4gICAgLy8gSWYgdGhlIGxvY2FsIGNvcHkgb2YgdGhlIGVtYWlsIG9uIHVzZXIgaXMgb3V0ZGF0ZWQsIHJlbG9hZCB0aGVcbiAgICAvLyB1c2VyLlxuICAgIGF3YWl0IHVzZXIucmVsb2FkKCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEVuZHBvaW50LCBIdHRwTWV0aG9kLCBfcGVyZm9ybUFwaVJlcXVlc3QgfSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVQcm9maWxlUmVxdWVzdCB7XG4gIGlkVG9rZW46IHN0cmluZztcbiAgZGlzcGxheU5hbWU/OiBzdHJpbmcgfCBudWxsO1xuICBwaG90b1VybD86IHN0cmluZyB8IG51bGw7XG4gIHJldHVyblNlY3VyZVRva2VuOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVByb2ZpbGVSZXNwb25zZSBleHRlbmRzIElkVG9rZW5SZXNwb25zZSB7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nIHwgbnVsbDtcbiAgcGhvdG9Vcmw/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJvZmlsZShcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogVXBkYXRlUHJvZmlsZVJlcXVlc3Rcbik6IFByb21pc2U8VXBkYXRlUHJvZmlsZVJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8VXBkYXRlUHJvZmlsZVJlcXVlc3QsIFVwZGF0ZVByb2ZpbGVSZXNwb25zZT4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyxcbiAgICByZXF1ZXN0XG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHtcbiAgdXBkYXRlRW1haWxQYXNzd29yZCBhcyBhcGlVcGRhdGVFbWFpbFBhc3N3b3JkLFxuICBVcGRhdGVFbWFpbFBhc3N3b3JkUmVxdWVzdFxufSBmcm9tICcuLi8uLi9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L2VtYWlsX2FuZF9wYXNzd29yZCc7XG5pbXBvcnQgeyB1cGRhdGVQcm9maWxlIGFzIGFwaVVwZGF0ZVByb2ZpbGUgfSBmcm9tICcuLi8uLi9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L3Byb2ZpbGUnO1xuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBfbG9nb3V0SWZJbnZhbGlkYXRlZCB9IGZyb20gJy4vaW52YWxpZGF0aW9uJztcbmltcG9ydCB7IGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFByb3ZpZGVySWQgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbi8qKlxuICogVXBkYXRlcyBhIHVzZXIncyBwcm9maWxlIGRhdGEuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBwcm9maWxlIC0gVGhlIHByb2ZpbGUncyBgZGlzcGxheU5hbWVgIGFuZCBgcGhvdG9VUkxgIHRvIHVwZGF0ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVQcm9maWxlKFxuICB1c2VyOiBVc2VyLFxuICB7XG4gICAgZGlzcGxheU5hbWUsXG4gICAgcGhvdG9VUkw6IHBob3RvVXJsXG4gIH06IHsgZGlzcGxheU5hbWU/OiBzdHJpbmcgfCBudWxsOyBwaG90b1VSTD86IHN0cmluZyB8IG51bGwgfVxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmIChkaXNwbGF5TmFtZSA9PT0gdW5kZWZpbmVkICYmIHBob3RvVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsO1xuICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlckludGVybmFsLmdldElkVG9rZW4oKTtcbiAgY29uc3QgcHJvZmlsZVJlcXVlc3QgPSB7XG4gICAgaWRUb2tlbixcbiAgICBkaXNwbGF5TmFtZSxcbiAgICBwaG90b1VybCxcbiAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxuICB9O1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKFxuICAgIHVzZXJJbnRlcm5hbCxcbiAgICBhcGlVcGRhdGVQcm9maWxlKHVzZXJJbnRlcm5hbC5hdXRoLCBwcm9maWxlUmVxdWVzdClcbiAgKTtcblxuICB1c2VySW50ZXJuYWwuZGlzcGxheU5hbWUgPSByZXNwb25zZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICB1c2VySW50ZXJuYWwucGhvdG9VUkwgPSByZXNwb25zZS5waG90b1VybCB8fCBudWxsO1xuXG4gIC8vIFVwZGF0ZSB0aGUgcGFzc3dvcmQgcHJvdmlkZXIgYXMgd2VsbFxuICBjb25zdCBwYXNzd29yZFByb3ZpZGVyID0gdXNlckludGVybmFsLnByb3ZpZGVyRGF0YS5maW5kKFxuICAgICh7IHByb3ZpZGVySWQgfSkgPT4gcHJvdmlkZXJJZCA9PT0gUHJvdmlkZXJJZC5QQVNTV09SRFxuICApO1xuICBpZiAocGFzc3dvcmRQcm92aWRlcikge1xuICAgIHBhc3N3b3JkUHJvdmlkZXIuZGlzcGxheU5hbWUgPSB1c2VySW50ZXJuYWwuZGlzcGxheU5hbWU7XG4gICAgcGFzc3dvcmRQcm92aWRlci5waG90b1VSTCA9IHVzZXJJbnRlcm5hbC5waG90b1VSTDtcbiAgfVxuXG4gIGF3YWl0IHVzZXJJbnRlcm5hbC5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkocmVzcG9uc2UpO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBBbiBlbWFpbCB3aWxsIGJlIHNlbnQgdG8gdGhlIG9yaWdpbmFsIGVtYWlsIGFkZHJlc3MgKGlmIGl0IHdhcyBzZXQpIHRoYXQgYWxsb3dzIHRvIHJldm9rZSB0aGVcbiAqIGVtYWlsIGFkZHJlc3MgY2hhbmdlLCBpbiBvcmRlciB0byBwcm90ZWN0IHRoZW0gZnJvbSBhY2NvdW50IGhpamFja2luZy5cbiAqXG4gKiBJbXBvcnRhbnQ6IHRoaXMgaXMgYSBzZWN1cml0eSBzZW5zaXRpdmUgb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHVzZXIgdG8gaGF2ZSByZWNlbnRseSBzaWduZWRcbiAqIGluLiBJZiB0aGlzIHJlcXVpcmVtZW50IGlzbid0IG1ldCwgYXNrIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbiBhbmQgdGhlbiBjYWxsXG4gKiB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBuZXdFbWFpbCAtIFRoZSBuZXcgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVFbWFpbCh1c2VyOiBVc2VyLCBuZXdFbWFpbDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiB1cGRhdGVFbWFpbE9yUGFzc3dvcmQoXG4gICAgZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpIGFzIFVzZXJJbnRlcm5hbCxcbiAgICBuZXdFbWFpbCxcbiAgICBudWxsXG4gICk7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgdXNlcidzIHBhc3N3b3JkLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJbXBvcnRhbnQ6IHRoaXMgaXMgYSBzZWN1cml0eSBzZW5zaXRpdmUgb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHVzZXIgdG8gaGF2ZSByZWNlbnRseSBzaWduZWRcbiAqIGluLiBJZiB0aGlzIHJlcXVpcmVtZW50IGlzbid0IG1ldCwgYXNrIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbiBhbmQgdGhlbiBjYWxsXG4gKiB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBuZXdQYXNzd29yZCAtIFRoZSBuZXcgcGFzc3dvcmQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUGFzc3dvcmQodXNlcjogVXNlciwgbmV3UGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gdXBkYXRlRW1haWxPclBhc3N3b3JkKFxuICAgIGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWwsXG4gICAgbnVsbCxcbiAgICBuZXdQYXNzd29yZFxuICApO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVFbWFpbE9yUGFzc3dvcmQoXG4gIHVzZXI6IFVzZXJJbnRlcm5hbCxcbiAgZW1haWw6IHN0cmluZyB8IG51bGwsXG4gIHBhc3N3b3JkOiBzdHJpbmcgfCBudWxsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgeyBhdXRoIH0gPSB1c2VyO1xuICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gIGNvbnN0IHJlcXVlc3Q6IFVwZGF0ZUVtYWlsUGFzc3dvcmRSZXF1ZXN0ID0ge1xuICAgIGlkVG9rZW4sXG4gICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcbiAgfTtcblxuICBpZiAoZW1haWwpIHtcbiAgICByZXF1ZXN0LmVtYWlsID0gZW1haWw7XG4gIH1cblxuICBpZiAocGFzc3dvcmQpIHtcbiAgICByZXF1ZXN0LnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gIH1cblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKFxuICAgIHVzZXIsXG4gICAgYXBpVXBkYXRlRW1haWxQYXNzd29yZChhdXRoLCByZXF1ZXN0KVxuICApO1xuICBhd2FpdCB1c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSwgLyogcmVsb2FkICovIHRydWUpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQWRkaXRpb25hbFVzZXJJbmZvLCBVc2VyQ3JlZGVudGlhbCB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBJZFRva2VuUmVzcG9uc2UsIElkVG9rZW5SZXNwb25zZUtpbmQgfSBmcm9tICcuLi8uLi9tb2RlbC9pZF90b2tlbic7XG5pbXBvcnQgeyBfcGFyc2VUb2tlbiB9IGZyb20gJy4vaWRfdG9rZW5fcmVzdWx0JztcbmltcG9ydCB7IFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IFByb3ZpZGVySWQgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbi8qKlxuICogUGFyc2UgdGhlIGBBZGRpdGlvbmFsVXNlckluZm9gIGZyb20gdGhlIElEIHRva2VuIHJlc3BvbnNlLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9mcm9tSWRUb2tlblJlc3BvbnNlKFxuICBpZFRva2VuUmVzcG9uc2U/OiBJZFRva2VuUmVzcG9uc2Vcbik6IEFkZGl0aW9uYWxVc2VySW5mbyB8IG51bGwge1xuICBpZiAoIWlkVG9rZW5SZXNwb25zZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHsgcHJvdmlkZXJJZCB9ID0gaWRUb2tlblJlc3BvbnNlO1xuICBjb25zdCBwcm9maWxlID0gaWRUb2tlblJlc3BvbnNlLnJhd1VzZXJJbmZvXG4gICAgPyBKU09OLnBhcnNlKGlkVG9rZW5SZXNwb25zZS5yYXdVc2VySW5mbylcbiAgICA6IHt9O1xuICBjb25zdCBpc05ld1VzZXIgPVxuICAgIGlkVG9rZW5SZXNwb25zZS5pc05ld1VzZXIgfHxcbiAgICBpZFRva2VuUmVzcG9uc2Uua2luZCA9PT0gSWRUb2tlblJlc3BvbnNlS2luZC5TaWdudXBOZXdVc2VyO1xuICBpZiAoIXByb3ZpZGVySWQgJiYgaWRUb2tlblJlc3BvbnNlPy5pZFRva2VuKSB7XG4gICAgY29uc3Qgc2lnbkluUHJvdmlkZXIgPSBfcGFyc2VUb2tlbihpZFRva2VuUmVzcG9uc2UuaWRUb2tlbik/LmZpcmViYXNlPy5bXG4gICAgICAnc2lnbl9pbl9wcm92aWRlcidcbiAgICBdO1xuICAgIGlmIChzaWduSW5Qcm92aWRlcikge1xuICAgICAgY29uc3QgZmlsdGVyZWRQcm92aWRlcklkID1cbiAgICAgICAgc2lnbkluUHJvdmlkZXIgIT09IFByb3ZpZGVySWQuQU5PTllNT1VTICYmXG4gICAgICAgIHNpZ25JblByb3ZpZGVyICE9PSBQcm92aWRlcklkLkNVU1RPTVxuICAgICAgICAgID8gKHNpZ25JblByb3ZpZGVyIGFzIFByb3ZpZGVySWQpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgLy8gVXNlcyBnZW5lcmljIGNsYXNzIGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgbGVnYWN5IFNESy5cbiAgICAgIHJldHVybiBuZXcgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIGZpbHRlcmVkUHJvdmlkZXJJZCk7XG4gICAgfVxuICB9XG4gIGlmICghcHJvdmlkZXJJZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN3aXRjaCAocHJvdmlkZXJJZCkge1xuICAgIGNhc2UgUHJvdmlkZXJJZC5GQUNFQk9PSzpcbiAgICAgIHJldHVybiBuZXcgRmFjZWJvb2tBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlKTtcbiAgICBjYXNlIFByb3ZpZGVySWQuR0lUSFVCOlxuICAgICAgcmV0dXJuIG5ldyBHaXRodWJBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlKTtcbiAgICBjYXNlIFByb3ZpZGVySWQuR09PR0xFOlxuICAgICAgcmV0dXJuIG5ldyBHb29nbGVBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlKTtcbiAgICBjYXNlIFByb3ZpZGVySWQuVFdJVFRFUjpcbiAgICAgIHJldHVybiBuZXcgVHdpdHRlckFkZGl0aW9uYWxVc2VySW5mbyhcbiAgICAgICAgaXNOZXdVc2VyLFxuICAgICAgICBwcm9maWxlLFxuICAgICAgICBpZFRva2VuUmVzcG9uc2Uuc2NyZWVuTmFtZSB8fCBudWxsXG4gICAgICApO1xuICAgIGNhc2UgUHJvdmlkZXJJZC5DVVNUT006XG4gICAgY2FzZSBQcm92aWRlcklkLkFOT05ZTU9VUzpcbiAgICAgIHJldHVybiBuZXcgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIG51bGwpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm92aWRlcklkLCBwcm9maWxlKTtcbiAgfVxufVxuXG5jbGFzcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIGltcGxlbWVudHMgQWRkaXRpb25hbFVzZXJJbmZvIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgaXNOZXdVc2VyOiBib29sZWFuLFxuICAgIHJlYWRvbmx5IHByb3ZpZGVySWQ6IFByb3ZpZGVySWQgfCBzdHJpbmcgfCBudWxsLFxuICAgIHJlYWRvbmx5IHByb2ZpbGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge31cbiAgKSB7fVxufVxuXG5jbGFzcyBGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUgZXh0ZW5kcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcbiAgY29uc3RydWN0b3IoXG4gICAgaXNOZXdVc2VyOiBib29sZWFuLFxuICAgIHByb3ZpZGVySWQ6IFByb3ZpZGVySWQsXG4gICAgcHJvZmlsZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgcmVhZG9ubHkgdXNlcm5hbWU6IHN0cmluZyB8IG51bGxcbiAgKSB7XG4gICAgc3VwZXIoaXNOZXdVc2VyLCBwcm92aWRlcklkLCBwcm9maWxlKTtcbiAgfVxufVxuXG5jbGFzcyBGYWNlYm9va0FkZGl0aW9uYWxVc2VySW5mbyBleHRlbmRzIEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8ge1xuICBjb25zdHJ1Y3Rvcihpc05ld1VzZXI6IGJvb2xlYW4sIHByb2ZpbGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gICAgc3VwZXIoaXNOZXdVc2VyLCBQcm92aWRlcklkLkZBQ0VCT09LLCBwcm9maWxlKTtcbiAgfVxufVxuXG5jbGFzcyBHaXRodWJBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUge1xuICBjb25zdHJ1Y3Rvcihpc05ld1VzZXI6IGJvb2xlYW4sIHByb2ZpbGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gICAgc3VwZXIoXG4gICAgICBpc05ld1VzZXIsXG4gICAgICBQcm92aWRlcklkLkdJVEhVQixcbiAgICAgIHByb2ZpbGUsXG4gICAgICB0eXBlb2YgcHJvZmlsZT8ubG9naW4gPT09ICdzdHJpbmcnID8gcHJvZmlsZT8ubG9naW4gOiBudWxsXG4gICAgKTtcbiAgfVxufVxuXG5jbGFzcyBHb29nbGVBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcbiAgY29uc3RydWN0b3IoaXNOZXdVc2VyOiBib29sZWFuLCBwcm9maWxlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIHN1cGVyKGlzTmV3VXNlciwgUHJvdmlkZXJJZC5HT09HTEUsIHByb2ZpbGUpO1xuICB9XG59XG5cbmNsYXNzIFR3aXR0ZXJBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUge1xuICBjb25zdHJ1Y3RvcihcbiAgICBpc05ld1VzZXI6IGJvb2xlYW4sXG4gICAgcHJvZmlsZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgc2NyZWVuTmFtZTogc3RyaW5nIHwgbnVsbFxuICApIHtcbiAgICBzdXBlcihpc05ld1VzZXIsIFByb3ZpZGVySWQuVFdJVFRFUiwgcHJvZmlsZSwgc2NyZWVuTmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBwcm92aWRlciBzcGVjaWZpYyB7QGxpbmsgQWRkaXRpb25hbFVzZXJJbmZvfSBmb3IgdGhlIGdpdmVuIGNyZWRlbnRpYWwuXG4gKlxuICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRpdGlvbmFsVXNlckluZm8oXG4gIHVzZXJDcmVkZW50aWFsOiBVc2VyQ3JlZGVudGlhbFxuKTogQWRkaXRpb25hbFVzZXJJbmZvIHwgbnVsbCB7XG4gIGNvbnN0IHsgdXNlciwgX3Rva2VuUmVzcG9uc2UgfSA9IHVzZXJDcmVkZW50aWFsIGFzIFVzZXJDcmVkZW50aWFsSW50ZXJuYWw7XG4gIGlmICh1c2VyLmlzQW5vbnltb3VzICYmICFfdG9rZW5SZXNwb25zZSkge1xuICAgIC8vIEhhbmRsZSB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHNpZ25JbkFub255bW91c2x5KCkgZ2V0cyBjYWxsZWQgdHdpY2UuXG4gICAgLy8gTm8gbmV0d29yayBjYWxsIGlzIG1hZGUgc28gdGhlcmUncyBub3RoaW5nIHRvIGFjdHVhbGx5IGZpbGwgdGhpcyBpblxuICAgIHJldHVybiB7XG4gICAgICBwcm92aWRlcklkOiBudWxsLFxuICAgICAgaXNOZXdVc2VyOiBmYWxzZSxcbiAgICAgIHByb2ZpbGU6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9mcm9tSWRUb2tlblJlc3BvbnNlKF90b2tlblJlc3BvbnNlKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7XG4gIEF1dGgsXG4gIE5leHRPck9ic2VydmVyLFxuICBQZXJzaXN0ZW5jZSxcbiAgVXNlcixcbiAgQ29tcGxldGVGbixcbiAgRXJyb3JGbixcbiAgVW5zdWJzY3JpYmVcbn0gZnJvbSAnLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4uL2NvcmUvYXV0aC9hdXRoX2ltcGwnO1xuXG5leHBvcnQge1xuICBkZWJ1Z0Vycm9yTWFwLFxuICBwcm9kRXJyb3JNYXAsXG4gIEFVVEhfRVJST1JfQ09ERVNfTUFQX0RPX05PVF9VU0VfSU5URVJOQUxMWSBhcyBBdXRoRXJyb3JDb2Rlc1xufSBmcm9tICcuL2Vycm9ycyc7XG5cbi8vIE5vbi1vcHRpb25hbCBhdXRoIG1ldGhvZHMuXG4vKipcbiAqIENoYW5nZXMgdGhlIHR5cGUgb2YgcGVyc2lzdGVuY2Ugb24gdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSBmb3IgdGhlIGN1cnJlbnRseSBzYXZlZFxuICogYEF1dGhgIHNlc3Npb24gYW5kIGFwcGxpZXMgdGhpcyB0eXBlIG9mIHBlcnNpc3RlbmNlIGZvciBmdXR1cmUgc2lnbi1pbiByZXF1ZXN0cywgaW5jbHVkaW5nXG4gKiBzaWduLWluIHdpdGggcmVkaXJlY3QgcmVxdWVzdHMuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgbWFrZXMgaXQgZWFzeSBmb3IgYSB1c2VyIHNpZ25pbmcgaW4gdG8gc3BlY2lmeSB3aGV0aGVyIHRoZWlyIHNlc3Npb24gc2hvdWxkIGJlXG4gKiByZW1lbWJlcmVkIG9yIG5vdC4gSXQgYWxzbyBtYWtlcyBpdCBlYXNpZXIgdG8gbmV2ZXIgcGVyc2lzdCB0aGUgYEF1dGhgIHN0YXRlIGZvciBhcHBsaWNhdGlvbnNcbiAqIHRoYXQgYXJlIHNoYXJlZCBieSBvdGhlciB1c2VycyBvciBoYXZlIHNlbnNpdGl2ZSBkYXRhLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBzZXRQZXJzaXN0ZW5jZShhdXRoLCBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBwZXJzaXN0ZW5jZSAtIFRoZSB7QGxpbmsgUGVyc2lzdGVuY2V9IHRvIHVzZS5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgcGVyc2lzdGVuY2UgY2hhbmdlIGhhcyBjb21wbGV0ZWRcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQZXJzaXN0ZW5jZShcbiAgYXV0aDogQXV0aCxcbiAgcGVyc2lzdGVuY2U6IFBlcnNpc3RlbmNlXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5zZXRQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZSk7XG59XG5cbi8qKlxuICogTG9hZHMgdGhlIHJlQ0FQVENIQSBjb25maWd1cmF0aW9uIGludG8gdGhlIGBBdXRoYCBpbnN0YW5jZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyB3aWxsIGxvYWQgdGhlIHJlQ0FQVENIQSBjb25maWcsIHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIHRoZSByZUNBUFRDSEFcbiAqIHZlcmlmaWNhdGlvbiBmbG93IHNob3VsZCBiZSB0cmlnZ2VyZWQgZm9yIGVhY2ggYXV0aCBwcm92aWRlciwgaW50byB0aGVcbiAqIGN1cnJlbnQgQXV0aCBzZXNzaW9uLlxuICpcbiAqIElmIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoKSBpcyBub3QgaW52b2tlZCwgdGhlIGF1dGggZmxvdyB3aWxsIGFsd2F5cyBzdGFydFxuICogd2l0aG91dCByZUNBUFRDSEEgdmVyaWZpY2F0aW9uLiBJZiB0aGUgcHJvdmlkZXIgaXMgY29uZmlndXJlZCB0byByZXF1aXJlIHJlQ0FQVENIQVxuICogdmVyaWZpY2F0aW9uLCB0aGUgU0RLIHdpbGwgdHJhbnNwYXJlbnRseSBsb2FkIHRoZSByZUNBUFRDSEEgY29uZmlnIGFuZCByZXN0YXJ0IHRoZVxuICogYXV0aCBmbG93cy5cbiAqXG4gKiBUaHVzLCBieSBjYWxsaW5nIHRoaXMgb3B0aW9uYWwgbWV0aG9kLCB5b3Ugd2lsbCByZWR1Y2UgdGhlIGxhdGVuY3kgb2YgZnV0dXJlIGF1dGggZmxvd3MuXG4gKiBMb2FkaW5nIHRoZSByZUNBUFRDSEEgY29uZmlnIGVhcmx5IHdpbGwgYWxzbyBlbmhhbmNlIHRoZSBzaWduYWwgY29sbGVjdGVkIGJ5IHJlQ0FQVENIQS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyhhdXRoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKGF1dGg6IEF1dGgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICByZXR1cm4gYXV0aEludGVybmFsLmluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoKTtcbn1cblxuLyoqXG4gKiBBZGRzIGFuIG9ic2VydmVyIGZvciBjaGFuZ2VzIHRvIHRoZSBzaWduZWQtaW4gdXNlcidzIElEIHRva2VuLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGluY2x1ZGVzIHNpZ24taW4sIHNpZ24tb3V0LCBhbmQgdG9rZW4gcmVmcmVzaCBldmVudHMuXG4gKiBUaGlzIHdpbGwgbm90IGJlIHRyaWdnZXJlZCBhdXRvbWF0aWNhbGx5IHVwb24gSUQgdG9rZW4gZXhwaXJhdGlvbi4gVXNlIHtAbGluayBVc2VyLmdldElkVG9rZW59IHRvIHJlZnJlc2ggdGhlIElEIHRva2VuLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBuZXh0T3JPYnNlcnZlciAtIGNhbGxiYWNrIHRyaWdnZXJlZCBvbiBjaGFuZ2UuXG4gKiBAcGFyYW0gZXJyb3IgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC4gRXJyb3JzXG4gKiBvbiBzaWduaW5nIGluL291dCBjYW4gYmUgY2F1Z2h0IGluIHByb21pc2VzIHJldHVybmVkIGZyb21cbiAqIHNpZ24taW4vc2lnbi1vdXQgZnVuY3Rpb25zLlxuICogQHBhcmFtIGNvbXBsZXRlZCAtIERlcHJlY2F0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbmV2ZXIgdHJpZ2dlcmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uSWRUb2tlbkNoYW5nZWQoXG4gIGF1dGg6IEF1dGgsXG4gIG5leHRPck9ic2VydmVyOiBOZXh0T3JPYnNlcnZlcjxVc2VyPixcbiAgZXJyb3I/OiBFcnJvckZuLFxuICBjb21wbGV0ZWQ/OiBDb21wbGV0ZUZuXG4pOiBVbnN1YnNjcmliZSB7XG4gIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkub25JZFRva2VuQ2hhbmdlZChcbiAgICBuZXh0T3JPYnNlcnZlcixcbiAgICBlcnJvcixcbiAgICBjb21wbGV0ZWRcbiAgKTtcbn1cbi8qKlxuICogQWRkcyBhIGJsb2NraW5nIGNhbGxiYWNrIHRoYXQgcnVucyBiZWZvcmUgYW4gYXV0aCBzdGF0ZSBjaGFuZ2VcbiAqIHNldHMgYSBuZXcgdXNlci5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBjYWxsYmFjayB0cmlnZ2VyZWQgYmVmb3JlIG5ldyB1c2VyIHZhbHVlIGlzIHNldC5cbiAqICAgSWYgdGhpcyB0aHJvd3MsIGl0IGJsb2NrcyB0aGUgdXNlciBmcm9tIGJlaW5nIHNldC5cbiAqIEBwYXJhbSBvbkFib3J0IC0gY2FsbGJhY2sgdHJpZ2dlcmVkIGlmIGEgbGF0ZXIgYGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoKWBcbiAqICAgY2FsbGJhY2sgdGhyb3dzLCBhbGxvd2luZyB5b3UgdG8gdW5kbyBhbnkgc2lkZSBlZmZlY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZChcbiAgYXV0aDogQXV0aCxcbiAgY2FsbGJhY2s6ICh1c2VyOiBVc2VyIHwgbnVsbCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gIG9uQWJvcnQ/OiAoKSA9PiB2b2lkXG4pOiBVbnN1YnNjcmliZSB7XG4gIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZChjYWxsYmFjaywgb25BYm9ydCk7XG59XG4vKipcbiAqIEFkZHMgYW4gb2JzZXJ2ZXIgZm9yIGNoYW5nZXMgdG8gdGhlIHVzZXIncyBzaWduLWluIHN0YXRlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUbyBrZWVwIHRoZSBvbGQgYmVoYXZpb3IsIHNlZSB7QGxpbmsgb25JZFRva2VuQ2hhbmdlZH0uXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIG5leHRPck9ic2VydmVyIC0gY2FsbGJhY2sgdHJpZ2dlcmVkIG9uIGNoYW5nZS5cbiAqIEBwYXJhbSBlcnJvciAtIERlcHJlY2F0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbmV2ZXIgdHJpZ2dlcmVkLiBFcnJvcnNcbiAqIG9uIHNpZ25pbmcgaW4vb3V0IGNhbiBiZSBjYXVnaHQgaW4gcHJvbWlzZXMgcmV0dXJuZWQgZnJvbVxuICogc2lnbi1pbi9zaWduLW91dCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gY29tcGxldGVkIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gb25BdXRoU3RhdGVDaGFuZ2VkKFxuICBhdXRoOiBBdXRoLFxuICBuZXh0T3JPYnNlcnZlcjogTmV4dE9yT2JzZXJ2ZXI8VXNlcj4sXG4gIGVycm9yPzogRXJyb3JGbixcbiAgY29tcGxldGVkPzogQ29tcGxldGVGblxuKTogVW5zdWJzY3JpYmUge1xuICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLm9uQXV0aFN0YXRlQ2hhbmdlZChcbiAgICBuZXh0T3JPYnNlcnZlcixcbiAgICBlcnJvcixcbiAgICBjb21wbGV0ZWRcbiAgKTtcbn1cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCBsYW5ndWFnZSB0byB0aGUgZGVmYXVsdCBkZXZpY2UvYnJvd3NlciBwcmVmZXJlbmNlLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VEZXZpY2VMYW5ndWFnZShhdXRoOiBBdXRoKTogdm9pZCB7XG4gIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS51c2VEZXZpY2VMYW5ndWFnZSgpO1xufVxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBzZXRzIHRoZSBwcm92aWRlZCB1c2VyIGFzIHtAbGluayBBdXRoLmN1cnJlbnRVc2VyfSBvbiB0aGVcbiAqIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogQSBuZXcgaW5zdGFuY2UgY29weSBvZiB0aGUgdXNlciBwcm92aWRlZCB3aWxsIGJlIG1hZGUgYW5kIHNldCBhcyBjdXJyZW50VXNlci5cbiAqXG4gKiBUaGlzIHdpbGwgdHJpZ2dlciB7QGxpbmsgb25BdXRoU3RhdGVDaGFuZ2VkfSBhbmQge0BsaW5rIG9uSWRUb2tlbkNoYW5nZWR9IGxpc3RlbmVyc1xuICogbGlrZSBvdGhlciBzaWduIGluIG1ldGhvZHMuXG4gKlxuICogVGhlIG9wZXJhdGlvbiBmYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSB1c2VyIHRvIGJlIHVwZGF0ZWQgYmVsb25ncyB0byBhIGRpZmZlcmVudCBGaXJlYmFzZVxuICogcHJvamVjdC5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gdXNlciAtIFRoZSBuZXcge0BsaW5rIFVzZXJ9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUN1cnJlbnRVc2VyKFxuICBhdXRoOiBBdXRoLFxuICB1c2VyOiBVc2VyIHwgbnVsbFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkudXBkYXRlQ3VycmVudFVzZXIodXNlcik7XG59XG4vKipcbiAqIFNpZ25zIG91dCB0aGUgY3VycmVudCB1c2VyLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduT3V0KGF1dGg6IEF1dGgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5zaWduT3V0KCk7XG59XG5cbmV4cG9ydCB7IGluaXRpYWxpemVBdXRoIH0gZnJvbSAnLi9hdXRoL2luaXRpYWxpemUnO1xuZXhwb3J0IHsgY29ubmVjdEF1dGhFbXVsYXRvciB9IGZyb20gJy4vYXV0aC9lbXVsYXRvcic7XG5cbi8vIGNyZWRlbnRpYWxzXG5leHBvcnQgeyBBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4vY3JlZGVudGlhbHMnO1xuZXhwb3J0IHsgRW1haWxBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4vY3JlZGVudGlhbHMvZW1haWwnO1xuZXhwb3J0IHsgT0F1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi9jcmVkZW50aWFscy9vYXV0aCc7XG5leHBvcnQgeyBQaG9uZUF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi9jcmVkZW50aWFscy9waG9uZSc7XG5cbi8vIHBlcnNpc3RlbmNlXG5leHBvcnQgeyBpbk1lbW9yeVBlcnNpc3RlbmNlIH0gZnJvbSAnLi9wZXJzaXN0ZW5jZS9pbl9tZW1vcnknO1xuXG4vLyBwcm92aWRlcnNcbmV4cG9ydCB7IEVtYWlsQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZW1haWwnO1xuZXhwb3J0IHsgRmFjZWJvb2tBdXRoUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9mYWNlYm9vayc7XG5leHBvcnQgeyBDdXN0b21QYXJhbWV0ZXJzIH0gZnJvbSAnLi9wcm92aWRlcnMvZmVkZXJhdGVkJztcbmV4cG9ydCB7IEdvb2dsZUF1dGhQcm92aWRlciB9IGZyb20gJy4vcHJvdmlkZXJzL2dvb2dsZSc7XG5leHBvcnQgeyBHaXRodWJBdXRoUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9naXRodWInO1xuZXhwb3J0IHsgT0F1dGhQcm92aWRlciwgT0F1dGhDcmVkZW50aWFsT3B0aW9ucyB9IGZyb20gJy4vcHJvdmlkZXJzL29hdXRoJztcbmV4cG9ydCB7IFNBTUxBdXRoUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9zYW1sJztcbmV4cG9ydCB7IFR3aXR0ZXJBdXRoUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy90d2l0dGVyJztcblxuLy8gc3RyYXRlZ2llc1xuZXhwb3J0IHsgc2lnbkluQW5vbnltb3VzbHkgfSBmcm9tICcuL3N0cmF0ZWdpZXMvYW5vbnltb3VzJztcbmV4cG9ydCB7XG4gIHNpZ25JbldpdGhDcmVkZW50aWFsLFxuICBsaW5rV2l0aENyZWRlbnRpYWwsXG4gIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWxcbn0gZnJvbSAnLi9zdHJhdGVnaWVzL2NyZWRlbnRpYWwnO1xuZXhwb3J0IHsgc2lnbkluV2l0aEN1c3RvbVRva2VuIH0gZnJvbSAnLi9zdHJhdGVnaWVzL2N1c3RvbV90b2tlbic7XG5leHBvcnQge1xuICBzZW5kUGFzc3dvcmRSZXNldEVtYWlsLFxuICBjb25maXJtUGFzc3dvcmRSZXNldCxcbiAgYXBwbHlBY3Rpb25Db2RlLFxuICBjaGVja0FjdGlvbkNvZGUsXG4gIHZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlLFxuICBjcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmQsXG4gIHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkXG59IGZyb20gJy4vc3RyYXRlZ2llcy9lbWFpbF9hbmRfcGFzc3dvcmQnO1xuZXhwb3J0IHtcbiAgc2VuZFNpZ25JbkxpbmtUb0VtYWlsLFxuICBpc1NpZ25JbldpdGhFbWFpbExpbmssXG4gIHNpZ25JbldpdGhFbWFpbExpbmtcbn0gZnJvbSAnLi9zdHJhdGVnaWVzL2VtYWlsX2xpbmsnO1xuZXhwb3J0IHtcbiAgZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWwsXG4gIHNlbmRFbWFpbFZlcmlmaWNhdGlvbixcbiAgdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWxcbn0gZnJvbSAnLi9zdHJhdGVnaWVzL2VtYWlsJztcblxuLy8gY29yZVxuZXhwb3J0IHsgQWN0aW9uQ29kZVVSTCwgcGFyc2VBY3Rpb25Db2RlVVJMIH0gZnJvbSAnLi9hY3Rpb25fY29kZV91cmwnO1xuXG4vLyB1c2VyXG5leHBvcnQge1xuICB1cGRhdGVQcm9maWxlLFxuICB1cGRhdGVFbWFpbCxcbiAgdXBkYXRlUGFzc3dvcmRcbn0gZnJvbSAnLi91c2VyL2FjY291bnRfaW5mbyc7XG5leHBvcnQgeyBnZXRJZFRva2VuLCBnZXRJZFRva2VuUmVzdWx0IH0gZnJvbSAnLi91c2VyL2lkX3Rva2VuX3Jlc3VsdCc7XG5leHBvcnQgeyB1bmxpbmsgfSBmcm9tICcuL3VzZXIvbGlua191bmxpbmsnO1xuZXhwb3J0IHsgZ2V0QWRkaXRpb25hbFVzZXJJbmZvIH0gZnJvbSAnLi91c2VyL2FkZGl0aW9uYWxfdXNlcl9pbmZvJztcblxuLy8gTm9uLW9wdGlvbmFsIHVzZXIgbWV0aG9kcy5cbmV4cG9ydCB7IHJlbG9hZCB9IGZyb20gJy4vdXNlci9yZWxvYWQnO1xuLyoqXG4gKiBEZWxldGVzIGFuZCBzaWducyBvdXQgdGhlIHVzZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIEltcG9ydGFudDogdGhpcyBpcyBhIHNlY3VyaXR5LXNlbnNpdGl2ZSBvcGVyYXRpb24gdGhhdCByZXF1aXJlcyB0aGUgdXNlciB0byBoYXZlIHJlY2VudGx5XG4gKiBzaWduZWQgaW4uIElmIHRoaXMgcmVxdWlyZW1lbnQgaXNuJ3QgbWV0LCBhc2sgdGhlIHVzZXIgdG8gYXV0aGVudGljYXRlIGFnYWluIGFuZCB0aGVuIGNhbGxcbiAqIHtAbGluayByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsfS5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVVzZXIodXNlcjogVXNlcik6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLmRlbGV0ZSgpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JTZXNzaW9uIH0gZnJvbSAnLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IGVudW0gTXVsdGlGYWN0b3JTZXNzaW9uVHlwZSB7XG4gIEVOUk9MTCA9ICdlbnJvbGwnLFxuICBTSUdOX0lOID0gJ3NpZ25pbidcbn1cblxuaW50ZXJmYWNlIFNlcmlhbGl6ZWRNdWx0aUZhY3RvclNlc3Npb24ge1xuICBtdWx0aUZhY3RvclNlc3Npb246IHtcbiAgICBpZFRva2VuPzogc3RyaW5nO1xuICAgIHBlbmRpbmdDcmVkZW50aWFsPzogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgY2xhc3MgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbCBpbXBsZW1lbnRzIE11bHRpRmFjdG9yU2Vzc2lvbiB7XG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgdHlwZTogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZSxcbiAgICByZWFkb25seSBjcmVkZW50aWFsOiBzdHJpbmcsXG4gICAgcmVhZG9ubHkgYXV0aD86IEF1dGhJbnRlcm5hbFxuICApIHt9XG5cbiAgc3RhdGljIF9mcm9tSWR0b2tlbihcbiAgICBpZFRva2VuOiBzdHJpbmcsXG4gICAgYXV0aD86IEF1dGhJbnRlcm5hbFxuICApOiBNdWx0aUZhY3RvclNlc3Npb25JbXBsIHtcbiAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwoXG4gICAgICBNdWx0aUZhY3RvclNlc3Npb25UeXBlLkVOUk9MTCxcbiAgICAgIGlkVG9rZW4sXG4gICAgICBhdXRoXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBfZnJvbU1mYVBlbmRpbmdDcmVkZW50aWFsKFxuICAgIG1mYVBlbmRpbmdDcmVkZW50aWFsOiBzdHJpbmdcbiAgKTogTXVsdGlGYWN0b3JTZXNzaW9uSW1wbCB7XG4gICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvclNlc3Npb25JbXBsKFxuICAgICAgTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5TSUdOX0lOLFxuICAgICAgbWZhUGVuZGluZ0NyZWRlbnRpYWxcbiAgICApO1xuICB9XG5cbiAgdG9KU09OKCk6IFNlcmlhbGl6ZWRNdWx0aUZhY3RvclNlc3Npb24ge1xuICAgIGNvbnN0IGtleSA9XG4gICAgICB0aGlzLnR5cGUgPT09IE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMXG4gICAgICAgID8gJ2lkVG9rZW4nXG4gICAgICAgIDogJ3BlbmRpbmdDcmVkZW50aWFsJztcbiAgICByZXR1cm4ge1xuICAgICAgbXVsdGlGYWN0b3JTZXNzaW9uOiB7XG4gICAgICAgIFtrZXldOiB0aGlzLmNyZWRlbnRpYWxcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGZyb21KU09OKFxuICAgIG9iajogUGFydGlhbDxTZXJpYWxpemVkTXVsdGlGYWN0b3JTZXNzaW9uPlxuICApOiBNdWx0aUZhY3RvclNlc3Npb25JbXBsIHwgbnVsbCB7XG4gICAgaWYgKG9iaj8ubXVsdGlGYWN0b3JTZXNzaW9uKSB7XG4gICAgICBpZiAob2JqLm11bHRpRmFjdG9yU2Vzc2lvbj8ucGVuZGluZ0NyZWRlbnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbChcbiAgICAgICAgICBvYmoubXVsdGlGYWN0b3JTZXNzaW9uLnBlbmRpbmdDcmVkZW50aWFsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKG9iai5tdWx0aUZhY3RvclNlc3Npb24/LmlkVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21JZHRva2VuKFxuICAgICAgICAgIG9iai5tdWx0aUZhY3RvclNlc3Npb24uaWRUb2tlblxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgQXV0aCxcbiAgTXVsdGlGYWN0b3JSZXNvbHZlcixcbiAgVXNlckNyZWRlbnRpYWwsXG4gIE11bHRpRmFjdG9yRXJyb3Jcbn0gZnJvbSAnLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHsgX2Nhc3RBdXRoIH0gZnJvbSAnLi4vY29yZS9hdXRoL2F1dGhfaW1wbCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbXBsIH0gZnJvbSAnLi4vY29yZS91c2VyL3VzZXJfY3JlZGVudGlhbF9pbXBsJztcbmltcG9ydCB7IF9hc3NlcnQsIF9mYWlsIH0gZnJvbSAnLi4vY29yZS91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwgfSBmcm9tICcuL21mYV9hc3NlcnRpb24nO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JFcnJvciBhcyBNdWx0aUZhY3RvckVycm9ySW50ZXJuYWwgfSBmcm9tICcuL21mYV9lcnJvcic7XG5pbXBvcnQgeyBNdWx0aUZhY3RvckluZm9JbXBsIH0gZnJvbSAnLi9tZmFfaW5mbyc7XG5pbXBvcnQgeyBNdWx0aUZhY3RvclNlc3Npb25JbXBsIH0gZnJvbSAnLi9tZmFfc2Vzc2lvbic7XG5pbXBvcnQgeyBnZXRNb2R1bGFySW5zdGFuY2UgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi4vbW9kZWwvZW51bXMnO1xuXG5leHBvcnQgY2xhc3MgTXVsdGlGYWN0b3JSZXNvbHZlckltcGwgaW1wbGVtZW50cyBNdWx0aUZhY3RvclJlc29sdmVyIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBzZXNzaW9uOiBNdWx0aUZhY3RvclNlc3Npb25JbXBsLFxuICAgIHJlYWRvbmx5IGhpbnRzOiBNdWx0aUZhY3RvckluZm9JbXBsW10sXG4gICAgcHJpdmF0ZSByZWFkb25seSBzaWduSW5SZXNvbHZlcjogKFxuICAgICAgYXNzZXJ0aW9uOiBNdWx0aUZhY3RvckFzc2VydGlvbkltcGxcbiAgICApID0+IFByb21pc2U8VXNlckNyZWRlbnRpYWxJbnRlcm5hbD5cbiAgKSB7fVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9mcm9tRXJyb3IoXG4gICAgYXV0aEV4dGVybjogQXV0aCxcbiAgICBlcnJvcjogTXVsdGlGYWN0b3JFcnJvckludGVybmFsXG4gICk6IE11bHRpRmFjdG9yUmVzb2x2ZXJJbXBsIHtcbiAgICBjb25zdCBhdXRoID0gX2Nhc3RBdXRoKGF1dGhFeHRlcm4pO1xuICAgIGNvbnN0IHNlcnZlclJlc3BvbnNlID0gZXJyb3IuY3VzdG9tRGF0YS5fc2VydmVyUmVzcG9uc2U7XG4gICAgY29uc3QgaGludHMgPSAoc2VydmVyUmVzcG9uc2UubWZhSW5mbyB8fCBbXSkubWFwKGVucm9sbG1lbnQgPT5cbiAgICAgIE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShhdXRoLCBlbnJvbGxtZW50KVxuICAgICk7XG5cbiAgICBfYXNzZXJ0KFxuICAgICAgc2VydmVyUmVzcG9uc2UubWZhUGVuZGluZ0NyZWRlbnRpYWwsXG4gICAgICBhdXRoLFxuICAgICAgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUlxuICAgICk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbChcbiAgICAgIHNlcnZlclJlc3BvbnNlLm1mYVBlbmRpbmdDcmVkZW50aWFsXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JSZXNvbHZlckltcGwoXG4gICAgICBzZXNzaW9uLFxuICAgICAgaGludHMsXG4gICAgICBhc3luYyAoXG4gICAgICAgIGFzc2VydGlvbjogTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsXG4gICAgICApOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWw+ID0+IHtcbiAgICAgICAgY29uc3QgbWZhUmVzcG9uc2UgPSBhd2FpdCBhc3NlcnRpb24uX3Byb2Nlc3MoYXV0aCwgc2Vzc2lvbik7XG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgdW5uZWVkZWQgZmllbGRzIGZyb20gdGhlIG9sZCBsb2dpbiByZXNwb25zZVxuICAgICAgICBkZWxldGUgc2VydmVyUmVzcG9uc2UubWZhSW5mbztcbiAgICAgICAgZGVsZXRlIHNlcnZlclJlc3BvbnNlLm1mYVBlbmRpbmdDcmVkZW50aWFsO1xuXG4gICAgICAgIC8vIFVzZSBpbiB0aGUgbmV3IHRva2VuICYgcmVmcmVzaCB0b2tlbiBpbiB0aGUgb2xkIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IGlkVG9rZW5SZXNwb25zZSA9IHtcbiAgICAgICAgICAuLi5zZXJ2ZXJSZXNwb25zZSxcbiAgICAgICAgICBpZFRva2VuOiBtZmFSZXNwb25zZS5pZFRva2VuLFxuICAgICAgICAgIHJlZnJlc2hUb2tlbjogbWZhUmVzcG9uc2UucmVmcmVzaFRva2VuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGNvbGxhcHNlIHRoaXMgc3dpdGNoIHN0YXRlbWVudCBpbnRvIFVzZXJDcmVkZW50aWFsSW1wbC5fZm9yT3BlcmF0aW9uIGFuZCBoYXZlIGl0IHN1cHBvcnQgdGhlIFNJR05fSU4gY2FzZVxuICAgICAgICBzd2l0Y2ggKGVycm9yLm9wZXJhdGlvblR5cGUpIHtcbiAgICAgICAgICBjYXNlIE9wZXJhdGlvblR5cGUuU0lHTl9JTjpcbiAgICAgICAgICAgIGNvbnN0IHVzZXJDcmVkZW50aWFsID1cbiAgICAgICAgICAgICAgYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKFxuICAgICAgICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgICAgICAgZXJyb3Iub3BlcmF0aW9uVHlwZSxcbiAgICAgICAgICAgICAgICBpZFRva2VuUmVzcG9uc2VcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF3YWl0IGF1dGguX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xuICAgICAgICAgIGNhc2UgT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURTpcbiAgICAgICAgICAgIF9hc3NlcnQoZXJyb3IudXNlciwgYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgICAgICAgICByZXR1cm4gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24oXG4gICAgICAgICAgICAgIGVycm9yLnVzZXIsXG4gICAgICAgICAgICAgIGVycm9yLm9wZXJhdGlvblR5cGUsXG4gICAgICAgICAgICAgIGlkVG9rZW5SZXNwb25zZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgX2ZhaWwoYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgYXN5bmMgcmVzb2x2ZVNpZ25JbihcbiAgICBhc3NlcnRpb25FeHRlcm46IE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbFxuICApOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsPiB7XG4gICAgY29uc3QgYXNzZXJ0aW9uID0gYXNzZXJ0aW9uRXh0ZXJuIGFzIE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbDtcbiAgICByZXR1cm4gdGhpcy5zaWduSW5SZXNvbHZlcihhc3NlcnRpb24pO1xuICB9XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSB7QGxpbmsgTXVsdGlGYWN0b3JSZXNvbHZlcn0gc3VpdGFibGUgZm9yIGNvbXBsZXRpb24gb2YgYVxuICogbXVsdGktZmFjdG9yIGZsb3cuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVycm9yIC0gVGhlIHtAbGluayBNdWx0aUZhY3RvckVycm9yfSByYWlzZWQgZHVyaW5nIGEgc2lnbi1pbiwgb3JcbiAqIHJlYXV0aGVudGljYXRpb24gb3BlcmF0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE11bHRpRmFjdG9yUmVzb2x2ZXIoXG4gIGF1dGg6IEF1dGgsXG4gIGVycm9yOiBNdWx0aUZhY3RvckVycm9yXG4pOiBNdWx0aUZhY3RvclJlc29sdmVyIHtcbiAgY29uc3QgYXV0aE1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XG4gIGNvbnN0IGVycm9ySW50ZXJuYWwgPSBlcnJvciBhcyBNdWx0aUZhY3RvckVycm9ySW50ZXJuYWw7XG4gIF9hc3NlcnQoXG4gICAgZXJyb3IuY3VzdG9tRGF0YS5vcGVyYXRpb25UeXBlLFxuICAgIGF1dGhNb2R1bGFyLFxuICAgIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1JcbiAgKTtcbiAgX2Fzc2VydChcbiAgICBlcnJvckludGVybmFsLmN1c3RvbURhdGEuX3NlcnZlclJlc3BvbnNlPy5tZmFQZW5kaW5nQ3JlZGVudGlhbCxcbiAgICBhdXRoTW9kdWxhcixcbiAgICBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SXG4gICk7XG5cbiAgcmV0dXJuIE11bHRpRmFjdG9yUmVzb2x2ZXJJbXBsLl9mcm9tRXJyb3IoYXV0aE1vZHVsYXIsIGVycm9ySW50ZXJuYWwpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgRW5kcG9pbnQsXG4gIEh0dHBNZXRob2QsXG4gIF9hZGRUaWRJZk5lY2Vzc2FyeSxcbiAgX3BlcmZvcm1BcGlSZXF1ZXN0XG59IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IFNpZ25JbldpdGhQaG9uZU51bWJlclJlcXVlc3QgfSBmcm9tICcuLi9hdXRoZW50aWNhdGlvbi9zbXMnO1xuaW1wb3J0IHsgRmluYWxpemVNZmFSZXNwb25zZSB9IGZyb20gJy4uL2F1dGhlbnRpY2F0aW9uL21mYSc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcblxuLyoqXG4gKiBNRkEgSW5mbyBhcyByZXR1cm5lZCBieSB0aGUgQVBJLlxuICovXG5pbnRlcmZhY2UgQmFzZU1mYUVucm9sbG1lbnQge1xuICBtZmFFbnJvbGxtZW50SWQ6IHN0cmluZztcbiAgZW5yb2xsZWRBdDogbnVtYmVyO1xuICBkaXNwbGF5TmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBBbiBNRkEgcHJvdmlkZWQgYnkgU01TIHZlcmlmaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQaG9uZU1mYUVucm9sbG1lbnQgZXh0ZW5kcyBCYXNlTWZhRW5yb2xsbWVudCB7XG4gIHBob25lSW5mbzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEFuIE1GQSBwcm92aWRlZCBieSBUT1RQIChUaW1lLWJhc2VkIE9uZSBUaW1lIFBhc3N3b3JkKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUb3RwTWZhRW5yb2xsbWVudCBleHRlbmRzIEJhc2VNZmFFbnJvbGxtZW50IHt9XG5cbi8qKlxuICogTWZhRW5yb2xsbWVudCBjYW4gYmUgYW55IHN1YnR5cGUgb2YgQmFzZU1mYUVucm9sbG1lbnQsIGN1cnJlbnRseSBvbmx5IFBob25lTWZhRW5yb2xsbWVudCBhbmQgVG90cE1mYUVucm9sbG1lbnQgYXJlIHN1cHBvcnRlZC5cbiAqL1xuZXhwb3J0IHR5cGUgTWZhRW5yb2xsbWVudCA9IFBob25lTWZhRW5yb2xsbWVudCB8IFRvdHBNZmFFbnJvbGxtZW50O1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXJ0UGhvbmVNZmFFbnJvbGxtZW50UmVxdWVzdCB7XG4gIGlkVG9rZW46IHN0cmluZztcbiAgcGhvbmVFbnJvbGxtZW50SW5mbzoge1xuICAgIHBob25lTnVtYmVyOiBzdHJpbmc7XG4gICAgcmVjYXB0Y2hhVG9rZW46IHN0cmluZztcbiAgfTtcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhcnRQaG9uZU1mYUVucm9sbG1lbnRSZXNwb25zZSB7XG4gIHBob25lU2Vzc2lvbkluZm86IHtcbiAgICBzZXNzaW9uSW5mbzogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRFbnJvbGxQaG9uZU1mYShcbiAgYXV0aDogQXV0aEludGVybmFsLFxuICByZXF1ZXN0OiBTdGFydFBob25lTWZhRW5yb2xsbWVudFJlcXVlc3Rcbik6IFByb21pc2U8U3RhcnRQaG9uZU1mYUVucm9sbG1lbnRSZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PFxuICAgIFN0YXJ0UGhvbmVNZmFFbnJvbGxtZW50UmVxdWVzdCxcbiAgICBTdGFydFBob25lTWZhRW5yb2xsbWVudFJlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuU1RBUlRfTUZBX0VOUk9MTE1FTlQsXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluYWxpemVQaG9uZU1mYUVucm9sbG1lbnRSZXF1ZXN0IHtcbiAgaWRUb2tlbjogc3RyaW5nO1xuICBwaG9uZVZlcmlmaWNhdGlvbkluZm86IFNpZ25JbldpdGhQaG9uZU51bWJlclJlcXVlc3Q7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nIHwgbnVsbDtcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluYWxpemVQaG9uZU1mYUVucm9sbG1lbnRSZXNwb25zZVxuICBleHRlbmRzIEZpbmFsaXplTWZhUmVzcG9uc2Uge31cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmFsaXplRW5yb2xsUGhvbmVNZmEoXG4gIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgcmVxdWVzdDogRmluYWxpemVQaG9uZU1mYUVucm9sbG1lbnRSZXF1ZXN0XG4pOiBQcm9taXNlPEZpbmFsaXplUGhvbmVNZmFFbnJvbGxtZW50UmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxcbiAgICBGaW5hbGl6ZVBob25lTWZhRW5yb2xsbWVudFJlcXVlc3QsXG4gICAgRmluYWxpemVQaG9uZU1mYUVucm9sbG1lbnRSZXNwb25zZVxuICA+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LkZJTkFMSVpFX01GQV9FTlJPTExNRU5ULFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuZXhwb3J0IGludGVyZmFjZSBTdGFydFRvdHBNZmFFbnJvbGxtZW50UmVxdWVzdCB7XG4gIGlkVG9rZW46IHN0cmluZztcbiAgdG90cEVucm9sbG1lbnRJbmZvOiB7fTtcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlIHtcbiAgdG90cFNlc3Npb25JbmZvOiB7XG4gICAgc2hhcmVkU2VjcmV0S2V5OiBzdHJpbmc7XG4gICAgdmVyaWZpY2F0aW9uQ29kZUxlbmd0aDogbnVtYmVyO1xuICAgIGhhc2hpbmdBbGdvcml0aG06IHN0cmluZztcbiAgICBwZXJpb2RTZWM6IG51bWJlcjtcbiAgICBzZXNzaW9uSW5mbzogc3RyaW5nO1xuICAgIGZpbmFsaXplRW5yb2xsbWVudFRpbWU6IG51bWJlcjtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0RW5yb2xsVG90cE1mYShcbiAgYXV0aDogQXV0aEludGVybmFsLFxuICByZXF1ZXN0OiBTdGFydFRvdHBNZmFFbnJvbGxtZW50UmVxdWVzdFxuKTogUHJvbWlzZTxTdGFydFRvdHBNZmFFbnJvbGxtZW50UmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxcbiAgICBTdGFydFRvdHBNZmFFbnJvbGxtZW50UmVxdWVzdCxcbiAgICBTdGFydFRvdHBNZmFFbnJvbGxtZW50UmVzcG9uc2VcbiAgPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5TVEFSVF9NRkFfRU5ST0xMTUVOVCxcbiAgICBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdClcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb3RwVmVyaWZpY2F0aW9uSW5mbyB7XG4gIHNlc3Npb25JbmZvOiBzdHJpbmc7XG4gIHZlcmlmaWNhdGlvbkNvZGU6IHN0cmluZztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRmluYWxpemVUb3RwTWZhRW5yb2xsbWVudFJlcXVlc3Qge1xuICBpZFRva2VuOiBzdHJpbmc7XG4gIHRvdHBWZXJpZmljYXRpb25JbmZvOiBUb3RwVmVyaWZpY2F0aW9uSW5mbztcbiAgZGlzcGxheU5hbWU/OiBzdHJpbmcgfCBudWxsO1xuICB0ZW5hbnRJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaW5hbGl6ZVRvdHBNZmFFbnJvbGxtZW50UmVzcG9uc2VcbiAgZXh0ZW5kcyBGaW5hbGl6ZU1mYVJlc3BvbnNlIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5hbGl6ZUVucm9sbFRvdHBNZmEoXG4gIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgcmVxdWVzdDogRmluYWxpemVUb3RwTWZhRW5yb2xsbWVudFJlcXVlc3Rcbik6IFByb21pc2U8RmluYWxpemVUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8XG4gICAgRmluYWxpemVUb3RwTWZhRW5yb2xsbWVudFJlcXVlc3QsXG4gICAgRmluYWxpemVUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlXG4gID4oXG4gICAgYXV0aCxcbiAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgRW5kcG9pbnQuRklOQUxJWkVfTUZBX0VOUk9MTE1FTlQsXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2l0aGRyYXdNZmFSZXF1ZXN0IHtcbiAgaWRUb2tlbjogc3RyaW5nO1xuICBtZmFFbnJvbGxtZW50SWQ6IHN0cmluZztcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2l0aGRyYXdNZmFSZXNwb25zZSBleHRlbmRzIEZpbmFsaXplTWZhUmVzcG9uc2Uge31cblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhkcmF3TWZhKFxuICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gIHJlcXVlc3Q6IFdpdGhkcmF3TWZhUmVxdWVzdFxuKTogUHJvbWlzZTxXaXRoZHJhd01mYVJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8V2l0aGRyYXdNZmFSZXF1ZXN0LCBXaXRoZHJhd01mYVJlc3BvbnNlPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICBFbmRwb2ludC5XSVRIRFJBV19NRkEsXG4gICAgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHtcbiAgTXVsdGlGYWN0b3JBc3NlcnRpb24sXG4gIE11bHRpRmFjdG9ySW5mbyxcbiAgTXVsdGlGYWN0b3JTZXNzaW9uLFxuICBNdWx0aUZhY3RvclVzZXIsXG4gIFVzZXJcbn0gZnJvbSAnLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHsgd2l0aGRyYXdNZmEgfSBmcm9tICcuLi9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L21mYSc7XG5pbXBvcnQgeyBfbG9nb3V0SWZJbnZhbGlkYXRlZCB9IGZyb20gJy4uL2NvcmUvdXNlci9pbnZhbGlkYXRpb24nO1xuaW1wb3J0IHsgVXNlckludGVybmFsIH0gZnJvbSAnLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwgfSBmcm9tICcuL21mYV9hc3NlcnRpb24nO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JJbmZvSW1wbCB9IGZyb20gJy4vbWZhX2luZm8nO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbCB9IGZyb20gJy4vbWZhX3Nlc3Npb24nO1xuaW1wb3J0IHsgZ2V0TW9kdWxhckluc3RhbmNlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5leHBvcnQgY2xhc3MgTXVsdGlGYWN0b3JVc2VySW1wbCBpbXBsZW1lbnRzIE11bHRpRmFjdG9yVXNlciB7XG4gIGVucm9sbGVkRmFjdG9yczogTXVsdGlGYWN0b3JJbmZvW10gPSBbXTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHVzZXI6IFVzZXJJbnRlcm5hbCkge1xuICAgIHVzZXIuX29uUmVsb2FkKHVzZXJJbmZvID0+IHtcbiAgICAgIGlmICh1c2VySW5mby5tZmFJbmZvKSB7XG4gICAgICAgIHRoaXMuZW5yb2xsZWRGYWN0b3JzID0gdXNlckluZm8ubWZhSW5mby5tYXAoZW5yb2xsbWVudCA9PlxuICAgICAgICAgIE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZSh1c2VyLmF1dGgsIGVucm9sbG1lbnQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgX2Zyb21Vc2VyKHVzZXI6IFVzZXJJbnRlcm5hbCk6IE11bHRpRmFjdG9yVXNlckltcGwge1xuICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JVc2VySW1wbCh1c2VyKTtcbiAgfVxuXG4gIGFzeW5jIGdldFNlc3Npb24oKTogUHJvbWlzZTxNdWx0aUZhY3RvclNlc3Npb24+IHtcbiAgICByZXR1cm4gTXVsdGlGYWN0b3JTZXNzaW9uSW1wbC5fZnJvbUlkdG9rZW4oXG4gICAgICBhd2FpdCB0aGlzLnVzZXIuZ2V0SWRUb2tlbigpLFxuICAgICAgdGhpcy51c2VyLmF1dGhcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgZW5yb2xsKFxuICAgIGFzc2VydGlvbkV4dGVybjogTXVsdGlGYWN0b3JBc3NlcnRpb24sXG4gICAgZGlzcGxheU5hbWU/OiBzdHJpbmcgfCBudWxsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGFzc2VydGlvbiA9IGFzc2VydGlvbkV4dGVybiBhcyBNdWx0aUZhY3RvckFzc2VydGlvbkltcGw7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IChhd2FpdCB0aGlzLmdldFNlc3Npb24oKSkgYXMgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbDtcbiAgICBjb25zdCBmaW5hbGl6ZU1mYVJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQoXG4gICAgICB0aGlzLnVzZXIsXG4gICAgICBhc3NlcnRpb24uX3Byb2Nlc3ModGhpcy51c2VyLmF1dGgsIHNlc3Npb24sIGRpc3BsYXlOYW1lKVxuICAgICk7XG4gICAgLy8gTmV3IHRva2VucyB3aWxsIGJlIGlzc3VlZCBhZnRlciBlbnJvbGxtZW50IG9mIHRoZSBuZXcgc2Vjb25kIGZhY3RvcnMuXG4gICAgLy8gVGhleSBuZWVkIHRvIGJlIHVwZGF0ZWQgb24gdGhlIHVzZXIuXG4gICAgYXdhaXQgdGhpcy51c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShmaW5hbGl6ZU1mYVJlc3BvbnNlKTtcbiAgICAvLyBUaGUgdXNlciBuZWVkcyB0byBiZSByZWxvYWRlZCB0byBnZXQgdGhlIG5ldyBtdWx0aS1mYWN0b3IgaW5mb3JtYXRpb25cbiAgICAvLyBmcm9tIHNlcnZlci4gVVNFUl9SRUxPQURFRCBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBhbmQgYGVucm9sbGVkRmFjdG9yc2BcbiAgICAvLyB3aWxsIGJlIHVwZGF0ZWQuXG4gICAgcmV0dXJuIHRoaXMudXNlci5yZWxvYWQoKTtcbiAgfVxuXG4gIGFzeW5jIHVuZW5yb2xsKGluZm9PclVpZDogTXVsdGlGYWN0b3JJbmZvIHwgc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbWZhRW5yb2xsbWVudElkID1cbiAgICAgIHR5cGVvZiBpbmZvT3JVaWQgPT09ICdzdHJpbmcnID8gaW5mb09yVWlkIDogaW5mb09yVWlkLnVpZDtcbiAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdGhpcy51c2VyLmdldElkVG9rZW4oKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaWRUb2tlblJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQoXG4gICAgICAgIHRoaXMudXNlcixcbiAgICAgICAgd2l0aGRyYXdNZmEodGhpcy51c2VyLmF1dGgsIHtcbiAgICAgICAgICBpZFRva2VuLFxuICAgICAgICAgIG1mYUVucm9sbG1lbnRJZFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc2Vjb25kIGZhY3RvciBmcm9tIHRoZSB1c2VyJ3MgbGlzdC5cbiAgICAgIHRoaXMuZW5yb2xsZWRGYWN0b3JzID0gdGhpcy5lbnJvbGxlZEZhY3RvcnMuZmlsdGVyKFxuICAgICAgICAoeyB1aWQgfSkgPT4gdWlkICE9PSBtZmFFbnJvbGxtZW50SWRcbiAgICAgICk7XG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB0aGUgYmFja2VuZCBkZWNpZGVkIHRvIHJldm9rZSB0aGUgdXNlcidzIHNlc3Npb24sXG4gICAgICAvLyB0aGUgdG9rZW5SZXNwb25zZSBtYXkgYmUgZW1wdHkuIElmIHRoZSB0b2tlbnMgd2VyZSBub3QgdXBkYXRlZCAoYW5kIHRoZXlcbiAgICAgIC8vIGFyZSBub3cgaW52YWxpZCksIHJlbG9hZGluZyB0aGUgdXNlciB3aWxsIGRpc2NvdmVyIHRoaXMgYW5kIGludmFsaWRhdGVcbiAgICAgIC8vIHRoZSB1c2VyJ3Mgc3RhdGUgYWNjb3JkaW5nbHkuXG4gICAgICBhd2FpdCB0aGlzLnVzZXIuX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KGlkVG9rZW5SZXNwb25zZSk7XG4gICAgICBhd2FpdCB0aGlzLnVzZXIucmVsb2FkKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbXVsdGlGYWN0b3JVc2VyQ2FjaGUgPSBuZXcgV2Vha01hcDxVc2VyLCBNdWx0aUZhY3RvclVzZXI+KCk7XG5cbi8qKlxuICogVGhlIHtAbGluayBNdWx0aUZhY3RvclVzZXJ9IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHVzZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgaXMgdXNlZCB0byBhY2Nlc3MgYWxsIG11bHRpLWZhY3RvciBwcm9wZXJ0aWVzIGFuZCBvcGVyYXRpb25zIHJlbGF0ZWQgdG8gdGhlIHVzZXIuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aUZhY3Rvcih1c2VyOiBVc2VyKTogTXVsdGlGYWN0b3JVc2VyIHtcbiAgY29uc3QgdXNlck1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gIGlmICghbXVsdGlGYWN0b3JVc2VyQ2FjaGUuaGFzKHVzZXJNb2R1bGFyKSkge1xuICAgIG11bHRpRmFjdG9yVXNlckNhY2hlLnNldChcbiAgICAgIHVzZXJNb2R1bGFyLFxuICAgICAgTXVsdGlGYWN0b3JVc2VySW1wbC5fZnJvbVVzZXIodXNlck1vZHVsYXIgYXMgVXNlckludGVybmFsKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG11bHRpRmFjdG9yVXNlckNhY2hlLmdldCh1c2VyTW9kdWxhcikhO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IFBlcnNpc3RlbmNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IGVudW0gUGVyc2lzdGVuY2VUeXBlIHtcbiAgU0VTU0lPTiA9ICdTRVNTSU9OJyxcbiAgTE9DQUwgPSAnTE9DQUwnLFxuICBOT05FID0gJ05PTkUnXG59XG5cbmV4cG9ydCB0eXBlIFBlcnNpc3RlZEJsb2IgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuZXhwb3J0IGludGVyZmFjZSBJbnN0YW50aWF0b3I8VD4ge1xuICAoYmxvYjogUGVyc2lzdGVkQmxvYik6IFQ7XG59XG5cbmV4cG9ydCB0eXBlIFBlcnNpc3RlbmNlVmFsdWUgPSBQZXJzaXN0ZWRCbG9iIHwgc3RyaW5nO1xuXG5leHBvcnQgY29uc3QgU1RPUkFHRV9BVkFJTEFCTEVfS0VZID0gJ19fc2FrJztcblxuZXhwb3J0IGludGVyZmFjZSBTdG9yYWdlRXZlbnRMaXN0ZW5lciB7XG4gICh2YWx1ZTogUGVyc2lzdGVuY2VWYWx1ZSB8IG51bGwpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBlcnNpc3RlbmNlSW50ZXJuYWwgZXh0ZW5kcyBQZXJzaXN0ZW5jZSB7XG4gIHR5cGU6IFBlcnNpc3RlbmNlVHlwZTtcbiAgX2lzQXZhaWxhYmxlKCk6IFByb21pc2U8Ym9vbGVhbj47XG4gIF9zZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBQZXJzaXN0ZW5jZVZhbHVlKTogUHJvbWlzZTx2b2lkPjtcbiAgX2dldDxUIGV4dGVuZHMgUGVyc2lzdGVuY2VWYWx1ZT4oa2V5OiBzdHJpbmcpOiBQcm9taXNlPFQgfCBudWxsPjtcbiAgX3JlbW92ZShrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XG4gIF9hZGRMaXN0ZW5lcihrZXk6IHN0cmluZywgbGlzdGVuZXI6IFN0b3JhZ2VFdmVudExpc3RlbmVyKTogdm9pZDtcbiAgX3JlbW92ZUxpc3RlbmVyKGtleTogc3RyaW5nLCBsaXN0ZW5lcjogU3RvcmFnZUV2ZW50TGlzdGVuZXIpOiB2b2lkO1xuICAvLyBTaG91bGQgdGhpcyBwZXJzaXN0ZW5jZSBhbGxvdyBtaWdyYXRpb24gdXAgdGhlIGNob3NlbiBoaWVyYXJjaHk/XG4gIF9zaG91bGRBbGxvd01pZ3JhdGlvbj86IGJvb2xlYW47XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBQZXJzaXN0ZW5jZVZhbHVlLFxuICBTVE9SQUdFX0FWQUlMQUJMRV9LRVksXG4gIFBlcnNpc3RlbmNlVHlwZVxufSBmcm9tICcuLi8uLi9jb3JlL3BlcnNpc3RlbmNlJztcblxuLy8gVGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgYnJvd3NlciBwZXJzaXN0ZW5jZSB0eXBlczogbG9jYWwgYW5kIHNlc3Npb24uXG4vLyBCb3RoIGhhdmUgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYnV0IHVzZSBhIGRpZmZlcmVudCB1bmRlcmx5aW5nIHN0b3JhZ2Vcbi8vIG9iamVjdC5cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJyb3dzZXJQZXJzaXN0ZW5jZUNsYXNzIHtcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCByZWFkb25seSBzdG9yYWdlUmV0cmlldmVyOiAoKSA9PiBTdG9yYWdlLFxuICAgIHJlYWRvbmx5IHR5cGU6IFBlcnNpc3RlbmNlVHlwZVxuICApIHt9XG5cbiAgX2lzQXZhaWxhYmxlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuc3RvcmFnZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfQVZBSUxBQkxFX0tFWSwgJzEnKTtcbiAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfQVZBSUxBQkxFX0tFWSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgX3NldChrZXk6IHN0cmluZywgdmFsdWU6IFBlcnNpc3RlbmNlVmFsdWUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgX2dldDxUIGV4dGVuZHMgUGVyc2lzdGVuY2VWYWx1ZT4oa2V5OiBzdHJpbmcpOiBQcm9taXNlPFQgfCBudWxsPiB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShqc29uID8gSlNPTi5wYXJzZShqc29uKSA6IG51bGwpO1xuICB9XG5cbiAgX3JlbW92ZShrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldCBzdG9yYWdlKCk6IFN0b3JhZ2Uge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VSZXRyaWV2ZXIoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUGVyc2lzdGVuY2UgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5pbXBvcnQgeyBnZXRVQSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7XG4gIF9pc1NhZmFyaSxcbiAgX2lzSU9TLFxuICBfaXNJZnJhbWUsXG4gIF9pc01vYmlsZUJyb3dzZXIsXG4gIF9pc0lFMTBcbn0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2Jyb3dzZXInO1xuaW1wb3J0IHtcbiAgUGVyc2lzdGVuY2VJbnRlcm5hbCBhcyBJbnRlcm5hbFBlcnNpc3RlbmNlLFxuICBQZXJzaXN0ZW5jZVR5cGUsXG4gIFBlcnNpc3RlbmNlVmFsdWUsXG4gIFN0b3JhZ2VFdmVudExpc3RlbmVyXG59IGZyb20gJy4uLy4uL2NvcmUvcGVyc2lzdGVuY2UnO1xuaW1wb3J0IHsgQnJvd3NlclBlcnNpc3RlbmNlQ2xhc3MgfSBmcm9tICcuL2Jyb3dzZXInO1xuXG5mdW5jdGlvbiBfaWZyYW1lQ2Fubm90U3luY1dlYlN0b3JhZ2UoKTogYm9vbGVhbiB7XG4gIGNvbnN0IHVhID0gZ2V0VUEoKTtcbiAgcmV0dXJuIF9pc1NhZmFyaSh1YSkgfHwgX2lzSU9TKHVhKTtcbn1cblxuLy8gVGhlIHBvbGxpbmcgcGVyaW9kIGluIGNhc2UgZXZlbnRzIGFyZSBub3Qgc3VwcG9ydGVkXG5leHBvcnQgY29uc3QgX1BPTExJTkdfSU5URVJWQUxfTVMgPSAxMDAwO1xuXG4vLyBUaGUgSUUgMTAgbG9jYWxTdG9yYWdlIGNyb3NzIHRhYiBzeW5jaHJvbml6YXRpb24gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG5jb25zdCBJRTEwX0xPQ0FMX1NUT1JBR0VfU1lOQ19ERUxBWSA9IDEwO1xuXG5jbGFzcyBCcm93c2VyTG9jYWxQZXJzaXN0ZW5jZVxuICBleHRlbmRzIEJyb3dzZXJQZXJzaXN0ZW5jZUNsYXNzXG4gIGltcGxlbWVudHMgSW50ZXJuYWxQZXJzaXN0ZW5jZVxue1xuICBzdGF0aWMgdHlwZTogJ0xPQ0FMJyA9ICdMT0NBTCc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKCkgPT4gd2luZG93LmxvY2FsU3RvcmFnZSwgUGVyc2lzdGVuY2VUeXBlLkxPQ0FMKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgYm91bmRFdmVudEhhbmRsZXIgPSAoXG4gICAgZXZlbnQ6IFN0b3JhZ2VFdmVudCxcbiAgICBwb2xsPzogYm9vbGVhblxuICApOiB2b2lkID0+IHRoaXMub25TdG9yYWdlRXZlbnQoZXZlbnQsIHBvbGwpO1xuICBwcml2YXRlIHJlYWRvbmx5IGxpc3RlbmVyczogUmVjb3JkPHN0cmluZywgU2V0PFN0b3JhZ2VFdmVudExpc3RlbmVyPj4gPSB7fTtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2NhbENhY2hlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudWxsPiA9IHt9O1xuICAvLyBzZXRUaW1lb3V0IHJldHVybiB2YWx1ZSBpcyBwbGF0Zm9ybSBzcGVjaWZpY1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBwcml2YXRlIHBvbGxUaW1lcjogYW55IHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gU2FmYXJpIG9yIGlPUyBicm93c2VyIGFuZCBlbWJlZGRlZCBpbiBhbiBpZnJhbWUuXG4gIHByaXZhdGUgcmVhZG9ubHkgc2FmYXJpTG9jYWxTdG9yYWdlTm90U3luY2VkID1cbiAgICBfaWZyYW1lQ2Fubm90U3luY1dlYlN0b3JhZ2UoKSAmJiBfaXNJZnJhbWUoKTtcbiAgLy8gV2hldGhlciB0byB1c2UgcG9sbGluZyBpbnN0ZWFkIG9mIGRlcGVuZGluZyBvbiB3aW5kb3cgZXZlbnRzXG4gIHByaXZhdGUgcmVhZG9ubHkgZmFsbGJhY2tUb1BvbGxpbmcgPSBfaXNNb2JpbGVCcm93c2VyKCk7XG4gIHJlYWRvbmx5IF9zaG91bGRBbGxvd01pZ3JhdGlvbiA9IHRydWU7XG5cbiAgcHJpdmF0ZSBmb3JBbGxDaGFuZ2VkS2V5cyhcbiAgICBjYjogKGtleTogc3RyaW5nLCBvbGRWYWx1ZTogc3RyaW5nIHwgbnVsbCwgbmV3VmFsdWU6IHN0cmluZyB8IG51bGwpID0+IHZvaWRcbiAgKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgYWxsIGtleXMgd2l0aCBsaXN0ZW5lcnMgb24gdGhlbS5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVycykpIHtcbiAgICAgIC8vIEdldCB2YWx1ZSBmcm9tIGxvY2FsU3RvcmFnZS5cbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5sb2NhbENhY2hlW2tleV07XG4gICAgICAvLyBJZiBsb2NhbCBtYXAgdmFsdWUgZG9lcyBub3QgbWF0Y2gsIHRyaWdnZXIgbGlzdGVuZXIgd2l0aCBzdG9yYWdlIGV2ZW50LlxuICAgICAgLy8gRGlmZmVyZW50aWF0ZSB0aGlzIHNpbXVsYXRlZCBldmVudCBmcm9tIHRoZSByZWFsIHN0b3JhZ2UgZXZlbnQuXG4gICAgICBpZiAobmV3VmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgIGNiKGtleSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uU3RvcmFnZUV2ZW50KGV2ZW50OiBTdG9yYWdlRXZlbnQsIHBvbGwgPSBmYWxzZSk6IHZvaWQge1xuICAgIC8vIEtleSB3b3VsZCBiZSBudWxsIGluIHNvbWUgc2l0dWF0aW9ucywgbGlrZSB3aGVuIGxvY2FsU3RvcmFnZSBpcyBjbGVhcmVkXG4gICAgaWYgKCFldmVudC5rZXkpIHtcbiAgICAgIHRoaXMuZm9yQWxsQ2hhbmdlZEtleXMoXG4gICAgICAgIChrZXk6IHN0cmluZywgX29sZFZhbHVlOiBzdHJpbmcgfCBudWxsLCBuZXdWYWx1ZTogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IGV2ZW50LmtleTtcblxuICAgIC8vIENoZWNrIHRoZSBtZWNoYW5pc20gaG93IHRoaXMgZXZlbnQgd2FzIGRldGVjdGVkLlxuICAgIC8vIFRoZSBmaXJzdCBldmVudCB3aWxsIGRpY3RhdGUgdGhlIG1lY2hhbmlzbSB0byBiZSB1c2VkLlxuICAgIGlmIChwb2xsKSB7XG4gICAgICAvLyBFbnZpcm9ubWVudCBkZXRlY3RzIHN0b3JhZ2UgY2hhbmdlcyB2aWEgcG9sbGluZy5cbiAgICAgIC8vIFJlbW92ZSBzdG9yYWdlIGV2ZW50IGxpc3RlbmVyIHRvIHByZXZlbnQgcG9zc2libGUgZXZlbnQgZHVwbGljYXRpb24uXG4gICAgICB0aGlzLmRldGFjaExpc3RlbmVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVudmlyb25tZW50IGRldGVjdHMgc3RvcmFnZSBjaGFuZ2VzIHZpYSBzdG9yYWdlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgLy8gUmVtb3ZlIHBvbGxpbmcgbGlzdGVuZXIgdG8gcHJldmVudCBwb3NzaWJsZSBldmVudCBkdXBsaWNhdGlvbi5cbiAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG5cbiAgICAvLyBTYWZhcmkgZW1iZWRkZWQgaWZyYW1lLiBTdG9yYWdlIGV2ZW50IHdpbGwgdHJpZ2dlciB3aXRoIHRoZSBkZWx0YVxuICAgIC8vIGNoYW5nZXMgYnV0IG5vIGNoYW5nZXMgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBpZnJhbWUgbG9jYWxTdG9yYWdlLlxuICAgIGlmICh0aGlzLnNhZmFyaUxvY2FsU3RvcmFnZU5vdFN5bmNlZCkge1xuICAgICAgLy8gR2V0IGN1cnJlbnQgaWZyYW1lIHBhZ2UgdmFsdWUuXG4gICAgICBjb25zdCBzdG9yZWRWYWx1ZSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAvLyBWYWx1ZSBub3Qgc3luY2hyb25pemVkLCBzeW5jaHJvbml6ZSBtYW51YWxseS5cbiAgICAgIGlmIChldmVudC5uZXdWYWx1ZSAhPT0gc3RvcmVkVmFsdWUpIHtcbiAgICAgICAgaWYgKGV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gVmFsdWUgY2hhbmdlZCBmcm9tIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCBldmVudC5uZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ3VycmVudCB2YWx1ZSBkZWxldGVkLlxuICAgICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbENhY2hlW2tleV0gPT09IGV2ZW50Lm5ld1ZhbHVlICYmICFwb2xsKSB7XG4gICAgICAgIC8vIEFscmVhZHkgZGV0ZWN0ZWQgYW5kIHByb2Nlc3NlZCwgZG8gbm90IHRyaWdnZXIgbGlzdGVuZXJzIGFnYWluLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdHJpZ2dlckxpc3RlbmVycyA9ICgpOiB2b2lkID0+IHtcbiAgICAgIC8vIEtlZXAgbG9jYWwgbWFwIHVwIHRvIGRhdGUgaW4gY2FzZSBzdG9yYWdlIGV2ZW50IGlzIHRyaWdnZXJlZCBiZWZvcmVcbiAgICAgIC8vIHBvbGwuXG4gICAgICBjb25zdCBzdG9yZWRWYWx1ZSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICBpZiAoIXBvbGwgJiYgdGhpcy5sb2NhbENhY2hlW2tleV0gPT09IHN0b3JlZFZhbHVlKSB7XG4gICAgICAgIC8vIFJlYWwgc3RvcmFnZSBldmVudCB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGRldGVjdGVkLCBkbyBub3RoaW5nLlxuICAgICAgICAvLyBUaGlzIHNlZW1zIHRvIHRyaWdnZXIgaW4gc29tZSBJRSBicm93c2VycyBmb3Igc29tZSByZWFzb24uXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKGtleSwgc3RvcmVkVmFsdWUpO1xuICAgIH07XG5cbiAgICBjb25zdCBzdG9yZWRWYWx1ZSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgaWYgKFxuICAgICAgX2lzSUUxMCgpICYmXG4gICAgICBzdG9yZWRWYWx1ZSAhPT0gZXZlbnQubmV3VmFsdWUgJiZcbiAgICAgIGV2ZW50Lm5ld1ZhbHVlICE9PSBldmVudC5vbGRWYWx1ZVxuICAgICkge1xuICAgICAgLy8gSUUgMTAgaGFzIHRoaXMgd2VpcmQgYnVnIHdoZXJlIGEgc3RvcmFnZSBldmVudCB3b3VsZCB0cmlnZ2VyIHdpdGggdGhlXG4gICAgICAvLyBjb3JyZWN0IGtleSwgb2xkVmFsdWUgYW5kIG5ld1ZhbHVlIGJ1dCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpIGRvZXNcbiAgICAgIC8vIG5vdCB5aWVsZCB0aGUgdXBkYXRlZCB2YWx1ZSB1bnRpbCBhIGZldyBtaWxsaXNlY29uZHMuIFRoaXMgZW5zdXJlc1xuICAgICAgLy8gdGhpcyByZWNvdmVycyBmcm9tIHRoYXQgc2l0dWF0aW9uLlxuICAgICAgc2V0VGltZW91dCh0cmlnZ2VyTGlzdGVuZXJzLCBJRTEwX0xPQ0FMX1NUT1JBR0VfU1lOQ19ERUxBWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG5vdGlmeUxpc3RlbmVycyhrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLmxvY2FsQ2FjaGVba2V5XSA9IHZhbHVlO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2tleV07XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBBcnJheS5mcm9tKGxpc3RlbmVycykpIHtcbiAgICAgICAgbGlzdGVuZXIodmFsdWUgPyBKU09OLnBhcnNlKHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXJ0UG9sbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG5cbiAgICB0aGlzLnBvbGxUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuZm9yQWxsQ2hhbmdlZEtleXMoXG4gICAgICAgIChrZXk6IHN0cmluZywgb2xkVmFsdWU6IHN0cmluZyB8IG51bGwsIG5ld1ZhbHVlOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gICAgICAgICAgdGhpcy5vblN0b3JhZ2VFdmVudChcbiAgICAgICAgICAgIG5ldyBTdG9yYWdlRXZlbnQoJ3N0b3JhZ2UnLCB7XG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgIG5ld1ZhbHVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8qIHBvbGwgKi8gdHJ1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSwgX1BPTExJTkdfSU5URVJWQUxfTVMpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdG9wUG9sbGluZygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wb2xsVGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5wb2xsVGltZXIpO1xuICAgICAgdGhpcy5wb2xsVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXR0YWNoTGlzdGVuZXIoKTogdm9pZCB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyKTtcbiAgfVxuXG4gIHByaXZhdGUgZGV0YWNoTGlzdGVuZXIoKTogdm9pZCB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyKTtcbiAgfVxuXG4gIF9hZGRMaXN0ZW5lcihrZXk6IHN0cmluZywgbGlzdGVuZXI6IFN0b3JhZ2VFdmVudExpc3RlbmVyKTogdm9pZCB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMubGlzdGVuZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFdoZXRoZXIgYnJvd3NlciBjYW4gZGV0ZWN0IHN0b3JhZ2UgZXZlbnQgd2hlbiBpdCBoYWQgYWxyZWFkeSBiZWVuIHB1c2hlZCB0byB0aGUgYmFja2dyb3VuZC5cbiAgICAgIC8vIFRoaXMgbWF5IGhhcHBlbiBpbiBzb21lIG1vYmlsZSBicm93c2Vycy4gQSBsb2NhbFN0b3JhZ2UgY2hhbmdlIGluIHRoZSBmb3JlZ3JvdW5kIHdpbmRvd1xuICAgICAgLy8gd2lsbCBub3QgYmUgZGV0ZWN0ZWQgaW4gdGhlIGJhY2tncm91bmQgd2luZG93IHZpYSB0aGUgc3RvcmFnZSBldmVudC5cbiAgICAgIC8vIFRoaXMgd2FzIGRldGVjdGVkIGluIGlPUyA3LnggbW9iaWxlIGJyb3dzZXJzXG4gICAgICBpZiAodGhpcy5mYWxsYmFja1RvUG9sbGluZykge1xuICAgICAgICB0aGlzLnN0YXJ0UG9sbGluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hdHRhY2hMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzW2tleV0pIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzW2tleV0gPSBuZXcgU2V0KCk7XG4gICAgICAvLyBQb3B1bGF0ZSB0aGUgY2FjaGUgdG8gYXZvaWQgc3B1cmlvdXNseSB0cmlnZ2VyaW5nIG9uIGZpcnN0IHBvbGwuXG4gICAgICB0aGlzLmxvY2FsQ2FjaGVba2V5XSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJzW2tleV0uYWRkKGxpc3RlbmVyKTtcbiAgfVxuXG4gIF9yZW1vdmVMaXN0ZW5lcihrZXk6IHN0cmluZywgbGlzdGVuZXI6IFN0b3JhZ2VFdmVudExpc3RlbmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzW2tleV0pIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzW2tleV0uZGVsZXRlKGxpc3RlbmVyKTtcblxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzW2tleV0uc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5kZXRhY2hMaXN0ZW5lcigpO1xuICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBsb2NhbCBjYWNoZSBvbiBiYXNlIG9wZXJhdGlvbnM6XG5cbiAgYXN5bmMgX3NldChrZXk6IHN0cmluZywgdmFsdWU6IFBlcnNpc3RlbmNlVmFsdWUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBzdXBlci5fc2V0KGtleSwgdmFsdWUpO1xuICAgIHRoaXMubG9jYWxDYWNoZVtrZXldID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG5cbiAgYXN5bmMgX2dldDxUIGV4dGVuZHMgUGVyc2lzdGVuY2VWYWx1ZT4oa2V5OiBzdHJpbmcpOiBQcm9taXNlPFQgfCBudWxsPiB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBzdXBlci5fZ2V0PFQ+KGtleSk7XG4gICAgdGhpcy5sb2NhbENhY2hlW2tleV0gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgYXN5bmMgX3JlbW92ZShrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHN1cGVyLl9yZW1vdmUoa2V5KTtcbiAgICBkZWxldGUgdGhpcy5sb2NhbENhY2hlW2tleV07XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgUGVyc2lzdGVuY2V9IG9mIHR5cGUgYExPQ0FMYCB1c2luZyBgbG9jYWxTdG9yYWdlYFxuICogZm9yIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYnJvd3NlckxvY2FsUGVyc2lzdGVuY2U6IFBlcnNpc3RlbmNlID0gQnJvd3NlckxvY2FsUGVyc2lzdGVuY2U7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQZXJzaXN0ZW5jZSB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7XG4gIFBlcnNpc3RlbmNlSW50ZXJuYWwgYXMgSW50ZXJuYWxQZXJzaXN0ZW5jZSxcbiAgUGVyc2lzdGVuY2VUeXBlLFxuICBTdG9yYWdlRXZlbnRMaXN0ZW5lclxufSBmcm9tICcuLi8uLi9jb3JlL3BlcnNpc3RlbmNlJztcbmltcG9ydCB7IEJyb3dzZXJQZXJzaXN0ZW5jZUNsYXNzIH0gZnJvbSAnLi9icm93c2VyJztcblxuY2xhc3MgQnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZVxuICBleHRlbmRzIEJyb3dzZXJQZXJzaXN0ZW5jZUNsYXNzXG4gIGltcGxlbWVudHMgSW50ZXJuYWxQZXJzaXN0ZW5jZVxue1xuICBzdGF0aWMgdHlwZTogJ1NFU1NJT04nID0gJ1NFU1NJT04nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCgpID0+IHdpbmRvdy5zZXNzaW9uU3RvcmFnZSwgUGVyc2lzdGVuY2VUeXBlLlNFU1NJT04pO1xuICB9XG5cbiAgX2FkZExpc3RlbmVyKF9rZXk6IHN0cmluZywgX2xpc3RlbmVyOiBTdG9yYWdlRXZlbnRMaXN0ZW5lcik6IHZvaWQge1xuICAgIC8vIExpc3RlbmVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3Igc2Vzc2lvbiBzdG9yYWdlIHNpbmNlIGl0IGNhbm5vdCBiZSBzaGFyZWQgYWNyb3NzIHdpbmRvd3NcbiAgICByZXR1cm47XG4gIH1cblxuICBfcmVtb3ZlTGlzdGVuZXIoX2tleTogc3RyaW5nLCBfbGlzdGVuZXI6IFN0b3JhZ2VFdmVudExpc3RlbmVyKTogdm9pZCB7XG4gICAgLy8gTGlzdGVuZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBzZXNzaW9uIHN0b3JhZ2Ugc2luY2UgaXQgY2Fubm90IGJlIHNoYXJlZCBhY3Jvc3Mgd2luZG93c1xuICAgIHJldHVybjtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBQZXJzaXN0ZW5jZX0gb2YgYFNFU1NJT05gIHVzaW5nIGBzZXNzaW9uU3RvcmFnZWBcbiAqIGZvciB0aGUgdW5kZXJseWluZyBzdG9yYWdlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2U6IFBlcnNpc3RlbmNlID0gQnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBUT0RPOiByZW1vdmUgdGhpcyBvbmNlIHRzbGliIGhhcyBhIHBvbHlmaWxsIGZvciBQcm9taXNlLmFsbFNldHRsZWQgKi9cbmludGVyZmFjZSBQcm9taXNlRnVsZmlsbGVkUmVzdWx0PFQ+IHtcbiAgZnVsZmlsbGVkOiB0cnVlO1xuICB2YWx1ZTogVDtcbn1cblxuaW50ZXJmYWNlIFByb21pc2VSZWplY3RlZFJlc3VsdCB7XG4gIGZ1bGZpbGxlZDogZmFsc2U7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHJlYXNvbjogYW55O1xufVxuXG5leHBvcnQgdHlwZSBQcm9taXNlU2V0dGxlZFJlc3VsdDxUPiA9XG4gIHwgUHJvbWlzZUZ1bGZpbGxlZFJlc3VsdDxUPlxuICB8IFByb21pc2VSZWplY3RlZFJlc3VsdDtcblxuLyoqXG4gKiBTaGltIGZvciBQcm9taXNlLmFsbFNldHRsZWQsIG5vdGUgdGhlIHNsaWdodGx5IGRpZmZlcmVudCBmb3JtYXQgb2YgYGZ1bGZpbGxlZGAgdnMgYHN0YXR1c2AuXG4gKlxuICogQHBhcmFtIHByb21pc2VzIC0gQXJyYXkgb2YgcHJvbWlzZXMgdG8gd2FpdCBvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hbGxTZXR0bGVkPFQ+KFxuICBwcm9taXNlczogQXJyYXk8UHJvbWlzZTxUPj5cbik6IFByb21pc2U8QXJyYXk8UHJvbWlzZVNldHRsZWRSZXN1bHQ8VD4+PiB7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBwcm9taXNlcy5tYXAoYXN5bmMgcHJvbWlzZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHByb21pc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnVsZmlsbGVkOiB0cnVlLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0gYXMgUHJvbWlzZUZ1bGZpbGxlZFJlc3VsdDxUPjtcbiAgICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZ1bGZpbGxlZDogZmFsc2UsXG4gICAgICAgICAgcmVhc29uXG4gICAgICAgIH0gYXMgUHJvbWlzZVJlamVjdGVkUmVzdWx0O1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBSZWNlaXZlckhhbmRsZXIsXG4gIF9FdmVudFR5cGUsXG4gIF9SZWNlaXZlclJlc3BvbnNlLFxuICBTZW5kZXJNZXNzYWdlRXZlbnQsXG4gIF9TdGF0dXMsXG4gIF9TZW5kZXJSZXF1ZXN0XG59IGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgX2FsbFNldHRsZWQgfSBmcm9tICcuL3Byb21pc2UnO1xuXG4vKipcbiAqIEludGVyZmFjZSBjbGFzcyBmb3IgcmVjZWl2aW5nIG1lc3NhZ2VzLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFJlY2VpdmVyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgcmVjZWl2ZXJzOiBSZWNlaXZlcltdID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgYm91bmRFdmVudEhhbmRsZXI6IEV2ZW50TGlzdGVuZXI7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBoYW5kbGVyc01hcDoge1xuICAgIC8vIFR5cGVzY3JpcHQgZG9lc24ndCBoYXZlIGV4aXN0ZW50aWFsIHR5cGVzIDooXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBbZXZlbnRUeXBlOiBzdHJpbmddOiBTZXQ8UmVjZWl2ZXJIYW5kbGVyPGFueSwgYW55Pj47XG4gIH0gPSB7fTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGV2ZW50VGFyZ2V0OiBFdmVudFRhcmdldCkge1xuICAgIHRoaXMuYm91bmRFdmVudEhhbmRsZXIgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogT2J0YWluIGFuIGluc3RhbmNlIG9mIGEgUmVjZWl2ZXIgZm9yIGEgZ2l2ZW4gZXZlbnQgdGFyZ2V0LCBpZiBub25lIGV4aXN0cyBpdCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudFRhcmdldCAtIEFuIGV2ZW50IHRhcmdldCAoc3VjaCBhcyB3aW5kb3cgb3Igc2VsZikgdGhyb3VnaCB3aGljaCB0aGUgdW5kZXJseWluZ1xuICAgKiBtZXNzYWdlcyB3aWxsIGJlIHJlY2VpdmVkLlxuICAgKi9cbiAgc3RhdGljIF9nZXRJbnN0YW5jZShldmVudFRhcmdldDogRXZlbnRUYXJnZXQpOiBSZWNlaXZlciB7XG4gICAgLy8gVGhlIHJlc3VsdHMgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSBzaW5jZSBvYmplY3RzIGNhbid0IGJlIGtleXMgZm9yIG90aGVyXG4gICAgLy8gb2JqZWN0cy4gSW4gYWRkaXRpb24sIHNldHRpbmcgYSB1bmlxdWUgcHJvcGVydHkgb24gYW4gZXZlbnQgdGFyZ2V0IGFzIGFcbiAgICAvLyBoYXNoIG1hcCBrZXkgbWF5IG5vdCBiZSBhbGxvd2VkIGR1ZSB0byBDT1JTIHJlc3RyaWN0aW9ucy5cbiAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gdGhpcy5yZWNlaXZlcnMuZmluZChyZWNlaXZlciA9PlxuICAgICAgcmVjZWl2ZXIuaXNMaXN0ZW5pbmd0byhldmVudFRhcmdldClcbiAgICApO1xuICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdJbnN0YW5jZTtcbiAgICB9XG4gICAgY29uc3QgbmV3SW5zdGFuY2UgPSBuZXcgUmVjZWl2ZXIoZXZlbnRUYXJnZXQpO1xuICAgIHRoaXMucmVjZWl2ZXJzLnB1c2gobmV3SW5zdGFuY2UpO1xuICAgIHJldHVybiBuZXdJbnN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgaXNMaXN0ZW5pbmd0byhldmVudFRhcmdldDogRXZlbnRUYXJnZXQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudFRhcmdldCA9PT0gZXZlbnRUYXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogRmFucyBvdXQgYSBNZXNzYWdlRXZlbnQgdG8gdGhlIGFwcHJvcHJpYXRlIGxpc3RlbmVycy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogU2VuZHMgYW4ge0BsaW5rIFN0YXR1cy5BQ0t9IHVwb24gcmVjZWlwdCBhbmQgYSB7QGxpbmsgU3RhdHVzLkRPTkV9IG9uY2UgYWxsIGhhbmRsZXJzIGhhdmVcbiAgICogZmluaXNoZWQgcHJvY2Vzc2luZy5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE1lc3NhZ2VFdmVudC5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlRXZlbnQ8XG4gICAgVCBleHRlbmRzIF9SZWNlaXZlclJlc3BvbnNlLFxuICAgIFMgZXh0ZW5kcyBfU2VuZGVyUmVxdWVzdFxuICA+KGV2ZW50OiBFdmVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1lc3NhZ2VFdmVudCA9IGV2ZW50IGFzIE1lc3NhZ2VFdmVudDxTZW5kZXJNZXNzYWdlRXZlbnQ8Uz4+O1xuICAgIGNvbnN0IHsgZXZlbnRJZCwgZXZlbnRUeXBlLCBkYXRhIH0gPSBtZXNzYWdlRXZlbnQuZGF0YTtcblxuICAgIGNvbnN0IGhhbmRsZXJzOiBTZXQ8UmVjZWl2ZXJIYW5kbGVyPFQsIFM+PiB8IHVuZGVmaW5lZCA9XG4gICAgICB0aGlzLmhhbmRsZXJzTWFwW2V2ZW50VHlwZV07XG4gICAgaWYgKCFoYW5kbGVycz8uc2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1lc3NhZ2VFdmVudC5wb3J0c1swXS5wb3N0TWVzc2FnZSh7XG4gICAgICBzdGF0dXM6IF9TdGF0dXMuQUNLLFxuICAgICAgZXZlbnRJZCxcbiAgICAgIGV2ZW50VHlwZVxuICAgIH0pO1xuXG4gICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKGhhbmRsZXJzKS5tYXAoYXN5bmMgaGFuZGxlciA9PlxuICAgICAgaGFuZGxlcihtZXNzYWdlRXZlbnQub3JpZ2luLCBkYXRhKVxuICAgICk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfYWxsU2V0dGxlZChwcm9taXNlcyk7XG4gICAgbWVzc2FnZUV2ZW50LnBvcnRzWzBdLnBvc3RNZXNzYWdlKHtcbiAgICAgIHN0YXR1czogX1N0YXR1cy5ET05FLFxuICAgICAgZXZlbnRJZCxcbiAgICAgIGV2ZW50VHlwZSxcbiAgICAgIHJlc3BvbnNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGEgcGFydGljdWxhciBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50VHlwZSAtIEV2ZW50IG5hbWUgdG8gc3Vic2NyaWJlIHRvLlxuICAgKiBAcGFyYW0gZXZlbnRIYW5kbGVyIC0gVGhlIGV2ZW50IGhhbmRsZXIgd2hpY2ggc2hvdWxkIHJlY2VpdmUgdGhlIGV2ZW50cy5cbiAgICpcbiAgICovXG4gIF9zdWJzY3JpYmU8VCBleHRlbmRzIF9SZWNlaXZlclJlc3BvbnNlLCBTIGV4dGVuZHMgX1NlbmRlclJlcXVlc3Q+KFxuICAgIGV2ZW50VHlwZTogX0V2ZW50VHlwZSxcbiAgICBldmVudEhhbmRsZXI6IFJlY2VpdmVySGFuZGxlcjxULCBTPlxuICApOiB2b2lkIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5oYW5kbGVyc01hcCkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGFuZGxlcnNNYXBbZXZlbnRUeXBlXSkge1xuICAgICAgdGhpcy5oYW5kbGVyc01hcFtldmVudFR5cGVdID0gbmV3IFNldCgpO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlcnNNYXBbZXZlbnRUeXBlXS5hZGQoZXZlbnRIYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBhbiBldmVudCBoYW5kbGVyIGZyb20gYSBwYXJ0aWN1bGFyIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gRXZlbnQgbmFtZSB0byB1bnN1YnNjcmliZSBmcm9tLlxuICAgKiBAcGFyYW0gZXZlbnRIYW5kbGVyIC0gT3B0aW5vYWwgZXZlbnQgaGFuZGxlciwgaWYgbm9uZSBwcm92aWRlZCwgdW5zdWJzY3JpYmUgYWxsIGhhbmRsZXJzIG9uIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqL1xuICBfdW5zdWJzY3JpYmU8VCBleHRlbmRzIF9SZWNlaXZlclJlc3BvbnNlLCBTIGV4dGVuZHMgX1NlbmRlclJlcXVlc3Q+KFxuICAgIGV2ZW50VHlwZTogX0V2ZW50VHlwZSxcbiAgICBldmVudEhhbmRsZXI/OiBSZWNlaXZlckhhbmRsZXI8VCwgUz5cbiAgKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNNYXBbZXZlbnRUeXBlXSAmJiBldmVudEhhbmRsZXIpIHtcbiAgICAgIHRoaXMuaGFuZGxlcnNNYXBbZXZlbnRUeXBlXS5kZWxldGUoZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKCFldmVudEhhbmRsZXIgfHwgdGhpcy5oYW5kbGVyc01hcFtldmVudFR5cGVdLnNpemUgPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmhhbmRsZXJzTWFwW2V2ZW50VHlwZV07XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcnNNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5ldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5ib3VuZEV2ZW50SGFuZGxlcik7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gX2dlbmVyYXRlRXZlbnRJZChwcmVmaXggPSAnJywgZGlnaXRzID0gMTApOiBzdHJpbmcge1xuICBsZXQgcmFuZG9tID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlnaXRzOyBpKyspIHtcbiAgICByYW5kb20gKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApO1xuICB9XG4gIHJldHVybiBwcmVmaXggKyByYW5kb207XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBfZ2VuZXJhdGVFdmVudElkIH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2V2ZW50X2lkJztcbmltcG9ydCB7XG4gIF9TZW5kZXJSZXF1ZXN0LFxuICBfRXZlbnRUeXBlLFxuICBSZWNlaXZlck1lc3NhZ2VFdmVudCxcbiAgX01lc3NhZ2VFcnJvcixcbiAgU2VuZGVyTWVzc2FnZUV2ZW50LFxuICBfU3RhdHVzLFxuICBfUmVjZWl2ZXJNZXNzYWdlUmVzcG9uc2UsXG4gIF9SZWNlaXZlclJlc3BvbnNlLFxuICBfVGltZW91dER1cmF0aW9uXG59IGZyb20gJy4vaW5kZXgnO1xuXG5pbnRlcmZhY2UgTWVzc2FnZUhhbmRsZXIge1xuICBtZXNzYWdlQ2hhbm5lbDogTWVzc2FnZUNoYW5uZWw7XG4gIG9uTWVzc2FnZTogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdDtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHNlbmRpbmcgbWVzc2FnZXMgYW5kIHdhaXRpbmcgZm9yIGEgY29tcGxldGlvbiByZXNwb25zZS5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBTZW5kZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGhhbmRsZXJzID0gbmV3IFNldDxNZXNzYWdlSGFuZGxlcj4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHRhcmdldDogU2VydmljZVdvcmtlcikge31cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgdGhlIGhhbmRsZXIgYW5kIHJlbW92ZSBpdCBmcm9tIG91ciB0cmFja2luZyBTZXQuXG4gICAqXG4gICAqIEBwYXJhbSBoYW5kbGVyIC0gVGhlIGhhbmRsZXIgdG8gdW5zdWJzY3JpYmUuXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZU1lc3NhZ2VIYW5kbGVyKGhhbmRsZXI6IE1lc3NhZ2VIYW5kbGVyKTogdm9pZCB7XG4gICAgaWYgKGhhbmRsZXIubWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgIGhhbmRsZXIubWVzc2FnZUNoYW5uZWwucG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgJ21lc3NhZ2UnLFxuICAgICAgICBoYW5kbGVyLm9uTWVzc2FnZVxuICAgICAgKTtcbiAgICAgIGhhbmRsZXIubWVzc2FnZUNoYW5uZWwucG9ydDEuY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVycy5kZWxldGUoaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIFJlY2VpdmVyIGxvY2F0ZWQgYXQge0BsaW5rIHRhcmdldH0uXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFdlJ2xsIGZpcnN0IHdhaXQgYSBiaXQgZm9yIGFuIEFDSyAsIGlmIHdlIGdldCBvbmUgd2Ugd2lsbCB3YWl0IHNpZ25pZmljYW50bHkgbG9uZ2VyIHVudGlsIHRoZVxuICAgKiByZWNlaXZlciBoYXMgaGFkIGEgY2hhbmNlIHRvIGZ1bGx5IHByb2Nlc3MgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gVHlwZSBvZiBldmVudCB0byBzZW5kLlxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBwYXlsb2FkIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHRpbWVvdXQgLSBUaW1lb3V0IGZvciB3YWl0aW5nIG9uIGFuIEFDSyBmcm9tIHRoZSByZWNlaXZlci5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc2V0dGxlZCBwcm9taXNlcyBmcm9tIGFsbCB0aGUgaGFuZGxlcnMgdGhhdCB3ZXJlIGxpc3RlbmluZyBvbiB0aGUgcmVjZWl2ZXIuXG4gICAqL1xuICBhc3luYyBfc2VuZDxUIGV4dGVuZHMgX1JlY2VpdmVyUmVzcG9uc2UsIFMgZXh0ZW5kcyBfU2VuZGVyUmVxdWVzdD4oXG4gICAgZXZlbnRUeXBlOiBfRXZlbnRUeXBlLFxuICAgIGRhdGE6IFMsXG4gICAgdGltZW91dCA9IF9UaW1lb3V0RHVyYXRpb24uQUNLXG4gICk6IFByb21pc2U8X1JlY2VpdmVyTWVzc2FnZVJlc3BvbnNlPFQ+PiB7XG4gICAgY29uc3QgbWVzc2FnZUNoYW5uZWwgPVxuICAgICAgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJyA/IG5ldyBNZXNzYWdlQ2hhbm5lbCgpIDogbnVsbDtcbiAgICBpZiAoIW1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoX01lc3NhZ2VFcnJvci5DT05ORUNUSU9OX1VOQVZBSUxBQkxFKTtcbiAgICB9XG4gICAgLy8gTm9kZSB0aW1lcnMgYW5kIGJyb3dzZXIgdGltZXJzIHJldHVybiBmdW5kYW1lbnRhbGx5IGRpZmZlcmVudCB0eXBlcy5cbiAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBjYXJlIHdoYXQgdGhlIHZhbHVlIGlzIGJ1dCBUUyB3b24ndCBhY2NlcHQgdW5rbm93biBhbmRcbiAgICAvLyB3ZSBjYW4ndCBjYXN0IHByb3Blcmx5IGluIGJvdGggZW52aXJvbm1lbnRzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbGV0IGNvbXBsZXRpb25UaW1lcjogYW55O1xuICAgIGxldCBoYW5kbGVyOiBNZXNzYWdlSGFuZGxlcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8X1JlY2VpdmVyTWVzc2FnZVJlc3BvbnNlPFQ+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBldmVudElkID0gX2dlbmVyYXRlRXZlbnRJZCgnJywgMjApO1xuICAgICAgbWVzc2FnZUNoYW5uZWwucG9ydDEuc3RhcnQoKTtcbiAgICAgIGNvbnN0IGFja1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoX01lc3NhZ2VFcnJvci5VTlNVUFBPUlRFRF9FVkVOVCkpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgICBoYW5kbGVyID0ge1xuICAgICAgICBtZXNzYWdlQ2hhbm5lbCxcbiAgICAgICAgb25NZXNzYWdlKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2VFdmVudCA9IGV2ZW50IGFzIE1lc3NhZ2VFdmVudDxSZWNlaXZlck1lc3NhZ2VFdmVudDxUPj47XG4gICAgICAgICAgaWYgKG1lc3NhZ2VFdmVudC5kYXRhLmV2ZW50SWQgIT09IGV2ZW50SWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChtZXNzYWdlRXZlbnQuZGF0YS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgX1N0YXR1cy5BQ0s6XG4gICAgICAgICAgICAgIC8vIFRoZSByZWNlaXZlciBzaG91bGQgQUNLIGZpcnN0LlxuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYWNrVGltZXIpO1xuICAgICAgICAgICAgICBjb21wbGV0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKF9NZXNzYWdlRXJyb3IuVElNRU9VVCkpO1xuICAgICAgICAgICAgICB9LCBfVGltZW91dER1cmF0aW9uLkNPTVBMRVRJT04pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1N0YXR1cy5ET05FOlxuICAgICAgICAgICAgICAvLyBPbmNlIHRoZSByZWNlaXZlcidzIGhhbmRsZXJzIGFyZSBmaW5pc2hlZCB3ZSB3aWxsIGdldCB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbXBsZXRpb25UaW1lcik7XG4gICAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZUV2ZW50LmRhdGEucmVzcG9uc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChhY2tUaW1lcik7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb21wbGV0aW9uVGltZXIpO1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKF9NZXNzYWdlRXJyb3IuSU5WQUxJRF9SRVNQT05TRSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmhhbmRsZXJzLmFkZChoYW5kbGVyKTtcbiAgICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQxLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLm9uTWVzc2FnZSk7XG4gICAgICB0aGlzLnRhcmdldC5wb3N0TWVzc2FnZShcbiAgICAgICAge1xuICAgICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgICBldmVudElkLFxuICAgICAgICAgIGRhdGFcbiAgICAgICAgfSBhcyBTZW5kZXJNZXNzYWdlRXZlbnQ8Uz4sXG4gICAgICAgIFttZXNzYWdlQ2hhbm5lbC5wb3J0Ml1cbiAgICAgICk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICB0aGlzLnJlbW92ZU1lc3NhZ2VIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBSZWNhcHRjaGEsIEdyZUNBUFRDSEFUb3BMZXZlbCB9IGZyb20gJy4vcmVjYXB0Y2hhL3JlY2FwdGNoYSc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB3aW5kb3cgdHlwZSB0aGF0IG1lbGRzIHRoZSBub3JtYWwgd2luZG93IHR5cGUgcGx1cyB0aGVcbiAqIHZhcmlvdXMgYml0cyB3ZSBuZWVkLiBUaGUgdGhyZWUgZGlmZmVyZW50IGJsb2NrcyB0aGF0IGFyZSAmJ2QgdG9nZXRoZXJcbiAqIGNhbnQgYmUgZGVmaW5lZCBpbiB0aGUgc2FtZSBibG9jayB0b2dldGhlci5cbiAqL1xuZXhwb3J0IHR5cGUgQXV0aFdpbmRvdyA9IHtcbiAgLy8gU3RhbmRhcmQgd2luZG93IHR5cGVzXG4gIFtUIGluIGtleW9mIFdpbmRvd106IFdpbmRvd1tUXTtcbn0gJiB7XG4gIC8vIEFueSBrbm93biAvIG5hbWVkIHByb3BlcnRpZXMgd2Ugd2FudCB0byBhZGRcbiAgZ3JlY2FwdGNoYT86IFJlY2FwdGNoYSB8IEdyZUNBUFRDSEFUb3BMZXZlbDtcbiAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbiAgX19fanNsPzogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgZ2FwaT86IHR5cGVvZiBnYXBpO1xufSAmIHtcbiAgLy8gQSBmaW5hbCBjYXRjaC1hbGwgZm9yIGNhbGxiYWNrcyAod2hpY2ggd2lsbCBoYXZlIHJhbmRvbSBuYW1lcykgdGhhdFxuICAvLyB3ZSB3aWxsIHN0aWNrIG9uIHRoZSB3aW5kb3cuXG4gIFtjYWxsYmFjazogc3RyaW5nXTogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZDtcbn07XG5cbi8qKlxuICogTGF6eSBhY2Nlc3NvciBmb3Igd2luZG93LCBzaW5jZSB0aGUgY29tcGF0IGxheWVyIHdvbid0IHRyZWUgc2hha2UgdGhpcyBvdXQsXG4gKiB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBub3QgdG8gbWVzcyB3aXRoIHdpbmRvdyB1bmxlc3Mgd2UgaGF2ZSB0b1xuICovXG5leHBvcnQgZnVuY3Rpb24gX3dpbmRvdygpOiBBdXRoV2luZG93IHtcbiAgcmV0dXJuIHdpbmRvdyBhcyB1bmtub3duIGFzIEF1dGhXaW5kb3c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2V0V2luZG93TG9jYXRpb24odXJsOiBzdHJpbmcpOiB2b2lkIHtcbiAgX3dpbmRvdygpLmxvY2F0aW9uLmhyZWYgPSB1cmw7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgX3dpbmRvdyB9IGZyb20gJy4uL2F1dGhfd2luZG93JztcblxuZXhwb3J0IGZ1bmN0aW9uIF9pc1dvcmtlcigpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgX3dpbmRvdygpWydXb3JrZXJHbG9iYWxTY29wZSddICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBfd2luZG93KClbJ2ltcG9ydFNjcmlwdHMnXSA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX2dldEFjdGl2ZVNlcnZpY2VXb3JrZXIoKTogUHJvbWlzZTxTZXJ2aWNlV29ya2VyIHwgbnVsbD4ge1xuICBpZiAoIW5hdmlnYXRvcj8uc2VydmljZVdvcmtlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVnaXN0cmF0aW9uID0gYXdhaXQgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVhZHk7XG4gICAgcmV0dXJuIHJlZ2lzdHJhdGlvbi5hY3RpdmU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0U2VydmljZVdvcmtlckNvbnRyb2xsZXIoKTogU2VydmljZVdvcmtlciB8IG51bGwge1xuICByZXR1cm4gbmF2aWdhdG9yPy5zZXJ2aWNlV29ya2VyPy5jb250cm9sbGVyIHx8IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0V29ya2VyR2xvYmFsU2NvcGUoKTogU2VydmljZVdvcmtlciB8IG51bGwge1xuICByZXR1cm4gX2lzV29ya2VyKCkgPyAoc2VsZiBhcyB1bmtub3duIGFzIFNlcnZpY2VXb3JrZXIpIDogbnVsbDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFBlcnNpc3RlbmNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7XG4gIFBlcnNpc3RlZEJsb2IsXG4gIFBlcnNpc3RlbmNlSW50ZXJuYWwgYXMgSW50ZXJuYWxQZXJzaXN0ZW5jZSxcbiAgUGVyc2lzdGVuY2VUeXBlLFxuICBQZXJzaXN0ZW5jZVZhbHVlLFxuICBTdG9yYWdlRXZlbnRMaXN0ZW5lcixcbiAgU1RPUkFHRV9BVkFJTEFCTEVfS0VZXG59IGZyb20gJy4uLy4uL2NvcmUvcGVyc2lzdGVuY2UvJztcbmltcG9ydCB7XG4gIF9FdmVudFR5cGUsXG4gIF9QaW5nUmVzcG9uc2UsXG4gIEtleUNoYW5nZWRSZXNwb25zZSxcbiAgS2V5Q2hhbmdlZFJlcXVlc3QsXG4gIFBpbmdSZXF1ZXN0LFxuICBfVGltZW91dER1cmF0aW9uXG59IGZyb20gJy4uL21lc3NhZ2VjaGFubmVsL2luZGV4JztcbmltcG9ydCB7IFJlY2VpdmVyIH0gZnJvbSAnLi4vbWVzc2FnZWNoYW5uZWwvcmVjZWl2ZXInO1xuaW1wb3J0IHsgU2VuZGVyIH0gZnJvbSAnLi4vbWVzc2FnZWNoYW5uZWwvc2VuZGVyJztcbmltcG9ydCB7XG4gIF9pc1dvcmtlcixcbiAgX2dldEFjdGl2ZVNlcnZpY2VXb3JrZXIsXG4gIF9nZXRTZXJ2aWNlV29ya2VyQ29udHJvbGxlcixcbiAgX2dldFdvcmtlckdsb2JhbFNjb3BlXG59IGZyb20gJy4uL3V0aWwvd29ya2VyJztcblxuZXhwb3J0IGNvbnN0IERCX05BTUUgPSAnZmlyZWJhc2VMb2NhbFN0b3JhZ2VEYic7XG5jb25zdCBEQl9WRVJTSU9OID0gMTtcbmNvbnN0IERCX09CSkVDVFNUT1JFX05BTUUgPSAnZmlyZWJhc2VMb2NhbFN0b3JhZ2UnO1xuY29uc3QgREJfREFUQV9LRVlQQVRIID0gJ2ZiYXNlX2tleSc7XG5cbmludGVyZmFjZSBEQk9iamVjdCB7XG4gIFtEQl9EQVRBX0tFWVBBVEhdOiBzdHJpbmc7XG4gIHZhbHVlOiBQZXJzaXN0ZWRCbG9iO1xufVxuXG4vKipcbiAqIFByb21pc2Ugd3JhcHBlciBmb3IgSURCUmVxdWVzdFxuICpcbiAqIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3QgY2xlYW5seSBleHRlbmQgUHJvbWlzZTxUPiBzaW5jZSBwcm9taXNlcyBhcmUgbm90IGNhbGxhYmxlIGluIEVTNlxuICpcbiAqL1xuY2xhc3MgREJQcm9taXNlPFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSByZXF1ZXN0OiBJREJSZXF1ZXN0KSB7fVxuXG4gIHRvUHJvbWlzZSgpOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUodGhpcy5yZXF1ZXN0LnJlc3VsdCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgcmVqZWN0KHRoaXMucmVxdWVzdC5lcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRPYmplY3RTdG9yZShkYjogSURCRGF0YWJhc2UsIGlzUmVhZFdyaXRlOiBib29sZWFuKTogSURCT2JqZWN0U3RvcmUge1xuICByZXR1cm4gZGJcbiAgICAudHJhbnNhY3Rpb24oW0RCX09CSkVDVFNUT1JFX05BTUVdLCBpc1JlYWRXcml0ZSA/ICdyZWFkd3JpdGUnIDogJ3JlYWRvbmx5JylcbiAgICAub2JqZWN0U3RvcmUoREJfT0JKRUNUU1RPUkVfTkFNRSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfY2xlYXJEYXRhYmFzZShkYjogSURCRGF0YWJhc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3Qgb2JqZWN0U3RvcmUgPSBnZXRPYmplY3RTdG9yZShkYiwgdHJ1ZSk7XG4gIHJldHVybiBuZXcgREJQcm9taXNlPHZvaWQ+KG9iamVjdFN0b3JlLmNsZWFyKCkpLnRvUHJvbWlzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2RlbGV0ZURhdGFiYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKERCX05BTUUpO1xuICByZXR1cm4gbmV3IERCUHJvbWlzZTx2b2lkPihyZXF1ZXN0KS50b1Byb21pc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9vcGVuRGF0YWJhc2UoKTogUHJvbWlzZTxJREJEYXRhYmFzZT4ge1xuICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oREJfTkFNRSwgREJfVkVSU0lPTik7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICB9KTtcblxuICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigndXBncmFkZW5lZWRlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGRiID0gcmVxdWVzdC5yZXN1bHQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERCX09CSkVDVFNUT1JFX05BTUUsIHsga2V5UGF0aDogREJfREFUQV9LRVlQQVRIIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYjogSURCRGF0YWJhc2UgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgIC8vIFN0cmFuZ2UgYnVnIHRoYXQgb2NjdXJzIGluIEZpcmVmb3ggd2hlbiBtdWx0aXBsZSB0YWJzIGFyZSBvcGVuZWQgYXQgdGhlXG4gICAgICAvLyBzYW1lIHRpbWUuIFRoZSBvbmx5IHdheSB0byByZWNvdmVyIHNlZW1zIHRvIGJlIGRlbGV0aW5nIHRoZSBkYXRhYmFzZVxuICAgICAgLy8gYW5kIHJlLWluaXRpYWxpemluZyBpdC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzYzNFxuXG4gICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoREJfT0JKRUNUU1RPUkVfTkFNRSkpIHtcbiAgICAgICAgLy8gTmVlZCB0byBjbG9zZSB0aGUgZGF0YWJhc2Ugb3IgZWxzZSB5b3UgZ2V0IGEgYGJsb2NrZWRgIGV2ZW50XG4gICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgIGF3YWl0IF9kZWxldGVEYXRhYmFzZSgpO1xuICAgICAgICByZXNvbHZlKGF3YWl0IF9vcGVuRGF0YWJhc2UoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGRiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcHV0T2JqZWN0KFxuICBkYjogSURCRGF0YWJhc2UsXG4gIGtleTogc3RyaW5nLFxuICB2YWx1ZTogUGVyc2lzdGVuY2VWYWx1ZSB8IHN0cmluZ1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJlcXVlc3QgPSBnZXRPYmplY3RTdG9yZShkYiwgdHJ1ZSkucHV0KHtcbiAgICBbREJfREFUQV9LRVlQQVRIXToga2V5LFxuICAgIHZhbHVlXG4gIH0pO1xuICByZXR1cm4gbmV3IERCUHJvbWlzZTx2b2lkPihyZXF1ZXN0KS50b1Byb21pc2UoKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0T2JqZWN0KFxuICBkYjogSURCRGF0YWJhc2UsXG4gIGtleTogc3RyaW5nXG4pOiBQcm9taXNlPFBlcnNpc3RlZEJsb2IgfCBudWxsPiB7XG4gIGNvbnN0IHJlcXVlc3QgPSBnZXRPYmplY3RTdG9yZShkYiwgZmFsc2UpLmdldChrZXkpO1xuICBjb25zdCBkYXRhID0gYXdhaXQgbmV3IERCUHJvbWlzZTxEQk9iamVjdCB8IHVuZGVmaW5lZD4ocmVxdWVzdCkudG9Qcm9taXNlKCk7XG4gIHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogZGF0YS52YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9kZWxldGVPYmplY3QoZGI6IElEQkRhdGFiYXNlLCBrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZXF1ZXN0ID0gZ2V0T2JqZWN0U3RvcmUoZGIsIHRydWUpLmRlbGV0ZShrZXkpO1xuICByZXR1cm4gbmV3IERCUHJvbWlzZTx2b2lkPihyZXF1ZXN0KS50b1Byb21pc2UoKTtcbn1cblxuZXhwb3J0IGNvbnN0IF9QT0xMSU5HX0lOVEVSVkFMX01TID0gODAwO1xuZXhwb3J0IGNvbnN0IF9UUkFOU0FDVElPTl9SRVRSWV9DT1VOVCA9IDM7XG5cbmNsYXNzIEluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2UgaW1wbGVtZW50cyBJbnRlcm5hbFBlcnNpc3RlbmNlIHtcbiAgc3RhdGljIHR5cGU6ICdMT0NBTCcgPSAnTE9DQUwnO1xuXG4gIHR5cGUgPSBQZXJzaXN0ZW5jZVR5cGUuTE9DQUw7XG4gIGRiPzogSURCRGF0YWJhc2U7XG4gIHJlYWRvbmx5IF9zaG91bGRBbGxvd01pZ3JhdGlvbiA9IHRydWU7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBsaXN0ZW5lcnM6IFJlY29yZDxzdHJpbmcsIFNldDxTdG9yYWdlRXZlbnRMaXN0ZW5lcj4+ID0ge307XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9jYWxDYWNoZTogUmVjb3JkPHN0cmluZywgUGVyc2lzdGVuY2VWYWx1ZSB8IG51bGw+ID0ge307XG4gIC8vIHNldFRpbWVvdXQgcmV0dXJuIHZhbHVlIGlzIHBsYXRmb3JtIHNwZWNpZmljXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHByaXZhdGUgcG9sbFRpbWVyOiBhbnkgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwZW5kaW5nV3JpdGVzID0gMDtcblxuICBwcml2YXRlIHJlY2VpdmVyOiBSZWNlaXZlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHNlbmRlcjogU2VuZGVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc2VydmljZVdvcmtlclJlY2VpdmVyQXZhaWxhYmxlID0gZmFsc2U7XG4gIHByaXZhdGUgYWN0aXZlU2VydmljZVdvcmtlcjogU2VydmljZVdvcmtlciB8IG51bGwgPSBudWxsO1xuICAvLyBWaXNpYmxlIGZvciB0ZXN0aW5nIG9ubHlcbiAgcmVhZG9ubHkgX3dvcmtlckluaXRpYWxpemF0aW9uUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBGaXJlICYgZm9yZ2V0IHRoZSBzZXJ2aWNlIHdvcmtlciByZWdpc3RyYXRpb24gYXMgaXQgbWF5IG5ldmVyIHJlc29sdmVcbiAgICB0aGlzLl93b3JrZXJJbml0aWFsaXphdGlvblByb21pc2UgPVxuICAgICAgdGhpcy5pbml0aWFsaXplU2VydmljZVdvcmtlck1lc3NhZ2luZygpLnRoZW4oXG4gICAgICAgICgpID0+IHt9LFxuICAgICAgICAoKSA9PiB7fVxuICAgICAgKTtcbiAgfVxuXG4gIGFzeW5jIF9vcGVuRGIoKTogUHJvbWlzZTxJREJEYXRhYmFzZT4ge1xuICAgIGlmICh0aGlzLmRiKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYjtcbiAgICB9XG4gICAgdGhpcy5kYiA9IGF3YWl0IF9vcGVuRGF0YWJhc2UoKTtcbiAgICByZXR1cm4gdGhpcy5kYjtcbiAgfVxuXG4gIGFzeW5jIF93aXRoUmV0cmllczxUPihvcDogKGRiOiBJREJEYXRhYmFzZSkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGxldCBudW1BdHRlbXB0cyA9IDA7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLl9vcGVuRGIoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG9wKGRiKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKG51bUF0dGVtcHRzKysgPiBfVFJBTlNBQ1RJT05fUkVUUllfQ09VTlQpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRiKSB7XG4gICAgICAgICAgdGhpcy5kYi5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMuZGIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgYWRkaW5nIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5kZXhlZERCIGV2ZW50cyBkbyBub3QgcHJvcGFnYXRlIGZyb20gdGhlIG1haW4gd2luZG93IHRvIHRoZSB3b3JrZXIgY29udGV4dC4gIFdlIHJlbHkgb24gYVxuICAgKiBwb3N0TWVzc2FnZSBpbnRlcmZhY2UgdG8gc2VuZCB0aGVzZSBldmVudHMgdG8gdGhlIHdvcmtlciBvdXJzZWx2ZXMuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRpYWxpemVTZXJ2aWNlV29ya2VyTWVzc2FnaW5nKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBfaXNXb3JrZXIoKSA/IHRoaXMuaW5pdGlhbGl6ZVJlY2VpdmVyKCkgOiB0aGlzLmluaXRpYWxpemVTZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcyB0aGUgd29ya2VyIHdlIHNob3VsZCBsaXN0ZW4gdG8gZXZlbnRzIGZyb20gdGhlIG1haW4gd2luZG93LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplUmVjZWl2ZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5yZWNlaXZlciA9IFJlY2VpdmVyLl9nZXRJbnN0YW5jZShfZ2V0V29ya2VyR2xvYmFsU2NvcGUoKSEpO1xuICAgIC8vIFJlZnJlc2ggZnJvbSBwZXJzaXN0ZW5jZSBpZiB3ZSByZWNlaXZlIGEgS2V5Q2hhbmdlZCBtZXNzYWdlLlxuICAgIHRoaXMucmVjZWl2ZXIuX3N1YnNjcmliZShcbiAgICAgIF9FdmVudFR5cGUuS0VZX0NIQU5HRUQsXG4gICAgICBhc3luYyAoX29yaWdpbjogc3RyaW5nLCBkYXRhOiBLZXlDaGFuZ2VkUmVxdWVzdCkgPT4ge1xuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5fcG9sbCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtleVByb2Nlc3NlZDoga2V5cy5pbmNsdWRlcyhkYXRhLmtleSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIC8vIExldCB0aGUgc2VuZGVyIGtub3cgdGhhdCB3ZSBhcmUgbGlzdGVuaW5nIHNvIHRoZXkgZ2l2ZSB1cyBtb3JlIHRpbWVvdXQuXG4gICAgdGhpcy5yZWNlaXZlci5fc3Vic2NyaWJlKFxuICAgICAgX0V2ZW50VHlwZS5QSU5HLFxuICAgICAgYXN5bmMgKF9vcmlnaW46IHN0cmluZywgX2RhdGE6IFBpbmdSZXF1ZXN0KSA9PiB7XG4gICAgICAgIHJldHVybiBbX0V2ZW50VHlwZS5LRVlfQ0hBTkdFRF07XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcyB0aGUgbWFpbiB3aW5kb3csIHdlIHNob3VsZCBsZXQgdGhlIHdvcmtlciBrbm93IHdoZW4ga2V5cyBjaGFuZ2UgKHNldCBhbmQgcmVtb3ZlKS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2aWNlV29ya2VyQ29udGFpbmVyL3JlYWR5IHwgU2VydmljZVdvcmtlckNvbnRhaW5lci5yZWFkeX1cbiAgICogbWF5IG5vdCByZXNvbHZlLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplU2VuZGVyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGFuIGFjdGl2ZSBzZXJ2aWNlIHdvcmtlci5cbiAgICB0aGlzLmFjdGl2ZVNlcnZpY2VXb3JrZXIgPSBhd2FpdCBfZ2V0QWN0aXZlU2VydmljZVdvcmtlcigpO1xuICAgIGlmICghdGhpcy5hY3RpdmVTZXJ2aWNlV29ya2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VuZGVyID0gbmV3IFNlbmRlcih0aGlzLmFjdGl2ZVNlcnZpY2VXb3JrZXIpO1xuICAgIC8vIFBpbmcgdGhlIHNlcnZpY2Ugd29ya2VyIHRvIGNoZWNrIHdoYXQgZXZlbnRzIHRoZXkgY2FuIGhhbmRsZS5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5zZW5kZXIuX3NlbmQ8X1BpbmdSZXNwb25zZSwgUGluZ1JlcXVlc3Q+KFxuICAgICAgX0V2ZW50VHlwZS5QSU5HLFxuICAgICAge30sXG4gICAgICBfVGltZW91dER1cmF0aW9uLkxPTkdfQUNLXG4gICAgKTtcbiAgICBpZiAoIXJlc3VsdHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgcmVzdWx0c1swXT8uZnVsZmlsbGVkICYmXG4gICAgICByZXN1bHRzWzBdPy52YWx1ZS5pbmNsdWRlcyhfRXZlbnRUeXBlLktFWV9DSEFOR0VEKVxuICAgICkge1xuICAgICAgdGhpcy5zZXJ2aWNlV29ya2VyUmVjZWl2ZXJBdmFpbGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMZXQgdGhlIHdvcmtlciBrbm93IGFib3V0IGEgY2hhbmdlZCBrZXksIHRoZSBleGFjdCBrZXkgZG9lc24ndCB0ZWNobmljYWxseSBtYXR0ZXIgc2luY2UgdGhlXG4gICAqIHdvcmtlciB3aWxsIGp1c3QgdHJpZ2dlciBhIGZ1bGwgc3luYyBhbnl3YXkuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEZvciBub3csIHdlIG9ubHkgc3VwcG9ydCBvbmUgc2VydmljZSB3b3JrZXIgcGVyIHBhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgLSBTdG9yYWdlIGtleSB3aGljaCBjaGFuZ2VkLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBub3RpZnlTZXJ2aWNlV29ya2VyKGtleTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuc2VuZGVyIHx8XG4gICAgICAhdGhpcy5hY3RpdmVTZXJ2aWNlV29ya2VyIHx8XG4gICAgICBfZ2V0U2VydmljZVdvcmtlckNvbnRyb2xsZXIoKSAhPT0gdGhpcy5hY3RpdmVTZXJ2aWNlV29ya2VyXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnNlbmRlci5fc2VuZDxLZXlDaGFuZ2VkUmVzcG9uc2UsIEtleUNoYW5nZWRSZXF1ZXN0PihcbiAgICAgICAgX0V2ZW50VHlwZS5LRVlfQ0hBTkdFRCxcbiAgICAgICAgeyBrZXkgfSxcbiAgICAgICAgLy8gVXNlIGxvbmcgdGltZW91dCBpZiByZWNlaXZlciBoYXMgcHJldmlvdXNseSByZXNwb25kZWQgdG8gYSBwaW5nIGZyb20gdXMuXG4gICAgICAgIHRoaXMuc2VydmljZVdvcmtlclJlY2VpdmVyQXZhaWxhYmxlXG4gICAgICAgICAgPyBfVGltZW91dER1cmF0aW9uLkxPTkdfQUNLXG4gICAgICAgICAgOiBfVGltZW91dER1cmF0aW9uLkFDS1xuICAgICAgKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBiZXN0IGVmZm9ydCBhcHByb2FjaC4gSWdub3JlIGVycm9ycy5cbiAgICB9XG4gIH1cblxuICBhc3luYyBfaXNBdmFpbGFibGUoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghaW5kZXhlZERCKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgX29wZW5EYXRhYmFzZSgpO1xuICAgICAgYXdhaXQgX3B1dE9iamVjdChkYiwgU1RPUkFHRV9BVkFJTEFCTEVfS0VZLCAnMScpO1xuICAgICAgYXdhaXQgX2RlbGV0ZU9iamVjdChkYiwgU1RPUkFHRV9BVkFJTEFCTEVfS0VZKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge31cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF93aXRoUGVuZGluZ1dyaXRlKHdyaXRlOiAoKSA9PiBQcm9taXNlPHZvaWQ+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5wZW5kaW5nV3JpdGVzKys7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHdyaXRlKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucGVuZGluZ1dyaXRlcy0tO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9zZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBQZXJzaXN0ZW5jZVZhbHVlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhQZW5kaW5nV3JpdGUoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5fd2l0aFJldHJpZXMoKGRiOiBJREJEYXRhYmFzZSkgPT4gX3B1dE9iamVjdChkYiwga2V5LCB2YWx1ZSkpO1xuICAgICAgdGhpcy5sb2NhbENhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzLm5vdGlmeVNlcnZpY2VXb3JrZXIoa2V5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIF9nZXQ8VCBleHRlbmRzIFBlcnNpc3RlbmNlVmFsdWU+KGtleTogc3RyaW5nKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuICAgIGNvbnN0IG9iaiA9IChhd2FpdCB0aGlzLl93aXRoUmV0cmllcygoZGI6IElEQkRhdGFiYXNlKSA9PlxuICAgICAgZ2V0T2JqZWN0KGRiLCBrZXkpXG4gICAgKSkgYXMgVDtcbiAgICB0aGlzLmxvY2FsQ2FjaGVba2V5XSA9IG9iajtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgYXN5bmMgX3JlbW92ZShrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl93aXRoUGVuZGluZ1dyaXRlKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuX3dpdGhSZXRyaWVzKChkYjogSURCRGF0YWJhc2UpID0+IF9kZWxldGVPYmplY3QoZGIsIGtleSkpO1xuICAgICAgZGVsZXRlIHRoaXMubG9jYWxDYWNoZVtrZXldO1xuICAgICAgcmV0dXJuIHRoaXMubm90aWZ5U2VydmljZVdvcmtlcihrZXkpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfcG9sbCgpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgLy8gVE9ETzogY2hlY2sgaWYgd2UgbmVlZCB0byBmYWxsYmFjayBpZiBnZXRBbGwgaXMgbm90IHN1cHBvcnRlZFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3dpdGhSZXRyaWVzKChkYjogSURCRGF0YWJhc2UpID0+IHtcbiAgICAgIGNvbnN0IGdldEFsbFJlcXVlc3QgPSBnZXRPYmplY3RTdG9yZShkYiwgZmFsc2UpLmdldEFsbCgpO1xuICAgICAgcmV0dXJuIG5ldyBEQlByb21pc2U8REJPYmplY3RbXSB8IG51bGw+KGdldEFsbFJlcXVlc3QpLnRvUHJvbWlzZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd3JpdGVzIGluIHByb2dyZXNzIGFib3J0LCB3ZSdsbCBnZXQgcGlja2VkIHVwIG9uIHRoZSBuZXh0IHBvbGxcbiAgICBpZiAodGhpcy5wZW5kaW5nV3JpdGVzICE9PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGNvbnN0IGtleXNJblJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHsgZmJhc2Vfa2V5OiBrZXksIHZhbHVlIH0gb2YgcmVzdWx0KSB7XG4gICAgICBrZXlzSW5SZXN1bHQuYWRkKGtleSk7XG4gICAgICBpZiAoSlNPTi5zdHJpbmdpZnkodGhpcy5sb2NhbENhY2hlW2tleV0pICE9PSBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoa2V5LCB2YWx1ZSBhcyBQZXJzaXN0ZW5jZVZhbHVlKTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgbG9jYWxLZXkgb2YgT2JqZWN0LmtleXModGhpcy5sb2NhbENhY2hlKSkge1xuICAgICAgaWYgKHRoaXMubG9jYWxDYWNoZVtsb2NhbEtleV0gJiYgIWtleXNJblJlc3VsdC5oYXMobG9jYWxLZXkpKSB7XG4gICAgICAgIC8vIERlbGV0ZWRcbiAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMobG9jYWxLZXksIG51bGwpO1xuICAgICAgICBrZXlzLnB1c2gobG9jYWxLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIHByaXZhdGUgbm90aWZ5TGlzdGVuZXJzKFxuICAgIGtleTogc3RyaW5nLFxuICAgIG5ld1ZhbHVlOiBQZXJzaXN0ZW5jZVZhbHVlIHwgbnVsbFxuICApOiB2b2lkIHtcbiAgICB0aGlzLmxvY2FsQ2FjaGVba2V5XSA9IG5ld1ZhbHVlO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2tleV07XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBBcnJheS5mcm9tKGxpc3RlbmVycykpIHtcbiAgICAgICAgbGlzdGVuZXIobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRQb2xsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcblxuICAgIHRoaXMucG9sbFRpbWVyID0gc2V0SW50ZXJ2YWwoXG4gICAgICBhc3luYyAoKSA9PiB0aGlzLl9wb2xsKCksXG4gICAgICBfUE9MTElOR19JTlRFUlZBTF9NU1xuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHN0b3BQb2xsaW5nKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnBvbGxUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnBvbGxUaW1lcik7XG4gICAgICB0aGlzLnBvbGxUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgX2FkZExpc3RlbmVyKGtleTogc3RyaW5nLCBsaXN0ZW5lcjogU3RvcmFnZUV2ZW50TGlzdGVuZXIpOiB2b2lkIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zdGFydFBvbGxpbmcoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1trZXldKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc1trZXldID0gbmV3IFNldCgpO1xuICAgICAgLy8gUG9wdWxhdGUgdGhlIGNhY2hlIHRvIGF2b2lkIHNwdXJpb3VzbHkgdHJpZ2dlcmluZyBvbiBmaXJzdCBwb2xsLlxuICAgICAgdm9pZCB0aGlzLl9nZXQoa2V5KTsgLy8gVGhpcyBjYW4gaGFwcGVuIGluIHRoZSBiYWNrZ3JvdW5kIGFzeW5jIGFuZCB3ZSBjYW4gcmV0dXJuIGltbWVkaWF0ZWx5LlxuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVyc1trZXldLmFkZChsaXN0ZW5lcik7XG4gIH1cblxuICBfcmVtb3ZlTGlzdGVuZXIoa2V5OiBzdHJpbmcsIGxpc3RlbmVyOiBTdG9yYWdlRXZlbnRMaXN0ZW5lcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmxpc3RlbmVyc1trZXldKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc1trZXldLmRlbGV0ZShsaXN0ZW5lcik7XG5cbiAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1trZXldLnNpemUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMubGlzdGVuZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgUGVyc2lzdGVuY2V9IG9mIHR5cGUgYExPQ0FMYCB1c2luZyBgaW5kZXhlZERCYFxuICogZm9yIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgaW5kZXhlZERCTG9jYWxQZXJzaXN0ZW5jZTogUGVyc2lzdGVuY2UgPSBJbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgX3BlcmZvcm1BcGlSZXF1ZXN0LFxuICBFbmRwb2ludCxcbiAgSHR0cE1ldGhvZCxcbiAgX2FkZFRpZElmTmVjZXNzYXJ5XG59IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IEF1dGggfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgSWRUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgTWZhRW5yb2xsbWVudCB9IGZyb20gJy4uL2FjY291bnRfbWFuYWdlbWVudC9tZmEnO1xuaW1wb3J0IHsgU2lnbkluV2l0aElkcFJlc3BvbnNlIH0gZnJvbSAnLi9pZHAnO1xuaW1wb3J0IHtcbiAgU2lnbkluV2l0aFBob25lTnVtYmVyUmVxdWVzdCxcbiAgU2lnbkluV2l0aFBob25lTnVtYmVyUmVzcG9uc2Vcbn0gZnJvbSAnLi9zbXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmFsaXplTWZhUmVzcG9uc2Uge1xuICBpZFRva2VuOiBzdHJpbmc7XG4gIHJlZnJlc2hUb2tlbjogc3RyaW5nO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElkVG9rZW5NZmFSZXNwb25zZSBleHRlbmRzIElkVG9rZW5SZXNwb25zZSB7XG4gIG1mYVBlbmRpbmdDcmVkZW50aWFsPzogc3RyaW5nO1xuICBtZmFJbmZvPzogTWZhRW5yb2xsbWVudFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXJ0UGhvbmVNZmFTaWduSW5SZXF1ZXN0IHtcbiAgbWZhUGVuZGluZ0NyZWRlbnRpYWw6IHN0cmluZztcbiAgbWZhRW5yb2xsbWVudElkOiBzdHJpbmc7XG4gIHBob25lU2lnbkluSW5mbzoge1xuICAgIHJlY2FwdGNoYVRva2VuOiBzdHJpbmc7XG4gIH07XG4gIHRlbmFudElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXJ0UGhvbmVNZmFTaWduSW5SZXNwb25zZSB7XG4gIHBob25lUmVzcG9uc2VJbmZvOiB7XG4gICAgc2Vzc2lvbkluZm86IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0U2lnbkluUGhvbmVNZmEoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IFN0YXJ0UGhvbmVNZmFTaWduSW5SZXF1ZXN0XG4pOiBQcm9taXNlPFN0YXJ0UGhvbmVNZmFTaWduSW5SZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PFxuICAgIFN0YXJ0UGhvbmVNZmFTaWduSW5SZXF1ZXN0LFxuICAgIFN0YXJ0UGhvbmVNZmFTaWduSW5SZXNwb25zZVxuICA+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LlNUQVJUX01GQV9TSUdOX0lOLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmFsaXplUGhvbmVNZmFTaWduSW5SZXF1ZXN0IHtcbiAgbWZhUGVuZGluZ0NyZWRlbnRpYWw6IHN0cmluZztcbiAgcGhvbmVWZXJpZmljYXRpb25JbmZvOiBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXF1ZXN0O1xuICB0ZW5hbnRJZD86IHN0cmluZztcbn1cblxuLy8gVE9UUCBNRkEgU2lnbiBpbiBvbmx5IGhhcyBhIGZpbmFsaXplIHBoYXNlLiBQaG9uZSBNRkEgaGFzIGEgc3RhcnQgcGhhc2UgdG8gaW5pdGlhdGUgc2VuZGluZyBhblxuLy8gU01TIGFuZCBhIGZpbmFsaXplIHBoYXNlIHRvIGNvbXBsZXRlIHNpZ24gaW4uIFdpdGggVE9UUCwgdGhlIHVzZXIgYWxyZWFkeSBoYXMgdGhlIE9UUCBpbiB0aGVcbi8vIFRPVFAvQXV0aGVudGljYXRvciBhcHAuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmFsaXplVG90cE1mYVNpZ25JblJlcXVlc3Qge1xuICBtZmFQZW5kaW5nQ3JlZGVudGlhbDogc3RyaW5nO1xuICB0b3RwVmVyaWZpY2F0aW9uSW5mbzogeyB2ZXJpZmljYXRpb25Db2RlOiBzdHJpbmcgfTtcbiAgdGVuYW50SWQ/OiBzdHJpbmc7XG4gIG1mYUVucm9sbG1lbnRJZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmFsaXplUGhvbmVNZmFTaWduSW5SZXNwb25zZSBleHRlbmRzIEZpbmFsaXplTWZhUmVzcG9uc2Uge31cblxuZXhwb3J0IGludGVyZmFjZSBGaW5hbGl6ZVRvdHBNZmFTaWduSW5SZXNwb25zZSBleHRlbmRzIEZpbmFsaXplTWZhUmVzcG9uc2Uge31cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmFsaXplU2lnbkluUGhvbmVNZmEoXG4gIGF1dGg6IEF1dGgsXG4gIHJlcXVlc3Q6IEZpbmFsaXplUGhvbmVNZmFTaWduSW5SZXF1ZXN0XG4pOiBQcm9taXNlPEZpbmFsaXplUGhvbmVNZmFTaWduSW5SZXNwb25zZT4ge1xuICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0PFxuICAgIEZpbmFsaXplUGhvbmVNZmFTaWduSW5SZXF1ZXN0LFxuICAgIEZpbmFsaXplUGhvbmVNZmFTaWduSW5SZXNwb25zZVxuICA+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LkZJTkFMSVpFX01GQV9TSUdOX0lOLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluYWxpemVTaWduSW5Ub3RwTWZhKFxuICBhdXRoOiBBdXRoLFxuICByZXF1ZXN0OiBGaW5hbGl6ZVRvdHBNZmFTaWduSW5SZXF1ZXN0XG4pOiBQcm9taXNlPEZpbmFsaXplVG90cE1mYVNpZ25JblJlc3BvbnNlPiB7XG4gIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3Q8XG4gICAgRmluYWxpemVUb3RwTWZhU2lnbkluUmVxdWVzdCxcbiAgICBGaW5hbGl6ZVRvdHBNZmFTaWduSW5SZXNwb25zZVxuICA+KFxuICAgIGF1dGgsXG4gICAgSHR0cE1ldGhvZC5QT1NULFxuICAgIEVuZHBvaW50LkZJTkFMSVpFX01GQV9TSUdOX0lOLFxuICAgIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KVxuICApO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBQaG9uZU9yT2F1dGhUb2tlblJlc3BvbnNlID1cbiAgfCBTaWduSW5XaXRoUGhvbmVOdW1iZXJSZXNwb25zZVxuICB8IFNpZ25JbldpdGhJZHBSZXNwb25zZVxuICB8IElkVG9rZW5SZXNwb25zZTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi8uLi9jb3JlL2Vycm9ycyc7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IFJlY2FwdGNoYVBhcmFtZXRlcnMgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHtcbiAgUmVjYXB0Y2hhLFxuICBHcmVDQVBUQ0hBVG9wTGV2ZWwsXG4gIEdyZUNBUFRDSEFSZW5kZXJPcHRpb24sXG4gIEdyZUNBUFRDSEFcbn0gZnJvbSAnLi9yZWNhcHRjaGEnO1xuXG5leHBvcnQgY29uc3QgX1NPTFZFX1RJTUVfTVMgPSA1MDA7XG5leHBvcnQgY29uc3QgX0VYUElSQVRJT05fVElNRV9NUyA9IDYwXzAwMDtcbmV4cG9ydCBjb25zdCBfV0lER0VUX0lEX1NUQVJUID0gMV8wMDBfMDAwXzAwMF8wMDA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2lkZ2V0IHtcbiAgZ2V0UmVzcG9uc2U6ICgpID0+IHN0cmluZyB8IG51bGw7XG4gIGRlbGV0ZTogKCkgPT4gdm9pZDtcbiAgZXhlY3V0ZTogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGNsYXNzIE1vY2tSZUNhcHRjaGEgaW1wbGVtZW50cyBSZWNhcHRjaGEge1xuICBwcml2YXRlIGNvdW50ZXIgPSBfV0lER0VUX0lEX1NUQVJUO1xuICBfd2lkZ2V0cyA9IG5ldyBNYXA8bnVtYmVyLCBXaWRnZXQ+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBhdXRoOiBBdXRoSW50ZXJuYWwpIHt9XG5cbiAgcmVuZGVyKFxuICAgIGNvbnRhaW5lcjogc3RyaW5nIHwgSFRNTEVsZW1lbnQsXG4gICAgcGFyYW1ldGVycz86IFJlY2FwdGNoYVBhcmFtZXRlcnNcbiAgKTogbnVtYmVyIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuY291bnRlcjtcbiAgICB0aGlzLl93aWRnZXRzLnNldChcbiAgICAgIGlkLFxuICAgICAgbmV3IE1vY2tXaWRnZXQoY29udGFpbmVyLCB0aGlzLmF1dGgubmFtZSwgcGFyYW1ldGVycyB8fCB7fSlcbiAgICApO1xuICAgIHRoaXMuY291bnRlcisrO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIHJlc2V0KG9wdFdpZGdldElkPzogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgaWQgPSBvcHRXaWRnZXRJZCB8fCBfV0lER0VUX0lEX1NUQVJUO1xuICAgIHZvaWQgdGhpcy5fd2lkZ2V0cy5nZXQoaWQpPy5kZWxldGUoKTtcbiAgICB0aGlzLl93aWRnZXRzLmRlbGV0ZShpZCk7XG4gIH1cblxuICBnZXRSZXNwb25zZShvcHRXaWRnZXRJZD86IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3QgaWQgPSBvcHRXaWRnZXRJZCB8fCBfV0lER0VUX0lEX1NUQVJUO1xuICAgIHJldHVybiB0aGlzLl93aWRnZXRzLmdldChpZCk/LmdldFJlc3BvbnNlKCkgfHwgJyc7XG4gIH1cblxuICBhc3luYyBleGVjdXRlKG9wdFdpZGdldElkPzogbnVtYmVyIHwgc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBpZDogbnVtYmVyID0gKG9wdFdpZGdldElkIGFzIG51bWJlcikgfHwgX1dJREdFVF9JRF9TVEFSVDtcbiAgICB2b2lkIHRoaXMuX3dpZGdldHMuZ2V0KGlkKT8uZXhlY3V0ZSgpO1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTW9ja0dyZUNBUFRDSEFUb3BMZXZlbCBpbXBsZW1lbnRzIEdyZUNBUFRDSEFUb3BMZXZlbCB7XG4gIGVudGVycHJpc2U6IEdyZUNBUFRDSEEgPSBuZXcgTW9ja0dyZUNBUFRDSEEoKTtcbiAgcmVhZHkoY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgZXhlY3V0ZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX3NpdGVLZXk6IHN0cmluZyxcbiAgICBfb3B0aW9uczogeyBhY3Rpb246IHN0cmluZyB9XG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgndG9rZW4nKTtcbiAgfVxuICByZW5kZXIoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9jb250YWluZXI6IHN0cmluZyB8IEhUTUxFbGVtZW50LFxuICAgIF9wYXJhbWV0ZXJzOiBHcmVDQVBUQ0hBUmVuZGVyT3B0aW9uXG4gICk6IHN0cmluZyB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNb2NrR3JlQ0FQVENIQSBpbXBsZW1lbnRzIEdyZUNBUFRDSEEge1xuICByZWFkeShjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBleGVjdXRlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBfc2l0ZUtleTogc3RyaW5nLFxuICAgIF9vcHRpb25zOiB7IGFjdGlvbjogc3RyaW5nIH1cbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCd0b2tlbicpO1xuICB9XG4gIHJlbmRlcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX2NvbnRhaW5lcjogc3RyaW5nIHwgSFRNTEVsZW1lbnQsXG4gICAgX3BhcmFtZXRlcnM6IEdyZUNBUFRDSEFSZW5kZXJPcHRpb25cbiAgKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1vY2tXaWRnZXQge1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgaXNWaXNpYmxlOiBib29sZWFuO1xuICBwcml2YXRlIHRpbWVySWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGRlbGV0ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSByZXNwb25zZVRva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSByZWFkb25seSBjbGlja0hhbmRsZXIgPSAoKTogdm9pZCA9PiB7XG4gICAgdGhpcy5leGVjdXRlKCk7XG4gIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY29udGFpbmVyT3JJZDogc3RyaW5nIHwgSFRNTEVsZW1lbnQsXG4gICAgYXBwTmFtZTogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGFyYW1zOiBSZWNhcHRjaGFQYXJhbWV0ZXJzXG4gICkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9XG4gICAgICB0eXBlb2YgY29udGFpbmVyT3JJZCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXJPcklkKVxuICAgICAgICA6IGNvbnRhaW5lck9ySWQ7XG4gICAgX2Fzc2VydChjb250YWluZXIsIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IsIHsgYXBwTmFtZSB9KTtcblxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuaXNWaXNpYmxlID0gdGhpcy5wYXJhbXMuc2l6ZSAhPT0gJ2ludmlzaWJsZSc7XG4gICAgaWYgKHRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgZ2V0UmVzcG9uc2UoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgdGhpcy5jaGVja0lmRGVsZXRlZCgpO1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlVG9rZW47XG4gIH1cblxuICBkZWxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja0lmRGVsZXRlZCgpO1xuICAgIHRoaXMuZGVsZXRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMudGltZXJJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgICB0aGlzLnRpbWVySWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyKTtcbiAgfVxuXG4gIGV4ZWN1dGUoKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja0lmRGVsZXRlZCgpO1xuICAgIGlmICh0aGlzLnRpbWVySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRpbWVySWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJlc3BvbnNlVG9rZW4gPSBnZW5lcmF0ZVJhbmRvbUFscGhhTnVtZXJpY1N0cmluZyg1MCk7XG4gICAgICBjb25zdCB7IGNhbGxiYWNrLCAnZXhwaXJlZC1jYWxsYmFjayc6IGV4cGlyZWRDYWxsYmFjayB9ID0gdGhpcy5wYXJhbXM7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsYmFjayh0aGlzLnJlc3BvbnNlVG9rZW4pO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRpbWVySWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzcG9uc2VUb2tlbiA9IG51bGw7XG4gICAgICAgIGlmIChleHBpcmVkQ2FsbGJhY2spIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXhwaXJlZENhbGxiYWNrKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgIHRoaXMuZXhlY3V0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBfRVhQSVJBVElPTl9USU1FX01TKTtcbiAgICB9LCBfU09MVkVfVElNRV9NUyk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrSWZEZWxldGVkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVDQVBUQ0hBIG1vY2sgd2FzIGFscmVhZHkgZGVsZXRlZCEnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21BbHBoYU51bWVyaWNTdHJpbmcobGVuOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBjaGFycyA9IFtdO1xuICBjb25zdCBhbGxvd2VkQ2hhcnMgPVxuICAgICcxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWic7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaGFycy5wdXNoKFxuICAgICAgYWxsb3dlZENoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhbGxvd2VkQ2hhcnMubGVuZ3RoKSlcbiAgICApO1xuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IHF1ZXJ5c3RyaW5nIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCwgX2NyZWF0ZUVycm9yIH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBEZWxheSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9kZWxheSc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IF93aW5kb3cgfSBmcm9tICcuLi9hdXRoX3dpbmRvdyc7XG5pbXBvcnQgKiBhcyBqc0hlbHBlcnMgZnJvbSAnLi4vbG9hZF9qcyc7XG5pbXBvcnQgeyBSZWNhcHRjaGEsIGlzVjIgfSBmcm9tICcuL3JlY2FwdGNoYSc7XG5pbXBvcnQgeyBNb2NrUmVDYXB0Y2hhIH0gZnJvbSAnLi9yZWNhcHRjaGFfbW9jayc7XG5cbi8vIFJlQ2FwdGNoYSB3aWxsIGxvYWQgdXNpbmcgdGhlIHNhbWUgY2FsbGJhY2ssIHNvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBuZWVkc1xuLy8gdG8gYmUga2VwdCBhcm91bmRcbmV4cG9ydCBjb25zdCBfSlNMT0FEX0NBTExCQUNLID0ganNIZWxwZXJzLl9nZW5lcmF0ZUNhbGxiYWNrTmFtZSgncmNiJyk7XG5jb25zdCBORVRXT1JLX1RJTUVPVVRfREVMQVkgPSBuZXcgRGVsYXkoMzAwMDAsIDYwMDAwKTtcbmNvbnN0IFJFQ0FQVENIQV9CQVNFID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20vcmVjYXB0Y2hhL2FwaS5qcz8nO1xuXG4vKipcbiAqIFdlIG5lZWQgdG8gbWFyayB0aGlzIGludGVyZmFjZSBhcyBpbnRlcm5hbCBleHBsaWNpdGx5IHRvIGV4Y2x1ZGUgaXQgaW4gdGhlIHB1YmxpYyB0eXBpbmdzLCBiZWNhdXNlXG4gKiBpdCByZWZlcmVuY2VzIEF1dGhJbnRlcm5hbCB3aGljaCBoYXMgYSBjaXJjdWxhciBkZXBlbmRlbmN5IHdpdGggVXNlckludGVybmFsLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlQ2FwdGNoYUxvYWRlciB7XG4gIGxvYWQoYXV0aDogQXV0aEludGVybmFsLCBobD86IHN0cmluZyk6IFByb21pc2U8UmVjYXB0Y2hhPjtcbiAgY2xlYXJlZE9uZUluc3RhbmNlKCk6IHZvaWQ7XG59XG5cbi8qKlxuICogTG9hZGVyIGZvciB0aGUgR1JlQ2FwdGNoYSBsaWJyYXJ5LiBUaGVyZSBzaG91bGQgb25seSBldmVyIGJlIG9uZSBvZiB0aGlzLlxuICovXG5leHBvcnQgY2xhc3MgUmVDYXB0Y2hhTG9hZGVySW1wbCBpbXBsZW1lbnRzIFJlQ2FwdGNoYUxvYWRlciB7XG4gIHByaXZhdGUgaG9zdExhbmd1YWdlID0gJyc7XG4gIHByaXZhdGUgY291bnRlciA9IDA7XG4gIC8qKlxuICAgKiBDaGVjayBmb3IgYHJlbmRlcigpYCBtZXRob2QuIGB3aW5kb3cuZ3JlY2FwdGNoYWAgd2lsbCBleGlzdCBpZiB0aGUgRW50ZXJwcmlzZVxuICAgKiB2ZXJzaW9uIG9mIHRoZSBSZUNBUFRDSEEgc2NyaXB0IHdhcyBsb2FkZWQgYnkgc29tZW9uZSBlbHNlIChlLmcuIEFwcCBDaGVjaykgYnV0XG4gICAqIGB3aW5kb3cuZ3JlY2FwdGNoYS5yZW5kZXIoKWAgd2lsbCBub3QuIEFub3RoZXIgbG9hZCB3aWxsIGFkZCBpdC5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgbGlicmFyeVNlcGFyYXRlbHlMb2FkZWQgPSAhIV93aW5kb3coKS5ncmVjYXB0Y2hhPy5yZW5kZXI7XG5cbiAgbG9hZChhdXRoOiBBdXRoSW50ZXJuYWwsIGhsID0gJycpOiBQcm9taXNlPFJlY2FwdGNoYT4ge1xuICAgIF9hc3NlcnQoaXNIb3N0TGFuZ3VhZ2VWYWxpZChobCksIGF1dGgsIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IpO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkUmVzb2x2ZUltbWVkaWF0ZWx5KGhsKSAmJiBpc1YyKF93aW5kb3coKS5ncmVjYXB0Y2hhKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfd2luZG93KCkuZ3JlY2FwdGNoYSEgYXMgUmVjYXB0Y2hhKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFJlY2FwdGNoYT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbmV0d29ya1RpbWVvdXQgPSBfd2luZG93KCkuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChfY3JlYXRlRXJyb3IoYXV0aCwgQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEKSk7XG4gICAgICB9LCBORVRXT1JLX1RJTUVPVVRfREVMQVkuZ2V0KCkpO1xuXG4gICAgICBfd2luZG93KClbX0pTTE9BRF9DQUxMQkFDS10gPSAoKSA9PiB7XG4gICAgICAgIF93aW5kb3coKS5jbGVhclRpbWVvdXQobmV0d29ya1RpbWVvdXQpO1xuICAgICAgICBkZWxldGUgX3dpbmRvdygpW19KU0xPQURfQ0FMTEJBQ0tdO1xuXG4gICAgICAgIGNvbnN0IHJlY2FwdGNoYSA9IF93aW5kb3coKS5ncmVjYXB0Y2hhIGFzIFJlY2FwdGNoYTtcblxuICAgICAgICBpZiAoIXJlY2FwdGNoYSB8fCAhaXNWMihyZWNhcHRjaGEpKSB7XG4gICAgICAgICAgcmVqZWN0KF9jcmVhdGVFcnJvcihhdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JhcCB0aGUgZ3JlcHRjaGEgcmVuZGVyIGZ1bmN0aW9uIHNvIHRoYXQgd2Uga25vdyBpZiB0aGUgZGV2ZWxvcGVyIGhhc1xuICAgICAgICAvLyBjYWxsZWQgaXQgc2VwYXJhdGVseVxuICAgICAgICBjb25zdCByZW5kZXIgPSByZWNhcHRjaGEucmVuZGVyO1xuICAgICAgICByZWNhcHRjaGEucmVuZGVyID0gKGNvbnRhaW5lciwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgY29uc3Qgd2lkZ2V0SWQgPSByZW5kZXIoY29udGFpbmVyLCBwYXJhbXMpO1xuICAgICAgICAgIHRoaXMuY291bnRlcisrO1xuICAgICAgICAgIHJldHVybiB3aWRnZXRJZDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmhvc3RMYW5ndWFnZSA9IGhsO1xuICAgICAgICByZXNvbHZlKHJlY2FwdGNoYSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNBUFRDSEFfQkFTRX0/JHtxdWVyeXN0cmluZyh7XG4gICAgICAgIG9ubG9hZDogX0pTTE9BRF9DQUxMQkFDSyxcbiAgICAgICAgcmVuZGVyOiAnZXhwbGljaXQnLFxuICAgICAgICBobFxuICAgICAgfSl9YDtcblxuICAgICAganNIZWxwZXJzLl9sb2FkSlModXJsKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChuZXR3b3JrVGltZW91dCk7XG4gICAgICAgIHJlamVjdChfY3JlYXRlRXJyb3IoYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUikpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjbGVhcmVkT25lSW5zdGFuY2UoKTogdm9pZCB7XG4gICAgdGhpcy5jb3VudGVyLS07XG4gIH1cblxuICBwcml2YXRlIHNob3VsZFJlc29sdmVJbW1lZGlhdGVseShobDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gV2UgY2FuIHJlc29sdmUgaW1tZWRpYXRlbHkgaWY6XG4gICAgLy8gICDigKIgZ3JlY2FwdGNoYSBpcyBhbHJlYWR5IGRlZmluZWQgQU5EIChcbiAgICAvLyAgICAgMS4gdGhlIHJlcXVlc3RlZCBsYW5ndWFnZSBjb2RlcyBhcmUgdGhlIHNhbWUgT1JcbiAgICAvLyAgICAgMi4gdGhlcmUgZXhpc3RzIGFscmVhZHkgYSBSZUNhcHRjaGEgb24gdGhlIHBhZ2VcbiAgICAvLyAgICAgMy4gdGhlIGxpYnJhcnkgd2FzIGFscmVhZHkgbG9hZGVkIGJ5IHRoZSBhcHBcbiAgICAvLyBJbiBjYXNlcyAoMikgYW5kICgzKSwgd2UgX2Nhbid0XyByZWxvYWQgYXMgaXQgd291bGQgYnJlYWsgdGhlIHJlY2FwdGNoYXNcbiAgICAvLyB0aGF0IGFyZSBhbHJlYWR5IGluIHRoZSBwYWdlXG4gICAgcmV0dXJuIChcbiAgICAgICEhX3dpbmRvdygpLmdyZWNhcHRjaGE/LnJlbmRlciAmJlxuICAgICAgKGhsID09PSB0aGlzLmhvc3RMYW5ndWFnZSB8fFxuICAgICAgICB0aGlzLmNvdW50ZXIgPiAwIHx8XG4gICAgICAgIHRoaXMubGlicmFyeVNlcGFyYXRlbHlMb2FkZWQpXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0hvc3RMYW5ndWFnZVZhbGlkKGhsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGhsLmxlbmd0aCA8PSA2ICYmIC9eXFxzKlthLXpBLVowLTlcXC1dKlxccyokLy50ZXN0KGhsKTtcbn1cblxuZXhwb3J0IGNsYXNzIE1vY2tSZUNhcHRjaGFMb2FkZXJJbXBsIGltcGxlbWVudHMgUmVDYXB0Y2hhTG9hZGVyIHtcbiAgYXN5bmMgbG9hZChhdXRoOiBBdXRoSW50ZXJuYWwpOiBQcm9taXNlPFJlY2FwdGNoYT4ge1xuICAgIHJldHVybiBuZXcgTW9ja1JlQ2FwdGNoYShhdXRoKTtcbiAgfVxuXG4gIGNsZWFyZWRPbmVJbnN0YW5jZSgpOiB2b2lkIHt9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoLCBSZWNhcHRjaGFQYXJhbWV0ZXJzIH0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IGdldFJlY2FwdGNoYVBhcmFtcyB9IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9yZWNhcHRjaGEnO1xuaW1wb3J0IHsgX2Nhc3RBdXRoIH0gZnJvbSAnLi4vLi4vY29yZS9hdXRoL2F1dGhfaW1wbCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgX2lzSHR0cE9ySHR0cHMgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvbG9jYXRpb24nO1xuaW1wb3J0IHsgQXBwbGljYXRpb25WZXJpZmllckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXBwbGljYXRpb25fdmVyaWZpZXInO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBfd2luZG93IH0gZnJvbSAnLi4vYXV0aF93aW5kb3cnO1xuaW1wb3J0IHsgX2lzV29ya2VyIH0gZnJvbSAnLi4vdXRpbC93b3JrZXInO1xuaW1wb3J0IHsgUmVjYXB0Y2hhIH0gZnJvbSAnLi9yZWNhcHRjaGEnO1xuaW1wb3J0IHtcbiAgTW9ja1JlQ2FwdGNoYUxvYWRlckltcGwsXG4gIFJlQ2FwdGNoYUxvYWRlcixcbiAgUmVDYXB0Y2hhTG9hZGVySW1wbFxufSBmcm9tICcuL3JlY2FwdGNoYV9sb2FkZXInO1xuXG5leHBvcnQgY29uc3QgUkVDQVBUQ0hBX1ZFUklGSUVSX1RZUEUgPSAncmVjYXB0Y2hhJztcblxuY29uc3QgREVGQVVMVF9QQVJBTVM6IFJlY2FwdGNoYVBhcmFtZXRlcnMgPSB7XG4gIHRoZW1lOiAnbGlnaHQnLFxuICB0eXBlOiAnaW1hZ2UnXG59O1xuXG50eXBlIFRva2VuQ2FsbGJhY2sgPSAodG9rZW46IHN0cmluZykgPT4gdm9pZDtcblxuLyoqXG4gKiBBbiB7QGxpbmsgaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9yZWNhcHRjaGEvIHwgcmVDQVBUQ0hBfS1iYXNlZCBhcHBsaWNhdGlvbiB2ZXJpZmllci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWNhcHRjaGFWZXJpZmllciBpbXBsZW1lbnRzIEFwcGxpY2F0aW9uVmVyaWZpZXJJbnRlcm5hbCB7XG4gIC8qKlxuICAgKiBUaGUgYXBwbGljYXRpb24gdmVyaWZpZXIgdHlwZS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogRm9yIGEgcmVDQVBUQ0hBIHZlcmlmaWVyLCB0aGlzIGlzICdyZWNhcHRjaGEnLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZSA9IFJFQ0FQVENIQV9WRVJJRklFUl9UWVBFO1xuICBwcml2YXRlIGRlc3Ryb3llZCA9IGZhbHNlO1xuICBwcml2YXRlIHdpZGdldElkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSByZWFkb25seSBjb250YWluZXI6IEhUTUxFbGVtZW50O1xuICBwcml2YXRlIHJlYWRvbmx5IGlzSW52aXNpYmxlOiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IHRva2VuQ2hhbmdlTGlzdGVuZXJzID0gbmV3IFNldDxUb2tlbkNhbGxiYWNrPigpO1xuICBwcml2YXRlIHJlbmRlclByb21pc2U6IFByb21pc2U8bnVtYmVyPiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHJlYWRvbmx5IGF1dGg6IEF1dGhJbnRlcm5hbDtcblxuICAvKiogQGludGVybmFsICovXG4gIHJlYWRvbmx5IF9yZWNhcHRjaGFMb2FkZXI6IFJlQ2FwdGNoYUxvYWRlcjtcbiAgcHJpdmF0ZSByZWNhcHRjaGE6IFJlY2FwdGNoYSB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gY29udGFpbmVyT3JJZCAtIFRoZSByZUNBUFRDSEEgY29udGFpbmVyIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBoYXMgZGlmZmVyZW50IG1lYW5pbmcgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHJlQ0FQVENIQSBpcyBoaWRkZW4gb3IgdmlzaWJsZS4gRm9yIGFcbiAgICogdmlzaWJsZSByZUNBUFRDSEEgdGhlIGNvbnRhaW5lciBtdXN0IGJlIGVtcHR5LiBJZiBhIHN0cmluZyBpcyB1c2VkLCBpdCBoYXMgdG8gY29ycmVzcG9uZCB0b1xuICAgKiBhbiBlbGVtZW50IElELiBUaGUgY29ycmVzcG9uZGluZyBlbGVtZW50IG11c3QgYWxzbyBtdXN0IGJlIGluIHRoZSBET00gYXQgdGhlIHRpbWUgb2ZcbiAgICogaW5pdGlhbGl6YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gVGhlIG9wdGlvbmFsIHJlQ0FQVENIQSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBDaGVjayB0aGUgcmVDQVBUQ0hBIGRvY3MgZm9yIGEgY29tcHJlaGVuc2l2ZSBsaXN0LiBBbGwgcGFyYW1ldGVycyBhcmUgYWNjZXB0ZWQgZXhjZXB0IGZvclxuICAgKiB0aGUgc2l0ZWtleS4gRmlyZWJhc2UgQXV0aCBiYWNrZW5kIHByb3Zpc2lvbnMgYSByZUNBUFRDSEEgZm9yIGVhY2ggcHJvamVjdCBhbmQgd2lsbFxuICAgKiBjb25maWd1cmUgdGhpcyB1cG9uIHJlbmRlcmluZy4gRm9yIGFuIGludmlzaWJsZSByZUNBUFRDSEEsIGEgc2l6ZSBrZXkgbXVzdCBoYXZlIHRoZSB2YWx1ZVxuICAgKiAnaW52aXNpYmxlJy5cbiAgICpcbiAgICogQHBhcmFtIGF1dGhFeHRlcm4gLSBUaGUgY29ycmVzcG9uZGluZyBGaXJlYmFzZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBjb250YWluZXJPcklkOiBIVE1MRWxlbWVudCB8IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhcmFtZXRlcnM6IFJlY2FwdGNoYVBhcmFtZXRlcnMgPSB7XG4gICAgICAuLi5ERUZBVUxUX1BBUkFNU1xuICAgIH0sXG4gICAgYXV0aEV4dGVybjogQXV0aFxuICApIHtcbiAgICB0aGlzLmF1dGggPSBfY2FzdEF1dGgoYXV0aEV4dGVybik7XG4gICAgdGhpcy5pc0ludmlzaWJsZSA9IHRoaXMucGFyYW1ldGVycy5zaXplID09PSAnaW52aXNpYmxlJztcbiAgICBfYXNzZXJ0KFxuICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgIHRoaXMuYXV0aCxcbiAgICAgIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9TVVBQT1JURURcbiAgICApO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9XG4gICAgICB0eXBlb2YgY29udGFpbmVyT3JJZCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXJPcklkKVxuICAgICAgICA6IGNvbnRhaW5lck9ySWQ7XG4gICAgX2Fzc2VydChjb250YWluZXIsIHRoaXMuYXV0aCwgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUik7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLnBhcmFtZXRlcnMuY2FsbGJhY2sgPSB0aGlzLm1ha2VUb2tlbkNhbGxiYWNrKHRoaXMucGFyYW1ldGVycy5jYWxsYmFjayk7XG5cbiAgICB0aGlzLl9yZWNhcHRjaGFMb2FkZXIgPSB0aGlzLmF1dGguc2V0dGluZ3MuYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nXG4gICAgICA/IG5ldyBNb2NrUmVDYXB0Y2hhTG9hZGVySW1wbCgpXG4gICAgICA6IG5ldyBSZUNhcHRjaGFMb2FkZXJJbXBsKCk7XG5cbiAgICB0aGlzLnZhbGlkYXRlU3RhcnRpbmdTdGF0ZSgpO1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgaWYgc2RrIHZlcnNpb24gaXMgbmVlZGVkXG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSB1c2VyIHRvIHNvbHZlIHRoZSByZUNBUFRDSEEgYW5kIHJlc29sdmVzIHdpdGggdGhlIHJlQ0FQVENIQSB0b2tlbi5cbiAgICpcbiAgICogQHJldHVybnMgQSBQcm9taXNlIGZvciB0aGUgcmVDQVBUQ0hBIHRva2VuLlxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5KCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdGhpcy5hc3NlcnROb3REZXN0cm95ZWQoKTtcbiAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMucmVuZGVyKCk7XG4gICAgY29uc3QgcmVjYXB0Y2hhID0gdGhpcy5nZXRBc3NlcnRlZFJlY2FwdGNoYSgpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSByZWNhcHRjaGEuZ2V0UmVzcG9uc2UoaWQpO1xuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgdG9rZW5DaGFuZ2UgPSAodG9rZW46IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgdG9rZW4gZXhwaXJhdGlvbnMuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2tlbkNoYW5nZUxpc3RlbmVycy5kZWxldGUodG9rZW5DaGFuZ2UpO1xuICAgICAgICByZXNvbHZlKHRva2VuKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudG9rZW5DaGFuZ2VMaXN0ZW5lcnMuYWRkKHRva2VuQ2hhbmdlKTtcbiAgICAgIGlmICh0aGlzLmlzSW52aXNpYmxlKSB7XG4gICAgICAgIHJlY2FwdGNoYS5leGVjdXRlKGlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSByZUNBUFRDSEEgd2lkZ2V0IG9uIHRoZSBwYWdlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZUNBUFRDSEEgd2lkZ2V0IElELlxuICAgKi9cbiAgcmVuZGVyKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYXNzZXJ0Tm90RGVzdHJveWVkKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gVGhpcyBtZXRob2QgcmV0dXJucyBhIHByb21pc2UuIFNpbmNlIGl0J3Mgbm90IGFzeW5jICh3ZSB3YW50IHRvIHJldHVybiB0aGVcbiAgICAgIC8vIF9zYW1lXyBwcm9taXNlIGlmIHJlbmRlcmluZyBpcyBzdGlsbCBvY2N1cnJpbmcpLCB0aGUgQVBJIHN1cmZhY2Ugc2hvdWxkXG4gICAgICAvLyByZWplY3Qgd2l0aCB0aGUgZXJyb3IgcmF0aGVyIHRoYW4ganVzdCB0aHJvd1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbmRlclByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclByb21pc2U7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJQcm9taXNlID0gdGhpcy5tYWtlUmVuZGVyUHJvbWlzZSgpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJQcm9taXNlID0gbnVsbDtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5yZW5kZXJQcm9taXNlO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5hc3NlcnROb3REZXN0cm95ZWQoKTtcbiAgICBpZiAodGhpcy53aWRnZXRJZCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5nZXRBc3NlcnRlZFJlY2FwdGNoYSgpLnJlc2V0KHRoaXMud2lkZ2V0SWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHJlQ0FQVENIQSB3aWRnZXQgZnJvbSB0aGUgcGFnZSBhbmQgZGVzdHJveXMgdGhlIGluc3RhbmNlLlxuICAgKi9cbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5hc3NlcnROb3REZXN0cm95ZWQoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5fcmVjYXB0Y2hhTG9hZGVyLmNsZWFyZWRPbmVJbnN0YW5jZSgpO1xuICAgIGlmICghdGhpcy5pc0ludmlzaWJsZSkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVTdGFydGluZ1N0YXRlKCk6IHZvaWQge1xuICAgIF9hc3NlcnQoIXRoaXMucGFyYW1ldGVycy5zaXRla2V5LCB0aGlzLmF1dGgsIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IpO1xuICAgIF9hc3NlcnQoXG4gICAgICB0aGlzLmlzSW52aXNpYmxlIHx8ICF0aGlzLmNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCksXG4gICAgICB0aGlzLmF1dGgsXG4gICAgICBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SXG4gICAgKTtcbiAgICBfYXNzZXJ0KFxuICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgIHRoaXMuYXV0aCxcbiAgICAgIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9TVVBQT1JURURcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBtYWtlVG9rZW5DYWxsYmFjayhcbiAgICBleGlzdGluZzogVG9rZW5DYWxsYmFjayB8IHN0cmluZyB8IHVuZGVmaW5lZFxuICApOiBUb2tlbkNhbGxiYWNrIHtcbiAgICByZXR1cm4gdG9rZW4gPT4ge1xuICAgICAgdGhpcy50b2tlbkNoYW5nZUxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKHRva2VuKSk7XG4gICAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGV4aXN0aW5nKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBnbG9iYWxGdW5jID0gX3dpbmRvdygpW2V4aXN0aW5nXTtcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxGdW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZ2xvYmFsRnVuYyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3NlcnROb3REZXN0cm95ZWQoKTogdm9pZCB7XG4gICAgX2Fzc2VydCghdGhpcy5kZXN0cm95ZWQsIHRoaXMuYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG1ha2VSZW5kZXJQcm9taXNlKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgaWYgKCF0aGlzLndpZGdldElkKSB7XG4gICAgICBsZXQgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICBpZiAoIXRoaXMuaXNJbnZpc2libGUpIHtcbiAgICAgICAgY29uc3QgZ3VhcmFudGVlZEVtcHR5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChndWFyYW50ZWVkRW1wdHkpO1xuICAgICAgICBjb250YWluZXIgPSBndWFyYW50ZWVkRW1wdHk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2lkZ2V0SWQgPSB0aGlzLmdldEFzc2VydGVkUmVjYXB0Y2hhKCkucmVuZGVyKFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHRoaXMucGFyYW1ldGVyc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy53aWRnZXRJZDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBfYXNzZXJ0KFxuICAgICAgX2lzSHR0cE9ySHR0cHMoKSAmJiAhX2lzV29ya2VyKCksXG4gICAgICB0aGlzLmF1dGgsXG4gICAgICBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SXG4gICAgKTtcblxuICAgIGF3YWl0IGRvbVJlYWR5KCk7XG4gICAgdGhpcy5yZWNhcHRjaGEgPSBhd2FpdCB0aGlzLl9yZWNhcHRjaGFMb2FkZXIubG9hZChcbiAgICAgIHRoaXMuYXV0aCxcbiAgICAgIHRoaXMuYXV0aC5sYW5ndWFnZUNvZGUgfHwgdW5kZWZpbmVkXG4gICAgKTtcblxuICAgIGNvbnN0IHNpdGVLZXkgPSBhd2FpdCBnZXRSZWNhcHRjaGFQYXJhbXModGhpcy5hdXRoKTtcbiAgICBfYXNzZXJ0KHNpdGVLZXksIHRoaXMuYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgdGhpcy5wYXJhbWV0ZXJzLnNpdGVrZXkgPSBzaXRlS2V5O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBc3NlcnRlZFJlY2FwdGNoYSgpOiBSZWNhcHRjaGEge1xuICAgIF9hc3NlcnQodGhpcy5yZWNhcHRjaGEsIHRoaXMuYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgcmV0dXJuIHRoaXMucmVjYXB0Y2hhO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRvbVJlYWR5KCk6IFByb21pc2U8dm9pZD4ge1xuICBsZXQgcmVzb2x2ZXI6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEb2N1bWVudCBub3QgcmVhZHksIHdhaXQgZm9yIGxvYWQgYmVmb3JlIHJlc29sdmluZy5cbiAgICAvLyBTYXZlIHJlc29sdmVyLCBzbyB3ZSBjYW4gcmVtb3ZlIGxpc3RlbmVyIGluIGNhc2UgaXQgd2FzIGV4dGVybmFsbHlcbiAgICAvLyBjYW5jZWxsZWQuXG4gICAgcmVzb2x2ZXIgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCByZXNvbHZlcik7XG4gIH0pLmNhdGNoKGUgPT4ge1xuICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCByZXNvbHZlcik7XG4gICAgfVxuXG4gICAgdGhyb3cgZTtcbiAgfSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBBcHBsaWNhdGlvblZlcmlmaWVyLFxuICBBdXRoLFxuICBDb25maXJtYXRpb25SZXN1bHQsXG4gIFBob25lSW5mb09wdGlvbnMsXG4gIFVzZXIsXG4gIFVzZXJDcmVkZW50aWFsXG59IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IHN0YXJ0RW5yb2xsUGhvbmVNZmEgfSBmcm9tICcuLi8uLi9hcGkvYWNjb3VudF9tYW5hZ2VtZW50L21mYSc7XG5pbXBvcnQgeyBzdGFydFNpZ25JblBob25lTWZhIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL21mYSc7XG5pbXBvcnQgeyBzZW5kUGhvbmVWZXJpZmljYXRpb25Db2RlIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL3Ntcyc7XG5pbXBvcnQgeyBBcHBsaWNhdGlvblZlcmlmaWVySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hcHBsaWNhdGlvbl92ZXJpZmllcic7XG5pbXBvcnQgeyBQaG9uZUF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi4vLi4vY29yZS9jcmVkZW50aWFscy9waG9uZSc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydExpbmtlZFN0YXR1cywgX2xpbmsgfSBmcm9tICcuLi8uLi9jb3JlL3VzZXIvbGlua191bmxpbmsnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQge1xuICBsaW5rV2l0aENyZWRlbnRpYWwsXG4gIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWwsXG4gIHNpZ25JbldpdGhDcmVkZW50aWFsXG59IGZyb20gJy4uLy4uL2NvcmUvc3RyYXRlZ2llcy9jcmVkZW50aWFsJztcbmltcG9ydCB7XG4gIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwsXG4gIE11bHRpRmFjdG9yU2Vzc2lvblR5cGVcbn0gZnJvbSAnLi4vLi4vbWZhL21mYV9zZXNzaW9uJztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgUkVDQVBUQ0hBX1ZFUklGSUVSX1RZUEUgfSBmcm9tICcuLi9yZWNhcHRjaGEvcmVjYXB0Y2hhX3ZlcmlmaWVyJztcbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4uLy4uL2NvcmUvYXV0aC9hdXRoX2ltcGwnO1xuaW1wb3J0IHsgZ2V0TW9kdWxhckluc3RhbmNlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgUHJvdmlkZXJJZCB9IGZyb20gJy4uLy4uL21vZGVsL2VudW1zJztcblxuaW50ZXJmYWNlIE9uQ29uZmlybWF0aW9uQ2FsbGJhY2sge1xuICAoY3JlZGVudGlhbDogUGhvbmVBdXRoQ3JlZGVudGlhbCk6IFByb21pc2U8VXNlckNyZWRlbnRpYWw+O1xufVxuXG5jbGFzcyBDb25maXJtYXRpb25SZXN1bHRJbXBsIGltcGxlbWVudHMgQ29uZmlybWF0aW9uUmVzdWx0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgdmVyaWZpY2F0aW9uSWQ6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9uQ29uZmlybWF0aW9uOiBPbkNvbmZpcm1hdGlvbkNhbGxiYWNrXG4gICkge31cblxuICBjb25maXJtKHZlcmlmaWNhdGlvbkNvZGU6IHN0cmluZyk6IFByb21pc2U8VXNlckNyZWRlbnRpYWw+IHtcbiAgICBjb25zdCBhdXRoQ3JlZGVudGlhbCA9IFBob25lQXV0aENyZWRlbnRpYWwuX2Zyb21WZXJpZmljYXRpb24oXG4gICAgICB0aGlzLnZlcmlmaWNhdGlvbklkLFxuICAgICAgdmVyaWZpY2F0aW9uQ29kZVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMub25Db25maXJtYXRpb24oYXV0aENyZWRlbnRpYWwpO1xuICB9XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gdXNpbmcgYSBwaG9uZSBudW1iZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgbWV0aG9kIHNlbmRzIGEgY29kZSB2aWEgU01TIHRvIHRoZSBnaXZlblxuICogcGhvbmUgbnVtYmVyLCBhbmQgcmV0dXJucyBhIHtAbGluayBDb25maXJtYXRpb25SZXN1bHR9LiBBZnRlciB0aGUgdXNlclxuICogcHJvdmlkZXMgdGhlIGNvZGUgc2VudCB0byB0aGVpciBwaG9uZSwgY2FsbCB7QGxpbmsgQ29uZmlybWF0aW9uUmVzdWx0LmNvbmZpcm19XG4gKiB3aXRoIHRoZSBjb2RlIHRvIHNpZ24gdGhlIHVzZXIgaW4uXG4gKlxuICogRm9yIGFidXNlIHByZXZlbnRpb24sIHRoaXMgbWV0aG9kIGFsc28gcmVxdWlyZXMgYSB7QGxpbmsgQXBwbGljYXRpb25WZXJpZmllcn0uXG4gKiBUaGlzIFNESyBpbmNsdWRlcyBhIHJlQ0FQVENIQS1iYXNlZCBpbXBsZW1lbnRhdGlvbiwge0BsaW5rIFJlY2FwdGNoYVZlcmlmaWVyfS5cbiAqIFRoaXMgZnVuY3Rpb24gY2FuIHdvcmsgb24gb3RoZXIgcGxhdGZvcm1zIHRoYXQgZG8gbm90IHN1cHBvcnQgdGhlXG4gKiB7QGxpbmsgUmVjYXB0Y2hhVmVyaWZpZXJ9IChsaWtlIFJlYWN0IE5hdGl2ZSksIGJ1dCB5b3UgbmVlZCB0byB1c2UgYVxuICogdGhpcmQtcGFydHkge0BsaW5rIEFwcGxpY2F0aW9uVmVyaWZpZXJ9IGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyAncmVjYXB0Y2hhLWNvbnRhaW5lcicgaXMgdGhlIElEIG9mIGFuIGVsZW1lbnQgaW4gdGhlIERPTS5cbiAqIGNvbnN0IGFwcGxpY2F0aW9uVmVyaWZpZXIgPSBuZXcgZmlyZWJhc2UuYXV0aC5SZWNhcHRjaGFWZXJpZmllcigncmVjYXB0Y2hhLWNvbnRhaW5lcicpO1xuICogY29uc3QgY29uZmlybWF0aW9uUmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBob25lTnVtYmVyKGF1dGgsIHBob25lTnVtYmVyLCBhcHBsaWNhdGlvblZlcmlmaWVyKTtcbiAqIC8vIE9idGFpbiBhIHZlcmlmaWNhdGlvbkNvZGUgZnJvbSB0aGUgdXNlci5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCBjb25maXJtYXRpb25SZXN1bHQuY29uZmlybSh2ZXJpZmljYXRpb25Db2RlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBwaG9uZU51bWJlciAtIFRoZSB1c2VyJ3MgcGhvbmUgbnVtYmVyIGluIEUuMTY0IGZvcm1hdCAoZS5nLiArMTY1MDU1NTAxMDEpLlxuICogQHBhcmFtIGFwcFZlcmlmaWVyIC0gVGhlIHtAbGluayBBcHBsaWNhdGlvblZlcmlmaWVyfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGhvbmVOdW1iZXIoXG4gIGF1dGg6IEF1dGgsXG4gIHBob25lTnVtYmVyOiBzdHJpbmcsXG4gIGFwcFZlcmlmaWVyOiBBcHBsaWNhdGlvblZlcmlmaWVyXG4pOiBQcm9taXNlPENvbmZpcm1hdGlvblJlc3VsdD4ge1xuICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gIGNvbnN0IHZlcmlmaWNhdGlvbklkID0gYXdhaXQgX3ZlcmlmeVBob25lTnVtYmVyKFxuICAgIGF1dGhJbnRlcm5hbCxcbiAgICBwaG9uZU51bWJlcixcbiAgICBnZXRNb2R1bGFySW5zdGFuY2UoYXBwVmVyaWZpZXIgYXMgQXBwbGljYXRpb25WZXJpZmllckludGVybmFsKVxuICApO1xuICByZXR1cm4gbmV3IENvbmZpcm1hdGlvblJlc3VsdEltcGwodmVyaWZpY2F0aW9uSWQsIGNyZWQgPT5cbiAgICBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoSW50ZXJuYWwsIGNyZWQpXG4gICk7XG59XG5cbi8qKlxuICogTGlua3MgdGhlIHVzZXIgYWNjb3VudCB3aXRoIHRoZSBnaXZlbiBwaG9uZSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBwaG9uZU51bWJlciAtIFRoZSB1c2VyJ3MgcGhvbmUgbnVtYmVyIGluIEUuMTY0IGZvcm1hdCAoZS5nLiArMTY1MDU1NTAxMDEpLlxuICogQHBhcmFtIGFwcFZlcmlmaWVyIC0gVGhlIHtAbGluayBBcHBsaWNhdGlvblZlcmlmaWVyfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsaW5rV2l0aFBob25lTnVtYmVyKFxuICB1c2VyOiBVc2VyLFxuICBwaG9uZU51bWJlcjogc3RyaW5nLFxuICBhcHBWZXJpZmllcjogQXBwbGljYXRpb25WZXJpZmllclxuKTogUHJvbWlzZTxDb25maXJtYXRpb25SZXN1bHQ+IHtcbiAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpIGFzIFVzZXJJbnRlcm5hbDtcbiAgYXdhaXQgX2Fzc2VydExpbmtlZFN0YXR1cyhmYWxzZSwgdXNlckludGVybmFsLCBQcm92aWRlcklkLlBIT05FKTtcbiAgY29uc3QgdmVyaWZpY2F0aW9uSWQgPSBhd2FpdCBfdmVyaWZ5UGhvbmVOdW1iZXIoXG4gICAgdXNlckludGVybmFsLmF1dGgsXG4gICAgcGhvbmVOdW1iZXIsXG4gICAgZ2V0TW9kdWxhckluc3RhbmNlKGFwcFZlcmlmaWVyIGFzIEFwcGxpY2F0aW9uVmVyaWZpZXJJbnRlcm5hbClcbiAgKTtcbiAgcmV0dXJuIG5ldyBDb25maXJtYXRpb25SZXN1bHRJbXBsKHZlcmlmaWNhdGlvbklkLCBjcmVkID0+XG4gICAgbGlua1dpdGhDcmVkZW50aWFsKHVzZXJJbnRlcm5hbCwgY3JlZClcbiAgKTtcbn1cblxuLyoqXG4gKiBSZS1hdXRoZW50aWNhdGVzIGEgdXNlciB1c2luZyBhIGZyZXNoIHBob25lIGNyZWRlbnRpYWwuXG4gKlxuICogQHJlbWFya3MgVXNlIGJlZm9yZSBvcGVyYXRpb25zIHN1Y2ggYXMge0BsaW5rIHVwZGF0ZVBhc3N3b3JkfSB0aGF0IHJlcXVpcmUgdG9rZW5zIGZyb20gcmVjZW50IHNpZ24taW4gYXR0ZW1wdHMuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBwaG9uZU51bWJlciAtIFRoZSB1c2VyJ3MgcGhvbmUgbnVtYmVyIGluIEUuMTY0IGZvcm1hdCAoZS5nLiArMTY1MDU1NTAxMDEpLlxuICogQHBhcmFtIGFwcFZlcmlmaWVyIC0gVGhlIHtAbGluayBBcHBsaWNhdGlvblZlcmlmaWVyfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlcihcbiAgdXNlcjogVXNlcixcbiAgcGhvbmVOdW1iZXI6IHN0cmluZyxcbiAgYXBwVmVyaWZpZXI6IEFwcGxpY2F0aW9uVmVyaWZpZXJcbik6IFByb21pc2U8Q29uZmlybWF0aW9uUmVzdWx0PiB7XG4gIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWw7XG4gIGNvbnN0IHZlcmlmaWNhdGlvbklkID0gYXdhaXQgX3ZlcmlmeVBob25lTnVtYmVyKFxuICAgIHVzZXJJbnRlcm5hbC5hdXRoLFxuICAgIHBob25lTnVtYmVyLFxuICAgIGdldE1vZHVsYXJJbnN0YW5jZShhcHBWZXJpZmllciBhcyBBcHBsaWNhdGlvblZlcmlmaWVySW50ZXJuYWwpXG4gICk7XG4gIHJldHVybiBuZXcgQ29uZmlybWF0aW9uUmVzdWx0SW1wbCh2ZXJpZmljYXRpb25JZCwgY3JlZCA9PlxuICAgIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWwodXNlckludGVybmFsLCBjcmVkKVxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB2ZXJpZmljYXRpb24gSUQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBTTVMgY29kZSB0aGF0IGlzIHNlbnQuXG4gKlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3ZlcmlmeVBob25lTnVtYmVyKFxuICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gIG9wdGlvbnM6IFBob25lSW5mb09wdGlvbnMgfCBzdHJpbmcsXG4gIHZlcmlmaWVyOiBBcHBsaWNhdGlvblZlcmlmaWVySW50ZXJuYWxcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHJlY2FwdGNoYVRva2VuID0gYXdhaXQgdmVyaWZpZXIudmVyaWZ5KCk7XG5cbiAgdHJ5IHtcbiAgICBfYXNzZXJ0KFxuICAgICAgdHlwZW9mIHJlY2FwdGNoYVRva2VuID09PSAnc3RyaW5nJyxcbiAgICAgIGF1dGgsXG4gICAgICBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SXG4gICAgKTtcbiAgICBfYXNzZXJ0KFxuICAgICAgdmVyaWZpZXIudHlwZSA9PT0gUkVDQVBUQ0hBX1ZFUklGSUVSX1RZUEUsXG4gICAgICBhdXRoLFxuICAgICAgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUlxuICAgICk7XG5cbiAgICBsZXQgcGhvbmVJbmZvT3B0aW9uczogUGhvbmVJbmZvT3B0aW9ucztcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBob25lSW5mb09wdGlvbnMgPSB7XG4gICAgICAgIHBob25lTnVtYmVyOiBvcHRpb25zXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwaG9uZUluZm9PcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoJ3Nlc3Npb24nIGluIHBob25lSW5mb09wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNlc3Npb24gPSBwaG9uZUluZm9PcHRpb25zLnNlc3Npb24gYXMgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbDtcblxuICAgICAgaWYgKCdwaG9uZU51bWJlcicgaW4gcGhvbmVJbmZvT3B0aW9ucykge1xuICAgICAgICBfYXNzZXJ0KFxuICAgICAgICAgIHNlc3Npb24udHlwZSA9PT0gTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5FTlJPTEwsXG4gICAgICAgICAgYXV0aCxcbiAgICAgICAgICBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc3RhcnRFbnJvbGxQaG9uZU1mYShhdXRoLCB7XG4gICAgICAgICAgaWRUb2tlbjogc2Vzc2lvbi5jcmVkZW50aWFsLFxuICAgICAgICAgIHBob25lRW5yb2xsbWVudEluZm86IHtcbiAgICAgICAgICAgIHBob25lTnVtYmVyOiBwaG9uZUluZm9PcHRpb25zLnBob25lTnVtYmVyLFxuICAgICAgICAgICAgcmVjYXB0Y2hhVG9rZW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UucGhvbmVTZXNzaW9uSW5mby5zZXNzaW9uSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hc3NlcnQoXG4gICAgICAgICAgc2Vzc2lvbi50eXBlID09PSBNdWx0aUZhY3RvclNlc3Npb25UeXBlLlNJR05fSU4sXG4gICAgICAgICAgYXV0aCxcbiAgICAgICAgICBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG1mYUVucm9sbG1lbnRJZCA9XG4gICAgICAgICAgcGhvbmVJbmZvT3B0aW9ucy5tdWx0aUZhY3RvckhpbnQ/LnVpZCB8fFxuICAgICAgICAgIHBob25lSW5mb09wdGlvbnMubXVsdGlGYWN0b3JVaWQ7XG4gICAgICAgIF9hc3NlcnQobWZhRW5yb2xsbWVudElkLCBhdXRoLCBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX0lORk8pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN0YXJ0U2lnbkluUGhvbmVNZmEoYXV0aCwge1xuICAgICAgICAgIG1mYVBlbmRpbmdDcmVkZW50aWFsOiBzZXNzaW9uLmNyZWRlbnRpYWwsXG4gICAgICAgICAgbWZhRW5yb2xsbWVudElkLFxuICAgICAgICAgIHBob25lU2lnbkluSW5mbzoge1xuICAgICAgICAgICAgcmVjYXB0Y2hhVG9rZW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UucGhvbmVSZXNwb25zZUluZm8uc2Vzc2lvbkluZm87XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgc2Vzc2lvbkluZm8gfSA9IGF3YWl0IHNlbmRQaG9uZVZlcmlmaWNhdGlvbkNvZGUoYXV0aCwge1xuICAgICAgICBwaG9uZU51bWJlcjogcGhvbmVJbmZvT3B0aW9ucy5waG9uZU51bWJlcixcbiAgICAgICAgcmVjYXB0Y2hhVG9rZW5cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlc3Npb25JbmZvO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICB2ZXJpZmllci5fcmVzZXQoKTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHVzZXIncyBwaG9uZSBudW1iZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogLy8gJ3JlY2FwdGNoYS1jb250YWluZXInIGlzIHRoZSBJRCBvZiBhbiBlbGVtZW50IGluIHRoZSBET00uXG4gKiBjb25zdCBhcHBsaWNhdGlvblZlcmlmaWVyID0gbmV3IFJlY2FwdGNoYVZlcmlmaWVyKCdyZWNhcHRjaGEtY29udGFpbmVyJyk7XG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBQaG9uZUF1dGhQcm92aWRlcihhdXRoKTtcbiAqIGNvbnN0IHZlcmlmaWNhdGlvbklkID0gYXdhaXQgcHJvdmlkZXIudmVyaWZ5UGhvbmVOdW1iZXIoJysxNjUwNTU1MDEwMScsIGFwcGxpY2F0aW9uVmVyaWZpZXIpO1xuICogLy8gT2J0YWluIHRoZSB2ZXJpZmljYXRpb25Db2RlIGZyb20gdGhlIHVzZXIuXG4gKiBjb25zdCBwaG9uZUNyZWRlbnRpYWwgPSBQaG9uZUF1dGhQcm92aWRlci5jcmVkZW50aWFsKHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlKTtcbiAqIGF3YWl0IHVwZGF0ZVBob25lTnVtYmVyKHVzZXIsIHBob25lQ3JlZGVudGlhbCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIGNyZWRlbnRpYWwgLSBBIGNyZWRlbnRpYWwgYXV0aGVudGljYXRpbmcgdGhlIG5ldyBwaG9uZSBudW1iZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlUGhvbmVOdW1iZXIoXG4gIHVzZXI6IFVzZXIsXG4gIGNyZWRlbnRpYWw6IFBob25lQXV0aENyZWRlbnRpYWxcbik6IFByb21pc2U8dm9pZD4ge1xuICBhd2FpdCBfbGluayhnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsLCBjcmVkZW50aWFsKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEF1dGgsXG4gIFBob25lSW5mb09wdGlvbnMsXG4gIEFwcGxpY2F0aW9uVmVyaWZpZXIsXG4gIFVzZXJDcmVkZW50aWFsXG59IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IFNpZ25JbldpdGhQaG9uZU51bWJlclJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL3Ntcyc7XG5pbXBvcnQgeyBBcHBsaWNhdGlvblZlcmlmaWVySW50ZXJuYWwgYXMgQXBwbGljYXRpb25WZXJpZmllckludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXBwbGljYXRpb25fdmVyaWZpZXInO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIGFzIEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbnRlcm5hbCBhcyBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBQaG9uZUF1dGhDcmVkZW50aWFsIH0gZnJvbSAnLi4vLi4vY29yZS9jcmVkZW50aWFscy9waG9uZSc7XG5pbXBvcnQgeyBfdmVyaWZ5UGhvbmVOdW1iZXIgfSBmcm9tICcuLi9zdHJhdGVnaWVzL3Bob25lJztcbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4uLy4uL2NvcmUvYXV0aC9hdXRoX2ltcGwnO1xuaW1wb3J0IHsgQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCB7IEZpcmViYXNlRXJyb3IsIGdldE1vZHVsYXJJbnN0YW5jZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaWRfdG9rZW4nO1xuaW1wb3J0IHsgUHJvdmlkZXJJZCwgU2lnbkluTWV0aG9kIH0gZnJvbSAnLi4vLi4vbW9kZWwvZW51bXMnO1xuXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBQaG9uZUF1dGhDcmVkZW50aWFsfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gJ3JlY2FwdGNoYS1jb250YWluZXInIGlzIHRoZSBJRCBvZiBhbiBlbGVtZW50IGluIHRoZSBET00uXG4gKiBjb25zdCBhcHBsaWNhdGlvblZlcmlmaWVyID0gbmV3IFJlY2FwdGNoYVZlcmlmaWVyKCdyZWNhcHRjaGEtY29udGFpbmVyJyk7XG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBQaG9uZUF1dGhQcm92aWRlcihhdXRoKTtcbiAqIGNvbnN0IHZlcmlmaWNhdGlvbklkID0gYXdhaXQgcHJvdmlkZXIudmVyaWZ5UGhvbmVOdW1iZXIoJysxNjUwNTU1MDEwMScsIGFwcGxpY2F0aW9uVmVyaWZpZXIpO1xuICogLy8gT2J0YWluIHRoZSB2ZXJpZmljYXRpb25Db2RlIGZyb20gdGhlIHVzZXIuXG4gKiBjb25zdCBwaG9uZUNyZWRlbnRpYWwgPSBQaG9uZUF1dGhQcm92aWRlci5jcmVkZW50aWFsKHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlKTtcbiAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aCwgcGhvbmVDcmVkZW50aWFsKTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFBob25lQXV0aFByb3ZpZGVyIHtcbiAgLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LlBIT05FLiAqL1xuICBzdGF0aWMgcmVhZG9ubHkgUFJPVklERVJfSUQ6ICdwaG9uZScgPSBQcm92aWRlcklkLlBIT05FO1xuICAvKiogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5QSE9ORS4gKi9cbiAgc3RhdGljIHJlYWRvbmx5IFBIT05FX1NJR05fSU5fTUVUSE9EOiAncGhvbmUnID0gU2lnbkluTWV0aG9kLlBIT05FO1xuXG4gIC8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5QSE9ORS4gKi9cbiAgcmVhZG9ubHkgcHJvdmlkZXJJZCA9IFBob25lQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEO1xuICBwcml2YXRlIHJlYWRvbmx5IGF1dGg6IEF1dGhJbnRlcm5hbDtcblxuICAvKipcbiAgICogQHBhcmFtIGF1dGggLSBUaGUgRmlyZWJhc2Uge0BsaW5rIEF1dGh9IGluc3RhbmNlIGluIHdoaWNoIHNpZ24taW5zIHNob3VsZCBvY2N1ci5cbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKGF1dGg6IEF1dGgpIHtcbiAgICB0aGlzLmF1dGggPSBfY2FzdEF1dGgoYXV0aCk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogU3RhcnRzIGEgcGhvbmUgbnVtYmVyIGF1dGhlbnRpY2F0aW9uIGZsb3cgYnkgc2VuZGluZyBhIHZlcmlmaWNhdGlvbiBjb2RlIHRvIHRoZSBnaXZlbiBwaG9uZVxuICAgKiBudW1iZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY29uc3QgcHJvdmlkZXIgPSBuZXcgUGhvbmVBdXRoUHJvdmlkZXIoYXV0aCk7XG4gICAqIGNvbnN0IHZlcmlmaWNhdGlvbklkID0gYXdhaXQgcHJvdmlkZXIudmVyaWZ5UGhvbmVOdW1iZXIocGhvbmVOdW1iZXIsIGFwcGxpY2F0aW9uVmVyaWZpZXIpO1xuICAgKiAvLyBPYnRhaW4gdmVyaWZpY2F0aW9uQ29kZSBmcm9tIHRoZSB1c2VyLlxuICAgKiBjb25zdCBhdXRoQ3JlZGVudGlhbCA9IFBob25lQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwodmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUpO1xuICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGF1dGhDcmVkZW50aWFsKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIEFuIGFsdGVybmF0aXZlIGZsb3cgaXMgcHJvdmlkZWQgdXNpbmcgdGhlIGBzaWduSW5XaXRoUGhvbmVOdW1iZXJgIG1ldGhvZC5cbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBjb25maXJtYXRpb25SZXN1bHQgPSBzaWduSW5XaXRoUGhvbmVOdW1iZXIoYXV0aCwgcGhvbmVOdW1iZXIsIGFwcGxpY2F0aW9uVmVyaWZpZXIpO1xuICAgKiAvLyBPYnRhaW4gdmVyaWZpY2F0aW9uQ29kZSBmcm9tIHRoZSB1c2VyLlxuICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGNvbmZpcm1hdGlvblJlc3VsdC5jb25maXJtKHZlcmlmaWNhdGlvbkNvZGUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHBob25lSW5mb09wdGlvbnMgLSBUaGUgdXNlcidzIHtAbGluayBQaG9uZUluZm9PcHRpb25zfS4gVGhlIHBob25lIG51bWJlciBzaG91bGQgYmUgaW5cbiAgICogRS4xNjQgZm9ybWF0IChlLmcuICsxNjUwNTU1MDEwMSkuXG4gICAqIEBwYXJhbSBhcHBsaWNhdGlvblZlcmlmaWVyIC0gRm9yIGFidXNlIHByZXZlbnRpb24sIHRoaXMgbWV0aG9kIGFsc28gcmVxdWlyZXMgYVxuICAgKiB7QGxpbmsgQXBwbGljYXRpb25WZXJpZmllcn0uIFRoaXMgU0RLIGluY2x1ZGVzIGEgcmVDQVBUQ0hBLWJhc2VkIGltcGxlbWVudGF0aW9uLFxuICAgKiB7QGxpbmsgUmVjYXB0Y2hhVmVyaWZpZXJ9LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgZm9yIGEgdmVyaWZpY2F0aW9uIElEIHRoYXQgY2FuIGJlIHBhc3NlZCB0b1xuICAgKiB7QGxpbmsgUGhvbmVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbH0gdG8gaWRlbnRpZnkgdGhpcyBmbG93Li5cbiAgICovXG4gIHZlcmlmeVBob25lTnVtYmVyKFxuICAgIHBob25lT3B0aW9uczogUGhvbmVJbmZvT3B0aW9ucyB8IHN0cmluZyxcbiAgICBhcHBsaWNhdGlvblZlcmlmaWVyOiBBcHBsaWNhdGlvblZlcmlmaWVyXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIF92ZXJpZnlQaG9uZU51bWJlcihcbiAgICAgIHRoaXMuYXV0aCxcbiAgICAgIHBob25lT3B0aW9ucyxcbiAgICAgIGdldE1vZHVsYXJJbnN0YW5jZShhcHBsaWNhdGlvblZlcmlmaWVyIGFzIEFwcGxpY2F0aW9uVmVyaWZpZXJJbnRlcm5hbClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwaG9uZSBhdXRoIGNyZWRlbnRpYWwsIGdpdmVuIHRoZSB2ZXJpZmljYXRpb24gSUQgZnJvbVxuICAgKiB7QGxpbmsgUGhvbmVBdXRoUHJvdmlkZXIudmVyaWZ5UGhvbmVOdW1iZXJ9IGFuZCB0aGUgY29kZSB0aGF0IHdhcyBzZW50IHRvIHRoZSB1c2VyJ3NcbiAgICogbW9iaWxlIGRldmljZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBwcm92aWRlciA9IG5ldyBQaG9uZUF1dGhQcm92aWRlcihhdXRoKTtcbiAgICogY29uc3QgdmVyaWZpY2F0aW9uSWQgPSBwcm92aWRlci52ZXJpZnlQaG9uZU51bWJlcihwaG9uZU51bWJlciwgYXBwbGljYXRpb25WZXJpZmllcik7XG4gICAqIC8vIE9idGFpbiB2ZXJpZmljYXRpb25Db2RlIGZyb20gdGhlIHVzZXIuXG4gICAqIGNvbnN0IGF1dGhDcmVkZW50aWFsID0gUGhvbmVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbCh2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSk7XG4gICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aCwgYXV0aENyZWRlbnRpYWwpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogQW4gYWx0ZXJuYXRpdmUgZmxvdyBpcyBwcm92aWRlZCB1c2luZyB0aGUgYHNpZ25JbldpdGhQaG9uZU51bWJlcmAgbWV0aG9kLlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IGNvbmZpcm1hdGlvblJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQaG9uZU51bWJlcihhdXRoLCBwaG9uZU51bWJlciwgYXBwbGljYXRpb25WZXJpZmllcik7XG4gICAqIC8vIE9idGFpbiB2ZXJpZmljYXRpb25Db2RlIGZyb20gdGhlIHVzZXIuXG4gICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgY29uZmlybWF0aW9uUmVzdWx0LmNvbmZpcm0odmVyaWZpY2F0aW9uQ29kZSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gdmVyaWZpY2F0aW9uSWQgLSBUaGUgdmVyaWZpY2F0aW9uIElEIHJldHVybmVkIGZyb20ge0BsaW5rIFBob25lQXV0aFByb3ZpZGVyLnZlcmlmeVBob25lTnVtYmVyfS5cbiAgICogQHBhcmFtIHZlcmlmaWNhdGlvbkNvZGUgLSBUaGUgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlcidzIG1vYmlsZSBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBhdXRoIHByb3ZpZGVyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbChcbiAgICB2ZXJpZmljYXRpb25JZDogc3RyaW5nLFxuICAgIHZlcmlmaWNhdGlvbkNvZGU6IHN0cmluZ1xuICApOiBQaG9uZUF1dGhDcmVkZW50aWFsIHtcbiAgICByZXR1cm4gUGhvbmVBdXRoQ3JlZGVudGlhbC5fZnJvbVZlcmlmaWNhdGlvbihcbiAgICAgIHZlcmlmaWNhdGlvbklkLFxuICAgICAgdmVyaWZpY2F0aW9uQ29kZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQoXG4gICAgdXNlckNyZWRlbnRpYWw6IFVzZXJDcmVkZW50aWFsXG4gICk6IEF1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgY29uc3QgY3JlZGVudGlhbCA9IHVzZXJDcmVkZW50aWFsIGFzIFVzZXJDcmVkZW50aWFsSW50ZXJuYWw7XG4gICAgcmV0dXJuIFBob25lQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KGNyZWRlbnRpYWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSB3aGVuIHBhc3NlZCBhbiBlcnJvci5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd29ya3MgZm9yIGVycm9ycyBsaWtlXG4gICAqIGBhdXRoL2FjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxzYC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIHJlY292ZXJpbmcgd2hlbiBhdHRlbXB0aW5nIHRvIHNldCBhIHVzZXIncyBwaG9uZSBudW1iZXIgYnV0IHRoZSBudW1iZXJcbiAgICogaW4gcXVlc3Rpb24gaXMgYWxyZWFkeSB0aWVkIHRvIGFub3RoZXIgYWNjb3VudC4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmdcbiAgICogY29kZSB0cmllcyB0byB1cGRhdGUgdGhlIGN1cnJlbnQgdXNlcidzIHBob25lIG51bWJlciwgYW5kIGlmIHRoYXRcbiAgICogZmFpbHMsIGxpbmtzIHRoZSB1c2VyIHdpdGggdGhlIGFjY291bnQgYXNzb2NpYXRlZCB3aXRoIHRoYXQgbnVtYmVyOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBwcm92aWRlciA9IG5ldyBQaG9uZUF1dGhQcm92aWRlcihhdXRoKTtcbiAgICogY29uc3QgdmVyaWZpY2F0aW9uSWQgPSBhd2FpdCBwcm92aWRlci52ZXJpZnlQaG9uZU51bWJlcihudW1iZXIsIHZlcmlmaWVyKTtcbiAgICogdHJ5IHtcbiAgICogICBjb25zdCBjb2RlID0gJyc7IC8vIFByb21wdCB0aGUgdXNlciBmb3IgdGhlIHZlcmlmaWNhdGlvbiBjb2RlXG4gICAqICAgYXdhaXQgdXBkYXRlUGhvbmVOdW1iZXIoXG4gICAqICAgICAgIGF1dGguY3VycmVudFVzZXIsXG4gICAqICAgICAgIFBob25lQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwodmVyaWZpY2F0aW9uSWQsIGNvZGUpKTtcbiAgICogfSBjYXRjaCAoZSkge1xuICAgKiAgIGlmICgoZSBhcyBGaXJlYmFzZUVycm9yKT8uY29kZSA9PT0gJ2F1dGgvYWNjb3VudC1leGlzdHMtd2l0aC1kaWZmZXJlbnQtY3JlZGVudGlhbCcpIHtcbiAgICogICAgIGNvbnN0IGNyZWQgPSBQaG9uZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbUVycm9yKGUpO1xuICAgKiAgICAgYXdhaXQgbGlua1dpdGhDcmVkZW50aWFsKGF1dGguY3VycmVudFVzZXIsIGNyZWQpO1xuICAgKiAgIH1cbiAgICogfVxuICAgKlxuICAgKiAvLyBBdCB0aGlzIHBvaW50LCBhdXRoLmN1cnJlbnRVc2VyLnBob25lTnVtYmVyID09PSBudW1iZXIuXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gZ2VuZXJhdGUgYSBjcmVkZW50aWFsIGZyb20uXG4gICAqL1xuICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcjogRmlyZWJhc2VFcnJvcik6IEF1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgcmV0dXJuIFBob25lQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KFxuICAgICAgKGVycm9yLmN1c3RvbURhdGEgfHwge30pIGFzIFRhZ2dlZFdpdGhUb2tlblJlc3BvbnNlXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHtcbiAgICBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZVxuICB9OiBUYWdnZWRXaXRoVG9rZW5SZXNwb25zZSk6IEF1dGhDcmVkZW50aWFsIHwgbnVsbCB7XG4gICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBwaG9uZU51bWJlciwgdGVtcG9yYXJ5UHJvb2YgfSA9XG4gICAgICB0b2tlblJlc3BvbnNlIGFzIFNpZ25JbldpdGhQaG9uZU51bWJlclJlc3BvbnNlO1xuICAgIGlmIChwaG9uZU51bWJlciAmJiB0ZW1wb3JhcnlQcm9vZikge1xuICAgICAgcmV0dXJuIFBob25lQXV0aENyZWRlbnRpYWwuX2Zyb21Ub2tlblJlc3BvbnNlKFxuICAgICAgICBwaG9uZU51bWJlcixcbiAgICAgICAgdGVtcG9yYXJ5UHJvb2ZcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3BvcHVwX3JlZGlyZWN0JztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4vYXNzZXJ0JztcbmltcG9ydCB7IF9nZXRJbnN0YW5jZSB9IGZyb20gJy4vaW5zdGFudGlhdG9yJztcblxuLyoqXG4gKiBDaG9vc2VzIGEgcG9wdXAvcmVkaXJlY3QgcmVzb2x2ZXIgdG8gdXNlLiBUaGlzIHByZWZlcnMgdGhlIG92ZXJyaWRlICh3aGljaFxuICogaXMgZGlyZWN0bHkgcGFzc2VkIGluKSwgYW5kIGZhbGxzIGJhY2sgdG8gdGhlIHByb3BlcnR5IHNldCBvbiB0aGUgYXV0aFxuICogb2JqZWN0LiBJZiBuZWl0aGVyIGFyZSBhdmFpbGFibGUsIHRoaXMgZnVuY3Rpb24gZXJyb3JzIHcvIGFuIGFyZ3VtZW50IGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX3dpdGhEZWZhdWx0UmVzb2x2ZXIoXG4gIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgcmVzb2x2ZXJPdmVycmlkZTogUG9wdXBSZWRpcmVjdFJlc29sdmVyIHwgdW5kZWZpbmVkXG4pOiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJJbnRlcm5hbCB7XG4gIGlmIChyZXNvbHZlck92ZXJyaWRlKSB7XG4gICAgcmV0dXJuIF9nZXRJbnN0YW5jZShyZXNvbHZlck92ZXJyaWRlKTtcbiAgfVxuXG4gIF9hc3NlcnQoYXV0aC5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLCBhdXRoLCBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SKTtcblxuICByZXR1cm4gYXV0aC5fcG9wdXBSZWRpcmVjdFJlc29sdmVyO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgc2lnbkluV2l0aElkcCxcbiAgU2lnbkluV2l0aElkcFJlcXVlc3Rcbn0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL2lkcCc7XG5pbXBvcnQgeyBQaG9uZU9yT2F1dGhUb2tlblJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vYXBpL2F1dGhlbnRpY2F0aW9uL21mYSc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IElkVG9rZW5SZXNwb25zZSB9IGZyb20gJy4uLy4uL21vZGVsL2lkX3Rva2VuJztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCwgVXNlckNyZWRlbnRpYWxJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgQXV0aENyZWRlbnRpYWwgfSBmcm9tICcuLi9jcmVkZW50aWFscyc7XG5pbXBvcnQgeyBfbGluayBhcyBfbGlua1VzZXIgfSBmcm9tICcuLi91c2VyL2xpbmtfdW5saW5rJztcbmltcG9ydCB7IF9yZWF1dGhlbnRpY2F0ZSB9IGZyb20gJy4uL3VzZXIvcmVhdXRoZW50aWNhdGUnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IF9zaWduSW5XaXRoQ3JlZGVudGlhbCB9IGZyb20gJy4vY3JlZGVudGlhbCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IFByb3ZpZGVySWQgfSBmcm9tICcuLi8uLi9tb2RlbC9lbnVtcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSWRwVGFza1BhcmFtcyB7XG4gIGF1dGg6IEF1dGhJbnRlcm5hbDtcbiAgcmVxdWVzdFVyaTogc3RyaW5nO1xuICBzZXNzaW9uSWQ/OiBzdHJpbmc7XG4gIHRlbmFudElkPzogc3RyaW5nO1xuICBwb3N0Qm9keT86IHN0cmluZztcbiAgcGVuZGluZ1Rva2VuPzogc3RyaW5nO1xuICB1c2VyPzogVXNlckludGVybmFsO1xuICBieXBhc3NBdXRoU3RhdGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBJZHBUYXNrID0gKFxuICBwYXJhbXM6IElkcFRhc2tQYXJhbXNcbikgPT4gUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEludGVybmFsPjtcblxuY2xhc3MgSWRwQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgcGFyYW1zOiBJZHBUYXNrUGFyYW1zKSB7XG4gICAgc3VwZXIoUHJvdmlkZXJJZC5DVVNUT00sIFByb3ZpZGVySWQuQ1VTVE9NKTtcbiAgfVxuXG4gIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxQaG9uZU9yT2F1dGhUb2tlblJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgdGhpcy5fYnVpbGRJZHBSZXF1ZXN0KCkpO1xuICB9XG5cbiAgX2xpbmtUb0lkVG9rZW4oXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGlkVG9rZW46IHN0cmluZ1xuICApOiBQcm9taXNlPElkVG9rZW5SZXNwb25zZT4ge1xuICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHRoaXMuX2J1aWxkSWRwUmVxdWVzdChpZFRva2VuKSk7XG4gIH1cblxuICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8SWRUb2tlblJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgdGhpcy5fYnVpbGRJZHBSZXF1ZXN0KCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBfYnVpbGRJZHBSZXF1ZXN0KGlkVG9rZW4/OiBzdHJpbmcpOiBTaWduSW5XaXRoSWRwUmVxdWVzdCB7XG4gICAgY29uc3QgcmVxdWVzdDogU2lnbkluV2l0aElkcFJlcXVlc3QgPSB7XG4gICAgICByZXF1ZXN0VXJpOiB0aGlzLnBhcmFtcy5yZXF1ZXN0VXJpLFxuICAgICAgc2Vzc2lvbklkOiB0aGlzLnBhcmFtcy5zZXNzaW9uSWQsXG4gICAgICBwb3N0Qm9keTogdGhpcy5wYXJhbXMucG9zdEJvZHksXG4gICAgICB0ZW5hbnRJZDogdGhpcy5wYXJhbXMudGVuYW50SWQsXG4gICAgICBwZW5kaW5nVG9rZW46IHRoaXMucGFyYW1zLnBlbmRpbmdUb2tlbixcbiAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlLFxuICAgICAgcmV0dXJuSWRwQ3JlZGVudGlhbDogdHJ1ZVxuICAgIH07XG5cbiAgICBpZiAoaWRUb2tlbikge1xuICAgICAgcmVxdWVzdC5pZFRva2VuID0gaWRUb2tlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX3NpZ25JbihcbiAgcGFyYW1zOiBJZHBUYXNrUGFyYW1zXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWw+IHtcbiAgcmV0dXJuIF9zaWduSW5XaXRoQ3JlZGVudGlhbChcbiAgICBwYXJhbXMuYXV0aCxcbiAgICBuZXcgSWRwQ3JlZGVudGlhbChwYXJhbXMpLFxuICAgIHBhcmFtcy5ieXBhc3NBdXRoU3RhdGVcbiAgKSBhcyBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWw+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3JlYXV0aChcbiAgcGFyYW1zOiBJZHBUYXNrUGFyYW1zXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWw+IHtcbiAgY29uc3QgeyBhdXRoLCB1c2VyIH0gPSBwYXJhbXM7XG4gIF9hc3NlcnQodXNlciwgYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gIHJldHVybiBfcmVhdXRoZW50aWNhdGUoXG4gICAgdXNlcixcbiAgICBuZXcgSWRwQ3JlZGVudGlhbChwYXJhbXMpLFxuICAgIHBhcmFtcy5ieXBhc3NBdXRoU3RhdGVcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9saW5rKFxuICBwYXJhbXM6IElkcFRhc2tQYXJhbXNcbik6IFByb21pc2U8VXNlckNyZWRlbnRpYWxJbnRlcm5hbD4ge1xuICBjb25zdCB7IGF1dGgsIHVzZXIgfSA9IHBhcmFtcztcbiAgX2Fzc2VydCh1c2VyLCBhdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgcmV0dXJuIF9saW5rVXNlcih1c2VyLCBuZXcgSWRwQ3JlZGVudGlhbChwYXJhbXMpLCBwYXJhbXMuYnlwYXNzQXV0aFN0YXRlKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbmltcG9ydCB7XG4gIEF1dGhFdmVudCxcbiAgQXV0aEV2ZW50Q29uc3VtZXIsXG4gIEF1dGhFdmVudFR5cGUsXG4gIEV2ZW50TWFuYWdlcixcbiAgUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWxcbn0gZnJvbSAnLi4vLi4vbW9kZWwvcG9wdXBfcmVkaXJlY3QnO1xuaW1wb3J0IHsgVXNlckludGVybmFsLCBVc2VyQ3JlZGVudGlhbEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvdXNlcic7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGRlYnVnQXNzZXJ0LCBfZmFpbCB9IGZyb20gJy4uL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7XG4gIF9saW5rLFxuICBfcmVhdXRoLFxuICBfc2lnbkluLFxuICBJZHBUYXNrLFxuICBJZHBUYXNrUGFyYW1zXG59IGZyb20gJy4uL3N0cmF0ZWdpZXMvaWRwJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuXG5pbnRlcmZhY2UgUGVuZGluZ1Byb21pc2Uge1xuICByZXNvbHZlOiAoY3JlZDogVXNlckNyZWRlbnRpYWxJbnRlcm5hbCB8IG51bGwpID0+IHZvaWQ7XG4gIHJlamVjdDogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBQb3B1cCBldmVudCBtYW5hZ2VyLiBIYW5kbGVzIHRoZSBwb3B1cCdzIGVudGlyZSBsaWZlY3ljbGU7IGxpc3RlbnMgdG8gYXV0aFxuICogZXZlbnRzXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFBvcHVwUmVkaXJlY3RPcGVyYXRpb25cbiAgaW1wbGVtZW50cyBBdXRoRXZlbnRDb25zdW1lclxue1xuICBwcml2YXRlIHBlbmRpbmdQcm9taXNlOiBQZW5kaW5nUHJvbWlzZSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGV2ZW50TWFuYWdlcjogRXZlbnRNYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG4gIHJlYWRvbmx5IGZpbHRlcjogQXV0aEV2ZW50VHlwZVtdO1xuXG4gIGFic3RyYWN0IGV2ZW50SWQ6IHN0cmluZyB8IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBmaWx0ZXI6IEF1dGhFdmVudFR5cGUgfCBBdXRoRXZlbnRUeXBlW10sXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHJlc29sdmVyOiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJJbnRlcm5hbCxcbiAgICBwcm90ZWN0ZWQgdXNlcj86IFVzZXJJbnRlcm5hbCxcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2VcbiAgKSB7XG4gICAgdGhpcy5maWx0ZXIgPSBBcnJheS5pc0FycmF5KGZpbHRlcikgPyBmaWx0ZXIgOiBbZmlsdGVyXTtcbiAgfVxuXG4gIGFic3RyYWN0IG9uRXhlY3V0aW9uKCk6IFByb21pc2U8dm9pZD47XG5cbiAgZXhlY3V0ZSgpOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfCBudWxsPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfCBudWxsPihcbiAgICAgIGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUHJvbWlzZSA9IHsgcmVzb2x2ZSwgcmVqZWN0IH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGF3YWl0IHRoaXMucmVzb2x2ZXIuX2luaXRpYWxpemUodGhpcy5hdXRoKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLm9uRXhlY3V0aW9uKCk7XG4gICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIucmVnaXN0ZXJDb25zdW1lcih0aGlzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMucmVqZWN0KGUgYXMgRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIG9uQXV0aEV2ZW50KGV2ZW50OiBBdXRoRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7IHVybFJlc3BvbnNlLCBzZXNzaW9uSWQsIHBvc3RCb2R5LCB0ZW5hbnRJZCwgZXJyb3IsIHR5cGUgfSA9IGV2ZW50O1xuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhpcy5yZWplY3QoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmFtczogSWRwVGFza1BhcmFtcyA9IHtcbiAgICAgIGF1dGg6IHRoaXMuYXV0aCxcbiAgICAgIHJlcXVlc3RVcmk6IHVybFJlc3BvbnNlISxcbiAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkISxcbiAgICAgIHRlbmFudElkOiB0ZW5hbnRJZCB8fCB1bmRlZmluZWQsXG4gICAgICBwb3N0Qm9keTogcG9zdEJvZHkgfHwgdW5kZWZpbmVkLFxuICAgICAgdXNlcjogdGhpcy51c2VyLFxuICAgICAgYnlwYXNzQXV0aFN0YXRlOiB0aGlzLmJ5cGFzc0F1dGhTdGF0ZVxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5yZXNvbHZlKGF3YWl0IHRoaXMuZ2V0SWRwVGFzayh0eXBlKShwYXJhbXMpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLnJlamVjdChlIGFzIEVycm9yKTtcbiAgICB9XG4gIH1cblxuICBvbkVycm9yKGVycm9yOiBGaXJlYmFzZUVycm9yKTogdm9pZCB7XG4gICAgdGhpcy5yZWplY3QoZXJyb3IpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRJZHBUYXNrKHR5cGU6IEF1dGhFdmVudFR5cGUpOiBJZHBUYXNrIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQXV0aEV2ZW50VHlwZS5TSUdOX0lOX1ZJQV9QT1BVUDpcbiAgICAgIGNhc2UgQXV0aEV2ZW50VHlwZS5TSUdOX0lOX1ZJQV9SRURJUkVDVDpcbiAgICAgICAgcmV0dXJuIF9zaWduSW47XG4gICAgICBjYXNlIEF1dGhFdmVudFR5cGUuTElOS19WSUFfUE9QVVA6XG4gICAgICBjYXNlIEF1dGhFdmVudFR5cGUuTElOS19WSUFfUkVESVJFQ1Q6XG4gICAgICAgIHJldHVybiBfbGluaztcbiAgICAgIGNhc2UgQXV0aEV2ZW50VHlwZS5SRUFVVEhfVklBX1BPUFVQOlxuICAgICAgY2FzZSBBdXRoRXZlbnRUeXBlLlJFQVVUSF9WSUFfUkVESVJFQ1Q6XG4gICAgICAgIHJldHVybiBfcmVhdXRoO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgX2ZhaWwodGhpcy5hdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVzb2x2ZShjcmVkOiBVc2VyQ3JlZGVudGlhbEludGVybmFsIHwgbnVsbCk6IHZvaWQge1xuICAgIGRlYnVnQXNzZXJ0KHRoaXMucGVuZGluZ1Byb21pc2UsICdQZW5kaW5nIHByb21pc2Ugd2FzIG5ldmVyIHNldCcpO1xuICAgIHRoaXMucGVuZGluZ1Byb21pc2UucmVzb2x2ZShjcmVkKTtcbiAgICB0aGlzLnVucmVnaXN0ZXJBbmRDbGVhblVwKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVqZWN0KGVycm9yOiBFcnJvcik6IHZvaWQge1xuICAgIGRlYnVnQXNzZXJ0KHRoaXMucGVuZGluZ1Byb21pc2UsICdQZW5kaW5nIHByb21pc2Ugd2FzIG5ldmVyIHNldCcpO1xuICAgIHRoaXMucGVuZGluZ1Byb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB0aGlzLnVucmVnaXN0ZXJBbmRDbGVhblVwKCk7XG4gIH1cblxuICBwcml2YXRlIHVucmVnaXN0ZXJBbmRDbGVhblVwKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmV2ZW50TWFuYWdlcikge1xuICAgICAgdGhpcy5ldmVudE1hbmFnZXIudW5yZWdpc3RlckNvbnN1bWVyKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ1Byb21pc2UgPSBudWxsO1xuICAgIHRoaXMuY2xlYW5VcCgpO1xuICB9XG5cbiAgYWJzdHJhY3QgY2xlYW5VcCgpOiB2b2lkO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgQXV0aCxcbiAgQXV0aFByb3ZpZGVyLFxuICBQb3B1cFJlZGlyZWN0UmVzb2x2ZXIsXG4gIFVzZXIsXG4gIFVzZXJDcmVkZW50aWFsXG59IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IF9jYXN0QXV0aCB9IGZyb20gJy4uLy4uL2NvcmUvYXV0aC9hdXRoX2ltcGwnO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzJztcbmltcG9ydCB7XG4gIF9hc3NlcnQsXG4gIGRlYnVnQXNzZXJ0LFxuICBfY3JlYXRlRXJyb3IsXG4gIF9hc3NlcnRJbnN0YW5jZU9mXG59IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgRGVsYXkgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvZGVsYXknO1xuaW1wb3J0IHsgX2dlbmVyYXRlRXZlbnRJZCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9ldmVudF9pZCc7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7XG4gIEF1dGhFdmVudFR5cGUsXG4gIFBvcHVwUmVkaXJlY3RSZXNvbHZlckludGVybmFsXG59IGZyb20gJy4uLy4uL21vZGVsL3BvcHVwX3JlZGlyZWN0JztcbmltcG9ydCB7IFVzZXJJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgX3dpdGhEZWZhdWx0UmVzb2x2ZXIgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvcmVzb2x2ZXInO1xuaW1wb3J0IHsgQXV0aFBvcHVwIH0gZnJvbSAnLi4vdXRpbC9wb3B1cCc7XG5pbXBvcnQgeyBBYnN0cmFjdFBvcHVwUmVkaXJlY3RPcGVyYXRpb24gfSBmcm9tICcuLi8uLi9jb3JlL3N0cmF0ZWdpZXMvYWJzdHJhY3RfcG9wdXBfcmVkaXJlY3Rfb3BlcmF0aW9uJztcbmltcG9ydCB7IEZlZGVyYXRlZEF1dGhQcm92aWRlciB9IGZyb20gJy4uLy4uL2NvcmUvcHJvdmlkZXJzL2ZlZGVyYXRlZCc7XG5pbXBvcnQgeyBnZXRNb2R1bGFySW5zdGFuY2UgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbi8qXG4gKiBUaGUgZXZlbnQgdGltZW91dCBpcyB0aGUgc2FtZSBvbiBtb2JpbGUgYW5kIGRlc2t0b3AsIG5vIG5lZWQgZm9yIERlbGF5LiBTZXQgdGhpcyB0byA4cyBzaW5jZVxuICogYmxvY2tpbmcgZnVuY3Rpb25zIGNhbiB0YWtlIHVwdG8gN3MgdG8gY29tcGxldGUgc2lnbiBpbiwgYXMgZG9jdW1lbnRlZCBpbjpcbiAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2Jsb2NraW5nLWZ1bmN0aW9ucyN1bmRlcnN0YW5kaW5nX2Jsb2NraW5nX2Z1bmN0aW9uc1xuICogaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvYXV0aC9leHRlbmQtd2l0aC1ibG9ja2luZy1mdW5jdGlvbnMjdW5kZXJzdGFuZGluZ19ibG9ja2luZ19mdW5jdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gX1RpbWVvdXQge1xuICBBVVRIX0VWRU5UID0gODAwMFxufVxuZXhwb3J0IGNvbnN0IF9QT0xMX1dJTkRPV19DTE9TRV9USU1FT1VUID0gbmV3IERlbGF5KDIwMDAsIDEwMDAwKTtcblxuLyoqXG4gKiBBdXRoZW50aWNhdGVzIGEgRmlyZWJhc2UgY2xpZW50IHVzaW5nIGEgcG9wdXAtYmFzZWQgT0F1dGggYXV0aGVudGljYXRpb24gZmxvdy5cbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgc3VjY2VlZHMsIHJldHVybnMgdGhlIHNpZ25lZCBpbiB1c2VyIGFsb25nIHdpdGggdGhlIHByb3ZpZGVyJ3MgY3JlZGVudGlhbC4gSWYgc2lnbiBpbiB3YXNcbiAqIHVuc3VjY2Vzc2Z1bCwgcmV0dXJucyBhbiBlcnJvciBvYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XG4gKlxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXG4gKiBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIEZhY2Vib29rIEFjY2VzcyBUb2tlbi5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBwcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChhdXRoLCByZXN1bHQpO1xuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIHByb3ZpZGVyIC0gVGhlIHByb3ZpZGVyIHRvIGF1dGhlbnRpY2F0ZS4gVGhlIHByb3ZpZGVyIGhhcyB0byBiZSBhbiB7QGxpbmsgT0F1dGhQcm92aWRlcn0uXG4gKiBOb24tT0F1dGggcHJvdmlkZXJzIGxpa2Uge0BsaW5rIEVtYWlsQXV0aFByb3ZpZGVyfSB3aWxsIHRocm93IGFuIGVycm9yLlxuICogQHBhcmFtIHJlc29sdmVyIC0gQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFBvcHVwUmVkaXJlY3RSZXNvbHZlcn0sIG9wdGlvbmFsXG4gKiBpZiBhbHJlYWR5IHN1cHBsaWVkIHRvIHtAbGluayBpbml0aWFsaXplQXV0aH0gb3IgcHJvdmlkZWQgYnkge0BsaW5rIGdldEF1dGh9LlxuICpcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUG9wdXAoXG4gIGF1dGg6IEF1dGgsXG4gIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gIHJlc29sdmVyPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsPiB7XG4gIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgX2Fzc2VydEluc3RhbmNlT2YoYXV0aCwgcHJvdmlkZXIsIEZlZGVyYXRlZEF1dGhQcm92aWRlcik7XG4gIGNvbnN0IHJlc29sdmVySW50ZXJuYWwgPSBfd2l0aERlZmF1bHRSZXNvbHZlcihhdXRoSW50ZXJuYWwsIHJlc29sdmVyKTtcbiAgY29uc3QgYWN0aW9uID0gbmV3IFBvcHVwT3BlcmF0aW9uKFxuICAgIGF1dGhJbnRlcm5hbCxcbiAgICBBdXRoRXZlbnRUeXBlLlNJR05fSU5fVklBX1BPUFVQLFxuICAgIHByb3ZpZGVyLFxuICAgIHJlc29sdmVySW50ZXJuYWxcbiAgKTtcbiAgcmV0dXJuIGFjdGlvbi5leGVjdXRlTm90TnVsbCgpO1xufVxuXG4vKipcbiAqIFJlYXV0aGVudGljYXRlcyB0aGUgY3VycmVudCB1c2VyIHdpdGggdGhlIHNwZWNpZmllZCB7QGxpbmsgT0F1dGhQcm92aWRlcn0gdXNpbmcgYSBwb3AtdXAgYmFzZWRcbiAqIE9BdXRoIGZsb3cuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHRoZSByZWF1dGhlbnRpY2F0aW9uIGlzIHN1Y2Nlc3NmdWwsIHRoZSByZXR1cm5lZCByZXN1bHQgd2lsbCBjb250YWluIHRoZSB1c2VyIGFuZCB0aGVcbiAqIHByb3ZpZGVyJ3MgY3JlZGVudGlhbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBSZWF1dGhlbnRpY2F0ZSB1c2luZyBhIHBvcHVwLlxuICogYXdhaXQgcmVhdXRoZW50aWNhdGVXaXRoUG9wdXAocmVzdWx0LnVzZXIsIHByb3ZpZGVyKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gcHJvdmlkZXIgLSBUaGUgcHJvdmlkZXIgdG8gYXV0aGVudGljYXRlLiBUaGUgcHJvdmlkZXIgaGFzIHRvIGJlIGFuIHtAbGluayBPQXV0aFByb3ZpZGVyfS5cbiAqIE5vbi1PQXV0aCBwcm92aWRlcnMgbGlrZSB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKiBAcGFyYW0gcmVzb2x2ZXIgLSBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgUG9wdXBSZWRpcmVjdFJlc29sdmVyfSwgb3B0aW9uYWxcbiAqIGlmIGFscmVhZHkgc3VwcGxpZWQgdG8ge0BsaW5rIGluaXRpYWxpemVBdXRofSBvciBwcm92aWRlZCBieSB7QGxpbmsgZ2V0QXV0aH0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhdXRoZW50aWNhdGVXaXRoUG9wdXAoXG4gIHVzZXI6IFVzZXIsXG4gIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gIHJlc29sdmVyPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4pOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsPiB7XG4gIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWw7XG4gIF9hc3NlcnRJbnN0YW5jZU9mKHVzZXJJbnRlcm5hbC5hdXRoLCBwcm92aWRlciwgRmVkZXJhdGVkQXV0aFByb3ZpZGVyKTtcbiAgY29uc3QgcmVzb2x2ZXJJbnRlcm5hbCA9IF93aXRoRGVmYXVsdFJlc29sdmVyKHVzZXJJbnRlcm5hbC5hdXRoLCByZXNvbHZlcik7XG4gIGNvbnN0IGFjdGlvbiA9IG5ldyBQb3B1cE9wZXJhdGlvbihcbiAgICB1c2VySW50ZXJuYWwuYXV0aCxcbiAgICBBdXRoRXZlbnRUeXBlLlJFQVVUSF9WSUFfUE9QVVAsXG4gICAgcHJvdmlkZXIsXG4gICAgcmVzb2x2ZXJJbnRlcm5hbCxcbiAgICB1c2VySW50ZXJuYWxcbiAgKTtcbiAgcmV0dXJuIGFjdGlvbi5leGVjdXRlTm90TnVsbCgpO1xufVxuXG4vKipcbiAqIExpbmtzIHRoZSBhdXRoZW50aWNhdGVkIHByb3ZpZGVyIHRvIHRoZSB1c2VyIGFjY291bnQgdXNpbmcgYSBwb3AtdXAgYmFzZWQgT0F1dGggZmxvdy5cbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgdGhlIGxpbmtpbmcgaXMgc3VjY2Vzc2Z1bCwgdGhlIHJldHVybmVkIHJlc3VsdCB3aWxsIGNvbnRhaW4gdGhlIHVzZXIgYW5kIHRoZSBwcm92aWRlcidzIGNyZWRlbnRpYWwuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIHNvbWUgb3RoZXIgcHJvdmlkZXIuXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpO1xuICogLy8gTGluayB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIGF3YWl0IGxpbmtXaXRoUG9wdXAocmVzdWx0LnVzZXIsIHByb3ZpZGVyKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gcHJvdmlkZXIgLSBUaGUgcHJvdmlkZXIgdG8gYXV0aGVudGljYXRlLiBUaGUgcHJvdmlkZXIgaGFzIHRvIGJlIGFuIHtAbGluayBPQXV0aFByb3ZpZGVyfS5cbiAqIE5vbi1PQXV0aCBwcm92aWRlcnMgbGlrZSB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKiBAcGFyYW0gcmVzb2x2ZXIgLSBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgUG9wdXBSZWRpcmVjdFJlc29sdmVyfSwgb3B0aW9uYWxcbiAqIGlmIGFscmVhZHkgc3VwcGxpZWQgdG8ge0BsaW5rIGluaXRpYWxpemVBdXRofSBvciBwcm92aWRlZCBieSB7QGxpbmsgZ2V0QXV0aH0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbGlua1dpdGhQb3B1cChcbiAgdXNlcjogVXNlcixcbiAgcHJvdmlkZXI6IEF1dGhQcm92aWRlcixcbiAgcmVzb2x2ZXI/OiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJcbik6IFByb21pc2U8VXNlckNyZWRlbnRpYWw+IHtcbiAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpIGFzIFVzZXJJbnRlcm5hbDtcbiAgX2Fzc2VydEluc3RhbmNlT2YodXNlckludGVybmFsLmF1dGgsIHByb3ZpZGVyLCBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIpO1xuICBjb25zdCByZXNvbHZlckludGVybmFsID0gX3dpdGhEZWZhdWx0UmVzb2x2ZXIodXNlckludGVybmFsLmF1dGgsIHJlc29sdmVyKTtcblxuICBjb25zdCBhY3Rpb24gPSBuZXcgUG9wdXBPcGVyYXRpb24oXG4gICAgdXNlckludGVybmFsLmF1dGgsXG4gICAgQXV0aEV2ZW50VHlwZS5MSU5LX1ZJQV9QT1BVUCxcbiAgICBwcm92aWRlcixcbiAgICByZXNvbHZlckludGVybmFsLFxuICAgIHVzZXJJbnRlcm5hbFxuICApO1xuICByZXR1cm4gYWN0aW9uLmV4ZWN1dGVOb3ROdWxsKCk7XG59XG5cbi8qKlxuICogUG9wdXAgZXZlbnQgbWFuYWdlci4gSGFuZGxlcyB0aGUgcG9wdXAncyBlbnRpcmUgbGlmZWN5Y2xlOyBsaXN0ZW5zIHRvIGF1dGhcbiAqIGV2ZW50c1xuICpcbiAqL1xuY2xhc3MgUG9wdXBPcGVyYXRpb24gZXh0ZW5kcyBBYnN0cmFjdFBvcHVwUmVkaXJlY3RPcGVyYXRpb24ge1xuICAvLyBPbmx5IG9uZSBwb3B1cCBpcyBldmVyIHNob3duIGF0IG9uY2UuIFRoZSBsaWZlY3ljbGUgb2YgdGhlIGN1cnJlbnQgcG9wdXBcbiAgLy8gY2FuIGJlIG1hbmFnZWQgLyBjYW5jZWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICBwcml2YXRlIHN0YXRpYyBjdXJyZW50UG9wdXBBY3Rpb246IFBvcHVwT3BlcmF0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgYXV0aFdpbmRvdzogQXV0aFBvcHVwIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcG9sbElkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgZmlsdGVyOiBBdXRoRXZlbnRUeXBlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcHJvdmlkZXI6IEF1dGhQcm92aWRlcixcbiAgICByZXNvbHZlcjogUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWwsXG4gICAgdXNlcj86IFVzZXJJbnRlcm5hbFxuICApIHtcbiAgICBzdXBlcihhdXRoLCBmaWx0ZXIsIHJlc29sdmVyLCB1c2VyKTtcbiAgICBpZiAoUG9wdXBPcGVyYXRpb24uY3VycmVudFBvcHVwQWN0aW9uKSB7XG4gICAgICBQb3B1cE9wZXJhdGlvbi5jdXJyZW50UG9wdXBBY3Rpb24uY2FuY2VsKCk7XG4gICAgfVxuXG4gICAgUG9wdXBPcGVyYXRpb24uY3VycmVudFBvcHVwQWN0aW9uID0gdGhpcztcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGVOb3ROdWxsKCk6IFByb21pc2U8VXNlckNyZWRlbnRpYWw+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGUoKTtcbiAgICBfYXNzZXJ0KHJlc3VsdCwgdGhpcy5hdXRoLCBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgb25FeGVjdXRpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgZGVidWdBc3NlcnQoXG4gICAgICB0aGlzLmZpbHRlci5sZW5ndGggPT09IDEsXG4gICAgICAnUG9wdXAgb3BlcmF0aW9ucyBvbmx5IGhhbmRsZSBvbmUgZXZlbnQnXG4gICAgKTtcbiAgICBjb25zdCBldmVudElkID0gX2dlbmVyYXRlRXZlbnRJZCgpO1xuICAgIHRoaXMuYXV0aFdpbmRvdyA9IGF3YWl0IHRoaXMucmVzb2x2ZXIuX29wZW5Qb3B1cChcbiAgICAgIHRoaXMuYXV0aCxcbiAgICAgIHRoaXMucHJvdmlkZXIsXG4gICAgICB0aGlzLmZpbHRlclswXSwgLy8gVGhlcmUncyBhbHdheXMgb25lLCBzZWUgY29uc3RydWN0b3JcbiAgICAgIGV2ZW50SWRcbiAgICApO1xuICAgIHRoaXMuYXV0aFdpbmRvdy5hc3NvY2lhdGVkRXZlbnQgPSBldmVudElkO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHdlYiBzdG9yYWdlIHN1cHBvcnQgYW5kIG9yaWdpbiB2YWxpZGF0aW9uIF9hZnRlcl8gdGhlIHBvcHVwIGlzXG4gICAgLy8gbG9hZGVkLiBUaGVzZSBvcGVyYXRpb25zIGFyZSBzbG93ICh+MSBzZWNvbmQgb3Igc28pIFJhdGhlciB0aGFuXG4gICAgLy8gd2FpdGluZyBvbiB0aGVtIGJlZm9yZSBvcGVuaW5nIHRoZSB3aW5kb3csIG9wdGltaXN0aWNhbGx5IG9wZW4gdGhlIHBvcHVwXG4gICAgLy8gYW5kIGNoZWNrIGZvciBzdG9yYWdlIHN1cHBvcnQgYXQgdGhlIHNhbWUgdGltZS4gSWYgc3RvcmFnZSBzdXBwb3J0IGlzXG4gICAgLy8gbm90IGF2YWlsYWJsZSwgdGhpcyB3aWxsIGNhdXNlIHRoZSB3aG9sZSB0aGluZyB0byByZWplY3QgcHJvcGVybHkuIEl0XG4gICAgLy8gd2lsbCBhbHNvIGNsb3NlIHRoZSBwb3B1cCwgYnV0IHNpbmNlIHRoZSBwcm9taXNlIGhhcyBhbHJlYWR5IHJlamVjdGVkLFxuICAgIC8vIHRoZSBwb3B1cCBjbG9zZWQgYnkgdXNlciBwb2xsIHdpbGwgcmVqZWN0IGludG8gdGhlIHZvaWQuXG4gICAgdGhpcy5yZXNvbHZlci5fb3JpZ2luVmFsaWRhdGlvbih0aGlzLmF1dGgpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhpcy5yZWplY3QoZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc29sdmVyLl9pc0lmcmFtZVdlYlN0b3JhZ2VTdXBwb3J0ZWQodGhpcy5hdXRoLCBpc1N1cHBvcnRlZCA9PiB7XG4gICAgICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMucmVqZWN0KFxuICAgICAgICAgIF9jcmVhdGVFcnJvcih0aGlzLmF1dGgsIEF1dGhFcnJvckNvZGUuV0VCX1NUT1JBR0VfVU5TVVBQT1JURUQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgdXNlciBjbG9zdXJlLiBOb3RpY2UgdGhpcyBkb2VzICpub3QqIHVzZSBhd2FpdFxuICAgIHRoaXMucG9sbFVzZXJDYW5jZWxsYXRpb24oKTtcbiAgfVxuXG4gIGdldCBldmVudElkKCk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmF1dGhXaW5kb3c/LmFzc29jaWF0ZWRFdmVudCB8fCBudWxsO1xuICB9XG5cbiAgY2FuY2VsKCk6IHZvaWQge1xuICAgIHRoaXMucmVqZWN0KF9jcmVhdGVFcnJvcih0aGlzLmF1dGgsIEF1dGhFcnJvckNvZGUuRVhQSVJFRF9QT1BVUF9SRVFVRVNUKSk7XG4gIH1cblxuICBjbGVhblVwKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmF1dGhXaW5kb3cpIHtcbiAgICAgIHRoaXMuYXV0aFdpbmRvdy5jbG9zZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBvbGxJZCkge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnBvbGxJZCk7XG4gICAgfVxuXG4gICAgdGhpcy5hdXRoV2luZG93ID0gbnVsbDtcbiAgICB0aGlzLnBvbGxJZCA9IG51bGw7XG4gICAgUG9wdXBPcGVyYXRpb24uY3VycmVudFBvcHVwQWN0aW9uID0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgcG9sbFVzZXJDYW5jZWxsYXRpb24oKTogdm9pZCB7XG4gICAgY29uc3QgcG9sbCA9ICgpOiB2b2lkID0+IHtcbiAgICAgIGlmICh0aGlzLmF1dGhXaW5kb3c/LndpbmRvdz8uY2xvc2VkKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZXJlIGlzIHN1ZmZpY2llbnQgdGltZSBmb3Igd2hhdGV2ZXIgYWN0aW9uIHRvXG4gICAgICAgIC8vIGNvbXBsZXRlLiBUaGUgd2luZG93IGNvdWxkIGhhdmUgY2xvc2VkIGJ1dCB0aGUgc2lnbiBpbiBuZXR3b3JrXG4gICAgICAgIC8vIGNhbGwgY291bGQgc3RpbGwgYmUgaW4gZmxpZ2h0LiBUaGlzIGlzIHNwZWNpZmljYWxseSB0cnVlIGZvclxuICAgICAgICAvLyBGaXJlZm94IG9yIGlmIHRoZSBvcGVuZXIgaXMgaW4gYW4gaWZyYW1lLCBpbiB3aGljaCBjYXNlIHRoZSBvYXV0aFxuICAgICAgICAvLyBoZWxwZXIgY2xvc2VzIHRoZSBwb3B1cC5cbiAgICAgICAgdGhpcy5wb2xsSWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wb2xsSWQgPSBudWxsO1xuICAgICAgICAgIHRoaXMucmVqZWN0KFxuICAgICAgICAgICAgX2NyZWF0ZUVycm9yKHRoaXMuYXV0aCwgQXV0aEVycm9yQ29kZS5QT1BVUF9DTE9TRURfQllfVVNFUilcbiAgICAgICAgICApO1xuICAgICAgICB9LCBfVGltZW91dC5BVVRIX0VWRU5UKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvbGxJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KHBvbGwsIF9QT0xMX1dJTkRPV19DTE9TRV9USU1FT1VULmdldCgpKTtcbiAgICB9O1xuXG4gICAgcG9sbCgpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7XG4gIEF1dGhFdmVudCxcbiAgQXV0aEV2ZW50VHlwZSxcbiAgUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWxcbn0gZnJvbSAnLi4vLi4vbW9kZWwvcG9wdXBfcmVkaXJlY3QnO1xuaW1wb3J0IHsgVXNlckNyZWRlbnRpYWxJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL3VzZXInO1xuaW1wb3J0IHsgUGVyc2lzdGVuY2VJbnRlcm5hbCB9IGZyb20gJy4uL3BlcnNpc3RlbmNlJztcbmltcG9ydCB7IF9wZXJzaXN0ZW5jZUtleU5hbWUgfSBmcm9tICcuLi9wZXJzaXN0ZW5jZS9wZXJzaXN0ZW5jZV91c2VyX21hbmFnZXInO1xuaW1wb3J0IHsgX2dldEluc3RhbmNlIH0gZnJvbSAnLi4vdXRpbC9pbnN0YW50aWF0b3InO1xuaW1wb3J0IHsgQWJzdHJhY3RQb3B1cFJlZGlyZWN0T3BlcmF0aW9uIH0gZnJvbSAnLi9hYnN0cmFjdF9wb3B1cF9yZWRpcmVjdF9vcGVyYXRpb24nO1xuXG5jb25zdCBQRU5ESU5HX1JFRElSRUNUX0tFWSA9ICdwZW5kaW5nUmVkaXJlY3QnO1xuXG4vLyBXZSBvbmx5IGdldCBvbmUgcmVkaXJlY3Qgb3V0Y29tZSBmb3IgYW55IG9uZSBhdXRoLCBzbyBqdXN0IHN0b3JlIGl0XG4vLyBpbiBoZXJlLlxuY29uc3QgcmVkaXJlY3RPdXRjb21lTWFwOiBNYXA8XG4gIHN0cmluZyxcbiAgKCkgPT4gUHJvbWlzZTxVc2VyQ3JlZGVudGlhbEludGVybmFsIHwgbnVsbD5cbj4gPSBuZXcgTWFwKCk7XG5cbmV4cG9ydCBjbGFzcyBSZWRpcmVjdEFjdGlvbiBleHRlbmRzIEFic3RyYWN0UG9wdXBSZWRpcmVjdE9wZXJhdGlvbiB7XG4gIGV2ZW50SWQgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICByZXNvbHZlcjogUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWwsXG4gICAgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2VcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICBhdXRoLFxuICAgICAgW1xuICAgICAgICBBdXRoRXZlbnRUeXBlLlNJR05fSU5fVklBX1JFRElSRUNULFxuICAgICAgICBBdXRoRXZlbnRUeXBlLkxJTktfVklBX1JFRElSRUNULFxuICAgICAgICBBdXRoRXZlbnRUeXBlLlJFQVVUSF9WSUFfUkVESVJFQ1QsXG4gICAgICAgIEF1dGhFdmVudFR5cGUuVU5LTk9XTlxuICAgICAgXSxcbiAgICAgIHJlc29sdmVyLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgYnlwYXNzQXV0aFN0YXRlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZXhlY3V0ZSBmdW5jdGlvbjsgaWYgd2UgYWxyZWFkeSBoYXZlIGEgcmVkaXJlY3QgcmVzdWx0LCB0aGVuXG4gICAqIGp1c3QgcmV0dXJuIGl0LlxuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZSgpOiBQcm9taXNlPFVzZXJDcmVkZW50aWFsSW50ZXJuYWwgfCBudWxsPiB7XG4gICAgbGV0IHJlYWR5T3V0Y29tZSA9IHJlZGlyZWN0T3V0Y29tZU1hcC5nZXQodGhpcy5hdXRoLl9rZXkoKSk7XG4gICAgaWYgKCFyZWFkeU91dGNvbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhhc1BlbmRpbmdSZWRpcmVjdCA9IGF3YWl0IF9nZXRBbmRDbGVhclBlbmRpbmdSZWRpcmVjdFN0YXR1cyhcbiAgICAgICAgICB0aGlzLnJlc29sdmVyLFxuICAgICAgICAgIHRoaXMuYXV0aFxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBoYXNQZW5kaW5nUmVkaXJlY3QgPyBhd2FpdCBzdXBlci5leGVjdXRlKCkgOiBudWxsO1xuICAgICAgICByZWFkeU91dGNvbWUgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVhZHlPdXRjb21lID0gKCkgPT4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICB9XG5cbiAgICAgIHJlZGlyZWN0T3V0Y29tZU1hcC5zZXQodGhpcy5hdXRoLl9rZXkoKSwgcmVhZHlPdXRjb21lKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBub3QgYnlwYXNzaW5nIGF1dGggc3RhdGUsIHRoZSByZWFkeSBvdXRjb21lIHNob3VsZCBiZSBzZXQgdG9cbiAgICAvLyBudWxsLlxuICAgIGlmICghdGhpcy5ieXBhc3NBdXRoU3RhdGUpIHtcbiAgICAgIHJlZGlyZWN0T3V0Y29tZU1hcC5zZXQodGhpcy5hdXRoLl9rZXkoKSwgKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG51bGwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVhZHlPdXRjb21lKCk7XG4gIH1cblxuICBhc3luYyBvbkF1dGhFdmVudChldmVudDogQXV0aEV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IEF1dGhFdmVudFR5cGUuU0lHTl9JTl9WSUFfUkVESVJFQ1QpIHtcbiAgICAgIHJldHVybiBzdXBlci5vbkF1dGhFdmVudChldmVudCk7XG4gICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSBBdXRoRXZlbnRUeXBlLlVOS05PV04pIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzZW50aW5lbCB2YWx1ZSBpbmRpY2F0aW5nIHRoZXJlJ3Mgbm8gcGVuZGluZyByZWRpcmVjdFxuICAgICAgdGhpcy5yZXNvbHZlKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5ldmVudElkKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5hdXRoLl9yZWRpcmVjdFVzZXJGb3JJZChldmVudC5ldmVudElkKTtcbiAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIHJldHVybiBzdXBlci5vbkF1dGhFdmVudChldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgb25FeGVjdXRpb24oKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIGNsZWFuVXAoKTogdm9pZCB7fVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX2dldEFuZENsZWFyUGVuZGluZ1JlZGlyZWN0U3RhdHVzKFxuICByZXNvbHZlcjogUG9wdXBSZWRpcmVjdFJlc29sdmVySW50ZXJuYWwsXG4gIGF1dGg6IEF1dGhJbnRlcm5hbFxuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IGtleSA9IHBlbmRpbmdSZWRpcmVjdEtleShhdXRoKTtcbiAgY29uc3QgcGVyc2lzdGVuY2UgPSByZXNvbHZlclBlcnNpc3RlbmNlKHJlc29sdmVyKTtcbiAgaWYgKCEoYXdhaXQgcGVyc2lzdGVuY2UuX2lzQXZhaWxhYmxlKCkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhhc1BlbmRpbmdSZWRpcmVjdCA9IChhd2FpdCBwZXJzaXN0ZW5jZS5fZ2V0KGtleSkpID09PSAndHJ1ZSc7XG4gIGF3YWl0IHBlcnNpc3RlbmNlLl9yZW1vdmUoa2V5KTtcbiAgcmV0dXJuIGhhc1BlbmRpbmdSZWRpcmVjdDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9zZXRQZW5kaW5nUmVkaXJlY3RTdGF0dXMoXG4gIHJlc29sdmVyOiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJJbnRlcm5hbCxcbiAgYXV0aDogQXV0aEludGVybmFsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIHJlc29sdmVyUGVyc2lzdGVuY2UocmVzb2x2ZXIpLl9zZXQocGVuZGluZ1JlZGlyZWN0S2V5KGF1dGgpLCAndHJ1ZScpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2NsZWFyUmVkaXJlY3RPdXRjb21lcygpOiB2b2lkIHtcbiAgcmVkaXJlY3RPdXRjb21lTWFwLmNsZWFyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfb3ZlcnJpZGVSZWRpcmVjdFJlc3VsdChcbiAgYXV0aDogQXV0aEludGVybmFsLFxuICByZXN1bHQ6ICgpID0+IFByb21pc2U8VXNlckNyZWRlbnRpYWxJbnRlcm5hbCB8IG51bGw+XG4pOiB2b2lkIHtcbiAgcmVkaXJlY3RPdXRjb21lTWFwLnNldChhdXRoLl9rZXkoKSwgcmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZXJQZXJzaXN0ZW5jZShcbiAgcmVzb2x2ZXI6IFBvcHVwUmVkaXJlY3RSZXNvbHZlckludGVybmFsXG4pOiBQZXJzaXN0ZW5jZUludGVybmFsIHtcbiAgcmV0dXJuIF9nZXRJbnN0YW5jZShyZXNvbHZlci5fcmVkaXJlY3RQZXJzaXN0ZW5jZSk7XG59XG5cbmZ1bmN0aW9uIHBlbmRpbmdSZWRpcmVjdEtleShhdXRoOiBBdXRoSW50ZXJuYWwpOiBzdHJpbmcge1xuICByZXR1cm4gX3BlcnNpc3RlbmNlS2V5TmFtZShcbiAgICBQRU5ESU5HX1JFRElSRUNUX0tFWSxcbiAgICBhdXRoLmNvbmZpZy5hcGlLZXksXG4gICAgYXV0aC5uYW1lXG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBBdXRoLFxuICBBdXRoUHJvdmlkZXIsXG4gIFBvcHVwUmVkaXJlY3RSZXNvbHZlcixcbiAgVXNlcixcbiAgVXNlckNyZWRlbnRpYWxcbn0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHsgX2Nhc3RBdXRoIH0gZnJvbSAnLi4vLi4vY29yZS9hdXRoL2F1dGhfaW1wbCc7XG5pbXBvcnQgeyBfYXNzZXJ0TGlua2VkU3RhdHVzIH0gZnJvbSAnLi4vLi4vY29yZS91c2VyL2xpbmtfdW5saW5rJztcbmltcG9ydCB7IF9hc3NlcnRJbnN0YW5jZU9mIH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBfZ2VuZXJhdGVFdmVudElkIH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2V2ZW50X2lkJztcbmltcG9ydCB7IEF1dGhFdmVudFR5cGUgfSBmcm9tICcuLi8uLi9tb2RlbC9wb3B1cF9yZWRpcmVjdCc7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IF93aXRoRGVmYXVsdFJlc29sdmVyIH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL3Jlc29sdmVyJztcbmltcG9ydCB7XG4gIFJlZGlyZWN0QWN0aW9uLFxuICBfc2V0UGVuZGluZ1JlZGlyZWN0U3RhdHVzXG59IGZyb20gJy4uLy4uL2NvcmUvc3RyYXRlZ2llcy9yZWRpcmVjdCc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9jb3JlL3Byb3ZpZGVycy9mZWRlcmF0ZWQnO1xuaW1wb3J0IHsgZ2V0TW9kdWxhckluc3RhbmNlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKipcbiAqIEF1dGhlbnRpY2F0ZXMgYSBGaXJlYmFzZSBjbGllbnQgdXNpbmcgYSBmdWxsLXBhZ2UgcmVkaXJlY3QgZmxvdy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVG8gaGFuZGxlIHRoZSByZXN1bHRzIGFuZCBlcnJvcnMgZm9yIHRoaXMgb3BlcmF0aW9uLCByZWZlciB0byB7QGxpbmsgZ2V0UmVkaXJlY3RSZXN1bHR9LlxuICogRm9sbG93IHRoZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvYXV0aC93ZWIvcmVkaXJlY3QtYmVzdC1wcmFjdGljZXNcbiAqIHwgYmVzdCBwcmFjdGljZXN9IHdoZW4gdXNpbmcge0BsaW5rIHNpZ25JbldpdGhSZWRpcmVjdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEZhY2Vib29rQXV0aFByb3ZpZGVyKCk7XG4gKiAvLyBZb3UgY2FuIGFkZCBhZGRpdGlvbmFsIHNjb3BlcyB0byB0aGUgcHJvdmlkZXI6XG4gKiBwcm92aWRlci5hZGRTY29wZSgndXNlcl9iaXJ0aGRheScpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgRmFjZWJvb2sgQWNjZXNzIFRva2VuLlxuICogICBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQoYXV0aCwgcmVzdWx0KTtcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogfVxuICogLy8gQXMgdGhpcyBBUEkgY2FuIGJlIHVzZWQgZm9yIHNpZ24taW4sIGxpbmtpbmcgYW5kIHJlYXV0aGVudGljYXRpb24sXG4gKiAvLyBjaGVjayB0aGUgb3BlcmF0aW9uVHlwZSB0byBkZXRlcm1pbmUgd2hhdCB0cmlnZ2VyZWQgdGhpcyByZWRpcmVjdFxuICogLy8gb3BlcmF0aW9uLlxuICogY29uc3Qgb3BlcmF0aW9uVHlwZSA9IHJlc3VsdC5vcGVyYXRpb25UeXBlO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIHByb3ZpZGVyIC0gVGhlIHByb3ZpZGVyIHRvIGF1dGhlbnRpY2F0ZS4gVGhlIHByb3ZpZGVyIGhhcyB0byBiZSBhbiB7QGxpbmsgT0F1dGhQcm92aWRlcn0uXG4gKiBOb24tT0F1dGggcHJvdmlkZXJzIGxpa2Uge0BsaW5rIEVtYWlsQXV0aFByb3ZpZGVyfSB3aWxsIHRocm93IGFuIGVycm9yLlxuICogQHBhcmFtIHJlc29sdmVyIC0gQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFBvcHVwUmVkaXJlY3RSZXNvbHZlcn0sIG9wdGlvbmFsXG4gKiBpZiBhbHJlYWR5IHN1cHBsaWVkIHRvIHtAbGluayBpbml0aWFsaXplQXV0aH0gb3IgcHJvdmlkZWQgYnkge0BsaW5rIGdldEF1dGh9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25JbldpdGhSZWRpcmVjdChcbiAgYXV0aDogQXV0aCxcbiAgcHJvdmlkZXI6IEF1dGhQcm92aWRlcixcbiAgcmVzb2x2ZXI/OiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJcbik6IFByb21pc2U8bmV2ZXI+IHtcbiAgcmV0dXJuIF9zaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIsIHJlc29sdmVyKSBhcyBQcm9taXNlPG5ldmVyPjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9zaWduSW5XaXRoUmVkaXJlY3QoXG4gIGF1dGg6IEF1dGgsXG4gIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gIHJlc29sdmVyPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4pOiBQcm9taXNlPHZvaWQgfCBuZXZlcj4ge1xuICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gIF9hc3NlcnRJbnN0YW5jZU9mKGF1dGgsIHByb3ZpZGVyLCBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIpO1xuICAvLyBXYWl0IGZvciBhdXRoIGluaXRpYWxpemF0aW9uIHRvIGNvbXBsZXRlLCB0aGlzIHdpbGwgcHJvY2VzcyBwZW5kaW5nIHJlZGlyZWN0cyBhbmQgY2xlYXIgdGhlXG4gIC8vIFBFTkRJTkdfUkVESVJFQ1RfS0VZIGluIHBlcnNpc3RlbmNlLiBUaGlzIHNob3VsZCBiZSBjb21wbGV0ZWQgYmVmb3JlIHN0YXJ0aW5nIGEgbmV3XG4gIC8vIHJlZGlyZWN0IGFuZCBjcmVhdGluZyBhIFBFTkRJTkdfUkVESVJFQ1RfS0VZIGVudHJ5LlxuICBhd2FpdCBhdXRoSW50ZXJuYWwuX2luaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgY29uc3QgcmVzb2x2ZXJJbnRlcm5hbCA9IF93aXRoRGVmYXVsdFJlc29sdmVyKGF1dGhJbnRlcm5hbCwgcmVzb2x2ZXIpO1xuICBhd2FpdCBfc2V0UGVuZGluZ1JlZGlyZWN0U3RhdHVzKHJlc29sdmVySW50ZXJuYWwsIGF1dGhJbnRlcm5hbCk7XG5cbiAgcmV0dXJuIHJlc29sdmVySW50ZXJuYWwuX29wZW5SZWRpcmVjdChcbiAgICBhdXRoSW50ZXJuYWwsXG4gICAgcHJvdmlkZXIsXG4gICAgQXV0aEV2ZW50VHlwZS5TSUdOX0lOX1ZJQV9SRURJUkVDVFxuICApO1xufVxuXG4vKipcbiAqIFJlYXV0aGVudGljYXRlcyB0aGUgY3VycmVudCB1c2VyIHdpdGggdGhlIHNwZWNpZmllZCB7QGxpbmsgT0F1dGhQcm92aWRlcn0gdXNpbmcgYSBmdWxsLXBhZ2UgcmVkaXJlY3QgZmxvdy5cbiAqIEByZW1hcmtzXG4gKiBUbyBoYW5kbGUgdGhlIHJlc3VsdHMgYW5kIGVycm9ycyBmb3IgdGhpcyBvcGVyYXRpb24sIHJlZmVyIHRvIHtAbGluayBnZXRSZWRpcmVjdFJlc3VsdH0uXG4gKiBGb2xsb3cgdGhlIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9hdXRoL3dlYi9yZWRpcmVjdC1iZXN0LXByYWN0aWNlc1xuICogfCBiZXN0IHByYWN0aWNlc30gd2hlbiB1c2luZyB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3R9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBGYWNlYm9va0F1dGhQcm92aWRlcigpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogLy8gUmVhdXRoZW50aWNhdGUgdXNpbmcgYSByZWRpcmVjdC5cbiAqIGF3YWl0IHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0KHJlc3VsdC51c2VyLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgYWdhaW4gdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gcHJvdmlkZXIgLSBUaGUgcHJvdmlkZXIgdG8gYXV0aGVudGljYXRlLiBUaGUgcHJvdmlkZXIgaGFzIHRvIGJlIGFuIHtAbGluayBPQXV0aFByb3ZpZGVyfS5cbiAqIE5vbi1PQXV0aCBwcm92aWRlcnMgbGlrZSB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKiBAcGFyYW0gcmVzb2x2ZXIgLSBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgUG9wdXBSZWRpcmVjdFJlc29sdmVyfSwgb3B0aW9uYWxcbiAqIGlmIGFscmVhZHkgc3VwcGxpZWQgdG8ge0BsaW5rIGluaXRpYWxpemVBdXRofSBvciBwcm92aWRlZCBieSB7QGxpbmsgZ2V0QXV0aH0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3QoXG4gIHVzZXI6IFVzZXIsXG4gIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gIHJlc29sdmVyPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4pOiBQcm9taXNlPG5ldmVyPiB7XG4gIHJldHVybiBfcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3QoXG4gICAgdXNlcixcbiAgICBwcm92aWRlcixcbiAgICByZXNvbHZlclxuICApIGFzIFByb21pc2U8bmV2ZXI+O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9yZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdChcbiAgdXNlcjogVXNlcixcbiAgcHJvdmlkZXI6IEF1dGhQcm92aWRlcixcbiAgcmVzb2x2ZXI/OiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJcbik6IFByb21pc2U8dm9pZCB8IG5ldmVyPiB7XG4gIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSBhcyBVc2VySW50ZXJuYWw7XG4gIF9hc3NlcnRJbnN0YW5jZU9mKHVzZXJJbnRlcm5hbC5hdXRoLCBwcm92aWRlciwgRmVkZXJhdGVkQXV0aFByb3ZpZGVyKTtcbiAgLy8gV2FpdCBmb3IgYXV0aCBpbml0aWFsaXphdGlvbiB0byBjb21wbGV0ZSwgdGhpcyB3aWxsIHByb2Nlc3MgcGVuZGluZyByZWRpcmVjdHMgYW5kIGNsZWFyIHRoZVxuICAvLyBQRU5ESU5HX1JFRElSRUNUX0tFWSBpbiBwZXJzaXN0ZW5jZS4gVGhpcyBzaG91bGQgYmUgY29tcGxldGVkIGJlZm9yZSBzdGFydGluZyBhIG5ld1xuICAvLyByZWRpcmVjdCBhbmQgY3JlYXRpbmcgYSBQRU5ESU5HX1JFRElSRUNUX0tFWSBlbnRyeS5cbiAgYXdhaXQgdXNlckludGVybmFsLmF1dGguX2luaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgLy8gQWxsb3cgdGhlIHJlc29sdmVyIHRvIGVycm9yIGJlZm9yZSBwZXJzaXN0aW5nIHRoZSByZWRpcmVjdCB1c2VyXG4gIGNvbnN0IHJlc29sdmVySW50ZXJuYWwgPSBfd2l0aERlZmF1bHRSZXNvbHZlcih1c2VySW50ZXJuYWwuYXV0aCwgcmVzb2x2ZXIpO1xuICBhd2FpdCBfc2V0UGVuZGluZ1JlZGlyZWN0U3RhdHVzKHJlc29sdmVySW50ZXJuYWwsIHVzZXJJbnRlcm5hbC5hdXRoKTtcblxuICBjb25zdCBldmVudElkID0gYXdhaXQgcHJlcGFyZVVzZXJGb3JSZWRpcmVjdCh1c2VySW50ZXJuYWwpO1xuICByZXR1cm4gcmVzb2x2ZXJJbnRlcm5hbC5fb3BlblJlZGlyZWN0KFxuICAgIHVzZXJJbnRlcm5hbC5hdXRoLFxuICAgIHByb3ZpZGVyLFxuICAgIEF1dGhFdmVudFR5cGUuUkVBVVRIX1ZJQV9SRURJUkVDVCxcbiAgICBldmVudElkXG4gICk7XG59XG5cbi8qKlxuICogTGlua3MgdGhlIHtAbGluayBPQXV0aFByb3ZpZGVyfSB0byB0aGUgdXNlciBhY2NvdW50IHVzaW5nIGEgZnVsbC1wYWdlIHJlZGlyZWN0IGZsb3cuXG4gKiBAcmVtYXJrc1xuICogVG8gaGFuZGxlIHRoZSByZXN1bHRzIGFuZCBlcnJvcnMgZm9yIHRoaXMgb3BlcmF0aW9uLCByZWZlciB0byB7QGxpbmsgZ2V0UmVkaXJlY3RSZXN1bHR9LlxuICogRm9sbG93IHRoZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvYXV0aC93ZWIvcmVkaXJlY3QtYmVzdC1wcmFjdGljZXNcbiAqIHwgYmVzdCBwcmFjdGljZXN9IHdoZW4gdXNpbmcge0BsaW5rIGxpbmtXaXRoUmVkaXJlY3R9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIHNvbWUgb3RoZXIgcHJvdmlkZXIuXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpO1xuICogLy8gTGluayB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIGF3YWl0IGxpbmtXaXRoUmVkaXJlY3QocmVzdWx0LnVzZXIsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBwcm92aWRlciAtIFRoZSBwcm92aWRlciB0byBhdXRoZW50aWNhdGUuIFRoZSBwcm92aWRlciBoYXMgdG8gYmUgYW4ge0BsaW5rIE9BdXRoUHJvdmlkZXJ9LlxuICogTm9uLU9BdXRoIHByb3ZpZGVycyBsaWtlIHtAbGluayBFbWFpbEF1dGhQcm92aWRlcn0gd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqIEBwYXJhbSByZXNvbHZlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJ9LCBvcHRpb25hbFxuICogaWYgYWxyZWFkeSBzdXBwbGllZCB0byB7QGxpbmsgaW5pdGlhbGl6ZUF1dGh9IG9yIHByb3ZpZGVkIGJ5IHtAbGluayBnZXRBdXRofS5cbiAqXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGlua1dpdGhSZWRpcmVjdChcbiAgdXNlcjogVXNlcixcbiAgcHJvdmlkZXI6IEF1dGhQcm92aWRlcixcbiAgcmVzb2x2ZXI/OiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJcbik6IFByb21pc2U8bmV2ZXI+IHtcbiAgcmV0dXJuIF9saW5rV2l0aFJlZGlyZWN0KHVzZXIsIHByb3ZpZGVyLCByZXNvbHZlcikgYXMgUHJvbWlzZTxuZXZlcj47XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX2xpbmtXaXRoUmVkaXJlY3QoXG4gIHVzZXI6IFVzZXIsXG4gIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gIHJlc29sdmVyPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyXG4pOiBQcm9taXNlPHZvaWQgfCBuZXZlcj4ge1xuICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikgYXMgVXNlckludGVybmFsO1xuICBfYXNzZXJ0SW5zdGFuY2VPZih1c2VySW50ZXJuYWwuYXV0aCwgcHJvdmlkZXIsIEZlZGVyYXRlZEF1dGhQcm92aWRlcik7XG4gIC8vIFdhaXQgZm9yIGF1dGggaW5pdGlhbGl6YXRpb24gdG8gY29tcGxldGUsIHRoaXMgd2lsbCBwcm9jZXNzIHBlbmRpbmcgcmVkaXJlY3RzIGFuZCBjbGVhciB0aGVcbiAgLy8gUEVORElOR19SRURJUkVDVF9LRVkgaW4gcGVyc2lzdGVuY2UuIFRoaXMgc2hvdWxkIGJlIGNvbXBsZXRlZCBiZWZvcmUgc3RhcnRpbmcgYSBuZXdcbiAgLy8gcmVkaXJlY3QgYW5kIGNyZWF0aW5nIGEgUEVORElOR19SRURJUkVDVF9LRVkgZW50cnkuXG4gIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gIC8vIEFsbG93IHRoZSByZXNvbHZlciB0byBlcnJvciBiZWZvcmUgcGVyc2lzdGluZyB0aGUgcmVkaXJlY3QgdXNlclxuICBjb25zdCByZXNvbHZlckludGVybmFsID0gX3dpdGhEZWZhdWx0UmVzb2x2ZXIodXNlckludGVybmFsLmF1dGgsIHJlc29sdmVyKTtcbiAgYXdhaXQgX2Fzc2VydExpbmtlZFN0YXR1cyhmYWxzZSwgdXNlckludGVybmFsLCBwcm92aWRlci5wcm92aWRlcklkKTtcbiAgYXdhaXQgX3NldFBlbmRpbmdSZWRpcmVjdFN0YXR1cyhyZXNvbHZlckludGVybmFsLCB1c2VySW50ZXJuYWwuYXV0aCk7XG5cbiAgY29uc3QgZXZlbnRJZCA9IGF3YWl0IHByZXBhcmVVc2VyRm9yUmVkaXJlY3QodXNlckludGVybmFsKTtcbiAgcmV0dXJuIHJlc29sdmVySW50ZXJuYWwuX29wZW5SZWRpcmVjdChcbiAgICB1c2VySW50ZXJuYWwuYXV0aCxcbiAgICBwcm92aWRlcixcbiAgICBBdXRoRXZlbnRUeXBlLkxJTktfVklBX1JFRElSRUNULFxuICAgIGV2ZW50SWRcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfSBmcm9tIHRoZSByZWRpcmVjdC1iYXNlZCBzaWduLWluIGZsb3cuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHNpZ24taW4gc3VjY2VlZGVkLCByZXR1cm5zIHRoZSBzaWduZWQgaW4gdXNlci4gSWYgc2lnbi1pbiB3YXMgdW5zdWNjZXNzZnVsLCBmYWlscyB3aXRoIGFuXG4gKiBlcnJvci4gSWYgbm8gcmVkaXJlY3Qgb3BlcmF0aW9uIHdhcyBjYWxsZWQsIHJldHVybnMgYG51bGxgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBGYWNlYm9va0F1dGhQcm92aWRlcigpO1xuICogLy8gWW91IGNhbiBhZGQgYWRkaXRpb25hbCBzY29wZXMgdG8gdGhlIHByb3ZpZGVyOlxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3VzZXJfYmlydGhkYXknKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGlmIChyZXN1bHQpIHtcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIEZhY2Vib29rIEFjY2VzcyBUb2tlbi5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IHByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KGF1dGgsIHJlc3VsdCk7XG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIH1cbiAqIC8vIEFzIHRoaXMgQVBJIGNhbiBiZSB1c2VkIGZvciBzaWduLWluLCBsaW5raW5nIGFuZCByZWF1dGhlbnRpY2F0aW9uLFxuICogLy8gY2hlY2sgdGhlIG9wZXJhdGlvblR5cGUgdG8gZGV0ZXJtaW5lIHdoYXQgdHJpZ2dlcmVkIHRoaXMgcmVkaXJlY3RcbiAqIC8vIG9wZXJhdGlvbi5cbiAqIGNvbnN0IG9wZXJhdGlvblR5cGUgPSByZXN1bHQub3BlcmF0aW9uVHlwZTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSByZXNvbHZlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJ9LCBvcHRpb25hbFxuICogaWYgYWxyZWFkeSBzdXBwbGllZCB0byB7QGxpbmsgaW5pdGlhbGl6ZUF1dGh9IG9yIHByb3ZpZGVkIGJ5IHtAbGluayBnZXRBdXRofS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWRpcmVjdFJlc3VsdChcbiAgYXV0aDogQXV0aCxcbiAgcmVzb2x2ZXI/OiBQb3B1cFJlZGlyZWN0UmVzb2x2ZXJcbik6IFByb21pc2U8VXNlckNyZWRlbnRpYWwgfCBudWxsPiB7XG4gIGF3YWl0IF9jYXN0QXV0aChhdXRoKS5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICByZXR1cm4gX2dldFJlZGlyZWN0UmVzdWx0KGF1dGgsIHJlc29sdmVyLCBmYWxzZSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfZ2V0UmVkaXJlY3RSZXN1bHQoXG4gIGF1dGg6IEF1dGgsXG4gIHJlc29sdmVyRXh0ZXJuPzogUG9wdXBSZWRpcmVjdFJlc29sdmVyLFxuICBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZVxuKTogUHJvbWlzZTxVc2VyQ3JlZGVudGlhbCB8IG51bGw+IHtcbiAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICBjb25zdCByZXNvbHZlciA9IF93aXRoRGVmYXVsdFJlc29sdmVyKGF1dGhJbnRlcm5hbCwgcmVzb2x2ZXJFeHRlcm4pO1xuICBjb25zdCBhY3Rpb24gPSBuZXcgUmVkaXJlY3RBY3Rpb24oYXV0aEludGVybmFsLCByZXNvbHZlciwgYnlwYXNzQXV0aFN0YXRlKTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aW9uLmV4ZWN1dGUoKTtcblxuICBpZiAocmVzdWx0ICYmICFieXBhc3NBdXRoU3RhdGUpIHtcbiAgICBkZWxldGUgcmVzdWx0LnVzZXIuX3JlZGlyZWN0RXZlbnRJZDtcbiAgICBhd2FpdCBhdXRoSW50ZXJuYWwuX3BlcnNpc3RVc2VySWZDdXJyZW50KHJlc3VsdC51c2VyIGFzIFVzZXJJbnRlcm5hbCk7XG4gICAgYXdhaXQgYXV0aEludGVybmFsLl9zZXRSZWRpcmVjdFVzZXIobnVsbCwgcmVzb2x2ZXJFeHRlcm4pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZVVzZXJGb3JSZWRpcmVjdCh1c2VyOiBVc2VySW50ZXJuYWwpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBldmVudElkID0gX2dlbmVyYXRlRXZlbnRJZChgJHt1c2VyLnVpZH06OjpgKTtcbiAgdXNlci5fcmVkaXJlY3RFdmVudElkID0gZXZlbnRJZDtcbiAgYXdhaXQgdXNlci5hdXRoLl9zZXRSZWRpcmVjdFVzZXIodXNlcik7XG4gIGF3YWl0IHVzZXIuYXV0aC5fcGVyc2lzdFVzZXJJZkN1cnJlbnQodXNlcik7XG4gIHJldHVybiBldmVudElkO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgQXV0aEV2ZW50LFxuICBBdXRoRXZlbnRDb25zdW1lcixcbiAgQXV0aEV2ZW50VHlwZSxcbiAgRXZlbnRNYW5hZ2VyXG59IGZyb20gJy4uLy4uL21vZGVsL3BvcHVwX3JlZGlyZWN0JztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBfY3JlYXRlRXJyb3IgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5cbi8vIFRoZSBhbW91bnQgb2YgdGltZSB0byBzdG9yZSB0aGUgVUlEcyBvZiBzZWVuIGV2ZW50czsgdGhpcyBpc1xuLy8gc2V0IHRvIDEwIG1pbiBieSBkZWZhdWx0XG5jb25zdCBFVkVOVF9EVVBMSUNBVElPTl9DQUNIRV9EVVJBVElPTl9NUyA9IDEwICogNjAgKiAxMDAwO1xuXG5leHBvcnQgY2xhc3MgQXV0aEV2ZW50TWFuYWdlciBpbXBsZW1lbnRzIEV2ZW50TWFuYWdlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2FjaGVkRXZlbnRVaWRzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBjb25zdW1lcnM6IFNldDxBdXRoRXZlbnRDb25zdW1lcj4gPSBuZXcgU2V0KCk7XG4gIHByb3RlY3RlZCBxdWV1ZWRSZWRpcmVjdEV2ZW50OiBBdXRoRXZlbnQgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIGhhc0hhbmRsZWRQb3RlbnRpYWxSZWRpcmVjdCA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RQcm9jZXNzZWRFdmVudFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXV0aDogQXV0aEludGVybmFsKSB7fVxuXG4gIHJlZ2lzdGVyQ29uc3VtZXIoYXV0aEV2ZW50Q29uc3VtZXI6IEF1dGhFdmVudENvbnN1bWVyKTogdm9pZCB7XG4gICAgdGhpcy5jb25zdW1lcnMuYWRkKGF1dGhFdmVudENvbnN1bWVyKTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMucXVldWVkUmVkaXJlY3RFdmVudCAmJlxuICAgICAgdGhpcy5pc0V2ZW50Rm9yQ29uc3VtZXIodGhpcy5xdWV1ZWRSZWRpcmVjdEV2ZW50LCBhdXRoRXZlbnRDb25zdW1lcilcbiAgICApIHtcbiAgICAgIHRoaXMuc2VuZFRvQ29uc3VtZXIodGhpcy5xdWV1ZWRSZWRpcmVjdEV2ZW50LCBhdXRoRXZlbnRDb25zdW1lcik7XG4gICAgICB0aGlzLnNhdmVFdmVudFRvQ2FjaGUodGhpcy5xdWV1ZWRSZWRpcmVjdEV2ZW50KTtcbiAgICAgIHRoaXMucXVldWVkUmVkaXJlY3RFdmVudCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgdW5yZWdpc3RlckNvbnN1bWVyKGF1dGhFdmVudENvbnN1bWVyOiBBdXRoRXZlbnRDb25zdW1lcik6IHZvaWQge1xuICAgIHRoaXMuY29uc3VtZXJzLmRlbGV0ZShhdXRoRXZlbnRDb25zdW1lcik7XG4gIH1cblxuICBvbkV2ZW50KGV2ZW50OiBBdXRoRXZlbnQpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBoYW5kbGVkXG4gICAgaWYgKHRoaXMuaGFzRXZlbnRCZWVuSGFuZGxlZChldmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY29uc3VtZXJzLmZvckVhY2goY29uc3VtZXIgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNFdmVudEZvckNvbnN1bWVyKGV2ZW50LCBjb25zdW1lcikpIHtcbiAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VuZFRvQ29uc3VtZXIoZXZlbnQsIGNvbnN1bWVyKTtcbiAgICAgICAgdGhpcy5zYXZlRXZlbnRUb0NhY2hlKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmhhc0hhbmRsZWRQb3RlbnRpYWxSZWRpcmVjdCB8fCAhaXNSZWRpcmVjdEV2ZW50KGV2ZW50KSkge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBzZWVuIGEgcmVkaXJlY3QgYmVmb3JlLCBvciB0aGlzIGlzIGEgcG9wdXAgZXZlbnQsXG4gICAgICAvLyBiYWlsIG5vd1xuICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5oYXNIYW5kbGVkUG90ZW50aWFsUmVkaXJlY3QgPSB0cnVlO1xuXG4gICAgLy8gSWYgdGhlIHJlZGlyZWN0IHdhc24ndCBoYW5kbGVkLCBoYW5nIG9uIHRvIGl0XG4gICAgaWYgKCFoYW5kbGVkKSB7XG4gICAgICB0aGlzLnF1ZXVlZFJlZGlyZWN0RXZlbnQgPSBldmVudDtcbiAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGVkO1xuICB9XG5cbiAgcHJpdmF0ZSBzZW5kVG9Db25zdW1lcihldmVudDogQXV0aEV2ZW50LCBjb25zdW1lcjogQXV0aEV2ZW50Q29uc3VtZXIpOiB2b2lkIHtcbiAgICBpZiAoZXZlbnQuZXJyb3IgJiYgIWlzTnVsbFJlZGlyZWN0RXZlbnQoZXZlbnQpKSB7XG4gICAgICBjb25zdCBjb2RlID1cbiAgICAgICAgKGV2ZW50LmVycm9yLmNvZGU/LnNwbGl0KCdhdXRoLycpWzFdIGFzIEF1dGhFcnJvckNvZGUpIHx8XG4gICAgICAgIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1I7XG4gICAgICBjb25zdW1lci5vbkVycm9yKF9jcmVhdGVFcnJvcih0aGlzLmF1dGgsIGNvZGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3VtZXIub25BdXRoRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaXNFdmVudEZvckNvbnN1bWVyKFxuICAgIGV2ZW50OiBBdXRoRXZlbnQsXG4gICAgY29uc3VtZXI6IEF1dGhFdmVudENvbnN1bWVyXG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGV2ZW50SWRNYXRjaGVzID1cbiAgICAgIGNvbnN1bWVyLmV2ZW50SWQgPT09IG51bGwgfHxcbiAgICAgICghIWV2ZW50LmV2ZW50SWQgJiYgZXZlbnQuZXZlbnRJZCA9PT0gY29uc3VtZXIuZXZlbnRJZCk7XG4gICAgcmV0dXJuIGNvbnN1bWVyLmZpbHRlci5pbmNsdWRlcyhldmVudC50eXBlKSAmJiBldmVudElkTWF0Y2hlcztcbiAgfVxuXG4gIHByaXZhdGUgaGFzRXZlbnRCZWVuSGFuZGxlZChldmVudDogQXV0aEV2ZW50KTogYm9vbGVhbiB7XG4gICAgaWYgKFxuICAgICAgRGF0ZS5ub3coKSAtIHRoaXMubGFzdFByb2Nlc3NlZEV2ZW50VGltZSA+PVxuICAgICAgRVZFTlRfRFVQTElDQVRJT05fQ0FDSEVfRFVSQVRJT05fTVNcbiAgICApIHtcbiAgICAgIHRoaXMuY2FjaGVkRXZlbnRVaWRzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVkRXZlbnRVaWRzLmhhcyhldmVudFVpZChldmVudCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBzYXZlRXZlbnRUb0NhY2hlKGV2ZW50OiBBdXRoRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLmNhY2hlZEV2ZW50VWlkcy5hZGQoZXZlbnRVaWQoZXZlbnQpKTtcbiAgICB0aGlzLmxhc3RQcm9jZXNzZWRFdmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VWlkKGU6IEF1dGhFdmVudCk6IHN0cmluZyB7XG4gIHJldHVybiBbZS50eXBlLCBlLmV2ZW50SWQsIGUuc2Vzc2lvbklkLCBlLnRlbmFudElkXS5maWx0ZXIodiA9PiB2KS5qb2luKCctJyk7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbFJlZGlyZWN0RXZlbnQoeyB0eXBlLCBlcnJvciB9OiBBdXRoRXZlbnQpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlID09PSBBdXRoRXZlbnRUeXBlLlVOS05PV04gJiZcbiAgICBlcnJvcj8uY29kZSA9PT0gYGF1dGgvJHtBdXRoRXJyb3JDb2RlLk5PX0FVVEhfRVZFTlR9YFxuICApO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0RXZlbnQoZXZlbnQ6IEF1dGhFdmVudCk6IGJvb2xlYW4ge1xuICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlIEF1dGhFdmVudFR5cGUuU0lHTl9JTl9WSUFfUkVESVJFQ1Q6XG4gICAgY2FzZSBBdXRoRXZlbnRUeXBlLkxJTktfVklBX1JFRElSRUNUOlxuICAgIGNhc2UgQXV0aEV2ZW50VHlwZS5SRUFVVEhfVklBX1JFRElSRUNUOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBBdXRoRXZlbnRUeXBlLlVOS05PV046XG4gICAgICByZXR1cm4gaXNOdWxsUmVkaXJlY3RFdmVudChldmVudCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgX3BlcmZvcm1BcGlSZXF1ZXN0LCBFbmRwb2ludCwgSHR0cE1ldGhvZCB9IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IEF1dGggfSBmcm9tICcuLi8uLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdldFByb2plY3RDb25maWdSZXF1ZXN0IHtcbiAgYW5kcm9pZFBhY2thZ2VOYW1lPzogc3RyaW5nO1xuICBpb3NCdW5kbGVJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRQcm9qZWN0Q29uZmlnUmVzcG9uc2Uge1xuICBhdXRob3JpemVkRG9tYWluczogc3RyaW5nW107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfZ2V0UHJvamVjdENvbmZpZyhcbiAgYXV0aDogQXV0aCxcbiAgcmVxdWVzdDogR2V0UHJvamVjdENvbmZpZ1JlcXVlc3QgPSB7fVxuKTogUHJvbWlzZTxHZXRQcm9qZWN0Q29uZmlnUmVzcG9uc2U+IHtcbiAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdDxHZXRQcm9qZWN0Q29uZmlnUmVxdWVzdCwgR2V0UHJvamVjdENvbmZpZ1Jlc3BvbnNlPihcbiAgICBhdXRoLFxuICAgIEh0dHBNZXRob2QuR0VULFxuICAgIEVuZHBvaW50LkdFVF9QUk9KRUNUX0NPTkZJRyxcbiAgICByZXF1ZXN0XG4gICk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBfZ2V0UHJvamVjdENvbmZpZyB9IGZyb20gJy4uLy4uL2FwaS9wcm9qZWN0X2NvbmZpZy9nZXRfcHJvamVjdF9jb25maWcnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IF9mYWlsIH0gZnJvbSAnLi9hc3NlcnQnO1xuaW1wb3J0IHsgX2dldEN1cnJlbnRVcmwgfSBmcm9tICcuL2xvY2F0aW9uJztcblxuY29uc3QgSVBfQUREUkVTU19SRUdFWCA9IC9eXFxkezEsM31cXC5cXGR7MSwzfVxcLlxcZHsxLDN9XFwuXFxkezEsM30kLztcbmNvbnN0IEhUVFBfUkVHRVggPSAvXmh0dHBzPy87XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfdmFsaWRhdGVPcmlnaW4oYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIFNraXAgb3JpZ2luIHZhbGlkYXRpb24gaWYgd2UgYXJlIGluIGFuIGVtdWxhdGVkIGVudmlyb25tZW50XG4gIGlmIChhdXRoLmNvbmZpZy5lbXVsYXRvcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHsgYXV0aG9yaXplZERvbWFpbnMgfSA9IGF3YWl0IF9nZXRQcm9qZWN0Q29uZmlnKGF1dGgpO1xuXG4gIGZvciAoY29uc3QgZG9tYWluIG9mIGF1dGhvcml6ZWREb21haW5zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChtYXRjaERvbWFpbihkb21haW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlcmUncyBhIFVSTCBlcnJvcjsganVzdCBjb250aW51ZSBzZWFyY2hpbmdcbiAgICB9XG4gIH1cblxuICAvLyBJbiB0aGUgb2xkIFNESywgdGhpcyBlcnJvciBhbHNvIHByb3ZpZGVzIGhlbHBmdWwgbWVzc2FnZXMuXG4gIF9mYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PUklHSU4pO1xufVxuXG5mdW5jdGlvbiBtYXRjaERvbWFpbihleHBlY3RlZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGN1cnJlbnRVcmwgPSBfZ2V0Q3VycmVudFVybCgpO1xuICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSB9ID0gbmV3IFVSTChjdXJyZW50VXJsKTtcbiAgaWYgKGV4cGVjdGVkLnN0YXJ0c1dpdGgoJ2Nocm9tZS1leHRlbnNpb246Ly8nKSkge1xuICAgIGNvbnN0IGNlVXJsID0gbmV3IFVSTChleHBlY3RlZCk7XG5cbiAgICBpZiAoY2VVcmwuaG9zdG5hbWUgPT09ICcnICYmIGhvc3RuYW1lID09PSAnJykge1xuICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIHdlJ3JlIG5vdCBwYXJzaW5nIGNocm9tZSBVUkxzIHByb3Blcmx5XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwcm90b2NvbCA9PT0gJ2Nocm9tZS1leHRlbnNpb246JyAmJlxuICAgICAgICBleHBlY3RlZC5yZXBsYWNlKCdjaHJvbWUtZXh0ZW5zaW9uOi8vJywgJycpID09PVxuICAgICAgICAgIGN1cnJlbnRVcmwucmVwbGFjZSgnY2hyb21lLWV4dGVuc2lvbjovLycsICcnKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvdG9jb2wgPT09ICdjaHJvbWUtZXh0ZW5zaW9uOicgJiYgY2VVcmwuaG9zdG5hbWUgPT09IGhvc3RuYW1lO1xuICB9XG5cbiAgaWYgKCFIVFRQX1JFR0VYLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKElQX0FERFJFU1NfUkVHRVgudGVzdChleHBlY3RlZCkpIHtcbiAgICAvLyBUaGUgZG9tYWluIGhhcyB0byBiZSBleGFjdGx5IGVxdWFsIHRvIHRoZSBwYXR0ZXJuLCBhcyBhbiBJUCBkb21haW4gd2lsbFxuICAgIC8vIG9ubHkgY29udGFpbiB0aGUgSVAsIG5vIGV4dHJhIGNoYXJhY3Rlci5cbiAgICByZXR1cm4gaG9zdG5hbWUgPT09IGV4cGVjdGVkO1xuICB9XG5cbiAgLy8gRG90cyBpbiBwYXR0ZXJuIHNob3VsZCBiZSBlc2NhcGVkLlxuICBjb25zdCBlc2NhcGVkRG9tYWluUGF0dGVybiA9IGV4cGVjdGVkLnJlcGxhY2UoL1xcLi9nLCAnXFxcXC4nKTtcbiAgLy8gTm9uIGlwIGFkZHJlc3MgZG9tYWlucy5cbiAgLy8gZG9tYWluLmNvbSA9ICouZG9tYWluLmNvbSBPUiBkb21haW4uY29tXG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChcbiAgICAnXiguK1xcXFwuJyArIGVzY2FwZWREb21haW5QYXR0ZXJuICsgJ3wnICsgZXNjYXBlZERvbWFpblBhdHRlcm4gKyAnKSQnLFxuICAgICdpJ1xuICApO1xuICByZXR1cm4gcmUudGVzdChob3N0bmFtZSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzJztcbmltcG9ydCB7IF9jcmVhdGVFcnJvciB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgRGVsYXkgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvZGVsYXknO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBfd2luZG93IH0gZnJvbSAnLi4vYXV0aF93aW5kb3cnO1xuaW1wb3J0ICogYXMganMgZnJvbSAnLi4vbG9hZF9qcyc7XG5cbmNvbnN0IE5FVFdPUktfVElNRU9VVCA9IG5ldyBEZWxheSgzMDAwMCwgNjAwMDApO1xuXG4vKipcbiAqIFJlc2V0IHVubGFvZGVkIEdBcGkgbW9kdWxlcy4gSWYgZ2FwaS5sb2FkIGZhaWxzIGR1ZSB0byBhIG5ldHdvcmsgZXJyb3IsXG4gKiBpdCB3aWxsIHN0b3Agd29ya2luZyBhZnRlciBhIHJldHJpYWwuIFRoaXMgaXMgYSBoYWNrIHRvIGZpeCB0aGlzIGlzc3VlLlxuICovXG5mdW5jdGlvbiByZXNldFVubG9hZGVkR2FwaU1vZHVsZXMoKTogdm9pZCB7XG4gIC8vIENsZWFyIGxhc3QgZmFpbGVkIGdhcGkubG9hZCBzdGF0ZSB0byBmb3JjZSBuZXh0IGdhcGkubG9hZCB0byBmaXJzdFxuICAvLyBsb2FkIHRoZSBmYWlsZWQgZ2FwaS5pZnJhbWVzIG1vZHVsZS5cbiAgLy8gR2V0IGdhcGl4LmJlYWNvbiBjb250ZXh0LlxuICBjb25zdCBiZWFjb24gPSBfd2luZG93KCkuX19fanNsO1xuICAvLyBHZXQgY3VycmVudCBoaW50LlxuICBpZiAoYmVhY29uPy5IKSB7XG4gICAgLy8gR2V0IGdhcGkgaGludC5cbiAgICBmb3IgKGNvbnN0IGhpbnQgb2YgT2JqZWN0LmtleXMoYmVhY29uLkgpKSB7XG4gICAgICAvLyBSZXF1ZXN0ZWQgbW9kdWxlcy5cbiAgICAgIGJlYWNvbi5IW2hpbnRdLnIgPSBiZWFjb24uSFtoaW50XS5yIHx8IFtdO1xuICAgICAgLy8gTG9hZGVkIG1vZHVsZXMuXG4gICAgICBiZWFjb24uSFtoaW50XS5MID0gYmVhY29uLkhbaGludF0uTCB8fCBbXTtcbiAgICAgIC8vIFNldCByZXF1ZXN0ZWQgbW9kdWxlcyB0byBhIGNvcHkgb2YgdGhlIGxvYWRlZCBtb2R1bGVzLlxuICAgICAgYmVhY29uLkhbaGludF0uciA9IFsuLi5iZWFjb24uSFtoaW50XS5MXTtcbiAgICAgIC8vIENsZWFyIHBlbmRpbmcgY2FsbGJhY2tzLlxuICAgICAgaWYgKGJlYWNvbi5DUCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJlYWNvbi5DUC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIFJlbW92ZSBhbGwgZmFpbGVkIHBlbmRpbmcgY2FsbGJhY2tzLlxuICAgICAgICAgIGJlYWNvbi5DUFtpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9hZEdhcGkoYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxnYXBpLmlmcmFtZXMuQ29udGV4dD4ge1xuICByZXR1cm4gbmV3IFByb21pc2U8Z2FwaS5pZnJhbWVzLkNvbnRleHQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAvLyBGdW5jdGlvbiB0byBydW4gd2hlbiBnYXBpLmxvYWQgaXMgcmVhZHkuXG4gICAgZnVuY3Rpb24gbG9hZEdhcGlJZnJhbWUoKTogdm9pZCB7XG4gICAgICAvLyBUaGUgZGV2ZWxvcGVyIG1heSBoYXZlIHRyaWVkIHRvIHByZXZpb3VzbHkgcnVuIGdhcGkubG9hZCBhbmQgZmFpbGVkLlxuICAgICAgLy8gUnVuIHRoaXMgdG8gZml4IHRoYXQuXG4gICAgICByZXNldFVubG9hZGVkR2FwaU1vZHVsZXMoKTtcbiAgICAgIGdhcGkubG9hZCgnZ2FwaS5pZnJhbWVzJywge1xuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoZ2FwaS5pZnJhbWVzLmdldENvbnRleHQoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9udGltZW91dDogKCkgPT4ge1xuICAgICAgICAgIC8vIFRoZSBhYm92ZSByZXNldCBtYXkgYmUgc3VmZmljaWVudCwgYnV0IGhhdmluZyB0aGlzIHJlc2V0IGFmdGVyXG4gICAgICAgICAgLy8gZmFpbHVyZSBlbnN1cmVzIHRoYXQgaWYgdGhlIGRldmVsb3BlciBjYWxscyBnYXBpLmxvYWQgYWZ0ZXIgdGhlXG4gICAgICAgICAgLy8gY29ubmVjdGlvbiBpcyByZS1lc3RhYmxpc2hlZCBhbmQgYmVmb3JlIGFub3RoZXIgYXR0ZW1wdCB0byBlbWJlZFxuICAgICAgICAgIC8vIHRoZSBpZnJhbWUsIGl0IHdvdWxkIHdvcmsgYW5kIHdvdWxkIG5vdCBiZSBicm9rZW4gYmVjYXVzZSBvZiBvdXJcbiAgICAgICAgICAvLyBmYWlsZWQgYXR0ZW1wdC5cbiAgICAgICAgICAvLyBUaW1lb3V0IHdoZW4gZ2FwaS5pZnJhbWVzLklmcmFtZSBub3QgbG9hZGVkLlxuICAgICAgICAgIHJlc2V0VW5sb2FkZWRHYXBpTW9kdWxlcygpO1xuICAgICAgICAgIHJlamVjdChfY3JlYXRlRXJyb3IoYXV0aCwgQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVvdXQ6IE5FVFdPUktfVElNRU9VVC5nZXQoKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKF93aW5kb3coKS5nYXBpPy5pZnJhbWVzPy5JZnJhbWUpIHtcbiAgICAgIC8vIElmIGdhcGkuaWZyYW1lcy5JZnJhbWUgYXZhaWxhYmxlLCByZXNvbHZlLlxuICAgICAgcmVzb2x2ZShnYXBpLmlmcmFtZXMuZ2V0Q29udGV4dCgpKTtcbiAgICB9IGVsc2UgaWYgKCEhX3dpbmRvdygpLmdhcGk/LmxvYWQpIHtcbiAgICAgIC8vIEdhcGkgbG9hZGVyIHJlYWR5LCBsb2FkIGdhcGkuaWZyYW1lcy5cbiAgICAgIGxvYWRHYXBpSWZyYW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBpZnJhbWUgY2FsbGJhY2sgd2hlbiB0aGlzIGlzIGNhbGxlZCBzbyBhcyBub3QgdG8gb3ZlcndyaXRlXG4gICAgICAvLyBhbnkgcHJldmlvdXMgZGVmaW5lZCBjYWxsYmFjay4gVGhpcyBoYXBwZW5zIGlmIHRoaXMgbWV0aG9kIGlzIGNhbGxlZFxuICAgICAgLy8gbXVsdGlwbGUgdGltZXMgaW4gcGFyYWxsZWwgYW5kIGNvdWxkIHJlc3VsdCBpbiB0aGUgbGF0ZXIgY2FsbGJhY2tcbiAgICAgIC8vIG92ZXJ3cml0aW5nIHRoZSBwcmV2aW91cyBvbmUuIFRoaXMgd291bGQgZW5kIHVwIHdpdGggYSBpZnJhbWVcbiAgICAgIC8vIHRpbWVvdXQuXG4gICAgICBjb25zdCBjYk5hbWUgPSBqcy5fZ2VuZXJhdGVDYWxsYmFja05hbWUoJ2lmcmFtZWZjYicpO1xuICAgICAgLy8gR0FwaSBsb2FkZXIgbm90IGF2YWlsYWJsZSwgZHluYW1pY2FsbHkgbG9hZCBwbGF0Zm9ybS5qcy5cbiAgICAgIF93aW5kb3coKVtjYk5hbWVdID0gKCkgPT4ge1xuICAgICAgICAvLyBHQXBpIGxvYWRlciBzaG91bGQgYmUgcmVhZHkuXG4gICAgICAgIGlmICghIWdhcGkubG9hZCkge1xuICAgICAgICAgIGxvYWRHYXBpSWZyYW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gR2FwaSBsb2FkZXIgZmFpbGVkLCB0aHJvdyBlcnJvci5cbiAgICAgICAgICByZWplY3QoX2NyZWF0ZUVycm9yKGF1dGgsIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy8gTG9hZCBHQXBpIGxvYWRlci5cbiAgICAgIHJldHVybiBqc1xuICAgICAgICAuX2xvYWRKUyhgaHR0cHM6Ly9hcGlzLmdvb2dsZS5jb20vanMvYXBpLmpzP29ubG9hZD0ke2NiTmFtZX1gKVxuICAgICAgICAuY2F0Y2goZSA9PiByZWplY3QoZSkpO1xuICAgIH1cbiAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgIC8vIFJlc2V0IGNhY2hlZCBwcm9taXNlIHRvIGFsbG93IGZvciByZXRyaWFsLlxuICAgIGNhY2hlZEdBcGlMb2FkZXIgPSBudWxsO1xuICAgIHRocm93IGVycm9yO1xuICB9KTtcbn1cblxubGV0IGNhY2hlZEdBcGlMb2FkZXI6IFByb21pc2U8Z2FwaS5pZnJhbWVzLkNvbnRleHQ+IHwgbnVsbCA9IG51bGw7XG5leHBvcnQgZnVuY3Rpb24gX2xvYWRHYXBpKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8Z2FwaS5pZnJhbWVzLkNvbnRleHQ+IHtcbiAgY2FjaGVkR0FwaUxvYWRlciA9IGNhY2hlZEdBcGlMb2FkZXIgfHwgbG9hZEdhcGkoYXV0aCk7XG4gIHJldHVybiBjYWNoZWRHQXBpTG9hZGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Jlc2V0TG9hZGVyKCk6IHZvaWQge1xuICBjYWNoZWRHQXBpTG9hZGVyID0gbnVsbDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBTREtfVkVSU0lPTiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgcXVlcnlzdHJpbmcgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBEZWZhdWx0Q29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vaW50ZXJuYWwnO1xuXG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCwgX2NyZWF0ZUVycm9yIH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBEZWxheSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9kZWxheSc7XG5pbXBvcnQgeyBfZW11bGF0b3JVcmwgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvZW11bGF0b3InO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBfd2luZG93IH0gZnJvbSAnLi4vYXV0aF93aW5kb3cnO1xuaW1wb3J0ICogYXMgZ2FwaUxvYWRlciBmcm9tICcuL2dhcGknO1xuXG5jb25zdCBQSU5HX1RJTUVPVVQgPSBuZXcgRGVsYXkoNTAwMCwgMTUwMDApO1xuY29uc3QgSUZSQU1FX1BBVEggPSAnX18vYXV0aC9pZnJhbWUnO1xuY29uc3QgRU1VTEFURURfSUZSQU1FX1BBVEggPSAnZW11bGF0b3IvYXV0aC9pZnJhbWUnO1xuXG5jb25zdCBJRlJBTUVfQVRUUklCVVRFUyA9IHtcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6ICctMTAwcHgnLFxuICAgIHdpZHRoOiAnMXB4JyxcbiAgICBoZWlnaHQ6ICcxcHgnXG4gIH0sXG4gICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcbiAgdGFiaW5kZXg6ICctMSdcbn07XG5cbi8vIE1hcCBmcm9tIGFwaUhvc3QgdG8gZW5kcG9pbnQgSUQgZm9yIHBhc3NpbmcgaW50byBpZnJhbWUuIEluIGN1cnJlbnQgU0RLLCBhcGlIb3N0IGNhbiBiZSBzZXQgdG9cbi8vIGFueXRoaW5nIChub3QgZnJvbSBhIGxpc3Qgb2YgZW5kcG9pbnRzIHdpdGggSURzIGFzIGluIGxlZ2FjeSksIHNvIHRoaXMgaXMgdGhlIGNsb3Nlc3Qgd2UgY2FuIGdldC5cbmNvbnN0IEVJRF9GUk9NX0FQSUhPU1QgPSBuZXcgTWFwKFtcbiAgW0RlZmF1bHRDb25maWcuQVBJX0hPU1QsICdwJ10sIC8vIHByb2R1Y3Rpb25cbiAgWydzdGFnaW5nLWlkZW50aXR5dG9vbGtpdC5zYW5kYm94Lmdvb2dsZWFwaXMuY29tJywgJ3MnXSwgLy8gc3RhZ2luZ1xuICBbJ3Rlc3QtaWRlbnRpdHl0b29sa2l0LnNhbmRib3guZ29vZ2xlYXBpcy5jb20nLCAndCddIC8vIHRlc3Rcbl0pO1xuXG5mdW5jdGlvbiBnZXRJZnJhbWVVcmwoYXV0aDogQXV0aEludGVybmFsKTogc3RyaW5nIHtcbiAgY29uc3QgY29uZmlnID0gYXV0aC5jb25maWc7XG4gIF9hc3NlcnQoY29uZmlnLmF1dGhEb21haW4sIGF1dGgsIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BVVRIX0RPTUFJTik7XG4gIGNvbnN0IHVybCA9IGNvbmZpZy5lbXVsYXRvclxuICAgID8gX2VtdWxhdG9yVXJsKGNvbmZpZywgRU1VTEFURURfSUZSQU1FX1BBVEgpXG4gICAgOiBgaHR0cHM6Ly8ke2F1dGguY29uZmlnLmF1dGhEb21haW59LyR7SUZSQU1FX1BBVEh9YDtcblxuICBjb25zdCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgYXBpS2V5OiBjb25maWcuYXBpS2V5LFxuICAgIGFwcE5hbWU6IGF1dGgubmFtZSxcbiAgICB2OiBTREtfVkVSU0lPTlxuICB9O1xuICBjb25zdCBlaWQgPSBFSURfRlJPTV9BUElIT1NULmdldChhdXRoLmNvbmZpZy5hcGlIb3N0KTtcbiAgaWYgKGVpZCkge1xuICAgIHBhcmFtcy5laWQgPSBlaWQ7XG4gIH1cbiAgY29uc3QgZnJhbWV3b3JrcyA9IGF1dGguX2dldEZyYW1ld29ya3MoKTtcbiAgaWYgKGZyYW1ld29ya3MubGVuZ3RoKSB7XG4gICAgcGFyYW1zLmZ3ID0gZnJhbWV3b3Jrcy5qb2luKCcsJyk7XG4gIH1cbiAgcmV0dXJuIGAke3VybH0/JHtxdWVyeXN0cmluZyhwYXJhbXMpLnNsaWNlKDEpfWA7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfb3BlbklmcmFtZShcbiAgYXV0aDogQXV0aEludGVybmFsXG4pOiBQcm9taXNlPGdhcGkuaWZyYW1lcy5JZnJhbWU+IHtcbiAgY29uc3QgY29udGV4dCA9IGF3YWl0IGdhcGlMb2FkZXIuX2xvYWRHYXBpKGF1dGgpO1xuICBjb25zdCBnYXBpID0gX3dpbmRvdygpLmdhcGk7XG4gIF9hc3NlcnQoZ2FwaSwgYXV0aCwgQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUik7XG4gIHJldHVybiBjb250ZXh0Lm9wZW4oXG4gICAge1xuICAgICAgd2hlcmU6IGRvY3VtZW50LmJvZHksXG4gICAgICB1cmw6IGdldElmcmFtZVVybChhdXRoKSxcbiAgICAgIG1lc3NhZ2VIYW5kbGVyc0ZpbHRlcjogZ2FwaS5pZnJhbWVzLkNST1NTX09SSUdJTl9JRlJBTUVTX0ZJTFRFUixcbiAgICAgIGF0dHJpYnV0ZXM6IElGUkFNRV9BVFRSSUJVVEVTLFxuICAgICAgZG9udGNsZWFyOiB0cnVlXG4gICAgfSxcbiAgICAoaWZyYW1lOiBnYXBpLmlmcmFtZXMuSWZyYW1lKSA9PlxuICAgICAgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhd2FpdCBpZnJhbWUucmVzdHlsZSh7XG4gICAgICAgICAgLy8gUHJldmVudCBpZnJhbWUgZnJvbSBjbG9zaW5nIG9uIG1vdXNlIG91dC5cbiAgICAgICAgICBzZXRIaWRlT25MZWF2ZTogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbmV0d29ya0Vycm9yID0gX2NyZWF0ZUVycm9yKFxuICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEXG4gICAgICAgICk7XG4gICAgICAgIC8vIENvbmZpcm0gaWZyYW1lIGlzIGNvcnJlY3RseSBsb2FkZWQuXG4gICAgICAgIC8vIFRvIGZhbGxiYWNrIG9uIGZhaWx1cmUsIHNldCBhIHRpbWVvdXQuXG4gICAgICAgIGNvbnN0IG5ldHdvcmtFcnJvclRpbWVyID0gX3dpbmRvdygpLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXR3b3JrRXJyb3IpO1xuICAgICAgICB9LCBQSU5HX1RJTUVPVVQuZ2V0KCkpO1xuICAgICAgICAvLyBDbGVhciB0aW1lciBhbmQgcmVzb2x2ZSBwZW5kaW5nIGlmcmFtZSByZWFkeSBwcm9taXNlLlxuICAgICAgICBmdW5jdGlvbiBjbGVhclRpbWVyQW5kUmVzb2x2ZSgpOiB2b2lkIHtcbiAgICAgICAgICBfd2luZG93KCkuY2xlYXJUaW1lb3V0KG5ldHdvcmtFcnJvclRpbWVyKTtcbiAgICAgICAgICByZXNvbHZlKGlmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyByZXR1cm5zIGFuIElUaGVuYWJsZS4gSG93ZXZlciB0aGUgcmVqZWN0IHBhcnQgZG9lcyBub3QgY2FsbFxuICAgICAgICAvLyB3aGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZC5cbiAgICAgICAgaWZyYW1lLnBpbmcoY2xlYXJUaW1lckFuZFJlc29sdmUpLnRoZW4oY2xlYXJUaW1lckFuZFJlc29sdmUsICgpID0+IHtcbiAgICAgICAgICByZWplY3QobmV0d29ya0Vycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICApO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGdldFVBIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHtcbiAgX2lzQ2hyb21lSU9TLFxuICBfaXNGaXJlZm94LFxuICBfaXNJT1NTdGFuZGFsb25lXG59IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9icm93c2VyJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuXG5jb25zdCBCQVNFX1BPUFVQX09QVElPTlMgPSB7XG4gIGxvY2F0aW9uOiAneWVzJyxcbiAgcmVzaXphYmxlOiAneWVzJyxcbiAgc3RhdHVzYmFyOiAneWVzJyxcbiAgdG9vbGJhcjogJ25vJ1xufTtcblxuY29uc3QgREVGQVVMVF9XSURUSCA9IDUwMDtcbmNvbnN0IERFRkFVTFRfSEVJR0hUID0gNjAwO1xuY29uc3QgVEFSR0VUX0JMQU5LID0gJ19ibGFuayc7XG5cbmNvbnN0IEZJUkVGT1hfRU1QVFlfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3QnO1xuXG5leHBvcnQgY2xhc3MgQXV0aFBvcHVwIHtcbiAgYXNzb2NpYXRlZEV2ZW50OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihyZWFkb25seSB3aW5kb3c6IFdpbmRvdyB8IG51bGwpIHt9XG5cbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMud2luZG93KSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndpbmRvdy5jbG9zZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9vcGVuKFxuICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gIHVybD86IHN0cmluZyxcbiAgbmFtZT86IHN0cmluZyxcbiAgd2lkdGggPSBERUZBVUxUX1dJRFRILFxuICBoZWlnaHQgPSBERUZBVUxUX0hFSUdIVFxuKTogQXV0aFBvcHVwIHtcbiAgY29uc3QgdG9wID0gTWF0aC5tYXgoKHdpbmRvdy5zY3JlZW4uYXZhaWxIZWlnaHQgLSBoZWlnaHQpIC8gMiwgMCkudG9TdHJpbmcoKTtcbiAgY29uc3QgbGVmdCA9IE1hdGgubWF4KCh3aW5kb3cuc2NyZWVuLmF2YWlsV2lkdGggLSB3aWR0aCkgLyAyLCAwKS50b1N0cmluZygpO1xuICBsZXQgdGFyZ2V0ID0gJyc7XG5cbiAgY29uc3Qgb3B0aW9uczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgICAuLi5CQVNFX1BPUFVQX09QVElPTlMsXG4gICAgd2lkdGg6IHdpZHRoLnRvU3RyaW5nKCksXG4gICAgaGVpZ2h0OiBoZWlnaHQudG9TdHJpbmcoKSxcbiAgICB0b3AsXG4gICAgbGVmdFxuICB9O1xuXG4gIC8vIENocm9tZSBpT1MgNyBhbmQgOCBpcyByZXR1cm5pbmcgYW4gdW5kZWZpbmVkIHBvcHVwIHdpbiB3aGVuIHRhcmdldCBpc1xuICAvLyBzcGVjaWZpZWQsIGV2ZW4gdGhvdWdoIHRoZSBwb3B1cCBpcyBub3QgbmVjZXNzYXJpbHkgYmxvY2tlZC5cbiAgY29uc3QgdWEgPSBnZXRVQSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5hbWUpIHtcbiAgICB0YXJnZXQgPSBfaXNDaHJvbWVJT1ModWEpID8gVEFSR0VUX0JMQU5LIDogbmFtZTtcbiAgfVxuXG4gIGlmIChfaXNGaXJlZm94KHVhKSkge1xuICAgIC8vIEZpcmVmb3ggY29tcGxhaW5zIHdoZW4gaW52YWxpZCBVUkxzIGFyZSBwb3BwZWQgb3V0LiBIYWNreSB3YXkgdG8gYnlwYXNzLlxuICAgIHVybCA9IHVybCB8fCBGSVJFRk9YX0VNUFRZX1VSTDtcbiAgICAvLyBGaXJlZm94IGRpc2FibGVzIGJ5IGRlZmF1bHQgc2Nyb2xsaW5nIG9uIHBvcHVwIHdpbmRvd3MsIHdoaWNoIGNhbiBjcmVhdGVcbiAgICAvLyBpc3N1ZXMgd2hlbiB0aGUgdXNlciBoYXMgbWFueSBHb29nbGUgYWNjb3VudHMsIGZvciBpbnN0YW5jZS5cbiAgICBvcHRpb25zLnNjcm9sbGJhcnMgPSAneWVzJztcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnNTdHJpbmcgPSBPYmplY3QuZW50cmllcyhvcHRpb25zKS5yZWR1Y2UoXG4gICAgKGFjY3VtLCBba2V5LCB2YWx1ZV0pID0+IGAke2FjY3VtfSR7a2V5fT0ke3ZhbHVlfSxgLFxuICAgICcnXG4gICk7XG5cbiAgaWYgKF9pc0lPU1N0YW5kYWxvbmUodWEpICYmIHRhcmdldCAhPT0gJ19zZWxmJykge1xuICAgIG9wZW5Bc05ld1dpbmRvd0lPUyh1cmwgfHwgJycsIHRhcmdldCk7XG4gICAgcmV0dXJuIG5ldyBBdXRoUG9wdXAobnVsbCk7XG4gIH1cblxuICAvLyBhYm91dDpibGFuayBnZXR0aW5nIHNhbml0aXplZCBjYXVzaW5nIGJyb3dzZXJzIGxpa2UgSUUvRWRnZSB0byBkaXNwbGF5XG4gIC8vIGJyaWVmIGVycm9yIG1lc3NhZ2UgYmVmb3JlIHJlZGlyZWN0aW5nIHRvIGhhbmRsZXIuXG4gIGNvbnN0IG5ld1dpbiA9IHdpbmRvdy5vcGVuKHVybCB8fCAnJywgdGFyZ2V0LCBvcHRpb25zU3RyaW5nKTtcbiAgX2Fzc2VydChuZXdXaW4sIGF1dGgsIEF1dGhFcnJvckNvZGUuUE9QVVBfQkxPQ0tFRCk7XG5cbiAgLy8gRmxha3kgb24gSUUgZWRnZSwgZW5jYXBzdWxhdGUgd2l0aCBhIHRyeSBhbmQgY2F0Y2guXG4gIHRyeSB7XG4gICAgbmV3V2luLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgcmV0dXJuIG5ldyBBdXRoUG9wdXAobmV3V2luKTtcbn1cblxuZnVuY3Rpb24gb3BlbkFzTmV3V2luZG93SU9TKHVybDogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgZWwuaHJlZiA9IHVybDtcbiAgZWwudGFyZ2V0ID0gdGFyZ2V0O1xuICBjb25zdCBjbGljayA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gIGNsaWNrLmluaXRNb3VzZUV2ZW50KFxuICAgICdjbGljaycsXG4gICAgdHJ1ZSxcbiAgICB0cnVlLFxuICAgIHdpbmRvdyxcbiAgICAxLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgZmFsc2UsXG4gICAgZmFsc2UsXG4gICAgZmFsc2UsXG4gICAgZmFsc2UsXG4gICAgMSxcbiAgICBudWxsXG4gICk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoY2xpY2spO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgU0RLX1ZFUlNJT04gfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IEF1dGhQcm92aWRlciB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBBcGlLZXksIEFwcE5hbWUsIEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHsgQXV0aEV2ZW50VHlwZSB9IGZyb20gJy4uLy4uL21vZGVsL3BvcHVwX3JlZGlyZWN0JztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgX2Fzc2VydCB9IGZyb20gJy4vYXNzZXJ0JztcbmltcG9ydCB7IGlzRW1wdHksIHF1ZXJ5c3RyaW5nIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgX2VtdWxhdG9yVXJsIH0gZnJvbSAnLi9lbXVsYXRvcic7XG5pbXBvcnQgeyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIgfSBmcm9tICcuLi9wcm92aWRlcnMvZmVkZXJhdGVkJztcbmltcG9ydCB7IEJhc2VPQXV0aFByb3ZpZGVyIH0gZnJvbSAnLi4vcHJvdmlkZXJzL29hdXRoJztcblxuLyoqXG4gKiBVUkwgZm9yIEF1dGhlbnRpY2F0aW9uIHdpZGdldCB3aGljaCB3aWxsIGluaXRpYXRlIHRoZSBPQXV0aCBoYW5kc2hha2VcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgV0lER0VUX1BBVEggPSAnX18vYXV0aC9oYW5kbGVyJztcblxuLyoqXG4gKiBVUkwgZm9yIGVtdWxhdGVkIGVudmlyb25tZW50XG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEVNVUxBVE9SX1dJREdFVF9QQVRIID0gJ2VtdWxhdG9yL2F1dGgvaGFuZGxlcic7XG5cbi8qKlxuICogRnJhZ21lbnQgbmFtZSBmb3IgdGhlIEFwcCBDaGVjayB0b2tlbiB0aGF0IGdldHMgcGFzc2VkIHRvIHRoZSB3aWRnZXRcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgRklSRUJBU0VfQVBQX0NIRUNLX0ZSQUdNRU5UX0lEID0gZW5jb2RlVVJJQ29tcG9uZW50KCdmYWMnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtZGVmaW5pdGlvbnNcbnR5cGUgV2lkZ2V0UGFyYW1zID0ge1xuICBhcGlLZXk6IEFwaUtleTtcbiAgYXBwTmFtZTogQXBwTmFtZTtcbiAgYXV0aFR5cGU6IEF1dGhFdmVudFR5cGU7XG4gIHJlZGlyZWN0VXJsPzogc3RyaW5nO1xuICB2OiBzdHJpbmc7XG4gIHByb3ZpZGVySWQ/OiBzdHJpbmc7XG4gIHNjb3Blcz86IHN0cmluZztcbiAgY3VzdG9tUGFyYW1ldGVycz86IHN0cmluZztcbiAgZXZlbnRJZD86IHN0cmluZztcbiAgdGlkPzogc3RyaW5nO1xufSAmIHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfZ2V0UmVkaXJlY3RVcmwoXG4gIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgcHJvdmlkZXI6IEF1dGhQcm92aWRlcixcbiAgYXV0aFR5cGU6IEF1dGhFdmVudFR5cGUsXG4gIHJlZGlyZWN0VXJsPzogc3RyaW5nLFxuICBldmVudElkPzogc3RyaW5nLFxuICBhZGRpdGlvbmFsUGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgX2Fzc2VydChhdXRoLmNvbmZpZy5hdXRoRG9tYWluLCBhdXRoLCBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQVVUSF9ET01BSU4pO1xuICBfYXNzZXJ0KGF1dGguY29uZmlnLmFwaUtleSwgYXV0aCwgQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQSV9LRVkpO1xuXG4gIGNvbnN0IHBhcmFtczogV2lkZ2V0UGFyYW1zID0ge1xuICAgIGFwaUtleTogYXV0aC5jb25maWcuYXBpS2V5LFxuICAgIGFwcE5hbWU6IGF1dGgubmFtZSxcbiAgICBhdXRoVHlwZSxcbiAgICByZWRpcmVjdFVybCxcbiAgICB2OiBTREtfVkVSU0lPTixcbiAgICBldmVudElkXG4gIH07XG5cbiAgaWYgKHByb3ZpZGVyIGluc3RhbmNlb2YgRmVkZXJhdGVkQXV0aFByb3ZpZGVyKSB7XG4gICAgcHJvdmlkZXIuc2V0RGVmYXVsdExhbmd1YWdlKGF1dGgubGFuZ3VhZ2VDb2RlKTtcbiAgICBwYXJhbXMucHJvdmlkZXJJZCA9IHByb3ZpZGVyLnByb3ZpZGVySWQgfHwgJyc7XG4gICAgaWYgKCFpc0VtcHR5KHByb3ZpZGVyLmdldEN1c3RvbVBhcmFtZXRlcnMoKSkpIHtcbiAgICAgIHBhcmFtcy5jdXN0b21QYXJhbWV0ZXJzID0gSlNPTi5zdHJpbmdpZnkocHJvdmlkZXIuZ2V0Q3VzdG9tUGFyYW1ldGVycygpKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIHNldCBhZGRpdGlvbmFsUGFyYW1zIGZyb20gdGhlIHByb3ZpZGVyIGFzIHdlbGw/XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYWRkaXRpb25hbFBhcmFtcyB8fCB7fSkpIHtcbiAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3ZpZGVyIGluc3RhbmNlb2YgQmFzZU9BdXRoUHJvdmlkZXIpIHtcbiAgICBjb25zdCBzY29wZXMgPSBwcm92aWRlci5nZXRTY29wZXMoKS5maWx0ZXIoc2NvcGUgPT4gc2NvcGUgIT09ICcnKTtcbiAgICBpZiAoc2NvcGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcmFtcy5zY29wZXMgPSBzY29wZXMuam9pbignLCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhdXRoLnRlbmFudElkKSB7XG4gICAgcGFyYW1zLnRpZCA9IGF1dGgudGVuYW50SWQ7XG4gIH1cblxuICAvLyBUT0RPOiBtYXliZSBzZXQgZWlkIGFzIGVuZGlwb2ludElkXG4gIC8vIFRPRE86IG1heWJlIHNldCBmdyBhcyBGcmFtZXdvcmtzLmpvaW4oXCIsXCIpXG5cbiAgY29uc3QgcGFyYW1zRGljdCA9IHBhcmFtcyBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXI+O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJhbXNEaWN0KSkge1xuICAgIGlmIChwYXJhbXNEaWN0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIHBhcmFtc0RpY3Rba2V5XTtcbiAgICB9XG4gIH1cblxuICAvLyBTZXRzIHRoZSBBcHAgQ2hlY2sgdG9rZW4gdG8gcGFzcyB0byB0aGUgd2lkZ2V0XG4gIGNvbnN0IGFwcENoZWNrVG9rZW4gPSBhd2FpdCBhdXRoLl9nZXRBcHBDaGVja1Rva2VuKCk7XG4gIGNvbnN0IGFwcENoZWNrVG9rZW5GcmFnbWVudCA9IGFwcENoZWNrVG9rZW5cbiAgICA/IGAjJHtGSVJFQkFTRV9BUFBfQ0hFQ0tfRlJBR01FTlRfSUR9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGFwcENoZWNrVG9rZW4pfWBcbiAgICA6ICcnO1xuXG4gIC8vIFN0YXJ0IGF0IGluZGV4IDEgdG8gc2tpcCB0aGUgbGVhZGluZyAnJicgaW4gdGhlIHF1ZXJ5IHN0cmluZ1xuICByZXR1cm4gYCR7Z2V0SGFuZGxlckJhc2UoYXV0aCl9PyR7cXVlcnlzdHJpbmcocGFyYW1zRGljdCkuc2xpY2UoXG4gICAgMVxuICApfSR7YXBwQ2hlY2tUb2tlbkZyYWdtZW50fWA7XG59XG5cbmZ1bmN0aW9uIGdldEhhbmRsZXJCYXNlKHsgY29uZmlnIH06IEF1dGhJbnRlcm5hbCk6IHN0cmluZyB7XG4gIGlmICghY29uZmlnLmVtdWxhdG9yKSB7XG4gICAgcmV0dXJuIGBodHRwczovLyR7Y29uZmlnLmF1dGhEb21haW59LyR7V0lER0VUX1BBVEh9YDtcbiAgfVxuXG4gIHJldHVybiBfZW11bGF0b3JVcmwoY29uZmlnLCBFTVVMQVRPUl9XSURHRVRfUEFUSCk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBdXRoUHJvdmlkZXIsIFBvcHVwUmVkaXJlY3RSZXNvbHZlciB9IGZyb20gJy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5cbmltcG9ydCB7IEF1dGhFdmVudE1hbmFnZXIgfSBmcm9tICcuLi9jb3JlL2F1dGgvYXV0aF9ldmVudF9tYW5hZ2VyJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi9jb3JlL2Vycm9ycyc7XG5pbXBvcnQgeyBfYXNzZXJ0LCBkZWJ1Z0Fzc2VydCwgX2ZhaWwgfSBmcm9tICcuLi9jb3JlL3V0aWwvYXNzZXJ0JztcbmltcG9ydCB7IF9nZW5lcmF0ZUV2ZW50SWQgfSBmcm9tICcuLi9jb3JlL3V0aWwvZXZlbnRfaWQnO1xuaW1wb3J0IHsgX2dldEN1cnJlbnRVcmwgfSBmcm9tICcuLi9jb3JlL3V0aWwvbG9jYXRpb24nO1xuaW1wb3J0IHsgX3ZhbGlkYXRlT3JpZ2luIH0gZnJvbSAnLi4vY29yZS91dGlsL3ZhbGlkYXRlX29yaWdpbic7XG5pbXBvcnQgeyBBdXRoSW50ZXJuYWwgfSBmcm9tICcuLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7XG4gIEF1dGhFdmVudFR5cGUsXG4gIEV2ZW50TWFuYWdlcixcbiAgR2FwaUF1dGhFdmVudCxcbiAgR2FwaU91dGNvbWUsXG4gIFBvcHVwUmVkaXJlY3RSZXNvbHZlckludGVybmFsXG59IGZyb20gJy4uL21vZGVsL3BvcHVwX3JlZGlyZWN0JztcbmltcG9ydCB7IF9zZXRXaW5kb3dMb2NhdGlvbiB9IGZyb20gJy4vYXV0aF93aW5kb3cnO1xuaW1wb3J0IHsgX29wZW5JZnJhbWUgfSBmcm9tICcuL2lmcmFtZS9pZnJhbWUnO1xuaW1wb3J0IHsgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSB9IGZyb20gJy4vcGVyc2lzdGVuY2Uvc2Vzc2lvbl9zdG9yYWdlJztcbmltcG9ydCB7IF9vcGVuLCBBdXRoUG9wdXAgfSBmcm9tICcuL3V0aWwvcG9wdXAnO1xuaW1wb3J0IHsgX2dldFJlZGlyZWN0UmVzdWx0IH0gZnJvbSAnLi9zdHJhdGVnaWVzL3JlZGlyZWN0JztcbmltcG9ydCB7IF9nZXRSZWRpcmVjdFVybCB9IGZyb20gJy4uL2NvcmUvdXRpbC9oYW5kbGVyJztcbmltcG9ydCB7IF9pc0lPUywgX2lzTW9iaWxlQnJvd3NlciwgX2lzU2FmYXJpIH0gZnJvbSAnLi4vY29yZS91dGlsL2Jyb3dzZXInO1xuaW1wb3J0IHsgX292ZXJyaWRlUmVkaXJlY3RSZXN1bHQgfSBmcm9tICcuLi9jb3JlL3N0cmF0ZWdpZXMvcmVkaXJlY3QnO1xuXG4vKipcbiAqIFRoZSBzcGVjaWFsIHdlYiBzdG9yYWdlIGV2ZW50XG4gKlxuICovXG5jb25zdCBXRUJfU1RPUkFHRV9TVVBQT1JUX0tFWSA9ICd3ZWJTdG9yYWdlU3VwcG9ydCc7XG5cbmludGVyZmFjZSBXZWJTdG9yYWdlU3VwcG9ydE1lc3NhZ2UgZXh0ZW5kcyBnYXBpLmlmcmFtZXMuTWVzc2FnZSB7XG4gIFtpbmRleDogbnVtYmVyXTogUmVjb3JkPHN0cmluZywgYm9vbGVhbj47XG59XG5cbmludGVyZmFjZSBNYW5hZ2VyT3JQcm9taXNlIHtcbiAgbWFuYWdlcj86IEV2ZW50TWFuYWdlcjtcbiAgcHJvbWlzZT86IFByb21pc2U8RXZlbnRNYW5hZ2VyPjtcbn1cblxuY2xhc3MgQnJvd3NlclBvcHVwUmVkaXJlY3RSZXNvbHZlciBpbXBsZW1lbnRzIFBvcHVwUmVkaXJlY3RSZXNvbHZlckludGVybmFsIHtcbiAgcHJpdmF0ZSByZWFkb25seSBldmVudE1hbmFnZXJzOiBSZWNvcmQ8c3RyaW5nLCBNYW5hZ2VyT3JQcm9taXNlPiA9IHt9O1xuICBwcml2YXRlIHJlYWRvbmx5IGlmcmFtZXM6IFJlY29yZDxzdHJpbmcsIGdhcGkuaWZyYW1lcy5JZnJhbWU+ID0ge307XG4gIHByaXZhdGUgcmVhZG9ubHkgb3JpZ2luVmFsaWRhdGlvblByb21pc2VzOiBSZWNvcmQ8c3RyaW5nLCBQcm9taXNlPHZvaWQ+PiA9IHt9O1xuXG4gIHJlYWRvbmx5IF9yZWRpcmVjdFBlcnNpc3RlbmNlID0gYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZTtcblxuICAvLyBXcmFwcGluZyBpbiBhc3luYyBldmVuIHRob3VnaCB3ZSBkb24ndCBhd2FpdCBhbnl3aGVyZSBpbiBvcmRlclxuICAvLyB0byBtYWtlIHN1cmUgZXJyb3JzIGFyZSByYWlzZWQgYXMgcHJvbWlzZSByZWplY3Rpb25zXG4gIGFzeW5jIF9vcGVuUG9wdXAoXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gICAgYXV0aFR5cGU6IEF1dGhFdmVudFR5cGUsXG4gICAgZXZlbnRJZD86IHN0cmluZ1xuICApOiBQcm9taXNlPEF1dGhQb3B1cD4ge1xuICAgIGRlYnVnQXNzZXJ0KFxuICAgICAgdGhpcy5ldmVudE1hbmFnZXJzW2F1dGguX2tleSgpXT8ubWFuYWdlcixcbiAgICAgICdfaW5pdGlhbGl6ZSgpIG5vdCBjYWxsZWQgYmVmb3JlIF9vcGVuUG9wdXAoKSdcbiAgICApO1xuXG4gICAgY29uc3QgdXJsID0gYXdhaXQgX2dldFJlZGlyZWN0VXJsKFxuICAgICAgYXV0aCxcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgYXV0aFR5cGUsXG4gICAgICBfZ2V0Q3VycmVudFVybCgpLFxuICAgICAgZXZlbnRJZFxuICAgICk7XG4gICAgcmV0dXJuIF9vcGVuKGF1dGgsIHVybCwgX2dlbmVyYXRlRXZlbnRJZCgpKTtcbiAgfVxuXG4gIGFzeW5jIF9vcGVuUmVkaXJlY3QoXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIHByb3ZpZGVyOiBBdXRoUHJvdmlkZXIsXG4gICAgYXV0aFR5cGU6IEF1dGhFdmVudFR5cGUsXG4gICAgZXZlbnRJZD86IHN0cmluZ1xuICApOiBQcm9taXNlPG5ldmVyPiB7XG4gICAgYXdhaXQgdGhpcy5fb3JpZ2luVmFsaWRhdGlvbihhdXRoKTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCBfZ2V0UmVkaXJlY3RVcmwoXG4gICAgICBhdXRoLFxuICAgICAgcHJvdmlkZXIsXG4gICAgICBhdXRoVHlwZSxcbiAgICAgIF9nZXRDdXJyZW50VXJsKCksXG4gICAgICBldmVudElkXG4gICAgKTtcbiAgICBfc2V0V2luZG93TG9jYXRpb24odXJsKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pO1xuICB9XG5cbiAgX2luaXRpYWxpemUoYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTxFdmVudE1hbmFnZXI+IHtcbiAgICBjb25zdCBrZXkgPSBhdXRoLl9rZXkoKTtcbiAgICBpZiAodGhpcy5ldmVudE1hbmFnZXJzW2tleV0pIHtcbiAgICAgIGNvbnN0IHsgbWFuYWdlciwgcHJvbWlzZSB9ID0gdGhpcy5ldmVudE1hbmFnZXJzW2tleV07XG4gICAgICBpZiAobWFuYWdlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1hbmFnZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWdBc3NlcnQocHJvbWlzZSwgJ0lmIG1hbmFnZXIgaXMgbm90IHNldCwgcHJvbWlzZSBzaG91bGQgYmUnKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuaW5pdEFuZEdldE1hbmFnZXIoYXV0aCk7XG4gICAgdGhpcy5ldmVudE1hbmFnZXJzW2tleV0gPSB7IHByb21pc2UgfTtcblxuICAgIC8vIElmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLCB0aGUga2V5IHNob3VsZCBiZSByZW1vdmVkIHNvIHRoYXQgdGhlXG4gICAgLy8gb3BlcmF0aW9uIGNhbiBiZSByZXRyaWVkIGxhdGVyLlxuICAgIHByb21pc2UuY2F0Y2goKCkgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRNYW5hZ2Vyc1trZXldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGluaXRBbmRHZXRNYW5hZ2VyKGF1dGg6IEF1dGhJbnRlcm5hbCk6IFByb21pc2U8RXZlbnRNYW5hZ2VyPiB7XG4gICAgY29uc3QgaWZyYW1lID0gYXdhaXQgX29wZW5JZnJhbWUoYXV0aCk7XG4gICAgY29uc3QgbWFuYWdlciA9IG5ldyBBdXRoRXZlbnRNYW5hZ2VyKGF1dGgpO1xuICAgIGlmcmFtZS5yZWdpc3RlcjxHYXBpQXV0aEV2ZW50PihcbiAgICAgICdhdXRoRXZlbnQnLFxuICAgICAgKGlmcmFtZUV2ZW50OiBHYXBpQXV0aEV2ZW50IHwgbnVsbCkgPT4ge1xuICAgICAgICBfYXNzZXJ0KGlmcmFtZUV2ZW50Py5hdXRoRXZlbnQsIGF1dGgsIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIX0VWRU5UKTtcbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgc3BsaXR0aW5nIHJlZGlyZWN0IGFuZCBwb3B1cCBldmVudHMgZWFybGllciBvblxuXG4gICAgICAgIGNvbnN0IGhhbmRsZWQgPSBtYW5hZ2VyLm9uRXZlbnQoaWZyYW1lRXZlbnQuYXV0aEV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBoYW5kbGVkID8gR2FwaU91dGNvbWUuQUNLIDogR2FwaU91dGNvbWUuRVJST1IgfTtcbiAgICAgIH0sXG4gICAgICBnYXBpLmlmcmFtZXMuQ1JPU1NfT1JJR0lOX0lGUkFNRVNfRklMVEVSXG4gICAgKTtcblxuICAgIHRoaXMuZXZlbnRNYW5hZ2Vyc1thdXRoLl9rZXkoKV0gPSB7IG1hbmFnZXIgfTtcbiAgICB0aGlzLmlmcmFtZXNbYXV0aC5fa2V5KCldID0gaWZyYW1lO1xuICAgIHJldHVybiBtYW5hZ2VyO1xuICB9XG5cbiAgX2lzSWZyYW1lV2ViU3RvcmFnZVN1cHBvcnRlZChcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgY2I6IChzdXBwb3J0ZWQ6IGJvb2xlYW4pID0+IHVua25vd25cbiAgKTogdm9pZCB7XG4gICAgY29uc3QgaWZyYW1lID0gdGhpcy5pZnJhbWVzW2F1dGguX2tleSgpXTtcbiAgICBpZnJhbWUuc2VuZDxnYXBpLmlmcmFtZXMuTWVzc2FnZSwgV2ViU3RvcmFnZVN1cHBvcnRNZXNzYWdlPihcbiAgICAgIFdFQl9TVE9SQUdFX1NVUFBPUlRfS0VZLFxuICAgICAgeyB0eXBlOiBXRUJfU1RPUkFHRV9TVVBQT1JUX0tFWSB9LFxuICAgICAgcmVzdWx0ID0+IHtcbiAgICAgICAgY29uc3QgaXNTdXBwb3J0ZWQgPSByZXN1bHQ/LlswXT8uW1dFQl9TVE9SQUdFX1NVUFBPUlRfS0VZXTtcbiAgICAgICAgaWYgKGlzU3VwcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjYighIWlzU3VwcG9ydGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9mYWlsKGF1dGgsIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgICAgfSxcbiAgICAgIGdhcGkuaWZyYW1lcy5DUk9TU19PUklHSU5fSUZSQU1FU19GSUxURVJcbiAgICApO1xuICB9XG5cbiAgX29yaWdpblZhbGlkYXRpb24oYXV0aDogQXV0aEludGVybmFsKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qga2V5ID0gYXV0aC5fa2V5KCk7XG4gICAgaWYgKCF0aGlzLm9yaWdpblZhbGlkYXRpb25Qcm9taXNlc1trZXldKSB7XG4gICAgICB0aGlzLm9yaWdpblZhbGlkYXRpb25Qcm9taXNlc1trZXldID0gX3ZhbGlkYXRlT3JpZ2luKGF1dGgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm9yaWdpblZhbGlkYXRpb25Qcm9taXNlc1trZXldO1xuICB9XG5cbiAgZ2V0IF9zaG91bGRJbml0UHJvYWN0aXZlbHkoKTogYm9vbGVhbiB7XG4gICAgLy8gTW9iaWxlIGJyb3dzZXJzIGFuZCBTYWZhcmkgbmVlZCB0byBvcHRpbWlzdGljYWxseSBpbml0aWFsaXplXG4gICAgcmV0dXJuIF9pc01vYmlsZUJyb3dzZXIoKSB8fCBfaXNTYWZhcmkoKSB8fCBfaXNJT1MoKTtcbiAgfVxuXG4gIF9jb21wbGV0ZVJlZGlyZWN0Rm4gPSBfZ2V0UmVkaXJlY3RSZXN1bHQ7XG5cbiAgX292ZXJyaWRlUmVkaXJlY3RSZXN1bHQgPSBfb3ZlcnJpZGVSZWRpcmVjdFJlc3VsdDtcbn1cblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgUG9wdXBSZWRpcmVjdFJlc29sdmVyfSBzdWl0YWJsZSBmb3IgYnJvd3NlclxuICogYmFzZWQgYXBwbGljYXRpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXI6IFBvcHVwUmVkaXJlY3RSZXNvbHZlciA9XG4gIEJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRmFjdG9ySWQsIE11bHRpRmFjdG9yQXNzZXJ0aW9uIH0gZnJvbSAnLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IGRlYnVnRmFpbCB9IGZyb20gJy4uL2NvcmUvdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbCwgTXVsdGlGYWN0b3JTZXNzaW9uVHlwZSB9IGZyb20gJy4vbWZhX3Nlc3Npb24nO1xuaW1wb3J0IHsgRmluYWxpemVNZmFSZXNwb25zZSB9IGZyb20gJy4uL2FwaS9hdXRoZW50aWNhdGlvbi9tZmEnO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vbW9kZWwvYXV0aCc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwgaW1wbGVtZW50cyBNdWx0aUZhY3RvckFzc2VydGlvbiB7XG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihyZWFkb25seSBmYWN0b3JJZDogRmFjdG9ySWQpIHt9XG5cbiAgX3Byb2Nlc3MoXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIHNlc3Npb246IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwsXG4gICAgZGlzcGxheU5hbWU/OiBzdHJpbmcgfCBudWxsXG4gICk6IFByb21pc2U8RmluYWxpemVNZmFSZXNwb25zZT4ge1xuICAgIHN3aXRjaCAoc2Vzc2lvbi50eXBlKSB7XG4gICAgICBjYXNlIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMOlxuICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVFbnJvbGwoYXV0aCwgc2Vzc2lvbi5jcmVkZW50aWFsLCBkaXNwbGF5TmFtZSk7XG4gICAgICBjYXNlIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuU0lHTl9JTjpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplU2lnbkluKGF1dGgsIHNlc3Npb24uY3JlZGVudGlhbCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGVidWdGYWlsKCd1bmV4cGVjdGVkIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUnKTtcbiAgICB9XG4gIH1cblxuICBhYnN0cmFjdCBfZmluYWxpemVFbnJvbGwoXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGlkVG9rZW46IHN0cmluZyxcbiAgICBkaXNwbGF5TmFtZT86IHN0cmluZyB8IG51bGxcbiAgKTogUHJvbWlzZTxGaW5hbGl6ZU1mYVJlc3BvbnNlPjtcbiAgYWJzdHJhY3QgX2ZpbmFsaXplU2lnbkluKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBtZmFQZW5kaW5nQ3JlZGVudGlhbDogc3RyaW5nXG4gICk6IFByb21pc2U8RmluYWxpemVNZmFSZXNwb25zZT47XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHtcbiAgRmFjdG9ySWQsXG4gIFBob25lTXVsdGlGYWN0b3JBc3NlcnRpb25cbn0gZnJvbSAnLi4vLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcblxuaW1wb3J0IHsgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIH0gZnJvbSAnLi4vLi4vLi4vbWZhL21mYV9hc3NlcnRpb24nO1xuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBmaW5hbGl6ZUVucm9sbFBob25lTWZhIH0gZnJvbSAnLi4vLi4vLi4vYXBpL2FjY291bnRfbWFuYWdlbWVudC9tZmEnO1xuaW1wb3J0IHsgUGhvbmVBdXRoQ3JlZGVudGlhbCB9IGZyb20gJy4uLy4uLy4uL2NvcmUvY3JlZGVudGlhbHMvcGhvbmUnO1xuaW1wb3J0IHtcbiAgZmluYWxpemVTaWduSW5QaG9uZU1mYSxcbiAgRmluYWxpemVNZmFSZXNwb25zZVxufSBmcm9tICcuLi8uLi8uLi9hcGkvYXV0aGVudGljYXRpb24vbWZhJztcblxuLyoqXG4gKiB7QGluaGVyaXRkb2MgUGhvbmVNdWx0aUZhY3RvckFzc2VydGlvbn1cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBQaG9uZU11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbFxuICBleHRlbmRzIE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbFxuICBpbXBsZW1lbnRzIFBob25lTXVsdGlGYWN0b3JBc3NlcnRpb25cbntcbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNyZWRlbnRpYWw6IFBob25lQXV0aENyZWRlbnRpYWwpIHtcbiAgICBzdXBlcihGYWN0b3JJZC5QSE9ORSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZnJvbUNyZWRlbnRpYWwoXG4gICAgY3JlZGVudGlhbDogUGhvbmVBdXRoQ3JlZGVudGlhbFxuICApOiBQaG9uZU11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCB7XG4gICAgcmV0dXJuIG5ldyBQaG9uZU11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbChjcmVkZW50aWFsKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2ZpbmFsaXplRW5yb2xsKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBpZFRva2VuOiBzdHJpbmcsXG4gICAgZGlzcGxheU5hbWU/OiBzdHJpbmcgfCBudWxsXG4gICk6IFByb21pc2U8RmluYWxpemVNZmFSZXNwb25zZT4ge1xuICAgIHJldHVybiBmaW5hbGl6ZUVucm9sbFBob25lTWZhKGF1dGgsIHtcbiAgICAgIGlkVG9rZW4sXG4gICAgICBkaXNwbGF5TmFtZSxcbiAgICAgIHBob25lVmVyaWZpY2F0aW9uSW5mbzogdGhpcy5jcmVkZW50aWFsLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpXG4gICAgfSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9maW5hbGl6ZVNpZ25JbihcbiAgICBhdXRoOiBBdXRoSW50ZXJuYWwsXG4gICAgbWZhUGVuZGluZ0NyZWRlbnRpYWw6IHN0cmluZ1xuICApOiBQcm9taXNlPEZpbmFsaXplTWZhUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gZmluYWxpemVTaWduSW5QaG9uZU1mYShhdXRoLCB7XG4gICAgICBtZmFQZW5kaW5nQ3JlZGVudGlhbCxcbiAgICAgIHBob25lVmVyaWZpY2F0aW9uSW5mbzogdGhpcy5jcmVkZW50aWFsLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhIHtAbGluayBQaG9uZU11bHRpRmFjdG9yQXNzZXJ0aW9ufS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEge0BsaW5rIFBob25lTXVsdGlGYWN0b3JBc3NlcnRpb259IHRvIGNvbmZpcm0gb3duZXJzaGlwIG9mIHRoZSBwaG9uZSBzZWNvbmQgZmFjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gcGhvbmVBdXRoQ3JlZGVudGlhbCAtIEEgY3JlZGVudGlhbCBwcm92aWRlZCBieSB7QGxpbmsgUGhvbmVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbH0uXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIFBob25lTXVsdGlGYWN0b3JBc3NlcnRpb259IHdoaWNoIGNhbiBiZSB1c2VkIHdpdGhcbiAgICoge0BsaW5rIE11bHRpRmFjdG9yUmVzb2x2ZXIucmVzb2x2ZVNpZ25Jbn1cbiAgICovXG4gIHN0YXRpYyBhc3NlcnRpb24oY3JlZGVudGlhbDogUGhvbmVBdXRoQ3JlZGVudGlhbCk6IFBob25lTXVsdGlGYWN0b3JBc3NlcnRpb24ge1xuICAgIHJldHVybiBQaG9uZU11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbC5fZnJvbUNyZWRlbnRpYWwoY3JlZGVudGlhbCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHBob25lIHNlY29uZCBmYWN0b3I6IGBwaG9uZWAuXG4gICAqL1xuICBzdGF0aWMgRkFDVE9SX0lEID0gJ3Bob25lJztcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQge1xuICBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb24sXG4gIE11bHRpRmFjdG9yU2Vzc2lvbixcbiAgRmFjdG9ySWRcbn0gZnJvbSAnLi4vLi4vbW9kZWwvcHVibGljX3R5cGVzJztcbmltcG9ydCB7IEF1dGhJbnRlcm5hbCB9IGZyb20gJy4uLy4uL21vZGVsL2F1dGgnO1xuaW1wb3J0IHtcbiAgZmluYWxpemVFbnJvbGxUb3RwTWZhLFxuICBzdGFydEVucm9sbFRvdHBNZmEsXG4gIFN0YXJ0VG90cE1mYUVucm9sbG1lbnRSZXNwb25zZSxcbiAgVG90cFZlcmlmaWNhdGlvbkluZm9cbn0gZnJvbSAnLi4vLi4vYXBpL2FjY291bnRfbWFuYWdlbWVudC9tZmEnO1xuaW1wb3J0IHtcbiAgRmluYWxpemVNZmFSZXNwb25zZSxcbiAgZmluYWxpemVTaWduSW5Ub3RwTWZhXG59IGZyb20gJy4uLy4uL2FwaS9hdXRoZW50aWNhdGlvbi9tZmEnO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIH0gZnJvbSAnLi4vLi4vbWZhL21mYV9hc3NlcnRpb24nO1xuaW1wb3J0IHsgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbCB9IGZyb20gJy4uL21mYV9zZXNzaW9uJztcbmltcG9ydCB7IEF1dGhFcnJvckNvZGUgfSBmcm9tICcuLi8uLi9jb3JlL2Vycm9ycyc7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2Fzc2VydCc7XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBUb3RwTXVsdGlGYWN0b3JHZW5lcmF0b3Ige1xuICAvKipcbiAgICogUHJvdmlkZXMgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB0byBjb25maXJtIG93bmVyc2hpcCBvZlxuICAgKiB0aGUgVE9UUCAodGltZS1iYXNlZCBvbmUtdGltZSBwYXNzd29yZCkgc2Vjb25kIGZhY3Rvci5cbiAgICogVGhpcyBhc3NlcnRpb24gaXMgdXNlZCB0byBjb21wbGV0ZSBlbnJvbGxtZW50IGluIFRPVFAgc2Vjb25kIGZhY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHNlY3JldCBBIHtAbGluayBUb3RwU2VjcmV0fSBjb250YWluaW5nIHRoZSBzaGFyZWQgc2VjcmV0IGtleSBhbmQgb3RoZXIgVE9UUCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0gb25lVGltZVBhc3N3b3JkIE9uZS10aW1lIHBhc3N3b3JkIGZyb20gVE9UUCBBcHAuXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gd2hpY2ggY2FuIGJlIHVzZWQgd2l0aFxuICAgKiB7QGxpbmsgTXVsdGlGYWN0b3JVc2VyLmVucm9sbH0uXG4gICAqL1xuICBzdGF0aWMgYXNzZXJ0aW9uRm9yRW5yb2xsbWVudChcbiAgICBzZWNyZXQ6IFRvdHBTZWNyZXQsXG4gICAgb25lVGltZVBhc3N3b3JkOiBzdHJpbmdcbiAgKTogVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uIHtcbiAgICByZXR1cm4gVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbC5fZnJvbVNlY3JldChzZWNyZXQsIG9uZVRpbWVQYXNzd29yZCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZXMgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB0byBjb25maXJtIG93bmVyc2hpcCBvZiB0aGUgVE9UUCBzZWNvbmQgZmFjdG9yLlxuICAgKiBUaGlzIGFzc2VydGlvbiBpcyB1c2VkIHRvIGNvbXBsZXRlIHNpZ25JbiB3aXRoIFRPVFAgYXMgdGhlIHNlY29uZCBmYWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBlbnJvbGxtZW50SWQgaWRlbnRpZmllcyB0aGUgZW5yb2xsZWQgVE9UUCBzZWNvbmQgZmFjdG9yLlxuICAgKiBAcGFyYW0gb25lVGltZVBhc3N3b3JkIE9uZS10aW1lIHBhc3N3b3JkIGZyb20gVE9UUCBBcHAuXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gd2hpY2ggY2FuIGJlIHVzZWQgd2l0aFxuICAgKiB7QGxpbmsgTXVsdGlGYWN0b3JSZXNvbHZlci5yZXNvbHZlU2lnbklufS5cbiAgICovXG4gIHN0YXRpYyBhc3NlcnRpb25Gb3JTaWduSW4oXG4gICAgZW5yb2xsbWVudElkOiBzdHJpbmcsXG4gICAgb25lVGltZVBhc3N3b3JkOiBzdHJpbmdcbiAgKTogVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uIHtcbiAgICByZXR1cm4gVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbC5fZnJvbUVucm9sbG1lbnRJZChcbiAgICAgIGVucm9sbG1lbnRJZCxcbiAgICAgIG9uZVRpbWVQYXNzd29yZFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdG8ge0BsaW5rIFRvdHBTZWNyZXR9IHdoaWNoIGNvbnRhaW5zIHRoZSBUT1RQIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBvdGhlciBwYXJhbWV0ZXJzLlxuICAgKiBDcmVhdGVzIGEgVE9UUCBzZWNyZXQgYXMgcGFydCBvZiBlbnJvbGxpbmcgYSBUT1RQIHNlY29uZCBmYWN0b3IuXG4gICAqIFVzZWQgZm9yIGdlbmVyYXRpbmcgYSBRUiBjb2RlIFVSTCBvciBpbnB1dHRpbmcgaW50byBhIFRPVFAgYXBwLlxuICAgKiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBhdXRoIGluc3RhbmNlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHVzZXIgaW4gdGhlIG11bHRpRmFjdG9yU2Vzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHNlc3Npb24gVGhlIHtAbGluayBNdWx0aUZhY3RvclNlc3Npb259IHRoYXQgdGhlIHVzZXIgaXMgcGFydCBvZi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRvIHtAbGluayBUb3RwU2VjcmV0fS5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZW5lcmF0ZVNlY3JldChcbiAgICBzZXNzaW9uOiBNdWx0aUZhY3RvclNlc3Npb25cbiAgKTogUHJvbWlzZTxUb3RwU2VjcmV0PiB7XG4gICAgY29uc3QgbWZhU2Vzc2lvbiA9IHNlc3Npb24gYXMgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbDtcbiAgICBfYXNzZXJ0KFxuICAgICAgdHlwZW9mIG1mYVNlc3Npb24uYXV0aCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgICBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SXG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN0YXJ0RW5yb2xsVG90cE1mYShtZmFTZXNzaW9uLmF1dGgsIHtcbiAgICAgIGlkVG9rZW46IG1mYVNlc3Npb24uY3JlZGVudGlhbCxcbiAgICAgIHRvdHBFbnJvbGxtZW50SW5mbzoge31cbiAgICB9KTtcbiAgICByZXR1cm4gVG90cFNlY3JldC5fZnJvbVN0YXJ0VG90cE1mYUVucm9sbG1lbnRSZXNwb25zZShcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgbWZhU2Vzc2lvbi5hdXRoXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgVE9UUCBzZWNvbmQgZmFjdG9yOiBgdG90cGAuXG4gICAqL1xuICBzdGF0aWMgRkFDVE9SX0lEOiAndG90cCcgPSBGYWN0b3JJZC5UT1RQO1xufVxuXG5leHBvcnQgY2xhc3MgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbFxuICBleHRlbmRzIE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbFxuICBpbXBsZW1lbnRzIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvblxue1xuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBvdHA6IHN0cmluZyxcbiAgICByZWFkb25seSBlbnJvbGxtZW50SWQ/OiBzdHJpbmcsXG4gICAgcmVhZG9ubHkgc2VjcmV0PzogVG90cFNlY3JldFxuICApIHtcbiAgICBzdXBlcihGYWN0b3JJZC5UT1RQKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9mcm9tU2VjcmV0KFxuICAgIHNlY3JldDogVG90cFNlY3JldCxcbiAgICBvdHA6IHN0cmluZ1xuICApOiBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIHtcbiAgICByZXR1cm4gbmV3IFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwob3RwLCB1bmRlZmluZWQsIHNlY3JldCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZnJvbUVucm9sbG1lbnRJZChcbiAgICBlbnJvbGxtZW50SWQ6IHN0cmluZyxcbiAgICBvdHA6IHN0cmluZ1xuICApOiBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIHtcbiAgICByZXR1cm4gbmV3IFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwob3RwLCBlbnJvbGxtZW50SWQpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBfZmluYWxpemVFbnJvbGwoXG4gICAgYXV0aDogQXV0aEludGVybmFsLFxuICAgIGlkVG9rZW46IHN0cmluZyxcbiAgICBkaXNwbGF5TmFtZT86IHN0cmluZyB8IG51bGxcbiAgKTogUHJvbWlzZTxGaW5hbGl6ZU1mYVJlc3BvbnNlPiB7XG4gICAgX2Fzc2VydChcbiAgICAgIHR5cGVvZiB0aGlzLnNlY3JldCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgICBhdXRoLFxuICAgICAgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUlxuICAgICk7XG4gICAgcmV0dXJuIGZpbmFsaXplRW5yb2xsVG90cE1mYShhdXRoLCB7XG4gICAgICBpZFRva2VuLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICB0b3RwVmVyaWZpY2F0aW9uSW5mbzogdGhpcy5zZWNyZXQuX21ha2VUb3RwVmVyaWZpY2F0aW9uSW5mbyh0aGlzLm90cClcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgX2ZpbmFsaXplU2lnbkluKFxuICAgIGF1dGg6IEF1dGhJbnRlcm5hbCxcbiAgICBtZmFQZW5kaW5nQ3JlZGVudGlhbDogc3RyaW5nXG4gICk6IFByb21pc2U8RmluYWxpemVNZmFSZXNwb25zZT4ge1xuICAgIF9hc3NlcnQoXG4gICAgICB0aGlzLmVucm9sbG1lbnRJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3RwICE9PSB1bmRlZmluZWQsXG4gICAgICBhdXRoLFxuICAgICAgQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUlxuICAgICk7XG4gICAgY29uc3QgdG90cFZlcmlmaWNhdGlvbkluZm8gPSB7IHZlcmlmaWNhdGlvbkNvZGU6IHRoaXMub3RwIH07XG4gICAgcmV0dXJuIGZpbmFsaXplU2lnbkluVG90cE1mYShhdXRoLCB7XG4gICAgICBtZmFQZW5kaW5nQ3JlZGVudGlhbCxcbiAgICAgIG1mYUVucm9sbG1lbnRJZDogdGhpcy5lbnJvbGxtZW50SWQsXG4gICAgICB0b3RwVmVyaWZpY2F0aW9uSW5mb1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufS5cbiAqXG4gKiBTdG9yZXMgdGhlIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBvdGhlciBwYXJhbWV0ZXJzIHRvIGdlbmVyYXRlIHRpbWUtYmFzZWQgT1RQcy5cbiAqIEltcGxlbWVudHMgbWV0aG9kcyB0byByZXRyaWV2ZSB0aGUgc2hhcmVkIHNlY3JldCBrZXkgYW5kIGdlbmVyYXRlIGEgUVIgY29kZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBUb3RwU2VjcmV0IHtcbiAgLyoqXG4gICAqIFNoYXJlZCBzZWNyZXQga2V5L3NlZWQgdXNlZCBmb3IgZW5yb2xsaW5nIGluIFRPVFAgTUZBIGFuZCBnZW5lcmF0aW5nIE9UUHMuXG4gICAqL1xuICByZWFkb25seSBzZWNyZXRLZXk6IHN0cmluZztcbiAgLyoqXG4gICAqIEhhc2hpbmcgYWxnb3JpdGhtIHVzZWQuXG4gICAqL1xuICByZWFkb25seSBoYXNoaW5nQWxnb3JpdGhtOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBMZW5ndGggb2YgdGhlIG9uZS10aW1lIHBhc3N3b3JkcyB0byBiZSBnZW5lcmF0ZWQuXG4gICAqL1xuICByZWFkb25seSBjb2RlTGVuZ3RoOiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgaW50ZXJ2YWwgKGluIHNlY29uZHMpIHdoZW4gdGhlIE9UUCBjb2RlcyBzaG91bGQgY2hhbmdlLlxuICAgKi9cbiAgcmVhZG9ubHkgY29kZUludGVydmFsU2Vjb25kczogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHRpbWVzdGFtcCAoVVRDIHN0cmluZykgYnkgd2hpY2ggVE9UUCBlbnJvbGxtZW50IHNob3VsZCBiZSBjb21wbGV0ZWQuXG4gICAqL1xuICAvLyBUaGlzIGNhbiBiZSB1c2VkIGJ5IGNhbGxlcnMgdG8gc2hvdyBhIGNvdW50ZG93biBvZiB3aGVuIHRvIGVudGVyIE9UUCBjb2RlIGJ5LlxuICByZWFkb25seSBlbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lOiBzdHJpbmc7XG5cbiAgLy8gVGhlIHB1YmxpYyBtZW1iZXJzIGFyZSBkZWNsYXJlZCBvdXRzaWRlIHRoZSBjb25zdHJ1Y3RvciBzbyB0aGUgZG9jcyBjYW4gYmUgZ2VuZXJhdGVkLlxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHNlY3JldEtleTogc3RyaW5nLFxuICAgIGhhc2hpbmdBbGdvcml0aG06IHN0cmluZyxcbiAgICBjb2RlTGVuZ3RoOiBudW1iZXIsXG4gICAgY29kZUludGVydmFsU2Vjb25kczogbnVtYmVyLFxuICAgIGVucm9sbG1lbnRDb21wbGV0aW9uRGVhZGxpbmU6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNlc3Npb25JbmZvOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBhdXRoOiBBdXRoSW50ZXJuYWxcbiAgKSB7XG4gICAgdGhpcy5zZWNyZXRLZXkgPSBzZWNyZXRLZXk7XG4gICAgdGhpcy5oYXNoaW5nQWxnb3JpdGhtID0gaGFzaGluZ0FsZ29yaXRobTtcbiAgICB0aGlzLmNvZGVMZW5ndGggPSBjb2RlTGVuZ3RoO1xuICAgIHRoaXMuY29kZUludGVydmFsU2Vjb25kcyA9IGNvZGVJbnRlcnZhbFNlY29uZHM7XG4gICAgdGhpcy5lbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lID0gZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9mcm9tU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlKFxuICAgIHJlc3BvbnNlOiBTdGFydFRvdHBNZmFFbnJvbGxtZW50UmVzcG9uc2UsXG4gICAgYXV0aDogQXV0aEludGVybmFsXG4gICk6IFRvdHBTZWNyZXQge1xuICAgIHJldHVybiBuZXcgVG90cFNlY3JldChcbiAgICAgIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5zaGFyZWRTZWNyZXRLZXksXG4gICAgICByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uaGFzaGluZ0FsZ29yaXRobSxcbiAgICAgIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby52ZXJpZmljYXRpb25Db2RlTGVuZ3RoLFxuICAgICAgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLnBlcmlvZFNlYyxcbiAgICAgIG5ldyBEYXRlKHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5maW5hbGl6ZUVucm9sbG1lbnRUaW1lKS50b1VUQ1N0cmluZygpLFxuICAgICAgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLnNlc3Npb25JbmZvLFxuICAgICAgYXV0aFxuICAgICk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9tYWtlVG90cFZlcmlmaWNhdGlvbkluZm8ob3RwOiBzdHJpbmcpOiBUb3RwVmVyaWZpY2F0aW9uSW5mbyB7XG4gICAgcmV0dXJuIHsgc2Vzc2lvbkluZm86IHRoaXMuc2Vzc2lvbkluZm8sIHZlcmlmaWNhdGlvbkNvZGU6IG90cCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBRUiBjb2RlIFVSTCBhcyBkZXNjcmliZWQgaW5cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9nb29nbGUtYXV0aGVudGljYXRvci93aWtpL0tleS1VcmktRm9ybWF0XG4gICAqIFRoaXMgY2FuIGJlIGRpc3BsYXllZCB0byB0aGUgdXNlciBhcyBhIFFSIGNvZGUgdG8gYmUgc2Nhbm5lZCBpbnRvIGEgVE9UUCBhcHAgbGlrZSBHb29nbGUgQXV0aGVudGljYXRvci5cbiAgICogSWYgdGhlIG9wdGlvbmFsIHBhcmFtZXRlcnMgYXJlIHVuc3BlY2lmaWVkLCBhbiBhY2NvdW50TmFtZSBvZiA8dXNlckVtYWlsPiBhbmQgaXNzdWVyIG9mIDxmaXJlYmFzZUFwcE5hbWU+IGFyZSB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudE5hbWUgdGhlIG5hbWUgb2YgdGhlIGFjY291bnQvYXBwIGFsb25nIHdpdGggYSB1c2VyIGlkZW50aWZpZXIuXG4gICAqIEBwYXJhbSBpc3N1ZXIgaXNzdWVyIG9mIHRoZSBUT1RQIChsaWtlbHkgdGhlIGFwcCBuYW1lKS5cbiAgICogQHJldHVybnMgQSBRUiBjb2RlIFVSTCBzdHJpbmcuXG4gICAqL1xuICBnZW5lcmF0ZVFyQ29kZVVybChhY2NvdW50TmFtZT86IHN0cmluZywgaXNzdWVyPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBsZXQgdXNlRGVmYXVsdHMgPSBmYWxzZTtcbiAgICBpZiAoX2lzRW1wdHlTdHJpbmcoYWNjb3VudE5hbWUpIHx8IF9pc0VtcHR5U3RyaW5nKGlzc3VlcikpIHtcbiAgICAgIHVzZURlZmF1bHRzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHVzZURlZmF1bHRzKSB7XG4gICAgICBpZiAoX2lzRW1wdHlTdHJpbmcoYWNjb3VudE5hbWUpKSB7XG4gICAgICAgIGFjY291bnROYW1lID0gdGhpcy5hdXRoLmN1cnJlbnRVc2VyPy5lbWFpbCB8fCAndW5rbm93bnVzZXInO1xuICAgICAgfVxuICAgICAgaWYgKF9pc0VtcHR5U3RyaW5nKGlzc3VlcikpIHtcbiAgICAgICAgaXNzdWVyID0gdGhpcy5hdXRoLm5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgb3RwYXV0aDovL3RvdHAvJHtpc3N1ZXJ9OiR7YWNjb3VudE5hbWV9P3NlY3JldD0ke3RoaXMuc2VjcmV0S2V5fSZpc3N1ZXI9JHtpc3N1ZXJ9JmFsZ29yaXRobT0ke3RoaXMuaGFzaGluZ0FsZ29yaXRobX0mZGlnaXRzPSR7dGhpcy5jb2RlTGVuZ3RofWA7XG4gIH1cbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gX2lzRW1wdHlTdHJpbmcoaW5wdXQ/OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgfHwgaW5wdXQ/Lmxlbmd0aCA9PT0gMDtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFVuc3Vic2NyaWJlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgRmlyZWJhc2VBdXRoSW50ZXJuYWwgfSBmcm9tICdAZmlyZWJhc2UvYXV0aC1pbnRlcm9wLXR5cGVzJztcblxuaW1wb3J0IHsgQXV0aEludGVybmFsIH0gZnJvbSAnLi4vLi4vbW9kZWwvYXV0aCc7XG5pbXBvcnQgeyBVc2VySW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC91c2VyJztcbmltcG9ydCB7IF9hc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQgeyBBdXRoRXJyb3JDb2RlIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuaW50ZXJmYWNlIFRva2VuTGlzdGVuZXIge1xuICAodG9rOiBzdHJpbmcgfCBudWxsKTogdW5rbm93bjtcbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhJbnRlcm9wIGltcGxlbWVudHMgRmlyZWJhc2VBdXRoSW50ZXJuYWwge1xuICBwcml2YXRlIHJlYWRvbmx5IGludGVybmFsTGlzdGVuZXJzOiBNYXA8VG9rZW5MaXN0ZW5lciwgVW5zdWJzY3JpYmU+ID1cbiAgICBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBhdXRoOiBBdXRoSW50ZXJuYWwpIHt9XG5cbiAgZ2V0VWlkKCk6IHN0cmluZyB8IG51bGwge1xuICAgIHRoaXMuYXNzZXJ0QXV0aENvbmZpZ3VyZWQoKTtcbiAgICByZXR1cm4gdGhpcy5hdXRoLmN1cnJlbnRVc2VyPy51aWQgfHwgbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldFRva2VuKFxuICAgIGZvcmNlUmVmcmVzaD86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTx7IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfSB8IG51bGw+IHtcbiAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XG4gICAgYXdhaXQgdGhpcy5hdXRoLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgaWYgKCF0aGlzLmF1dGguY3VycmVudFVzZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5hdXRoLmN1cnJlbnRVc2VyLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcbiAgICByZXR1cm4geyBhY2Nlc3NUb2tlbiB9O1xuICB9XG5cbiAgYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXI6IFRva2VuTGlzdGVuZXIpOiB2b2lkIHtcbiAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XG4gICAgaWYgKHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuaGFzKGxpc3RlbmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5hdXRoLm9uSWRUb2tlbkNoYW5nZWQodXNlciA9PiB7XG4gICAgICBsaXN0ZW5lcihcbiAgICAgICAgKHVzZXIgYXMgVXNlckludGVybmFsIHwgbnVsbCk/LnN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbiB8fCBudWxsXG4gICAgICApO1xuICAgIH0pO1xuICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCB1bnN1YnNjcmliZSk7XG4gICAgdGhpcy51cGRhdGVQcm9hY3RpdmVSZWZyZXNoKCk7XG4gIH1cblxuICByZW1vdmVBdXRoVG9rZW5MaXN0ZW5lcihsaXN0ZW5lcjogVG9rZW5MaXN0ZW5lcik6IHZvaWQge1xuICAgIHRoaXMuYXNzZXJ0QXV0aENvbmZpZ3VyZWQoKTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuZ2V0KGxpc3RlbmVyKTtcbiAgICBpZiAoIXVuc3Vic2NyaWJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy51cGRhdGVQcm9hY3RpdmVSZWZyZXNoKCk7XG4gIH1cblxuICBwcml2YXRlIGFzc2VydEF1dGhDb25maWd1cmVkKCk6IHZvaWQge1xuICAgIF9hc3NlcnQoXG4gICAgICB0aGlzLmF1dGguX2luaXRpYWxpemF0aW9uUHJvbWlzZSxcbiAgICAgIEF1dGhFcnJvckNvZGUuREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pbnRlcm5hbExpc3RlbmVycy5zaXplID4gMCkge1xuICAgICAgdGhpcy5hdXRoLl9zdGFydFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdXRoLl9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24gfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgQ29tcG9uZW50VHlwZSxcbiAgSW5zdGFudGlhdGlvbk1vZGVcbn0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5cbmltcG9ydCB7IG5hbWUsIHZlcnNpb24gfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgQXV0aEVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBfYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQnO1xuaW1wb3J0IHsgX2dldENsaWVudFZlcnNpb24sIENsaWVudFBsYXRmb3JtIH0gZnJvbSAnLi4vdXRpbC92ZXJzaW9uJztcbmltcG9ydCB7IF9jYXN0QXV0aCwgQXV0aEltcGwsIERlZmF1bHRDb25maWcgfSBmcm9tICcuL2F1dGhfaW1wbCc7XG5pbXBvcnQgeyBBdXRoSW50ZXJvcCB9IGZyb20gJy4vZmlyZWJhc2VfaW50ZXJuYWwnO1xuaW1wb3J0IHsgQ29uZmlnSW50ZXJuYWwgfSBmcm9tICcuLi8uLi9tb2RlbC9hdXRoJztcbmltcG9ydCB7IERlcGVuZGVuY2llcyB9IGZyb20gJy4uLy4uL21vZGVsL3B1YmxpY190eXBlcyc7XG5pbXBvcnQgeyBfaW5pdGlhbGl6ZUF1dGhJbnN0YW5jZSB9IGZyb20gJy4vaW5pdGlhbGl6ZSc7XG5cbmV4cG9ydCBjb25zdCBlbnVtIF9Db21wb25lbnROYW1lIHtcbiAgQVVUSCA9ICdhdXRoJyxcbiAgQVVUSF9JTlRFUk5BTCA9ICdhdXRoLWludGVybmFsJ1xufVxuXG5mdW5jdGlvbiBnZXRWZXJzaW9uRm9yUGxhdGZvcm0oXG4gIGNsaWVudFBsYXRmb3JtOiBDbGllbnRQbGF0Zm9ybVxuKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgc3dpdGNoIChjbGllbnRQbGF0Zm9ybSkge1xuICAgIGNhc2UgQ2xpZW50UGxhdGZvcm0uTk9ERTpcbiAgICAgIHJldHVybiAnbm9kZSc7XG4gICAgY2FzZSBDbGllbnRQbGF0Zm9ybS5SRUFDVF9OQVRJVkU6XG4gICAgICByZXR1cm4gJ3JuJztcbiAgICBjYXNlIENsaWVudFBsYXRmb3JtLldPUktFUjpcbiAgICAgIHJldHVybiAnd2Vid29ya2VyJztcbiAgICBjYXNlIENsaWVudFBsYXRmb3JtLkNPUkRPVkE6XG4gICAgICByZXR1cm4gJ2NvcmRvdmEnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckF1dGgoY2xpZW50UGxhdGZvcm06IENsaWVudFBsYXRmb3JtKTogdm9pZCB7XG4gIF9yZWdpc3RlckNvbXBvbmVudChcbiAgICBuZXcgQ29tcG9uZW50KFxuICAgICAgX0NvbXBvbmVudE5hbWUuQVVUSCxcbiAgICAgIChjb250YWluZXIsIHsgb3B0aW9uczogZGVwcyB9OiB7IG9wdGlvbnM/OiBEZXBlbmRlbmNpZXMgfSkgPT4ge1xuICAgICAgICBjb25zdCBhcHAgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcCcpLmdldEltbWVkaWF0ZSgpITtcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyID1cbiAgICAgICAgICBjb250YWluZXIuZ2V0UHJvdmlkZXI8J2hlYXJ0YmVhdCc+KCdoZWFydGJlYXQnKTtcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIgPVxuICAgICAgICAgIGNvbnRhaW5lci5nZXRQcm92aWRlcjwnYXBwLWNoZWNrLWludGVybmFsJz4oJ2FwcC1jaGVjay1pbnRlcm5hbCcpO1xuICAgICAgICBjb25zdCB7IGFwaUtleSwgYXV0aERvbWFpbiB9ID0gYXBwLm9wdGlvbnM7XG5cbiAgICAgICAgX2Fzc2VydChcbiAgICAgICAgICBhcGlLZXkgJiYgIWFwaUtleS5pbmNsdWRlcygnOicpLFxuICAgICAgICAgIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BUElfS0VZLFxuICAgICAgICAgIHsgYXBwTmFtZTogYXBwLm5hbWUgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZzogQ29uZmlnSW50ZXJuYWwgPSB7XG4gICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgIGF1dGhEb21haW4sXG4gICAgICAgICAgY2xpZW50UGxhdGZvcm0sXG4gICAgICAgICAgYXBpSG9zdDogRGVmYXVsdENvbmZpZy5BUElfSE9TVCxcbiAgICAgICAgICB0b2tlbkFwaUhvc3Q6IERlZmF1bHRDb25maWcuVE9LRU5fQVBJX0hPU1QsXG4gICAgICAgICAgYXBpU2NoZW1lOiBEZWZhdWx0Q29uZmlnLkFQSV9TQ0hFTUUsXG4gICAgICAgICAgc2RrQ2xpZW50VmVyc2lvbjogX2dldENsaWVudFZlcnNpb24oY2xpZW50UGxhdGZvcm0pXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYXV0aEluc3RhbmNlID0gbmV3IEF1dGhJbXBsKFxuICAgICAgICAgIGFwcCxcbiAgICAgICAgICBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIsXG4gICAgICAgICAgYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIsXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgICk7XG4gICAgICAgIF9pbml0aWFsaXplQXV0aEluc3RhbmNlKGF1dGhJbnN0YW5jZSwgZGVwcyk7XG5cbiAgICAgICAgcmV0dXJuIGF1dGhJbnN0YW5jZTtcbiAgICAgIH0sXG4gICAgICBDb21wb25lbnRUeXBlLlBVQkxJQ1xuICAgIClcbiAgICAgIC8qKlxuICAgICAgICogQXV0aCBjYW4gb25seSBiZSBpbml0aWFsaXplZCBieSBleHBsaWNpdGx5IGNhbGxpbmcgZ2V0QXV0aCgpIG9yIGluaXRpYWxpemVBdXRoKClcbiAgICAgICAqIEZvciB3aHkgd2UgZG8gdGhpcywgU2VlIGdvL2ZpcmViYXNlLW5leHQtYXV0aC1pbml0XG4gICAgICAgKi9cbiAgICAgIC5zZXRJbnN0YW50aWF0aW9uTW9kZShJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVClcbiAgICAgIC8qKlxuICAgICAgICogQmVjYXVzZSBhbGwgZmlyZWJhc2UgcHJvZHVjdHMgdGhhdCBkZXBlbmQgb24gYXV0aCBkZXBlbmQgb24gYXV0aC1pbnRlcm5hbCBkaXJlY3RseSxcbiAgICAgICAqIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBhdXRoLWludGVybmFsIGFmdGVyIGF1dGggaXMgaW5pdGlhbGl6ZWQgdG8gbWFrZSBpdCBhdmFpbGFibGUgdG8gb3RoZXIgZmlyZWJhc2UgcHJvZHVjdHMuXG4gICAgICAgKi9cbiAgICAgIC5zZXRJbnN0YW5jZUNyZWF0ZWRDYWxsYmFjayhcbiAgICAgICAgKGNvbnRhaW5lciwgX2luc3RhbmNlSWRlbnRpZmllciwgX2luc3RhbmNlKSA9PiB7XG4gICAgICAgICAgY29uc3QgYXV0aEludGVybmFsUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoXG4gICAgICAgICAgICBfQ29tcG9uZW50TmFtZS5BVVRIX0lOVEVSTkFMXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhdXRoSW50ZXJuYWxQcm92aWRlci5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgKTtcblxuICBfcmVnaXN0ZXJDb21wb25lbnQoXG4gICAgbmV3IENvbXBvbmVudChcbiAgICAgIF9Db21wb25lbnROYW1lLkFVVEhfSU5URVJOQUwsXG4gICAgICBjb250YWluZXIgPT4ge1xuICAgICAgICBjb25zdCBhdXRoID0gX2Nhc3RBdXRoKFxuICAgICAgICAgIGNvbnRhaW5lci5nZXRQcm92aWRlcihfQ29tcG9uZW50TmFtZS5BVVRIKS5nZXRJbW1lZGlhdGUoKSFcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIChhdXRoID0+IG5ldyBBdXRoSW50ZXJvcChhdXRoKSkoYXV0aCk7XG4gICAgICB9LFxuICAgICAgQ29tcG9uZW50VHlwZS5QUklWQVRFXG4gICAgKS5zZXRJbnN0YW50aWF0aW9uTW9kZShJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVClcbiAgKTtcblxuICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgZ2V0VmVyc2lvbkZvclBsYXRmb3JtKGNsaWVudFBsYXRmb3JtKSk7XG4gIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTUsIGVzbTIwMTcsIGNqczUsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXG4gIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnX19CVUlMRF9UQVJHRVRfXycpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmlyZWJhc2VBcHAsIGdldEFwcCwgX2dldFByb3ZpZGVyIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5cbmltcG9ydCB7XG4gIGluaXRpYWxpemVBdXRoLFxuICBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkLFxuICBvbklkVG9rZW5DaGFuZ2VkLFxuICBjb25uZWN0QXV0aEVtdWxhdG9yXG59IGZyb20gJy4uJztcbmltcG9ydCB7IHJlZ2lzdGVyQXV0aCB9IGZyb20gJy4uL2NvcmUvYXV0aC9yZWdpc3Rlcic7XG5pbXBvcnQgeyBDbGllbnRQbGF0Zm9ybSB9IGZyb20gJy4uL2NvcmUvdXRpbC92ZXJzaW9uJztcbmltcG9ydCB7IGJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlIH0gZnJvbSAnLi9wZXJzaXN0ZW5jZS9sb2NhbF9zdG9yYWdlJztcbmltcG9ydCB7IGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UgfSBmcm9tICcuL3BlcnNpc3RlbmNlL3Nlc3Npb25fc3RvcmFnZSc7XG5pbXBvcnQgeyBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlIH0gZnJvbSAnLi9wZXJzaXN0ZW5jZS9pbmRleGVkX2RiJztcbmltcG9ydCB7IGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgfSBmcm9tICcuL3BvcHVwX3JlZGlyZWN0JztcbmltcG9ydCB7IEF1dGgsIFVzZXIgfSBmcm9tICcuLi9tb2RlbC9wdWJsaWNfdHlwZXMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCwgZ2V0RXhwZXJpbWVudGFsU2V0dGluZyB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuY29uc3QgREVGQVVMVF9JRF9UT0tFTl9NQVhfQUdFID0gNSAqIDYwO1xuY29uc3QgYXV0aElkVG9rZW5NYXhBZ2UgPVxuICBnZXRFeHBlcmltZW50YWxTZXR0aW5nKCdhdXRoSWRUb2tlbk1heEFnZScpIHx8IERFRkFVTFRfSURfVE9LRU5fTUFYX0FHRTtcblxubGV0IGxhc3RQb3N0ZWRJZFRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsID0gbnVsbDtcblxuY29uc3QgbWludENvb2tpZUZhY3RvcnkgPSAodXJsOiBzdHJpbmcpID0+IGFzeW5jICh1c2VyOiBVc2VyIHwgbnVsbCkgPT4ge1xuICBjb25zdCBpZFRva2VuUmVzdWx0ID0gdXNlciAmJiAoYXdhaXQgdXNlci5nZXRJZFRva2VuUmVzdWx0KCkpO1xuICBjb25zdCBpZFRva2VuQWdlID1cbiAgICBpZFRva2VuUmVzdWx0ICYmXG4gICAgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gRGF0ZS5wYXJzZShpZFRva2VuUmVzdWx0Lmlzc3VlZEF0VGltZSkpIC8gMV8wMDA7XG4gIGlmIChpZFRva2VuQWdlICYmIGlkVG9rZW5BZ2UgPiBhdXRoSWRUb2tlbk1heEFnZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTcGVjaWZpY2FsbHkgdHJpcCBudWxsID0+IHVuZGVmaW5lZCB3aGVuIGxvZ2dlZCBvdXQsIHRvIGRlbGV0ZSBhbnkgZXhpc3RpbmcgY29va2llXG4gIGNvbnN0IGlkVG9rZW4gPSBpZFRva2VuUmVzdWx0Py50b2tlbjtcbiAgaWYgKGxhc3RQb3N0ZWRJZFRva2VuID09PSBpZFRva2VuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxhc3RQb3N0ZWRJZFRva2VuID0gaWRUb2tlbjtcbiAgYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgbWV0aG9kOiBpZFRva2VuID8gJ1BPU1QnIDogJ0RFTEVURScsXG4gICAgaGVhZGVyczogaWRUb2tlblxuICAgICAgPyB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7aWRUb2tlbn1gXG4gICAgICAgIH1cbiAgICAgIDoge31cbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIEF1dGggaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0uXG4gKiBJZiBubyBpbnN0YW5jZSBleGlzdHMsIGluaXRpYWxpemVzIGFuIEF1dGggaW5zdGFuY2Ugd2l0aCBwbGF0Zm9ybS1zcGVjaWZpYyBkZWZhdWx0IGRlcGVuZGVuY2llcy5cbiAqXG4gKiBAcGFyYW0gYXBwIC0gVGhlIEZpcmViYXNlIEFwcC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdXRoKGFwcDogRmlyZWJhc2VBcHAgPSBnZXRBcHAoKSk6IEF1dGgge1xuICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdhdXRoJyk7XG5cbiAgaWYgKHByb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgIHJldHVybiBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcbiAgfVxuXG4gIGNvbnN0IGF1dGggPSBpbml0aWFsaXplQXV0aChhcHAsIHtcbiAgICBwb3B1cFJlZGlyZWN0UmVzb2x2ZXI6IGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIsXG4gICAgcGVyc2lzdGVuY2U6IFtcbiAgICAgIGluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2UsXG4gICAgICBicm93c2VyTG9jYWxQZXJzaXN0ZW5jZSxcbiAgICAgIGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2VcbiAgICBdXG4gIH0pO1xuXG4gIGNvbnN0IGF1dGhUb2tlblN5bmNVcmwgPSBnZXRFeHBlcmltZW50YWxTZXR0aW5nKCdhdXRoVG9rZW5TeW5jVVJMJyk7XG4gIGlmIChhdXRoVG9rZW5TeW5jVXJsKSB7XG4gICAgY29uc3QgbWludENvb2tpZSA9IG1pbnRDb29raWVGYWN0b3J5KGF1dGhUb2tlblN5bmNVcmwpO1xuICAgIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoYXV0aCwgbWludENvb2tpZSwgKCkgPT5cbiAgICAgIG1pbnRDb29raWUoYXV0aC5jdXJyZW50VXNlcilcbiAgICApO1xuICAgIG9uSWRUb2tlbkNoYW5nZWQoYXV0aCwgdXNlciA9PiBtaW50Q29va2llKHVzZXIpKTtcbiAgfVxuXG4gIGNvbnN0IGF1dGhFbXVsYXRvckhvc3QgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0KCdhdXRoJyk7XG4gIGlmIChhdXRoRW11bGF0b3JIb3N0KSB7XG4gICAgY29ubmVjdEF1dGhFbXVsYXRvcihhdXRoLCBgaHR0cDovLyR7YXV0aEVtdWxhdG9ySG9zdH1gKTtcbiAgfVxuXG4gIHJldHVybiBhdXRoO1xufVxuXG5yZWdpc3RlckF1dGgoQ2xpZW50UGxhdGZvcm0uQlJPV1NFUik7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgcmVnaXN0ZXJWZXJzaW9uIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBuYW1lLCB2ZXJzaW9uIH0gZnJvbSAnLi4vcGFja2FnZS5qc29uJztcblxucmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdhcHAnKTtcbmV4cG9ydCAqIGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuIiwiaW1wb3J0IHtEcm9wYm94LCBEcm9wYm94QXV0aH0gZnJvbSAnZHJvcGJveCdcbmltcG9ydCB7VXRpbHN9IGZyb20gJ3N0dWZmJ1xuaW1wb3J0IHt0eXBlIEF1dGgsIHR5cGUgVXNlciwgZ2V0QXV0aCwgc2lnbkluV2l0aEN1c3RvbVRva2VufSBmcm9tICdmaXJlYmFzZS9hdXRoJ1xuaW1wb3J0IHt0eXBlIEZpcmViYXNlQXBwLCBpbml0aWFsaXplQXBwfSBmcm9tICdmaXJlYmFzZS9hcHAnXG5cbi8vIGNvbnN0IGRiID0gcmVxdWlyZSgnZHJvcGJveCcpXG5jb25zdCBmaXJlYmFzZUNvbmZpZyA9IHtcblx0YXBpS2V5OiAnQUl6YVN5RHd0Y1BqUU1qM0pBeTlkN3d3amliMTlleXd2R2ZkVjNBJyxcblx0YXV0aERvbWFpbjogJ3NwbHVuZ2UtMzkwMTEwLmZpcmViYXNlYXBwLmNvbScsXG5cdHByb2plY3RJZDogJ3NwbHVuZ2UtMzkwMTEwJyxcblx0c3RvcmFnZUJ1Y2tldDogJ3NwbHVuZ2UtMzkwMTEwLmFwcHNwb3QuY29tJyxcblx0bWVzc2FnaW5nU2VuZGVySWQ6ICcxMDQxNTQyNzM2ODk1Jyxcblx0YXBwSWQ6ICcxOjEwNDE1NDI3MzY4OTU6d2ViOjY2M2I5YzVhYjM4ZjgyOTVlYjk1Y2EnLFxufVxuXG5sZXQgZmlyZWJhc2VfYXBwOiBGaXJlYmFzZUFwcFxubGV0IGZpcmViYXNlX2F1dGg6IEF1dGhcbmZ1bmN0aW9uIGdldEN1cnJlbnRVc2VyKGF1dGg6IEF1dGgpOiBQcm9taXNlPFVzZXIgfCBudWxsPiB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0Y29uc3QgdW5zdWJzY3JpYmUgPSBhdXRoLm9uQXV0aFN0YXRlQ2hhbmdlZCgodXNlcikgPT4ge1xuXHRcdFx0dW5zdWJzY3JpYmUoKVxuXHRcdFx0cmVzb2x2ZSh1c2VyKVxuXHRcdH0sIHJlamVjdClcblx0fSlcbn1cblxuZXhwb3J0IGNsYXNzIERyb3Bib3hBdXRoZXIge1xuXHRDTElFTlRfSUQ6IHN0cmluZyA9ICdqeHB5aHYyY3FvenViMGMnXG5cdFJFRElSRUNUX1VSSTogc3RyaW5nID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC8nXG5cdC8vIEB0cy1pZ25vcmVcblx0ZGJ4OiBEcm9wYm94XG5cdC8vIEB0cy1pZ25vcmVcblx0ZGJ4QXV0aDogRHJvcGJveEF1dGhcblx0YXV0aGVkOiBib29sZWFuID0gZmFsc2Vcblx0Ly8gQHRzLWlnbm9yZVxuXHRmaXJlYmFzZV91c2VyOiBVc2VyIHwgbnVsbFxuXG5cdGFzeW5jIGluaXQoKSB7XG5cdFx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnKSB7XG5cdFx0XHR0aGlzLlJFRElSRUNUX1VSSSA9ICdodHRwczovL3dyaWdodHdyaXRlci5naXRodWIuaW8vc3BsdW5nZS8nXG5cdFx0fVxuXHRcdC8vIGNvbnNvbGUubG9nKGRiKVxuXHRcdGZpcmViYXNlX2FwcCA9IGluaXRpYWxpemVBcHAoZmlyZWJhc2VDb25maWcpXG5cdFx0ZmlyZWJhc2VfYXV0aCA9IGdldEF1dGgoZmlyZWJhc2VfYXBwKVxuXHRcdHRoaXMuZmlyZWJhc2VfdXNlciA9IGF3YWl0IGdldEN1cnJlbnRVc2VyKGZpcmViYXNlX2F1dGgpXG5cdFx0Ly8gZmlyZWJhc2VfYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZWQodXNlciA9PntcblxuXHRcdC8vIH0pXG5cdFx0dGhpcy5kYnhBdXRoID0gbmV3IERyb3Bib3hBdXRoKHtcblx0XHRcdGNsaWVudElkOiB0aGlzLkNMSUVOVF9JRCxcblx0XHR9KVxuXG5cdFx0aWYgKHRoaXMuZmlyZWJhc2VfdXNlcikge1xuXHRcdFx0Y29uc3QgaWRfdG9rZW4gPSBhd2FpdCBmaXJlYmFzZV9hdXRoLmN1cnJlbnRVc2VyPy5nZXRJZFRva2VuKHRydWUpXG5cblx0XHRcdGxldCByZXMgPSBhd2FpdCAoXG5cdFx0XHRcdGF3YWl0IGZldGNoKCdodHRwczovL3VzLWNlbnRyYWwxLXNwbHVuZ2UtMzkwMTEwLmNsb3VkZnVuY3Rpb25zLm5ldC9nZXREcm9wYm94Q29kZScgKyBgP2lkX3Rva2VuPSR7aWRfdG9rZW59YClcblx0XHRcdCkuanNvbigpXG5cblx0XHRcdGNvbnN0IGFjY2Vzc190b2tlbiA9IHJlcy50b2tlblxuXHRcdFx0dGhpcy5kYnhBdXRoLnNldEFjY2Vzc1Rva2VuKGFjY2Vzc190b2tlbilcblxuXHRcdFx0Ly8gdGhpcy5kYnhBdXRoLnNldFJlZnJlc2hUb2tlbihyZXMudG9rZW4pXG5cdFx0XHR0aGlzLmRieCA9IG5ldyBEcm9wYm94KHtcblx0XHRcdFx0YXV0aDogdGhpcy5kYnhBdXRoLFxuXHRcdFx0fSlcblx0XHRcdGxldCBmaWxlcyA9IGF3YWl0IHRoaXMuZGJ4LmZpbGVzTGlzdEZvbGRlcih7XG5cdFx0XHRcdHBhdGg6ICcnLFxuXHRcdFx0fSlcblx0XHRcdHRoaXMuYXV0aGVkID0gdHJ1ZVxuXHRcdH1cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCkge31cblxuXHRwYXJzZVF1ZXJ5U3RyaW5nKHN0cikge1xuXHRcdGNvbnN0IHJldCA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuXHRcdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHJldFxuXHRcdH1cblxuXHRcdHN0ciA9IHN0ci50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKVxuXG5cdFx0aWYgKCFzdHIpIHtcblx0XHRcdHJldHVybiByZXRcblx0XHR9XG5cblx0XHRzdHIuc3BsaXQoJyYnKS5mb3JFYWNoKChwYXJhbSkgPT4ge1xuXHRcdFx0Y29uc3QgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpXG5cdFx0XHQvLyBGaXJlZm94IChwcmUgNDApIGRlY29kZXMgYCUzRGAgdG8gYD1gXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9wdWxsLzM3XG5cdFx0XHRsZXQga2V5ID0gcGFydHMuc2hpZnQoKVxuXHRcdFx0bGV0IHZhbCA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0cy5qb2luKCc9JykgOiB1bmRlZmluZWRcblxuXHRcdFx0a2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSlcblxuXHRcdFx0Ly8gbWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcblx0XHRcdC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcblx0XHRcdHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpXG5cblx0XHRcdGlmIChyZXRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldFtrZXldID0gdmFsXG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0W2tleV0pKSB7XG5cdFx0XHRcdHJldFtrZXldLnB1c2godmFsKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF1cblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0cmV0dXJuIHJldFxuXHR9XG5cdGFzeW5jIGRvQXV0aCgpIHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgdXJsX3Jlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG5cdFx0XHRcdCdodHRwczovL3VzLWNlbnRyYWwxLXNwbHVuZ2UtMzkwMTEwLmNsb3VkZnVuY3Rpb25zLm5ldC9nZXRBdXRoZW50aWNhdGlvblVybCcgKyBgP3VybD0ke3dpbmRvdy5sb2NhdGlvbi5ocmVmfWAsXG5cdFx0XHQpXG5cdFx0XHRsZXQgdXJsID0gYXdhaXQgdXJsX3Jlc3BvbnNlLmpzb24oKVxuXHRcdFx0dXJsID0gdXJsWydhdXRoX3VybCddXG5cdFx0XHR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybFxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGVycm9yKVxuXHRcdH1cblx0fVxuXG5cdGFzeW5jIHRyeV9pbml0X2Ryb3Bib3goKSB7XG5cdFx0bGV0IGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuXHRcdGNvbnN0IGdldENvZGVGcm9tVXJsID0gKCkgPT4ge1xuXHRcdFx0Y29kZSA9IHRoaXMucGFyc2VRdWVyeVN0cmluZyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS5jb2RlXG5cdFx0XHRyZXR1cm4gY29kZVxuXHRcdH1cblx0XHRjb25zdCBoYXNSZWRpcmVjdGVkRnJvbUF1dGggPSAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gISFnZXRDb2RlRnJvbVVybCgpXG5cdFx0fVxuXHRcdGxldCByZWRpcmVjdGVkRnJvbUF1dGggPSBoYXNSZWRpcmVjdGVkRnJvbUF1dGgoKVxuXHRcdGlmIChyZWRpcmVjdGVkRnJvbUF1dGgpIHtcblx0XHRcdGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpXG5cblx0XHRcdGNvbnN0IGJvZHkgPSB7fVxuXG5cdFx0XHRmb3IgKGxldCBrZXkgb2YgdXJsLnNlYXJjaFBhcmFtcy5rZXlzKCkpIHtcblx0XHRcdFx0aWYgKHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKGtleSkubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGJvZHlba2V5XSA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKGtleSlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRib2R5W2tleV0gPSB1cmwuc2VhcmNoUGFyYW1zLmdldChrZXkpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSAmJlxuXHRcdFx0XHR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoXG5cdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHQnJyxcblx0XHRcdFx0XHR3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgK1xuXHRcdFx0XHRcdFx0d2luZG93LmxvY2F0aW9uLnNlYXJjaC5yZXBsYWNlKC9bPyZdY29kZT1bXiZdKy8sICcnKS5yZXBsYWNlKC9eJi8sICc/JykgK1xuXHRcdFx0XHRcdFx0d2luZG93LmxvY2F0aW9uLmhhc2gsXG5cdFx0XHRcdClcblx0XHRcdGJvZHlbJ3JlZGlyZWN0X3VybCddID0gd2luZG93LmxvY2F0aW9uLmhyZWZcblxuXHRcdFx0Y29uc3QgcmVzID0gYXdhaXQgZmV0Y2goXG5cdFx0XHRcdCdodHRwczovL3VzLWNlbnRyYWwxLXNwbHVuZ2UtMzkwMTEwLmNsb3VkZnVuY3Rpb25zLm5ldC9leGNoYW5nZURyb3Bib3hDb2RlJyArXG5cdFx0XHRcdFx0YD9yZWRpcmVjdF91cmw9JHt3aW5kb3cubG9jYXRpb24uaHJlZn1gICtcblx0XHRcdFx0XHRgJmNvZGU9JHtib2R5Wydjb2RlJ119YCxcblx0XHRcdClcblx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cdFx0XHRzaWduSW5XaXRoQ3VzdG9tVG9rZW4oZmlyZWJhc2VfYXV0aCwgZGF0YS50b2tlbilcblx0XHR9XG5cblx0XHRyZXR1cm5cblx0fVxufVxuIiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48ZGl2IGNsYXNzPVwia25vYi1jb250YWluZXJcIj5cblx0PGRpdlxuXHRcdGNsYXNzPVwia25vYlwiXG5cdFx0cm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIFxuXHRcdG9uOmNsaWNrPXthc3luYyAoKSA9PiB7XG5cdFx0XHQvLyBnYWxsZXJ5X29wZW4gPSAhZ2FsbGVyeV9vcGVuXG5cdFx0XHRnYWxsZXJ5X29wZW4uc2V0KHRydWUpXG5cdFx0XHRsZXQgW19jYW52YXNfaW1hZ2UsIGJsb2JdID0gYXdhaXQgZ2V0X2N1cnJlbnRfY2FudmFzX2FzX2ltYWdlKClcblx0XHRcdGNhbnZhc19pbWFnZSA9IF9jYW52YXNfaW1hZ2Vcblx0XHRcdGNhbnZhc19pbWFnZV9zcmMgPSBjYW52YXNfaW1hZ2Uuc3JjXG5cdFx0XHRjYW52YXNfaW1hZ2VfYmxvYiA9IGJsb2Jcblx0XHRcdGNvbnNvbGUubG9nKGNhbnZhc19pbWFnZS5zcmMpXG5cdFx0fX0+XG5cdFx0e0BodG1sIHNvbHZlSWNvbn1cblx0PC9kaXY+XG5cdHsjaWYgJGdhbGxlcnlfb3Blbn1cblx0XHQ8ZGl2IGlkPVwiZ2FsbGVyeS1jb250YWluZXItb3V0ZXJcIiBpbjpmYWRlPXt7ZHVyYXRpb246IDIwMH19PlxuXHRcdFx0PGRpdiBpZD1cImdhbGxlcnktY29udGFpbmVyXCI+XG5cdFx0XHRcdDxkaXYgaWQ9XCJ0b3AtYmFyXCI+XG5cdFx0XHRcdFx0PGRpdiBpZD1cInByb2plY3QtdGl0bGVcIj5Qcm9qZWN0PC9kaXY+XG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0aWQ9XCJiYWNrLWJ1dHRvblwiXG5cdFx0XHRcdFx0XHRyb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgXG5cdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHQvLyBnYWxsZXJ5X29wZW4gPSAhZ2FsbGVyeV9vcGVuXG5cdFx0XHRcdFx0XHRcdGdhbGxlcnlfb3Blbi5zZXQoZmFsc2UpXG5cdFx0XHRcdFx0XHR9fT5cblx0XHRcdFx0XHRcdHtAaHRtbCBmb3JiaWRJY29ufVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBpZD1cImN1cnJlbnQtcHJvamVjdFwiPlxuXHRcdFx0XHRcdDxpbWcgc3JjPXtjYW52YXNfaW1hZ2Vfc3JjfSBpZD1cImNhbnZhcy1wcmV2aWV3LWltZ1wiIGFsdD1cIlwiIC8+XG5cdFx0XHRcdFx0PGRpdiBpZD1cInByb2plY3Qtb3B0aW9uc1wiPlxuXHRcdFx0XHRcdFx0PGRpdiBpZD1cInByb2plY3Qtc2F2ZS1idXR0b25cIiByb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgb246Y2xpY2s9e3NhdmVfdG9fZHJvcGJveH0+XG5cdFx0XHRcdFx0XHRcdDxkaXYgaWQ9XCJwcm9qZWN0LXNhdmUtYnV0dG9uLXRpdGxlXCI+U2F2ZSB0byBkcm9wYm94PC9kaXY+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJpY29uXCIgc3R5bGU9XCJ0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwcHgsMC4ycmVtKTtcIj5cblx0XHRcdFx0XHRcdFx0XHR7QGh0bWwgY2FwdHVyZUljb259XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8IS0tIDxkaXYgaWQ9XCJwcm9qZWN0LXNhdmUtYnV0dG9uXCIgb246Y2xpY2s9eygpPT57XG5cdFx0XHRcdFx0XHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwcm9qZWN0JywgSlNPTi5zdHJpbmdpZnkocHJvamVjdCkpXG5cdFx0XHRcdFx0XHR9fT5cblx0XHRcdFx0XHRcdFx0PGRpdiBpZD1cInByb2plY3Qtc2F2ZS1idXR0b24tdGl0bGVcIj5TYXZlIHRvIGxvY2FsU3RvcmFnZTwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaWNvblwiIHN0eWxlPVwidHJhbnNmb3JtOiB0cmFuc2xhdGUoMHB4LDAuMnJlbSk7XCI+XG5cdFx0XHRcdFx0XHRcdFx0e0BodG1sIGNhcHR1cmVJY29ufVxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDwvZGl2PiAtLT5cblx0XHRcdFx0XHRcdDxkaXYgaWQ9XCJwcm9qZWN0LXNhdmUtYnV0dG9uXCIgb246Y2xpY2s9e2Rvd25sb2FkX2ltYWdlfSByb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgPlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGlkPVwicHJvamVjdC1zYXZlLWJ1dHRvbi10aXRsZVwiPkRvd25sb2FkPC9kaXY+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJpY29uXCIgc3R5bGU9XCJ0cmFuc2Zvcm06IHNjYWxlKDEuMzQpO1wiPlxuXHRcdFx0XHRcdFx0XHRcdHtAaHRtbCBkb3dubG9hZEljb259XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8ZGl2IGlkPVwicHJvamVjdC1zYXZlLWJ1dHRvblwiIGNsYXNzPVwiZGF0ZVwiPlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGlkPVwicHJvamVjdC1zYXZlLWJ1dHRvbi10aXRsZVwiPntmb3JtYXRfdGltZShjdXJyZW50X3Byb2plY3QuaWQpfTwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdHtAaHRtbCB0aW1lSWNvbn1cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBpZD1cIm9wdGlvbnMtYmFyXCI+XG5cdFx0XHRcdFx0PGRpdiBpZD1cImJ1dHRvblwiIG9uOmNsaWNrPXthc3luYyAoKSA9PiB7IFxuXHRcdFx0XHRcdFx0bGV0IHNhZmUgPSBhd2FpdCBpc19zYWZlX3RvX3N3aXRjaF90b19uZXdfcHJvamVjdCgpXG5cdFx0XHRcdFx0XHRzYWZlID0gc2FmZSA/IHNhZmUgOiBjb25maXJtKCdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY3JlYXRlIGFub3RoZXIgcHJvamVjdD8gVGhpcyBvbmUgaXMgbm90IHNhdmVkLicpXG5cdFx0XHRcdFx0XHRpZihzYWZlKXtcblx0XHRcdFx0XHRcdFx0bmV3X3Byb2plY3QoKVxuXHRcdFx0XHRcdFx0XHQvLyBnYWxsZXJ5X29wZW4gPSBmYWxzZVxuXHRcdFx0XHRcdFx0XHRnYWxsZXJ5X29wZW4uc2V0KGZhbHNlKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRyb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHRcdFx0TmV3IGZpbGVcblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0e0BodG1sIGxhdW5jaEljb259XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBpZD1cImJ1dHRvblwiIG9uOmNsaWNrPXthc3luYyAoKSA9PiB7IFxuXHRcdFx0XHRcdFx0c2l6ZV9tb2RhbF9vcGVuZWQgPSB0cnVlXG5cdFx0XHRcdFx0XHRyZXNpemVfd2lkZ2V0X2NhbnZhc19zaXplWzBdID0gY3VycmVudF9wcm9qZWN0LmNhbnZhc1Jlc1swXVxuXHRcdFx0XHRcdFx0cmVzaXplX3dpZGdldF9jYW52YXNfc2l6ZVsxXSA9IGN1cnJlbnRfcHJvamVjdC5jYW52YXNSZXNbMV1cblx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBcblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8ZGl2IGRyYWdnYWJsZT1cImZhbHNlXCI+XG5cdFx0XHRcdFx0XHRcdFJlc2l6ZVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHR7QGh0bWwgcmVzaXplSWNvbn1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGlkPVwic2l6ZS1tb2RhbFwiIHN0eWxlPXtzaXplX21vZGFsX29wZW5lZCA/IFwiXCIgOiBcImRpc3BsYXk6IG5vbmU7XCJ9PlxuXHRcdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0XHRpZD1cImJhY2stYnV0dG9uXCJcblx0XHRcdFx0XHRcdFx0cm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIFxuXHRcdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHNpemVfbW9kYWxfb3BlbmVkID0gZmFsc2Vcblx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0c3R5bGU9J21hcmdpbi1ib3R0b206IDAuNDVyZW07J1xuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdHtAaHRtbCBmb3JiaWRJY29ufVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8ZGl2IHN0eWxlPSdtYXJnaW4tYm90dG9tOiAxcmVtOyc+XG5cdFx0XHRcdFx0XHRcdFJlc2l6ZSBjYW52YXNcblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PGRpdiBzdHlsZT0nbWFyZ2luLWJvdHRvbTogMXJlbTsnPlxuXHRcdFx0XHRcdFx0XHR7Zmxvb3IocmVzaXplX3dpZGdldF9jYW52YXNfc2l6ZVswXSkgfSB4IHtmbG9vcihyZXNpemVfd2lkZ2V0X2NhbnZhc19zaXplWzFdKSB9XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDxkaXYgc3R5bGU9e2Bcblx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZDogd2hpdGU7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAxMHJlbTtcblx0XHRcdFx0XHRcdFx0YXNwZWN0LXJhdGlvOiAxLyR7cmVzaXplX3dpZGdldF9jYW52YXNfc2l6ZVsxXS9yZXNpemVfd2lkZ2V0X2NhbnZhc19zaXplWzBdfVxuXHRcdFx0XHRcdFx0YH0gb246cG9pbnRlcmRvd249e3Jlc2l6ZV93aWRnZXRfcG9pbnRlcl9kb3dufSA+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdFx0cm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIFxuXHRcdFx0XHRcdFx0XHRpZD1cImJhY2stYnV0dG9uXCJcblx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJvay1idXR0b25cIlxuXHRcdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHJlc2l6ZV93aWRnZXRfY2FudmFzX3NpemVbMF0gPSBmbG9vcihyZXNpemVfd2lkZ2V0X2NhbnZhc19zaXplWzBdKVxuXHRcdFx0XHRcdFx0XHRcdHJlc2l6ZV93aWRnZXRfY2FudmFzX3NpemVbMV0gPSBmbG9vcihyZXNpemVfd2lkZ2V0X2NhbnZhc19zaXplWzFdKVxuXHRcdFx0XHRcdFx0XHRcdHJlc2l6ZV9wcm9qZWN0KHJlc2l6ZV93aWRnZXRfY2FudmFzX3NpemUpXG5cdFx0XHRcdFx0XHRcdFx0c2l6ZV9tb2RhbF9vcGVuZWQgPSBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdC8vIGdhbGxlcnlfb3BlbiA9IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0Z2FsbGVyeV9vcGVuLnNldChmYWxzZSlcblx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0c3R5bGU9J21hcmdpbi10b3A6IDEuMTRyZW07J1xuXHRcdFx0XHRcdFx0XHQgPlxuXHRcdFx0XHRcdFx0XHR7QGh0bWwgb2tJY29ufVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8IS0tIDxidXR0b24gb246Y2xpY2s9e2FzeW5jKCk9PmF3YWl0IGxvZ19pbnRvX2Ryb3Bib3goKX0gY2xhc3M6aGlkZT17YXV0aGVkfSA+IC0tPlxuXHRcdFx0XHQ8YnV0dG9uIGlkPVwiZGItbG9naW4tYnV0dG9uXCIgb246Y2xpY2s9e2FzeW5jKCk9PmF3YWl0IGxvZ19pbnRvX2Ryb3Bib3goKX0gY2xhc3M6aGlkZT17YXV0aGVkfSA+XG5cdFx0XHRcdFx0TE9HIElOVE8gRFJPUEJPWFxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PGRpdiBpZD1cImdhbGxlcnktZWxlbWVudHNcIj5cblx0XHRcdFx0XHR7I2VhY2ggZ2FsbGVyeV9lbGVtZW50cyBhcyBlbGVtZW50LCBpfVxuXHRcdFx0XHRcdFx0PGRpdiBpZD1cImVsZW1lbnRcIiBvbjpjbGljaz17YXN5bmMgKCk9Pntcblx0XHRcdFx0XHRcdFx0bGV0IHNhZmUgPSBhd2FpdCBpc19zYWZlX3RvX3N3aXRjaF90b19uZXdfcHJvamVjdCgpXG5cdFx0XHRcdFx0XHRcdHNhZmUgPSBzYWZlID8gc2FmZSA6IGNvbmZpcm0oJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBzd2l0Y2ggdG8gYW5vdGhlciBwcm9qZWN0PyBUaGlzIG9uZSBpcyBub3Qgc2F2ZWQuJylcblx0XHRcdFx0XHRcdFx0aWYoc2FmZSl7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHByb2ogPSBhd2FpdCBkYnguZmlsZXNEb3dubG9hZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXRoOiAnLycgKyBlbGVtZW50Lm5hbWUgKyAnLmpzb24nXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdFx0XHRcdGxldCBiaW5hcnkgPSBhd2FpdCBwcm9qLnJlc3VsdC5maWxlQmxvYi50ZXh0KClcblx0XHRcdFx0XHRcdFx0XHRsZXQgYmluYXJ5X2pzb24gPSBKU09OLnBhcnNlKGJpbmFyeSlcblx0XHRcdFx0XHRcdFx0XHRsb2FkX3Byb2plY3QoYmluYXJ5X2pzb24pXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZ2FsbGVyeV9vcGVuID0gZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHRnYWxsZXJ5X29wZW4uc2V0KGZhbHNlKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9fSBcblx0XHRcdFx0XHRcdHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBcblx0XHRcdFx0XHRcdHN0eWxlPXsgTnVtYmVyKGVsZW1lbnQubmFtZSkgPT09IGN1cnJlbnRfcHJvamVjdC5pZCA/IFwiYm9yZGVyOiAwLjFyZW0gc29saWQgd2hpdGU7XCIgOiBcIlwifVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8IS0tIHtlbGVtZW50Lm5hbWV9IC0tPlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGlkPVwiZWxlbWVudC1uYW1lXCI+XG5cdFx0XHRcdFx0XHRcdFx0e2Zvcm1hdF90aW1lKGVsZW1lbnQubmFtZSl9XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8aW1nIGRyYWdnYWJsZT1cImZhbHNlXCIgc3JjPXtlbGVtZW50LmltYWdlX3NyY30gaWQ9XCJjYW52YXMtcHJldmlldy1pbWdcIiBhbHQ9XCJcIiAvPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHR7L2lmfVxuPC9kaXY+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdC8vIEB0cy1pZ25vcmVcblx0aW1wb3J0IHNvbHZlSWNvbiBmcm9tICcvLi4vcHVibGljL3NvbHZlLnN2Zydcblx0Ly8gQHRzLWlnbm9yZVxuXHRpbXBvcnQgbGF1bmNoSWNvbiBmcm9tICcvLi4vcHVibGljL2xhdW5jaC5zdmcnXG5cdC8vIEB0cy1pZ25vcmVcblx0aW1wb3J0IHJlc2l6ZUljb24gZnJvbSAnLy4uL3B1YmxpYy9yZXNpemUuc3ZnJ1xuXHQvLyBAdHMtaWdub3JlXG5cdGltcG9ydCBmb3JiaWRJY29uIGZyb20gJy8uLi9wdWJsaWMvZm9yYmlkLnN2Zydcblx0Ly8gQHRzLWlnbm9yZVxuXHRpbXBvcnQgb2tJY29uIGZyb20gJy8uLi9wdWJsaWMvb2suc3ZnJ1xuXHQvLyBAdHMtaWdub3JlXG5cdGltcG9ydCBjYXB0dXJlSWNvbiBmcm9tICcvLi4vcHVibGljL2NhcHR1cmUuc3ZnJ1xuXHQvLyBAdHMtaWdub3JlXG5cdGltcG9ydCBkb3dubG9hZEljb24gZnJvbSAnLy4uL3B1YmxpYy9kb3dubG9hZC5zdmcnXG5cdC8vIEB0cy1pZ25vcmVcblx0aW1wb3J0IHRpbWVJY29uIGZyb20gJy8uLi9wdWJsaWMvdGltZS5zdmcnXG5cdGltcG9ydCB7RHJvcGJveCwgRHJvcGJveEF1dGh9IGZyb20gJ2Ryb3Bib3gnXG5cdGltcG9ydCB0eXBlIHtQcm9qZWN0fSBmcm9tICdzdHVmZidcblx0aW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSdcblx0aW1wb3J0IHsgRHJvcGJveEF1dGhlciB9IGZyb20gJ2Ryb3Bib3hfYXV0aCdcblx0aW1wb3J0IHtmbG9hdGluZ19tb2RhbF9tZXNzYWdlfSBmcm9tICdzdG9yZSdcblx0aW1wb3J0IHtnYWxsZXJ5X29wZW59IGZyb20gJ3N0b3JlJ1xuXHRcblx0aW1wb3J0IHsgZmFkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblx0aW1wb3J0IHsgZmxvb3J9IGZyb20gJ3dtYXRoJ1xuXG5cblx0ZXhwb3J0IGxldCBjdXJyZW50X3Byb2plY3Q6IFByb2plY3Rcblx0ZXhwb3J0IGxldCBnZXRfY3VycmVudF9jYW52YXNfYXNfaW1hZ2U6ICgpID0+IFByb21pc2U8W0hUTUxJbWFnZUVsZW1lbnQsIEJsb2JdPlxuXHRleHBvcnQgbGV0IHJlc2l6ZV9wcm9qZWN0OiAobmV3X3NpemU6IG51bWJlcltdKSA9PiB2b2lkXG5cdGV4cG9ydCBsZXQgbmV3X3Byb2plY3Q6ICgpID0+IHZvaWRcblx0ZXhwb3J0IGxldCBsb2FkX3Byb2plY3Q6IChwcm9qZWN0OiBQcm9qZWN0KSA9PiB2b2lkXG5cdGV4cG9ydCBsZXQgcHJvamVjdF9oYXNfYmVlbl9tb2RpZmllZDogYm9vbGVhblxuXG5cdGNvbnN0IGZvcm1hdF90aW1lID0gKHQ6IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9Pntcblx0XHRyZXR1cm4gbmV3IERhdGUoTnVtYmVyKHQpKS50b0xvY2FsZVN0cmluZygnZW4tR0InLCB7XG5cdFx0XHRob3VyQ3ljbGU6ICdoMjMnLFxuXHRcdFx0ZGF5OiBcIjItZGlnaXRcIixcblx0XHRcdG1vbnRoOiBcIjItZGlnaXRcIixcblx0XHRcdHllYXI6IFwibnVtZXJpY1wiLFxuXHRcdFx0aG91cjogXCIyLWRpZ2l0XCIsXG5cdFx0XHRtaW51dGU6IFwiMi1kaWdpdFwiXG5cdFx0fSkucmVwbGFjZSgnLCcsJycpXG5cdH1cblxuXHQvLyBsZXQgZ2FsbGVyeV9vcGVuID0gZmFsc2Vcblx0bGV0IHNpemVfbW9kYWxfb3BlbmVkID0gZmFsc2VcblxuXHRsZXQgY2FudmFzX2ltYWdlOiBIVE1MSW1hZ2VFbGVtZW50IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG5cdGxldCBjYW52YXNfaW1hZ2VfYmxvYjogQmxvYiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuXHRsZXQgY2FudmFzX2ltYWdlX3NyYzogc3RyaW5nID0gJydcblx0XG5cblxuXHRjbGFzcyBFbGVtZW50IHtcblx0XHRuYW1lOiBzdHJpbmdcblx0XHRpbWFnZV9zcmM6IHN0cmluZ1xuXHRcdGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgaW1hZ2Vfc3JjOiBzdHJpbmcpIHtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWVcblx0XHRcdHRoaXMuaW1hZ2Vfc3JjID0gaW1hZ2Vfc3JjXG5cdFx0fVxuXHR9XG5cdFxuXHRsZXQgZGJ4OiBEcm9wYm94XG5cdGNvbnN0IGRieF9hdXRoZXIgPSBuZXcgRHJvcGJveEF1dGhlcigpXG5cdFxuXG5cdGxldCBhdXRoZWQgPSBmYWxzZVxuXHRsZXQgZ2FsbGVyeV9lbGVtZW50czogRWxlbWVudFtdID0gW11cblxuXHRjb25zdCBsb2dfaW50b19kcm9wYm94ID0gYXN5bmMgKCk9PiB7XG5cdFx0YXdhaXQgZGJ4X2F1dGhlci5kb0F1dGgoKVxuXHR9XG5cdFxuXHRleHBvcnQgY29uc3QgaXNfc2FmZV90b19zd2l0Y2hfdG9fbmV3X3Byb2plY3QgPSBhc3luYyAoKTogUHJvbWlzZTxib29sZWFuPiA9Pntcblx0XHRsZXQgcHJvamVjdF9pc19zYXZlZF90b19kcm9wYm94ID0gZmFsc2VcblxuXHRcdGlmKCFkYnhfYXV0aGVyLmF1dGhlZCl7XG5cdFx0XHRwcm9qZWN0X2lzX3NhdmVkX3RvX2Ryb3Bib3ggPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCByZXNwb25zZSA9IGF3YWl0IGRieC5maWxlc0xpc3RGb2xkZXIoe3BhdGg6ICcnfSlcblx0XHRcdGZvciAobGV0IGVsZW1lbnQgb2YgcmVzcG9uc2UucmVzdWx0LmVudHJpZXMpIHtcblx0XHRcdFx0bGV0IHByb2pfbmFtZSA9IE51bWJlcihlbGVtZW50Lm5hbWUuc2xpY2UoMCwtNSkpXG5cdFx0XHRcdGlmKHByb2pfbmFtZSA9PT0gY3VycmVudF9wcm9qZWN0LmlkKXtcblx0XHRcdFx0XHRwcm9qZWN0X2lzX3NhdmVkX3RvX2Ryb3Bib3ggPSB0cnVlXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKHByb2plY3RfaGFzX2JlZW5fbW9kaWZpZWQgfHwgIXByb2plY3RfaXNfc2F2ZWRfdG9fZHJvcGJveCl7XG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdH1cblxuXHRjb25zdCBkb3dubG9hZF9pbWFnZSA9IGFzeW5jICgpPT57XG5cdFx0Y29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0XHRsaW5rLmhyZWYgPSAoY2FudmFzX2ltYWdlIGFzIEhUTUxJbWFnZUVsZW1lbnQpLnNyY1xuXHRcdGxpbmsuZG93bmxvYWQgPSBjdXJyZW50X3Byb2plY3QuaWQgKyAnLnBuZyc7XG5cdFx0bGluay5jbGljaygpO1xuXHR9XG5cdGNvbnN0IHJlZmV0Y2hfY2FudmFzZXMgPSBhc3luYyAoKSA9PiB7XG5cdFx0bGV0IHJlc3BvbnNlID0gYXdhaXQgZGJ4LmZpbGVzTGlzdEZvbGRlcih7cGF0aDogJyd9KVxuXHRcdGNvbnNvbGUubG9nKHJlc3BvbnNlKVxuXHRcdGdhbGxlcnlfZWxlbWVudHMgPSBbXVxuXHRcdGZvciAobGV0IGVsZW1lbnQgb2YgcmVzcG9uc2UucmVzdWx0LmVudHJpZXMpIHtcblx0XHRcdGlmKGVsZW1lbnQubmFtZS5lbmRzV2l0aChcIi5qc29uXCIpKXtcblx0XHRcdFx0bGV0IHByb2pfbmFtZSA9IGVsZW1lbnQubmFtZS5zbGljZSgwLC01KVxuXHRcdFx0XHRsZXQgaW1hZ2UgPSBhd2FpdCBkYnguZmlsZXNEb3dubG9hZCh7XG5cdFx0XHRcdFx0cGF0aDogJy8nICsgcHJval9uYW1lICsgJy5wbmcnXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0bGV0IGJpbmFyeTogQmxvYiA9IGltYWdlLnJlc3VsdC5maWxlQmxvYlxuXHRcdFx0XHRjb25zdCBibG9iVG9EYXRhVVJMID0gKGJsb2I6IEJsb2IpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRcdFx0XHRyZWFkZXIub25sb2FkID0gX2UgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0IGFzIHN0cmluZyk7XG5cdFx0XHRcdFx0XHRyZWFkZXIub25lcnJvciA9IF9lID0+IHJlamVjdChyZWFkZXIuZXJyb3IpO1xuXHRcdFx0XHRcdFx0cmVhZGVyLm9uYWJvcnQgPSBfZSA9PiByZWplY3QobmV3IEVycm9yKFwiUmVhZCBhYm9ydGVkXCIpKTtcblx0XHRcdFx0XHRcdHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFxuXHRcdFx0XHQvLyBcdFx0YXdhaXQgYmxvYlRvRGF0YVVSTChiaW5hcnkpXG5cdFx0XHRcdC8vIClcblx0XHRcdFx0Ly8gZ2FsbGVyeV9lbGVtZW50cy5wdXNoKG5ldyBFbGVtZW50KFxuXHRcdFx0XHQvLyBcdHByb2pfbmFtZSxcblx0XHRcdFx0Ly8gXHRhd2FpdCBibG9iVG9EYXRhVVJMKGJpbmFyeSlcblx0XHRcdFx0Ly8gKSlcblx0XHRcdFx0Z2FsbGVyeV9lbGVtZW50cyA9IFsuLi4gZ2FsbGVyeV9lbGVtZW50cywgbmV3IEVsZW1lbnQoXG5cdFx0XHRcdFx0cHJval9uYW1lLFxuXHRcdFx0XHRcdGF3YWl0IGJsb2JUb0RhdGFVUkwoYmluYXJ5KVxuXHRcdFx0XHQpXVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRjb25zdCBzYXZlX3RvX2Ryb3Bib3ggPSBhc3luYyAoKT0+e1xuXHRcdGZsb2F0aW5nX21vZGFsX21lc3NhZ2Uuc2V0KFwiU3RhcnRpbmcgdXBsb2FkIHRvIGRyb3Bib3guXCIpXG5cdFx0bGV0IHIgPSBhd2FpdCBkYnguZmlsZXNVcGxvYWQoe1xuXHRcdFx0cGF0aDogJy8nICsgY3VycmVudF9wcm9qZWN0LmlkICsgJy5qc29uJyxcblx0XHRcdGNvbnRlbnRzOiBKU09OLnN0cmluZ2lmeShjdXJyZW50X3Byb2plY3QpLFxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0bW9kZTogXCJvdmVyd3JpdGVcIlxuXHRcdH0pXG5cdFx0ciA9IGF3YWl0IGRieC5maWxlc1VwbG9hZCh7XG5cdFx0XHRwYXRoOiAnLycgKyBjdXJyZW50X3Byb2plY3QuaWQgKyAnLnBuZycsXG5cdFx0XHRjb250ZW50czogYXdhaXQgKGF3YWl0IGZldGNoKCgoY2FudmFzX2ltYWdlIGFzIEhUTUxJbWFnZUVsZW1lbnQpLnNyYykpKS5ibG9iKCksXG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRtb2RlOiBcIm92ZXJ3cml0ZVwiXG5cdFx0fSlcblx0XHRmbG9hdGluZ19tb2RhbF9tZXNzYWdlLnNldChcIlVwbG9hZCB0byBkcm9wYm94IHN1Y2Nlc2Z1bC5cIilcblx0XHRwcm9qZWN0X2hhc19iZWVuX21vZGlmaWVkID0gZmFsc2Vcblx0XHRhd2FpdCByZWZldGNoX2NhbnZhc2VzKClcblx0fVxuXG5cdGNvbnN0IHJlc2l6ZV93aWRnZXRfcGl4ZWxfcmFuZ2UgPSAyMDBcblx0Y29uc3QgbWluID0gMFxuXHRjb25zdCBtYXggPSA0XG5cblx0bGV0IHJlc2l6ZV93aWRnZXRfY2FudmFzX3NpemUgPSBbMCwwXVxuXHRsZXQgcmVzaXplX3dpZGdldF9zdGFydF95ID0gMFxuXHRsZXQgcmVzaXplX3dkaWdldF9zdGFydF92YWx1ZSA9IFswLCAwXVxuXHRsZXQgcmVzaXplX3dpZGdldF9zdGFydF94ID0gMFxuXG5cdCQ6IHZhbHVlUmFuZ2UgPSBtYXggLSBtaW5cblxuXHRmdW5jdGlvbiByZXNpemVfd2lkZ2V0X3BvaW50ZXJfbW92ZSh7Y2xpZW50WCwgY2xpZW50WX0pIHtcblx0XHRsZXQgdmFsdWVEaWZmWSA9ICh2YWx1ZVJhbmdlICogKHJlc2l6ZV93aWRnZXRfc3RhcnRfeSAtIGNsaWVudFkpKSAvIHJlc2l6ZV93aWRnZXRfcGl4ZWxfcmFuZ2Vcblx0XHRsZXQgdmFsdWVEaWZmWCA9ICh2YWx1ZVJhbmdlICogKHJlc2l6ZV93aWRnZXRfc3RhcnRfeCAtIGNsaWVudFgpKSAvIHJlc2l6ZV93aWRnZXRfcGl4ZWxfcmFuZ2VcblxuXHRcdHJlc2l6ZV93aWRnZXRfY2FudmFzX3NpemVbMF0gPSByZXNpemVfd2RpZ2V0X3N0YXJ0X3ZhbHVlWzBdIC0gdmFsdWVEaWZmWCoxMDAwXG5cdFx0cmVzaXplX3dpZGdldF9jYW52YXNfc2l6ZVsxXSA9IHJlc2l6ZV93ZGlnZXRfc3RhcnRfdmFsdWVbMV0gKyB2YWx1ZURpZmZZKjEwMDBcblx0XHQvLyBicnVzaF9zelswXSA9IGNsYW1wKHN0YXJ0VmFsdWVbMF0gLSB2YWx1ZURpZmZYLCBtaW4sIG1heClcblx0XHQvLyBicnVzaF9zelsxXSA9IGNsYW1wKHN0YXJ0VmFsdWVbMV0gKyB2YWx1ZURpZmZZLCBtaW4sIG1heClcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2l6ZV93aWRnZXRfcG9pbnRlcl9kb3duKGU6IFBvaW50ZXJFdmVudCkge1xuXHRcdGxldCB7Y2xpZW50WCwgY2xpZW50WX0gPSBlXG5cdFx0Ly8gY29uc29sZS5sb2coeyBjbGllbnRZIH0pO1xuXHRcdGNvbnNvbGUubG9nKCdkb3duJylcblxuXHRcdHJlc2l6ZV93aWRnZXRfc3RhcnRfeSA9IGNsaWVudFlcblx0XHRyZXNpemVfd2lkZ2V0X3N0YXJ0X3ggPSBjbGllbnRYXG5cdFx0cmVzaXplX3dkaWdldF9zdGFydF92YWx1ZSA9IFsuLi5yZXNpemVfd2lkZ2V0X2NhbnZhc19zaXplXVxuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgcmVzaXplX3dpZGdldF9wb2ludGVyX21vdmUpXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHJlc2l6ZV93aWRnZXRfcG9pbnRlcl91cClcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpXG5cdH1cblxuXHRmdW5jdGlvbiByZXNpemVfd2lkZ2V0X3BvaW50ZXJfdXAoKSB7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgcmVzaXplX3dpZGdldF9wb2ludGVyX21vdmUpXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHJlc2l6ZV93aWRnZXRfcG9pbnRlcl91cClcblx0fVxuXG5cdG9uTW91bnQoYXN5bmMgKCkgPT4ge1xuXHRcdGF3YWl0IGRieF9hdXRoZXIuaW5pdCgpXG5cdFx0YXdhaXQgZGJ4X2F1dGhlci50cnlfaW5pdF9kcm9wYm94KClcblx0XHRhdXRoZWQgPSBkYnhfYXV0aGVyLmF1dGhlZFxuXHRcdGRieCA9IGRieF9hdXRoZXIuZGJ4XG5cdFx0aWYoYXV0aGVkKXtcblx0XHRcdHJlZmV0Y2hfY2FudmFzZXMoKVxuXHRcdH1cblx0fSlcblxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5cdCNjYW52YXMtcHJldmlldy1pbWcge1xuXHRcdC8qIG1heC13aWR0aDogMTJyZW07ICovXG5cdFx0aGVpZ2h0OiAxMnJlbTtcblx0XHQvKiBtYXgtd2lkdGg6IDVyZW07ICovXG5cdFx0LyogYXNwZWN0LXJhdGlvOnVuc2V0OyAqL1xuXHR9XG5cdC5oaWRle1xuXHRcdGRpc3BsYXk6IG5vbmU7XG5cdH1cblx0Omdsb2JhbCgjZ2FsbGVyeS1jb250YWluZXI6Oi13ZWJraXQtc2Nyb2xsYmFyKXtcblx0XHRiYWNrZ3JvdW5kOiBibGFjaztcblx0fVxuXHQ6Z2xvYmFsKCNnYWxsZXJ5LWNvbnRhaW5lcjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2spe1xuXHRcdGJhY2tncm91bmQ6IGdyZXk7XG5cdH1cblx0Omdsb2JhbCgjZ2FsbGVyeS1jb250YWluZXI6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iKXtcblx0XHRiYWNrZ3JvdW5kOiB3aGl0ZTsgXG5cdH1cblx0I2RiLWxvZ2luLWJ1dHRvbntcbiAgICBmb250LXNpemU6IDNyZW07XG4gICAgYm9yZGVyLXJhZGl1czogMHB4O1xuICAgIG1hcmdpbi1ib3R0b206IDJyZW07XG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdCY6YWN0aXZle1xuXHRcdFx0ZmlsdGVyOiBpbnZlcnQoMSk7XG5cdFx0fVxuXHR9XG5cdCNzaXplLW1vZGFsIHtcblx0XHRwb3NpdGlvbjogZml4ZWQ7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0d2lkdGg6IDEwMHZ3O1xuXHRcdGhlaWdodDogMTAwdmg7XG5cdFx0bGVmdDogMDtcblx0XHR0b3A6IDA7XG5cdFx0ei1pbmRleDogMTAxO1xuXHRcdGJhY2tncm91bmQ6IGJsYWNrO1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHR9XG5cdCNnYWxsZXJ5LWNvbnRhaW5lci1vdXRlciB7XG5cdFx0cG9zaXRpb246IGZpeGVkO1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdHdpZHRoOiAxMDB2dztcblx0XHRoZWlnaHQ6IDEwMHZoO1xuXHRcdGxlZnQ6IDA7XG5cdFx0dG9wOiAwO1xuXHRcdHotaW5kZXg6IDEwMDtcblx0XHRiYWNrZ3JvdW5kOiBibGFjaztcblx0XHQjZ2FsbGVyeS1jb250YWluZXIge1xuXHRcdFx0Ly8gc2Nyb2xsYmFyLWNvbG9yOiAjNjk2OWRkICNlMGUwZTA7XG5cdFx0XHQvLyBzY3JvbGxiYXItd2lkdGg6IHRoaW47XG5cdFx0XHRvdmVyZmxvdy15OiBvdmVybGF5O1xuXHRcdFx0c2Nyb2xsYmFyLWd1dHRlcjogc3RhYmxlIGJvdGgtZWRnZXM7XG5cdFx0XHRtYXJnaW4tdG9wOiAxcmVtO1xuXHRcdFx0Ly8gb3ZlcmZsb3c6IHNjcm9sbDtcblx0XHRcdGhlaWdodDogMTAwJTtcblx0XHRcdG1heC13aWR0aDogNDByZW07XG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRcdCN0b3AtYmFyIHtcblx0XHRcdFx0I3Byb2plY3QtdGl0bGUge1xuXHRcdFx0XHRcdG1hcmdpbi1sZWZ0OiAwLjVyZW07XG5cdFx0XHRcdH1cblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogMXJlbTtcblx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRcdGZvbnQtc2l6ZTogMnJlbTtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdFx0fVxuXHRcdFx0I29wdGlvbnMtYmFyIHtcblx0XHRcdFx0KiB7XG5cdFx0XHRcdFx0Zm9udC1zaXplOiAwLjk1cmVtO1xuXHRcdFx0XHRcdDpnbG9iYWwoc3ZnKXtcblx0XHRcdFx0XHRcdGZpbGw6IHdoaXRlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQjYnV0dG9ue1xuXHRcdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0XHRcdHBhZGRpbmc6IDByZW0gMC4ycmVtO1xuXHRcdFx0XHRcdDpnbG9iYWwoc3ZnKXtcblx0XHRcdFx0XHRcdGhlaWdodDogMTAwJTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JjphY3RpdmV7XG5cdFx0XHRcdFx0XHRmaWx0ZXI6IGludmVydCgxKTtcblx0XHRcdFx0XHRcdGJhY2tncm91bmQ6IGJsYWNrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAxcmVtO1xuXHRcdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdFx0Zm9udC1zaXplOiAycmVtO1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0XHR9XG5cdFx0XHQub2stYnV0dG9uIDpnbG9iYWwoc3ZnKSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogc2NhbGUoMC45NikgIWltcG9ydGFudDsgXG5cdFx0XHR9XG5cdFx0XHQjYmFjay1idXR0b24gPiA6Z2xvYmFsKHN2Zykge1xuXHRcdFx0XHQmOmFjdGl2ZXtcblx0XHRcdFx0XHRmaWx0ZXI6IGludmVydCgxKTtcblx0XHRcdFx0XHRiYWNrZ3JvdW5kOiBibGFjaztcblx0XHRcdFx0fVxuXHRcdFx0XHR0cmFuc2Zvcm06IHNjYWxlKDEuNSkgdHJhbnNsYXRlKDAuMnJlbSwgMHB4KTtcblx0XHRcdFx0ZmlsbDogd2hpdGU7XG5cdFx0XHRcdHdpZHRoOiAzcmVtO1xuXHRcdFx0XHRhc3BlY3QtcmF0aW86IDEvMTtcblx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0fVxuXHRcdFx0I2dhbGxlcnktZWxlbWVudHMge1xuXHRcdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdFx0ZGlzcGxheTogZ3JpZDtcblx0XHRcdFx0Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMywgMWZyKTtcblx0XHRcdFx0Z2FwOiAxMHB4O1xuXHRcdFx0XHRncmlkLWF1dG8tcm93czogbWlubWF4KDEwMHB4LCBhdXRvKTtcblx0XHRcdFx0I2VsZW1lbnR7XG5cdFx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0XHRcdC8vIHBvaW50ZXItZXZlbnRzOiBub25lO1xuXHRcdFx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXHRcdFx0XHRcdCNlbGVtZW50LW5hbWV7XG5cdFx0XHRcdFx0XHRtYXJnaW4tYm90dG9tOiAwLjVyZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCY6YWN0aXZle1xuXHRcdFx0XHRcdFx0YmFja2dyb3VuZDogd2hpdGU7XG5cdFx0XHRcdFx0XHQqe1xuXHRcdFx0XHRcdFx0XHRjb2xvcjogYmxhY2s7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQjY3VycmVudC1wcm9qZWN0IHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogMXJlbTtcblxuXHRcdFx0XHQjcHJvamVjdC1vcHRpb25zIHtcblx0XHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdFx0XHRcdCoge1xuXHRcdFx0XHRcdFx0Zm9udC1zaXplOiAxLjNyZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0I3Byb2plY3Qtc2F2ZS1idXR0b24tdGl0bGUge1xuXHRcdFx0XHRcdFx0Ly8gbWFyZ2luOiBhdXRvO1xuXHRcdFx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAwLjVyZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCNwcm9qZWN0LXNhdmUtYnV0dG9uIHtcblx0XHRcdFx0XHRcdCY6YWN0aXZle1xuXHRcdFx0XHRcdFx0XHRmaWx0ZXI6IGludmVydCgxKTtcblx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQuaWNvbiB7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAycmVtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAxLjVyZW07XG5cdFx0XHRcdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0XHRcdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuXHRcdFx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiByb3c7XG5cdFx0XHRcdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0XHRcdFx0aGVpZ2h0OiAycmVtO1xuXHRcdFx0XHRcdFx0bWF4LXdpZHRoOiAzMHJlbTtcblx0XHRcdFx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0XHRcdFx0KiB7XG5cdFx0XHRcdFx0XHRcdGZvbnQtc2l6ZTogMS4wcmVtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gJi5kYXRle1xuXHRcdFx0XHRcdFx0Ly8gXHQqIHtcblx0XHRcdFx0XHRcdC8vIFx0XHRmb250LXNpemU6IDAuNnJlbTtcblx0XHRcdFx0XHRcdC8vIFx0fVxuXHRcdFx0XHRcdFx0Ly8gfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQjcHJvamVjdC1zYXZlLWJ1dHRvbiA6Z2xvYmFsKHN2Zykge1xuXHRcdFx0XHRcdFx0Ly8gbWFyZ2luLXJpZ2h0OiAwcmVtO1xuXHRcdFx0XHRcdFx0YXNwZWN0LXJhdGlvOiAxLzE7XG5cdFx0XHRcdFx0XHRmaWxsOiB3aGl0ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbiAgLy8gQGltcG9ydCBcIi8uLi9zdHlsZXMvaWNvbi5zY3NzXCIgc2NvcGVkOyBcblx0Lmtub2ItY29udGFpbmVyIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHQvKiB3aWR0aDogNDBweDtcbiAgICBoZWlnaHQ6IDQwcHg7ICovXG5cdFx0YXNwZWN0LXJhdGlvOiAxLzE7XG5cdFx0Ly8gbWF4LWhlaWdodDogNTAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0bWFyZ2luLXJpZ2h0OiAxcmVtO1xuXHRcdHBvaW50ZXItZXZlbnRzOiBhbGw7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cdFx0bWFyZ2luLWJvdHRvbTogYXV0bztcblx0XHRtYXJnaW4tdG9wOiBhdXRvO1xuICAgIG1hcmdpbi1yaWdodDogMHJlbTtcblx0fVxuXG5cdC5rbm9iIHtcblx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRmaWx0ZXI6IGludmVydCgxKTtcblx0XHRcdGJhY2tncm91bmQ6IGJsYWNrO1xuXHRcdH1cblx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0YXNwZWN0LXJhdGlvOiAxLzE7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdC8qIGhlaWdodDogODAlOyAqL1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0Y29sb3I6IHZhcigtLXRleHQtY29sb3IpO1xuXHRcdHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XG5cdH1cblxuXHQua25vYiA6Z2xvYmFsKHN2Zykge1xuXHRcdGZpbGw6IHdoaXRlO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0fVxuPC9zdHlsZT5cblxuXG5cdFx0PCEtLSBjb25zdCBkYXRhVVJMVG9CbG9iID0gYXN5bmMgKGRhdGFVUkwpID0+IHtcblx0XHRcdGxldCBCQVNFNjRfTUFSS0VSID0gJztiYXNlNjQsJztcblxuXHRcdFx0aWYgKGRhdGFVUkwuaW5kZXhPZihCQVNFNjRfTUFSS0VSKSA9PSAtMSkge1xuXHRcdFx0XHRcdGxldCBwYXJ0cyA9IGRhdGFVUkwuc3BsaXQoJywnKTtcblx0XHRcdFx0XHRsZXQgY29udGVudFR5cGUgPSBwYXJ0c1swXS5zcGxpdCgnOicpWzFdO1xuXHRcdFx0XHRcdGxldCByYXcgPSBkZWNvZGVVUklDb21wb25lbnQocGFydHNbMV0pO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBCbG9iKFtyYXddLCB7dHlwZTogY29udGVudFR5cGV9KTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IHBhcnRzID0gZGF0YVVSTC5zcGxpdChCQVNFNjRfTUFSS0VSKTtcblx0XHRcdGxldCBjb250ZW50VHlwZSA9IHBhcnRzWzBdLnNwbGl0KCc6JylbMV07XG5cdFx0XHRsZXQgcmF3ID0gd2luZG93LmF0b2IocGFydHNbMV0pO1xuXHRcdFx0bGV0IHJhd0xlbmd0aCA9IHJhdy5sZW5ndGg7XG5cblx0XHRcdGxldCB1SW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkocmF3TGVuZ3RoKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYXdMZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdHVJbnQ4QXJyYXlbaV0gPSByYXcuY2hhckNvZGVBdChpKTtcblx0XHRcdH1cblx0XHRcdC8vIFRPRE86IFJFUExBQ0UgV0lUSCBUSElTPz9cblx0XHRcdGNvbnN0IGJsb2IgPSBhd2FpdCAoYXdhaXQgZmV0Y2goZGF0YVVSTCkpLmJsb2IoKTsgXG5cdFx0XHRyZXR1cm4gYmxvYlxuXHRcdFx0Ly8gYWRkIGNvbm5lY3Qtc3JjIGRhdGE6IHRvIHlvdXIgQ29udGVudC1TZWN1cml0eS1Qb2xpY3lcblxuXHRcdFx0cmV0dXJuIG5ldyBCbG9iKFt1SW50OEFycmF5XSwge3R5cGU6IGNvbnRlbnRUeXBlfSk7XG5cdFx0fSAtLT4iLCI8c3ZlbHRlOm9wdGlvbnMgYWNjZXNzb3JzIC8+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gIGltcG9ydCB7ZmxvYXRpbmdfbW9kYWxfbWVzc2FnZX0gZnJvbSBcInN0b3JlXCJcbiAgbGV0IGRpc3BsYXllZF9tZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgXG4gIGNvbnN0IGRpc3BsYXlfdGltZSA9IDFcbiAgY29uc3QgZmFkZV9pbl90ID0gMC4yXG4gIGNvbnN0IGZhZGVfb3V0X3QgPSAxXG4gIFxuICBsZXQgZmFkaW5nX2luID0gdHJ1ZVxuXG4gIGxldCBvcGFjaXR5ID0gMFxuICBcbiAgZmxvYXRpbmdfbW9kYWxfbWVzc2FnZS5zdWJzY3JpYmUobWVzc2FnZT0+e1xuICAgIGlmKG1lc3NhZ2Upe1xuICAgICAgZGlzcGxheWVkX21lc3NhZ2UgPSBtZXNzYWdlXG4gICAgICBvcGFjaXR5ID0gMVxuICAgICAgZmFkaW5nX2luID0gdHJ1ZVxuICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICBvcGFjaXR5ID0gMFxuICAgICAgICBmYWRpbmdfaW4gPSBmYWxzZVxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgZGlzcGxheWVkX21lc3NhZ2UgPSB1bmRlZmluZWRcbiAgICAgICAgfSwgZmFkZV9vdXRfdCAqIDEwMDApXG4gICAgICB9LCBkaXNwbGF5X3RpbWUgKiAxMDAwKVxuICAgICAgZmxvYXRpbmdfbW9kYWxfbWVzc2FnZS5zZXQodW5kZWZpbmVkKVxuICAgIH1cbiAgfSlcbjwvc2NyaXB0PlxuXG5cbjwhLS0geyNpZiBkaXNwbGF5ZWRfbWVzc2FnZX0gLS0+XG4gIDxkaXYgaWQ9XCJmbG9hdGluZy1tb2RhbFwiPlxuICAgPGRpdiBpZD1cInRleHRcIiBzdHlsZT17XG4gICAgYG9wYWNpdHk6ICR7b3BhY2l0eX07XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAke2ZhZGluZ19pbiA/IGZhZGVfaW5fdCA6IGZhZGVfb3V0X3R9cztgXG4gIH0gPlxuICAgIHtkaXNwbGF5ZWRfbWVzc2FnZX1cbiAgIDwvZGl2PlxuICA8L2Rpdj5cbjwhLS0gey9pZn0gLS0+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAqe1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG4gICNmbG9hdGluZy1tb2RhbCB7XG5cdFx0cG9zaXRpb246IGZpeGVkO1xuXHRcdHdpZHRoOiBmaXQtY29udGVudDtcblx0XHRoZWlnaHQ6IGZpdC1jb250ZW50O1xuICAgIHRvcDogNTAlO1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcblx0XHR6LWluZGV4OiAxMDA7XG4gICAgI3RleHR7XG4gICAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoMC4zcmVtKSBpbnZlcnQoMC4zKTtcbiAgICAgIHBhZGRpbmc6IDFyZW07XG4gICAgICBib3JkZXItcmFkaXVzOiAwLjVyZW07XG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG4gIH1cbjwvc3R5bGU+IiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48ZGl2IGJpbmQ6dGhpcz17cGlja2VyRWxlbWVudH0gb246cG9pbnRlcmRvd249e3BvaW50ZXJEb3dufSBjbGFzcz1cImtub2ItY29udGFpbmVyXCI+XG5cdDxkaXYgY2xhc3M9XCJrbm9iXCIgY2xhc3M6cGlja2luZz17cGlja2luZ30+XG5cdFx0e0BodG1sIHBpY2tJY29ufVxuXHQ8L2Rpdj5cbjwvZGl2PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHQvLyBAdHMtaWdub3JlXG5cdGltcG9ydCBwaWNrSWNvbiBmcm9tICcvLi4vcHVibGljL3BsdWcuc3ZnJ1xuXG5cdGV4cG9ydCBsZXQgcGlja19mcm9tX2NhbnZhczogKCkgPT4gbnVtYmVyW11cbiAgXG4gIGxldCBwaWNrZXJFbGVtZW50OiBIVE1MRWxlbWVudFxuICBcbiAgZXhwb3J0IGxldCBwaWNraW5nID0gZmFsc2VcbiAgZXhwb3J0IGxldCBqdXN0X2ZpbmlzaGVkX3BpY2sgPSBmYWxzZVxuXG5cdGZ1bmN0aW9uIHBvaW50ZXJNb3ZlKHsgY2xpZW50WCwgY2xpZW50WSB9KSB7XG4gICBwaWNrX2Zyb21fY2FudmFzKClcblx0fVxuXHRjb25zdCBwb2ludGVyVXAgPSAoKSA9PiB7XG4gICAgcGlja2luZyA9IGZhbHNlXG4gICAganVzdF9maW5pc2hlZF9waWNrID0gdHJ1ZVxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHBvaW50ZXJNb3ZlKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcG9pbnRlclVwKTtcblx0fVxuXHRcblx0Y29uc3QgcG9pbnRlckRvd24gPSAoZTogUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgcGlja2luZyA9IHRydWVcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBwb2ludGVyTW92ZSk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHBvaW50ZXJVcCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKSBcblx0fVxuXHRcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cblx0LnBpY2tpbmd7XG5cdFx0ZmlsdGVyOiBpbnZlcnQoMSk7XG5cdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdH1cblxuICBAaW1wb3J0IFwiLy4uL3N0eWxlcy9pY29uLnNjc3NcIiBzY29wZWQ7IFxuXHQua25vYi1jb250YWluZXIge1xuXHRcdHotaW5kZXg6IDAgIWltcG9ydGFudDtcblx0fVxuPC9zdHlsZT5cbiIsIjxzdmVsdGU6b3B0aW9ucyBhY2Nlc3NvcnMgLz5cblxuPGRpdiBjbGFzcz1cImtub2ItY29udGFpbmVyLWNvbnRhaW5lclwiPlxuXHQ8aW1nXG5cdFx0c3JjPXtzZWxlY3RlZF9icnVzaF90ZXh0dXJlID8gc2VsZWN0ZWRfYnJ1c2hfdGV4dHVyZS5wYXRoIDogJyd9XG5cdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdGRyb3Bkb3duX3RvZ2dsZWQgPSAhZHJvcGRvd25fdG9nZ2xlZFxuXHRcdH19IC8+XG5cdHsjaWYgZHJvcGRvd25fdG9nZ2xlZH1cblx0XHQ8ZGl2IGlkPVwiZHJvcGRvd25cIj5cblx0XHRcdHsjZWFjaCBicnVzaF90ZXh0dXJlcyBhcyB0ZXh0dXJlLCBpfVxuXHRcdFx0XHR7I2lmIHRleHR1cmUgIT09IHNlbGVjdGVkX2JydXNoX3RleHR1cmV9XG5cdFx0XHRcdFx0PGltZ1xuXHRcdFx0XHRcdFx0c3JjPXt0ZXh0dXJlLnBhdGh9XG5cdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRzZWxlY3RlZF9icnVzaF90ZXh0dXJlID0gdGV4dHVyZVxuXHRcdFx0XHRcdFx0XHRkcm9wZG93bl90b2dnbGVkID0gZmFsc2Vcblx0XHRcdFx0XHRcdH19IC8+XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHR7L2VhY2h9XG5cdFx0PC9kaXY+XG5cdHsvaWZ9XG48L2Rpdj5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUge0JydXNoVGV4dHVyZX0gZnJvbSAnc3R1ZmYnXG5cblx0ZXhwb3J0IGxldCBicnVzaF90ZXh0dXJlczogQXJyYXk8QnJ1c2hUZXh0dXJlPlxuXHRleHBvcnQgbGV0IHNlbGVjdGVkX2JydXNoX3RleHR1cmU6IEJydXNoVGV4dHVyZVxuXG5cdGxldCBkcm9wZG93bl90b2dnbGVkID0gZmFsc2VcblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuXHRpbWcge1xuXHRcdCY6YWN0aXZlIHtcblx0XHRcdGZpbHRlcjogaW52ZXJ0KDEpO1xuXHRcdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdFx0fVxuXHRcdC8vIHBvaW50ZXItZXZlbnRzOiBub25lO1xuXHR9XG5cdC5rbm9iLWNvbnRhaW5lci1jb250YWluZXIge1xuXHRcdHotaW5kZXg6IDk5O1xuXHRcdGFzcGVjdC1yYXRpbzogMS8xO1xuXHRcdC8vIG1heC1oZWlnaHQ6IDUwJTtcblx0XHRtYXJnaW4tYm90dG9tOiBhdXRvO1xuXHRcdG1hcmdpbi10b3A6IGF1dG87XG5cdFx0bWFyZ2luLXJpZ2h0OiAxLjVyZW07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdHBvaW50ZXItZXZlbnRzOiBhbGw7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdG1pbi13aWR0aDogN3JlbTtcblxuXHRcdGJvcmRlcjogMXB4IHNvbGlkIHdoaXRlO1xuXHRcdG1pbi13aWR0aDogMHB4O1xuXHRcdGFzcGVjdC1yYXRpbzogMS8xO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHQjZHJvcGRvd24ge1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRwb3NpdGlvbjogc3RhdGljO1xuXHRcdFx0aGVpZ2h0OiB1bnNldDtcblx0XHRcdGJhY2tncm91bmQ6IGJsYWNrO1xuXHRcdFx0Ly8gdG9wOiA4OHB4O1xuXHRcdFx0PiBpbWcge1xuXHRcdFx0XHR6LWluZGV4OiAxMDAwMDAwMDtcblx0XHRcdFx0YXNwZWN0LXJhdGlvOiAxLzE7XG5cdFx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0XHQvLyBwb3NpdGlvbjogc3RhdGljO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQ+IGltZyB7XG5cdFx0XHRhc3BlY3QtcmF0aW86IDEvMTtcblx0XHRcdGhlaWdodDogMTAwJTtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG4iLCI8c3ZlbHRlOm9wdGlvbnMgYWNjZXNzb3JzIC8+XG5cbjxkaXYgY2xhc3M9XCJrbm9iLWNvbnRhaW5lci1jb250YWluZXJcIiBzdHlsZT1cImJvcmRlcjogbm9uZTtcIiA+XG5cdHsjaWYgIWRyb3Bkb3duX3RvZ2dsZWR9XG5cdDxkaXYgc3R5bGU9XCJib3JkZXI6IG5vbmU7XCI+QmxlbmQgc3BhY2U8L2Rpdj5cblx0PGRpdiBzdHlsZT1cImJvcmRlcjogMXB4IHNvbGlkIHdoaXRlO1wiIG9uOmNsaWNrPXsoKT0+e1xuXHRcdGRyb3Bkb3duX3RvZ2dsZWQgPSB0cnVlXG5cdH19PntCbGVuZGluZ0NvbG91clNwYWNlW3NlbGVjdGVkX2NvbG91cl9zcGFjZV19PC9kaXY+XG5cdHsvaWZ9XG5cdHsjaWYgZHJvcGRvd25fdG9nZ2xlZH1cblx0XHQ8ZGl2IGlkPVwiZHJvcGRvd25cIj5cblx0XHRcdHsjZWFjaCBPYmplY3Qua2V5cyhCbGVuZGluZ0NvbG91clNwYWNlKSBhcyBjb2xvdXJfc3BhY2UsIGl9XG5cdFx0XHRcdHsjaWYgaXNOYU4oQmxlbmRpbmdDb2xvdXJTcGFjZVtjb2xvdXJfc3BhY2VdKX1cblx0XHRcdFx0XHQ8ZGl2IHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBvbjpjbGljaz17KCk9Pntcblx0XHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRcdHNlbGVjdGVkX2NvbG91cl9zcGFjZSA9IGNvbG91cl9zcGFjZVxuXHRcdFx0XHRcdFx0ZHJvcGRvd25fdG9nZ2xlZCA9IGZhbHNlXG5cdFx0XHRcdFx0fX0gc3R5bGU9IHtcblx0XHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRcdGNvbG91cl9zcGFjZSAgPT09IHNlbGVjdGVkX2NvbG91cl9zcGFjZSA/ICBcImJhY2tncm91bmQ6IGJsYWNrOyBmaWx0ZXI6IGludmVydCgxKTtcIiA6IFwiXCJcblx0XHRcdFx0XHR9PlxuXHRcdFx0XHRcdFx0e0JsZW5kaW5nQ29sb3VyU3BhY2VbY29sb3VyX3NwYWNlXX1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0ey9pZn1cblx0XHRcdHsvZWFjaH1cblx0XHQ8L2Rpdj5cblx0ey9pZn1cbjwvZGl2PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge0JsZW5kaW5nQ29sb3VyU3BhY2UsIEJydXNoVHlwZX0gZnJvbSAnYnJ1c2hfc3Ryb2tlJ1xuXG5cdGV4cG9ydCBsZXQgc2VsZWN0ZWRfY29sb3VyX3NwYWNlOiBCbGVuZGluZ0NvbG91clNwYWNlXG5cblx0bGV0IGRyb3Bkb3duX3RvZ2dsZWQgPSBmYWxzZVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuXHRkaXYge1xuXHRcdCY6YWN0aXZlIHtcblx0XHRcdGZpbHRlcjogaW52ZXJ0KDEpO1xuXHRcdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdFx0fVxuXHR9XG5cdC5rbm9iLWNvbnRhaW5lci1jb250YWluZXIge1xuXHRcdHotaW5kZXg6IDAgIWltcG9ydGFudDtcblx0XHRtYXJnaW4tYm90dG9tOiBhdXRvO1xuXHRcdG1hcmdpbi10b3A6IGF1dG87XG5cdFx0bWFyZ2luLXJpZ2h0OiAxLjVyZW07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdHBvaW50ZXItZXZlbnRzOiBhbGw7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdG1pbi13aWR0aDogN3JlbTtcblxuXHRcdGJvcmRlcjogMXB4IHNvbGlkIHdoaXRlO1xuXHRcdG1pbi13aWR0aDogMHB4O1xuXHRcdCNkcm9wZG93biB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdHBvc2l0aW9uOiBzdGF0aWM7XG5cdFx0XHRoZWlnaHQ6IHVuc2V0O1xuXHRcdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdFx0XHQ+IGRpdiB7XG5cdFx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHdoaXRlO1xuXHRcdFx0XHR6LWluZGV4OiAxMDAwMDAwMDtcblx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuIiwiPHN2ZWx0ZTpvcHRpb25zIGFjY2Vzc29ycyAvPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge29uTW91bnR9IGZyb20gJ3N2ZWx0ZSdcblxuXHRleHBvcnQgbGV0IGNvbG91cjogbnVtYmVyW11cblxuICBsZXQgY29sb3VyX2lkeCA9IDBcblxuICAvLyBAdHMtaWdub3JlXG4gIGxldCBlbGVtZW50czogSFRNTERpdkVsZW1lbnRbXSA9IFswLDAsMF1cbiAgLy8gQHRzLWlnbm9yZVxuICBsZXQgaW5uZXJzOiBIVE1MRGl2RWxlbWVudFtdID0gWzAsMCwwXVxuXG5cdGxldCBzdGFydFkgPSAwXG4gIGxldCBzdGFydFggPSAwO1xuICBsZXQgc3RhcnRWYWx1ZSA9IDBcblx0XG5cdGNvbnN0IGNsYW1wID0gKG51bSwgbWluLCBtYXgpID0+IHtcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihudW0sIG1heCkpO1xuXHR9XG5cbiAgLy8gQHRzLWlnbm9yZVxuICAkOiB7IGlmKGNvbG91clswXSAmJiBpc05hTihlbGVtZW50c1swXSkpIHVwZGF0ZV9zdHlsZSgwKSB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgJDogeyBpZihjb2xvdXJbMV0gJiYgaXNOYU4oZWxlbWVudHNbMV0pKSB1cGRhdGVfc3R5bGUoMSkgfVxuICAvLyBAdHMtaWdub3JlXG4gICQ6IHsgaWYoY29sb3VyWzJdICYmIGlzTmFOKGVsZW1lbnRzWzJdKSkgdXBkYXRlX3N0eWxlKDIpIH1cbiAgXG4gIGNvbnN0IHVwZGF0ZV9zdHlsZSA9IChpZHg6IG51bWJlcikgPT57XG4gICAgaW5uZXJzW2lkeF0uc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlWCgke2NvbG91cltpZHhdfSlgXG4gIH1cblx0XG5cdGNvbnN0IHBvaW50ZXJNb3ZlID0gKHsgY2xpZW50WCwgY2xpZW50WSB9KSA9PiB7XG5cdFx0bGV0IHNjYWxlID0gMC4yNS9lbGVtZW50c1tjb2xvdXJfaWR4XS5jbGllbnRXaWR0aFxuXG5cdFx0bGV0IHZhbHVlRGlmZiA9IC0oc3RhcnRYIC0gY2xpZW50WCkgKnNjYWxlO1xuXHRcdGNvbG91cltjb2xvdXJfaWR4XSA9IGNsYW1wKHN0YXJ0VmFsdWUgKyB2YWx1ZURpZmYsIDAsIDEpXG4gICAgdXBkYXRlX3N0eWxlKGNvbG91cl9pZHgpXG5cdH1cblx0XG5cdGNvbnN0IHBvaW50ZXJEb3duID0gKGU6IFBvaW50ZXJFdmVudCkgPT4ge1xuICAgIGxldCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGVcblx0XHRzdGFydFkgPSBjbGllbnRZO1xuXHRcdHN0YXJ0WCA9IGNsaWVudFg7XG5cdFx0c3RhcnRWYWx1ZSA9IGNvbG91cltjb2xvdXJfaWR4XTtcbiAgICB1cGRhdGVfc3R5bGUoY29sb3VyX2lkeClcblxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHBvaW50ZXJNb3ZlKTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcG9pbnRlclVwKTtcblx0fVxuXHRcblx0Y29uc3QgcG9pbnRlclVwID0gKCkgPT4ge1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHBvaW50ZXJNb3ZlKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcG9pbnRlclVwKTtcblx0fVxuICBcbiAgb25Nb3VudCgoKT0+e1xuICAgIHVwZGF0ZV9zdHlsZSgwKVxuICAgIHVwZGF0ZV9zdHlsZSgxKVxuICAgIHVwZGF0ZV9zdHlsZSgyKVxuICB9KVxuICBcbjwvc2NyaXB0PlxuXG5cbjxkaXYgZHJhZ2dhYmxlPVwiZmFsc2VcIiBjbGFzcz0na25vYi1jb250YWluZXItY29udGFpbmVyJz5cblxuICA8IS0tIHsjfSAtLT5cbiAgeyNlYWNoIGNvbG91ciBhcyBjb2xfZWxlbWVudCwgaX1cbiAgICB7I2lmIGkgIT09IDN9XG4gICAgICA8ZGl2IGNsYXNzPSdrbm9iLWNvbnRhaW5lcidcbiAgICAgICAgb246cG9pbnRlcmRvd249eyhlKT0+e1xuICAgICAgICAgIGNvbG91cl9pZHggPSBpXG4gICAgICAgICAgcG9pbnRlckRvd24oZSlcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpIFxuICAgICAgICB9fVxuICAgICAgICBiaW5kOnRoaXM9e2VsZW1lbnRzW2ldfVxuICAgICAgPlxuICAgICAgICAgPGRpdiBjbGFzcz0naW5uZXInIFxuICAgICAgICAgIHN0eWxlPXtcbiAgICAgICAgICAgIGkgPT09IDAgPyBcImJhY2tncm91bmQ6IHJnYmEoMjU1LDAsMCwxKTtcIiA6IGkgPT09IDEgPyBcImJhY2tncm91bmQ6IHJnYmEoMCwyNTUsMCwxKTtcIiA6IFwiYmFja2dyb3VuZDogcmdiYSgwLDAsMjU1LDEpO1wiXG4gICAgICAgICAgIH1cbiAgICAgICAgICAgYmluZDp0aGlzPXtpbm5lcnNbaV19XG4gICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgey9pZn1cbiAgey9lYWNofVxuPC9kaXY+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAua25vYi1jb250YWluZXItY29udGFpbmVye1xuICAgIC8vIG1heC1oZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcbiAgICBtYXJnaW4tbGVmdDogMHB4O1xuICAgIG1hcmdpbi1yaWdodDogMHB4O1xuICAgIGFzcGVjdC1yYXRpbzogMi8xO1xuICAgIC8qIG1heC1oZWlnaHQ6IDUwJTsgKi9cbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDE0cmVtO1xuICAgIC8qIG1hcmdpbi10b3A6IDAuNXJlbTsgKi9cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICB9XG4gIC5rbm9iLWNvbnRhaW5lcntcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xuICAgIC5pbm5lcntcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQ7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIFxuICAgIH1cbiAgICBcbiAgfVxuPC9zdHlsZT4iLCI8c3ZlbHRlOm9wdGlvbnMgYWNjZXNzb3JzIC8+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IG1vZCB9IGZyb20gXCJAMGI1dnIvZXhwZXJpbWVudGFsXCJcblx0aW1wb3J0IGNocm9tYSBmcm9tIFwiY2hyb21hLWpzXCJcblx0aW1wb3J0IHsgY2xhbXAsIG1pbiB9IGZyb20gXCJ3bWF0aFwiXG5cblx0aW1wb3J0IHsgZmFkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblxuXHRleHBvcnQgbGV0IGNvbG91cjogQXJyYXk8bnVtYmVyPjtcbiAgbGV0IGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnRcblxuICBjb25zdCByZV9yZW5kZXJfY29sb3VyID0gKGNvbG91cl9yOiBudW1iZXIsIGNvbG91cl9nOiBudW1iZXIsIGNvbG91cl9iOiBudW1iZXIpPT57XG4gICAgaWYoY29udGFpbmVyKXtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1jb2xvcicsIGByZ2JhKCR7XG4gICAgICAyNTUgKiBNYXRoLnBvdyhjb2xvdXJfciwgMC40NTQ1NDU0NTQ1NDU0NTQ1NDU0NSl9LCAke1xuICAgICAgMjU1ICogTWF0aC5wb3coY29sb3VyX2csIDAuNDU0NTQ1NDU0NTQ1NDU0NTQ1NDUpfSwgJHtcbiAgICAgIDI1NSAqIE1hdGgucG93KGNvbG91cl9iLCAwLjQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1KX0sICR7XG4gICAgICAyNTUgKiBNYXRoLnBvdygxLjAsIDAuNDU0NTQ1NDU0NTQ1NDU0NTQ1NDUpfSlgKVxuICAgIH1cbiAgfVxuXHRleHBvcnQgY29uc3QgdXBkYXRlX2Rpc3BsYXkgPSAoY29sb3VyX3I6IG51bWJlciwgY29sb3VyX2c6IG51bWJlciwgY29sb3VyX2I6IG51bWJlcik9PntyZV9yZW5kZXJfY29sb3VyKGNvbG91cl9yLCBjb2xvdXJfZywgY29sb3VyX2IpfVxuICBcblx0JDogcmVfcmVuZGVyX2NvbG91cihjb2xvdXJbMF0sIGNvbG91clsxXSwgY29sb3VyWzJdKTtcblxuXHRleHBvcnQgbGV0IGRyYWdnaW5nOiBib29sZWFuID0gZmFsc2Vcblx0ZXhwb3J0IGxldCBzdG9wcGVkX2RyYWdnaW5nOiBib29sZWFuID0gZmFsc2VcblxuXHRsZXQgc3RhcnRWYWx1ZSA9IFswLCAwXVxuXHRcblx0bGV0IGlzX3ZzX2FkanVzdGluZyA9IGZhbHNlXG5cdFxuXHRsZXQgcHJldlggPSAwXG5cdGxldCBwcmV2WSA9IDBcblxuXHRjb25zdCBjaHJvbWFfZ2wgPSAoY29sOiBudW1iZXJbXSkgPT4ge1xuXHRcdHJldHVybiBjaHJvbWEuZ2woY29sWzBdLCBjb2xbMV0sIGNvbFsyXSlcblx0fVxuXHRjb25zdCBjaHJvbWFfb2tsY2ggPSAoY29sOiBudW1iZXJbXSkgPT4ge1xuXHRcdHJldHVybiBjaHJvbWEub2tsY2goY29sWzBdLCBjb2xbMV0sIGNvbFsyXSlcblx0fVxuXG5cdGNvbnN0IHBvaW50ZXJNb3ZlID0gKHtjbGllbnRYLCBjbGllbnRZfSkgPT4ge1xuXHRcdGNvbnN0IHNjYWxlID0gMS4vbWluKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgXG5cdFx0Y29uc3QgdmFsdWVEaWZmWSA9IC0oY2xpZW50WSAtIHByZXZZKVxuXHRcdGNvbnN0IHZhbHVlRGlmZlggPSBjbGllbnRYIC0gcHJldlhcblx0XHRcblx0XHRwcmV2WCA9IGNsaWVudFhcblx0XHRwcmV2WSA9IGNsaWVudFlcblxuICAgIGxldCBjb2wgPSBjaHJvbWFfZ2woY29sb3VyKS5va2xjaCgpXG5cbiAgICBjb2xbMF0gKz0gdmFsdWVEaWZmWSoxLjAqc2NhbGVcblx0XHRpZihpc192c19hZGp1c3Rpbmcpe1xuXHRcdFx0Y29sWzFdICs9IHZhbHVlRGlmZlgqMC41KnNjYWxlXG5cdFx0fSBlbHNle1xuXHRcdFx0Y29sWzJdICs9IHZhbHVlRGlmZlgqMzYwKjEuMCpzY2FsZVxuXHRcdH1cbiAgICBjb2xbMF0gPSBjbGFtcChjb2xbMF0sIDAsIDEpXG4gICAgY29sWzFdID0gY2xhbXAoY29sWzFdLCAwLCAxKVxuICAgIGNvbFsyXSA9IG1vZChjb2xbMl0sIDM2MClcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb2wgPSBjaHJvbWFfb2tsY2goY29sKS5nbCgpXG4gICAgY29sb3VyWzBdID0gY29sWzBdXG4gICAgY29sb3VyWzFdID0gY29sWzFdXG4gICAgY29sb3VyWzJdID0gY29sWzJdXG5cdH1cblxuXHRjb25zdCBwb2ludGVyRG93biA9IChlOiBQb2ludGVyRXZlbnQpID0+IHtcblx0XHRkcmFnZ2luZyA9IHRydWVcblx0XHRjb25zdCB7Y2xpZW50WCwgY2xpZW50WX0gPSBlXG5cdFx0cHJldlkgPSBjbGllbnRZXG5cdFx0cHJldlggPSBjbGllbnRYXG5cdFx0c3RhcnRWYWx1ZSA9IFtjb2xvdXJbMF0sIGNvbG91clsxXSwgY29sb3VyWzJdLCAxXVxuXG5cblx0XHRjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IHhfcmVsYXRpdmVfdG9fZWxlbWVudCA9IChlLmNsaWVudFggLSByZWN0LmxlZnQpL3JlY3Qud2lkdGg7XG5cdFx0XG5cdFx0aXNfdnNfYWRqdXN0aW5nID0geF9yZWxhdGl2ZV90b19lbGVtZW50ID4gMC41XG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBwb2ludGVyTW92ZSlcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcG9pbnRlclVwKVxuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKClcblx0fVxuXG5cdGNvbnN0IHBvaW50ZXJVcCA9ICgpID0+IHtcblx0XHRkcmFnZ2luZyA9IGZhbHNlXG5cdFx0c3RvcHBlZF9kcmFnZ2luZyA9IHRydWVcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBwb2ludGVyTW92ZSlcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgcG9pbnRlclVwKVxuXHR9XG5cdFxuPC9zY3JpcHQ+XG5cbjxkaXYgZHJhZ2dhYmxlPVwiZmFsc2VcIiBjbGFzcz0na25vYi1jb250YWluZXInIGJpbmQ6dGhpcz17Y29udGFpbmVyfSBvbjpwb2ludGVyZG93bj17cG9pbnRlckRvd259ID5cblx0eyNpZiBkcmFnZ2luZ31cblx0PGRpdiB0cmFuc2l0aW9uOmZhZGU9e3tkdXJhdGlvbjogMjAwfX0gc3R5bGU9e2BvcGFjaXR5OiAke2lzX3ZzX2FkanVzdGluZyA/IDAuNSA6IDF9O2B9PlxuXHRcdFYvSFxuXHQ8L2Rpdj5cblx0PGRpdiBzdHlsZT17YG9wYWNpdHk6ICR7aXNfdnNfYWRqdXN0aW5nID8gMSA6IDAuNX07YH0+XG5cdFx0Vi9TXG5cdDwvZGl2PlxuXHR7L2lmfVxuPC9kaXY+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAua25vYi1jb250YWluZXJ7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0d2lkdGg6IDEwcmVtO1xuICAgICY6aG92ZXJ7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuXHRcdD5kaXZ7XG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdGhlaWdodDogMTAwJTtcblx0XHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXHRcdFx0ZmlsdGVyOiBpbnZlcnQoMSk7XG5cdFx0XHRmaWx0ZXI6IGdyYXlzY2FsZSgxKTtcblx0XHRcdGNvbG9yOiBibGFjaztcblx0XHR9XG4gICAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XG4gICAgYXNwZWN0LXJhdGlvOiAxLzE7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvcik7XG5cdFx0Ly8gd2lkdGg6IDE0cmVtO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICAvLyBtYXgtaGVpZ2h0OiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgfSAgXG48L3N0eWxlPiIsIjxzdmVsdGU6b3B0aW9ucyBhY2Nlc3NvcnMgLz5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtnYWxsZXJ5X29wZW59IGZyb20gJ3N0b3JlJ1xuXHQvLyBpbXBvcnQgS25vYiBmcm9tIFwiLi9Lbm9iLnN2ZWx0ZVwiXG48L3NjcmlwdD5cblxuXG48ZGl2IGlkPSdmb3VyLWljb25zJyBzdHlsZT17JGdhbGxlcnlfb3Blbj8gIFwiZGlzcGxheTogY29udGVudHM7XCIgOiBcIlwifT5cbiAgPHNsb3Q+PC9zbG90PlxuPC9kaXY+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAjZm91ci1pY29uc3tcbiAgICAvLyB3aWR0aDogMTAwJTtcbiAgICAvLyBtYXgtaGVpZ2h0OiB1bnNldCAhaW1wb3J0YW50O1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBhc3BlY3QtcmF0aW86IDEvMTtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIC8vIGhlaWdodDogMTAwJTtcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDJmciAxZnI7XG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAxZnIgMWZyO1xuICAgIHdpZHRoOiA1cmVtO1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC43KTtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiB0b3A7XG4gICAgLy8gcGFkZGluZzogMHJlbSAxcmVtO1xuICAgIC8vIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgLy8gPiAqOmxhc3Qtb2YtdHlwZSB7XG4gICAgLy8gICBtYXJnaW4tbGVmdDogYXV0bztcbiAgICAvLyAgIG1hcmdpbi1yaWdodDogMHB4O1xuICAgIC8vIH1cbiAgICA+Omdsb2JhbChkaXY6bm90KDpmaXJzdC1vZi10eXBlKSl7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBtYXgtaGVpZ2h0OiB1bnNldDtcbiAgICAgIG1hcmdpbjogMDtcbiAgICB9XG4gICAgPjpnbG9iYWwoZGl2OmZpcnN0LW9mLXR5cGUpe1xuICAgICAgZ3JpZC1jb2x1bW46IDEgLyAtMTtcbiAgICB9XG4gIH1cbjwvc3R5bGU+IiwiaW1wb3J0IHttaW4sIHNxcnR9IGZyb20gJ3dtYXRoJ1xuXG5pbnRlcmZhY2Uga2V5U3RhdGUge1xuXHRkb3duOiBib29sZWFuXG5cdGp1c3RfcHJlc3NlZDogYm9vbGVhblxuXHRqdXN0X3VucHJlc3NlZDogYm9vbGVhblxufVxuXG50eXBlIEJ0bkNvZGUgPVxuXHR8ICdLZXlBJ1xuXHR8ICdLZXlCJ1xuXHR8ICdLZXlDJ1xuXHR8ICdLZXlEJ1xuXHR8ICdLZXlFJ1xuXHR8ICdLZXlGJ1xuXHR8ICdLZXlHJ1xuXHR8ICdLZXlIJ1xuXHR8ICdLZXlJJ1xuXHR8ICdLZXlKJ1xuXHR8ICdLZXlLJ1xuXHR8ICdLZXlMJ1xuXHR8ICdLZXlNJ1xuXHR8ICdLZXlOJ1xuXHR8ICdLZXlPJ1xuXHR8ICdLZXlQJ1xuXHR8ICdLZXlRJ1xuXHR8ICdLZXlSJ1xuXHR8ICdLZXlTJ1xuXHR8ICdLZXlUJ1xuXHR8ICdLZXlVJ1xuXHR8ICdLZXlJJ1xuXHR8ICdLZXlWJ1xuXHR8ICdLZXlXJ1xuXHR8ICdLZXlYJ1xuXHR8ICdLZXlZJ1xuXHR8ICdLZXlaJ1xuXHR8ICdEaWdpdDEnXG5cdHwgJ0RpZ2l0Midcblx0fCAnRGlnaXQzJ1xuXHR8ICdEaWdpdDQnXG5cdHwgJ0RpZ2l0NSdcblx0fCAnRGlnaXQ2J1xuXHR8ICdEaWdpdDcnXG5cdHwgJ0RpZ2l0OCdcblx0fCAnRGlnaXQ5J1xuXHR8ICdEaWdpdDAnXG5cdHwgJ0NvbnRyb2xMZWZ0J1xuXHR8ICdBbHRMZWZ0J1xuXHR8ICdTaGlmdExlZnQnXG5cdHwgJ1NwYWNlJ1xuXG5leHBvcnQgY2xhc3MgSU8ge1xuXHRwcml2YXRlIGtleXMgPSBuZXcgTWFwPEJ0bkNvZGUsIGtleVN0YXRlPigpXG5cblx0Ly8gdG91Y2hfcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSg4KVxuXHQvLyB0b3VjaF9wb3NpdGlvbnNfY250ID0gMFxuXHR0b3VjaGVzOiB7W2tleTogbnVtYmVyXTogbnVtYmVyW119ID0ge31cblx0dHdvX2Zpbmdlcl9waW5jaF9wcmV2ID0gZmFsc2Vcblx0dHdvX2Zpbmdlcl9waW5jaCA9IGZhbHNlXG5cdGp1c3RfZmluaXNoZWRfcGluY2ggPSBmYWxzZVxuXHRqdXN0X3N0YXJ0ZWRfcGluY2ggPSBmYWxzZVxuXHR0b3VjaGVzX3N0YXJ0aW5nX3Bvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoNClcblx0dG91Y2hlc19zdGFydGluZ19taWRfcG9pbnQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG5cdHRvdWNoZXNfc3RhcnRpbmdfbGVuZ3RoID0gMFxuXHR0b3VjaGVzX21pZF9wb2ludF9wcmV2ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuXHRwaW5jaF9wb3MgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG5cdHBpbmNoX3pvb20gPSAwXG5cblx0Ly8gbW91c2VfcG9zOiBBcnJheTxudW1iZXI+ID0gWzAsIDBdXG5cdG1vdXNlX3BvczogRmxvYXQzMkFycmF5ID0gRmxvYXQzMkFycmF5LmZyb20oWzAsIDBdKVxuXHRkZWx0YV9tb3VzZV9wb3M6IEZsb2F0MzJBcnJheSA9IEZsb2F0MzJBcnJheS5mcm9tKFswLCAwXSlcblx0bW91c2VfcG9zX3ByZXY6IEZsb2F0MzJBcnJheSA9IEZsb2F0MzJBcnJheS5mcm9tKFswLCAwXSlcblx0bW91c2VfZG93bjogYm9vbGVhbiA9IGZhbHNlXG5cblx0cHJpdmF0ZSBfbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lID0gbmV3IEZsb2F0MzJBcnJheSg1MClcblx0cHJpdmF0ZSBfbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2IgPSBuZXcgRmxvYXQzMkFycmF5KDUwKVxuXHRfbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2NudCA9IDBcblx0X21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZV9jbnRfYiA9IDBcblx0bW91c2VfcG9zaXRpb25zX2Fycl9pZHggPSAwXG5cblx0Z2V0IG1vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZSgpOiBGbG9hdDMyQXJyYXkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlX3Bvc2l0aW9uc19hcnJfaWR4ID09PSAwXG5cdFx0XHQ/IHRoaXMuX21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZVxuXHRcdFx0OiB0aGlzLl9tb3VzZV9wb3NpdGlvbnNfZHVyaW5nX2xhc3RfZnJhbWVfYlxuXHR9XG5cdGdldCBtb3VzZV9wb3NpdGlvbnNfZHVyaW5nX2xhc3RfZnJhbWVfY250KCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VfcG9zaXRpb25zX2Fycl9pZHggPT09IDBcblx0XHRcdD8gdGhpcy5fbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2NudFxuXHRcdFx0OiB0aGlzLl9tb3VzZV9wb3NpdGlvbnNfZHVyaW5nX2xhc3RfZnJhbWVfY250X2Jcblx0fVxuXG5cdHBvaW50ZXJUeXBlOiBzdHJpbmcgPSAnbW91c2UnXG5cblx0bW91c2VfZG93bl9wcmV2ID0gZmFsc2Vcblx0bW91c2VfanVzdF91bnByZXNzZWQgPSBmYWxzZVxuXHRtb3VzZV9qdXN0X3ByZXNzZWQgPSBmYWxzZVxuXHRtb3VzZV9qdXN0X21vdmVkID0gZmFsc2VcblxuXHRtbWJfanVzdF91bnByZXNzZWQgPSBmYWxzZVxuXHRtbWJfanVzdF9wcmVzc2VkID0gZmFsc2Vcblx0bW1iX2Rvd24gPSBmYWxzZVxuXG5cdG1vdXNlX3doZWVsOiBudW1iZXIgPSAwXG5cblx0cHJlc3N1cmU6IG51bWJlciA9IDAuMFxuXG5cdHRpbHQ6IG51bWJlcltdID0gWzAsIDBdXG5cblx0dGljaygpIHtcblx0XHR0aGlzLmRlbHRhX21vdXNlX3Bvc1swXSA9IHRoaXMubW91c2VfcG9zWzBdIC0gdGhpcy5tb3VzZV9wb3NfcHJldlswXVxuXHRcdHRoaXMuZGVsdGFfbW91c2VfcG9zWzFdID0gdGhpcy5tb3VzZV9wb3NbMV0gLSB0aGlzLm1vdXNlX3Bvc19wcmV2WzFdXG5cdFx0dGhpcy5tb3VzZV9wb3NfcHJldlswXSA9IHRoaXMubW91c2VfcG9zWzBdXG5cdFx0dGhpcy5tb3VzZV9wb3NfcHJldlsxXSA9IHRoaXMubW91c2VfcG9zWzFdXG5cblx0XHRpZiAodGhpcy5tb3VzZV9wb3NpdGlvbnNfYXJyX2lkeCA9PT0gMCkge1xuXHRcdFx0dGhpcy5fbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2NudCA9IDBcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2NudF9iID0gMFxuXHRcdH1cblx0XHR0aGlzLm1vdXNlX3Bvc2l0aW9uc19hcnJfaWR4ID0gMSAtIHRoaXMubW91c2VfcG9zaXRpb25zX2Fycl9pZHhcblxuXHRcdGlmICh0aGlzLnR3b19maW5nZXJfcGluY2ggPT09IGZhbHNlICYmIHRoaXMudHdvX2Zpbmdlcl9waW5jaF9wcmV2ID09PSB0cnVlKSB7XG5cdFx0XHR0aGlzLmp1c3RfZmluaXNoZWRfcGluY2ggPSB0cnVlXG5cdFx0fSBlbHNlIGlmICh0aGlzLnR3b19maW5nZXJfcGluY2ggPT09IHRydWUgJiYgdGhpcy50d29fZmluZ2VyX3BpbmNoX3ByZXYgPT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLmp1c3Rfc3RhcnRlZF9waW5jaCA9IHRydWVcblx0XHR9XG5cblx0XHRpZiAodGhpcy5tb3VzZV9kb3duICE9PSB0aGlzLm1vdXNlX2Rvd25fcHJldikge1xuXHRcdFx0aWYgKHRoaXMubW91c2VfZG93bikge1xuXHRcdFx0XHR0aGlzLm1vdXNlX2p1c3RfcHJlc3NlZCA9IHRydWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubW91c2VfanVzdF91bnByZXNzZWQgPSB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHRpY2tfZW5kKCkge1xuXHRcdHRoaXMubW91c2VfanVzdF9wcmVzc2VkID0gZmFsc2Vcblx0XHR0aGlzLm1vdXNlX2p1c3RfdW5wcmVzc2VkID0gZmFsc2Vcblx0XHR0aGlzLm1vdXNlX2p1c3RfbW92ZWQgPSBmYWxzZVxuXHRcdHRoaXMubW91c2VfZG93bl9wcmV2ID0gdGhpcy5tb3VzZV9kb3duXG5cdFx0dGhpcy5tbWJfanVzdF91bnByZXNzZWQgPSBmYWxzZVxuXHRcdHRoaXMubW1iX2p1c3RfcHJlc3NlZCA9IGZhbHNlXG5cdFx0dGhpcy5tb3VzZV93aGVlbCA9IDBcblx0XHR0aGlzLnR3b19maW5nZXJfcGluY2hfcHJldiA9IHRoaXMudHdvX2Zpbmdlcl9waW5jaFxuXHRcdHRoaXMuanVzdF9maW5pc2hlZF9waW5jaCA9IGZhbHNlXG5cdFx0dGhpcy5qdXN0X3N0YXJ0ZWRfcGluY2ggPSBmYWxzZVxuXHRcdE9iamVjdC52YWx1ZXModGhpcy5rZXlzKS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRcdGtleS5qdXN0X3VucHJlc3NlZCA9IGZhbHNlXG5cdFx0XHRrZXkuanVzdF9wcmVzc2VkID0gZmFsc2Vcblx0XHR9KVxuXHR9XG5cdHB1YmxpYyBnZXRLZXkoY29kZTogQnRuQ29kZSk6IGtleVN0YXRlIHtcblx0XHRjb25zdCBrZXkgPSB0aGlzLmtleXNbY29kZV1cblx0XHRpZiAoa2V5KSB7XG5cdFx0XHRyZXR1cm4ga2V5XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7ZG93bjogZmFsc2UsIGp1c3RfcHJlc3NlZDogZmFsc2UsIGp1c3RfdW5wcmVzc2VkOiBmYWxzZX1cblx0XHR9XG5cdH1cblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuXHRcdFx0dGhpcy5rZXlzW2V2ZW50LmNvZGVdID0ge2Rvd246IHRydWUsIGp1c3RfcHJlc3NlZDogdHJ1ZSwganVzdF91bnByZXNzZWQ6IGZhbHNlfVxuXHRcdFx0aWYgKGV2ZW50LmNvZGUgPT09ICdBbHRMZWZ0JykgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdH0pXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2ZW50KSA9PiB7XG5cdFx0XHRsZXQganVzdF91bnByZXNzZWQgPSBmYWxzZVxuXHRcdFx0aWYgKHRoaXMuZ2V0S2V5KGV2ZW50LmNvZGUgYXMgQnRuQ29kZSkuZG93bikganVzdF91bnByZXNzZWQgPSB0cnVlXG5cdFx0XHR0aGlzLmtleXNbZXZlbnQuY29kZV0gPSB7ZG93bjogZmFsc2UsIGp1c3RfcHJlc3NlZDogZmFsc2UsIGp1c3RfdW5wcmVzc2VkOiBqdXN0X3VucHJlc3NlZH1cblx0XHR9KVxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChlKSA9PiB7XG5cdFx0XHR0aGlzLm1vdXNlX3doZWVsID0gZS5kZWx0YVkgPCAwID8gMSA6IGUuZGVsdGFZID4gMCA/IC0xIDogMFxuXHRcdH0pXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoZSkgPT4ge1xuXHRcdFx0aWYgKGUuYnV0dG9uID09PSAxKSB7XG5cdFx0XHRcdHRoaXMubW1iX2Rvd24gPSBmYWxzZVxuXHRcdFx0XHR0aGlzLm1tYl9qdXN0X3VucHJlc3NlZCA9IHRydWVcblx0XHRcdH1cblx0XHR9KVxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4ge1xuXHRcdFx0aWYgKGUuYnV0dG9uID09PSAxKSB7XG5cdFx0XHRcdHRoaXMubW1iX2Rvd24gPSB0cnVlXG5cdFx0XHRcdHRoaXMubW1iX2p1c3RfcHJlc3NlZCA9IHRydWVcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHR9XG5cdFx0fSlcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoKSA9PiB7XG5cdFx0XHRjb25zdCBsX2FsdCA9IHRoaXMuZ2V0S2V5KCdBbHRMZWZ0Jylcblx0XHRcdGlmIChsX2FsdC5kb3duKSB7XG5cdFx0XHRcdGxfYWx0Lmp1c3RfdW5wcmVzc2VkID0gdHJ1ZVxuXHRcdFx0XHRsX2FsdC5kb3duID0gZmFsc2Vcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgKGUpID0+IHtcblx0XHRcdGNvbnN0IGdldFJlbGF0aXZlTW91c2VQb3NpdGlvbiA9IChldmVudDogUG9pbnRlckV2ZW50LCB0YXJnZXQpID0+IHtcblx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0IHx8IGV2ZW50LnRhcmdldFxuXHRcdFx0XHRjb25zdCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR4OiBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxuXHRcdFx0XHRcdHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCxcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uc3QgZ2V0Tm9QYWRkaW5nTm9Cb3JkZXJDYW52YXNSZWxhdGl2ZU1vdXNlUG9zaXRpb24gPSAoZXZlbnQ6IFBvaW50ZXJFdmVudCwgdGFyZ2V0KSA9PiB7XG5cdFx0XHRcdHRhcmdldCA9IHRhcmdldCB8fCBldmVudC50YXJnZXRcblx0XHRcdFx0Y29uc3QgcG9zID0gZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCB0YXJnZXQpXG5cblx0XHRcdFx0cG9zLnggPSAocG9zLnggKiB0YXJnZXQud2lkdGgpIC8gdGFyZ2V0LmNsaWVudFdpZHRoXG5cdFx0XHRcdHBvcy55ID0gKHBvcy55ICogdGFyZ2V0LmhlaWdodCkgLyB0YXJnZXQuY2xpZW50SGVpZ2h0XG5cblx0XHRcdFx0cmV0dXJuIHBvc1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgKGUucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhlKVxuXHRcdFx0Y29uc3QgZ2wgPSB3aW5kb3cuZ2xcblx0XHRcdGNvbnN0IHBvcyA9IGdldE5vUGFkZGluZ05vQm9yZGVyQ2FudmFzUmVsYXRpdmVNb3VzZVBvc2l0aW9uKGUsIGdsLmNhbnZhcylcblxuXHRcdFx0Y29uc3QgeCA9IChwb3MueCAvIGdsLmNhbnZhcy53aWR0aCkgKiAyIC0gMVxuXHRcdFx0Y29uc3QgeSA9IChwb3MueSAvIGdsLmNhbnZhcy5oZWlnaHQpICogLTIgKyAxXG5cblx0XHRcdC8vIHRoaXMubW91c2VfcG9zID0gW3gsIHldXG5cdFx0XHR0aGlzLm1vdXNlX3Bvc1swXSA9IHhcblx0XHRcdHRoaXMubW91c2VfcG9zWzFdID0geVxuXG5cdFx0XHRjb25zdCBpc19iYWNrID0gdGhpcy5tb3VzZV9wb3NpdGlvbnNfYXJyX2lkeCA9PT0gMFxuXHRcdFx0Y29uc3QgcG9zaXRpb25zID0gaXNfYmFjayA/IHRoaXMuX21vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZV9iIDogdGhpcy5fbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lXG5cdFx0XHRjb25zdCBpZHggPSBpc19iYWNrID8gdGhpcy5fbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2NudF9iIDogdGhpcy5fbW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lX2NudFxuXHRcdFx0cG9zaXRpb25zW2lkeCAqIDJdID0geFxuXHRcdFx0cG9zaXRpb25zW2lkeCAqIDIgKyAxXSA9IHlcblx0XHRcdGlmIChpc19iYWNrKSB0aGlzLl9tb3VzZV9wb3NpdGlvbnNfZHVyaW5nX2xhc3RfZnJhbWVfY250X2IrK1xuXHRcdFx0ZWxzZSB0aGlzLl9tb3VzZV9wb3NpdGlvbnNfZHVyaW5nX2xhc3RfZnJhbWVfY250KytcblxuXHRcdFx0dGhpcy5wcmVzc3VyZSA9IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgPyAxIDogZS5wcmVzc3VyZSA/PyB0aGlzLnByZXNzdXJlXG5cdFx0XHR0aGlzLm1vdXNlX2p1c3RfbW92ZWQgPSB0cnVlXG5cblx0XHRcdHRoaXMudGlsdFswXSA9IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgPyAwIDogZS5hbHRpdHVkZUFuZ2xlID8/IHRoaXMudGlsdFswXVxuXHRcdFx0dGhpcy50aWx0WzFdID0gZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyA/IDAgOiBlLmF6aW11dGhBbmdsZSA/PyB0aGlzLnRpbHRbMV1cblx0XHR9KVxuXG5cdFx0Y29uc3QgY2FudmFzX2VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKSBhcyBIVE1MQ2FudmFzRWxlbWVudFxuXHRcdGNhbnZhc19lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAoZSkgPT4ge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlLnRhcmdldFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgdG91Y2ggPSBlLnRhcmdldFRvdWNoZXNbaV1cblx0XHRcdFx0Y29uc3QgdG91Y2hfaWQgPSB0b3VjaC5pZGVudGlmaWVyXG5cdFx0XHRcdHRoaXMudG91Y2hlc1t0b3VjaF9pZF0gPSBbdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WV1cblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0Y29uc3QgbGVuZ3RoID0gKGF4OiBudW1iZXIsIGF5OiBudW1iZXIsIGJ4OiBudW1iZXIsIGJ5OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuXHRcdFx0cmV0dXJuIHNxcnQoKGF4IC0gYngpICogKGF4IC0gYngpICsgKGF5IC0gYnkpICogKGF5IC0gYnkpKVxuXHRcdH1cblxuXHRcdGNhbnZhc19lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIChlKSA9PiB7XG5cdFx0XHRpZiAoZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PT0gMikge1xuXHRcdFx0XHRpZiAodGhpcy50d29fZmluZ2VyX3BpbmNoID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdC8vIGJlZ2luIHBpbmNoXG5cdFx0XHRcdFx0dGhpcy50b3VjaGVzX3N0YXJ0aW5nX3Bvc2l0aW9uc1swXSA9IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYXG5cdFx0XHRcdFx0dGhpcy50b3VjaGVzX3N0YXJ0aW5nX3Bvc2l0aW9uc1sxXSA9IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZXG5cdFx0XHRcdFx0dGhpcy50b3VjaGVzX3N0YXJ0aW5nX3Bvc2l0aW9uc1syXSA9IGUudGFyZ2V0VG91Y2hlc1sxXS5jbGllbnRYXG5cdFx0XHRcdFx0dGhpcy50b3VjaGVzX3N0YXJ0aW5nX3Bvc2l0aW9uc1szXSA9IGUudGFyZ2V0VG91Y2hlc1sxXS5jbGllbnRZXG5cdFx0XHRcdFx0dGhpcy50b3VjaGVzX3N0YXJ0aW5nX21pZF9wb2ludFswXSA9IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYICogMC41ICsgZS50YXJnZXRUb3VjaGVzWzFdLmNsaWVudFggKiAwLjVcblx0XHRcdFx0XHR0aGlzLnRvdWNoZXNfc3RhcnRpbmdfbWlkX3BvaW50WzFdID0gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkgKiAwLjUgKyBlLnRhcmdldFRvdWNoZXNbMV0uY2xpZW50WSAqIDAuNVxuXHRcdFx0XHRcdHRoaXMucGluY2hfem9vbSA9IDBcblx0XHRcdFx0XHR0aGlzLnRvdWNoZXNfc3RhcnRpbmdfbGVuZ3RoID0gbGVuZ3RoKFxuXHRcdFx0XHRcdFx0ZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFgsXG5cdFx0XHRcdFx0XHRlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WSxcblx0XHRcdFx0XHRcdGUudGFyZ2V0VG91Y2hlc1sxXS5jbGllbnRYLFxuXHRcdFx0XHRcdFx0ZS50YXJnZXRUb3VjaGVzWzFdLmNsaWVudFksXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdHRoaXMudG91Y2hlc19taWRfcG9pbnRfcHJldlswXSA9IHRoaXMudG91Y2hlc19zdGFydGluZ19taWRfcG9pbnRbMF1cblx0XHRcdFx0XHR0aGlzLnRvdWNoZXNfbWlkX3BvaW50X3ByZXZbMV0gPSB0aGlzLnRvdWNoZXNfc3RhcnRpbmdfbWlkX3BvaW50WzFdXG5cdFx0XHRcdFx0dGhpcy5waW5jaF9wb3NbMF0gPSAwXG5cdFx0XHRcdFx0dGhpcy5waW5jaF9wb3NbMV0gPSAwXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50d29fZmluZ2VyX3BpbmNoID0gdHJ1ZVxuXHRcdFx0XHRjb25zdCBtaWRfcG9pbnRfeCA9IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYICogMC41ICsgZS50YXJnZXRUb3VjaGVzWzFdLmNsaWVudFggKiAwLjVcblx0XHRcdFx0Y29uc3QgbWlkX3BvaW50X3kgPSBlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WSAqIDAuNSArIGUudGFyZ2V0VG91Y2hlc1sxXS5jbGllbnRZICogMC41XG5cblx0XHRcdFx0Y29uc3QgbGVuID0gbGVuZ3RoKFxuXHRcdFx0XHRcdGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYLFxuXHRcdFx0XHRcdGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZLFxuXHRcdFx0XHRcdGUudGFyZ2V0VG91Y2hlc1sxXS5jbGllbnRYLFxuXHRcdFx0XHRcdGUudGFyZ2V0VG91Y2hlc1sxXS5jbGllbnRZLFxuXHRcdFx0XHQpXG5cdFx0XHRcdGNvbnN0IHJlcyA9IG1pbih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KVxuXHRcdFx0XHR0aGlzLnBpbmNoX3pvb20gPSAoKGxlbiAtIHRoaXMudG91Y2hlc19zdGFydGluZ19sZW5ndGgpIC8gcmVzKSAqIDRcblxuXHRcdFx0XHR0aGlzLnBpbmNoX3Bvc1swXSArPSAoKChtaWRfcG9pbnRfeCAtIHRoaXMudG91Y2hlc19taWRfcG9pbnRfcHJldlswXSkgLyByZXMpICogMikgLyB3aW5kb3cuem9vbVswXVxuXHRcdFx0XHR0aGlzLnBpbmNoX3Bvc1sxXSArPSAoKChtaWRfcG9pbnRfeSAtIHRoaXMudG91Y2hlc19taWRfcG9pbnRfcHJldlsxXSkgLyByZXMpICogMikgLyB3aW5kb3cuem9vbVswXVxuXHRcdFx0XHR0aGlzLnRvdWNoZXNfbWlkX3BvaW50X3ByZXZbMF0gPSBtaWRfcG9pbnRfeFxuXHRcdFx0XHR0aGlzLnRvdWNoZXNfbWlkX3BvaW50X3ByZXZbMV0gPSBtaWRfcG9pbnRfeVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMudHdvX2Zpbmdlcl9waW5jaCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHRoaXMudHdvX2Zpbmdlcl9waW5jaCA9IGZhbHNlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0Y29uc3QgdG91Y2hfZW5kID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcblx0XHRcdGZvciAoY29uc3QgaWQgaW4gT2JqZWN0LmtleXModGhpcy50b3VjaGVzKSkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy50b3VjaGVzW2lkXVxuXHRcdFx0fVxuXHRcdFx0dGhpcy50d29fZmluZ2VyX3BpbmNoID0gZmFsc2Vcblx0XHR9XG5cblx0XHRjYW52YXNfZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIChlKSA9PiB7XG5cdFx0XHR0b3VjaF9lbmQoZSlcblx0XHR9KVxuXHRcdGNhbnZhc19lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKGUpID0+IHtcblx0XHRcdHRvdWNoX2VuZChlKVxuXHRcdH0pXG5cblx0XHRjYW52YXNfZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIChlKSA9PiB7XG5cdFx0XHR0aGlzLnBvaW50ZXJUeXBlID0gZS5wb2ludGVyVHlwZVxuXHRcdFx0aWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgJiYgZS5idXR0b24gIT09IDApIHJldHVyblxuXHRcdFx0dGhpcy5tb3VzZV9kb3duID0gdHJ1ZVxuXHRcdH0pXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsICgpID0+IHtcblx0XHRcdHRoaXMubW91c2VfZG93biA9IGZhbHNlXG5cdFx0fSlcblx0fVxufVxuIiwiaW1wb3J0IHtwYXVzZV9vbl9nbF9lcnJvcn0gZnJvbSAnZ2xfdXRpbHMnXG5pbXBvcnQge3R5cGUgQXR0cmliUG9pbnRlclBhcmFtc30gZnJvbSAnLi9UaGluZydcblxuZXhwb3J0IGNsYXNzIFVCTyB7XG5cdC8vIGJ1ZmY6IFdlYkdMQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCkgYXMgV2ViR0xCdWZmZXJcblx0YnVmZjogVmVydGV4QnVmZmVyXG5cdHVuaWZvcm1zOiAobnVtYmVyIHwgc3RyaW5nKVtdID0gW11cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0Ly8gZ2wuYmluZEJ1ZmZlcihnbC5VTklGT1JNX0JVRkZFUiwgdGhpcy5idWZmKVxuXHRcdC8vIGdsLmJ1ZmZlckRhdGEoZ2wuVU5JRk9STV9CVUZGRVIsIDMyICogNCwgZ2wuRFlOQU1JQ19EUkFXKVxuXHRcdC8vIHRoaXMuYnVmZiA9IG5ldyBWZXJ0ZXhCdWZmZXIoMCwgZ2wuRkxPQVQsIDMyICogNCAqIDQgKiA0LCBnbC5VTklGT1JNX0JVRkZFUilcblx0XHR0aGlzLmJ1ZmYgPSBuZXcgVmVydGV4QnVmZmVyKDAsIGdsLkZMT0FULCA5NiwgZ2wuVU5JRk9STV9CVUZGRVIpXG5cdFx0Z2wuYmluZEJ1ZmZlckJhc2UoZ2wuVU5JRk9STV9CVUZGRVIsIDAsIHRoaXMuYnVmZi5idWZmKVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBWZXJ0ZXhCdWZmZXIge1xuXHRidWZmOiBXZWJHTEJ1ZmZlclxuXG5cdGNwdV9idWZmOiBGbG9hdDMyQXJyYXkgfCBJbnQzMkFycmF5IHwgVWludDMyQXJyYXlcblx0dHlwZTogbnVtYmVyXG5cdHVzYWdlOiBudW1iZXJcblxuXHRzdHJpZGU6IG51bWJlclxuXHRzaW5nbGVfdmVydF9zejogbnVtYmVyXG5cdHN6OiBudW1iZXJcblx0bWF4X3N6OiBudW1iZXJcblxuXHRjb25zdHJ1Y3RvcihzaW5nbGVfdmVydF9zejogbnVtYmVyLCB0eXBlOiBudW1iZXIgPSBnbC5GTE9BVCwgbWF4X3NpemU6IG51bWJlciA9IDEwMDAwMDAwLCB1c2FnZTogbnVtYmVyID0gZ2wuQVJSQVlfQlVGRkVSKSB7XG5cdFx0dGhpcy5idWZmID0gZ2wuY3JlYXRlQnVmZmVyKCkgYXMgV2ViR0xCdWZmZXJcblx0XHR0aGlzLnVzYWdlID0gdXNhZ2Vcblx0XHRnbC5iaW5kQnVmZmVyKHVzYWdlLCB0aGlzLmJ1ZmYpXG5cdFx0dGhpcy50eXBlID0gdHlwZVxuXG5cdFx0dGhpcy5zaW5nbGVfdmVydF9zeiA9IHNpbmdsZV92ZXJ0X3N6XG5cdFx0dGhpcy5tYXhfc3ogPSBtYXhfc2l6ZVxuXHRcdHRoaXMuc3RyaWRlID0gMFxuXG5cdFx0aWYgKHR5cGUgPT09IGdsLkZMT0FUKSB7XG5cdFx0XHR0aGlzLmNwdV9idWZmID0gbmV3IEZsb2F0MzJBcnJheShtYXhfc2l6ZSlcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IGdsLklOVCkge1xuXHRcdFx0dGhpcy5jcHVfYnVmZiA9IG5ldyBJbnQzMkFycmF5KG1heF9zaXplKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNwdV9idWZmID0gbmV3IFVpbnQzMkFycmF5KG1heF9zaXplKVxuXHRcdH1cblxuXHRcdC8vIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNwdV9idWZmLCBnbC5EWU5BTUlDX0RSQVcpXG5cdFx0Ly8gZ2wuYnVmZmVyRGF0YSh1c2FnZSwgdGhpcy5jcHVfYnVmZi5sZW5ndGggKiB0aGlzLmNwdV9idWZmLkJZVEVTX1BFUl9FTEVNRU5ULCBnbC5EWU5BTUlDX0RSQVcpXG5cdFx0Z2wuYnVmZmVyRGF0YSh1c2FnZSwgdGhpcy5jcHVfYnVmZi5ieXRlTGVuZ3RoLCBnbC5EWU5BTUlDX0RSQVcpXG5cdFx0dGhpcy5zeiA9IDBcblx0fVxuXG5cdGJpbmRUb0F0dHJpYihpZHg6IG51bWJlciwgcGFyYW1zOiBBdHRyaWJQb2ludGVyUGFyYW1zIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHBhcmFtcykge1xuXHRcdFx0Z2wuYmluZEJ1ZmZlcih0aGlzLnVzYWdlLCB0aGlzLmJ1ZmYpXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuXHRcdFx0XHRpZHgsXG5cdFx0XHRcdHBhcmFtcy52ZXJ0X3N6ID8/IHRoaXMuc2luZ2xlX3ZlcnRfc3osXG5cdFx0XHRcdHBhcmFtcy50eXBlID8/IHRoaXMudHlwZSxcblx0XHRcdFx0ZmFsc2UsXG5cdFx0XHRcdHBhcmFtcy5zdHJpZGUgPz8gdGhpcy5zdHJpZGUsXG5cdFx0XHRcdHBhcmFtcy5vZmZzZXQgPz8gMCxcblx0XHRcdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2wuYmluZEJ1ZmZlcih0aGlzLnVzYWdlLCB0aGlzLmJ1ZmYpXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGlkeCwgdGhpcy5zaW5nbGVfdmVydF9zeiwgdGhpcy50eXBlLCBmYWxzZSwgdGhpcy5zdHJpZGUsIDApXG5cdFx0fVxuXHR9XG5cdHB1c2hfdmVydCh2ZXJ0OiBudW1iZXJbXSkge1xuXHRcdGlmICh2ZXJ0Lmxlbmd0aCAhPT0gdGhpcy5zaW5nbGVfdmVydF9zeikge1xuXHRcdFx0Ly8gZGVidWdnZXJcblx0XHR9XG5cdFx0Zm9yIChsZXQgdiBvZiB2ZXJ0KSB7XG5cdFx0XHR0aGlzLmNwdV9idWZmW3RoaXMuc3orK10gPSB2XG5cdFx0fVxuXHR9XG5cdHVwbG9hZF9leHRlcm5hbF9hcnJheShpbnB1dF9idWZmOiBudW1iZXJbXSB8IEZsb2F0MzJBcnJheSkge1xuXHRcdGlmIChpbnB1dF9idWZmIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGdsLmJpbmRCdWZmZXIodGhpcy51c2FnZSwgdGhpcy5idWZmKVxuXHRcdFx0bGV0IF9idWZmID0gRmxvYXQzMkFycmF5LmZyb20oaW5wdXRfYnVmZilcblx0XHRcdHRoaXMuc3ogPSBfYnVmZi5sZW5ndGhcblx0XHRcdC8vIGNvbnN0IHN6X2luX2J5dGVzID0gX2J1ZmYubGVuZ3RoICogX2J1ZmYuQllURVNfUEVSX0VMRU1FTlRcblx0XHRcdGNvbnN0IHN6X2luX2J5dGVzID0gX2J1ZmYuYnl0ZUxlbmd0aFxuXG5cdFx0XHQvLyBjb25zb2xlLmxvZygnQkVHSU4gQlVGRiBQUklOVCcpXG5cdFx0XHQvLyBjb25zb2xlLmxvZyhfYnVmZilcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdsZW4nKVxuXHRcdFx0Ly8gY29uc29sZS5sb2coX2J1ZmYubGVuZ3RoKVxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ3N6IGJ5ZXMnKVxuXHRcdFx0Ly8gY29uc29sZS5sb2coc3pfaW5fYnl0ZXMpXG5cdFx0XHQvLyBpZiAoX2J1ZmYubGVuZ3RoID4gMCkgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIF9idWZmLCBnbC5EWU5BTUlDX0RSQVcsIDAsIHN6X2luX2J5dGVzKVxuXHRcdFx0Ly8gaWYgKF9idWZmLmxlbmd0aCA+IDApIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBfYnVmZiwgZ2wuRFlOQU1JQ19EUkFXLCAwKVxuXHRcdFx0Ly8gaWYgKF9idWZmLmxlbmd0aCA+IDApIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBfYnVmZiwgZ2wuRFlOQU1JQ19EUkFXLCAwLCBzel9pbl9ieXRlcylcblx0XHRcdC8vIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBfYnVmZiwgZ2wuRFlOQU1JQ19EUkFXLCAwLCBzel9pbl9ieXRlcylcblxuXHRcdFx0Ly8gZ2wuYnVmZmVyU3ViRGF0YSh0aGlzLnVzYWdlLCAwLCBfYnVmZiwgMCwgc3pfaW5fYnl0ZXMpXG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKHRoaXMudXNhZ2UsIDAsIF9idWZmKVxuXHRcdFx0cGF1c2Vfb25fZ2xfZXJyb3IoKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRnbC5iaW5kQnVmZmVyKHRoaXMudXNhZ2UsIHRoaXMuYnVmZilcblx0XHRcdC8vIGNvbnN0IHN6X2luX2J5dGVzID0gaW5wdXRfYnVmZi5sZW5ndGggKiBpbnB1dF9idWZmLkJZVEVTX1BFUl9FTEVNRU5UXG5cdFx0XHRjb25zdCBzel9pbl9ieXRlcyA9IGlucHV0X2J1ZmYuYnl0ZUxlbmd0aFxuXHRcdFx0Ly8gZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGlucHV0X2J1ZmYsIGdsLkRZTkFNSUNfRFJBVywgMCwgc3pfaW5fYnl0ZXMpXG5cdFx0XHQvLyBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgaW5wdXRfYnVmZiwgMCwgc3pfaW5fYnl0ZXMpXG5cdFx0XHQvLyBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgc3pfaW5fYnl0ZXMsIGdsLkRZTkFNSUNfRFJBVylcblx0XHRcdC8vIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCBpbnB1dF9idWZmLCAwLCBzel9pbl9ieXRlcylcblx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEodGhpcy51c2FnZSwgMCwgaW5wdXRfYnVmZilcblxuXHRcdFx0Ly8gZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsMCwgaW5wdXRfYnVmZi5idWZmZXIsIGdsLkRZTkFNSUNfRFJBVylcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdC8vIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBpbnB1dF9idWZmLmJ1ZmZlciwgZ2wuRFlOQU1JQ19EUkFXKVxuXHRcdFx0cGF1c2Vfb25fZ2xfZXJyb3IoKVxuXHRcdH1cblx0fVxuXHR1cGxvYWQoKSB7XG5cdFx0Z2wuYmluZEJ1ZmZlcih0aGlzLnVzYWdlLCB0aGlzLmJ1ZmYpXG5cdFx0Y29uc3Qgc3pfaW5fYnl0ZXMgPSB0aGlzLnN6ICogdGhpcy5jcHVfYnVmZi5CWVRFU19QRVJfRUxFTUVOVFxuXHRcdC8vIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNwdV9idWZmLCBnbC5EWU5BTUlDX0RSQVcsIDAsIHN6X2luX2J5dGVzKVxuXHRcdGdsLmJ1ZmZlclN1YkRhdGEodGhpcy51c2FnZSwgMCwgdGhpcy5jcHVfYnVmZiwgMCwgc3pfaW5fYnl0ZXMpXG5cdFx0cGF1c2Vfb25fZ2xfZXJyb3IoKVxuXHR9XG59XG4iLCJpbXBvcnQge1RleHR1cmV9IGZyb20gJy4vVGV4dHVyZSdcblxuZXhwb3J0IGNsYXNzIFNoYWRlclByb2dyYW0ge1xuXHRwcm9ncmFtOiBXZWJHTFByb2dyYW1cblx0bG9hZFNoYWRlcih0eXBlOiBudW1iZXIsIHNvdXJjZTogc3RyaW5nKSB7XG5cdFx0c291cmNlID0gc291cmNlLnJlcGxhY2VBbGwoJ2V4cG9ydCBkZWZhdWx0IFwiJywgYGApXG5cdFx0c291cmNlID0gc291cmNlLnJlcGxhY2VBbGwoJ1wiOycsIGBgKVxuXHRcdHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlQWxsKCdcIicsIGBgKVxuXHRcdHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlQWxsKFxuXHRcdFx0YFxcXFxuYCxcblx0XHRcdGBcblx0XHRgLFxuXHRcdClcblx0XHRzb3VyY2UgPSBzb3VyY2UucmVwbGFjZShcblx0XHRcdC8oLiopKCN2ZXJzaW9uIDMwMCBlcylbXFx0XFxzXSovZyxcblx0XHRcdGAkMlxuXHRcdFx0YCxcblx0XHQpXG5cdFx0c291cmNlID0gc291cmNlLnJlcGxhY2VBbGwoXG5cdFx0XHQvKCNkZWZpbmUgLispW1xcdFxcc10qL2csXG5cdFx0XHRgXG5cdFx0JDFcblx0XHRgLFxuXHRcdClcblx0XHRzb3VyY2UgPSBzb3VyY2UucmVwbGFjZUFsbChcblx0XHRcdC9cdCtwcmVjaXNpb24gaGlnaHAgZmxvYXQ7L2dtLFxuXHRcdFx0YHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblx0XHRcdGAsXG5cdFx0KVxuXHRcdHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlQWxsKGBcXFxcdGAsIGBcdGApXG5cdFx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpIGFzIFdlYkdMU2hhZGVyXG5cblx0XHRnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpXG5cdFx0Z2wuY29tcGlsZVNoYWRlcihzaGFkZXIpXG5cdFx0aWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEFuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgc2hhZGVyczogJHtnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcil9YClcblx0XHRcdGNvbnNvbGUuZXJyb3Ioc291cmNlKVxuXHRcdH1cblx0XHRyZXR1cm4gc2hhZGVyXG5cdH1cblx0Y29uc3RydWN0b3IodnM6IHN0cmluZywgZnM6IHN0cmluZykge1xuXHRcdGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMubG9hZFNoYWRlcihnbC5WRVJURVhfU0hBREVSLCB2cylcblx0XHRjb25zdCBmcmFnbWVudFNoYWRlciA9IHRoaXMubG9hZFNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIsIGZzKVxuXG5cdFx0Y29uc3Qgc2hhZGVyUHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKSBhcyBXZWJHTFByb2dyYW1cblx0XHRnbC5hdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgdmVydGV4U2hhZGVyKVxuXHRcdGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCBmcmFnbWVudFNoYWRlcilcblx0XHRnbC5saW5rUHJvZ3JhbShzaGFkZXJQcm9ncmFtKVxuXG5cdFx0aWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlclByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihgVW5hYmxlIHRvIGluaXRpYWxpemUgdGhlIHNoYWRlciBwcm9ncmFtOiAke2dsLmdldFByb2dyYW1JbmZvTG9nKHNoYWRlclByb2dyYW0pfWApXG5cdFx0XHRjb25zb2xlLmVycm9yKHZzKVxuXHRcdFx0Y29uc29sZS5lcnJvcihmcylcblx0XHR9XG5cblx0XHR0aGlzLnByb2dyYW0gPSBzaGFkZXJQcm9ncmFtXG5cdFx0Z2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pXG5cdFx0Z2wudW5pZm9ybUJsb2NrQmluZGluZyh0aGlzLnByb2dyYW0sIDAsIDApXG5cdH1cblx0dXNlKCkge1xuXHRcdGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKVxuXHR9XG5cdHNldFVuaWZvcm1WZWMobmFtZTogc3RyaW5nLCB2ZWM6IG51bWJlcltdKSB7XG5cdFx0aWYgKHZlYy5sZW5ndGggPT0gMikgZ2wudW5pZm9ybTJmdihnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKSwgdmVjKVxuXHRcdGVsc2UgaWYgKHZlYy5sZW5ndGggPT0gMykgZ2wudW5pZm9ybTNmdihnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKSwgdmVjKVxuXHRcdGVsc2UgaWYgKHZlYy5sZW5ndGggPT0gNCkgZ2wudW5pZm9ybTRmdihnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKSwgdmVjKVxuXHR9XG5cdHNldFVuaWZvcm1GbG9hdChuYW1lOiBzdHJpbmcsIHZhbHVlOiBudW1iZXIpIHtcblx0XHRnbC51bmlmb3JtMWYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSksIHZhbHVlKVxuXHR9XG5cdHNldFVuaWZvcm1JbnQobmFtZTogc3RyaW5nLCB2YWx1ZTogbnVtYmVyKSB7XG5cdFx0Z2wudW5pZm9ybTFpKGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpLCB2YWx1ZSlcblx0fVxuXHRzZXRVbmlmb3JtVGV4dHVyZShuYW1lOiBzdHJpbmcsIHRleHR1cmU6IFRleHR1cmUsIGJpbmRpbmc6IG51bWJlciA9IDApIHtcblx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgYmluZGluZylcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLnRleClcblx0XHRnbC51bmlmb3JtMWkoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSksIGJpbmRpbmcpXG5cdH1cbn1cbiIsImltcG9ydCB7VmVydGV4QnVmZmVyfSBmcm9tICcuL0J1ZmZlcidcbmltcG9ydCB7U2hhZGVyUHJvZ3JhbX0gZnJvbSAnLi9TaGFkZXJQcm9ncmFtJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEJ1ZmZCaW5kaW5nIHtcblx0YnVmZjogVmVydGV4QnVmZmVyXG5cdHBhcmFtcz86IEF0dHJpYlBvaW50ZXJQYXJhbXNcbn1cbmV4cG9ydCBpbnRlcmZhY2UgQXR0cmliUG9pbnRlclBhcmFtcyB7XG5cdHZlcnRfc3o/OiBudW1iZXJcblx0c3RyaWRlPzogbnVtYmVyXG5cdHR5cGU/OiBudW1iZXJcblx0b2Zmc2V0PzogbnVtYmVyXG59XG5leHBvcnQgaW50ZXJmYWNlIERyYXdQYXJhbXMge1xuXHRwcmltX3R5cGU/OiBudW1iZXJcblx0ZHJhd19jbnQ/OiBudW1iZXJcbn1cblxuZXhwb3J0IGNsYXNzIFRoaW5nIHtcblx0dmFvOiBXZWJHTFZlcnRleEFycmF5T2JqZWN0XG5cdGJ1ZmZzOiBWZXJ0ZXhCdWZmZXJbXVxuXHRzaGFkZXI6IFNoYWRlclByb2dyYW1cblx0cHJpbV90eXBlOiBudW1iZXJcblxuXHRjb25zdHJ1Y3RvcihidWZmczogVmVydGV4QnVmZmVyW10sIHByaW1fdHlwZTogbnVtYmVyID0gZ2wuVFJJQU5HTEVTLCBzaGFkZXI6IFNoYWRlclByb2dyYW0pIHtcblx0XHR0aGlzLnByaW1fdHlwZSA9IHByaW1fdHlwZVxuXHRcdHRoaXMuc2hhZGVyID0gc2hhZGVyXG5cdFx0dGhpcy52YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpIGFzIFdlYkdMVmVydGV4QXJyYXlPYmplY3Rcblx0XHR0aGlzLmJ1ZmZzID0gWy4uLmJ1ZmZzXVxuXHRcdGdsLmJpbmRWZXJ0ZXhBcnJheSh0aGlzLnZhbylcblx0XHRsZXQgaSA9IDBcblx0XHRmb3IgKGxldCBidWZmIG9mIHRoaXMuYnVmZnMpIHtcblx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG5cdFx0XHRidWZmLmJpbmRUb0F0dHJpYihpKVxuXHRcdFx0aSsrXG5cdFx0fVxuXHR9XG5cdHN0YXRpYyBkcmF3X2V4dGVybmFsX2J1ZmZzX2FuZF9zaGFkZXIoYnVmZnM6IEJ1ZmZCaW5kaW5nW10sIHNoYWRlcjogU2hhZGVyUHJvZ3JhbSwgcGFyYW1zOiBEcmF3UGFyYW1zKSB7XG5cdFx0c2hhZGVyLnVzZSgpXG5cdFx0Ly8gZ2wuYmluZFZlcnRleEFycmF5KGdsLmRlZmF1bHRWYW8pXG5cdFx0Ly8gZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KDApXG5cdFx0Ly8gZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KDEpXG5cdFx0bGV0IGkgPSAwXG5cdFx0Ly8gZm9yIChsZXQgYnVmZiBvZiBidWZmcykge1xuXHRcdC8vIFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSlcblx0XHQvLyBcdGJ1ZmYuYnVmZi5iaW5kVG9BdHRyaWIoaSwgYnVmZi5wYXJhbXMgPz8gdW5kZWZpbmVkKVxuXHRcdC8vIFx0aSsrXG5cdFx0Ly8gfVxuXHRcdHBhcmFtcy5wcmltX3R5cGUgPSBwYXJhbXMucHJpbV90eXBlID8/IGdsLlRSSUFOR0xFU1xuXHRcdHBhcmFtcy5kcmF3X2NudCA9IHBhcmFtcy5kcmF3X2NudCA/PyBidWZmc1swXS5idWZmLnN6IC8gYnVmZnNbMF0uYnVmZi5zaW5nbGVfdmVydF9zelxuXG5cdFx0aWYgKHBhcmFtcy5wcmltX3R5cGUgPT09IGdsLlRSSUFOR0xFUykge1xuXHRcdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIHBhcmFtcy5kcmF3X2NudClcblx0XHRcdGNvbnNvbGUubG9nKCdEUkVXJylcblx0XHRcdGNvbnNvbGUubG9nKHBhcmFtcy5kcmF3X2NudClcblx0XHR9IGVsc2Uge1xuXHRcdFx0YWxlcnQoJ2JsZWVwIGJsb29wIGVycnJvcnJyJylcblx0XHR9XG5cdH1cblxuXHR1cGxvYWRfYWxsX2J1ZmZzKCkge1xuXHRcdGZvciAobGV0IGJ1ZmYgb2YgdGhpcy5idWZmcykge1xuXHRcdFx0YnVmZi51cGxvYWQoKVxuXHRcdH1cblx0fVxuXHRkcmF3X3dpdGhfZXh0ZXJuYWxfc2hhZGVyKHNoYWRlcjogU2hhZGVyUHJvZ3JhbSkge1xuXHRcdHNoYWRlci51c2UoKVxuXHRcdGlmICh0aGlzLnByaW1fdHlwZSA9PT0gZ2wuVFJJQU5HTEVTKSB7XG5cdFx0XHRsZXQgZHJhd19jbnQgPSB0aGlzLmJ1ZmZzWzBdLnN6IC8gdGhpcy5idWZmc1swXS5zaW5nbGVfdmVydF9zelxuXHRcdFx0Z2wuZHJhd0FycmF5cyh0aGlzLnByaW1fdHlwZSwgMCwgZHJhd19jbnQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGFsZXJ0KCdibGVlcCBibG9vcCBlcnJyb3JycicpXG5cdFx0fVxuXHRcdC8vIGdsLmJpbmRWZXJ0ZXhBcnJheShnbC5kZWZhdWx0VmFvKVxuXHR9XG5cblx0ZHJhdyhvZmZzOiBudW1iZXIgPSAwKSB7XG5cdFx0dGhpcy5kcmF3X3dpdGhfZXh0ZXJuYWxfc2hhZGVyKHRoaXMuc2hhZGVyKVxuXHR9XG59XG4iLCJpbXBvcnQge1V0aWxzfSBmcm9tICdzdHVmZidcbmltcG9ydCB7QnJ1c2hTdHJva2UsIEJydXNoVHlwZX0gZnJvbSAnYnJ1c2hfc3Ryb2tlJ1xuaW1wb3J0IHtjb3MsIGZsb29yLCBzaW59IGZyb20gJ3dtYXRoJ1xuaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnXG5pbXBvcnQgbGlidGVzcyBmcm9tICdsaWJ0ZXNzJ1xuaW1wb3J0IHtGcmFtZWJ1ZmZlcn0gZnJvbSAnZ2wvRnJhbWVidWZmZXInXG5pbXBvcnQge1RleHR1cmV9IGZyb20gJ2dsL1RleHR1cmUnXG5pbXBvcnQge1RoaW5nfSBmcm9tICdnbC9UaGluZydcbmNvbnN0IHRlc3N5ID0gKGZ1bmN0aW9uIGluaXRUZXNzZWxhdG9yKCkge1xuXHQvLyBmdW5jdGlvbiBjYWxsZWQgZm9yIGVhY2ggdmVydGV4IG9mIHRlc3NlbGF0b3Igb3V0cHV0XG5cdGZ1bmN0aW9uIHZlcnRleENhbGxiYWNrKGRhdGEsIHBvbHlWZXJ0QXJyYXkpIHtcblx0XHQvLyBjb25zb2xlLmxvZyhkYXRhWzBdLCBkYXRhWzFdKTtcblx0XHRwb2x5VmVydEFycmF5W3BvbHlWZXJ0QXJyYXkubGVuZ3RoXSA9IGRhdGFbMF1cblx0XHRwb2x5VmVydEFycmF5W3BvbHlWZXJ0QXJyYXkubGVuZ3RoXSA9IGRhdGFbMV1cblx0fVxuXHRmdW5jdGlvbiBiZWdpbmNhbGxiYWNrKHR5cGUpIHtcblx0XHRpZiAodHlwZSAhPT0gbGlidGVzcy5wcmltaXRpdmVUeXBlLkdMX1RSSUFOR0xFUykge1xuXHRcdFx0Y29uc29sZS5sb2coJ2V4cGVjdGVkIFRSSUFOR0xFUyBidXQgZ290IHR5cGU6ICcgKyB0eXBlKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBlcnJvcmNhbGxiYWNrKGVycm5vKSB7XG5cdFx0Y29uc29sZS5sb2coJ2Vycm9yIGNhbGxiYWNrJylcblx0XHRjb25zb2xlLmxvZygnZXJyb3IgbnVtYmVyOiAnICsgZXJybm8pXG5cdH1cblx0Ly8gY2FsbGJhY2sgZm9yIHdoZW4gc2VnbWVudHMgaW50ZXJzZWN0IGFuZCBtdXN0IGJlIHNwbGl0XG5cdGZ1bmN0aW9uIGNvbWJpbmVjYWxsYmFjayhjb29yZHMsIGRhdGEsIHdlaWdodCkge1xuXHRcdC8vIGNvbnNvbGUubG9nKCdjb21iaW5lIGNhbGxiYWNrJyk7XG5cdFx0cmV0dXJuIFtjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdXVxuXHR9XG5cdGZ1bmN0aW9uIGVkZ2VDYWxsYmFjayhmbGFnKSB7XG5cdFx0Ly8gZG9uJ3QgcmVhbGx5IGNhcmUgYWJvdXQgdGhlIGZsYWcsIGJ1dCBuZWVkIG5vLXN0cmlwL25vLWZhbiBiZWhhdmlvclxuXHRcdC8vIGNvbnNvbGUubG9nKCdlZGdlIGZsYWc6ICcgKyBmbGFnKTtcblx0fVxuXG5cdGNvbnN0IHRlc3N5ID0gbmV3IGxpYnRlc3MuR2x1VGVzc2VsYXRvcigpXG5cdC8vIHRlc3N5LmdsdVRlc3NQcm9wZXJ0eShsaWJ0ZXNzLmdsdUVudW0uR0xVX1RFU1NfV0lORElOR19SVUxFLCBsaWJ0ZXNzLndpbmRpbmdSdWxlLkdMVV9URVNTX1dJTkRJTkdfUE9TSVRJVkUpO1xuXHR0ZXNzeS5nbHVUZXNzQ2FsbGJhY2sobGlidGVzcy5nbHVFbnVtLkdMVV9URVNTX1ZFUlRFWF9EQVRBLCB2ZXJ0ZXhDYWxsYmFjaylcblx0dGVzc3kuZ2x1VGVzc0NhbGxiYWNrKGxpYnRlc3MuZ2x1RW51bS5HTFVfVEVTU19CRUdJTiwgYmVnaW5jYWxsYmFjaylcblx0dGVzc3kuZ2x1VGVzc0NhbGxiYWNrKGxpYnRlc3MuZ2x1RW51bS5HTFVfVEVTU19FUlJPUiwgZXJyb3JjYWxsYmFjaylcblx0dGVzc3kuZ2x1VGVzc0NhbGxiYWNrKGxpYnRlc3MuZ2x1RW51bS5HTFVfVEVTU19DT01CSU5FLCBjb21iaW5lY2FsbGJhY2spXG5cdHRlc3N5LmdsdVRlc3NDYWxsYmFjayhsaWJ0ZXNzLmdsdUVudW0uR0xVX1RFU1NfRURHRV9GTEFHLCBlZGdlQ2FsbGJhY2spXG5cblx0cmV0dXJuIHRlc3N5XG59KSgpXG5cbmZ1bmN0aW9uIHRyaWFuZ3VsYXRlKGNvbnRvdXJzKSB7XG5cdC8vIGxpYnRlc3Mgd2lsbCB0YWtlIDNkIHZlcnRzIGFuZCBmbGF0dGVuIHRvIGEgcGxhbmUgZm9yIHRlc3NlbGF0aW9uXG5cdC8vIHNpbmNlIG9ubHkgZG9pbmcgMmQgdGVzc2VsYXRpb24gaGVyZSwgcHJvdmlkZSB6PTEgbm9ybWFsIHRvIHNraXBcblx0Ly8gaXRlcmF0aW5nIG92ZXIgdmVydHMgb25seSB0byBnZXQgdGhlIHNhbWUgYW5zd2VyLlxuXHQvLyBjb21tZW50IG91dCB0byB0ZXN0IG5vcm1hbC1nZW5lcmF0aW9uIGNvZGVcblx0dGVzc3kuZ2x1VGVzc05vcm1hbCgwLCAwLCAxKVxuXG5cdGNvbnN0IHRyaWFuZ2xlVmVydHMgPSBbXVxuXHR0ZXNzeS5nbHVUZXNzQmVnaW5Qb2x5Z29uKHRyaWFuZ2xlVmVydHMpXG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb250b3Vycy5sZW5ndGg7IGkrKykge1xuXHRcdHRlc3N5LmdsdVRlc3NCZWdpbkNvbnRvdXIoKVxuXHRcdGxldCBjb250b3VyID0gY29udG91cnNbaV1cblx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGNvbnRvdXIubGVuZ3RoOyBqICs9IDIpIHtcblx0XHRcdGNvbnN0IGNvb3JkcyA9IFtjb250b3VyW2pdLCBjb250b3VyW2ogKyAxXSwgMF1cblx0XHRcdHRlc3N5LmdsdVRlc3NWZXJ0ZXgoY29vcmRzLCBjb29yZHMpXG5cdFx0fVxuXHRcdHRlc3N5LmdsdVRlc3NFbmRDb250b3VyKClcblx0fVxuXG5cdC8vIGZpbmlzaCBwb2x5Z29uIChhbmQgdGltZSB0cmlhbmd1bGF0aW9uIHByb2Nlc3MpXG5cdC8vIGNvbnN0IHN0YXJ0VGltZSA9IHdpbmRvdy5ub3dpc2goKVxuXHR0ZXNzeS5nbHVUZXNzRW5kUG9seWdvbigpXG5cdC8vIGNvbnN0IGVuZFRpbWUgPSB3aW5kb3cubm93aXNoKClcblx0Ly8gY29uc29sZS5sb2coJ3Rlc3NlbGF0aW9uIHRpbWU6ICcgKyAoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9GaXhlZCgyKSArICdtcycpXG5cblx0cmV0dXJuIHRyaWFuZ2xlVmVydHNcbn1cblxuY29uc3QgZ2V0X3N1YmFycmF5ID0gKGFycjogRmxvYXQzMkFycmF5LCBvZmZzX2JlZ2luOiBudW1iZXIsIG9mZnNfZW5kOiBudW1iZXIpOiBbRmxvYXQzMkFycmF5LCBudW1iZXJdID0+IHtcblx0cmV0dXJuIFthcnIuc3ViYXJyYXkob2Zmc19iZWdpbiwgb2Zmc19lbmQpLCBvZmZzX2VuZCAtIDFdXG59XG5cbmNvbnN0IGdldF9jaXJjX3Bvc19mcm9tX2FuZyA9IChhOiBudW1iZXIpID0+IHtcblx0Y29uc3QgYyA9IGNvcygtYSlcblx0Y29uc3QgcyA9IHNpbigtYSlcblx0cmV0dXJuIFtjLCBzXVxufVxuXG5sZXQgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRcbmV4cG9ydCBjbGFzcyBEcmF3ZXIge1xuXHRjYW52YXNfdGV4OiBUZXh0dXJlXG5cdGRlZmF1bHRfZnJhbWVidWZmZXI6IEZyYW1lYnVmZmVyXG5cdC8vIEB0cy1pZ25vcmVcblx0YnJ1c2hfYnVmZmVyOiBUaGluZ1xuXHR6b29tOiBudW1iZXIgPSAwXG5cdHBhbm5pbmc6IG51bWJlcltdID0gWzAsIDBdXG5cdHQ6IG51bWJlciA9IDBcblx0aWR4OiBudW1iZXIgPSAwXG5cdHRlbXBfYXJyYXlfYTogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxXzAwMF8wMClcblx0dGVtcF9hcnJheV9iOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDFfMDAwXzAwKVxuXG5cdHJlY29yZGVkX2RyYXdjYWxsczogbnVtYmVyW10gPSBbXVxuXG5cdGNvbnN0cnVjdG9yKF9nbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgY2FudmFzX3RleDogVGV4dHVyZSwgZGVmYXVsdF9mcmFtZWJ1ZmZlcjogRnJhbWVidWZmZXIpIHtcblx0XHR0aGlzLmNhbnZhc190ZXggPSBjYW52YXNfdGV4XG5cdFx0dGhpcy5kZWZhdWx0X2ZyYW1lYnVmZmVyID0gZGVmYXVsdF9mcmFtZWJ1ZmZlclxuXHRcdGdsID0gX2dsXG5cdH1cblxuXHRyZXNldCgpIHtcblx0XHR0aGlzLmlkeCA9IDBcblx0XHR0aGlzLnJlY29yZGVkX2RyYXdjYWxscy5sZW5ndGggPSAwXG5cdFx0Ly8gdGhpcy5yZWNvcmRlZF9kcmF3Y2FsbHMgPSBbXVxuXHRcdHRoaXMuYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnN6ID0gMFxuXHRcdHRoaXMuYnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLnN6ID0gMFxuXHR9XG5cblx0ZmlsbF9idWZmX2Zvcl9ibG9iX2JydXNoKHN0cm9rZTogQnJ1c2hTdHJva2UpIHtcblx0XHRjb25zdCBicnVzaF9idWZmZXIgPSB0aGlzLmJydXNoX2J1ZmZlclxuXHRcdGNvbnN0IGl0ZXJzID0gc3Ryb2tlLnBvc2l0aW9ucy5sZW5ndGggLyAyIC0gMVxuXG5cdFx0bGV0IGFzcGVjdF9jb3JyZWN0aW9uID0gWzAsIDBdXG5cdFx0aWYgKHRoaXMuY2FudmFzX3RleC5yZXNbMF0gPiB0aGlzLmNhbnZhc190ZXgucmVzWzFdKSB7XG5cdFx0XHRhc3BlY3RfY29ycmVjdGlvblswXSA9IHRoaXMuY2FudmFzX3RleC5yZXNbMV0gLyB0aGlzLmNhbnZhc190ZXgucmVzWzBdXG5cdFx0XHRhc3BlY3RfY29ycmVjdGlvblsxXSA9IDFcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXNwZWN0X2NvcnJlY3Rpb25bMF0gPSAxXG5cdFx0XHRhc3BlY3RfY29ycmVjdGlvblsxXSA9IHRoaXMuY2FudmFzX3RleC5yZXNbMF0gLyB0aGlzLmNhbnZhc190ZXgucmVzWzFdXG5cdFx0fVxuXG5cdFx0Y29uc3QgYWRkX2FuZ190b19wb3MgPSAoXG5cdFx0XHRwb3M6IG51bWJlcltdLFxuXHRcdFx0YW5nX3g6IG51bWJlcltdLFxuXHRcdFx0YW5nX3k6IG51bWJlcltdLFxuXHRcdFx0cG9zaXRpdmU6IGJvb2xlYW4sXG5cdFx0XHRzel94OiBudW1iZXIsXG5cdFx0XHRzel95OiBudW1iZXIsXG5cdFx0KTogbnVtYmVyW10gPT4ge1xuXHRcdFx0aWYgKHBvc2l0aXZlKSB7XG5cdFx0XHRcdHBvc1swXSArPSBhbmdfeFswXSAqIHN6X3ggKiBhc3BlY3RfY29ycmVjdGlvblswXVxuXHRcdFx0XHRwb3NbMV0gKz0gYW5nX3hbMV0gKiBzel94ICogYXNwZWN0X2NvcnJlY3Rpb25bMV1cblx0XHRcdFx0cG9zWzBdICs9IGFuZ195WzBdICogc3pfeSAqIGFzcGVjdF9jb3JyZWN0aW9uWzBdXG5cdFx0XHRcdHBvc1sxXSArPSBhbmdfeVsxXSAqIHN6X3kgKiBhc3BlY3RfY29ycmVjdGlvblsxXVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zWzBdIC09IGFuZ194WzBdICogc3pfeCAqIGFzcGVjdF9jb3JyZWN0aW9uWzBdXG5cdFx0XHRcdHBvc1sxXSAtPSBhbmdfeFsxXSAqIHN6X3ggKiBhc3BlY3RfY29ycmVjdGlvblsxXVxuXHRcdFx0XHRwb3NbMF0gKz0gYW5nX3lbMF0gKiBzel95ICogYXNwZWN0X2NvcnJlY3Rpb25bMF1cblx0XHRcdFx0cG9zWzFdICs9IGFuZ195WzFdICogc3pfeSAqIGFzcGVjdF9jb3JyZWN0aW9uWzFdXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcG9zXG5cdFx0fVxuXG5cdFx0bGV0IGlkeCA9IGJydXNoX2J1ZmZlci5idWZmc1swXS5zelxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuXHRcdFx0bGV0IHN6X3ggPSBzdHJva2Uuc2l6ZXNbaSAqIDJdIC8gMlxuXHRcdFx0bGV0IHN6X3kgPSBzdHJva2Uuc2l6ZXNbaSAqIDIgKyAxXSAvIDJcblx0XHRcdC8vIGxldCBuZXh0X3N6ID0gYnJ1c2hfc3Ryb2tlLnNpemVzW2kgKiAyICsgMl1cblxuXHRcdFx0bGV0IGFuZ194ID0gZ2V0X2NpcmNfcG9zX2Zyb21fYW5nKHN0cm9rZS5yb3RhdGlvbnNbaSAqIDIgKyAxXSlcblx0XHRcdGxldCBhbmdfeSA9IFthbmdfeFsxXSwgLWFuZ194WzBdXVxuXHRcdFx0Ly8gbGV0IG5leHRfYW5nID0gZ2V0X2NpcmNfcG9zX2Zyb21fYW5nKGJydXNoX3N0cm9rZS5yb3RhdGlvbnNbaSAqIDIgKyAzXSlcblx0XHRcdC8vIGxldCBuZXh0X2FuZ19iID0gW2N1cnJfYW5nWzFdLC1jdXJyX2FuZ1swXV1cblxuXHRcdFx0bGV0IGN1cnJfcG9zID0gW3N0cm9rZS5wb3NpdGlvbnNbaSAqIDJdLCBzdHJva2UucG9zaXRpb25zW2kgKiAyICsgMV1dXG5cdFx0XHQvLyBjdXJyX3Bvc1swXSArPSBvZmZzX3hcblx0XHRcdC8vIGN1cnJfcG9zWzFdICs9IG9mZnNfeVxuXHRcdFx0Ly8gbGV0IG5leHRfcG9zID0gW2JydXNoX3N0cm9rZS5wb3NpdGlvbnNbaSAqIDIgKyAyXSwgYnJ1c2hfc3Ryb2tlLnBvc2l0aW9uc1tpICogMiArIDNdXVxuXG5cdFx0XHRsZXQgY3Vycl9wb3NfbGVmdCA9IGFkZF9hbmdfdG9fcG9zKFsuLi5jdXJyX3Bvc10sIGFuZ194LCBhbmdfeSwgdHJ1ZSwgc3pfeCwgc3pfeSlcblx0XHRcdGxldCBjdXJyX3Bvc19yaWdodCA9IGFkZF9hbmdfdG9fcG9zKFsuLi5jdXJyX3Bvc10sIGFuZ194LCBhbmdfeSwgZmFsc2UsIHN6X3gsIHN6X3kpXG5cblx0XHRcdGxldCBuZXh0X3Bvc19sZWZ0ID0gWy4uLmN1cnJfcG9zX2xlZnRdXG5cdFx0XHRsZXQgbmV4dF9wb3NfcmlnaHQgPSBbLi4uY3Vycl9wb3NfcmlnaHRdXG5cblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tIE9GRlNcblx0XHRcdG5leHRfcG9zX2xlZnRbMF0gLT0gYW5nX3lbMF0gKiBzel95ICogYXNwZWN0X2NvcnJlY3Rpb25bMF0gKiAyXG5cdFx0XHRuZXh0X3Bvc19sZWZ0WzFdIC09IGFuZ195WzFdICogc3pfeSAqIGFzcGVjdF9jb3JyZWN0aW9uWzFdICogMlxuXHRcdFx0bmV4dF9wb3NfcmlnaHRbMF0gLT0gYW5nX3lbMF0gKiBzel95ICogYXNwZWN0X2NvcnJlY3Rpb25bMF0gKiAyXG5cdFx0XHRuZXh0X3Bvc19yaWdodFsxXSAtPSBhbmdfeVsxXSAqIHN6X3kgKiBhc3BlY3RfY29ycmVjdGlvblsxXSAqIDJcblx0XHRcdC8vIHBvc1sxXSArPSAoYW5nX29mZnNfYlsxXSAqIGFtdF9iKSAvIGFzcGVjdF9jb3JyZWN0aW9uWzFdXG5cblx0XHRcdGxldCBjdXJyX2NvbCA9IFtzdHJva2UuY29sb3Vyc1tpICogM10sIHN0cm9rZS5jb2xvdXJzW2kgKiAzICsgMV0sIHN0cm9rZS5jb2xvdXJzW2kgKiAzICsgMl1dXG5cdFx0XHRsZXQgY3Vycl9vcGFjaXR5ID0gc3Ryb2tlLm9wYWNpdGllc1tpXVxuXG5cdFx0XHRjb25zdCBjdXJyX3YgPSBpIC8gaXRlcnNcblx0XHRcdGNvbnN0IG5leHRfdiA9IChpICsgMSkgLyBpdGVyc1xuXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMF0ucHVzaF92ZXJ0KFsuLi5jdXJyX3Bvc19sZWZ0LCAwLCBjdXJyX3ZdKVxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLnB1c2hfdmVydChbLi4uY3Vycl9jb2wsIGN1cnJfb3BhY2l0eV0pXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IGN1cnJfcG9zX2xlZnRbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Bvc19sZWZ0WzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMFxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzJdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDBcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX29wYWNpdHlcblxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnB1c2hfdmVydChbLi4uY3Vycl9wb3NfcmlnaHQsIDEsIGN1cnJfdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFsuLi5jdXJyX2NvbCwgY3Vycl9vcGFjaXR5XSlcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gY3Vycl9wb3NfcmlnaHRbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Bvc19yaWdodFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDFcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAwXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9vcGFjaXR5XG5cblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS5wdXNoX3ZlcnQoWy4uLm5leHRfcG9zX2xlZnQsIDAsIG5leHRfdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFsuLi5jdXJyX2NvbCwgY3Vycl9vcGFjaXR5XSlcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gbmV4dF9wb3NfbGVmdFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IG5leHRfcG9zX2xlZnRbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAwXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMl1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfb3BhY2l0eVxuXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMF0ucHVzaF92ZXJ0KFsuLi5jdXJyX3Bvc19yaWdodCwgMSwgY3Vycl92XSlcblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1sxXS5wdXNoX3ZlcnQoWy4uLmN1cnJfY29sLCBjdXJyX29wYWNpdHldKVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Bvc19yaWdodFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IGN1cnJfcG9zX3JpZ2h0WzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzJdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDBcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX29wYWNpdHlcblxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnB1c2hfdmVydChbLi4ubmV4dF9wb3NfbGVmdCwgMCwgbmV4dF92XSlcblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1sxXS5wdXNoX3ZlcnQoWy4uLmN1cnJfY29sLCBjdXJyX29wYWNpdHldKVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBuZXh0X3Bvc19sZWZ0WzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gbmV4dF9wb3NfbGVmdFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDBcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAxXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9vcGFjaXR5XG5cblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS5wdXNoX3ZlcnQoWy4uLm5leHRfcG9zX3JpZ2h0LCAxLCBuZXh0X3ZdKVxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLnB1c2hfdmVydChbLi4uY3Vycl9jb2wsIGN1cnJfb3BhY2l0eV0pXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IG5leHRfcG9zX3JpZ2h0WzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gbmV4dF9wb3NfcmlnaHRbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAxXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMl1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfb3BhY2l0eVxuXHRcdH1cblx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uc3ogKz0gaXRlcnMgKiA2ICogNFxuXHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5zeiArPSBpdGVycyAqIDYgKiA0XG5cdFx0dGhpcy5yZWNvcmRlZF9kcmF3Y2FsbHMucHVzaCh0aGlzLmJydXNoX2J1ZmZlci5idWZmc1swXS5zeilcblx0fVxuXG5cdGZpbGxfYnVmZl9mb3JfbG9uZ19icnVzaChzdHJva2U6IEJydXNoU3Ryb2tlKSB7XG5cdFx0Y29uc3QgYnJ1c2hfYnVmZmVyID0gdGhpcy5icnVzaF9idWZmZXJcblx0XHRjb25zdCBpdGVycyA9IHN0cm9rZS5wb3NpdGlvbnMubGVuZ3RoIC8gMiAtIDFcblx0XHRsZXQgYXNwZWN0X2NvcnJlY3Rpb24gPSBbMCwgMF1cblx0XHRpZiAodGhpcy5jYW52YXNfdGV4LnJlc1swXSA+IHRoaXMuY2FudmFzX3RleC5yZXNbMV0pIHtcblx0XHRcdGFzcGVjdF9jb3JyZWN0aW9uWzBdID0gdGhpcy5jYW52YXNfdGV4LnJlc1sxXSAvIHRoaXMuY2FudmFzX3RleC5yZXNbMF1cblx0XHRcdGFzcGVjdF9jb3JyZWN0aW9uWzFdID0gMVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRhc3BlY3RfY29ycmVjdGlvblswXSA9IDFcblx0XHRcdGFzcGVjdF9jb3JyZWN0aW9uWzFdID0gdGhpcy5jYW52YXNfdGV4LnJlc1swXSAvIHRoaXMuY2FudmFzX3RleC5yZXNbMV1cblx0XHR9XG5cblx0XHRjb25zdCBhZGRfYW5nX3RvX3BvcyA9IChcblx0XHRcdHBvczogbnVtYmVyW10sXG5cdFx0XHRhbmdfb2ZmczogbnVtYmVyW10sXG5cdFx0XHRwb3NpdGl2ZTogYm9vbGVhbixcblx0XHRcdGFtdDogbnVtYmVyLFxuXHRcdFx0YXNwZWN0X2NvcnJlY3Rpb246IG51bWJlcltdLFxuXHRcdCk6IG51bWJlcltdID0+IHtcblx0XHRcdGlmIChwb3NpdGl2ZSkge1xuXHRcdFx0XHRwb3NbMF0gKz0gYW5nX29mZnNbMF0gKiBhbXQgKiBhc3BlY3RfY29ycmVjdGlvblswXVxuXHRcdFx0XHRwb3NbMV0gKz0gYW5nX29mZnNbMV0gKiBhbXQgKiBhc3BlY3RfY29ycmVjdGlvblsxXVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zWzBdIC09IGFuZ19vZmZzWzBdICogYW10ICogYXNwZWN0X2NvcnJlY3Rpb25bMF1cblx0XHRcdFx0cG9zWzFdIC09IGFuZ19vZmZzWzFdICogYW10ICogYXNwZWN0X2NvcnJlY3Rpb25bMV1cblx0XHRcdH1cblx0XHRcdHJldHVybiBwb3Ncblx0XHR9XG5cblx0XHRsZXQgaWR4ID0gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnN6XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcblx0XHRcdC8vICNkZWZpbmUgcm90KGEpIG1hdDIoY29zKGEpLC1zaW4oYSksc2luKGEpLGNvcyhhKSlcblx0XHRcdC8vIGJydXNoX3N0cm9rZS5cblx0XHRcdGxldCBjdXJyX3N6ID0gc3Ryb2tlLnNpemVzW2kgKiAyXVxuXHRcdFx0bGV0IG5leHRfc3ogPSBzdHJva2Uuc2l6ZXNbaSAqIDIgKyAyXVxuXG5cdFx0XHRsZXQgY3Vycl9hbmcgPSBnZXRfY2lyY19wb3NfZnJvbV9hbmcoc3Ryb2tlLnJvdGF0aW9uc1tpICogMiArIDFdKVxuXHRcdFx0bGV0IG5leHRfYW5nID0gZ2V0X2NpcmNfcG9zX2Zyb21fYW5nKHN0cm9rZS5yb3RhdGlvbnNbaSAqIDIgKyAzXSlcblxuXHRcdFx0bGV0IGN1cnJfcG9zID0gW3N0cm9rZS5wb3NpdGlvbnNbaSAqIDJdLCBzdHJva2UucG9zaXRpb25zW2kgKiAyICsgMV1dXG5cdFx0XHRsZXQgbmV4dF9wb3MgPSBbc3Ryb2tlLnBvc2l0aW9uc1tpICogMiArIDJdLCBzdHJva2UucG9zaXRpb25zW2kgKiAyICsgM11dXG5cblx0XHRcdGxldCBjdXJyX3Bvc19sZWZ0ID0gYWRkX2FuZ190b19wb3MoWy4uLmN1cnJfcG9zXSwgY3Vycl9hbmcsIHRydWUsIGN1cnJfc3osIGFzcGVjdF9jb3JyZWN0aW9uKVxuXHRcdFx0bGV0IGN1cnJfcG9zX3JpZ2h0ID0gYWRkX2FuZ190b19wb3MoWy4uLmN1cnJfcG9zXSwgY3Vycl9hbmcsIGZhbHNlLCBjdXJyX3N6LCBhc3BlY3RfY29ycmVjdGlvbilcblxuXHRcdFx0bGV0IG5leHRfcG9zX2xlZnQgPSBhZGRfYW5nX3RvX3BvcyhbLi4ubmV4dF9wb3NdLCBuZXh0X2FuZywgdHJ1ZSwgbmV4dF9zeiwgYXNwZWN0X2NvcnJlY3Rpb24pXG5cdFx0XHRsZXQgbmV4dF9wb3NfcmlnaHQgPSBhZGRfYW5nX3RvX3BvcyhbLi4ubmV4dF9wb3NdLCBuZXh0X2FuZywgZmFsc2UsIG5leHRfc3osIGFzcGVjdF9jb3JyZWN0aW9uKVxuXG5cdFx0XHRsZXQgY3Vycl9jb2wgPSBbc3Ryb2tlLmNvbG91cnNbaSAqIDNdLCBzdHJva2UuY29sb3Vyc1tpICogMyArIDFdLCBzdHJva2UuY29sb3Vyc1tpICogMyArIDJdXVxuXHRcdFx0bGV0IGN1cnJfb3BhY2l0eSA9IHN0cm9rZS5vcGFjaXRpZXNbaV1cblxuXHRcdFx0bGV0IG5leHRfY29sID0gW3N0cm9rZS5jb2xvdXJzW2kgKiAzICsgM10sIHN0cm9rZS5jb2xvdXJzW2kgKiAzICsgNF0sIHN0cm9rZS5jb2xvdXJzW2kgKiAzICsgNV1dXG5cdFx0XHRsZXQgbmV4dF9vcGFjaXR5ID0gc3Ryb2tlLm9wYWNpdGllc1tpICsgMV1cblxuXHRcdFx0Y29uc3QgY3Vycl92ID0gaSAvIGl0ZXJzXG5cdFx0XHRjb25zdCBuZXh0X3YgPSAoaSArIDEpIC8gaXRlcnNcblxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnB1c2hfdmVydChbLi4uY3Vycl9wb3NfbGVmdCwgMCwgY3Vycl92XSlcblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1sxXS5wdXNoX3ZlcnQoWy4uLmN1cnJfY29sLCBjdXJyX29wYWNpdHldKVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Bvc19sZWZ0WzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gY3Vycl9wb3NfbGVmdFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDBcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Zcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX29wYWNpdHlcblxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnB1c2hfdmVydChbLi4uY3Vycl9wb3NfcmlnaHQsIDEsIGN1cnJfdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFsuLi5jdXJyX2NvbCwgY3Vycl9vcGFjaXR5XSlcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gY3Vycl9wb3NfcmlnaHRbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Bvc19yaWdodFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDFcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX2NvbFsyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Zcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjdXJyX29wYWNpdHlcblxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnB1c2hfdmVydChbLi4ubmV4dF9wb3NfbGVmdCwgMCwgbmV4dF92XSlcblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1sxXS5wdXNoX3ZlcnQoWy4uLm5leHRfY29sLCBuZXh0X29wYWNpdHldKVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBuZXh0X3Bvc19sZWZ0WzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gbmV4dF9jb2xbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gbmV4dF9wb3NfbGVmdFsxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IG5leHRfY29sWzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDBcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBuZXh0X2NvbFsyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBuZXh0X3Zcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBuZXh0X29wYWNpdHlcblxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnB1c2hfdmVydChbLi4uY3Vycl9wb3NfcmlnaHQsIDEsIGN1cnJfdl0pXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFsuLi5jdXJyX2NvbCwgY3Vycl9vcGFjaXR5XSlcblxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBjdXJyX3Bvc19yaWdodFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IGN1cnJfcG9zX3JpZ2h0WzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY3Vycl9jb2xbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfY29sWzJdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IGN1cnJfdlxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGN1cnJfb3BhY2l0eVxuXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMF0ucHVzaF92ZXJ0KFsuLi5uZXh0X3Bvc19sZWZ0LCAwLCBuZXh0X3ZdKVxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLnB1c2hfdmVydChbLi4ubmV4dF9jb2wsIG5leHRfb3BhY2l0eV0pXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IG5leHRfcG9zX2xlZnRbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBuZXh0X2NvbFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBuZXh0X3Bvc19sZWZ0WzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gbmV4dF9jb2xbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMFxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IG5leHRfY29sWzJdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IG5leHRfdlxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IG5leHRfb3BhY2l0eVxuXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMF0ucHVzaF92ZXJ0KFsuLi5uZXh0X3Bvc19yaWdodCwgMSwgbmV4dF92XSlcblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1sxXS5wdXNoX3ZlcnQoWy4uLm5leHRfY29sLCBuZXh0X29wYWNpdHldKVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBuZXh0X3Bvc19yaWdodFswXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IG5leHRfY29sWzBdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IG5leHRfcG9zX3JpZ2h0WzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gbmV4dF9jb2xbMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IG5leHRfY29sWzJdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IG5leHRfdlxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IG5leHRfb3BhY2l0eVxuXHRcdH1cblx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uc3ogKz0gaXRlcnMgKiA2ICogNFxuXHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5zeiArPSBpdGVycyAqIDYgKiA0XG5cdFx0dGhpcy5yZWNvcmRlZF9kcmF3Y2FsbHMucHVzaCh0aGlzLmJydXNoX2J1ZmZlci5idWZmc1swXS5zeilcblx0fVxuXHRmaWxsX2J1ZmZfZm9yX3RyaWFuZ3VsYXRlZF9icnVzaChzdHJva2U6IEJydXNoU3Ryb2tlKSB7XG5cdFx0Y29uc3QgYnJ1c2hfYnVmZmVyID0gdGhpcy5icnVzaF9idWZmZXJcblx0XHRjb25zdCB7Y29sb3Vycywgb3BhY2l0aWVzLCBwb3NpdGlvbnN9ID0gc3Ryb2tlXG5cdFx0Ly8gbGV0IHBvc2l0aW9ucyA9IFsuLi5zdHJva2UucG9zaXRpb25zXVxuXHRcdC8vIGNvbnN0IFtuZXdfdHJpYW5nbGVzLCBvZmZzXSA9IGdldF9zdWJhcnJheSh0aGlzLnRlbXBfYXJyYXlfYSwgMCwgcG9zaXRpb25zLmxlbmd0aCAqIDMpXG5cdFx0Ly8gY29uc3QgW25ld19jb2xzXSA9IGdldF9zdWJhcnJheSh0aGlzLnRlbXBfYXJyYXlfYSwgb2Zmcywgb2ZmcyArIChwb3NpdGlvbnMubGVuZ3RoIC8gMikgKiAzICogNClcblx0XHRjb25zdCBpdGVycyA9IHBvc2l0aW9ucy5sZW5ndGggLyAyIC0gMVxuXHRcdGxldCBpZHggPSBicnVzaF9idWZmZXIuYnVmZnNbMF0uc3pcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcblx0XHRcdGxldCB1ID0gMFxuXHRcdFx0bGV0IHYgPSAwXG5cdFx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0ucHVzaF92ZXJ0KFsuLi5jdXJyX2NvbCwgY3Vycl9vcGFjaXR5XSlcblxuXHRcdFx0Ly8gbmV3X3RyaWFuZ2xlc1tpICogMyAqIDJdID0gcG9zaXRpb25zWzBdXG5cdFx0XHQvLyBuZXdfdHJpYW5nbGVzW2kgKiAzICogMiArIDFdID0gcG9zaXRpb25zWzAgKyAxXVxuXHRcdFx0Ly8gbmV3X2NvbHNbaSAqIDMgKiA0XSA9IHN0cm9rZS5jb2xvdXJzWzBdXG5cdFx0XHQvLyBuZXdfY29sc1tpICogMyAqIDQgKyAxXSA9IHN0cm9rZS5jb2xvdXJzWzFdXG5cdFx0XHQvLyBuZXdfY29sc1tpICogMyAqIDQgKyAyXSA9IHN0cm9rZS5jb2xvdXJzWzJdXG5cdFx0XHQvLyBuZXdfY29sc1tpICogMyAqIDQgKyAzXSA9IHN0cm9rZS5vcGFjaXRpZXNbMF1cblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS5wdXNoX3ZlcnQoW3Bvc2l0aW9uc1swXSwgcG9zaXRpb25zWzFdLCB1LCB2XSlcblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1sxXS5wdXNoX3ZlcnQoW2NvbG91cnNbMF0sIGNvbG91cnNbMV0sIGNvbG91cnNbMl0sIG9wYWNpdGllc1sxXV0pXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IHBvc2l0aW9uc1swXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGNvbG91cnNbMF1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gcG9zaXRpb25zWzFdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY29sb3Vyc1sxXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBpIC8gKGl0ZXJzICsgMSlcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjb2xvdXJzWzJdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDBcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBvcGFjaXRpZXNbMV1cblxuXHRcdFx0Ly8gbmV3X3RyaWFuZ2xlc1tpICogMyAqIDIgKyAyXSA9IHBvc2l0aW9uc1tpICogMl1cblx0XHRcdC8vIG5ld190cmlhbmdsZXNbaSAqIDMgKiAyICsgM10gPSBwb3NpdGlvbnNbaSAqIDIgKyAxXVxuXHRcdFx0Ly8gbmV3X2NvbHNbaSAqIDMgKiA0ICsgNF0gPSBzdHJva2UuY29sb3Vyc1tpICogM11cblx0XHRcdC8vIG5ld19jb2xzW2kgKiAzICogNCArIDVdID0gc3Ryb2tlLmNvbG91cnNbaSAqIDMgKyAxXVxuXHRcdFx0Ly8gbmV3X2NvbHNbaSAqIDMgKiA0ICsgNl0gPSBzdHJva2UuY29sb3Vyc1tpICogMyArIDJdXG5cdFx0XHQvLyBuZXdfY29sc1tpICogMyAqIDQgKyA3XSA9IHN0cm9rZS5vcGFjaXRpZXNbaV1cblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS5wdXNoX3ZlcnQoW3Bvc2l0aW9uc1tpICogMl0sIHBvc2l0aW9uc1tpICogMiArIDFdLCB1LCB2XSlcblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1sxXS5wdXNoX3ZlcnQoW2NvbG91cnNbaSAqIDNdLCBjb2xvdXJzW2kgKiAzICsgMV0sIGNvbG91cnNbaSAqIDMgKyAyXSwgb3BhY2l0aWVzW2ldXSlcblxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBwb3NpdGlvbnNbaSAqIDJdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY29sb3Vyc1tpICogM11cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gcG9zaXRpb25zW2kgKiAyICsgMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjb2xvdXJzW2kgKiAzICsgMV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gaSAvIChpdGVycyArIDEpXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uY3B1X2J1ZmZbaWR4KytdID0gY29sb3Vyc1tpICogMyArIDJdXG5cdFx0XHRicnVzaF9idWZmZXIuYnVmZnNbMF0uY3B1X2J1ZmZbaWR4XSA9IDFcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBvcGFjaXRpZXNbaV1cblxuXHRcdFx0Ly8gbmV3X3RyaWFuZ2xlc1tpICogMyAqIDIgKyA0XSA9IHBvc2l0aW9uc1tpICogMiArIDJdXG5cdFx0XHQvLyBuZXdfdHJpYW5nbGVzW2kgKiAzICogMiArIDVdID0gcG9zaXRpb25zW2kgKiAyICsgM11cblx0XHRcdC8vIG5ld19jb2xzW2kgKiAzICogNCArIDhdID0gc3Ryb2tlLmNvbG91cnNbaSAqIDMgKyAzXVxuXHRcdFx0Ly8gbmV3X2NvbHNbaSAqIDMgKiA0ICsgOV0gPSBzdHJva2UuY29sb3Vyc1tpICogMyArIDRdXG5cdFx0XHQvLyBuZXdfY29sc1tpICogMyAqIDQgKyAxMF0gPSBzdHJva2UuY29sb3Vyc1tpICogMyArIDVdXG5cdFx0XHQvLyBuZXdfY29sc1tpICogMyAqIDQgKyAxMV0gPSBzdHJva2Uub3BhY2l0aWVzW2kgKyAxXVxuXHRcdFx0Ly8gYnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnB1c2hfdmVydChbcG9zaXRpb25zW2kgKiAyICsgMl0sIHBvc2l0aW9uc1tpICogMiArIDNdLCB1LCB2XSlcblx0XHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1sxXS5wdXNoX3ZlcnQoW2NvbG91cnNbaSAqIDMgKyAzXSwgY29sb3Vyc1tpICogMyArIDRdLCBjb2xvdXJzW2kgKiAzICsgNV0sIG9wYWNpdGllc1tpICsgMV1dKVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBwb3NpdGlvbnNbaSAqIDIgKyAyXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGNvbG91cnNbaSAqIDMgKyAzXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSBwb3NpdGlvbnNbaSAqIDIgKyAzXVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IGNvbG91cnNbaSAqIDMgKyA0XVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLmNwdV9idWZmW2lkeF0gPSAoaSArIDEpIC8gKGl0ZXJzICsgMSlcblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1sxXS5jcHVfYnVmZltpZHgrK10gPSBjb2xvdXJzW2kgKiAzICsgNV1cblx0XHRcdGJydXNoX2J1ZmZlci5idWZmc1swXS5jcHVfYnVmZltpZHhdID0gMVxuXHRcdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzFdLmNwdV9idWZmW2lkeCsrXSA9IG9wYWNpdGllc1tpICsgMV1cblx0XHR9XG5cdFx0YnJ1c2hfYnVmZmVyLmJ1ZmZzWzBdLnN6ICs9IGl0ZXJzICogMyAqIDRcblx0XHRicnVzaF9idWZmZXIuYnVmZnNbMV0uc3ogKz0gaXRlcnMgKiAzICogNFxuXHRcdC8vIGJydXNoX2J1ZmZlci5idWZmc1swXS51cGxvYWRfZXh0ZXJuYWxfYXJyYXkobmV3X3RyaWFuZ2xlcylcblx0XHQvLyBicnVzaF9idWZmZXIuYnVmZnNbMV0udXBsb2FkX2V4dGVybmFsX2FycmF5KG5ld19jb2xzKVxuXHRcdHRoaXMucmVjb3JkZWRfZHJhd2NhbGxzLnB1c2godGhpcy5icnVzaF9idWZmZXIuYnVmZnNbMF0uc3opXG5cdH1cblxuXHRwdXNoX2FueV9zdHJva2Uoc3Ryb2tlOiBCcnVzaFN0cm9rZSkge1xuXHRcdGlmIChzdHJva2UuYnJ1c2hfdHlwZSA9PT0gQnJ1c2hUeXBlLkJsb2JzKSB7XG5cdFx0XHR0aGlzLmZpbGxfYnVmZl9mb3JfYmxvYl9icnVzaChzdHJva2UpXG5cdFx0fSBlbHNlIGlmIChzdHJva2UuYnJ1c2hfdHlwZSA9PT0gQnJ1c2hUeXBlLkxvbmcpIHtcblx0XHRcdHRoaXMuZmlsbF9idWZmX2Zvcl9sb25nX2JydXNoKHN0cm9rZSlcblx0XHR9IGVsc2UgaWYgKHN0cm9rZS5icnVzaF90eXBlID09PSBCcnVzaFR5cGUuVHJpKSB7XG5cdFx0XHR0aGlzLmZpbGxfYnVmZl9mb3JfdHJpYW5ndWxhdGVkX2JydXNoKHN0cm9rZSlcblx0XHR9XG5cdH1cblx0ZHJhd19zdHJva2VfaWR4KGlkeDogbnVtYmVyKSB7XG5cdFx0Y29uc3QgZHJhd19zdGFydCA9IGlkeCA9PT0gMCA/IDAgOiB0aGlzLnJlY29yZGVkX2RyYXdjYWxsc1tpZHggLSAxXVxuXHRcdGNvbnN0IGRyYXdfY250ID0gaWR4ID09PSAwID8gdGhpcy5yZWNvcmRlZF9kcmF3Y2FsbHNbMF0gOiB0aGlzLnJlY29yZGVkX2RyYXdjYWxsc1tpZHhdIC0gdGhpcy5yZWNvcmRlZF9kcmF3Y2FsbHNbaWR4IC0gMV1cblx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgZHJhd19zdGFydCAvIDQsIGRyYXdfY250IC8gNClcblx0fVxuXG5cdC8vIGRyYXdfYW55X3N0cm9rZShzdHJva2U6IEJydXNoU3Ryb2tlLCB0OiBudW1iZXIsIGJydXNoX2J1ZmZlcjogVGhpbmcsIHpvb206IG51bWJlciwgcGFubmluZzogbnVtYmVyW10pIHtcblx0Ly8gXHR0aGlzLmJydXNoX2J1ZmZlciA9IGJydXNoX2J1ZmZlclxuXHQvLyBcdHRoaXMudCA9IHRcblx0Ly8gXHR0aGlzLnpvb20gPSB6b29tXG5cdC8vIFx0dGhpcy5wYW5uaW5nWzBdID0gcGFubmluZ1swXVxuXHQvLyBcdHRoaXMucGFubmluZ1sxXSA9IHBhbm5pbmdbMV1cblxuXHQvLyBcdGJydXNoX2J1ZmZlci5kcmF3KClcblx0Ly8gfVxufVxuIiwiPG1haW4+XG5cdDxkaXYgaWQ9XCJiYXItY29udGFpbmVyXCI+XG5cdFx0PGRpdiBpZD1cImJhclwiPlxuXG5cdFx0XHQ8S25vYiBiaW5kOnRoaXM9e2NoYW9zS25vYn0gYmluZDp2YWx1ZT17Y3Vycl9icnVzaC5jaGFvc30gdGl0bGU9eydDaGFvcyd9IHRyaWdnZXJNb2RhbD17b3Blbk1vZGFsfSBtb2RhbD17Y2hhb3NTZW1pTW9kYWx9IC8+XG5cdFx0XHQ8S25vYlxuXHRcdFx0XHRiaW5kOnRoaXM9e2R5bmFtaWNzS25vYn1cblx0XHRcdFx0YmluZDp2YWx1ZT17Y3Vycl9icnVzaC5keW5hbWljc31cblx0XHRcdFx0dGl0bGU9eydEeW5hbWljcyd9XG5cdFx0XHRcdHRyaWdnZXJNb2RhbD17b3Blbk1vZGFsfVxuXHRcdFx0XHRtb2RhbD17ZHluYW1pY3NTZW1pTW9kYWx9IC8+XG5cdFx0XHQ8S25vYlxuXHRcdFx0XHRiaW5kOnRoaXM9e3RleER5bmFtaWNzS25vYn1cblx0XHRcdFx0YmluZDp2YWx1ZT17Y3Vycl9icnVzaC50ZXhfZHluYW1pY3N9XG5cdFx0XHRcdHRpdGxlPXsnVGV4J31cblx0XHRcdFx0dHJpZ2dlck1vZGFsPXtvcGVuTW9kYWx9XG5cdFx0XHRcdG1vZGFsPXt0ZXhEeW5hbWljc1NlbWlNb2RhbH0gLz5cblx0XHRcdDxCcnVzaFNpemVXaWRnZXRcblx0XHRcdFx0YmluZDpicnVzaF9zej17YnJ1c2hfc3p9XG5cdFx0XHRcdGJpbmQ6ZHJhZ2dpbmc9e2JydXNoX3NpemVfd2lkZ2V0X2RyYWdnaW5nfVxuXHRcdFx0XHRiaW5kOnN0b3BwZWRfZHJhZ2dpbmc9e2JydXNoX3NpemVfd2lkZ2V0X3N0b3BwZWRfZHJhZ2dpbmd9IC8+XG5cdFx0XHQ8ZGl2IFxuXHRcdFx0XHRzdHlsZT0naGVpZ2h0OiAxMDAlOyBkaXNwbGF5OiBmbGV4OyBhc3BlY3QtcmF0aW86IDYvMTsnXG5cdFx0XHRcdG9uOnBvaW50ZXJlbnRlcj17KCk9Pnttb3VzZV9vdmVyX2NvbG91cl9waWNrZXIgPSB0cnVlfX1cblx0XHRcdFx0b246cG9pbnRlcmxlYXZlPXsoKT0+e21vdXNlX292ZXJfY29sb3VyX3BpY2tlciA9IGZhbHNlOyBtb3VzZV9vdmVyX2NvbG91cl9waWNrZXJfZmluaXNoZWQgPSB0cnVlfX1cblx0XHRcdD5cblx0XHRcdDxSR0JTbGlkZXJzIGJpbmQ6Y29sb3VyPXtzdHJva2VfY29sfSAvPlxuXHRcdFx0PENvbG91ckRpc3BsYXkgXG5cdFx0XHRcdGJpbmQ6Y29sb3VyPXtzdHJva2VfY29sfSBcblx0XHRcdFx0YmluZDp1cGRhdGVfZGlzcGxheT17dHJpZ2dlcl9jb2xvdXJfZGlzcGxheV91cGRhdGV9IC8+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDwhLS0gPEJydXNoVHlwZVdpZGdldCBiaW5kOnNlbGVjdGVkX2JydXNoX3R5cGU9e2N1cnJfYnJ1c2guc2VsZWN0ZWRfYnJ1c2hfdHlwZX0gLz4gLS0+XG5cdFx0XHQ8QnJ1c2hUeXBlV2lkZ2V0IGJpbmQ6Y3Vycl9icnVzaD17Y3Vycl9icnVzaH0gLz5cblx0XHRcdDxCcnVzaFByZXNldFdpZGdldCBiaW5kOmJydXNoX3ByZXNldHM9e2JydXNoX3ByZXNldHN9IGJpbmQ6c2VsZWN0ZWRfYnJ1c2hfcHJlc2V0PXtjdXJyX2JydXNofSAvPlxuXHRcdFx0PCEtLSA8Rm91ckljb25zV2lkZ2V0PiAtLT5cblx0XHRcdFx0PFVuZG9SZWRvV2lkZ2V0XG5cdFx0XHRcdFx0dW5kbz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0dW5kb19wZW5kaW5nID0gdHJ1ZVxuXHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0cmVkbz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0cmVkb19wZW5kaW5nID0gdHJ1ZVxuXHRcdFx0XHRcdH19IC8+XG5cdFx0XHRcdDxHYWxsZXJ5V2lkZ2V0XG5cdFx0XHRcdFx0YmluZDpjdXJyZW50X3Byb2plY3Q9e3Byb2plY3R9XG5cdFx0XHRcdFx0Z2V0X2N1cnJlbnRfY2FudmFzX2FzX2ltYWdlPXthc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgW2ltZywgYmxvYl0gPSBhd2FpdCBjYW52YXNfcmVhZF90ZXgucmVhZF9iYWNrX2ltYWdlKHRydWUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gW2ltZywgYmxvYl1cblx0XHRcdFx0XHR9fSBcblx0XHRcdFx0XHRuZXdfcHJvamVjdD17KCk9PnsgXG5cdFx0XHRcdFx0XHRuZXdfcHJvamVjdF9wZW5kaW5nID0gdHJ1ZSBcblx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdGxvYWRfcHJvamVjdD17KHByb2plY3QpPT57IFxuXHRcdFx0XHRcdFx0cHJvamVjdF9wZW5kaW5nX2xvYWQgPSBwcm9qZWN0XG5cdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRiaW5kOnJlc2l6ZV9wcm9qZWN0PXtyZXNpemVfcHJvamVjdH1cblx0XHRcdFx0XHRiaW5kOnByb2plY3RfaGFzX2JlZW5fbW9kaWZpZWQ9e3Byb2plY3RfaGFzX2JlZW5fbW9kaWZpZWR9XG5cdFx0XHRcdFx0YmluZDppc19zYWZlX3RvX3N3aXRjaF90b19uZXdfcHJvamVjdD17aXNfc2FmZV90b19zd2l0Y2hfdG9fbmV3X3Byb2plY3R9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PFBpY2tDb2xvdXJXaWRnZXRcblx0XHRcdFx0XHRwaWNrX2Zyb21fY2FudmFzPXsoKSA9PiBwaWNrX2Zyb21fY2FudmFzKCl9XG5cdFx0XHRcdFx0YmluZDpwaWNraW5nPXtwaWNraW5nfVxuXHRcdFx0XHRcdGJpbmQ6anVzdF9maW5pc2hlZF9waWNrPXtqdXN0X2ZpbmlzaGVkX3BpY2t9IC8+XG5cdFx0XHQ8IS0tIDwvRm91ckljb25zV2lkZ2V0PiAtLT5cblx0XHRcdDxCbGVuZGluZ0NvbG91clNwYWNlV2lkZ2V0IGJpbmQ6c2VsZWN0ZWRfY29sb3VyX3NwYWNlPXtibGVuZGluZ19jb2xvdXJfc3BhY2V9Lz5cblx0XHRcdDxGbG9hdGluZ01vZGFsIC8+XG5cdFx0PC9kaXY+XG5cdFx0PFNlbWlNb2RhbCBiaW5kOnRoaXM9e2NoYW9zU2VtaU1vZGFsfSBrbm9iPXtjaGFvc0tub2J9PlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC5jaGFvc19sY2hbMF19IHRpdGxlPXsnQ2hhb3MgTCd9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLmNoYW9zX2xjaFsxXX0gdGl0bGU9eydDaGFvcyBDJ30gLz5cblx0XHRcdDxLbm9iIGJpbmQ6dmFsdWU9e2N1cnJfYnJ1c2guY2hhb3NfbGNoWzJdfSB0aXRsZT17J0NoYW9zIEgnfSAvPlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC5jaGFvc19zcGVlZH0gdGl0bGU9eydDaGFvcyBTcGVlZCd9IC8+XG5cdFx0PC9TZW1pTW9kYWw+XG5cdFx0PFNlbWlNb2RhbCBiaW5kOnRoaXM9e2R5bmFtaWNzU2VtaU1vZGFsfSBrbm9iPXtkeW5hbWljc0tub2J9PlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC5zdHJva2Vfb3BhY2l0eV9keW5hbWljc1swXX0gdGl0bGU9eydPcGFjaXR5IG1pbid9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLnN0cm9rZV9vcGFjaXR5X2R5bmFtaWNzWzFdfSB0aXRsZT17J09wYWNpdHkgbWF4J30gLz5cblx0XHRcdDxLbm9iIGJpbmQ6dmFsdWU9e2N1cnJfYnJ1c2guc3Ryb2tlX3NpemVfZHluYW1pY3NbMF19IHRpdGxlPXsnU2l6ZSBtaW4nfSAvPlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC5zdHJva2Vfc2l6ZV9keW5hbWljc1sxXX0gdGl0bGU9eydTaXplIG1heCd9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLnJvdF9qaXR0ZXJ9IHRpdGxlPXsnUm90IGppdHQnfSAvPlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC5wb3Nfaml0dGVyfSB0aXRsZT17J1BvcyBqaXR0J30gLz5cblx0XHQ8L1NlbWlNb2RhbD5cblx0XHQ8U2VtaU1vZGFsIGJpbmQ6dGhpcz17dGV4RHluYW1pY3NTZW1pTW9kYWx9IGtub2I9e3RleER5bmFtaWNzS25vYn0+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLnRleF9zdHJldGNoWzBdfSB0aXRsZT17J1N0cmV0Y2ggWCd9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLnRleF9zdHJldGNoWzFdfSB0aXRsZT17J1N0cmV0Y2ggWSd9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLm5vaXNlX3N0cmV0Y2hbMF19IHRpdGxlPXsnTm9pc2UgU3RyZXRjaCBYJ30gLz5cblx0XHRcdDxLbm9iIGJpbmQ6dmFsdWU9e2N1cnJfYnJ1c2gubm9pc2Vfc3RyZXRjaFsxXX0gdGl0bGU9eydOb2lzZSBTdHJldGNoIFknfSAvPlxuXHRcdFx0PEtub2IgYmluZDp2YWx1ZT17Y3Vycl9icnVzaC50ZXhfbGNoX2R5bmFtaWNzWzBdfSB0aXRsZT17J1RleCBWJ30gLz5cblx0XHRcdDxLbm9iIGJpbmQ6dmFsdWU9e2N1cnJfYnJ1c2gudGV4X2xjaF9keW5hbWljc1sxXX0gdGl0bGU9eydUZXggUyd9IC8+XG5cdFx0XHQ8S25vYiBiaW5kOnZhbHVlPXtjdXJyX2JydXNoLnRleF9sY2hfZHluYW1pY3NbMl19IHRpdGxlPXsnVGV4IEgnfSAvPlxuXHRcdFx0PFRleHR1cmVXaWRnZXQgYmluZDpicnVzaF90ZXh0dXJlcz17YnJ1c2hfdGV4dHVyZXN9IGJpbmQ6c2VsZWN0ZWRfYnJ1c2hfdGV4dHVyZT17Y3Vycl9icnVzaC5zZWxlY3RlZF9icnVzaF90ZXh0dXJlfSAvPlxuXHRcdDwvU2VtaU1vZGFsPlxuXHQ8L2Rpdj5cblx0PGNhbnZhcyBpZD1cImNhbnZhc1wiIGJpbmQ6dGhpcz17Y2FudmFzRWxlbWVudH0gLz5cbjwvbWFpbj5cblxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge29uTW91bnR9IGZyb20gJ3N2ZWx0ZSdcblx0aW1wb3J0IHtvbkRlc3Ryb3l9IGZyb20gJ3N2ZWx0ZSdcblx0aW1wb3J0IHtmbG9hdGluZ19tb2RhbF9tZXNzYWdlfSBmcm9tICdzdG9yZSdcblxuXHRpbXBvcnQge3Jlc2l6ZUlmTmVlZGVkIGFzIHJlc2l6ZURlZmF1bHRGcmFtZWJ1ZmZlcklmTmVlZGVkLCBwcmludF9vbl9nbF9lcnJvciwgaW5pdF9nbF9lcnJvcl9oYW5kbGluZywgY29weV9mYl90b190ZXh0dXJlLCBjb3B5X2ZiX3RvX2ZifSBmcm9tICdnbF91dGlscydcblxuXHRpbXBvcnQgS25vYiBmcm9tICcuL0tub2Iuc3ZlbHRlJ1xuXHRpbXBvcnQgQnJ1c2hTaXplV2lkZ2V0IGZyb20gJy4vQnJ1c2hTaXplV2lkZ2V0LnN2ZWx0ZSdcblx0aW1wb3J0IEJydXNoVHlwZVdpZGdldCBmcm9tICcuL0JydXNoVHlwZVdpZGdldC5zdmVsdGUnXG5cdGltcG9ydCBCcnVzaFByZXNldFdpZGdldCBmcm9tICcuL0JydXNoUHJlc2V0V2lkZ2V0LnN2ZWx0ZSdcblx0aW1wb3J0IFVuZG9SZWRvV2lkZ2V0IGZyb20gJy4vVW5kb1JlZG9XaWRnZXQuc3ZlbHRlJ1xuXHRpbXBvcnQgR2FsbGVyeVdpZGdldCBmcm9tICcuL0dhbGxlcnlXaWRnZXQuc3ZlbHRlJ1xuXHRpbXBvcnQgRmxvYXRpbmdNb2RhbCBmcm9tICcuL0Zsb2F0aW5nTW9kYWwuc3ZlbHRlJ1xuXHRpbXBvcnQgUGlja0NvbG91cldpZGdldCBmcm9tICcuL1BpY2tDb2xvdXJXaWRnZXQuc3ZlbHRlJ1xuXHRpbXBvcnQgVGV4dHVyZVdpZGdldCBmcm9tICcuL1RleHR1cmVXaWRnZXQuc3ZlbHRlJ1xuXHRpbXBvcnQgQmxlbmRpbmdDb2xvdXJTcGFjZVdpZGdldCBmcm9tICcuL0JsZW5kaW5nQ29sb3VyU3BhY2VXaWRnZXQuc3ZlbHRlJ1xuXG5cdGltcG9ydCBSR0JTbGlkZXJzIGZyb20gJy4vUkdCU2xpZGVycy5zdmVsdGUnXG5cdGltcG9ydCBDb2xvdXJEaXNwbGF5IGZyb20gJy4vQ29sb3VyRGlzcGxheS5zdmVsdGUnXG5cdGltcG9ydCBTZW1pTW9kYWwgZnJvbSAnLi9TZW1pTW9kYWwuc3ZlbHRlJ1xuXHRpbXBvcnQgRm91ckljb25zV2lkZ2V0IGZyb20gJy4vRm91ckljb25zV2lkZ2V0LnN2ZWx0ZSdcblx0aW1wb3J0IHtJT30gZnJvbSAnSU8nXG5cdGltcG9ydCBjaHJvbWEgZnJvbSAnY2hyb21hLWpzJ1xuXHRpbXBvcnQge0hhc2gsIGFicywgcG93LCB0YXUsIG1peCwgbWF4LCBsb2cyfSBmcm9tICd3bWF0aCdcblx0aW1wb3J0IHtjbGFtcCwgbGVycCwgbW9kLCBzbW9vdGhzdGVwfSBmcm9tICdAMGI1dnIvZXhwZXJpbWVudGFsJ1xuXHRpbXBvcnQge0JydXNoVGV4dHVyZSwgUHJvamVjdCwgVXRpbHN9IGZyb20gJ3N0dWZmJ1xuXHRpbXBvcnQge0JsZW5kaW5nQ29sb3VyU3BhY2UsIEJydXNoUHJlc2V0LCBCcnVzaFN0cm9rZSwgRHJhd1BhcmFtc30gZnJvbSAnYnJ1c2hfc3Ryb2tlJ1xuXHRpbXBvcnQge0RyYXdlcn0gZnJvbSAnZHJhd2VyJ1xuXHRpbXBvcnQgeyBGcmFtZWJ1ZmZlciB9IGZyb20gJ2dsL0ZyYW1lYnVmZmVyJ1xuXHRpbXBvcnQgeyBWZXJ0ZXhCdWZmZXIsIFVCTyB9IGZyb20gJ2dsL0J1ZmZlcidcblx0aW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJ2dsL1RleHR1cmUnXG5cdGltcG9ydCB7IFNoYWRlclByb2dyYW0gfSBmcm9tICdnbC9TaGFkZXJQcm9ncmFtJ1xuXHRpbXBvcnQgeyBUaGluZyB9IGZyb20gJ2dsL1RoaW5nJ1xuXG5cdC8vIEVsZW1lbnRzXG5cdGxldCBjYW52YXNFbGVtZW50OiBIVE1MQ2FudmFzRWxlbWVudFxuXHRsZXQgY2hhb3NTZW1pTW9kYWw6IFNlbWlNb2RhbFxuXHRsZXQgZHluYW1pY3NTZW1pTW9kYWw6IFNlbWlNb2RhbFxuXHRsZXQgdGV4RHluYW1pY3NTZW1pTW9kYWw6IFNlbWlNb2RhbFxuXHRsZXQgbW9kYWxzOiBTZW1pTW9kYWxbXSA9IFtdXG5cdGxldCBjaGFvc0tub2I6IEtub2Jcblx0bGV0IGR5bmFtaWNzS25vYjogS25vYlxuXHRsZXQgdGV4RHluYW1pY3NLbm9iOiBLbm9iXG5cblx0Ly8gVUkgU3RhdGVcblx0bGV0IGJydXNoX3NpemVfd2lkZ2V0X2RyYWdnaW5nOiBib29sZWFuXG5cdGxldCBicnVzaF9zaXplX3dpZGdldF9zdG9wcGVkX2RyYWdnaW5nOiBib29sZWFuXG5cdGxldCBuZXdfcHJvamVjdF9wZW5kaW5nOiBib29sZWFuID0gZmFsc2Vcblx0bGV0IHVuZG9fcGVuZGluZzogYm9vbGVhbiA9IGZhbHNlXG5cdGxldCByZWRvX3BlbmRpbmc6IGJvb2xlYW4gPSBmYWxzZVxuXHRsZXQgbW91c2Vfb3Zlcl9jb2xvdXJfcGlja2VyID0gZmFsc2Vcblx0bGV0IG1vdXNlX292ZXJfY29sb3VyX3BpY2tlcl9maW5pc2hlZCA9IGZhbHNlXG5cdGxldCBwaWNraW5nOiBib29sZWFuXG5cdGxldCBqdXN0X2ZpbmlzaGVkX3BpY2s6IGJvb2xlYW5cblx0bGV0IHBpY2tlZF9jb2w6IG51bWJlcltdID0gWzAsIDAsIDBdXG5cdGxldCBwcm9qZWN0X2hhc19iZWVuX21vZGlmaWVkID0gZmFsc2Vcblx0bGV0IGlzX3NhZmVfdG9fc3dpdGNoX3RvX25ld19wcm9qZWN0XG5cdGxldCBmdWxsX3JlZHJhd19uZWVkZWQ6IGJvb2xlYW4gPSBmYWxzZVxuXHRjb25zdCB6b29tID0gd2luZG93Lnpvb20gPSBGbG9hdDMyQXJyYXkuZnJvbShbMV0pXG5cdGxldCBkZXNpcmVkX3pvb20gPSAxXG5cdGNvbnN0IHBhbm5pbmdfdGVtcF9waW5jaCA9IG5ldyBGbG9hdDMyQXJyYXkoMilcblx0bGV0IHBhbm5pbmcgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG5cdGxldCBicnVzaF9wcmVzZXRzOiBCcnVzaFByZXNldFtdID0gW11cblx0Zm9yKGxldCBpID0gMDsgaSA8IDY7IGkrKyl7XG5cdFx0YnJ1c2hfcHJlc2V0cy5wdXNoKG5ldyBCcnVzaFByZXNldCgpKVxuXHR9XG5cdGxldCBicnVzaF90ZXh0dXJlczogQXJyYXk8QnJ1c2hUZXh0dXJlPiA9IFtdXG5cblx0Ly8gSW50ZXJuYWxzXG5cdGNvbnN0IHVuZG9fY2FjaGVfc3RlcHMgPSAyNVxuXHRjb25zdCBoYXNoID0gbmV3IEhhc2goKVxuXHRsZXQgaW86IElPXG5cdGxldCBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dFxuXHRsZXQgcHJvamVjdCA9IG5ldyBQcm9qZWN0KClcblx0bGV0IHByb2plY3RfcGVuZGluZ19sb2FkOiBQcm9qZWN0XG5cblx0Ly8gR0wgc3R1ZmZcblx0bGV0IGRlZmF1bHRfZnJhbWVidWZmZXI6IEZyYW1lYnVmZmVyXG5cdGxldCBjYW52YXNfZmI6IEZyYW1lYnVmZmVyXG5cdGxldCBjYW52YXNfcmVhZF90ZXg6IFRleHR1cmVcblx0bGV0IHRlbXBfdW5kb19mYjogRnJhbWVidWZmZXJcblx0bGV0IGRyYXdlcjogRHJhd2VyXG5cdGxldCB1Ym86IFVCT1xuXG5cdC8vIERyYXdpbmcgcGFyYW1zXG5cdGxldCBzdHJva2VfY29sOiBBcnJheTxudW1iZXI+ID0gWzAuNSwgMC40LCAwLjMsIDFdXG5cdGxldCBzdHJva2Vfb3BhY2l0eSA9IDBcblx0bGV0IGJydXNoX3JvdDogbnVtYmVyW10gPSBbMCwgMF1cblx0bGV0IGJydXNoX3Bvc19uZGNfc2NyZWVuOiBudW1iZXJbXSA9IFswLCAwXVxuXHRsZXQgYnJ1c2hfcG9zX25kY19jYW52YXM6IG51bWJlcltdID0gWzAsIDBdXG5cdGxldCBicnVzaF9zejogbnVtYmVyW10gPSBbMSwgMC4yXVxuXHRcblx0bGV0IGN1cnJfYnJ1c2g6IEJydXNoUHJlc2V0ID0gYnJ1c2hfcHJlc2V0c1swXVxuXHRsZXQgYmxlbmRpbmdfY29sb3VyX3NwYWNlID0gQmxlbmRpbmdDb2xvdXJTcGFjZS5Pa0xDSFxuXG5cdGxldCBicnVzaF9wYXJhbXNfbWF0ID0gbmV3IEZsb2F0MzJBcnJheSgxNilcblxuXHQvLyBGdW5jc1xuXHRsZXQgcmVzaXplX3Byb2plY3Q6IChzejogbnVtYmVyW10pPT52b2lkXG5cdGxldCB0cmlnZ2VyX2NvbG91cl9kaXNwbGF5X3VwZGF0ZTogKGNvbG91cl9yLCBjb2xvdXJfZywgY29sb3VyX2IpPT52b2lkXG5cblx0Y29uc3Qgc2V0X3NoYXJlZF91bmlmb3JtcyA9ICgpID0+IHtcblx0XHR1Ym8uYnVmZi5zeiA9IDBcblx0XHR1Ym8uYnVmZi5jcHVfYnVmZlswXSA9IGNhbnZhc19mYi5fdGV4dHVyZXNbMF0ucmVzWzBdXG5cdFx0dWJvLmJ1ZmYuY3B1X2J1ZmZbMV0gPSBjYW52YXNfZmIuX3RleHR1cmVzWzBdLnJlc1sxXVxuXHRcdHViby5idWZmLmNwdV9idWZmWzJdID0gZGVmYXVsdF9mcmFtZWJ1ZmZlci50ZXh0dXJlc1swXS5yZXNbMF1cblx0XHR1Ym8uYnVmZi5jcHVfYnVmZlszXSA9IGRlZmF1bHRfZnJhbWVidWZmZXIudGV4dHVyZXNbMF0ucmVzWzFdXG5cdFx0dWJvLmJ1ZmYuY3B1X2J1ZmZbNF0gPSBpc09uTW9iaWxlID8gMSA6IDBcblx0XHR1Ym8uYnVmZi51cGxvYWQoKVxuXHR9XG5cblx0Y29uc3QgcGlja19mcm9tX2NhbnZhcyA9ICgpID0+IHtcblx0XHRsZXQgY29vcmQgPSBVdGlscy50ZXh0dXJlX05EQ190b190ZXh0dXJlX3BpeGVsX2Nvb3Jkcyhcblx0XHRcdFV0aWxzLnNjcmVlbl9ORENfdG9fY2FudmFzX05EQyhbLi4uaW8ubW91c2VfcG9zXSwgZGVmYXVsdF9mcmFtZWJ1ZmZlci50ZXh0dXJlc1swXSwgY2FudmFzX3JlYWRfdGV4LCB6b29tWzBdLCBwYW5uaW5nKSxcblx0XHRcdGNhbnZhc19yZWFkX3RleCxcblx0XHQpXG5cdFx0bGV0IGMgPSBjYW52YXNfcmVhZF90ZXgucmVhZF9iYWNrX3BpeGVsKGNvb3JkKVxuXHRcdC8vIGNvbnNvbGUubG9nKGMpXG5cblx0XHRwaWNrZWRfY29sID0gWy4uLmNdXG5cdFx0cGlja2VkX2NvbFswXSA9IGNbMF0gLyAyNTVcblx0XHRwaWNrZWRfY29sWzFdID0gY1sxXSAvIDI1NVxuXHRcdHBpY2tlZF9jb2xbMl0gPSBjWzJdIC8gMjU1XG5cdFx0cGlja2VkX2NvbFswXSA9IHBvdyhwaWNrZWRfY29sWzBdLCAwLjQ1NDU0NTQ1NDU0NTQ1KVxuXHRcdHBpY2tlZF9jb2xbMV0gPSBwb3cocGlja2VkX2NvbFsxXSwgMC40NTQ1NDU0NTQ1NDU0NSlcblx0XHRwaWNrZWRfY29sWzJdID0gcG93KHBpY2tlZF9jb2xbMl0sIDAuNDU0NTQ1NDU0NTQ1NDUpXG5cdFx0cGlja2VkX2NvbC5wb3AoKVxuXHRcdHJldHVybiBjXG5cdH1cblxuXHRjb25zdCBvcGVuTW9kYWwgPSAobW9kYWw6IFNlbWlNb2RhbCkgPT4ge1xuXHRcdGZvciAobGV0IG0gb2YgbW9kYWxzKSB7XG5cdFx0XHRpZiAobSA9PT0gbW9kYWwpIHtcblx0XHRcdFx0aWYgKG0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0bS5oaWRkZW4gPSBmYWxzZVxuXHRcdFx0XHRcdG0ua25vYi5tb2RhbEhpZGRlbiA9IGZhbHNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bS5oaWRkZW4gPSB0cnVlXG5cdFx0XHRcdFx0bS5rbm9iLm1vZGFsSGlkZGVuID0gdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBtLmhpZGUoKVxuXHRcdFx0XHRtLmhpZGRlbiA9IHRydWVcblx0XHRcdFx0bS5rbm9iLm1vZGFsSGlkZGVuID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGNvbnN0IGluaXRfd2ViX2dsID0gKCkgPT4ge1xuXHRcdHdpbmRvdy5pc09uTW9iaWxlID0gVXRpbHMuaXNPbk1vYmlsZSgpXG5cdFx0Ly9AdHMtaWdub3JlXG5cdFx0d2luZG93LmdsID0gZ2wgPSBjYW52YXNFbGVtZW50LmdldENvbnRleHQoJ3dlYmdsMicsIHtcblx0XHRcdHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZSxcblx0XHRcdGFscGhhOiBmYWxzZSxcblx0XHRcdHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG5cdFx0XHRhbnRpYWxpYXM6IHRydWVcblx0XHR9KVxuXHRcdGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcblx0XHRnbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpO1xuXHRcdGdsLmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuXG5cblx0XHRnbC5kZWJ1Z0VuYWJsZWQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50J1xuXHRcdGdsLmRlYnVnRW5hYmxlZCA9IGZhbHNlXG5cdFx0aW5pdF9nbF9lcnJvcl9oYW5kbGluZygpXG5cblx0XHRjb25zdCB1c2VyQWdlbnRSZXMgPSBbY2FudmFzRWxlbWVudC5jbGllbnRXaWR0aCwgY2FudmFzRWxlbWVudC5jbGllbnRXaWR0aF1cblxuXHRcdGRlZmF1bHRfZnJhbWVidWZmZXIgPSBPYmplY3QuY3JlYXRlKEZyYW1lYnVmZmVyLnByb3RvdHlwZSlcblx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLmRlZmF1bHQgPSB0cnVlXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci5wb25nYWJsZSA9IGZhbHNlXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci5uZWVkc19wb25nID0gZmFsc2Vcblx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLnBvbmdfaWR4ID0gMFxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLl9mYiA9IG51bGxcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci5fdGV4dHVyZXMgPSBbT2JqZWN0LmNyZWF0ZShUZXh0dXJlLnByb3RvdHlwZSldXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci50ZXh0dXJlc1swXS5yZXMgPSBbLi4udXNlckFnZW50UmVzXVxuXG5cdFx0ZGVmYXVsdF9mcmFtZWJ1ZmZlci5iaW5kKClcblxuXHRcdGNhbnZhc19mYiA9IG5ldyBGcmFtZWJ1ZmZlcihbXG5cdFx0XHRuZXcgVGV4dHVyZShbcHJvamVjdC5jYW52YXNSZXNbMF0sIHByb2plY3QuY2FudmFzUmVzWzFdXSwgZ2wuUkdCQTE2RiwgIWlzT25Nb2JpbGUpIFxuXHRcdF0sIHRydWUpXG5cblx0XHR0ZW1wX3VuZG9fZmIgPSBuZXcgRnJhbWVidWZmZXIoW1xuXHRcdFx0bmV3IFRleHR1cmUoW3Byb2plY3QuY2FudmFzUmVzWzBdLCBwcm9qZWN0LmNhbnZhc1Jlc1sxXV0sIGdsLlJHQkExNkYsIGZhbHNlKSBcblx0XHRdLCBmYWxzZSlcblx0XHRcblxuXHRcdHVibyA9IG5ldyBVQk8oKVxuXHRcdHdpbmRvdy51Ym8gPSB1Ym9cblx0XHRcblxuXHRcdHJlc2l6ZURlZmF1bHRGcmFtZWJ1ZmZlcklmTmVlZGVkKGNhbnZhc0VsZW1lbnQsIGRlZmF1bHRfZnJhbWVidWZmZXIsIHVzZXJBZ2VudFJlcywgKGUpID0+IHt9LCAoKT0+e3NldF9zaGFyZWRfdW5pZm9ybXMoKX0pXG5cdFx0c2V0X3NoYXJlZF91bmlmb3JtcygpXG5cblx0XHRnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSlcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpXG5cdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKVxuXHRcdFxuXHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCk7XG5cdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCkgXG5cdH1cblx0Y29uc3QgaW5pdF9vdGhlcl9zdHVmZiA9IGFzeW5jICgpID0+IHtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLChldmVudCk9Pntcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fSlcblx0XHRpZiAoXCJ3YWtlTG9ja1wiIGluIG5hdmlnYXRvcikge1xuXHRcdFx0dHJ5e1xuXHRcdFx0XHRjb25zdCB3YWtlTG9jayA9IGF3YWl0IG5hdmlnYXRvci53YWtlTG9jay5yZXF1ZXN0KFwic2NyZWVuXCIpO1xuXHRcdFx0fSBjYXRjaChfKXtcblxuXHRcdFx0fVxuXHRcdH0gXG5cdFx0aW8gPSBuZXcgSU8oKVxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgKGV2ZW50KSA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpKVxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsICgpPT4ge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0d2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblx0XHR9KTtcblxuXHRcdGJydXNoX3RleHR1cmVzLnB1c2goXG5cdFx0XHRhd2FpdCBCcnVzaFRleHR1cmUuY3JlYXRlKHJlcXVpcmUoXCIuLi8uLi9wdWJsaWMvaW1hZ2VzL2Jyb3cud2VicFwiKS5kZWZhdWx0LCAwKVxuXHRcdClcblx0XHRicnVzaF90ZXh0dXJlcy5wdXNoKFxuXHRcdFx0YXdhaXQgQnJ1c2hUZXh0dXJlLmNyZWF0ZShyZXF1aXJlKFwiLi4vLi4vcHVibGljL2ltYWdlcy9jaGFyY29hbC53ZWJwXCIpLmRlZmF1bHQsIDEpXG5cdFx0KVxuXHRcdGJydXNoX3RleHR1cmVzLnB1c2goXG5cdFx0XHRhd2FpdCBCcnVzaFRleHR1cmUuY3JlYXRlKHJlcXVpcmUoXCIuLi8uLi9wdWJsaWMvaW1hZ2VzL2NpcmNsZS53ZWJwXCIpLmRlZmF1bHQsIDIpXG5cdFx0KVxuXHRcdGJydXNoX3RleHR1cmVzLnB1c2goXG5cdFx0XHRhd2FpdCBCcnVzaFRleHR1cmUuY3JlYXRlKHJlcXVpcmUoXCIuLi8uLi9wdWJsaWMvaW1hZ2VzL2dyYWRpZW50X2JvdHRvbV90b190b3Aud2VicFwiKS5kZWZhdWx0LCAzKVxuXHRcdClcblx0XHRicnVzaF90ZXh0dXJlcy5wdXNoKFxuXHRcdFx0YXdhaXQgQnJ1c2hUZXh0dXJlLmNyZWF0ZShyZXF1aXJlKFwiLi4vLi4vcHVibGljL2ltYWdlcy9vaWxfMDEud2VicFwiKS5kZWZhdWx0LCA0KVxuXHRcdClcblx0XHRicnVzaF90ZXh0dXJlcy5wdXNoKFxuXHRcdFx0YXdhaXQgQnJ1c2hUZXh0dXJlLmNyZWF0ZShyZXF1aXJlKFwiLi4vLi4vcHVibGljL2ltYWdlcy9vaWxfdGFwZXIud2VicFwiKS5kZWZhdWx0LCA1KVxuXHRcdClcblx0XHRicnVzaF90ZXh0dXJlcy5wdXNoKFxuXHRcdFx0YXdhaXQgQnJ1c2hUZXh0dXJlLmNyZWF0ZShyZXF1aXJlKFwiLi4vLi4vcHVibGljL2ltYWdlcy9zcXVhcmUud2VicFwiKS5kZWZhdWx0LCA2KVxuXHRcdClcblx0XHRicnVzaF90ZXh0dXJlcyA9IFsuLi5icnVzaF90ZXh0dXJlc11cblxuXHRcdGZvcihsZXQgYnJ1c2ggb2YgYnJ1c2hfcHJlc2V0cyl7XG5cdFx0XHRicnVzaC5zZWxlY3RlZF9icnVzaF90ZXh0dXJlID0gYnJ1c2hfdGV4dHVyZXNbMF1cblx0XHR9XG5cdFx0bW9kYWxzID0gW2NoYW9zU2VtaU1vZGFsLCBkeW5hbWljc1NlbWlNb2RhbCwgdGV4RHluYW1pY3NTZW1pTW9kYWxdXG5cdH1cblxuXHRvbk1vdW50KGFzeW5jICgpID0+IHtcblx0XHRpbml0X3dlYl9nbCgpXG5cdFx0YXdhaXQgaW5pdF9vdGhlcl9zdHVmZigpXG5cblx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLmJpbmQoKVxuXHRcdGRlZmF1bHRfZnJhbWVidWZmZXIuY2xlYXIoWzAsIDAsIDAsIDFdKVxuIFxuXHRcdGNhbnZhc19mYi5jbGVhcihbMCwgMCwgMCwgMF0pXG5cdFx0Y2FudmFzX2ZiLnBvbmcoKVxuXHRcdGNhbnZhc19mYi5iYWNrX3RleHR1cmVzWzBdLmJpbmRfdG9fdW5pdCgxKVxuXHRcdGNhbnZhc19mYi5jbGVhcihbMCwgMCwgMCwgMF0pXG5cblx0XHRjb25zdCB0ZW1wX3N0cm9rZV9mYiA9IG5ldyBGcmFtZWJ1ZmZlcihbXG5cdFx0XHRuZXcgVGV4dHVyZShbcHJvamVjdC5jYW52YXNSZXNbMF0sIHByb2plY3QuY2FudmFzUmVzWzFdXSwgZ2wuUkdCQTE2RiwgIWlzT25Nb2JpbGUpXG5cdFx0XSlcblx0XHR0ZW1wX3N0cm9rZV9mYi5jbGVhcihbMCwgMCwgMCwgMF0pXG5cblx0XHQvLyEgLS0tLS0tLS0tLS0tLS0tLS0tLSBTSEFERVJTXG5cdFx0Y29uc3QgaW5pdF90ZXh0dXJlX3VuaWZvcm1zID0gKHByb2dyYW06IFNoYWRlclByb2dyYW0pID0+e1xuXHRcdFx0cHJvZ3JhbS5zZXRVbmlmb3JtVGV4dHVyZSgndGVtcF90ZXgnLCB0ZW1wX3N0cm9rZV9mYi50ZXh0dXJlc1swXSwgMClcblx0XHRcdHByb2dyYW0uc2V0VW5pZm9ybVRleHR1cmUoJ2NhbnZhc19iYWNrJywgY2FudmFzX2ZiLmJhY2tfdGV4dHVyZXNbMF0sIDEpXG5cdFx0XHRwcm9ncmFtLnNldFVuaWZvcm1UZXh0dXJlKCdjYW52YXNfYicsIGNhbnZhc19mYi5fdGV4dHVyZXNbMF0sIDIpXG5cdFx0XHRwcm9ncmFtLnNldFVuaWZvcm1UZXh0dXJlKCdjYW52YXNfYScsIGNhbnZhc19mYi5fYmFja190ZXh0dXJlc1swXSwgMylcblx0XHRcdFxuXHRcdFx0Y29uc3QgYnJ1c2hfdGV4X3N0YXJ0X2lkeCA9IDVcblx0XHRcdGJydXNoX3RleHR1cmVzLmZvckVhY2goKGJydXNoX3RleCwgaSApPT57XG5cdFx0XHRcdGNvbnN0IG5hbWUgPSBgYnJ1c2hfdGV4dHVyZVske2l9XWBcblx0XHRcdFx0Y29uc29sZS5sb2cobmFtZSlcblx0XHRcdFx0Y29uc3QgYnJ1c2hfdGV4dHVyZXNfbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0ucHJvZ3JhbSwgbmFtZSlcblx0XHRcdFx0YnJ1c2hfdGV4LmdwdV90ZXguYmluZF90b191bml0KGJydXNoX3RleF9zdGFydF9pZHggKyBpKVx0XHRcdFx0XG5cdFx0XHRcdGdsLnVuaWZvcm0xaShicnVzaF90ZXh0dXJlc19sb2MsIGJydXNoX3RleF9zdGFydF9pZHggKyBpKTtcblx0XHRcdH0pXG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKSAvLyBUT0RFTEVURVxuXHRcdH1cblx0XHRjb25zdCBicnVzaF9wcmV2aWV3X3Byb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShyZXF1aXJlKCdzaGFkZXJzL2JydXNoX3ByZXZpZXcudmVydCcpLCByZXF1aXJlKCdzaGFkZXJzL2JydXNoX3ByZXZpZXcuZnJhZycpKVxuXHRcdGNvbnN0IGNvbG91cl9wcmV2aWV3X3Byb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShyZXF1aXJlKCdzaGFkZXJzL2NvbG91cl9wcmV2aWV3LnZlcnQnKSwgcmVxdWlyZSgnc2hhZGVycy9jb2xvdXJfcHJldmlldy5mcmFnJykpXG5cdFx0Y29uc3QgcGlja2VyX3Byb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShyZXF1aXJlKCdzaGFkZXJzL3BpY2tlci52ZXJ0JyksIHJlcXVpcmUoJ3NoYWRlcnMvcGlja2VyLmZyYWcnKSlcblx0XHRjb25zdCBjb21wb3NpdGVfc3Ryb2tlX3RvX2NhbnZhc19wcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0oXG5cdFx0XHRyZXF1aXJlKCdzaGFkZXJzL2NvbXBvc2l0ZV90ZW1wX3N0cm9rZV90b19jYW52YXMudmVydCcpLFxuXHRcdFx0cmVxdWlyZSgnc2hhZGVycy9jb21wb3NpdGVfdGVtcF9zdHJva2VfdG9fY2FudmFzLmZyYWcnKSxcblx0XHQpXG5cdFx0Y29uc3QgY29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfYl9wcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0oXG5cdFx0XHRyZXF1aXJlKCdzaGFkZXJzL2NvbXBvc2l0ZV90ZW1wX3N0cm9rZV90b19jYW52YXMudmVydCcpLFxuXHRcdFx0cmVxdWlyZSgnc2hhZGVycy9jb21wb3NpdGVfdGVtcF9zdHJva2VfdG9fY2FudmFzX2IuZnJhZycpLFxuXHRcdClcblx0XHRjb25zdCBwb3N0X2NhbnZhc19wcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0ocmVxdWlyZSgnc2hhZGVycy9wb3N0X2NhbnZhcy52ZXJ0JyksIHJlcXVpcmUoJ3NoYWRlcnMvcG9zdF9jYW52YXMuZnJhZycpKVxuXHRcdC8vQHRzLWlnbm9yZVxuXHRcdHBvc3RfY2FudmFzX3Byb2dyYW0uem9vbV9sb2MgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocG9zdF9jYW52YXNfcHJvZ3JhbS5wcm9ncmFtLCBcInpvb21cIilcblx0XHQvL0B0cy1pZ25vcmVcblx0XHRwb3N0X2NhbnZhc19wcm9ncmFtLnBhbm5pbmdfbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHBvc3RfY2FudmFzX3Byb2dyYW0ucHJvZ3JhbSwgXCJwYW5uaW5nXCIpXG5cdFx0Ly9AdHMtaWdub3JlXG5cdFx0cG9zdF9jYW52YXNfcHJvZ3JhbS5ibGVuZGluZ19jb2xvdXJfc3BhY2VfbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHBvc3RfY2FudmFzX3Byb2dyYW0ucHJvZ3JhbSwgXCJibGVuZGluZ19jb2xvdXJfc3BhY2VcIilcblx0XHRcblx0XHRjb25zdCBicnVzaF9sb25nX3Byb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShyZXF1aXJlKCdzaGFkZXJzL2JydXNoX2xvbmcudmVydCcpLCByZXF1aXJlKCdzaGFkZXJzL2JydXNoX2xvbmcuZnJhZycpKVxuXG5cdFx0YnJ1c2hfcHJldmlld19wcm9ncmFtLnVzZSgpXG5cdFx0aW5pdF90ZXh0dXJlX3VuaWZvcm1zKGJydXNoX3ByZXZpZXdfcHJvZ3JhbSlcblx0XHRjb2xvdXJfcHJldmlld19wcm9ncmFtLnVzZSgpXG5cdFx0aW5pdF90ZXh0dXJlX3VuaWZvcm1zKGNvbG91cl9wcmV2aWV3X3Byb2dyYW0pXG5cdFx0cGlja2VyX3Byb2dyYW0udXNlKClcblx0XHRpbml0X3RleHR1cmVfdW5pZm9ybXMocGlja2VyX3Byb2dyYW0pXG5cdFx0Y29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfcHJvZ3JhbS51c2UoKVxuXHRcdGluaXRfdGV4dHVyZV91bmlmb3Jtcyhjb21wb3NpdGVfc3Ryb2tlX3RvX2NhbnZhc19wcm9ncmFtKVxuXHRcdGNvbXBvc2l0ZV9zdHJva2VfdG9fY2FudmFzX2JfcHJvZ3JhbS51c2UoKVxuXHRcdGluaXRfdGV4dHVyZV91bmlmb3Jtcyhjb21wb3NpdGVfc3Ryb2tlX3RvX2NhbnZhc19iX3Byb2dyYW0pXG5cdFx0Ly9AdHMtaWdub3JlXG5cdFx0Y29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfcHJvZ3JhbS5ibGVuZGluZ19jb2xvdXJfc3BhY2VfbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGNvbXBvc2l0ZV9zdHJva2VfdG9fY2FudmFzX3Byb2dyYW0ucHJvZ3JhbSwgXCJibGVuZGluZ19jb2xvdXJfc3BhY2VcIilcblx0XHQvL0B0cy1pZ25vcmVcblx0XHRjb21wb3NpdGVfc3Ryb2tlX3RvX2NhbnZhc19iX3Byb2dyYW0uYmxlbmRpbmdfY29sb3VyX3NwYWNlX2xvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihjb21wb3NpdGVfc3Ryb2tlX3RvX2NhbnZhc19iX3Byb2dyYW0ucHJvZ3JhbSwgXCJibGVuZGluZ19jb2xvdXJfc3BhY2VcIilcblxuXHRcdHBvc3RfY2FudmFzX3Byb2dyYW0udXNlKClcblx0XHRpbml0X3RleHR1cmVfdW5pZm9ybXMocG9zdF9jYW52YXNfcHJvZ3JhbSlcblxuXHRcdGJydXNoX2xvbmdfcHJvZ3JhbS51c2UoKVxuXHRcdGluaXRfdGV4dHVyZV91bmlmb3JtcyhicnVzaF9sb25nX3Byb2dyYW0pXG5cdFx0Ly9AdHMtaWdub3JlXG5cdFx0YnJ1c2hfbG9uZ19wcm9ncmFtLmJydXNoX3BhcmFtc19sb2MgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oYnJ1c2hfbG9uZ19wcm9ncmFtLnByb2dyYW0sIFwiYnJ1c2hfcGFyYW1zXCIpXG5cdFx0XG5cblx0XHQvLyEgLS0tLS0tLS0tLS0tLS0tLS0tLSBQT1NUXG5cdFx0bGV0IGZyYW1lID0gMFxuXHRcdGNhbnZhc19yZWFkX3RleCA9IGNhbnZhc19mYi50ZXh0dXJlc1swXVxuXG5cblx0XHRsZXQgYnJ1c2hfYnVmZmVyID0gbmV3IFRoaW5nKFxuXHRcdFx0W25ldyBWZXJ0ZXhCdWZmZXIoNCwgZ2wuRkxPQVQpLCBuZXcgVmVydGV4QnVmZmVyKDQsIGdsLkZMT0FUKV0sXG5cdFx0XHRnbC5UUklBTkdMRVMsXG5cdFx0XHRicnVzaF9sb25nX3Byb2dyYW1cblx0XHQpXG5cdFx0Z2wuYmluZFZlcnRleEFycmF5KGJydXNoX2J1ZmZlci52YW8pXG5cdFx0XG5cblx0XHRsZXQgdDogbnVtYmVyID0gMFxuXHRcdGxldCBkZWx0YV90OiBudW1iZXIgPSAwXG5cdFx0bGV0IHJlZHJhd19uZWVkZWQgPSBmYWxzZVxuXG5cdFx0bGV0IHJlZG9faGlzdG9yeV9sZW5ndGggPSAwXG5cblx0XHRsZXQgYnJ1c2hfc3Ryb2tlID0gbmV3IEJydXNoU3Ryb2tlKFxuXHRcdFx0Y3Vycl9icnVzaC5zZWxlY3RlZF9icnVzaF90eXBlLCBcblx0XHRcdG5ldyBEcmF3UGFyYW1zKFxuXHRcdFx0XHRjdXJyX2JydXNoLnRleF9keW5hbWljcywgXG5cdFx0XHRcdGN1cnJfYnJ1c2gudGV4X2xjaF9keW5hbWljcywgXG5cdFx0XHRcdGN1cnJfYnJ1c2gubm9pc2Vfc3RyZXRjaCwgXG5cdFx0XHRcdGN1cnJfYnJ1c2gudGV4X3N0cmV0Y2gsIFxuXHRcdFx0XHRCbGVuZGluZ0NvbG91clNwYWNlLlBpZ21lbnRzXG5cdFx0XHRcdCksXG5cdFx0XHRcdGN1cnJfYnJ1c2guc2VsZWN0ZWRfYnJ1c2hfdGV4dHVyZVxuXHRcdFx0KVxuXG5cblx0XHRkcmF3ZXIgPSBuZXcgRHJhd2VyKFxuXHRcdFx0Z2wsXG5cdFx0XHRjYW52YXNfZmIudGV4dHVyZXNbMF0sXG5cdFx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLFxuXHRcdClcblx0XHRjb25zdCBjb21wb3NpdGVfc3Ryb2tlID0gKCkgPT4ge1xuXHRcdFx0Y2FudmFzX2ZiLmJpbmQoKVxuXHRcdFx0Y2FudmFzX2ZiLmNsZWFyKClcblxuXHRcdFx0Y29uc3QgY29tcF9wcm9ncmFtID0gY2FudmFzX2ZiLnBvbmdfaWR4ID09PSAwID8gY29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfcHJvZ3JhbSA6IGNvbXBvc2l0ZV9zdHJva2VfdG9fY2FudmFzX2JfcHJvZ3JhbVxuXHRcdFx0aWYoY2FudmFzX2ZiLnBvbmdfaWR4ID09PSAwKXtcblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRjb21wX3Byb2dyYW0udXNlKClcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGdsLnVuaWZvcm0xaShjb21wX3Byb2dyYW0uYmxlbmRpbmdfY29sb3VyX3NwYWNlX2xvYywgYmxlbmRpbmdfY29sb3VyX3NwYWNlKVxuXHRcdFx0Y2FudmFzX2ZiLmJhY2tfdGV4dHVyZXNbMF0uYmluZF90b191bml0KDEpXG5cdFx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KVxuXHRcdFx0dGVtcF9zdHJva2VfZmIuY2xlYXIoKVxuXHRcdH1cblx0XHRcblx0XHRjb25zdCBkcmF3X25fc3Ryb2tlcyA9IChzdGFydF9pZHg6IG51bWJlciB8IHVuZGVmaW5lZCwgZW5kX2lkeDogbnVtYmVyIHwgdW5kZWZpbmVkLCBmdWxsX3JlZHJhdzogYm9vbGVhbiA9IGZhbHNlKT0+e1xuXHRcdFx0bGV0IGsgPSAwXG5cdFx0XHRcblx0XHRcdGRyYXdlci5icnVzaF9idWZmZXIgPSBicnVzaF9idWZmZXJcblx0XHRcdGRyYXdlci5yZXNldCgpXG5cdFx0XHRcblx0XHRcdHN0YXJ0X2lkeCA9IHN0YXJ0X2lkeCA/PyAwXG5cdFx0XHRlbmRfaWR4ID0gZW5kX2lkeCA/PyBwcm9qZWN0LmJydXNoX3N0cm9rZXMubGVuZ3RoXG5cdFx0XHRcblx0XHRcdGZvcihrID0gc3RhcnRfaWR4OyBrIDwgZW5kX2lkeDsgaysrKXtcblx0XHRcdFx0ZHJhd2VyLnB1c2hfYW55X3N0cm9rZShwcm9qZWN0LmJydXNoX3N0cm9rZXNba10pXG5cdFx0XHR9XG5cblx0XHRcdGRyYXdlci5icnVzaF9idWZmZXIudXBsb2FkX2FsbF9idWZmcygpXG5cdFx0XHRjb25zdCBicnVzaF9zaGFkZXIgPSBkcmF3ZXIuYnJ1c2hfYnVmZmVyLnNoYWRlclxuXHRcdFx0YnJ1c2hfc2hhZGVyLnVzZSgpXG5cblx0XHRcdGxldCBwcmV2X2NvbG91cl9zcGFjZSA9IC0xXG5cdFx0XHRsZXQgcHJldl9jb2xvdXJfc3BhY2VfYiA9IC0xXG5cdFx0XHRsZXQgcHJldl9icnVzaF90ZXhfaWR4ID0gLTFcblx0XHRcdFxuXHRcdFx0bGV0IHByZXZfaHN2X2R5bmFtaWNzID0gWy05OTk5LC05OTk5LC05OTk5XVxuXHRcdFx0bGV0IHByZXZfbm9pc2Vfc3RyZXRjaCA9IFstOTk5OSwtOTk5OV1cblx0XHRcdGxldCBwcmV2X3RleF9zdHJldGNoID0gWy05OTk5LC05OTk5XVxuXG5cblx0XHRcdGdsLnVzZVByb2dyYW0oY29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfcHJvZ3JhbS5wcm9ncmFtKVxuXG5cdFx0XHRjYW52YXNfZmIuX3RleHR1cmVzWzBdLmJpbmRfdG9fdW5pdCgyKVxuXHRcdFx0Y2FudmFzX2ZiLl9iYWNrX3RleHR1cmVzWzBdLmJpbmRfdG9fdW5pdCgzKVxuXG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxNSlcblx0XHRcdGxldCBjb21wX3Byb2dyYW0gPSBjb21wb3NpdGVfc3Ryb2tlX3RvX2NhbnZhc19wcm9ncmFtXG5cdFx0XHRnbC5jbGVhckNvbG9yKDAsMCwwLDApXG5cdFx0XHRnbC52aWV3cG9ydCgwLCAwLCBwcm9qZWN0LmNhbnZhc1Jlc1swXSwgcHJvamVjdC5jYW52YXNSZXNbMV0pXG5cblx0XHRcdGsgPSBzdGFydF9pZHhcblx0XHRcdGxldCBqID0gMFxuXHRcdFx0XG5cdFx0XHRmb3IobGV0IGFtb2d1cyBvZiBkcmF3ZXIucmVjb3JkZWRfZHJhd2NhbGxzKXtcblx0XHRcdFx0Y29uc3QgbmV3X25vaXNlX3N0cmV0Y2ggPSBwcm9qZWN0LmJydXNoX3N0cm9rZXNba10uZHJhd19wYXJhbXMubm9pc2Vfc3RyZXRjaFxuXHRcdFx0XHRjb25zdCBuZXdfdGV4X3N0cmV0Y2ggPSBwcm9qZWN0LmJydXNoX3N0cm9rZXNba10uZHJhd19wYXJhbXMudGV4X3N0cmV0Y2hcblx0XHRcdFx0Y29uc3QgbmV3X2hzdl9keW5hbWljcyA9IHByb2plY3QuYnJ1c2hfc3Ryb2tlc1trXS5kcmF3X3BhcmFtcy50ZXhfbGNoX2R5bmFtaWNzXG5cblx0XHRcdFx0Y29uc3QgbmV3X2JydXNoX3RleF9pZHggPSBwcm9qZWN0LmJydXNoX3N0cm9rZXNba10uYnJ1c2hfdGV4dHVyZS5pZHhcblx0XHRcdFx0Y29uc3QgbmV3X2NvbF9zcGFjZSA9IHByb2plY3QuYnJ1c2hfc3Ryb2tlc1trXS5kcmF3X3BhcmFtcy5ibGVuZGluZ19jb2xvdXJfc3BhY2VcblxuXHRcdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRlbXBfc3Ryb2tlX2ZiLmZiKVxuXHRcdFx0XHRnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKVxuXG5cdFx0XHRcdGJydXNoX3NoYWRlci51c2UoKVxuXG5cdFx0XHRcdGlmKFxuXHRcdFx0XHRcdG5ld19icnVzaF90ZXhfaWR4ICE9PSBwcmV2X2JydXNoX3RleF9pZHggfHxcblx0XHRcdFx0XHRwcmV2X2hzdl9keW5hbWljc1swXSAhPT0gbmV3X2hzdl9keW5hbWljc1swXSB8fCBcblx0XHRcdFx0XHRwcmV2X2hzdl9keW5hbWljc1sxXSAhPT0gbmV3X2hzdl9keW5hbWljc1sxXSB8fCBcblx0XHRcdFx0XHRwcmV2X2hzdl9keW5hbWljc1syXSAhPT0gbmV3X2hzdl9keW5hbWljc1syXSB8fFxuXHRcdFx0XHRcdHByZXZfbm9pc2Vfc3RyZXRjaFswXSAhPT0gbmV3X25vaXNlX3N0cmV0Y2hbMF0gfHwgXG5cdFx0XHRcdFx0cHJldl9ub2lzZV9zdHJldGNoWzFdICE9PSBuZXdfbm9pc2Vfc3RyZXRjaFsxXSB8fFxuXHRcdFx0XHRcdHByZXZfdGV4X3N0cmV0Y2hbMF0gIT09IG5ld190ZXhfc3RyZXRjaFswXSB8fCBcblx0XHRcdFx0XHRwcmV2X3RleF9zdHJldGNoWzFdICE9PSBuZXdfdGV4X3N0cmV0Y2hbMV0gXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KXtcblx0XHRcdFx0XHRicnVzaF9wYXJhbXNfbWF0WzBdID0gbmV3X2JydXNoX3RleF9pZHhcblx0XHRcdFx0XHRicnVzaF9wYXJhbXNfbWF0WzFdID0gbmV3X2hzdl9keW5hbWljc1swXVxuXHRcdFx0XHRcdGJydXNoX3BhcmFtc19tYXRbMl0gPSBuZXdfaHN2X2R5bmFtaWNzWzFdXG5cdFx0XHRcdFx0YnJ1c2hfcGFyYW1zX21hdFszXSA9IG5ld19oc3ZfZHluYW1pY3NbMl1cblx0XHRcdFx0XHRicnVzaF9wYXJhbXNfbWF0WzRdID0gbmV3X25vaXNlX3N0cmV0Y2hbMF1cblx0XHRcdFx0XHRicnVzaF9wYXJhbXNfbWF0WzVdID0gbmV3X25vaXNlX3N0cmV0Y2hbMV1cblx0XHRcdFx0XHRicnVzaF9wYXJhbXNfbWF0WzZdID0gbmV3X3RleF9zdHJldGNoWzBdXG5cdFx0XHRcdFx0YnJ1c2hfcGFyYW1zX21hdFs3XSA9IG5ld190ZXhfc3RyZXRjaFsxXSBcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdihicnVzaF9zaGFkZXIuYnJ1c2hfcGFyYW1zX2xvYywgZmFsc2UsIGJydXNoX3BhcmFtc19tYXQpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkcmF3ZXIuZHJhd19zdHJva2VfaWR4KGopXG5cblx0XHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBjYW52YXNfZmIuZmIpXG5cblx0XHRcdFx0Y29tcF9wcm9ncmFtID0gY2FudmFzX2ZiLnBvbmdfaWR4ID09PSAwID8gY29tcG9zaXRlX3N0cm9rZV90b19jYW52YXNfcHJvZ3JhbSA6IGNvbXBvc2l0ZV9zdHJva2VfdG9fY2FudmFzX2JfcHJvZ3JhbVxuXHRcdFx0XHRjb21wX3Byb2dyYW0udXNlKClcblxuXHRcdFx0XHRpZihjYW52YXNfZmIucG9uZ19pZHggPT09IDApe1xuXHRcdFx0XHRcdGlmKG5ld19jb2xfc3BhY2UgIT09IHByZXZfY29sb3VyX3NwYWNlKXtcblx0XHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0xaShjb21wX3Byb2dyYW0uYmxlbmRpbmdfY29sb3VyX3NwYWNlX2xvYywgcHJldl9jb2xvdXJfc3BhY2UgPSBuZXdfY29sX3NwYWNlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZihuZXdfY29sX3NwYWNlICE9PSBwcmV2X2NvbG91cl9zcGFjZV9iKXtcblx0XHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0xaShjb21wX3Byb2dyYW0uYmxlbmRpbmdfY29sb3VyX3NwYWNlX2xvYywgcHJldl9jb2xvdXJfc3BhY2VfYiA9IG5ld19jb2xfc3BhY2UpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNClcblxuXHRcdFx0XHRjYW52YXNfZmIucG9uZygpXG5cdFx0XHRcdFxuXHRcdFx0XHRpZihmdWxsX3JlZHJhdyAmJiBqID09PSBlbmRfaWR4IC0gKGVuZF9pZHggJSB1bmRvX2NhY2hlX3N0ZXBzKSAtIDEpe1xuXHRcdFx0XHRcdGNvcHlfZmJfdG9fZmIoY2FudmFzX2ZiLmZiX2JhY2ssIHRlbXBfdW5kb19mYi5mYiwgY2FudmFzX2ZiLl90ZXh0dXJlc1swXS5yZXMpXG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHByZXZfaHN2X2R5bmFtaWNzWzBdID0gbmV3X2hzdl9keW5hbWljc1swXVxuXHRcdFx0XHRwcmV2X2hzdl9keW5hbWljc1sxXSA9IG5ld19oc3ZfZHluYW1pY3NbMV1cblx0XHRcdFx0cHJldl9oc3ZfZHluYW1pY3NbMl0gPSBuZXdfaHN2X2R5bmFtaWNzWzJdIFxuXHRcdFx0XHRwcmV2X25vaXNlX3N0cmV0Y2hbMF0gPSBuZXdfbm9pc2Vfc3RyZXRjaFswXVxuXHRcdFx0XHRwcmV2X25vaXNlX3N0cmV0Y2hbMV0gPSBuZXdfbm9pc2Vfc3RyZXRjaFsxXVxuXHRcdFx0XHRwcmV2X3RleF9zdHJldGNoWzBdID0gbmV3X3RleF9zdHJldGNoWzBdXG5cdFx0XHRcdHByZXZfdGV4X3N0cmV0Y2hbMV0gPSBuZXdfdGV4X3N0cmV0Y2hbMV1cblx0XHRcdFx0aysrXG5cdFx0XHRcdGorK1xuXHRcdFx0fVxuXHRcdFx0cmVkcmF3X25lZWRlZCA9IHRydWVcblx0XHRcdHRlbXBfc3Ryb2tlX2ZiLmNsZWFyKClcblxuXHRcdH1cblxuXHRcdGNvbnN0IHJlZHJhd193aG9sZV9wcm9qZWN0ID0gKCkgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coJ1JFRFJBVyBFVkVSWVRISU5HJylcblx0XHRcdGNvbnNvbGUudGltZShcIlJFRFJBVyBBTExcIilcblx0XHRcdGNhbnZhc19mYi5jbGVhcigpXG5cdFx0XHRjYW52YXNfZmIucG9uZygpXG5cdFx0XHRjYW52YXNfZmIuYmFja190ZXh0dXJlc1swXS5iaW5kX3RvX3VuaXQoMSlcblx0XHRcdGNhbnZhc19mYi5jbGVhcigpXG5cdFx0XHR0ZW1wX3N0cm9rZV9mYi5jbGVhcigpXG5cblxuXHRcdFx0ZHJhd19uX3N0cm9rZXMoMCwgcHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aCAtIHJlZG9faGlzdG9yeV9sZW5ndGgsIHRydWUpXG5cblx0XHRcdGNvbnNvbGUudGltZUVuZChcIlJFRFJBVyBBTExcIilcblx0XHR9XG5cdFx0cmVzaXplX3Byb2plY3QgPSAobmV3X3N6OiBudW1iZXJbXSk6IHZvaWQgPT4ge1xuXHRcdFx0cHJvamVjdC5jYW52YXNSZXMgPSBbLi4ubmV3X3N6XVxuXHRcdFx0dGVtcF9zdHJva2VfZmIudGV4dHVyZXNbMF0ucmVzaXplKG5ld19zeilcblx0XHRcdGNhbnZhc19mYi5iYWNrX3RleHR1cmVzWzBdLnJlc2l6ZShuZXdfc3opXG5cdFx0XHRjYW52YXNfZmIudGV4dHVyZXNbMF0ucmVzaXplKG5ld19zeilcblx0XHRcdGNhbnZhc19mYi5yZWNyZWF0ZSgpXG5cdFx0XHRjYW52YXNfZmIuYmFja190ZXh0dXJlc1swXS5iaW5kX3RvX3VuaXQoMSlcblx0XHRcdHRlbXBfc3Ryb2tlX2ZiLnJlY3JlYXRlKClcblx0XHRcdHRlbXBfc3Ryb2tlX2ZiLnRleHR1cmVzWzBdLmJpbmRfdG9fdW5pdCgwKVxuXHRcdFx0dGVtcF91bmRvX2ZiLnRleHR1cmVzWzBdLnJlc2l6ZShuZXdfc3opXG5cdFx0XHR0ZW1wX3VuZG9fZmIucmVjcmVhdGUoKVxuXHRcdFx0c2V0X3NoYXJlZF91bmlmb3JtcygpXG5cdFx0XHRmdWxsX3JlZHJhd19uZWVkZWQgPSB0cnVlXG5cdFx0XHRwcm9qZWN0X2hhc19iZWVuX21vZGlmaWVkID0gZmFsc2Vcblx0XHRcdHJlZG9faGlzdG9yeV9sZW5ndGggPSAwXG5cdFx0fVxuXHRcdFxuXHRcdGxldCBsb2FkX3Byb2plY3QgPSAobmV3X3Byb2plY3Q6IFByb2plY3QpID0+e1xuXHRcdFx0cHJvamVjdCA9IG5ldyBQcm9qZWN0KClcblx0XHRcdHByb2plY3RfaGFzX2JlZW5fbW9kaWZpZWQgPSBmYWxzZVxuXHRcdFx0cmVkb19oaXN0b3J5X2xlbmd0aCA9IDBcblx0XHRcdGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhuZXdfcHJvamVjdCBhcyBPYmplY3QpKSB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0cHJvamVjdFtrZXldID0gbmV3X3Byb2plY3Rba2V5XVxuXHRcdFx0fVxuXHRcdFx0cHJvamVjdC5jYW52YXNSZXMgPSBbLi4ubmV3X3Byb2plY3QuY2FudmFzUmVzXVxuXHRcdFx0cmVzaXplX3Byb2plY3QocHJvamVjdC5jYW52YXNSZXMpXG5cdFx0XHRyZWRyYXdfd2hvbGVfcHJvamVjdCgpXG5cdFx0fVxuXHRcdGxldCBsb2NhbF9zdG9yYWdlX3Byb2ogPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncHJvamVjdCcpXG5cblx0XHRpZiAobG9jYWxfc3RvcmFnZV9wcm9qKSB7XG5cdFx0XHRsb2NhbF9zdG9yYWdlX3Byb2ogPSBKU09OLnBhcnNlKGxvY2FsX3N0b3JhZ2VfcHJvailcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGxvYWRfcHJvamVjdChsb2NhbF9zdG9yYWdlX3Byb2opXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGxvYWRfcHJvamVjdChuZXcgUHJvamVjdCgpKVxuXHRcdFx0bG9hZF9wcm9qZWN0KG5ldyBQcm9qZWN0KCkpXG5cdFx0fVxuXHRcdFxuXHRcdGNvbnN0IGhhbmRsZV9pbnB1dF9hY3Rpb25zID0gKCk9Pntcblx0XHRcdGlmIChpby5nZXRLZXkoJ0FsdExlZnQnKS5kb3duKSB7XG5cdFx0XHRcdGlmIChpby5nZXRLZXkoJ0FsdExlZnQnKS5qdXN0X3ByZXNzZWQpIHtcblx0XHRcdFx0XHRwaWNraW5nID0gdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdHBpY2tfZnJvbV9jYW52YXMoKVxuXHRcdFx0fSBlbHNlIGlmIChpby5nZXRLZXkoJ0FsdExlZnQnKS5qdXN0X3VucHJlc3NlZCkge1xuXHRcdFx0XHRqdXN0X2ZpbmlzaGVkX3BpY2sgPSB0cnVlXG5cdFx0XHRcdHBpY2tpbmcgPSBmYWxzZVxuXHRcdFx0fVxuXG5cdFx0XHRpZihtb3VzZV9vdmVyX2NvbG91cl9waWNrZXIgfHwgbW91c2Vfb3Zlcl9jb2xvdXJfcGlja2VyX2ZpbmlzaGVkKXtcblx0XHRcdFx0cmVkcmF3X25lZWRlZCA9IHRydWVcblx0XHRcdH1cblxuXHRcdFx0aWYoaW8uanVzdF9maW5pc2hlZF9waW5jaCl7XG5cdFx0XHRcdHpvb21bMF0gPSBkZXNpcmVkX3pvb20gPSBwb3coMiwgbG9nMihkZXNpcmVkX3pvb20pICsgaW8ucGluY2hfem9vbSlcblx0XHRcdH1cblx0XHRcdGlmKGlvLnR3b19maW5nZXJfcGluY2gpe1xuXHRcdFx0XHRyZWRyYXdfbmVlZGVkID0gdHJ1ZVxuXHRcdFx0XHR6b29tWzBdID0gcG93KDIsbG9nMihkZXNpcmVkX3pvb20pICArIGlvLnBpbmNoX3pvb20pXG5cdFx0XHRcdGlmKGlvLmp1c3Rfc3RhcnRlZF9waW5jaCl7XG5cdFx0XHRcdFx0cGFubmluZ190ZW1wX3BpbmNoWzBdID0gcGFubmluZ1swXVxuXHRcdFx0XHRcdHBhbm5pbmdfdGVtcF9waW5jaFsxXSA9IHBhbm5pbmdbMV1cblx0XHRcdFx0fVxuXHRcdFx0XHRwYW5uaW5nWzBdID0gcGFubmluZ190ZW1wX3BpbmNoWzBdICsgaW8ucGluY2hfcG9zWzBdXG5cdFx0XHRcdHBhbm5pbmdbMV0gPSBwYW5uaW5nX3RlbXBfcGluY2hbMV0gLSBpby5waW5jaF9wb3NbMV1cblx0XHRcdH0gZWxzZSBpZihhYnMoZGVzaXJlZF96b29tIC0gem9vbVswXSkgPiAwLjAwMSApe1xuXHRcdFx0XHRyZWRyYXdfbmVlZGVkID0gdHJ1ZVxuXHRcdFx0XHR6b29tWzBdID0gbWl4KHpvb21bMF0sZGVzaXJlZF96b29tLGRlbHRhX3QqMjApXG5cdFx0XHR9XG5cdFx0XHRpZiAoZnJhbWUgPT09IDAgfHwgcGlja2luZyB8fCBqdXN0X2ZpbmlzaGVkX3BpY2sgfHwgaW8ubW91c2Vfd2hlZWwgfHwgaW8ubW1iX2Rvd24pIHtcblx0XHRcdFx0cmVkcmF3X25lZWRlZCA9IHRydWVcblx0XHRcdFx0aWYgKGp1c3RfZmluaXNoZWRfcGljaykge1xuXHRcdFx0XHRcdGxldCBjb29yZHMgPSBVdGlscy5zY3JlZW5fTkRDX3RvX2NhbnZhc19OREMoXG5cdFx0XHRcdFx0XHRbLi4uaW8ubW91c2VfcG9zXSxcblx0XHRcdFx0XHRcdGRlZmF1bHRfZnJhbWVidWZmZXIudGV4dHVyZXNbMF0sXG5cdFx0XHRcdFx0XHRjYW52YXNfZmIuX3RleHR1cmVzWzBdLFxuXHRcdFx0XHRcdFx0em9vbVswXSxcblx0XHRcdFx0XHRcdHBhbm5pbmcsXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdGlmIChjb29yZHNbMF0gPiAtMSAmJiBjb29yZHNbMF0gPCAxICYmIGNvb3Jkc1sxXSA+IC0xICYmIGNvb3Jkc1sxXSA8IDEpIHtcblx0XHRcdFx0XHRcdC8vIHN0cm9rZV9jb2wgPSBbLi4ucGlja2VkX2NvbF1cblx0XHRcdFx0XHRcdHN0cm9rZV9jb2xbMF0gPSBwaWNrZWRfY29sWzBdXG5cdFx0XHRcdFx0XHRzdHJva2VfY29sWzFdID0gcGlja2VkX2NvbFsxXVxuXHRcdFx0XHRcdFx0c3Ryb2tlX2NvbFsyXSA9IHBpY2tlZF9jb2xbMl1cblx0XHRcdFx0XHRcdFV0aWxzLmdhbW1hX2NvcnJlY3Qoc3Ryb2tlX2NvbCwgdHJ1ZSwgdHJ1ZSlcblx0XHRcdFx0XHRcdHN0cm9rZV9jb2xbM10gPSAxXG5cdFx0XHRcdFx0XHQvLyBzdHJva2VfY29sID0gWy4uLnN0cm9rZV9jb2xdXG5cdFx0XHRcdFx0XHR0cmlnZ2VyX2NvbG91cl9kaXNwbGF5X3VwZGF0ZShzdHJva2VfY29sWzBdLCBzdHJva2VfY29sWzFdLCBzdHJva2VfY29sWzJdKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zb2xlLmxvZyhjb29yZHMpXG5cdFx0XHRcdFx0anVzdF9maW5pc2hlZF9waWNrID0gZmFsc2Vcblx0XHRcdFx0XHRwaWNraW5nID0gZmFsc2Vcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImZpbmlzaGVkIHBpY2tcIilcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW8ubW1iX2Rvd24pIHtcblx0XHRcdFx0XHRwYW5uaW5nWzBdICs9IGlvLmRlbHRhX21vdXNlX3Bvc1swXSAvIHpvb21bMF1cblx0XHRcdFx0XHRwYW5uaW5nWzFdICs9IGlvLmRlbHRhX21vdXNlX3Bvc1sxXSAvIHpvb21bMF1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW8ubW91c2Vfd2hlZWwpIHtcblx0XHRcdFx0XHRpZiAoaW8ubW91c2Vfd2hlZWwgPiAwKSB7XG5cdFx0XHRcdFx0XHRkZXNpcmVkX3pvb20gKj0gMS4yXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRlc2lyZWRfem9vbSAvPSAxLjJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gLS0tLS0gVU5ET19SRURPXG5cdFx0XHRsZXQgbF9jdHJsX2Rvd24gPSBpby5nZXRLZXkoJ0NvbnRyb2xMZWZ0JykuZG93blxuXHRcdFx0bGV0IGxfc2hpZnRfZG93biA9IGlvLmdldEtleSgnU2hpZnRMZWZ0JykuZG93blxuXHRcdFx0bGV0IHpfanVzdF9wcmVzc2VkID0gaW8uZ2V0S2V5KCdLZXlaJykuanVzdF9wcmVzc2VkXG5cdFx0XHRjb25zdCBpZHhfYmVmb3JlID0gcHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aCAtIHJlZG9faGlzdG9yeV9sZW5ndGhcblx0XHRcdGlmIChyZWRvX3BlbmRpbmcgfHwgKGxfc2hpZnRfZG93biAmJiBsX2N0cmxfZG93biAmJiB6X2p1c3RfcHJlc3NlZCkpIHtcblx0XHRcdFx0cmVkb19oaXN0b3J5X2xlbmd0aCAtPSAxXG5cdFx0XHRcdGNvbnN0IGlkeF9ub3cgPSBpZHhfYmVmb3JlICsgMVxuXHRcdFx0XHRpZiAocmVkb19oaXN0b3J5X2xlbmd0aCA+PSAwKSB7IFxuXHRcdFx0XHRcdGlmKGlkeF9ub3cgJSB1bmRvX2NhY2hlX3N0ZXBzID09PSAwKXtcblx0XHRcdFx0XHRcdHRlbXBfc3Ryb2tlX2ZiLmNsZWFyKClcblx0XHRcdFx0XHRcdGRyYXdfbl9zdHJva2VzKGlkeF9iZWZvcmUsIGlkeF9iZWZvcmUgKyAxKVxuXHRcdFx0XHRcdFx0Y29weV9mYl90b19mYihjYW52YXNfZmIuZmJfYmFjayx0ZW1wX3VuZG9fZmIuZmIsIGNhbnZhc19mYi50ZXh0dXJlc1swXS5yZXMpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRlbXBfc3Ryb2tlX2ZiLmNsZWFyKClcblx0XHRcdFx0XHRcdGRyYXdfbl9zdHJva2VzKGlkeF9iZWZvcmUsIGlkeF9iZWZvcmUgKyAxKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHsgXG5cdFx0XHRcdFx0Ly8gY2xhbXBcblx0XHRcdFx0XHRyZWRvX2hpc3RvcnlfbGVuZ3RoID0gMCBcblx0XHRcdFx0XHRmbG9hdGluZ19tb2RhbF9tZXNzYWdlLnNldChcIkxhc3QgcmVkb1wiKVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHVuZG9fcGVuZGluZyB8fCAobF9jdHJsX2Rvd24gJiYgel9qdXN0X3ByZXNzZWQpKSB7XG5cdFx0XHRcdHJlZG9faGlzdG9yeV9sZW5ndGggKz0gMVxuXHRcdFx0XHRjb25zdCBpZHhfbm93ID0gaWR4X2JlZm9yZSAtIDFcblx0XHRcdFx0aWYgKHJlZG9faGlzdG9yeV9sZW5ndGggPD0gcHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aCkgeyBcblx0XHRcdFx0XHRpZihpZHhfYmVmb3JlICUgdW5kb19jYWNoZV9zdGVwcyA9PT0gMCl7XG5cdFx0XHRcdFx0XHQvLyByZWRyYXcgYWxsXG5cdFx0XHRcdFx0XHRjYW52YXNfZmIuY2xlYXIoKVxuXHRcdFx0XHRcdFx0Y2FudmFzX2ZiLnBvbmcoKVxuXHRcdFx0XHRcdFx0Y2FudmFzX2ZiLmJhY2tfdGV4dHVyZXNbMF0uYmluZF90b191bml0KDEpXG5cdFx0XHRcdFx0XHRjYW52YXNfZmIuY2xlYXIoKVxuXHRcdFx0XHRcdFx0dGVtcF9zdHJva2VfZmIuY2xlYXIoKVxuXHRcdFx0XHRcdFx0ZHJhd19uX3N0cm9rZXMoMCwgaWR4X2JlZm9yZSAtIHVuZG9fY2FjaGVfc3RlcHMpXG5cdFx0XHRcdFx0XHRjb3B5X2ZiX3RvX2ZiKGNhbnZhc19mYi5mYl9iYWNrLHRlbXBfdW5kb19mYi5mYiwgY2FudmFzX2ZiLnRleHR1cmVzWzBdLnJlcylcblx0XHRcdFx0XHRcdHRlbXBfc3Ryb2tlX2ZiLmNsZWFyKClcblx0XHRcdFx0XHRcdGRyYXdfbl9zdHJva2VzKCBpZHhfYmVmb3JlIC0gdW5kb19jYWNoZV9zdGVwcywgcHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aCAtIHJlZG9faGlzdG9yeV9sZW5ndGgpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvcHlfZmJfdG9fZmIodGVtcF91bmRvX2ZiLmZiLGNhbnZhc19mYi5mYl9iYWNrLCBjYW52YXNfZmIudGV4dHVyZXNbMF0ucmVzKVxuXHRcdFx0XHRcdFx0Y2FudmFzX2ZiLmJhY2tfdGV4dHVyZXNbMF0uYmluZF90b191bml0KDEpXG5cdFx0XHRcdFx0XHR0ZW1wX3N0cm9rZV9mYi5jbGVhcigpXG5cdFx0XHRcdFx0XHRjb25zdCB1bmRvX21vZF9vZmZzID0gaWR4X25vdyAlIHVuZG9fY2FjaGVfc3RlcHNcblx0XHRcdFx0XHRcdGRyYXdfbl9zdHJva2VzKCBpZHhfbm93IC0gdW5kb19tb2Rfb2ZmcywgcHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aCAtIHJlZG9faGlzdG9yeV9sZW5ndGgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTE1KVxuXHRcdFx0XHR9IGVsc2UgeyBcblx0XHRcdFx0XHQvLyBjbGFtcFxuXHRcdFx0XHRcdHJlZG9faGlzdG9yeV9sZW5ndGggLT0gMSBcblx0XHRcdFx0XHRmbG9hdGluZ19tb2RhbF9tZXNzYWdlLnNldChcIkxhc3QgdW5kb1wiKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGNvbnN0IHJlY29yZF9zdHJva2UgPSAoKT0+e1xuXHRcdFx0XHRpZiAoaW8ubW91c2VfanVzdF9wcmVzc2VkICYmICEocmVkb19wZW5kaW5nIHx8IHVuZG9fcGVuZGluZykpIHtcblx0XHRcdFx0XHRicnVzaF9zdHJva2UgPSBuZXcgQnJ1c2hTdHJva2UoY3Vycl9icnVzaC5zZWxlY3RlZF9icnVzaF90eXBlLCBuZXcgRHJhd1BhcmFtcyhcblx0XHRcdFx0XHRcdGN1cnJfYnJ1c2gudGV4X2R5bmFtaWNzLCBjdXJyX2JydXNoLnRleF9sY2hfZHluYW1pY3MsIGN1cnJfYnJ1c2gubm9pc2Vfc3RyZXRjaCxcblx0XHRcdFx0XHRcdC8vIGN1cnJfYnJ1c2gudGV4X3N0cmV0Y2gsXG5cdFx0XHRcdFx0XHRbY3Vycl9icnVzaC50ZXhfc3RyZXRjaFswXSoyMC4sIGN1cnJfYnJ1c2gudGV4X3N0cmV0Y2hbMV0qMi4qMjAuXSxcblx0XHRcdFx0XHRcdGJsZW5kaW5nX2NvbG91cl9zcGFjZVxuXHRcdFx0XHRcdFx0KSwgY3Vycl9icnVzaC5zZWxlY3RlZF9icnVzaF90ZXh0dXJlKVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmVkb19oaXN0b3J5X2xlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRwcm9qZWN0LmJydXNoX3N0cm9rZXMucG9wKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVkb19oaXN0b3J5X2xlbmd0aCA9IDBcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJydXNoX3JvdCA9IFsuLi5pby50aWx0XVxuXG5cdFx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBpby5tb3VzZV9wb3NpdGlvbnNfZHVyaW5nX2xhc3RfZnJhbWVfY250OyBpKyspe1xuXHRcdFx0XHRcdC8vIGJydXNoX3Bvc19uZGNfc2NyZWVuID0gWy4uLmlvLm1vdXNlX3Bvc11cblx0XHRcdFx0XHRicnVzaF9wb3NfbmRjX3NjcmVlbiA9IFtcblx0XHRcdFx0XHRcdGlvLm1vdXNlX3Bvc2l0aW9uc19kdXJpbmdfbGFzdF9mcmFtZVtpKjJdLFxuXHRcdFx0XHRcdFx0aW8ubW91c2VfcG9zaXRpb25zX2R1cmluZ19sYXN0X2ZyYW1lW2kqMiArIDFdXG5cdFx0XHRcdFx0XVxuXHRcdFx0XHRcdGJydXNoX3Bvc19uZGNfY2FudmFzID0gVXRpbHMuc2NyZWVuX05EQ190b19jYW52YXNfTkRDKFxuXHRcdFx0XHRcdFx0YnJ1c2hfcG9zX25kY19zY3JlZW4sXG5cdFx0XHRcdFx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLnRleHR1cmVzWzBdLFxuXHRcdFx0XHRcdFx0Y2FudmFzX3JlYWRfdGV4LFxuXHRcdFx0XHRcdFx0em9vbVswXSxcblx0XHRcdFx0XHRcdHBhbm5pbmcsXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdGlmKGN1cnJfYnJ1c2gucG9zX2ppdHRlciA+IDAuMDEpe1xuXHRcdFx0XHRcdFx0YnJ1c2hfcG9zX25kY19jYW52YXNbMF0gKz0gY3Vycl9icnVzaC5wb3Nfaml0dGVyICogKDIgKiBoYXNoLnZhbHVlTm9pc2VTbW9vdGgodCAqIDEwMCArIDI1MSwgMikgLSAxKVxuXHRcdFx0XHRcdFx0YnJ1c2hfcG9zX25kY19jYW52YXNbMV0gKz0gY3Vycl9icnVzaC5wb3Nfaml0dGVyICogKDIgKiBoYXNoLnZhbHVlTm9pc2VTbW9vdGgodCAqIDEwMCArIDEyNTEsIDIpIC0gMSlcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgY29sID0gWy4uLnN0cm9rZV9jb2xdXG5cblx0XHRcdFx0XHRpZihjdXJyX2JydXNoLmNoYW9zID4gMC4wMSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgY2hyb21hX2dsID0gKGNvbDogbnVtYmVyW10pID0+IHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNocm9tYS5nbChjb2xbMF0sIGNvbFsxXSwgY29sWzJdKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29uc3QgY2hyb21hX29rbGNoID0gKGNvbDogbnVtYmVyW10pID0+IHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNocm9tYS5va2xjaChjb2xbMF0sIGNvbFsxXSwgY29sWzJdKVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbCA9IGNocm9tYV9nbChjb2wpLm9rbGNoKClcblx0XHRcdFx0XHRcdGNvbnN0IGMgPSBjb2xbMV1cblxuXHRcdFx0XHRcdFx0bGV0IGh1ZV9qaXR0X2FtdCA9ICgxLXBvdyhjICwwLjIpKjEuMikqNFxuXHRcdFx0XHRcdFx0aHVlX2ppdHRfYW10ID0gbWF4KGh1ZV9qaXR0X2FtdCwwKVxuXHRcdFx0XHRcdFx0aHVlX2ppdHRfYW10ICs9IHBvdyhzbW9vdGhzdGVwKDAuLDEuLDEtYykgLDU3LikqMi4yXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y29sWzBdICs9ICgtMC41ICsgaGFzaC52YWx1ZU5vaXNlU21vb3RoKHQgKiAxMDAgKiBjdXJyX2JydXNoLmNoYW9zX3NwZWVkLCAyKSkgKiBjdXJyX2JydXNoLmNoYW9zICogY3Vycl9icnVzaC5jaGFvc19sY2hbMF1cblx0XHRcdFx0XHRcdGNvbFsxXSArPSAoLTAuNSArIGhhc2gudmFsdWVOb2lzZVNtb290aCh0ICogMTAwICogY3Vycl9icnVzaC5jaGFvc19zcGVlZCArIDEwMCwgMikpICogY3Vycl9icnVzaC5jaGFvcyAqIGN1cnJfYnJ1c2guY2hhb3NfbGNoWzFdIFxuXHRcdFx0XHRcdFx0Y29sWzJdICs9IGh1ZV9qaXR0X2FtdCooLTAuNSArIGhhc2gudmFsdWVOb2lzZVNtb290aCh0ICogMTAwICogY3Vycl9icnVzaC5jaGFvc19zcGVlZCArIDIwMCwgMikpICogMzAwICogY3Vycl9icnVzaC5jaGFvcyAqIGN1cnJfYnJ1c2guY2hhb3NfbGNoWzJdXG5cdFx0XHRcdFx0XHRjb2xbMF0gPSBjbGFtcChjb2xbMF0sIDAsIDEpXG5cdFx0XHRcdFx0XHRjb2xbMV0gPSBjbGFtcChjb2xbMV0sIDAsIDEpXG5cdFx0XHRcdFx0XHRjb2xbMl0gPSBtb2QoY29sWzJdLCAzNjApXG5cblx0XHRcdFx0XHRcdGNvbCA9IGNocm9tYV9va2xjaChjb2wpLmdsKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0c3Ryb2tlX29wYWNpdHkgPSBsZXJwKGN1cnJfYnJ1c2guc3Ryb2tlX29wYWNpdHlfZHluYW1pY3NbMF0sIGN1cnJfYnJ1c2guc3Ryb2tlX29wYWNpdHlfZHluYW1pY3NbMV0sIGlvLnByZXNzdXJlKVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKGN1cnJfYnJ1c2gucm90X2ppdHRlciA+IDAuMDEpIHtcblx0XHRcdFx0XHRcdGJydXNoX3JvdFsxXSArPSAxMCpjdXJyX2JydXNoLnJvdF9qaXR0ZXIgKiAoMiAqIGhhc2gudmFsdWVOb2lzZVNtb290aCh0ICogMTAgKyAxMDAsIDIpIC0gMSlcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgc3ogPSBbLi4uYnJ1c2hfc3pdXG5cblx0XHRcdFx0XHRsZXQgc2l6ZV9wcmVzc3VyZV93ZWlnaHQgPSBsZXJwKGN1cnJfYnJ1c2guc3Ryb2tlX3NpemVfZHluYW1pY3NbMF0sY3Vycl9icnVzaC4gc3Ryb2tlX3NpemVfZHluYW1pY3NbMV0sIGlvLnByZXNzdXJlKVxuXHRcdFx0XHRcdGxldCBzaXplX3RpbHRfd2VpZ2h0ID0gbGVycCgwLjQsIDEsIGlvLnRpbHRbMF0gLyB0YXUpXG5cdFx0XHRcdFx0Ly8gVE9ETzogc3ogZHluYW1pY3Ncblx0XHRcdFx0XHRzelswXSAqPSBzaXplX3ByZXNzdXJlX3dlaWdodCAqIHNpemVfdGlsdF93ZWlnaHRcblx0XHRcdFx0XHRzelsxXSAqPSBzaXplX3ByZXNzdXJlX3dlaWdodCAqIHNpemVfdGlsdF93ZWlnaHRcblxuXHRcdFx0XHRcdGJydXNoX3N0cm9rZS5wdXNoX3N0cm9rZShicnVzaF9wb3NfbmRjX2NhbnZhcywgYnJ1c2hfcm90LCBzeiwgc3Ryb2tlX29wYWNpdHksIGNvbClcblx0XHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGRyYXcgPSAoX3Q6IG51bWJlcikgPT4ge1xuXHRcdFx0cmVkcmF3X25lZWRlZCA9IGZhbHNlXG5cdFx0XHRjb25zdCBuZXdfdCA9IF90IC8gMTAwMFxuXHRcdFx0ZGVsdGFfdCA9IG5ld190IC0gdFxuXHRcdFx0dCA9IG5ld190XG5cdFx0XHRyZXNpemVEZWZhdWx0RnJhbWVidWZmZXJJZk5lZWRlZChcblx0XHRcdFx0Y2FudmFzRWxlbWVudCwgXG5cdFx0XHRcdGRlZmF1bHRfZnJhbWVidWZmZXIsIFxuXHRcdFx0XHRkZWZhdWx0X2ZyYW1lYnVmZmVyLl90ZXh0dXJlc1swXS5yZXMsIFxuXHRcdFx0XHQodjogYm9vbGVhbikgPT4ge1xuXHRcdFx0XHRyZWRyYXdfbmVlZGVkID0gdlxuXHRcdFx0fSwoKT0+e3NldF9zaGFyZWRfdW5pZm9ybXMoKX0pXG5cdFx0XHRpby50aWNrKClcblx0XHRcdFxuXHRcdFx0aWYobmV3X3Byb2plY3RfcGVuZGluZyl7XG5cdFx0XHRcdGxvYWRfcHJvamVjdChuZXcgUHJvamVjdCgpKVxuXHRcdFx0XHRuZXdfcHJvamVjdF9wZW5kaW5nID0gZmFsc2Vcblx0XHRcdH1cblx0XHRcdGlmKHByb2plY3RfcGVuZGluZ19sb2FkKXtcblx0XHRcdFx0bG9hZF9wcm9qZWN0KHByb2plY3RfcGVuZGluZ19sb2FkKVxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdHByb2plY3RfcGVuZGluZ19sb2FkID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmKGZ1bGxfcmVkcmF3X25lZWRlZCl7XG5cdFx0XHRcdHJlZHJhd193aG9sZV9wcm9qZWN0KClcblx0XHRcdH1cblxuXHRcdFx0aGFuZGxlX2lucHV0X2FjdGlvbnMoKVxuXG5cdFx0XHQvLyAtLS0tLSBSRUNPUkQgU1RST0tFIC8gRFJBV1xuXHRcdFx0aWYgKChpby5tb3VzZV9qdXN0X3ByZXNzZWQgfHwgKGlvLm1vdXNlX2Rvd24gJiYgaW8ubW91c2VfanVzdF9tb3ZlZCkpICYmIGlvLnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG5cdFx0XHRcdHByb2plY3RfaGFzX2JlZW5fbW9kaWZpZWQgPSB0cnVlXG5cdFx0XHRcdHJlZHJhd19uZWVkZWQgPSB0cnVlXG5cdFx0XHRcdHJlY29yZF9zdHJva2UoKVxuXHRcdFx0XHR0ZW1wX3N0cm9rZV9mYi5jbGVhcigpXG5cdFx0XHRcdHRlbXBfc3Ryb2tlX2ZiLmJpbmQoKVxuXHRcdFx0XHRkcmF3ZXIuYnJ1c2hfYnVmZmVyID0gYnJ1c2hfYnVmZmVyXG5cdFx0XHRcdGRyYXdlci5yZXNldCgpXG5cdFx0XHRcdGRyYXdlci5wdXNoX2FueV9zdHJva2UoYnJ1c2hfc3Ryb2tlKVxuXHRcdFx0XHRkcmF3ZXIuYnJ1c2hfYnVmZmVyLnVwbG9hZF9hbGxfYnVmZnMoKVxuXHRcdFx0XHRjb25zdCBicnVzaF9zaGFkZXIgPSBkcmF3ZXIuYnJ1c2hfYnVmZmVyLnNoYWRlclxuXHRcdFx0XHRicnVzaF9zaGFkZXIudXNlKClcblxuXHRcdFx0XHRicnVzaF9wYXJhbXNfbWF0WzBdID0gY3Vycl9icnVzaC5zZWxlY3RlZF9icnVzaF90ZXh0dXJlLmlkeFxuXHRcdFx0XHRicnVzaF9wYXJhbXNfbWF0WzFdID0gYnJ1c2hfc3Ryb2tlLmRyYXdfcGFyYW1zLnRleF9sY2hfZHluYW1pY3NbMF1cblx0XHRcdFx0YnJ1c2hfcGFyYW1zX21hdFsyXSA9IGJydXNoX3N0cm9rZS5kcmF3X3BhcmFtcy50ZXhfbGNoX2R5bmFtaWNzWzFdXG5cdFx0XHRcdGJydXNoX3BhcmFtc19tYXRbM10gPSBicnVzaF9zdHJva2UuZHJhd19wYXJhbXMudGV4X2xjaF9keW5hbWljc1syXVxuXHRcdFx0XHRicnVzaF9wYXJhbXNfbWF0WzRdID0gYnJ1c2hfc3Ryb2tlLmRyYXdfcGFyYW1zLm5vaXNlX3N0cmV0Y2hbMF1cblx0XHRcdFx0YnJ1c2hfcGFyYW1zX21hdFs1XSA9IGJydXNoX3N0cm9rZS5kcmF3X3BhcmFtcy5ub2lzZV9zdHJldGNoWzFdXG5cdFx0XHRcdGJydXNoX3BhcmFtc19tYXRbNl0gPSBicnVzaF9zdHJva2UuZHJhd19wYXJhbXMudGV4X3N0cmV0Y2hbMF1cblx0XHRcdFx0YnJ1c2hfcGFyYW1zX21hdFs3XSA9IGJydXNoX3N0cm9rZS5kcmF3X3BhcmFtcy50ZXhfc3RyZXRjaFsxXSBcblxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoYnJ1c2hfc2hhZGVyLmJydXNoX3BhcmFtc19sb2MsIGZhbHNlLCBicnVzaF9wYXJhbXNfbWF0KVxuXG5cdFx0XHRcdGRyYXdlci5kcmF3X3N0cm9rZV9pZHgoMClcblx0XHRcdH1cblx0XHRcdC8vIC0tLS0tIENPTVBPU0lURSBORVcgU1RST0tFXG5cdFx0XHRpZiAoaW8ubW91c2VfanVzdF91bnByZXNzZWQgJiYgaW8ucG9pbnRlclR5cGUgIT09ICd0b3VjaCcgJiYgISh1bmRvX3BlbmRpbmcgfHwgcmVkb19wZW5kaW5nKSkge1xuXHRcdFx0XHRpZihmcmFtZSAlIDE1ID09PSAwIHx8ICFpc09uTW9iaWxlKXtcblx0XHRcdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncHJvamVjdCcsIEpTT04uc3RyaW5naWZ5KHByb2plY3QpKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHByb2plY3QucHVzaF9zdHJva2UoYnJ1c2hfc3Ryb2tlKVxuXHRcdFx0XHRyZWRyYXdfbmVlZGVkID0gdHJ1ZVxuXHRcdFx0XHRjb21wb3NpdGVfc3Ryb2tlKClcblx0XHRcdFx0Y2FudmFzX2ZiLnBvbmcoKVxuXHRcdFx0XHRjYW52YXNfZmIuYmFja190ZXh0dXJlc1swXS5iaW5kX3RvX3VuaXQoMSlcblx0XHRcdFx0aWYocHJvamVjdC5icnVzaF9zdHJva2VzLmxlbmd0aCAlIHVuZG9fY2FjaGVfc3RlcHMgPT09IDApe1xuXHRcdFx0XHRcdGNvcHlfZmJfdG9fZmIoY2FudmFzX2ZiLmZiX2JhY2ssIHRlbXBfdW5kb19mYi5mYiwgY2FudmFzX2ZiLnRleHR1cmVzWzBdLnJlcylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYnJ1c2hfc2l6ZV93aWRnZXRfZHJhZ2dpbmcgfHwgYnJ1c2hfc2l6ZV93aWRnZXRfc3RvcHBlZF9kcmFnZ2luZykgcmVkcmF3X25lZWRlZCA9IHRydWVcblxuXHRcdFx0Ly8gLS0tLS0gUkVEUkFXXG5cdFx0XHRpZiAocmVkcmF3X25lZWRlZCkge1xuXHRcdFx0XHRpZihjYW52YXNfZmIuX3RleHR1cmVzWzBdLm1pcG1hcHBlZCl7XG5cdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgY2FudmFzX2ZiLl90ZXh0dXJlc1swXS50ZXgpXG5cdFx0XHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRClcblx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBjYW52YXNfZmIuX2JhY2tfdGV4dHVyZXNbMF0udGV4KVxuXHRcdFx0XHRcdGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpXG5cdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbClcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0ZW1wX3N0cm9rZV9mYi50ZXh0dXJlc1swXS5taXBtYXBwZWQpe1xuXHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRlbXBfc3Ryb2tlX2ZiLnRleHR1cmVzWzBdLnRleClcblx0XHRcdFx0XHRnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKVxuXHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBnbC5jbGVhckNvbG9yKDAsMCwwLDEpXG5cdFx0XHRcdGdsLnZpZXdwb3J0KDAsIDAsIGRlZmF1bHRfZnJhbWVidWZmZXIuX3RleHR1cmVzWzBdLnJlc1swXSwgZGVmYXVsdF9mcmFtZWJ1ZmZlci5fdGV4dHVyZXNbMF0ucmVzWzFdKVxuXHRcdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGRlZmF1bHRfZnJhbWVidWZmZXIuZmIpXG5cdFx0XHRcdGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXG5cblx0XHRcdFx0RnJhbWVidWZmZXIuY3VycmVudGx5X2JvdW5kID0gZGVmYXVsdF9mcmFtZWJ1ZmZlclxuXG5cdFx0XHRcdHBvc3RfY2FudmFzX3Byb2dyYW0udXNlKClcblxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdGdsLnVuaWZvcm0xZihwb3N0X2NhbnZhc19wcm9ncmFtLnpvb21fbG9jLCB6b29tKVxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdGdsLnVuaWZvcm0yZnYocG9zdF9jYW52YXNfcHJvZ3JhbS5wYW5uaW5nX2xvYywgcGFubmluZylcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRnbC51bmlmb3JtMWkocG9zdF9jYW52YXNfcHJvZ3JhbS5ibGVuZGluZ19jb2xvdXJfc3BhY2VfbG9jLCBibGVuZGluZ19jb2xvdXJfc3BhY2UpXG5cdFx0XHRcdGNhbnZhc19mYi5iYWNrX3RleHR1cmVzWzBdLmJpbmRfdG9fdW5pdCgxKVxuXHRcdFx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KVxuXHRcdFx0XHRcblx0XHRcdFx0aWYobW91c2Vfb3Zlcl9jb2xvdXJfcGlja2VyICYmICFicnVzaF9zaXplX3dpZGdldF9kcmFnZ2luZyl7XG5cdFx0XHRcdFx0Y29sb3VyX3ByZXZpZXdfcHJvZ3JhbS51c2UoKVxuXHRcdFx0XHRcdGNvbG91cl9wcmV2aWV3X3Byb2dyYW0uc2V0VW5pZm9ybVZlYyhcImJydXNoX3N6XCIsIGJydXNoX3N6KVxuXHRcdFx0XHRcdGNvbG91cl9wcmV2aWV3X3Byb2dyYW0uc2V0VW5pZm9ybVZlYyhcImNvbG91clwiLCBzdHJva2VfY29sKVxuXHRcdFx0XHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYnJ1c2hfc2l6ZV93aWRnZXRfZHJhZ2dpbmcpIHtcblx0XHRcdFx0XHRicnVzaF9wcmV2aWV3X3Byb2dyYW0udXNlKClcblx0XHRcdFx0XHRicnVzaF9wcmV2aWV3X3Byb2dyYW0uc2V0VW5pZm9ybUZsb2F0KFwiem9vbVwiLCB6b29tWzBdKVxuXHRcdFx0XHRcdGJydXNoX3ByZXZpZXdfcHJvZ3JhbS5zZXRVbmlmb3JtVmVjKFwiYnJ1c2hfc3pcIiwgYnJ1c2hfc3opXG5cdFx0XHRcdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNClcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwaWNraW5nKSB7XG5cdFx0XHRcdFx0cGlja2VyX3Byb2dyYW0udXNlKClcblx0XHRcdFx0XHRwaWNrZXJfcHJvZ3JhbS5zZXRVbmlmb3JtVmVjKCdwaWNrZWRfY29sJywgcGlja2VkX2NvbClcblx0XHRcdFx0XHRwaWNrZXJfcHJvZ3JhbS5zZXRVbmlmb3JtVmVjKCdwaWNrZXJfcG9zJywgWy4uLmlvLm1vdXNlX3Bvc10pXG5cdFx0XHRcdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJpbnRfb25fZ2xfZXJyb3IoKVxuXHRcdFx0YnJ1c2hfc2l6ZV93aWRnZXRfc3RvcHBlZF9kcmFnZ2luZyA9IGZhbHNlXG5cdFx0XHRyZWRvX3BlbmRpbmcgPSBmYWxzZVxuXHRcdFx0dW5kb19wZW5kaW5nID0gZmFsc2Vcblx0XHRcdGZ1bGxfcmVkcmF3X25lZWRlZCA9IGZhbHNlXG5cdFx0XHRtb3VzZV9vdmVyX2NvbG91cl9waWNrZXJfZmluaXNoZWQgPSBmYWxzZVxuXHRcdFx0aW8udGlja19lbmQoKVxuXHRcdFx0ZnJhbWUrK1xuXHRcdFx0Zm9yIChsZXQgZnJhbWVidWZmZXIgb2YgRnJhbWVidWZmZXIuZnJhbWVidWZmZXJzKSB7XG5cdFx0XHRcdGlmIChmcmFtZWJ1ZmZlci5uZWVkc19wb25nKSB7XG5cdFx0XHRcdFx0ZnJhbWVidWZmZXIucG9uZygpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KVxuXHRcdH1cblx0XHQ7KCgpID0+IHtcblx0XHRcdGRyYXcoMClcblx0XHR9KSgpXG5cdH0pXG5cblx0b25EZXN0cm95KCgpID0+IHt9KVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuXHQua25vYi1jb250YWluZXIge1xuXHRcdHBhZGRpbmc6IDFyZW0gMHJlbTtcblx0fVxuXHQ6Z2xvYmFsKCopIHtcblx0XHRjb2xvcjogd2hpdGU7XG5cdFx0Zm9udC1mYW1pbHk6ICdKZXRCcmFpbnMgTW9ubyc7XG5cdFx0Zm9udC13ZWlnaHQ6IDkwMDtcblx0fVxuXHRtYWluIHtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdCNiYXItY29udGFpbmVyIHtcblx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHQjYmFyIHtcblx0XHRcdFx0ei1pbmRleDogMDtcblx0XHRcdFx0PjpnbG9iYWwoZGl2KSB7XG5cdFx0XHRcdFx0bWF4LWhlaWdodDogNHJlbTtcblx0XHRcdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHRcdFx0Jjpub3QoOmZpcnN0LW9mLXR5cGUpe1xuXHRcdFx0XHRcdFx0bWFyZ2luLWxlZnQ6IDAuMjVyZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1hcmdpbi1yaWdodDogMC4yNXJlbTtcblx0XHRcdFx0XHR6LWluZGV4OiAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZsZXgtd3JhcDogd3JhcDtcblx0XHRcdFx0YmFja2dyb3VuZDogYmxhY2s7XG5cdFx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0XHQ+ICo6bGFzdC1vZi10eXBlIHtcblx0XHRcdFx0XHRtYXJnaW4tbGVmdDogYXV0bztcblx0XHRcdFx0XHRtYXJnaW4tcmlnaHQ6IDBweDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjYW52YXMge1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRcdG1hcmdpbjogYXV0bztcblx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuIiwiaW1wb3J0ICcuLi9wdWJsaWMvSmV0QnJhaW5zTW9uby1SZWd1bGFyLnR0ZidcbmltcG9ydCAnLi4vcHVibGljL3N0eWxlLmNzcydcblxuaW1wb3J0IEFwcCBmcm9tICcuL2NvbXBvbmVudHMvQXBwLnN2ZWx0ZSdcblxuY29uc3QgYXBwID0gbmV3IEFwcCh7XG5cdHRhcmdldDogZG9jdW1lbnQuYm9keSxcblx0cHJvcHM6IHt9LFxufSlcblxuZXhwb3J0IGRlZmF1bHQgYXBwXG4iXSwibmFtZXMiOlsic3RyaW5nVG9CeXRlQXJyYXkiLCJhcHBOYW1lIiwiYXBwQ29tcGF0TmFtZSIsImFuYWx5dGljc05hbWUiLCJhbmFseXRpY3NDb21wYXROYW1lIiwiYXBwQ2hlY2tOYW1lIiwiYXBwQ2hlY2tDb21wYXROYW1lIiwiYXV0aE5hbWUiLCJhdXRoQ29tcGF0TmFtZSIsImRhdGFiYXNlTmFtZSIsImRhdGFiYXNlQ29tcGF0TmFtZSIsImZ1bmN0aW9uc05hbWUiLCJmdW5jdGlvbnNDb21wYXROYW1lIiwiaW5zdGFsbGF0aW9uc05hbWUiLCJpbnN0YWxsYXRpb25zQ29tcGF0TmFtZSIsIm1lc3NhZ2luZ05hbWUiLCJtZXNzYWdpbmdDb21wYXROYW1lIiwicGVyZm9ybWFuY2VOYW1lIiwicGVyZm9ybWFuY2VDb21wYXROYW1lIiwicmVtb3RlQ29uZmlnTmFtZSIsInJlbW90ZUNvbmZpZ0NvbXBhdE5hbWUiLCJzdG9yYWdlTmFtZSIsInN0b3JhZ2VDb21wYXROYW1lIiwiZmlyZXN0b3JlTmFtZSIsImZpcmVzdG9yZUNvbXBhdE5hbWUiLCJwYWNrYWdlTmFtZSIsInNldExvZ0xldmVsSW1wbCIsIm5hbWUiLCJ2ZXJzaW9uIiwianNIZWxwZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fbG9hZEpTIiwiYXBwbHlBY3Rpb25Db2RlIiwic2VuZEVtYWlsVmVyaWZpY2F0aW9uIiwic2VuZFBhc3N3b3JkUmVzZXRFbWFpbCIsInNlbmRTaWduSW5MaW5rVG9FbWFpbCIsInNpZ25JbldpdGhFbWFpbExpbmsiLCJJRFBfUkVRVUVTVF9VUkkiLCJzaWduSW5XaXRoUGhvbmVOdW1iZXIiLCJsaW5rV2l0aFBob25lTnVtYmVyIiwiX2xpbmsiLCJzaWduSW5XaXRoQ3VzdG9tVG9rZW4iLCJnZXRJZFRva2VuUmVzcG9uc2UiLCJhdXRoZW50aWNhdGlvbi5zZW5kUGFzc3dvcmRSZXNldEVtYWlsIiwiYXV0aGVudGljYXRpb25cclxuICAgICAgICAgICAgLnNlbmRQYXNzd29yZFJlc2V0RW1haWwiLCJhY2NvdW50LnJlc2V0UGFzc3dvcmQiLCJhY2NvdW50LmFwcGx5QWN0aW9uQ29kZSIsImFwaS5zZW5kU2lnbkluTGlua1RvRW1haWwiLCJhcGlcclxuICAgICAgICAgICAgLnNlbmRTaWduSW5MaW5rVG9FbWFpbCIsImFwaS5zZW5kRW1haWxWZXJpZmljYXRpb24iLCJhcGkudmVyaWZ5QW5kQ2hhbmdlRW1haWwiLCJ1cGRhdGVQcm9maWxlIiwiYXBpVXBkYXRlUHJvZmlsZSIsImFwaVVwZGF0ZUVtYWlsUGFzc3dvcmQiLCJfUE9MTElOR19JTlRFUlZBTF9NUyIsImpzSGVscGVycy5fZ2VuZXJhdGVDYWxsYmFja05hbWUiLCJqc0hlbHBlcnMuX2xvYWRKUyIsIl9saW5rVXNlciIsImpzLl9nZW5lcmF0ZUNhbGxiYWNrTmFtZSIsImpzXHJcbiAgICAgICAgICAgICAgICAuX2xvYWRKUyIsImdhcGlMb2FkZXIuX2xvYWRHYXBpIl0sInNvdXJjZVJvb3QiOiIifQ==